/*!
 * ONNX Runtime Web v1.18.0
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
"use strict";var ort=(()=>{var Dl=Object.create;var Ne=Object.defineProperty;var Ll=Object.getOwnPropertyDescriptor;var $l=Object.getOwnPropertyNames;var kl=Object.getPrototypeOf,Bl=Object.prototype.hasOwnProperty;var x=(a,e)=>()=>(a&&(e=a(a=0)),e);var Z=(a,e)=>()=>(e||a((e={exports:{}}).exports,e),e.exports),Br=(a,e)=>{for(var o in e)Ne(a,o,{get:e[o],enumerable:!0})},qn=(a,e,o,t)=>{if(e&&typeof e=="object"||typeof e=="function")for(let n of $l(e))!Bl.call(a,n)&&n!==o&&Ne(a,n,{get:()=>e[n],enumerable:!(t=Ll(e,n))||t.enumerable});return a};var ne=(a,e,o)=>(o=a!=null?Dl(kl(a)):{},qn(e||!a||!a.__esModule?Ne(o,"default",{value:a,enumerable:!0}):o,a)),jn=a=>qn(Ne({},"__esModule",{value:!0}),a);var Ce,Ut,be,Fl,Ge,Re=x(()=>{"use strict";Ce=new Map,Ut=[],be=(a,e,o)=>{if(e&&typeof e.init=="function"&&typeof e.createInferenceSessionHandler=="function"){let t=Ce.get(a);if(t===void 0)Ce.set(a,{backend:e,priority:o});else{if(t.priority>o)return;if(t.priority===o&&t.backend!==e)throw new Error(`cannot register backend "${a}" using priority ${o}`)}if(o>=0){let n=Ut.indexOf(a);n!==-1&&Ut.splice(n,1);for(let r=0;r<Ut.length;r++)if(Ce.get(Ut[r]).priority<=o){Ut.splice(r,0,a);return}Ut.push(a)}return}throw new TypeError("not a valid backend")},Fl=async a=>{let e=Ce.get(a);if(!e)return"backend not found.";if(e.initialized)return e.backend;if(e.aborted)return e.error;{let o=!!e.initPromise;try{return o||(e.initPromise=e.backend.init(a)),await e.initPromise,e.initialized=!0,e.backend}catch(t){return o||(e.error=`${t}`,e.aborted=!0),e.error}finally{delete e.initPromise}}},Ge=async a=>{let e=a.executionProviders||[],o=e.map(u=>typeof u=="string"?u:u.name),t=o.length===0?Ut:o,n,r=[],s=new Set;for(let u of t){let l=await Fl(u);typeof l=="string"?r.push({name:u,err:l}):(n||(n=l),n===l&&s.add(u))}if(!n)throw new Error(`no available backend found. ERR: ${r.map(u=>`[${u.name}] ${u.err}`).join(", ")}`);for(let{name:u,err:l}of r)o.includes(u)&&console.warn(`removing requested execution provider "${u}" from session options because it is not available: ${l}`);let i=e.filter(u=>s.has(typeof u=="string"?u:u.name));return[n,new Proxy(a,{get:(u,l)=>l==="executionProviders"?i:Reflect.get(u,l)})]}});var Kn=x(()=>{"use strict";Re()});var Xn,Jn=x(()=>{"use strict";Xn="1.18.0"});var Zn,ct,Fr=x(()=>{"use strict";Jn();Zn="warning",ct={wasm:{},webgl:{},webgpu:{},versions:{common:Xn},set logLevel(a){if(a!==void 0){if(typeof a!="string"||["verbose","info","warning","error","fatal"].indexOf(a)===-1)throw new Error(`Unsupported logging level: ${a}`);Zn=a}},get logLevel(){return Zn}};Object.defineProperty(ct,"logLevel",{enumerable:!0})});var j,Yn=x(()=>{"use strict";Fr();j=ct});var Qn,to,eo=x(()=>{"use strict";Qn=(a,e)=>{let o=typeof document<"u"?document.createElement("canvas"):new OffscreenCanvas(1,1);o.width=a.dims[3],o.height=a.dims[2];let t=o.getContext("2d");if(t!=null){let n,r;e?.tensorLayout!==void 0&&e.tensorLayout==="NHWC"?(n=a.dims[2],r=a.dims[3]):(n=a.dims[3],r=a.dims[2]);let s=e?.format!==void 0?e.format:"RGB",i=e?.norm,u,l;i===void 0||i.mean===void 0?u=[255,255,255,255]:typeof i.mean=="number"?u=[i.mean,i.mean,i.mean,i.mean]:(u=[i.mean[0],i.mean[1],i.mean[2],0],i.mean[3]!==void 0&&(u[3]=i.mean[3])),i===void 0||i.bias===void 0?l=[0,0,0,0]:typeof i.bias=="number"?l=[i.bias,i.bias,i.bias,i.bias]:(l=[i.bias[0],i.bias[1],i.bias[2],0],i.bias[3]!==void 0&&(l[3]=i.bias[3]));let f=r*n,p=0,d=f,b=f*2,g=-1;s==="RGBA"?(p=0,d=f,b=f*2,g=f*3):s==="RGB"?(p=0,d=f,b=f*2):s==="RBG"&&(p=0,b=f,d=f*2);for(let y=0;y<r;y++)for(let v=0;v<n;v++){let _=(a.data[p++]-l[0])*u[0],A=(a.data[d++]-l[1])*u[1],S=(a.data[b++]-l[2])*u[2],C=g===-1?255:(a.data[g++]-l[3])*u[3];t.fillStyle="rgba("+_+","+A+","+S+","+C+")",t.fillRect(v,y,1,1)}if("toDataURL"in o)return o.toDataURL();throw new Error("toDataURL is not supported")}else throw new Error("Can not access image data")},to=(a,e)=>{let o=typeof document<"u"?document.createElement("canvas").getContext("2d"):new OffscreenCanvas(1,1).getContext("2d"),t;if(o!=null){let n,r,s;e?.tensorLayout!==void 0&&e.tensorLayout==="NHWC"?(n=a.dims[2],r=a.dims[1],s=a.dims[3]):(n=a.dims[3],r=a.dims[2],s=a.dims[1]);let i=e!==void 0&&e.format!==void 0?e.format:"RGB",u=e?.norm,l,f;u===void 0||u.mean===void 0?l=[255,255,255,255]:typeof u.mean=="number"?l=[u.mean,u.mean,u.mean,u.mean]:(l=[u.mean[0],u.mean[1],u.mean[2],255],u.mean[3]!==void 0&&(l[3]=u.mean[3])),u===void 0||u.bias===void 0?f=[0,0,0,0]:typeof u.bias=="number"?f=[u.bias,u.bias,u.bias,u.bias]:(f=[u.bias[0],u.bias[1],u.bias[2],0],u.bias[3]!==void 0&&(f[3]=u.bias[3]));let p=r*n;if(e!==void 0&&(e.format!==void 0&&s===4&&e.format!=="RGBA"||s===3&&e.format!=="RGB"&&e.format!=="BGR"))throw new Error("Tensor format doesn't match input tensor dims");let d=4,b=0,g=1,y=2,v=3,_=0,A=p,S=p*2,C=-1;i==="RGBA"?(_=0,A=p,S=p*2,C=p*3):i==="RGB"?(_=0,A=p,S=p*2):i==="RBG"&&(_=0,S=p,A=p*2),t=o.createImageData(n,r);for(let F=0;F<r*n;b+=d,g+=d,y+=d,v+=d,F++)t.data[b]=(a.data[_++]-f[0])*l[0],t.data[g]=(a.data[A++]-f[1])*l[1],t.data[y]=(a.data[S++]-f[2])*l[2],t.data[v]=C===-1?255:(a.data[C++]-f[3])*l[3]}else throw new Error("Can not access image data");return t}});var Nr,ro,no,oo,io,ao=x(()=>{"use strict";Ve();Nr=(a,e)=>{if(a===void 0)throw new Error("Image buffer must be defined");if(e.height===void 0||e.width===void 0)throw new Error("Image height and width must be defined");if(e.tensorLayout==="NHWC")throw new Error("NHWC Tensor layout is not supported yet");let{height:o,width:t}=e,n=e.norm??{mean:255,bias:0},r,s;typeof n.mean=="number"?r=[n.mean,n.mean,n.mean,n.mean]:r=[n.mean[0],n.mean[1],n.mean[2],n.mean[3]??255],typeof n.bias=="number"?s=[n.bias,n.bias,n.bias,n.bias]:s=[n.bias[0],n.bias[1],n.bias[2],n.bias[3]??0];let i=e.format!==void 0?e.format:"RGBA",u=e.tensorFormat!==void 0&&e.tensorFormat!==void 0?e.tensorFormat:"RGB",l=o*t,f=u==="RGBA"?new Float32Array(l*4):new Float32Array(l*3),p=4,d=0,b=1,g=2,y=3,v=0,_=l,A=l*2,S=-1;i==="RGB"&&(p=3,d=0,b=1,g=2,y=-1),u==="RGBA"?S=l*3:u==="RBG"?(v=0,A=l,_=l*2):u==="BGR"&&(A=0,_=l,v=l*2);for(let F=0;F<l;F++,d+=p,g+=p,b+=p,y+=p)f[v++]=(a[d]+s[0])/r[0],f[_++]=(a[b]+s[1])/r[1],f[A++]=(a[g]+s[2])/r[2],S!==-1&&y!==-1&&(f[S++]=(a[y]+s[3])/r[3]);return u==="RGBA"?new ot("float32",f,[1,4,o,t]):new ot("float32",f,[1,3,o,t])},ro=async(a,e)=>{let o=typeof HTMLImageElement<"u"&&a instanceof HTMLImageElement,t=typeof ImageData<"u"&&a instanceof ImageData,n=typeof ImageBitmap<"u"&&a instanceof ImageBitmap,r=typeof a=="string",s,i=e??{},u=()=>{if(typeof document<"u")return document.createElement("canvas");if(typeof OffscreenCanvas<"u")return new OffscreenCanvas(1,1);throw new Error("Canvas is not supported")},l=f=>f instanceof HTMLCanvasElement||f instanceof OffscreenCanvas?f.getContext("2d"):null;if(o){let f=u();f.width=a.width,f.height=a.height;let p=l(f);if(p!=null){let d=a.height,b=a.width;if(e!==void 0&&e.resizedHeight!==void 0&&e.resizedWidth!==void 0&&(d=e.resizedHeight,b=e.resizedWidth),e!==void 0){if(i=e,e.tensorFormat!==void 0)throw new Error("Image input config format must be RGBA for HTMLImageElement");i.tensorFormat="RGBA",i.height=d,i.width=b}else i.tensorFormat="RGBA",i.height=d,i.width=b;p.drawImage(a,0,0),s=p.getImageData(0,0,b,d).data}else throw new Error("Can not access image data")}else if(t){let f,p;if(e!==void 0&&e.resizedWidth!==void 0&&e.resizedHeight!==void 0?(f=e.resizedHeight,p=e.resizedWidth):(f=a.height,p=a.width),e!==void 0&&(i=e),i.format="RGBA",i.height=f,i.width=p,e!==void 0){let d=u();d.width=p,d.height=f;let b=l(d);if(b!=null)b.putImageData(a,0,0),s=b.getImageData(0,0,p,f).data;else throw new Error("Can not access image data")}else s=a.data}else if(n){if(e===void 0)throw new Error("Please provide image config with format for Imagebitmap");let f=u();f.width=a.width,f.height=a.height;let p=l(f);if(p!=null){let d=a.height,b=a.width;return p.drawImage(a,0,0,b,d),s=p.getImageData(0,0,b,d).data,i.height=d,i.width=b,Nr(s,i)}else throw new Error("Can not access image data")}else{if(r)return new Promise((f,p)=>{let d=u(),b=l(d);if(!a||!b)return p();let g=new Image;g.crossOrigin="Anonymous",g.src=a,g.onload=()=>{d.width=g.width,d.height=g.height,b.drawImage(g,0,0,d.width,d.height);let y=b.getImageData(0,0,d.width,d.height);i.height=d.height,i.width=d.width,f(Nr(y.data,i))}});throw new Error("Input data provided is not supported - aborted tensor creation")}if(s!==void 0)return Nr(s,i);throw new Error("Input data provided is not supported - aborted tensor creation")},no=(a,e)=>{let{width:o,height:t,download:n,dispose:r}=e,s=[1,t,o,4];return new ot({location:"texture",type:"float32",texture:a,dims:s,download:n,dispose:r})},oo=(a,e)=>{let{dataType:o,dims:t,download:n,dispose:r}=e;return new ot({location:"gpu-buffer",type:o??"float32",gpuBuffer:a,dims:t,download:n,dispose:r})},io=(a,e,o)=>new ot({location:"cpu-pinned",type:a,data:e,dims:o??[e.length]})});var Wt,ye,so,uo,lo=x(()=>{"use strict";Wt=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array]]),ye=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]),so=!1,uo=()=>{if(!so){so=!0;let a=typeof BigInt64Array<"u"&&BigInt64Array.from,e=typeof BigUint64Array<"u"&&BigUint64Array.from,o=typeof Float16Array<"u"&&Float16Array.from;a&&(Wt.set("int64",BigInt64Array),ye.set(BigInt64Array,"int64")),e&&(Wt.set("uint64",BigUint64Array),ye.set(BigUint64Array,"uint64")),o?(Wt.set("float16",Float16Array),ye.set(Float16Array,"float16")):Wt.set("float16",Uint16Array)}}});var fo,co,po=x(()=>{"use strict";Ve();fo=a=>{let e=1;for(let o=0;o<a.length;o++){let t=a[o];if(typeof t!="number"||!Number.isSafeInteger(t))throw new TypeError(`dims[${o}] must be an integer, got: ${t}`);if(t<0)throw new RangeError(`dims[${o}] must be a non-negative integer, got: ${t}`);e*=t}return e},co=(a,e)=>{switch(a.location){case"cpu":return new ot(a.type,a.data,e);case"cpu-pinned":return new ot({location:"cpu-pinned",data:a.data,type:a.type,dims:e});case"texture":return new ot({location:"texture",texture:a.texture,type:a.type,dims:e});case"gpu-buffer":return new ot({location:"gpu-buffer",gpuBuffer:a.gpuBuffer,type:a.type,dims:e});default:throw new Error(`tensorReshape: tensor location ${a.location} is not supported`)}}});var ot,Ve=x(()=>{"use strict";eo();ao();lo();po();ot=class{constructor(e,o,t){uo();let n,r;if(typeof e=="object"&&"location"in e)switch(this.dataLocation=e.location,n=e.type,r=e.dims,e.location){case"cpu-pinned":{let i=Wt.get(n);if(!i)throw new TypeError(`unsupported type "${n}" to create tensor from pinned buffer`);if(!(e.data instanceof i))throw new TypeError(`buffer should be of type ${i.name}`);this.cpuData=e.data;break}case"texture":{if(n!=="float32")throw new TypeError(`unsupported type "${n}" to create tensor from texture`);this.gpuTextureData=e.texture,this.downloader=e.download,this.disposer=e.dispose;break}case"gpu-buffer":{if(n!=="float32"&&n!=="float16"&&n!=="int32"&&n!=="int64"&&n!=="uint32"&&n!=="uint8"&&n!=="bool")throw new TypeError(`unsupported type "${n}" to create tensor from gpu buffer`);this.gpuBufferData=e.gpuBuffer,this.downloader=e.download,this.disposer=e.dispose;break}default:throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`)}else{let i,u;if(typeof e=="string")if(n=e,u=t,e==="string"){if(!Array.isArray(o))throw new TypeError("A string tensor's data must be a string array.");i=o}else{let l=Wt.get(e);if(l===void 0)throw new TypeError(`Unsupported tensor type: ${e}.`);if(Array.isArray(o)){if(e==="float16"&&l===Uint16Array)throw new TypeError("Creating a float16 tensor from number array is not supported. Please use Uint16Array as data.");e==="uint64"||e==="int64"?i=l.from(o,BigInt):i=l.from(o)}else if(o instanceof l)i=o;else throw new TypeError(`A ${n} tensor's data must be type of ${l}`)}else if(u=o,Array.isArray(e)){if(e.length===0)throw new TypeError("Tensor type cannot be inferred from an empty array.");let l=typeof e[0];if(l==="string")n="string",i=e;else if(l==="boolean")n="bool",i=Uint8Array.from(e);else throw new TypeError(`Invalid element type of data array: ${l}.`)}else{let l=ye.get(e.constructor);if(l===void 0)throw new TypeError(`Unsupported type for tensor data: ${e.constructor}.`);n=l,i=e}if(u===void 0)u=[i.length];else if(!Array.isArray(u))throw new TypeError("A tensor's dims must be a number array");r=u,this.cpuData=i,this.dataLocation="cpu"}let s=fo(r);if(this.cpuData&&s!==this.cpuData.length)throw new Error(`Tensor's size(${s}) does not match data length(${this.cpuData.length}).`);this.type=n,this.dims=r,this.size=s}static async fromImage(e,o){return ro(e,o)}static fromTexture(e,o){return no(e,o)}static fromGpuBuffer(e,o){return oo(e,o)}static fromPinnedBuffer(e,o,t){return io(e,o,t)}toDataURL(e){return Qn(this,e)}toImageData(e){return to(this,e)}get data(){if(this.ensureValid(),!this.cpuData)throw new Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");return this.cpuData}get location(){return this.dataLocation}get texture(){if(this.ensureValid(),!this.gpuTextureData)throw new Error("The data is not stored as a WebGL texture.");return this.gpuTextureData}get gpuBuffer(){if(this.ensureValid(),!this.gpuBufferData)throw new Error("The data is not stored as a WebGPU buffer.");return this.gpuBufferData}async getData(e){switch(this.ensureValid(),this.dataLocation){case"cpu":case"cpu-pinned":return this.data;case"texture":case"gpu-buffer":{if(!this.downloader)throw new Error("The current tensor is not created with a specified data downloader.");if(this.isDownloading)throw new Error("The current tensor is being downloaded.");try{this.isDownloading=!0;let o=await this.downloader();return this.downloader=void 0,this.dataLocation="cpu",this.cpuData=o,e&&this.disposer&&(this.disposer(),this.disposer=void 0),o}finally{this.isDownloading=!1}}default:throw new Error(`cannot get data from location: ${this.dataLocation}`)}}dispose(){if(this.isDownloading)throw new Error("The current tensor is being downloaded.");this.disposer&&(this.disposer(),this.disposer=void 0),this.cpuData=void 0,this.gpuTextureData=void 0,this.gpuBufferData=void 0,this.downloader=void 0,this.isDownloading=void 0,this.dataLocation="none"}ensureValid(){if(this.dataLocation==="none")throw new Error("The tensor is disposed.")}reshape(e){if(this.ensureValid(),this.downloader||this.disposer)throw new Error("Cannot reshape a tensor that owns GPU resource.");return co(this,e)}}});var rt,ze=x(()=>{"use strict";Ve();rt=ot});var Cr,ho,ge,xe,Gr=x(()=>{"use strict";Fr();Cr=(a,e)=>{(typeof ct.trace>"u"?!ct.wasm.trace:!ct.trace)||console.timeStamp(`${a}::ORT::${e}`)},ho=(a,e)=>{let o=new Error().stack?.split(/\r\n|\r|\n/g)||[],t=!1;for(let n=0;n<o.length;n++){if(t&&!o[n].includes("TRACE_FUNC")){let r=`FUNC_${a}::${o[n].trim().split(" ")[1]}`;e&&(r+=`::${e}`),Cr("CPU",r);return}o[n].includes("TRACE_FUNC")&&(t=!0)}},ge=a=>{(typeof ct.trace>"u"?!ct.wasm.trace:!ct.trace)||ho("BEGIN",a)},xe=a=>{(typeof ct.trace>"u"?!ct.wasm.trace:!ct.trace)||ho("END",a)}});var Me,mo=x(()=>{"use strict";Re();ze();Gr();Me=class a{constructor(e){this.handler=e}async run(e,o,t){ge();let n={},r={};if(typeof e!="object"||e===null||e instanceof rt||Array.isArray(e))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let s=!0;if(typeof o=="object"){if(o===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(o instanceof rt)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(o)){if(o.length===0)throw new TypeError("'fetches' cannot be an empty array.");s=!1;for(let l of o){if(typeof l!="string")throw new TypeError("'fetches' must be a string array or an object.");if(this.outputNames.indexOf(l)===-1)throw new RangeError(`'fetches' contains invalid output name: ${l}.`);n[l]=null}if(typeof t=="object"&&t!==null)r=t;else if(typeof t<"u")throw new TypeError("'options' must be an object.")}else{let l=!1,f=Object.getOwnPropertyNames(o);for(let p of this.outputNames)if(f.indexOf(p)!==-1){let d=o[p];(d===null||d instanceof rt)&&(l=!0,s=!1,n[p]=d)}if(l){if(typeof t=="object"&&t!==null)r=t;else if(typeof t<"u")throw new TypeError("'options' must be an object.")}else r=o}}else if(typeof o<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let l of this.inputNames)if(typeof e[l]>"u")throw new Error(`input '${l}' is missing in 'feeds'.`);if(s)for(let l of this.outputNames)n[l]=null;let i=await this.handler.run(e,n,r),u={};for(let l in i)if(Object.hasOwnProperty.call(i,l)){let f=i[l];f instanceof rt?u[l]=f:u[l]=new rt(f.type,f.data,f.dims)}return xe(),u}async release(){return this.handler.dispose()}static async create(e,o,t,n){ge();let r,s={};if(typeof e=="string"){if(r=e,typeof o=="object"&&o!==null)s=o;else if(typeof o<"u")throw new TypeError("'options' must be an object.")}else if(e instanceof Uint8Array){if(r=e,typeof o=="object"&&o!==null)s=o;else if(typeof o<"u")throw new TypeError("'options' must be an object.")}else if(e instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&e instanceof SharedArrayBuffer){let f=e,p=0,d=e.byteLength;if(typeof o=="object"&&o!==null)s=o;else if(typeof o=="number"){if(p=o,!Number.isSafeInteger(p))throw new RangeError("'byteOffset' must be an integer.");if(p<0||p>=f.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${f.byteLength}).`);if(d=e.byteLength-p,typeof t=="number"){if(d=t,!Number.isSafeInteger(d))throw new RangeError("'byteLength' must be an integer.");if(d<=0||p+d>f.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${f.byteLength-p}].`);if(typeof n=="object"&&n!==null)s=n;else if(typeof n<"u")throw new TypeError("'options' must be an object.")}else if(typeof t<"u")throw new TypeError("'byteLength' must be a number.")}else if(typeof o<"u")throw new TypeError("'options' must be an object.");r=new Uint8Array(f,p,d)}else throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");let[i,u]=await Ge(s),l=await i.createInferenceSessionHandler(r,u);return xe(),new a(l)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}}});var bo,yo=x(()=>{"use strict";mo();bo=Me});var go=x(()=>{"use strict"});var xo=x(()=>{"use strict"});var To=x(()=>{"use strict"});var vo=x(()=>{"use strict"});var Nl,Ue,wo=x(()=>{"use strict";Re();ze();Nl="Training backend could not be resolved. Make sure you're using the correct configuration & WebAssembly files.",Ue=class a{constructor(e,o,t){this.handler=e,this.hasOptimizerModel=o,this.hasEvalModel=t}get trainingInputNames(){return this.handler.inputNames}get trainingOutputNames(){return this.handler.outputNames}get evalInputNames(){if(this.hasEvalModel)return this.handler.evalInputNames;throw new Error("This training session has no evalModel loaded.")}get evalOutputNames(){if(this.hasEvalModel)return this.handler.evalOutputNames;throw new Error("This training session has no evalModel loaded.")}static async create(e,o){let t=e.evalModel||"",n=e.optimizerModel||"",r=o||{},[s,i]=await Ge(r);if(s.createTrainingSessionHandler){let u=await s.createTrainingSessionHandler(e.checkpointState,e.trainModel,t,n,i);return new a(u,!!e.optimizerModel,!!e.evalModel)}else throw new Error(Nl)}typeNarrowingForRunStep(e,o,t,n,r){let s={},i={};if(typeof t!="object"||t===null||t instanceof rt||Array.isArray(t))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let u=!0;if(typeof n=="object"){if(n===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(n instanceof rt)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(n)){if(n.length===0)throw new TypeError("'fetches' cannot be an empty array.");u=!1;for(let l of n){if(typeof l!="string")throw new TypeError("'fetches' must be a string array or an object.");if(o.indexOf(l)===-1)throw new RangeError(`'fetches' contains invalid output name: ${l}.`);s[l]=null}if(typeof r=="object"&&r!==null)i=r;else if(typeof r<"u")throw new TypeError("'options' must be an object.")}else{let l=!1,f=Object.getOwnPropertyNames(n);for(let p of o)if(f.indexOf(p)!==-1){let d=n[p];(d===null||d instanceof rt)&&(l=!0,u=!1,s[p]=d)}if(l){if(typeof r=="object"&&r!==null)i=r;else if(typeof r<"u")throw new TypeError("'options' must be an object.")}else i=n}}else if(typeof n<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let l of e)if(typeof t[l]>"u")throw new Error(`input '${l}' is missing in 'feeds'.`);if(u)for(let l of o)s[l]=null;return[s,i]}convertHandlerReturnTypeToMapOfTensors(e){let o={};for(let t in e)if(Object.hasOwnProperty.call(e,t)){let n=e[t];n instanceof rt?o[t]=n:o[t]=new rt(n.type,n.data,n.dims)}return o}async lazyResetGrad(){await this.handler.lazyResetGrad()}async runTrainStep(e,o,t){let[n,r]=this.typeNarrowingForRunStep(this.trainingInputNames,this.trainingOutputNames,e,o,t),s=await this.handler.runTrainStep(e,n,r);return this.convertHandlerReturnTypeToMapOfTensors(s)}async runOptimizerStep(e){if(this.hasOptimizerModel)await this.handler.runOptimizerStep(e||{});else throw new Error("This TrainingSession has no OptimizerModel loaded.")}async runEvalStep(e,o,t){if(this.hasEvalModel){let[n,r]=this.typeNarrowingForRunStep(this.evalInputNames,this.evalOutputNames,e,o,t),s=await this.handler.runEvalStep(e,n,r);return this.convertHandlerReturnTypeToMapOfTensors(s)}else throw new Error("This TrainingSession has no EvalModel loaded.")}async getParametersSize(e=!0){return this.handler.getParametersSize(e)}async loadParametersBuffer(e,o=!0){let t=await this.getParametersSize(o);if(e.length!==4*t)throw new Error("Size of the buffer passed into loadParametersBuffer must match the number of parameters in the model. Please use getParametersSize method to check.");return this.handler.loadParametersBuffer(e,o)}async getContiguousParameters(e=!0){return this.handler.getContiguousParameters(e)}async release(){return this.handler.dispose()}}});var Io,_o=x(()=>{"use strict";wo();Io=Ue});var Rr={};Br(Rr,{InferenceSession:()=>bo,TRACE:()=>Cr,TRACE_FUNC_BEGIN:()=>ge,TRACE_FUNC_END:()=>xe,Tensor:()=>rt,TrainingSession:()=>Io,env:()=>j,registerBackend:()=>be});var Ft=x(()=>{"use strict";Kn();Yn();yo();ze();go();xo();Gr();To();vo();_o()});function Nt(a,e,o,t){if(e===void 0)return Gl(a);if(o===void 0)We(a,e,1);else if(typeof o=="number"&&t===void 0)We(a,e,o);else if(typeof o=="string"&&t===void 0)We(a,o,1,e);else if(typeof o=="string"&&typeof t=="number")We(a,o,t,e);else throw new TypeError("input is valid")}function Gl(a){return{verbose:Nt.verbose.bind(null,a),info:Nt.info.bind(null,a),warning:Nt.warning.bind(null,a),error:Nt.error.bind(null,a),fatal:Nt.fatal.bind(null,a)}}function We(a,e,o,t){let n=Te[t||""]||Te[""];Ao[a]<Ao[n.minimalSeverity]||(n.logDateTime&&(e=`${new Date().toISOString()}|${e}`),n.logSourceLocation,Cl[n.provider].log(a,e,t))}var Vr,zr,Ao,Cl,Oo,Te,M,qe,je,Ke,He,pt=x(()=>{"use strict";Vr=class{log(e,o,t){}},zr=class{log(e,o,t){console.log(`${this.color(e)} ${t?"\x1B[35m"+t+"\x1B[0m ":""}${o}`)}color(e){switch(e){case"verbose":return"\x1B[34;40mv\x1B[0m";case"info":return"\x1B[32mi\x1B[0m";case"warning":return"\x1B[30;43mw\x1B[0m";case"error":return"\x1B[31;40me\x1B[0m";case"fatal":return"\x1B[101mf\x1B[0m";default:throw new Error(`unsupported severity: ${e}`)}}},Ao={verbose:1e3,info:2e3,warning:4e3,error:5e3,fatal:6e3},Cl={none:new Vr,console:new zr},Oo={provider:"console",minimalSeverity:"warning",logDateTime:!0,logSourceLocation:!1},Te={"":Oo};(u=>{function a(l,f){u("verbose",l,f)}u.verbose=a;function e(l,f){u("info",l,f)}u.info=e;function o(l,f){u("warning",l,f)}u.warning=o;function t(l,f){u("error",l,f)}u.error=t;function n(l,f){u("fatal",l,f)}u.fatal=n;function r(l){Te={},s("",l||{})}u.reset=r;function s(l,f){if(l==="*")r(f);else{let p=Te[l]||Oo;Te[l]={provider:f.provider||p.provider,minimalSeverity:f.minimalSeverity||p.minimalSeverity,logDateTime:f.logDateTime===void 0?p.logDateTime:f.logDateTime,logSourceLocation:f.logSourceLocation===void 0?p.logSourceLocation:f.logSourceLocation}}}u.set=s;function i(l){let f={};l.logLevel&&(f.minimalSeverity=l.logLevel),s("",f)}u.setWithEnv=i})(Nt||={});M=Nt,qe=class{constructor(e,o,t,n,r,s){this.category=e;this.name=o;this.startTime=t;this.endCallback=n;this.timer=r;this.ctx=s}async end(){return this.endCallback(this)}async checkTimer(){if(this.ctx===void 0||this.timer===void 0)throw new Error("No webgl timer found");return this.ctx.endTimer(),this.ctx.waitForQueryAndGetTime(this.timer)}},je=class{constructor(e,o,t,n){this.category=e;this.name=o;this.startTime=t;this.endTime=n}},Ke=class{constructor(e,o,t){this._started=!1;this._flushPointer=0;this._started=!1,this._maxNumberEvents=e===void 0?1e4:e,this._flushBatchSize=o===void 0?10:o,this._flushIntervalInMilliseconds=t===void 0?5e3:t}static create(e){return e===void 0?new this:new this(e.maxNumberEvents,e.flushBatchSize,e.flushIntervalInMilliseconds)}start(){this._started=!0,this._timingEvents=[],this._flushTime=He(),this._flushPointer=0}stop(){for(this._started=!1;this._flushPointer<this._timingEvents.length;this._flushPointer++)this.logOneEvent(this._timingEvents[this._flushPointer])}event(e,o,t,n){let r=this._started?this.begin(e,o,n):void 0,s=!1,i=t();if(i&&typeof i.then=="function")return s=!0,new Promise((u,l)=>{i.then(async f=>{r&&await r.end(),u(f)},async f=>{r&&await r.end(),l(f)})});if(!s&&r){let u=r.end();if(u&&typeof u.then=="function")return new Promise((l,f)=>{u.then(()=>{l(i)},p=>{f(p)})})}return i}begin(e,o,t){if(!this._started)throw new Error("profiler is not started yet");if(t===void 0){let n=He();return this.flush(n),new qe(e,o,n,r=>this.endSync(r))}else{let n=t.beginTimer();return new qe(e,o,0,async r=>this.end(r),n,t)}}async end(e){let o=await e.checkTimer();this._timingEvents.length<this._maxNumberEvents&&(this._timingEvents.push(new je(e.category,e.name,e.startTime,o)),this.flush(o))}endSync(e){let o=He();this._timingEvents.length<this._maxNumberEvents&&(this._timingEvents.push(new je(e.category,e.name,e.startTime,o)),this.flush(o))}logOneEvent(e){M.verbose(`Profiler.${e.category}`,`${(e.endTime-e.startTime).toFixed(2)}ms on event '${e.name}' at ${e.endTime.toFixed(2)}`)}flush(e){if(this._timingEvents.length-this._flushPointer>=this._flushBatchSize||e-this._flushTime>=this._flushIntervalInMilliseconds){for(let o=this._flushPointer;this._flushPointer<o+this._flushBatchSize&&this._flushPointer<this._timingEvents.length;this._flushPointer++)this.logOneEvent(this._timingEvents[this._flushPointer]);this._flushTime=He()}}get started(){return this._started}},He=typeof performance<"u"&&performance.now?()=>performance.now():Date.now});function Po(a,e,o){for(let t of o){let n=t[0],r=t[1],s=t[2],i=t[3],u=t[4];if(a.opType===n){for(let l of e)if((l.domain===r||l.domain==="ai.onnx"&&r==="")&&Rl(l.version,s))return{opImpl:i,opInit:u}}}throw new TypeError(`cannot resolve operator '${a.opType}' with opsets: ${e.map(t=>`${t.domain||"ai.onnx"} v${t.version}`).join(", ")}`)}function Rl(a,e){if(e.endsWith("+")){let o=Number.parseInt(e.substring(0,e.length-1),10);return!isNaN(o)&&o<=a}else if(e.split("-").length===2){let o=e.split("-"),t=Number.parseInt(o[0],10),n=Number.parseInt(o[1],10);return!isNaN(t)&&!isNaN(n)&&t<=a&&a<=n}else return Number.parseInt(e,10)===a}var Eo=x(()=>{"use strict"});var Do=Z(Mr=>{"use strict";Mr.__esModule=!0;var Vl=function(){function a(e){if(!e)throw new TypeError("Invalid argument; `value` has no value.");this.value=a.EMPTY,e&&a.isGuid(e)&&(this.value=e)}return a.isGuid=function(e){var o=e.toString();return e&&(e instanceof a||a.validator.test(o))},a.create=function(){return new a([a.gen(2),a.gen(1),a.gen(1),a.gen(1),a.gen(3)].join("-"))},a.createEmpty=function(){return new a("emptyguid")},a.parse=function(e){return new a(e)},a.raw=function(){return[a.gen(2),a.gen(1),a.gen(1),a.gen(1),a.gen(3)].join("-")},a.gen=function(e){for(var o="",t=0;t<e;t++)o+=((1+Math.random())*65536|0).toString(16).substring(1);return o},a.prototype.equals=function(e){return a.isGuid(e)&&this.value===e.toString()},a.prototype.isEmpty=function(){return this.value===a.EMPTY},a.prototype.toString=function(){return this.value},a.prototype.toJSON=function(){return{value:this.value}},a.validator=new RegExp("^[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}$","i"),a.EMPTY="00000000-0000-0000-0000-000000000000",a}();Mr.Guid=Vl});function U(a,e,o){this.low=a|0,this.high=e|0,this.unsigned=!!o}function nt(a){return(a&&a.__isLong__)===!0}function Lo(a){var e=Math.clz32(a&-a);return a?31-e:e}function Ht(a,e){var o,t,n;return e?(a>>>=0,(n=0<=a&&a<256)&&(t=ko[a],t)?t:(o=V(a,0,!0),n&&(ko[a]=o),o)):(a|=0,(n=-128<=a&&a<128)&&(t=$o[a],t)?t:(o=V(a,a<0?-1:0,!1),n&&($o[a]=o),o))}function ht(a,e){if(isNaN(a))return e?$t:Tt;if(e){if(a<0)return $t;if(a>=Co)return Vo}else{if(a<=-Fo)return ut;if(a+1>=Fo)return Ro}return a<0?ht(-a,e).neg():V(a%ie|0,a/ie|0,e)}function V(a,e,o){return new U(a,e,o)}function Wr(a,e,o){if(a.length===0)throw Error("empty string");if(typeof e=="number"?(o=e,e=!1):e=!!e,a==="NaN"||a==="Infinity"||a==="+Infinity"||a==="-Infinity")return e?$t:Tt;if(o=o||10,o<2||36<o)throw RangeError("radix");var t;if((t=a.indexOf("-"))>0)throw Error("interior hyphen");if(t===0)return Wr(a.substring(1),e,o).neg();for(var n=ht(Xe(o,8)),r=Tt,s=0;s<a.length;s+=8){var i=Math.min(8,a.length-s),u=parseInt(a.substring(s,s+i),o);if(i<8){var l=ht(Xe(o,i));r=r.mul(l).add(ht(u))}else r=r.mul(n),r=r.add(ht(u))}return r.unsigned=e,r}function vt(a,e){return typeof a=="number"?ht(a,e):typeof a=="string"?Wr(a,e):V(a.low,a.high,typeof e=="boolean"?e:a.unsigned)}var dt,$o,ko,Xe,Bo,zl,ie,Co,Fo,No,Tt,$t,oe,Go,Ur,Ro,Vo,ut,T,kt,Hr=x(()=>{dt=null;try{dt=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}U.prototype.__isLong__;Object.defineProperty(U.prototype,"__isLong__",{value:!0});U.isLong=nt;$o={},ko={};U.fromInt=Ht;U.fromNumber=ht;U.fromBits=V;Xe=Math.pow;U.fromString=Wr;U.fromValue=vt;Bo=65536,zl=1<<24,ie=Bo*Bo,Co=ie*ie,Fo=Co/2,No=Ht(zl),Tt=Ht(0);U.ZERO=Tt;$t=Ht(0,!0);U.UZERO=$t;oe=Ht(1);U.ONE=oe;Go=Ht(1,!0);U.UONE=Go;Ur=Ht(-1);U.NEG_ONE=Ur;Ro=V(-1,2147483647,!1);U.MAX_VALUE=Ro;Vo=V(-1,-1,!0);U.MAX_UNSIGNED_VALUE=Vo;ut=V(0,-2147483648,!1);U.MIN_VALUE=ut;T=U.prototype;T.toInt=function(){return this.unsigned?this.low>>>0:this.low};T.toNumber=function(){return this.unsigned?(this.high>>>0)*ie+(this.low>>>0):this.high*ie+(this.low>>>0)};T.toString=function(e){if(e=e||10,e<2||36<e)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(ut)){var o=ht(e),t=this.div(o),n=t.mul(o).sub(this);return t.toString(e)+n.toInt().toString(e)}else return"-"+this.neg().toString(e);for(var r=ht(Xe(e,6),this.unsigned),s=this,i="";;){var u=s.div(r),l=s.sub(u.mul(r)).toInt()>>>0,f=l.toString(e);if(s=u,s.isZero())return f+i;for(;f.length<6;)f="0"+f;i=""+f+i}};T.getHighBits=function(){return this.high};T.getHighBitsUnsigned=function(){return this.high>>>0};T.getLowBits=function(){return this.low};T.getLowBitsUnsigned=function(){return this.low>>>0};T.getNumBitsAbs=function(){if(this.isNegative())return this.eq(ut)?64:this.neg().getNumBitsAbs();for(var e=this.high!=0?this.high:this.low,o=31;o>0&&!(e&1<<o);o--);return this.high!=0?o+33:o+1};T.isZero=function(){return this.high===0&&this.low===0};T.eqz=T.isZero;T.isNegative=function(){return!this.unsigned&&this.high<0};T.isPositive=function(){return this.unsigned||this.high>=0};T.isOdd=function(){return(this.low&1)===1};T.isEven=function(){return(this.low&1)===0};T.equals=function(e){return nt(e)||(e=vt(e)),this.unsigned!==e.unsigned&&this.high>>>31===1&&e.high>>>31===1?!1:this.high===e.high&&this.low===e.low};T.eq=T.equals;T.notEquals=function(e){return!this.eq(e)};T.neq=T.notEquals;T.ne=T.notEquals;T.lessThan=function(e){return this.comp(e)<0};T.lt=T.lessThan;T.lessThanOrEqual=function(e){return this.comp(e)<=0};T.lte=T.lessThanOrEqual;T.le=T.lessThanOrEqual;T.greaterThan=function(e){return this.comp(e)>0};T.gt=T.greaterThan;T.greaterThanOrEqual=function(e){return this.comp(e)>=0};T.gte=T.greaterThanOrEqual;T.ge=T.greaterThanOrEqual;T.compare=function(e){if(nt(e)||(e=vt(e)),this.eq(e))return 0;var o=this.isNegative(),t=e.isNegative();return o&&!t?-1:!o&&t?1:this.unsigned?e.high>>>0>this.high>>>0||e.high===this.high&&e.low>>>0>this.low>>>0?-1:1:this.sub(e).isNegative()?-1:1};T.comp=T.compare;T.negate=function(){return!this.unsigned&&this.eq(ut)?ut:this.not().add(oe)};T.neg=T.negate;T.add=function(e){nt(e)||(e=vt(e));var o=this.high>>>16,t=this.high&65535,n=this.low>>>16,r=this.low&65535,s=e.high>>>16,i=e.high&65535,u=e.low>>>16,l=e.low&65535,f=0,p=0,d=0,b=0;return b+=r+l,d+=b>>>16,b&=65535,d+=n+u,p+=d>>>16,d&=65535,p+=t+i,f+=p>>>16,p&=65535,f+=o+s,f&=65535,V(d<<16|b,f<<16|p,this.unsigned)};T.subtract=function(e){return nt(e)||(e=vt(e)),this.add(e.neg())};T.sub=T.subtract;T.multiply=function(e){if(this.isZero())return this;if(nt(e)||(e=vt(e)),dt){var o=dt.mul(this.low,this.high,e.low,e.high);return V(o,dt.get_high(),this.unsigned)}if(e.isZero())return this.unsigned?$t:Tt;if(this.eq(ut))return e.isOdd()?ut:Tt;if(e.eq(ut))return this.isOdd()?ut:Tt;if(this.isNegative())return e.isNegative()?this.neg().mul(e.neg()):this.neg().mul(e).neg();if(e.isNegative())return this.mul(e.neg()).neg();if(this.lt(No)&&e.lt(No))return ht(this.toNumber()*e.toNumber(),this.unsigned);var t=this.high>>>16,n=this.high&65535,r=this.low>>>16,s=this.low&65535,i=e.high>>>16,u=e.high&65535,l=e.low>>>16,f=e.low&65535,p=0,d=0,b=0,g=0;return g+=s*f,b+=g>>>16,g&=65535,b+=r*f,d+=b>>>16,b&=65535,b+=s*l,d+=b>>>16,b&=65535,d+=n*f,p+=d>>>16,d&=65535,d+=r*l,p+=d>>>16,d&=65535,d+=s*u,p+=d>>>16,d&=65535,p+=t*f+n*l+r*u+s*i,p&=65535,V(b<<16|g,p<<16|d,this.unsigned)};T.mul=T.multiply;T.divide=function(e){if(nt(e)||(e=vt(e)),e.isZero())throw Error("division by zero");if(dt){if(!this.unsigned&&this.high===-2147483648&&e.low===-1&&e.high===-1)return this;var o=(this.unsigned?dt.div_u:dt.div_s)(this.low,this.high,e.low,e.high);return V(o,dt.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?$t:Tt;var t,n,r;if(this.unsigned){if(e.unsigned||(e=e.toUnsigned()),e.gt(this))return $t;if(e.gt(this.shru(1)))return Go;r=$t}else{if(this.eq(ut)){if(e.eq(oe)||e.eq(Ur))return ut;if(e.eq(ut))return oe;var s=this.shr(1);return t=s.div(e).shl(1),t.eq(Tt)?e.isNegative()?oe:Ur:(n=this.sub(e.mul(t)),r=t.add(n.div(e)),r)}else if(e.eq(ut))return this.unsigned?$t:Tt;if(this.isNegative())return e.isNegative()?this.neg().div(e.neg()):this.neg().div(e).neg();if(e.isNegative())return this.div(e.neg()).neg();r=Tt}for(n=this;n.gte(e);){t=Math.max(1,Math.floor(n.toNumber()/e.toNumber()));for(var i=Math.ceil(Math.log(t)/Math.LN2),u=i<=48?1:Xe(2,i-48),l=ht(t),f=l.mul(e);f.isNegative()||f.gt(n);)t-=u,l=ht(t,this.unsigned),f=l.mul(e);l.isZero()&&(l=oe),r=r.add(l),n=n.sub(f)}return r};T.div=T.divide;T.modulo=function(e){if(nt(e)||(e=vt(e)),dt){var o=(this.unsigned?dt.rem_u:dt.rem_s)(this.low,this.high,e.low,e.high);return V(o,dt.get_high(),this.unsigned)}return this.sub(this.div(e).mul(e))};T.mod=T.modulo;T.rem=T.modulo;T.not=function(){return V(~this.low,~this.high,this.unsigned)};T.countLeadingZeros=function(){return this.high?Math.clz32(this.high):Math.clz32(this.low)+32};T.clz=T.countLeadingZeros;T.countTrailingZeros=function(){return this.low?Lo(this.low):Lo(this.high)+32};T.ctz=T.countTrailingZeros;T.and=function(e){return nt(e)||(e=vt(e)),V(this.low&e.low,this.high&e.high,this.unsigned)};T.or=function(e){return nt(e)||(e=vt(e)),V(this.low|e.low,this.high|e.high,this.unsigned)};T.xor=function(e){return nt(e)||(e=vt(e)),V(this.low^e.low,this.high^e.high,this.unsigned)};T.shiftLeft=function(e){return nt(e)&&(e=e.toInt()),(e&=63)===0?this:e<32?V(this.low<<e,this.high<<e|this.low>>>32-e,this.unsigned):V(0,this.low<<e-32,this.unsigned)};T.shl=T.shiftLeft;T.shiftRight=function(e){return nt(e)&&(e=e.toInt()),(e&=63)===0?this:e<32?V(this.low>>>e|this.high<<32-e,this.high>>e,this.unsigned):V(this.high>>e-32,this.high>=0?0:-1,this.unsigned)};T.shr=T.shiftRight;T.shiftRightUnsigned=function(e){return nt(e)&&(e=e.toInt()),(e&=63)===0?this:e<32?V(this.low>>>e|this.high<<32-e,this.high>>>e,this.unsigned):e===32?V(this.high,0,this.unsigned):V(this.high>>>e-32,0,this.unsigned)};T.shru=T.shiftRightUnsigned;T.shr_u=T.shiftRightUnsigned;T.rotateLeft=function(e){var o;return nt(e)&&(e=e.toInt()),(e&=63)===0?this:e===32?V(this.high,this.low,this.unsigned):e<32?(o=32-e,V(this.low<<e|this.high>>>o,this.high<<e|this.low>>>o,this.unsigned)):(e-=32,o=32-e,V(this.high<<e|this.low>>>o,this.low<<e|this.high>>>o,this.unsigned))};T.rotl=T.rotateLeft;T.rotateRight=function(e){var o;return nt(e)&&(e=e.toInt()),(e&=63)===0?this:e===32?V(this.high,this.low,this.unsigned):e<32?(o=32-e,V(this.high<<o|this.low>>>e,this.low<<o|this.high>>>e,this.unsigned)):(e-=32,o=32-e,V(this.low<<o|this.high>>>e,this.high<<o|this.low>>>e,this.unsigned))};T.rotr=T.rotateRight;T.toSigned=function(){return this.unsigned?V(this.low,this.high,!1):this};T.toUnsigned=function(){return this.unsigned?this:V(this.low,this.high,!0)};T.toBytes=function(e){return e?this.toBytesLE():this.toBytesBE()};T.toBytesLE=function(){var e=this.high,o=this.low;return[o&255,o>>>8&255,o>>>16&255,o>>>24,e&255,e>>>8&255,e>>>16&255,e>>>24]};T.toBytesBE=function(){var e=this.high,o=this.low;return[e>>>24,e>>>16&255,e>>>8&255,e&255,o>>>24,o>>>16&255,o>>>8&255,o&255]};U.fromBytes=function(e,o,t){return t?U.fromBytesLE(e,o):U.fromBytesBE(e,o)};U.fromBytesLE=function(e,o){return new U(e[0]|e[1]<<8|e[2]<<16|e[3]<<24,e[4]|e[5]<<8|e[6]<<16|e[7]<<24,o)};U.fromBytesBE=function(e,o){return new U(e[4]<<24|e[5]<<16|e[6]<<8|e[7],e[0]<<24|e[1]<<16|e[2]<<8|e[3],o)};kt=U});var m,Je=x(()=>{m={};m.Offset;m.Table;m.SIZEOF_SHORT=2;m.SIZEOF_INT=4;m.FILE_IDENTIFIER_LENGTH=4;m.SIZE_PREFIX_LENGTH=4;m.Encoding={UTF8_BYTES:1,UTF16_STRING:2};m.int32=new Int32Array(2);m.float32=new Float32Array(m.int32.buffer);m.float64=new Float64Array(m.int32.buffer);m.isLittleEndian=new Uint16Array(new Uint8Array([1,0]).buffer)[0]===1;m.Long=function(a,e){this.low=a|0,this.high=e|0};m.Long.create=function(a,e){return a==0&&e==0?m.Long.ZERO:new m.Long(a,e)};m.Long.prototype.toFloat64=function(){return(this.low>>>0)+this.high*4294967296};m.Long.prototype.equals=function(a){return this.low==a.low&&this.high==a.high};m.Long.ZERO=new m.Long(0,0);m.Builder=function(a){if(a)var e=a;else var e=1024;this.bb=m.ByteBuffer.allocate(e),this.space=e,this.minalign=1,this.vtable=null,this.vtable_in_use=0,this.isNested=!1,this.object_start=0,this.vtables=[],this.vector_num_elems=0,this.force_defaults=!1};m.Builder.prototype.clear=function(){this.bb.clear(),this.space=this.bb.capacity(),this.minalign=1,this.vtable=null,this.vtable_in_use=0,this.isNested=!1,this.object_start=0,this.vtables=[],this.vector_num_elems=0,this.force_defaults=!1};m.Builder.prototype.forceDefaults=function(a){this.force_defaults=a};m.Builder.prototype.dataBuffer=function(){return this.bb};m.Builder.prototype.asUint8Array=function(){return this.bb.bytes().subarray(this.bb.position(),this.bb.position()+this.offset())};m.Builder.prototype.prep=function(a,e){a>this.minalign&&(this.minalign=a);for(var o=~(this.bb.capacity()-this.space+e)+1&a-1;this.space<o+a+e;){var t=this.bb.capacity();this.bb=m.Builder.growByteBuffer(this.bb),this.space+=this.bb.capacity()-t}this.pad(o)};m.Builder.prototype.pad=function(a){for(var e=0;e<a;e++)this.bb.writeInt8(--this.space,0)};m.Builder.prototype.writeInt8=function(a){this.bb.writeInt8(this.space-=1,a)};m.Builder.prototype.writeInt16=function(a){this.bb.writeInt16(this.space-=2,a)};m.Builder.prototype.writeInt32=function(a){this.bb.writeInt32(this.space-=4,a)};m.Builder.prototype.writeInt64=function(a){this.bb.writeInt64(this.space-=8,a)};m.Builder.prototype.writeFloat32=function(a){this.bb.writeFloat32(this.space-=4,a)};m.Builder.prototype.writeFloat64=function(a){this.bb.writeFloat64(this.space-=8,a)};m.Builder.prototype.addInt8=function(a){this.prep(1,0),this.writeInt8(a)};m.Builder.prototype.addInt16=function(a){this.prep(2,0),this.writeInt16(a)};m.Builder.prototype.addInt32=function(a){this.prep(4,0),this.writeInt32(a)};m.Builder.prototype.addInt64=function(a){this.prep(8,0),this.writeInt64(a)};m.Builder.prototype.addFloat32=function(a){this.prep(4,0),this.writeFloat32(a)};m.Builder.prototype.addFloat64=function(a){this.prep(8,0),this.writeFloat64(a)};m.Builder.prototype.addFieldInt8=function(a,e,o){(this.force_defaults||e!=o)&&(this.addInt8(e),this.slot(a))};m.Builder.prototype.addFieldInt16=function(a,e,o){(this.force_defaults||e!=o)&&(this.addInt16(e),this.slot(a))};m.Builder.prototype.addFieldInt32=function(a,e,o){(this.force_defaults||e!=o)&&(this.addInt32(e),this.slot(a))};m.Builder.prototype.addFieldInt64=function(a,e,o){(this.force_defaults||!e.equals(o))&&(this.addInt64(e),this.slot(a))};m.Builder.prototype.addFieldFloat32=function(a,e,o){(this.force_defaults||e!=o)&&(this.addFloat32(e),this.slot(a))};m.Builder.prototype.addFieldFloat64=function(a,e,o){(this.force_defaults||e!=o)&&(this.addFloat64(e),this.slot(a))};m.Builder.prototype.addFieldOffset=function(a,e,o){(this.force_defaults||e!=o)&&(this.addOffset(e),this.slot(a))};m.Builder.prototype.addFieldStruct=function(a,e,o){e!=o&&(this.nested(e),this.slot(a))};m.Builder.prototype.nested=function(a){if(a!=this.offset())throw new Error("FlatBuffers: struct must be serialized inline.")};m.Builder.prototype.notNested=function(){if(this.isNested)throw new Error("FlatBuffers: object serialization must not be nested.")};m.Builder.prototype.slot=function(a){this.vtable[a]=this.offset()};m.Builder.prototype.offset=function(){return this.bb.capacity()-this.space};m.Builder.growByteBuffer=function(a){var e=a.capacity();if(e&3221225472)throw new Error("FlatBuffers: cannot grow buffer beyond 2 gigabytes.");var o=e<<1,t=m.ByteBuffer.allocate(o);return t.setPosition(o-e),t.bytes().set(a.bytes(),o-e),t};m.Builder.prototype.addOffset=function(a){this.prep(m.SIZEOF_INT,0),this.writeInt32(this.offset()-a+m.SIZEOF_INT)};m.Builder.prototype.startObject=function(a){this.notNested(),this.vtable==null&&(this.vtable=[]),this.vtable_in_use=a;for(var e=0;e<a;e++)this.vtable[e]=0;this.isNested=!0,this.object_start=this.offset()};m.Builder.prototype.endObject=function(){if(this.vtable==null||!this.isNested)throw new Error("FlatBuffers: endObject called without startObject");this.addInt32(0);for(var a=this.offset(),e=this.vtable_in_use-1;e>=0&&this.vtable[e]==0;e--);for(var o=e+1;e>=0;e--)this.addInt16(this.vtable[e]!=0?a-this.vtable[e]:0);var t=2;this.addInt16(a-this.object_start);var n=(o+t)*m.SIZEOF_SHORT;this.addInt16(n);var r=0,s=this.space;t:for(e=0;e<this.vtables.length;e++){var i=this.bb.capacity()-this.vtables[e];if(n==this.bb.readInt16(i)){for(var u=m.SIZEOF_SHORT;u<n;u+=m.SIZEOF_SHORT)if(this.bb.readInt16(s+u)!=this.bb.readInt16(i+u))continue t;r=this.vtables[e];break}}return r?(this.space=this.bb.capacity()-a,this.bb.writeInt32(this.space,r-a)):(this.vtables.push(this.offset()),this.bb.writeInt32(this.bb.capacity()-a,this.offset()-a)),this.isNested=!1,a};m.Builder.prototype.finish=function(a,e,o){var t=o?m.SIZE_PREFIX_LENGTH:0;if(e){var n=e;if(this.prep(this.minalign,m.SIZEOF_INT+m.FILE_IDENTIFIER_LENGTH+t),n.length!=m.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: file identifier must be length "+m.FILE_IDENTIFIER_LENGTH);for(var r=m.FILE_IDENTIFIER_LENGTH-1;r>=0;r--)this.writeInt8(n.charCodeAt(r))}this.prep(this.minalign,m.SIZEOF_INT+t),this.addOffset(a),t&&this.addInt32(this.bb.capacity()-this.space),this.bb.setPosition(this.space)};m.Builder.prototype.finishSizePrefixed=function(a,e){this.finish(a,e,!0)};m.Builder.prototype.requiredField=function(a,e){var o=this.bb.capacity()-a,t=o-this.bb.readInt32(o),n=this.bb.readInt16(t+e)!=0;if(!n)throw new Error("FlatBuffers: field "+e+" must be set")};m.Builder.prototype.startVector=function(a,e,o){this.notNested(),this.vector_num_elems=e,this.prep(m.SIZEOF_INT,a*e),this.prep(o,a*e)};m.Builder.prototype.endVector=function(){return this.writeInt32(this.vector_num_elems),this.offset()};m.Builder.prototype.createString=function(a){if(a instanceof Uint8Array)var e=a;else for(var e=[],o=0;o<a.length;){var t,n=a.charCodeAt(o++);if(n<55296||n>=56320)t=n;else{var r=a.charCodeAt(o++);t=(n<<10)+r+(65536-56623104-56320)}t<128?e.push(t):(t<2048?e.push(t>>6&31|192):(t<65536?e.push(t>>12&15|224):e.push(t>>18&7|240,t>>12&63|128),e.push(t>>6&63|128)),e.push(t&63|128))}this.addInt8(0),this.startVector(1,e.length,1),this.bb.setPosition(this.space-=e.length);for(var o=0,s=this.space,i=this.bb.bytes();o<e.length;o++)i[s++]=e[o];return this.endVector()};m.Builder.prototype.createLong=function(a,e){return m.Long.create(a,e)};m.ByteBuffer=function(a){this.bytes_=a,this.position_=0};m.ByteBuffer.allocate=function(a){return new m.ByteBuffer(new Uint8Array(a))};m.ByteBuffer.prototype.clear=function(){this.position_=0};m.ByteBuffer.prototype.bytes=function(){return this.bytes_};m.ByteBuffer.prototype.position=function(){return this.position_};m.ByteBuffer.prototype.setPosition=function(a){this.position_=a};m.ByteBuffer.prototype.capacity=function(){return this.bytes_.length};m.ByteBuffer.prototype.readInt8=function(a){return this.readUint8(a)<<24>>24};m.ByteBuffer.prototype.readUint8=function(a){return this.bytes_[a]};m.ByteBuffer.prototype.readInt16=function(a){return this.readUint16(a)<<16>>16};m.ByteBuffer.prototype.readUint16=function(a){return this.bytes_[a]|this.bytes_[a+1]<<8};m.ByteBuffer.prototype.readInt32=function(a){return this.bytes_[a]|this.bytes_[a+1]<<8|this.bytes_[a+2]<<16|this.bytes_[a+3]<<24};m.ByteBuffer.prototype.readUint32=function(a){return this.readInt32(a)>>>0};m.ByteBuffer.prototype.readInt64=function(a){return new m.Long(this.readInt32(a),this.readInt32(a+4))};m.ByteBuffer.prototype.readUint64=function(a){return new m.Long(this.readUint32(a),this.readUint32(a+4))};m.ByteBuffer.prototype.readFloat32=function(a){return m.int32[0]=this.readInt32(a),m.float32[0]};m.ByteBuffer.prototype.readFloat64=function(a){return m.int32[m.isLittleEndian?0:1]=this.readInt32(a),m.int32[m.isLittleEndian?1:0]=this.readInt32(a+4),m.float64[0]};m.ByteBuffer.prototype.writeInt8=function(a,e){this.bytes_[a]=e};m.ByteBuffer.prototype.writeUint8=function(a,e){this.bytes_[a]=e};m.ByteBuffer.prototype.writeInt16=function(a,e){this.bytes_[a]=e,this.bytes_[a+1]=e>>8};m.ByteBuffer.prototype.writeUint16=function(a,e){this.bytes_[a]=e,this.bytes_[a+1]=e>>8};m.ByteBuffer.prototype.writeInt32=function(a,e){this.bytes_[a]=e,this.bytes_[a+1]=e>>8,this.bytes_[a+2]=e>>16,this.bytes_[a+3]=e>>24};m.ByteBuffer.prototype.writeUint32=function(a,e){this.bytes_[a]=e,this.bytes_[a+1]=e>>8,this.bytes_[a+2]=e>>16,this.bytes_[a+3]=e>>24};m.ByteBuffer.prototype.writeInt64=function(a,e){this.writeInt32(a,e.low),this.writeInt32(a+4,e.high)};m.ByteBuffer.prototype.writeUint64=function(a,e){this.writeUint32(a,e.low),this.writeUint32(a+4,e.high)};m.ByteBuffer.prototype.writeFloat32=function(a,e){m.float32[0]=e,this.writeInt32(a,m.int32[0])};m.ByteBuffer.prototype.writeFloat64=function(a,e){m.float64[0]=e,this.writeInt32(a,m.int32[m.isLittleEndian?0:1]),this.writeInt32(a+4,m.int32[m.isLittleEndian?1:0])};m.ByteBuffer.prototype.getBufferIdentifier=function(){if(this.bytes_.length<this.position_+m.SIZEOF_INT+m.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: ByteBuffer is too short to contain an identifier.");for(var a="",e=0;e<m.FILE_IDENTIFIER_LENGTH;e++)a+=String.fromCharCode(this.readInt8(this.position_+m.SIZEOF_INT+e));return a};m.ByteBuffer.prototype.__offset=function(a,e){var o=a-this.readInt32(a);return e<this.readInt16(o)?this.readInt16(o+e):0};m.ByteBuffer.prototype.__union=function(a,e){return a.bb_pos=e+this.readInt32(e),a.bb=this,a};m.ByteBuffer.prototype.__string=function(a,e){a+=this.readInt32(a);var o=this.readInt32(a),t="",n=0;if(a+=m.SIZEOF_INT,e===m.Encoding.UTF8_BYTES)return this.bytes_.subarray(a,a+o);for(;n<o;){var r,s=this.readUint8(a+n++);if(s<192)r=s;else{var i=this.readUint8(a+n++);if(s<224)r=(s&31)<<6|i&63;else{var u=this.readUint8(a+n++);if(s<240)r=(s&15)<<12|(i&63)<<6|u&63;else{var l=this.readUint8(a+n++);r=(s&7)<<18|(i&63)<<12|(u&63)<<6|l&63}}}r<65536?t+=String.fromCharCode(r):(r-=65536,t+=String.fromCharCode((r>>10)+55296,(r&1024-1)+56320))}return t};m.ByteBuffer.prototype.__indirect=function(a){return a+this.readInt32(a)};m.ByteBuffer.prototype.__vector=function(a){return a+this.readInt32(a)+m.SIZEOF_INT};m.ByteBuffer.prototype.__vector_len=function(a){return this.readInt32(a+this.readInt32(a))};m.ByteBuffer.prototype.__has_identifier=function(a){if(a.length!=m.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: file identifier must be length "+m.FILE_IDENTIFIER_LENGTH);for(var e=0;e<m.FILE_IDENTIFIER_LENGTH;e++)if(a.charCodeAt(e)!=this.readInt8(this.position_+m.SIZEOF_INT+e))return!1;return!0};m.ByteBuffer.prototype.createLong=function(a,e){return m.Long.create(a,e)}});var P,ve=x(()=>{"use strict";Je();(e=>{let a;(t=>{let o;(r=>{let n;(S=>(S[S.UNDEFINED=0]="UNDEFINED",S[S.FLOAT=1]="FLOAT",S[S.INT=2]="INT",S[S.STRING=3]="STRING",S[S.TENSOR=4]="TENSOR",S[S.GRAPH=5]="GRAPH",S[S.FLOATS=6]="FLOATS",S[S.INTS=7]="INTS",S[S.STRINGS=8]="STRINGS",S[S.TENSORS=9]="TENSORS",S[S.GRAPHS=10]="GRAPHS",S[S.SPARSE_TENSOR=11]="SPARSE_TENSOR",S[S.SPARSE_TENSORS=12]="SPARSE_TENSORS"))(n=r.AttributeType||={})})(o=t.fbs||={})})(a=e.experimental||={})})(P||={});(e=>{let a;(t=>{let o;(r=>{let n;(l=>(l[l.UNKNOWN=0]="UNKNOWN",l[l.VALUE=1]="VALUE",l[l.PARAM=2]="PARAM"))(n=r.DimensionValueType||={})})(o=t.fbs||={})})(a=e.experimental||={})})(P||={});(e=>{let a;(t=>{let o;(r=>{let n;(L=>(L[L.UNDEFINED=0]="UNDEFINED",L[L.FLOAT=1]="FLOAT",L[L.UINT8=2]="UINT8",L[L.INT8=3]="INT8",L[L.UINT16=4]="UINT16",L[L.INT16=5]="INT16",L[L.INT32=6]="INT32",L[L.INT64=7]="INT64",L[L.STRING=8]="STRING",L[L.BOOL=9]="BOOL",L[L.FLOAT16=10]="FLOAT16",L[L.DOUBLE=11]="DOUBLE",L[L.UINT32=12]="UINT32",L[L.UINT64=13]="UINT64",L[L.COMPLEX64=14]="COMPLEX64",L[L.COMPLEX128=15]="COMPLEX128",L[L.BFLOAT16=16]="BFLOAT16",L[L.FLOAT8E4M3FN=17]="FLOAT8E4M3FN",L[L.FLOAT8E4M3FNUZ=18]="FLOAT8E4M3FNUZ",L[L.FLOAT8E5M2=19]="FLOAT8E5M2",L[L.FLOAT8E5M2FNUZ=20]="FLOAT8E5M2FNUZ"))(n=r.TensorDataType||={})})(o=t.fbs||={})})(a=e.experimental||={})})(P||={});(e=>{let a;(t=>{let o;(r=>{let n;(u=>(u[u.Primitive=0]="Primitive",u[u.Fused=1]="Fused"))(n=r.NodeType||={})})(o=t.fbs||={})})(a=e.experimental||={})})(P||={});(e=>{let a;(t=>{let o;(r=>{let n;(f=>(f[f.NONE=0]="NONE",f[f.tensor_type=1]="tensor_type",f[f.sequence_type=2]="sequence_type",f[f.map_type=3]="map_type"))(n=r.TypeInfoValue||={})})(o=t.fbs||={})})(a=e.experimental||={})})(P||={});(e=>{let a;(t=>{let o;(r=>{class n{constructor(){this.bb=null;this.bb_pos=0}__init(i,u){return this.bb_pos=i,this.bb=u,this}static getRootAsShape(i,u){return(u||new n).__init(i.readInt32(i.position())+i.position(),i)}static getSizePrefixedRootAsShape(i,u){return i.setPosition(i.position()+m.SIZE_PREFIX_LENGTH),(u||new n).__init(i.readInt32(i.position())+i.position(),i)}dim(i,u){let l=this.bb.__offset(this.bb_pos,4);return l?(u||new e.experimental.fbs.Dimension).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+l)+i*4),this.bb):null}dimLength(){let i=this.bb.__offset(this.bb_pos,4);return i?this.bb.__vector_len(this.bb_pos+i):0}static startShape(i){i.startObject(1)}static addDim(i,u){i.addFieldOffset(0,u,0)}static createDimVector(i,u){i.startVector(4,u.length,4);for(let l=u.length-1;l>=0;l--)i.addOffset(u[l]);return i.endVector()}static startDimVector(i,u){i.startVector(4,u,4)}static endShape(i){return i.endObject()}static createShape(i,u){return n.startShape(i),n.addDim(i,u),n.endShape(i)}}r.Shape=n})(o=t.fbs||={})})(a=e.experimental||={})})(P||={});(e=>{let a;(t=>{let o;(r=>{class n{constructor(){this.bb=null;this.bb_pos=0}__init(i,u){return this.bb_pos=i,this.bb=u,this}static getRootAsDimension(i,u){return(u||new n).__init(i.readInt32(i.position())+i.position(),i)}static getSizePrefixedRootAsDimension(i,u){return i.setPosition(i.position()+m.SIZE_PREFIX_LENGTH),(u||new n).__init(i.readInt32(i.position())+i.position(),i)}value(i){let u=this.bb.__offset(this.bb_pos,4);return u?(i||new e.experimental.fbs.DimensionValue).__init(this.bb.__indirect(this.bb_pos+u),this.bb):null}denotation(i){let u=this.bb.__offset(this.bb_pos,6);return u?this.bb.__string(this.bb_pos+u,i):null}static startDimension(i){i.startObject(2)}static addValue(i,u){i.addFieldOffset(0,u,0)}static addDenotation(i,u){i.addFieldOffset(1,u,0)}static endDimension(i){return i.endObject()}static createDimension(i,u,l){return n.startDimension(i),n.addValue(i,u),n.addDenotation(i,l),n.endDimension(i)}}r.Dimension=n})(o=t.fbs||={})})(a=e.experimental||={})})(P||={});(e=>{let a;(t=>{let o;(r=>{class n{constructor(){this.bb=null;this.bb_pos=0}__init(i,u){return this.bb_pos=i,this.bb=u,this}static getRootAsDimensionValue(i,u){return(u||new n).__init(i.readInt32(i.position())+i.position(),i)}static getSizePrefixedRootAsDimensionValue(i,u){return i.setPosition(i.position()+m.SIZE_PREFIX_LENGTH),(u||new n).__init(i.readInt32(i.position())+i.position(),i)}dimType(){let i=this.bb.__offset(this.bb_pos,4);return i?this.bb.readInt8(this.bb_pos+i):0}dimValue(){let i=this.bb.__offset(this.bb_pos,6);return i?this.bb.readInt64(this.bb_pos+i):this.bb.createLong(0,0)}dimParam(i){let u=this.bb.__offset(this.bb_pos,8);return u?this.bb.__string(this.bb_pos+u,i):null}static startDimensionValue(i){i.startObject(3)}static addDimType(i,u){i.addFieldInt8(0,u,0)}static addDimValue(i,u){i.addFieldInt64(1,u,i.createLong(0,0))}static addDimParam(i,u){i.addFieldOffset(2,u,0)}static endDimensionValue(i){return i.endObject()}static createDimensionValue(i,u,l,f){return n.startDimensionValue(i),n.addDimType(i,u),n.addDimValue(i,l),n.addDimParam(i,f),n.endDimensionValue(i)}}r.DimensionValue=n})(o=t.fbs||={})})(a=e.experimental||={})})(P||={});(e=>{let a;(t=>{let o;(r=>{class n{constructor(){this.bb=null;this.bb_pos=0}__init(i,u){return this.bb_pos=i,this.bb=u,this}static getRootAsTensorTypeAndShape(i,u){return(u||new n).__init(i.readInt32(i.position())+i.position(),i)}static getSizePrefixedRootAsTensorTypeAndShape(i,u){return i.setPosition(i.position()+m.SIZE_PREFIX_LENGTH),(u||new n).__init(i.readInt32(i.position())+i.position(),i)}elemType(){let i=this.bb.__offset(this.bb_pos,4);return i?this.bb.readInt32(this.bb_pos+i):0}shape(i){let u=this.bb.__offset(this.bb_pos,6);return u?(i||new e.experimental.fbs.Shape).__init(this.bb.__indirect(this.bb_pos+u),this.bb):null}static startTensorTypeAndShape(i){i.startObject(2)}static addElemType(i,u){i.addFieldInt32(0,u,0)}static addShape(i,u){i.addFieldOffset(1,u,0)}static endTensorTypeAndShape(i){return i.endObject()}static createTensorTypeAndShape(i,u,l){return n.startTensorTypeAndShape(i),n.addElemType(i,u),n.addShape(i,l),n.endTensorTypeAndShape(i)}}r.TensorTypeAndShape=n})(o=t.fbs||={})})(a=e.experimental||={})})(P||={});(e=>{let a;(t=>{let o;(r=>{class n{constructor(){this.bb=null;this.bb_pos=0}__init(i,u){return this.bb_pos=i,this.bb=u,this}static getRootAsMapType(i,u){return(u||new n).__init(i.readInt32(i.position())+i.position(),i)}static getSizePrefixedRootAsMapType(i,u){return i.setPosition(i.position()+m.SIZE_PREFIX_LENGTH),(u||new n).__init(i.readInt32(i.position())+i.position(),i)}keyType(){let i=this.bb.__offset(this.bb_pos,4);return i?this.bb.readInt32(this.bb_pos+i):0}valueType(i){let u=this.bb.__offset(this.bb_pos,6);return u?(i||new e.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+u),this.bb):null}static startMapType(i){i.startObject(2)}static addKeyType(i,u){i.addFieldInt32(0,u,0)}static addValueType(i,u){i.addFieldOffset(1,u,0)}static endMapType(i){return i.endObject()}static createMapType(i,u,l){return n.startMapType(i),n.addKeyType(i,u),n.addValueType(i,l),n.endMapType(i)}}r.MapType=n})(o=t.fbs||={})})(a=e.experimental||={})})(P||={});(e=>{let a;(t=>{let o;(r=>{class n{constructor(){this.bb=null;this.bb_pos=0}__init(i,u){return this.bb_pos=i,this.bb=u,this}static getRootAsSequenceType(i,u){return(u||new n).__init(i.readInt32(i.position())+i.position(),i)}static getSizePrefixedRootAsSequenceType(i,u){return i.setPosition(i.position()+m.SIZE_PREFIX_LENGTH),(u||new n).__init(i.readInt32(i.position())+i.position(),i)}elemType(i){let u=this.bb.__offset(this.bb_pos,4);return u?(i||new e.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+u),this.bb):null}static startSequenceType(i){i.startObject(1)}static addElemType(i,u){i.addFieldOffset(0,u,0)}static endSequenceType(i){return i.endObject()}static createSequenceType(i,u){return n.startSequenceType(i),n.addElemType(i,u),n.endSequenceType(i)}}r.SequenceType=n})(o=t.fbs||={})})(a=e.experimental||={})})(P||={});(e=>{let a;(t=>{let o;(r=>{class n{constructor(){this.bb=null;this.bb_pos=0}__init(i,u){return this.bb_pos=i,this.bb=u,this}nodeIndex(){return this.bb.readUint32(this.bb_pos)}srcArgIndex(){return this.bb.readInt32(this.bb_pos+4)}dstArgIndex(){return this.bb.readInt32(this.bb_pos+8)}static createEdgeEnd(i,u,l,f){return i.prep(4,12),i.writeInt32(f),i.writeInt32(l),i.writeInt32(u),i.offset()}}r.EdgeEnd=n})(o=t.fbs||={})})(a=e.experimental||={})})(P||={});(e=>{let a;(t=>{let o;(r=>{class n{constructor(){this.bb=null;this.bb_pos=0}__init(i,u){return this.bb_pos=i,this.bb=u,this}static getRootAsNodeEdge(i,u){return(u||new n).__init(i.readInt32(i.position())+i.position(),i)}static getSizePrefixedRootAsNodeEdge(i,u){return i.setPosition(i.position()+m.SIZE_PREFIX_LENGTH),(u||new n).__init(i.readInt32(i.position())+i.position(),i)}nodeIndex(){let i=this.bb.__offset(this.bb_pos,4);return i?this.bb.readUint32(this.bb_pos+i):0}inputEdges(i,u){let l=this.bb.__offset(this.bb_pos,6);return l?(u||new e.experimental.fbs.EdgeEnd).__init(this.bb.__vector(this.bb_pos+l)+i*12,this.bb):null}inputEdgesLength(){let i=this.bb.__offset(this.bb_pos,6);return i?this.bb.__vector_len(this.bb_pos+i):0}outputEdges(i,u){let l=this.bb.__offset(this.bb_pos,8);return l?(u||new e.experimental.fbs.EdgeEnd).__init(this.bb.__vector(this.bb_pos+l)+i*12,this.bb):null}outputEdgesLength(){let i=this.bb.__offset(this.bb_pos,8);return i?this.bb.__vector_len(this.bb_pos+i):0}static startNodeEdge(i){i.startObject(3)}static addNodeIndex(i,u){i.addFieldInt32(0,u,0)}static addInputEdges(i,u){i.addFieldOffset(1,u,0)}static startInputEdgesVector(i,u){i.startVector(12,u,4)}static addOutputEdges(i,u){i.addFieldOffset(2,u,0)}static startOutputEdgesVector(i,u){i.startVector(12,u,4)}static endNodeEdge(i){return i.endObject()}static createNodeEdge(i,u,l,f){return n.startNodeEdge(i),n.addNodeIndex(i,u),n.addInputEdges(i,l),n.addOutputEdges(i,f),n.endNodeEdge(i)}}r.NodeEdge=n})(o=t.fbs||={})})(a=e.experimental||={})})(P||={});(e=>{let a;(t=>{let o;(r=>{class n{constructor(){this.bb=null;this.bb_pos=0}__init(i,u){return this.bb_pos=i,this.bb=u,this}static getRootAsNode(i,u){return(u||new n).__init(i.readInt32(i.position())+i.position(),i)}static getSizePrefixedRootAsNode(i,u){return i.setPosition(i.position()+m.SIZE_PREFIX_LENGTH),(u||new n).__init(i.readInt32(i.position())+i.position(),i)}name(i){let u=this.bb.__offset(this.bb_pos,4);return u?this.bb.__string(this.bb_pos+u,i):null}docString(i){let u=this.bb.__offset(this.bb_pos,6);return u?this.bb.__string(this.bb_pos+u,i):null}domain(i){let u=this.bb.__offset(this.bb_pos,8);return u?this.bb.__string(this.bb_pos+u,i):null}sinceVersion(){let i=this.bb.__offset(this.bb_pos,10);return i?this.bb.readInt32(this.bb_pos+i):0}index(){let i=this.bb.__offset(this.bb_pos,12);return i?this.bb.readUint32(this.bb_pos+i):0}opType(i){let u=this.bb.__offset(this.bb_pos,14);return u?this.bb.__string(this.bb_pos+u,i):null}type(){let i=this.bb.__offset(this.bb_pos,16);return i?this.bb.readInt32(this.bb_pos+i):0}executionProviderType(i){let u=this.bb.__offset(this.bb_pos,18);return u?this.bb.__string(this.bb_pos+u,i):null}inputs(i,u){let l=this.bb.__offset(this.bb_pos,20);return l?this.bb.__string(this.bb.__vector(this.bb_pos+l)+i*4,u):null}inputsLength(){let i=this.bb.__offset(this.bb_pos,20);return i?this.bb.__vector_len(this.bb_pos+i):0}outputs(i,u){let l=this.bb.__offset(this.bb_pos,22);return l?this.bb.__string(this.bb.__vector(this.bb_pos+l)+i*4,u):null}outputsLength(){let i=this.bb.__offset(this.bb_pos,22);return i?this.bb.__vector_len(this.bb_pos+i):0}attributes(i,u){let l=this.bb.__offset(this.bb_pos,24);return l?(u||new e.experimental.fbs.Attribute).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+l)+i*4),this.bb):null}attributesLength(){let i=this.bb.__offset(this.bb_pos,24);return i?this.bb.__vector_len(this.bb_pos+i):0}inputArgCounts(i){let u=this.bb.__offset(this.bb_pos,26);return u?this.bb.readInt32(this.bb.__vector(this.bb_pos+u)+i*4):0}inputArgCountsLength(){let i=this.bb.__offset(this.bb_pos,26);return i?this.bb.__vector_len(this.bb_pos+i):0}inputArgCountsArray(){let i=this.bb.__offset(this.bb_pos,26);return i?new Int32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+i),this.bb.__vector_len(this.bb_pos+i)):null}implicitInputs(i,u){let l=this.bb.__offset(this.bb_pos,28);return l?this.bb.__string(this.bb.__vector(this.bb_pos+l)+i*4,u):null}implicitInputsLength(){let i=this.bb.__offset(this.bb_pos,28);return i?this.bb.__vector_len(this.bb_pos+i):0}static startNode(i){i.startObject(13)}static addName(i,u){i.addFieldOffset(0,u,0)}static addDocString(i,u){i.addFieldOffset(1,u,0)}static addDomain(i,u){i.addFieldOffset(2,u,0)}static addSinceVersion(i,u){i.addFieldInt32(3,u,0)}static addIndex(i,u){i.addFieldInt32(4,u,0)}static addOpType(i,u){i.addFieldOffset(5,u,0)}static addType(i,u){i.addFieldInt32(6,u,0)}static addExecutionProviderType(i,u){i.addFieldOffset(7,u,0)}static addInputs(i,u){i.addFieldOffset(8,u,0)}static createInputsVector(i,u){i.startVector(4,u.length,4);for(let l=u.length-1;l>=0;l--)i.addOffset(u[l]);return i.endVector()}static startInputsVector(i,u){i.startVector(4,u,4)}static addOutputs(i,u){i.addFieldOffset(9,u,0)}static createOutputsVector(i,u){i.startVector(4,u.length,4);for(let l=u.length-1;l>=0;l--)i.addOffset(u[l]);return i.endVector()}static startOutputsVector(i,u){i.startVector(4,u,4)}static addAttributes(i,u){i.addFieldOffset(10,u,0)}static createAttributesVector(i,u){i.startVector(4,u.length,4);for(let l=u.length-1;l>=0;l--)i.addOffset(u[l]);return i.endVector()}static startAttributesVector(i,u){i.startVector(4,u,4)}static addInputArgCounts(i,u){i.addFieldOffset(11,u,0)}static createInputArgCountsVector(i,u){i.startVector(4,u.length,4);for(let l=u.length-1;l>=0;l--)i.addInt32(u[l]);return i.endVector()}static startInputArgCountsVector(i,u){i.startVector(4,u,4)}static addImplicitInputs(i,u){i.addFieldOffset(12,u,0)}static createImplicitInputsVector(i,u){i.startVector(4,u.length,4);for(let l=u.length-1;l>=0;l--)i.addOffset(u[l]);return i.endVector()}static startImplicitInputsVector(i,u){i.startVector(4,u,4)}static endNode(i){return i.endObject()}static createNode(i,u,l,f,p,d,b,g,y,v,_,A,S,C){return n.startNode(i),n.addName(i,u),n.addDocString(i,l),n.addDomain(i,f),n.addSinceVersion(i,p),n.addIndex(i,d),n.addOpType(i,b),n.addType(i,g),n.addExecutionProviderType(i,y),n.addInputs(i,v),n.addOutputs(i,_),n.addAttributes(i,A),n.addInputArgCounts(i,S),n.addImplicitInputs(i,C),n.endNode(i)}}r.Node=n})(o=t.fbs||={})})(a=e.experimental||={})})(P||={});(e=>{let a;(t=>{let o;(r=>{class n{constructor(){this.bb=null;this.bb_pos=0}__init(i,u){return this.bb_pos=i,this.bb=u,this}static getRootAsValueInfo(i,u){return(u||new n).__init(i.readInt32(i.position())+i.position(),i)}static getSizePrefixedRootAsValueInfo(i,u){return i.setPosition(i.position()+m.SIZE_PREFIX_LENGTH),(u||new n).__init(i.readInt32(i.position())+i.position(),i)}name(i){let u=this.bb.__offset(this.bb_pos,4);return u?this.bb.__string(this.bb_pos+u,i):null}docString(i){let u=this.bb.__offset(this.bb_pos,6);return u?this.bb.__string(this.bb_pos+u,i):null}type(i){let u=this.bb.__offset(this.bb_pos,8);return u?(i||new e.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+u),this.bb):null}static startValueInfo(i){i.startObject(3)}static addName(i,u){i.addFieldOffset(0,u,0)}static addDocString(i,u){i.addFieldOffset(1,u,0)}static addType(i,u){i.addFieldOffset(2,u,0)}static endValueInfo(i){return i.endObject()}static createValueInfo(i,u,l,f){return n.startValueInfo(i),n.addName(i,u),n.addDocString(i,l),n.addType(i,f),n.endValueInfo(i)}}r.ValueInfo=n})(o=t.fbs||={})})(a=e.experimental||={})})(P||={});(e=>{let a;(t=>{let o;(r=>{class n{constructor(){this.bb=null;this.bb_pos=0}__init(i,u){return this.bb_pos=i,this.bb=u,this}static getRootAsTypeInfo(i,u){return(u||new n).__init(i.readInt32(i.position())+i.position(),i)}static getSizePrefixedRootAsTypeInfo(i,u){return i.setPosition(i.position()+m.SIZE_PREFIX_LENGTH),(u||new n).__init(i.readInt32(i.position())+i.position(),i)}denotation(i){let u=this.bb.__offset(this.bb_pos,4);return u?this.bb.__string(this.bb_pos+u,i):null}valueType(){let i=this.bb.__offset(this.bb_pos,6);return i?this.bb.readUint8(this.bb_pos+i):0}value(i){let u=this.bb.__offset(this.bb_pos,8);return u?this.bb.__union(i,this.bb_pos+u):null}static startTypeInfo(i){i.startObject(3)}static addDenotation(i,u){i.addFieldOffset(0,u,0)}static addValueType(i,u){i.addFieldInt8(1,u,0)}static addValue(i,u){i.addFieldOffset(2,u,0)}static endTypeInfo(i){return i.endObject()}static createTypeInfo(i,u,l,f){return n.startTypeInfo(i),n.addDenotation(i,u),n.addValueType(i,l),n.addValue(i,f),n.endTypeInfo(i)}}r.TypeInfo=n})(o=t.fbs||={})})(a=e.experimental||={})})(P||={});(e=>{let a;(t=>{let o;(r=>{class n{constructor(){this.bb=null;this.bb_pos=0}__init(i,u){return this.bb_pos=i,this.bb=u,this}static getRootAsOperatorSetId(i,u){return(u||new n).__init(i.readInt32(i.position())+i.position(),i)}static getSizePrefixedRootAsOperatorSetId(i,u){return i.setPosition(i.position()+m.SIZE_PREFIX_LENGTH),(u||new n).__init(i.readInt32(i.position())+i.position(),i)}domain(i){let u=this.bb.__offset(this.bb_pos,4);return u?this.bb.__string(this.bb_pos+u,i):null}version(){let i=this.bb.__offset(this.bb_pos,6);return i?this.bb.readInt64(this.bb_pos+i):this.bb.createLong(0,0)}static startOperatorSetId(i){i.startObject(2)}static addDomain(i,u){i.addFieldOffset(0,u,0)}static addVersion(i,u){i.addFieldInt64(1,u,i.createLong(0,0))}static endOperatorSetId(i){return i.endObject()}static createOperatorSetId(i,u,l){return n.startOperatorSetId(i),n.addDomain(i,u),n.addVersion(i,l),n.endOperatorSetId(i)}}r.OperatorSetId=n})(o=t.fbs||={})})(a=e.experimental||={})})(P||={});(e=>{let a;(t=>{let o;(r=>{class n{constructor(){this.bb=null;this.bb_pos=0}__init(i,u){return this.bb_pos=i,this.bb=u,this}static getRootAsTensor(i,u){return(u||new n).__init(i.readInt32(i.position())+i.position(),i)}static getSizePrefixedRootAsTensor(i,u){return i.setPosition(i.position()+m.SIZE_PREFIX_LENGTH),(u||new n).__init(i.readInt32(i.position())+i.position(),i)}name(i){let u=this.bb.__offset(this.bb_pos,4);return u?this.bb.__string(this.bb_pos+u,i):null}docString(i){let u=this.bb.__offset(this.bb_pos,6);return u?this.bb.__string(this.bb_pos+u,i):null}dims(i){let u=this.bb.__offset(this.bb_pos,8);return u?this.bb.readInt64(this.bb.__vector(this.bb_pos+u)+i*8):this.bb.createLong(0,0)}dimsLength(){let i=this.bb.__offset(this.bb_pos,8);return i?this.bb.__vector_len(this.bb_pos+i):0}dataType(){let i=this.bb.__offset(this.bb_pos,10);return i?this.bb.readInt32(this.bb_pos+i):0}rawData(i){let u=this.bb.__offset(this.bb_pos,12);return u?this.bb.readUint8(this.bb.__vector(this.bb_pos+u)+i):0}rawDataLength(){let i=this.bb.__offset(this.bb_pos,12);return i?this.bb.__vector_len(this.bb_pos+i):0}rawDataArray(){let i=this.bb.__offset(this.bb_pos,12);return i?new Uint8Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+i),this.bb.__vector_len(this.bb_pos+i)):null}stringData(i,u){let l=this.bb.__offset(this.bb_pos,14);return l?this.bb.__string(this.bb.__vector(this.bb_pos+l)+i*4,u):null}stringDataLength(){let i=this.bb.__offset(this.bb_pos,14);return i?this.bb.__vector_len(this.bb_pos+i):0}static startTensor(i){i.startObject(6)}static addName(i,u){i.addFieldOffset(0,u,0)}static addDocString(i,u){i.addFieldOffset(1,u,0)}static addDims(i,u){i.addFieldOffset(2,u,0)}static createDimsVector(i,u){i.startVector(8,u.length,8);for(let l=u.length-1;l>=0;l--)i.addInt64(u[l]);return i.endVector()}static startDimsVector(i,u){i.startVector(8,u,8)}static addDataType(i,u){i.addFieldInt32(3,u,0)}static addRawData(i,u){i.addFieldOffset(4,u,0)}static createRawDataVector(i,u){i.startVector(1,u.length,1);for(let l=u.length-1;l>=0;l--)i.addInt8(u[l]);return i.endVector()}static startRawDataVector(i,u){i.startVector(1,u,1)}static addStringData(i,u){i.addFieldOffset(5,u,0)}static createStringDataVector(i,u){i.startVector(4,u.length,4);for(let l=u.length-1;l>=0;l--)i.addOffset(u[l]);return i.endVector()}static startStringDataVector(i,u){i.startVector(4,u,4)}static endTensor(i){return i.endObject()}static createTensor(i,u,l,f,p,d,b){return n.startTensor(i),n.addName(i,u),n.addDocString(i,l),n.addDims(i,f),n.addDataType(i,p),n.addRawData(i,d),n.addStringData(i,b),n.endTensor(i)}}r.Tensor=n})(o=t.fbs||={})})(a=e.experimental||={})})(P||={});(e=>{let a;(t=>{let o;(r=>{class n{constructor(){this.bb=null;this.bb_pos=0}__init(i,u){return this.bb_pos=i,this.bb=u,this}static getRootAsSparseTensor(i,u){return(u||new n).__init(i.readInt32(i.position())+i.position(),i)}static getSizePrefixedRootAsSparseTensor(i,u){return i.setPosition(i.position()+m.SIZE_PREFIX_LENGTH),(u||new n).__init(i.readInt32(i.position())+i.position(),i)}values(i){let u=this.bb.__offset(this.bb_pos,4);return u?(i||new e.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+u),this.bb):null}indices(i){let u=this.bb.__offset(this.bb_pos,6);return u?(i||new e.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+u),this.bb):null}dims(i){let u=this.bb.__offset(this.bb_pos,8);return u?this.bb.readInt64(this.bb.__vector(this.bb_pos+u)+i*8):this.bb.createLong(0,0)}dimsLength(){let i=this.bb.__offset(this.bb_pos,8);return i?this.bb.__vector_len(this.bb_pos+i):0}static startSparseTensor(i){i.startObject(3)}static addValues(i,u){i.addFieldOffset(0,u,0)}static addIndices(i,u){i.addFieldOffset(1,u,0)}static addDims(i,u){i.addFieldOffset(2,u,0)}static createDimsVector(i,u){i.startVector(8,u.length,8);for(let l=u.length-1;l>=0;l--)i.addInt64(u[l]);return i.endVector()}static startDimsVector(i,u){i.startVector(8,u,8)}static endSparseTensor(i){return i.endObject()}static createSparseTensor(i,u,l,f){return n.startSparseTensor(i),n.addValues(i,u),n.addIndices(i,l),n.addDims(i,f),n.endSparseTensor(i)}}r.SparseTensor=n})(o=t.fbs||={})})(a=e.experimental||={})})(P||={});(e=>{let a;(t=>{let o;(r=>{class n{constructor(){this.bb=null;this.bb_pos=0}__init(i,u){return this.bb_pos=i,this.bb=u,this}static getRootAsAttribute(i,u){return(u||new n).__init(i.readInt32(i.position())+i.position(),i)}static getSizePrefixedRootAsAttribute(i,u){return i.setPosition(i.position()+m.SIZE_PREFIX_LENGTH),(u||new n).__init(i.readInt32(i.position())+i.position(),i)}name(i){let u=this.bb.__offset(this.bb_pos,4);return u?this.bb.__string(this.bb_pos+u,i):null}docString(i){let u=this.bb.__offset(this.bb_pos,6);return u?this.bb.__string(this.bb_pos+u,i):null}type(){let i=this.bb.__offset(this.bb_pos,8);return i?this.bb.readInt32(this.bb_pos+i):0}f(){let i=this.bb.__offset(this.bb_pos,10);return i?this.bb.readFloat32(this.bb_pos+i):0}i(){let i=this.bb.__offset(this.bb_pos,12);return i?this.bb.readInt64(this.bb_pos+i):this.bb.createLong(0,0)}s(i){let u=this.bb.__offset(this.bb_pos,14);return u?this.bb.__string(this.bb_pos+u,i):null}t(i){let u=this.bb.__offset(this.bb_pos,16);return u?(i||new e.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+u),this.bb):null}g(i){let u=this.bb.__offset(this.bb_pos,18);return u?(i||new e.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb_pos+u),this.bb):null}floats(i){let u=this.bb.__offset(this.bb_pos,20);return u?this.bb.readFloat32(this.bb.__vector(this.bb_pos+u)+i*4):0}floatsLength(){let i=this.bb.__offset(this.bb_pos,20);return i?this.bb.__vector_len(this.bb_pos+i):0}floatsArray(){let i=this.bb.__offset(this.bb_pos,20);return i?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+i),this.bb.__vector_len(this.bb_pos+i)):null}ints(i){let u=this.bb.__offset(this.bb_pos,22);return u?this.bb.readInt64(this.bb.__vector(this.bb_pos+u)+i*8):this.bb.createLong(0,0)}intsLength(){let i=this.bb.__offset(this.bb_pos,22);return i?this.bb.__vector_len(this.bb_pos+i):0}strings(i,u){let l=this.bb.__offset(this.bb_pos,24);return l?this.bb.__string(this.bb.__vector(this.bb_pos+l)+i*4,u):null}stringsLength(){let i=this.bb.__offset(this.bb_pos,24);return i?this.bb.__vector_len(this.bb_pos+i):0}tensors(i,u){let l=this.bb.__offset(this.bb_pos,26);return l?(u||new e.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+l)+i*4),this.bb):null}tensorsLength(){let i=this.bb.__offset(this.bb_pos,26);return i?this.bb.__vector_len(this.bb_pos+i):0}graphs(i,u){let l=this.bb.__offset(this.bb_pos,28);return l?(u||new e.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+l)+i*4),this.bb):null}graphsLength(){let i=this.bb.__offset(this.bb_pos,28);return i?this.bb.__vector_len(this.bb_pos+i):0}static startAttribute(i){i.startObject(13)}static addName(i,u){i.addFieldOffset(0,u,0)}static addDocString(i,u){i.addFieldOffset(1,u,0)}static addType(i,u){i.addFieldInt32(2,u,0)}static addF(i,u){i.addFieldFloat32(3,u,0)}static addI(i,u){i.addFieldInt64(4,u,i.createLong(0,0))}static addS(i,u){i.addFieldOffset(5,u,0)}static addT(i,u){i.addFieldOffset(6,u,0)}static addG(i,u){i.addFieldOffset(7,u,0)}static addFloats(i,u){i.addFieldOffset(8,u,0)}static createFloatsVector(i,u){i.startVector(4,u.length,4);for(let l=u.length-1;l>=0;l--)i.addFloat32(u[l]);return i.endVector()}static startFloatsVector(i,u){i.startVector(4,u,4)}static addInts(i,u){i.addFieldOffset(9,u,0)}static createIntsVector(i,u){i.startVector(8,u.length,8);for(let l=u.length-1;l>=0;l--)i.addInt64(u[l]);return i.endVector()}static startIntsVector(i,u){i.startVector(8,u,8)}static addStrings(i,u){i.addFieldOffset(10,u,0)}static createStringsVector(i,u){i.startVector(4,u.length,4);for(let l=u.length-1;l>=0;l--)i.addOffset(u[l]);return i.endVector()}static startStringsVector(i,u){i.startVector(4,u,4)}static addTensors(i,u){i.addFieldOffset(11,u,0)}static createTensorsVector(i,u){i.startVector(4,u.length,4);for(let l=u.length-1;l>=0;l--)i.addOffset(u[l]);return i.endVector()}static startTensorsVector(i,u){i.startVector(4,u,4)}static addGraphs(i,u){i.addFieldOffset(12,u,0)}static createGraphsVector(i,u){i.startVector(4,u.length,4);for(let l=u.length-1;l>=0;l--)i.addOffset(u[l]);return i.endVector()}static startGraphsVector(i,u){i.startVector(4,u,4)}static endAttribute(i){return i.endObject()}static createAttribute(i,u,l,f,p,d,b,g,y,v,_,A,S,C){return n.startAttribute(i),n.addName(i,u),n.addDocString(i,l),n.addType(i,f),n.addF(i,p),n.addI(i,d),n.addS(i,b),n.addT(i,g),n.addG(i,y),n.addFloats(i,v),n.addInts(i,_),n.addStrings(i,A),n.addTensors(i,S),n.addGraphs(i,C),n.endAttribute(i)}}r.Attribute=n})(o=t.fbs||={})})(a=e.experimental||={})})(P||={});(e=>{let a;(t=>{let o;(r=>{class n{constructor(){this.bb=null;this.bb_pos=0}__init(i,u){return this.bb_pos=i,this.bb=u,this}static getRootAsGraph(i,u){return(u||new n).__init(i.readInt32(i.position())+i.position(),i)}static getSizePrefixedRootAsGraph(i,u){return i.setPosition(i.position()+m.SIZE_PREFIX_LENGTH),(u||new n).__init(i.readInt32(i.position())+i.position(),i)}initializers(i,u){let l=this.bb.__offset(this.bb_pos,4);return l?(u||new e.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+l)+i*4),this.bb):null}initializersLength(){let i=this.bb.__offset(this.bb_pos,4);return i?this.bb.__vector_len(this.bb_pos+i):0}nodeArgs(i,u){let l=this.bb.__offset(this.bb_pos,6);return l?(u||new e.experimental.fbs.ValueInfo).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+l)+i*4),this.bb):null}nodeArgsLength(){let i=this.bb.__offset(this.bb_pos,6);return i?this.bb.__vector_len(this.bb_pos+i):0}nodes(i,u){let l=this.bb.__offset(this.bb_pos,8);return l?(u||new e.experimental.fbs.Node).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+l)+i*4),this.bb):null}nodesLength(){let i=this.bb.__offset(this.bb_pos,8);return i?this.bb.__vector_len(this.bb_pos+i):0}maxNodeIndex(){let i=this.bb.__offset(this.bb_pos,10);return i?this.bb.readUint32(this.bb_pos+i):0}nodeEdges(i,u){let l=this.bb.__offset(this.bb_pos,12);return l?(u||new e.experimental.fbs.NodeEdge).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+l)+i*4),this.bb):null}nodeEdgesLength(){let i=this.bb.__offset(this.bb_pos,12);return i?this.bb.__vector_len(this.bb_pos+i):0}inputs(i,u){let l=this.bb.__offset(this.bb_pos,14);return l?this.bb.__string(this.bb.__vector(this.bb_pos+l)+i*4,u):null}inputsLength(){let i=this.bb.__offset(this.bb_pos,14);return i?this.bb.__vector_len(this.bb_pos+i):0}outputs(i,u){let l=this.bb.__offset(this.bb_pos,16);return l?this.bb.__string(this.bb.__vector(this.bb_pos+l)+i*4,u):null}outputsLength(){let i=this.bb.__offset(this.bb_pos,16);return i?this.bb.__vector_len(this.bb_pos+i):0}sparseInitializers(i,u){let l=this.bb.__offset(this.bb_pos,18);return l?(u||new e.experimental.fbs.SparseTensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+l)+i*4),this.bb):null}sparseInitializersLength(){let i=this.bb.__offset(this.bb_pos,18);return i?this.bb.__vector_len(this.bb_pos+i):0}static startGraph(i){i.startObject(8)}static addInitializers(i,u){i.addFieldOffset(0,u,0)}static createInitializersVector(i,u){i.startVector(4,u.length,4);for(let l=u.length-1;l>=0;l--)i.addOffset(u[l]);return i.endVector()}static startInitializersVector(i,u){i.startVector(4,u,4)}static addNodeArgs(i,u){i.addFieldOffset(1,u,0)}static createNodeArgsVector(i,u){i.startVector(4,u.length,4);for(let l=u.length-1;l>=0;l--)i.addOffset(u[l]);return i.endVector()}static startNodeArgsVector(i,u){i.startVector(4,u,4)}static addNodes(i,u){i.addFieldOffset(2,u,0)}static createNodesVector(i,u){i.startVector(4,u.length,4);for(let l=u.length-1;l>=0;l--)i.addOffset(u[l]);return i.endVector()}static startNodesVector(i,u){i.startVector(4,u,4)}static addMaxNodeIndex(i,u){i.addFieldInt32(3,u,0)}static addNodeEdges(i,u){i.addFieldOffset(4,u,0)}static createNodeEdgesVector(i,u){i.startVector(4,u.length,4);for(let l=u.length-1;l>=0;l--)i.addOffset(u[l]);return i.endVector()}static startNodeEdgesVector(i,u){i.startVector(4,u,4)}static addInputs(i,u){i.addFieldOffset(5,u,0)}static createInputsVector(i,u){i.startVector(4,u.length,4);for(let l=u.length-1;l>=0;l--)i.addOffset(u[l]);return i.endVector()}static startInputsVector(i,u){i.startVector(4,u,4)}static addOutputs(i,u){i.addFieldOffset(6,u,0)}static createOutputsVector(i,u){i.startVector(4,u.length,4);for(let l=u.length-1;l>=0;l--)i.addOffset(u[l]);return i.endVector()}static startOutputsVector(i,u){i.startVector(4,u,4)}static addSparseInitializers(i,u){i.addFieldOffset(7,u,0)}static createSparseInitializersVector(i,u){i.startVector(4,u.length,4);for(let l=u.length-1;l>=0;l--)i.addOffset(u[l]);return i.endVector()}static startSparseInitializersVector(i,u){i.startVector(4,u,4)}static endGraph(i){return i.endObject()}static createGraph(i,u,l,f,p,d,b,g,y){return n.startGraph(i),n.addInitializers(i,u),n.addNodeArgs(i,l),n.addNodes(i,f),n.addMaxNodeIndex(i,p),n.addNodeEdges(i,d),n.addInputs(i,b),n.addOutputs(i,g),n.addSparseInitializers(i,y),n.endGraph(i)}}r.Graph=n})(o=t.fbs||={})})(a=e.experimental||={})})(P||={});(e=>{let a;(t=>{let o;(r=>{class n{constructor(){this.bb=null;this.bb_pos=0}__init(i,u){return this.bb_pos=i,this.bb=u,this}static getRootAsModel(i,u){return(u||new n).__init(i.readInt32(i.position())+i.position(),i)}static getSizePrefixedRootAsModel(i,u){return i.setPosition(i.position()+m.SIZE_PREFIX_LENGTH),(u||new n).__init(i.readInt32(i.position())+i.position(),i)}irVersion(){let i=this.bb.__offset(this.bb_pos,4);return i?this.bb.readInt64(this.bb_pos+i):this.bb.createLong(0,0)}opsetImport(i,u){let l=this.bb.__offset(this.bb_pos,6);return l?(u||new e.experimental.fbs.OperatorSetId).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+l)+i*4),this.bb):null}opsetImportLength(){let i=this.bb.__offset(this.bb_pos,6);return i?this.bb.__vector_len(this.bb_pos+i):0}producerName(i){let u=this.bb.__offset(this.bb_pos,8);return u?this.bb.__string(this.bb_pos+u,i):null}producerVersion(i){let u=this.bb.__offset(this.bb_pos,10);return u?this.bb.__string(this.bb_pos+u,i):null}domain(i){let u=this.bb.__offset(this.bb_pos,12);return u?this.bb.__string(this.bb_pos+u,i):null}modelVersion(){let i=this.bb.__offset(this.bb_pos,14);return i?this.bb.readInt64(this.bb_pos+i):this.bb.createLong(0,0)}docString(i){let u=this.bb.__offset(this.bb_pos,16);return u?this.bb.__string(this.bb_pos+u,i):null}graph(i){let u=this.bb.__offset(this.bb_pos,18);return u?(i||new e.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb_pos+u),this.bb):null}graphDocString(i){let u=this.bb.__offset(this.bb_pos,20);return u?this.bb.__string(this.bb_pos+u,i):null}static startModel(i){i.startObject(9)}static addIrVersion(i,u){i.addFieldInt64(0,u,i.createLong(0,0))}static addOpsetImport(i,u){i.addFieldOffset(1,u,0)}static createOpsetImportVector(i,u){i.startVector(4,u.length,4);for(let l=u.length-1;l>=0;l--)i.addOffset(u[l]);return i.endVector()}static startOpsetImportVector(i,u){i.startVector(4,u,4)}static addProducerName(i,u){i.addFieldOffset(2,u,0)}static addProducerVersion(i,u){i.addFieldOffset(3,u,0)}static addDomain(i,u){i.addFieldOffset(4,u,0)}static addModelVersion(i,u){i.addFieldInt64(5,u,i.createLong(0,0))}static addDocString(i,u){i.addFieldOffset(6,u,0)}static addGraph(i,u){i.addFieldOffset(7,u,0)}static addGraphDocString(i,u){i.addFieldOffset(8,u,0)}static endModel(i){return i.endObject()}static createModel(i,u,l,f,p,d,b,g,y,v){return n.startModel(i),n.addIrVersion(i,u),n.addOpsetImport(i,l),n.addProducerName(i,f),n.addProducerVersion(i,p),n.addDomain(i,d),n.addModelVersion(i,b),n.addDocString(i,g),n.addGraph(i,y),n.addGraphDocString(i,v),n.endModel(i)}}r.Model=n})(o=t.fbs||={})})(a=e.experimental||={})})(P||={});(e=>{let a;(t=>{let o;(r=>{class n{constructor(){this.bb=null;this.bb_pos=0}__init(i,u){return this.bb_pos=i,this.bb=u,this}static getRootAsKernelCreateInfos(i,u){return(u||new n).__init(i.readInt32(i.position())+i.position(),i)}static getSizePrefixedRootAsKernelCreateInfos(i,u){return i.setPosition(i.position()+m.SIZE_PREFIX_LENGTH),(u||new n).__init(i.readInt32(i.position())+i.position(),i)}nodeIndices(i){let u=this.bb.__offset(this.bb_pos,4);return u?this.bb.readUint32(this.bb.__vector(this.bb_pos+u)+i*4):0}nodeIndicesLength(){let i=this.bb.__offset(this.bb_pos,4);return i?this.bb.__vector_len(this.bb_pos+i):0}nodeIndicesArray(){let i=this.bb.__offset(this.bb_pos,4);return i?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+i),this.bb.__vector_len(this.bb_pos+i)):null}kernelDefHashes(i){let u=this.bb.__offset(this.bb_pos,6);return u?this.bb.readUint64(this.bb.__vector(this.bb_pos+u)+i*8):this.bb.createLong(0,0)}kernelDefHashesLength(){let i=this.bb.__offset(this.bb_pos,6);return i?this.bb.__vector_len(this.bb_pos+i):0}static startKernelCreateInfos(i){i.startObject(2)}static addNodeIndices(i,u){i.addFieldOffset(0,u,0)}static createNodeIndicesVector(i,u){i.startVector(4,u.length,4);for(let l=u.length-1;l>=0;l--)i.addInt32(u[l]);return i.endVector()}static startNodeIndicesVector(i,u){i.startVector(4,u,4)}static addKernelDefHashes(i,u){i.addFieldOffset(1,u,0)}static createKernelDefHashesVector(i,u){i.startVector(8,u.length,8);for(let l=u.length-1;l>=0;l--)i.addInt64(u[l]);return i.endVector()}static startKernelDefHashesVector(i,u){i.startVector(8,u,8)}static endKernelCreateInfos(i){return i.endObject()}static createKernelCreateInfos(i,u,l){return n.startKernelCreateInfos(i),n.addNodeIndices(i,u),n.addKernelDefHashes(i,l),n.endKernelCreateInfos(i)}}r.KernelCreateInfos=n})(o=t.fbs||={})})(a=e.experimental||={})})(P||={});(e=>{let a;(t=>{let o;(r=>{class n{constructor(){this.bb=null;this.bb_pos=0}__init(i,u){return this.bb_pos=i,this.bb=u,this}static getRootAsSubGraphSessionState(i,u){return(u||new n).__init(i.readInt32(i.position())+i.position(),i)}static getSizePrefixedRootAsSubGraphSessionState(i,u){return i.setPosition(i.position()+m.SIZE_PREFIX_LENGTH),(u||new n).__init(i.readInt32(i.position())+i.position(),i)}graphId(i){let u=this.bb.__offset(this.bb_pos,4);return u?this.bb.__string(this.bb_pos+u,i):null}sessionState(i){let u=this.bb.__offset(this.bb_pos,6);return u?(i||new e.experimental.fbs.SessionState).__init(this.bb.__indirect(this.bb_pos+u),this.bb):null}static startSubGraphSessionState(i){i.startObject(2)}static addGraphId(i,u){i.addFieldOffset(0,u,0)}static addSessionState(i,u){i.addFieldOffset(1,u,0)}static endSubGraphSessionState(i){let u=i.endObject();return i.requiredField(u,4),u}static createSubGraphSessionState(i,u,l){return n.startSubGraphSessionState(i),n.addGraphId(i,u),n.addSessionState(i,l),n.endSubGraphSessionState(i)}}r.SubGraphSessionState=n})(o=t.fbs||={})})(a=e.experimental||={})})(P||={});(e=>{let a;(t=>{let o;(r=>{class n{constructor(){this.bb=null;this.bb_pos=0}__init(i,u){return this.bb_pos=i,this.bb=u,this}static getRootAsSessionState(i,u){return(u||new n).__init(i.readInt32(i.position())+i.position(),i)}static getSizePrefixedRootAsSessionState(i,u){return i.setPosition(i.position()+m.SIZE_PREFIX_LENGTH),(u||new n).__init(i.readInt32(i.position())+i.position(),i)}kernels(i){let u=this.bb.__offset(this.bb_pos,4);return u?(i||new e.experimental.fbs.KernelCreateInfos).__init(this.bb.__indirect(this.bb_pos+u),this.bb):null}subGraphSessionStates(i,u){let l=this.bb.__offset(this.bb_pos,6);return l?(u||new e.experimental.fbs.SubGraphSessionState).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+l)+i*4),this.bb):null}subGraphSessionStatesLength(){let i=this.bb.__offset(this.bb_pos,6);return i?this.bb.__vector_len(this.bb_pos+i):0}static startSessionState(i){i.startObject(2)}static addKernels(i,u){i.addFieldOffset(0,u,0)}static addSubGraphSessionStates(i,u){i.addFieldOffset(1,u,0)}static createSubGraphSessionStatesVector(i,u){i.startVector(4,u.length,4);for(let l=u.length-1;l>=0;l--)i.addOffset(u[l]);return i.endVector()}static startSubGraphSessionStatesVector(i,u){i.startVector(4,u,4)}static endSessionState(i){return i.endObject()}static createSessionState(i,u,l){return n.startSessionState(i),n.addKernels(i,u),n.addSubGraphSessionStates(i,l),n.endSessionState(i)}}r.SessionState=n})(o=t.fbs||={})})(a=e.experimental||={})})(P||={});(e=>{let a;(t=>{let o;(r=>{class n{constructor(){this.bb=null;this.bb_pos=0}__init(i,u){return this.bb_pos=i,this.bb=u,this}static getRootAsInferenceSession(i,u){return(u||new n).__init(i.readInt32(i.position())+i.position(),i)}static getSizePrefixedRootAsInferenceSession(i,u){return i.setPosition(i.position()+m.SIZE_PREFIX_LENGTH),(u||new n).__init(i.readInt32(i.position())+i.position(),i)}static bufferHasIdentifier(i){return i.__has_identifier("ORTM")}ortVersion(i){let u=this.bb.__offset(this.bb_pos,4);return u?this.bb.__string(this.bb_pos+u,i):null}model(i){let u=this.bb.__offset(this.bb_pos,6);return u?(i||new e.experimental.fbs.Model).__init(this.bb.__indirect(this.bb_pos+u),this.bb):null}sessionState(i){let u=this.bb.__offset(this.bb_pos,8);return u?(i||new e.experimental.fbs.SessionState).__init(this.bb.__indirect(this.bb_pos+u),this.bb):null}static startInferenceSession(i){i.startObject(3)}static addOrtVersion(i,u){i.addFieldOffset(0,u,0)}static addModel(i,u){i.addFieldOffset(1,u,0)}static addSessionState(i,u){i.addFieldOffset(2,u,0)}static endInferenceSession(i){return i.endObject()}static finishInferenceSessionBuffer(i,u){i.finish(u,"ORTM")}static finishSizePrefixedInferenceSessionBuffer(i,u){i.finish(u,"ORTM",!0)}static createInferenceSession(i,u,l,f){return n.startInferenceSession(i),n.addOrtVersion(i,u),n.addModel(i,l),n.addSessionState(i,f),n.endInferenceSession(i)}}r.InferenceSession=n})(o=t.fbs||={})})(a=e.experimental||={})})(P||={})});var Mo=Z((lh,zo)=>{"use strict";zo.exports=Ml;function Ml(a,e){for(var o=new Array(arguments.length-1),t=0,n=2,r=!0;n<arguments.length;)o[t++]=arguments[n++];return new Promise(function(i,u){o[t]=function(f){if(r)if(r=!1,f)u(f);else{for(var p=new Array(arguments.length-1),d=0;d<p.length;)p[d++]=arguments[d];i.apply(null,p)}};try{a.apply(e||null,o)}catch(l){r&&(r=!1,u(l))}})}});var qo=Z(Ho=>{"use strict";var Ze=Ho;Ze.length=function(e){var o=e.length;if(!o)return 0;for(var t=0;--o%4>1&&e.charAt(o)==="=";)++t;return Math.ceil(e.length*3)/4-t};var ae=new Array(64),Wo=new Array(123);for(wt=0;wt<64;)Wo[ae[wt]=wt<26?wt+65:wt<52?wt+71:wt<62?wt-4:wt-59|43]=wt++;var wt;Ze.encode=function(e,o,t){for(var n=null,r=[],s=0,i=0,u;o<t;){var l=e[o++];switch(i){case 0:r[s++]=ae[l>>2],u=(l&3)<<4,i=1;break;case 1:r[s++]=ae[u|l>>4],u=(l&15)<<2,i=2;break;case 2:r[s++]=ae[u|l>>6],r[s++]=ae[l&63],i=0;break}s>8191&&((n||(n=[])).push(String.fromCharCode.apply(String,r)),s=0)}return i&&(r[s++]=ae[u],r[s++]=61,i===1&&(r[s++]=61)),n?(s&&n.push(String.fromCharCode.apply(String,r.slice(0,s))),n.join("")):String.fromCharCode.apply(String,r.slice(0,s))};var Uo="invalid encoding";Ze.decode=function(e,o,t){for(var n=t,r=0,s,i=0;i<e.length;){var u=e.charCodeAt(i++);if(u===61&&r>1)break;if((u=Wo[u])===void 0)throw Error(Uo);switch(r){case 0:s=u,r=1;break;case 1:o[t++]=s<<2|(u&48)>>4,s=u,r=2;break;case 2:o[t++]=(s&15)<<4|(u&60)>>2,s=u,r=3;break;case 3:o[t++]=(s&3)<<6|u,r=0;break}}if(r===1)throw Error(Uo);return t-n};Ze.test=function(e){return/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(e)}});var Ko=Z((ch,jo)=>{"use strict";jo.exports=Ye;function Ye(){this._listeners={}}Ye.prototype.on=function(e,o,t){return(this._listeners[e]||(this._listeners[e]=[])).push({fn:o,ctx:t||this}),this};Ye.prototype.off=function(e,o){if(e===void 0)this._listeners={};else if(o===void 0)this._listeners[e]=[];else for(var t=this._listeners[e],n=0;n<t.length;)t[n].fn===o?t.splice(n,1):++n;return this};Ye.prototype.emit=function(e){var o=this._listeners[e];if(o){for(var t=[],n=1;n<arguments.length;)t.push(arguments[n++]);for(n=0;n<o.length;)o[n].fn.apply(o[n++].ctx,t)}return this}});var ei=Z((ph,ti)=>{"use strict";ti.exports=Xo(Xo);function Xo(a){return typeof Float32Array<"u"?function(){var e=new Float32Array([-0]),o=new Uint8Array(e.buffer),t=o[3]===128;function n(u,l,f){e[0]=u,l[f]=o[0],l[f+1]=o[1],l[f+2]=o[2],l[f+3]=o[3]}function r(u,l,f){e[0]=u,l[f]=o[3],l[f+1]=o[2],l[f+2]=o[1],l[f+3]=o[0]}a.writeFloatLE=t?n:r,a.writeFloatBE=t?r:n;function s(u,l){return o[0]=u[l],o[1]=u[l+1],o[2]=u[l+2],o[3]=u[l+3],e[0]}function i(u,l){return o[3]=u[l],o[2]=u[l+1],o[1]=u[l+2],o[0]=u[l+3],e[0]}a.readFloatLE=t?s:i,a.readFloatBE=t?i:s}():function(){function e(t,n,r,s){var i=n<0?1:0;if(i&&(n=-n),n===0)t(1/n>0?0:2147483648,r,s);else if(isNaN(n))t(2143289344,r,s);else if(n>34028234663852886e22)t((i<<31|2139095040)>>>0,r,s);else if(n<11754943508222875e-54)t((i<<31|Math.round(n/1401298464324817e-60))>>>0,r,s);else{var u=Math.floor(Math.log(n)/Math.LN2),l=Math.round(n*Math.pow(2,-u)*8388608)&8388607;t((i<<31|u+127<<23|l)>>>0,r,s)}}a.writeFloatLE=e.bind(null,Jo),a.writeFloatBE=e.bind(null,Zo);function o(t,n,r){var s=t(n,r),i=(s>>31)*2+1,u=s>>>23&255,l=s&8388607;return u===255?l?NaN:i*(1/0):u===0?i*1401298464324817e-60*l:i*Math.pow(2,u-150)*(l+8388608)}a.readFloatLE=o.bind(null,Yo),a.readFloatBE=o.bind(null,Qo)}(),typeof Float64Array<"u"?function(){var e=new Float64Array([-0]),o=new Uint8Array(e.buffer),t=o[7]===128;function n(u,l,f){e[0]=u,l[f]=o[0],l[f+1]=o[1],l[f+2]=o[2],l[f+3]=o[3],l[f+4]=o[4],l[f+5]=o[5],l[f+6]=o[6],l[f+7]=o[7]}function r(u,l,f){e[0]=u,l[f]=o[7],l[f+1]=o[6],l[f+2]=o[5],l[f+3]=o[4],l[f+4]=o[3],l[f+5]=o[2],l[f+6]=o[1],l[f+7]=o[0]}a.writeDoubleLE=t?n:r,a.writeDoubleBE=t?r:n;function s(u,l){return o[0]=u[l],o[1]=u[l+1],o[2]=u[l+2],o[3]=u[l+3],o[4]=u[l+4],o[5]=u[l+5],o[6]=u[l+6],o[7]=u[l+7],e[0]}function i(u,l){return o[7]=u[l],o[6]=u[l+1],o[5]=u[l+2],o[4]=u[l+3],o[3]=u[l+4],o[2]=u[l+5],o[1]=u[l+6],o[0]=u[l+7],e[0]}a.readDoubleLE=t?s:i,a.readDoubleBE=t?i:s}():function(){function e(t,n,r,s,i,u){var l=s<0?1:0;if(l&&(s=-s),s===0)t(0,i,u+n),t(1/s>0?0:2147483648,i,u+r);else if(isNaN(s))t(0,i,u+n),t(2146959360,i,u+r);else if(s>17976931348623157e292)t(0,i,u+n),t((l<<31|2146435072)>>>0,i,u+r);else{var f;if(s<22250738585072014e-324)f=s/5e-324,t(f>>>0,i,u+n),t((l<<31|f/4294967296)>>>0,i,u+r);else{var p=Math.floor(Math.log(s)/Math.LN2);p===1024&&(p=1023),f=s*Math.pow(2,-p),t(f*4503599627370496>>>0,i,u+n),t((l<<31|p+1023<<20|f*1048576&1048575)>>>0,i,u+r)}}}a.writeDoubleLE=e.bind(null,Jo,0,4),a.writeDoubleBE=e.bind(null,Zo,4,0);function o(t,n,r,s,i){var u=t(s,i+n),l=t(s,i+r),f=(l>>31)*2+1,p=l>>>20&2047,d=4294967296*(l&1048575)+u;return p===2047?d?NaN:f*(1/0):p===0?f*5e-324*d:f*Math.pow(2,p-1075)*(d+4503599627370496)}a.readDoubleLE=o.bind(null,Yo,0,4),a.readDoubleBE=o.bind(null,Qo,4,0)}(),a}function Jo(a,e,o){e[o]=a&255,e[o+1]=a>>>8&255,e[o+2]=a>>>16&255,e[o+3]=a>>>24}function Zo(a,e,o){e[o]=a>>>24,e[o+1]=a>>>16&255,e[o+2]=a>>>8&255,e[o+3]=a&255}function Yo(a,e){return(a[e]|a[e+1]<<8|a[e+2]<<16|a[e+3]<<24)>>>0}function Qo(a,e){return(a[e]<<24|a[e+1]<<16|a[e+2]<<8|a[e+3])>>>0}});var ri=Z((exports,module)=>{"use strict";module.exports=inquire;function inquire(moduleName){try{var mod=eval("quire".replace(/^/,"re"))(moduleName);if(mod&&(mod.length||Object.keys(mod).length))return mod}catch(a){}return null}});var oi=Z(ni=>{"use strict";var qr=ni;qr.length=function(e){for(var o=0,t=0,n=0;n<e.length;++n)t=e.charCodeAt(n),t<128?o+=1:t<2048?o+=2:(t&64512)===55296&&(e.charCodeAt(n+1)&64512)===56320?(++n,o+=4):o+=3;return o};qr.read=function(e,o,t){var n=t-o;if(n<1)return"";for(var r=null,s=[],i=0,u;o<t;)u=e[o++],u<128?s[i++]=u:u>191&&u<224?s[i++]=(u&31)<<6|e[o++]&63:u>239&&u<365?(u=((u&7)<<18|(e[o++]&63)<<12|(e[o++]&63)<<6|e[o++]&63)-65536,s[i++]=55296+(u>>10),s[i++]=56320+(u&1023)):s[i++]=(u&15)<<12|(e[o++]&63)<<6|e[o++]&63,i>8191&&((r||(r=[])).push(String.fromCharCode.apply(String,s)),i=0);return r?(i&&r.push(String.fromCharCode.apply(String,s.slice(0,i))),r.join("")):String.fromCharCode.apply(String,s.slice(0,i))};qr.write=function(e,o,t){for(var n=t,r,s,i=0;i<e.length;++i)r=e.charCodeAt(i),r<128?o[t++]=r:r<2048?(o[t++]=r>>6|192,o[t++]=r&63|128):(r&64512)===55296&&((s=e.charCodeAt(i+1))&64512)===56320?(r=65536+((r&1023)<<10)+(s&1023),++i,o[t++]=r>>18|240,o[t++]=r>>12&63|128,o[t++]=r>>6&63|128,o[t++]=r&63|128):(o[t++]=r>>12|224,o[t++]=r>>6&63|128,o[t++]=r&63|128);return t-n}});var ai=Z((hh,ii)=>{"use strict";ii.exports=Ul;function Ul(a,e,o){var t=o||8192,n=t>>>1,r=null,s=t;return function(u){if(u<1||u>n)return a(u);s+u>t&&(r=a(t),s=0);var l=e.call(r,s,s+=u);return s&7&&(s=(s|7)+1),l}}});var ui=Z((mh,si)=>{"use strict";si.exports=Q;var we=Gt();function Q(a,e){this.lo=a>>>0,this.hi=e>>>0}var qt=Q.zero=new Q(0,0);qt.toNumber=function(){return 0};qt.zzEncode=qt.zzDecode=function(){return this};qt.length=function(){return 1};var Wl=Q.zeroHash="\0\0\0\0\0\0\0\0";Q.fromNumber=function(e){if(e===0)return qt;var o=e<0;o&&(e=-e);var t=e>>>0,n=(e-t)/4294967296>>>0;return o&&(n=~n>>>0,t=~t>>>0,++t>4294967295&&(t=0,++n>4294967295&&(n=0))),new Q(t,n)};Q.from=function(e){if(typeof e=="number")return Q.fromNumber(e);if(we.isString(e))if(we.Long)e=we.Long.fromString(e);else return Q.fromNumber(parseInt(e,10));return e.low||e.high?new Q(e.low>>>0,e.high>>>0):qt};Q.prototype.toNumber=function(e){if(!e&&this.hi>>>31){var o=~this.lo+1>>>0,t=~this.hi>>>0;return o||(t=t+1>>>0),-(o+t*4294967296)}return this.lo+this.hi*4294967296};Q.prototype.toLong=function(e){return we.Long?new we.Long(this.lo|0,this.hi|0,!!e):{low:this.lo|0,high:this.hi|0,unsigned:!!e}};var Ct=String.prototype.charCodeAt;Q.fromHash=function(e){return e===Wl?qt:new Q((Ct.call(e,0)|Ct.call(e,1)<<8|Ct.call(e,2)<<16|Ct.call(e,3)<<24)>>>0,(Ct.call(e,4)|Ct.call(e,5)<<8|Ct.call(e,6)<<16|Ct.call(e,7)<<24)>>>0)};Q.prototype.toHash=function(){return String.fromCharCode(this.lo&255,this.lo>>>8&255,this.lo>>>16&255,this.lo>>>24,this.hi&255,this.hi>>>8&255,this.hi>>>16&255,this.hi>>>24)};Q.prototype.zzEncode=function(){var e=this.hi>>31;return this.hi=((this.hi<<1|this.lo>>>31)^e)>>>0,this.lo=(this.lo<<1^e)>>>0,this};Q.prototype.zzDecode=function(){var e=-(this.lo&1);return this.lo=((this.lo>>>1|this.hi<<31)^e)>>>0,this.hi=(this.hi>>>1^e)>>>0,this};Q.prototype.length=function(){var e=this.lo,o=(this.lo>>>28|this.hi<<4)>>>0,t=this.hi>>>24;return t===0?o===0?e<16384?e<128?1:2:e<2097152?3:4:o<16384?o<128?5:6:o<2097152?7:8:t<128?9:10}});var Gt=Z(jr=>{"use strict";var E=jr;E.asPromise=Mo();E.base64=qo();E.EventEmitter=Ko();E.float=ei();E.inquire=ri();E.utf8=oi();E.pool=ai();E.LongBits=ui();E.isNode=!!(typeof global<"u"&&global&&global.process&&global.process.versions&&global.process.versions.node);E.global=E.isNode&&global||typeof window<"u"&&window||typeof self<"u"&&self||jr;E.emptyArray=Object.freeze?Object.freeze([]):[];E.emptyObject=Object.freeze?Object.freeze({}):{};E.isInteger=Number.isInteger||function(e){return typeof e=="number"&&isFinite(e)&&Math.floor(e)===e};E.isString=function(e){return typeof e=="string"||e instanceof String};E.isObject=function(e){return e&&typeof e=="object"};E.isset=E.isSet=function(e,o){var t=e[o];return t!=null&&e.hasOwnProperty(o)?typeof t!="object"||(Array.isArray(t)?t.length:Object.keys(t).length)>0:!1};E.Buffer=function(){try{var a=E.inquire("buffer").Buffer;return a.prototype.utf8Write?a:null}catch{return null}}();E._Buffer_from=null;E._Buffer_allocUnsafe=null;E.newBuffer=function(e){return typeof e=="number"?E.Buffer?E._Buffer_allocUnsafe(e):new E.Array(e):E.Buffer?E._Buffer_from(e):typeof Uint8Array>"u"?e:new Uint8Array(e)};E.Array=typeof Uint8Array<"u"?Uint8Array:Array;E.Long=E.global.dcodeIO&&E.global.dcodeIO.Long||E.global.Long||E.inquire("long");E.key2Re=/^true|false|0|1$/;E.key32Re=/^-?(?:0|[1-9][0-9]*)$/;E.key64Re=/^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;E.longToHash=function(e){return e?E.LongBits.from(e).toHash():E.LongBits.zeroHash};E.longFromHash=function(e,o){var t=E.LongBits.fromHash(e);return E.Long?E.Long.fromBits(t.lo,t.hi,o):t.toNumber(!!o)};function li(a,e,o){for(var t=Object.keys(e),n=0;n<t.length;++n)(a[t[n]]===void 0||!o)&&(a[t[n]]=e[t[n]]);return a}E.merge=li;E.lcFirst=function(e){return e.charAt(0).toLowerCase()+e.substring(1)};function fi(a){function e(o,t){if(!(this instanceof e))return new e(o,t);Object.defineProperty(this,"message",{get:function(){return o}}),Error.captureStackTrace?Error.captureStackTrace(this,e):Object.defineProperty(this,"stack",{value:new Error().stack||""}),t&&li(this,t)}return e.prototype=Object.create(Error.prototype,{constructor:{value:e,writable:!0,enumerable:!1,configurable:!0},name:{get:function(){return a},set:void 0,enumerable:!1,configurable:!0},toString:{value:function(){return this.name+": "+this.message},writable:!0,enumerable:!1,configurable:!0}}),e}E.newError=fi;E.ProtocolError=fi("ProtocolError");E.oneOfGetter=function(e){for(var o={},t=0;t<e.length;++t)o[e[t]]=1;return function(){for(var n=Object.keys(this),r=n.length-1;r>-1;--r)if(o[n[r]]===1&&this[n[r]]!==void 0&&this[n[r]]!==null)return n[r]}};E.oneOfSetter=function(e){return function(o){for(var t=0;t<e.length;++t)e[t]!==o&&delete this[e[t]]}};E.toJSONOptions={longs:String,enums:String,bytes:String,json:!0};E._configure=function(){var a=E.Buffer;if(!a){E._Buffer_from=E._Buffer_allocUnsafe=null;return}E._Buffer_from=a.from!==Uint8Array.from&&a.from||function(o,t){return new a(o,t)},E._Buffer_allocUnsafe=a.allocUnsafe||function(o){return new a(o)}}});var tn=Z((yh,hi)=>{"use strict";hi.exports=G;var mt=Gt(),Kr,Qe=mt.LongBits,ci=mt.base64,pi=mt.utf8;function Ie(a,e,o){this.fn=a,this.len=e,this.next=void 0,this.val=o}function Jr(){}function Hl(a){this.head=a.head,this.tail=a.tail,this.len=a.len,this.next=a.states}function G(){this.len=0,this.head=new Ie(Jr,0,0),this.tail=this.head,this.states=null}var di=function(){return mt.Buffer?function(){return(G.create=function(){return new Kr})()}:function(){return new G}};G.create=di();G.alloc=function(e){return new mt.Array(e)};mt.Array!==Array&&(G.alloc=mt.pool(G.alloc,mt.Array.prototype.subarray));G.prototype._push=function(e,o,t){return this.tail=this.tail.next=new Ie(e,o,t),this.len+=o,this};function Zr(a,e,o){e[o]=a&255}function ql(a,e,o){for(;a>127;)e[o++]=a&127|128,a>>>=7;e[o]=a}function Yr(a,e){this.len=a,this.next=void 0,this.val=e}Yr.prototype=Object.create(Ie.prototype);Yr.prototype.fn=ql;G.prototype.uint32=function(e){return this.len+=(this.tail=this.tail.next=new Yr((e=e>>>0)<128?1:e<16384?2:e<2097152?3:e<268435456?4:5,e)).len,this};G.prototype.int32=function(e){return e<0?this._push(Qr,10,Qe.fromNumber(e)):this.uint32(e)};G.prototype.sint32=function(e){return this.uint32((e<<1^e>>31)>>>0)};function Qr(a,e,o){for(;a.hi;)e[o++]=a.lo&127|128,a.lo=(a.lo>>>7|a.hi<<25)>>>0,a.hi>>>=7;for(;a.lo>127;)e[o++]=a.lo&127|128,a.lo=a.lo>>>7;e[o++]=a.lo}G.prototype.uint64=function(e){var o=Qe.from(e);return this._push(Qr,o.length(),o)};G.prototype.int64=G.prototype.uint64;G.prototype.sint64=function(e){var o=Qe.from(e).zzEncode();return this._push(Qr,o.length(),o)};G.prototype.bool=function(e){return this._push(Zr,1,e?1:0)};function Xr(a,e,o){e[o]=a&255,e[o+1]=a>>>8&255,e[o+2]=a>>>16&255,e[o+3]=a>>>24}G.prototype.fixed32=function(e){return this._push(Xr,4,e>>>0)};G.prototype.sfixed32=G.prototype.fixed32;G.prototype.fixed64=function(e){var o=Qe.from(e);return this._push(Xr,4,o.lo)._push(Xr,4,o.hi)};G.prototype.sfixed64=G.prototype.fixed64;G.prototype.float=function(e){return this._push(mt.float.writeFloatLE,4,e)};G.prototype.double=function(e){return this._push(mt.float.writeDoubleLE,8,e)};var jl=mt.Array.prototype.set?function(e,o,t){o.set(e,t)}:function(e,o,t){for(var n=0;n<e.length;++n)o[t+n]=e[n]};G.prototype.bytes=function(e){var o=e.length>>>0;if(!o)return this._push(Zr,1,0);if(mt.isString(e)){var t=G.alloc(o=ci.length(e));ci.decode(e,t,0),e=t}return this.uint32(o)._push(jl,o,e)};G.prototype.string=function(e){var o=pi.length(e);return o?this.uint32(o)._push(pi.write,o,e):this._push(Zr,1,0)};G.prototype.fork=function(){return this.states=new Hl(this),this.head=this.tail=new Ie(Jr,0,0),this.len=0,this};G.prototype.reset=function(){return this.states?(this.head=this.states.head,this.tail=this.states.tail,this.len=this.states.len,this.states=this.states.next):(this.head=this.tail=new Ie(Jr,0,0),this.len=0),this};G.prototype.ldelim=function(){var e=this.head,o=this.tail,t=this.len;return this.reset().uint32(t),t&&(this.tail.next=e.next,this.tail=o,this.len+=t),this};G.prototype.finish=function(){for(var e=this.head.next,o=this.constructor.alloc(this.len),t=0;e;)e.fn(e.val,o,t),t+=e.len,e=e.next;return o};G._configure=function(a){Kr=a,G.create=di(),Kr._configure()}});var yi=Z((gh,bi)=>{"use strict";bi.exports=Ot;var mi=tn();(Ot.prototype=Object.create(mi.prototype)).constructor=Ot;var Rt=Gt();function Ot(){mi.call(this)}Ot._configure=function(){Ot.alloc=Rt._Buffer_allocUnsafe,Ot.writeBytesBuffer=Rt.Buffer&&Rt.Buffer.prototype instanceof Uint8Array&&Rt.Buffer.prototype.set.name==="set"?function(e,o,t){o.set(e,t)}:function(e,o,t){if(e.copy)e.copy(o,t,0,e.length);else for(var n=0;n<e.length;)o[t++]=e[n++]}};Ot.prototype.bytes=function(e){Rt.isString(e)&&(e=Rt._Buffer_from(e,"base64"));var o=e.length>>>0;return this.uint32(o),o&&this._push(Ot.writeBytesBuffer,o,e),this};function Kl(a,e,o){a.length<40?Rt.utf8.write(a,e,o):e.utf8Write?e.utf8Write(a,o):e.write(a,o)}Ot.prototype.string=function(e){var o=Rt.Buffer.byteLength(e);return this.uint32(o),o&&this._push(Kl,o,e),this};Ot._configure()});var nn=Z((xh,wi)=>{"use strict";wi.exports=K;var It=Gt(),rn,Ti=It.LongBits,Xl=It.utf8;function _t(a,e){return RangeError("index out of range: "+a.pos+" + "+(e||1)+" > "+a.len)}function K(a){this.buf=a,this.pos=0,this.len=a.length}var gi=typeof Uint8Array<"u"?function(e){if(e instanceof Uint8Array||Array.isArray(e))return new K(e);throw Error("illegal buffer")}:function(e){if(Array.isArray(e))return new K(e);throw Error("illegal buffer")},vi=function(){return It.Buffer?function(o){return(K.create=function(n){return It.Buffer.isBuffer(n)?new rn(n):gi(n)})(o)}:gi};K.create=vi();K.prototype._slice=It.Array.prototype.subarray||It.Array.prototype.slice;K.prototype.uint32=function(){var e=4294967295;return function(){if(e=(this.buf[this.pos]&127)>>>0,this.buf[this.pos++]<128||(e=(e|(this.buf[this.pos]&127)<<7)>>>0,this.buf[this.pos++]<128)||(e=(e|(this.buf[this.pos]&127)<<14)>>>0,this.buf[this.pos++]<128)||(e=(e|(this.buf[this.pos]&127)<<21)>>>0,this.buf[this.pos++]<128)||(e=(e|(this.buf[this.pos]&15)<<28)>>>0,this.buf[this.pos++]<128))return e;if((this.pos+=5)>this.len)throw this.pos=this.len,_t(this,10);return e}}();K.prototype.int32=function(){return this.uint32()|0};K.prototype.sint32=function(){var e=this.uint32();return e>>>1^-(e&1)|0};function en(){var a=new Ti(0,0),e=0;if(this.len-this.pos>4){for(;e<4;++e)if(a.lo=(a.lo|(this.buf[this.pos]&127)<<e*7)>>>0,this.buf[this.pos++]<128)return a;if(a.lo=(a.lo|(this.buf[this.pos]&127)<<28)>>>0,a.hi=(a.hi|(this.buf[this.pos]&127)>>4)>>>0,this.buf[this.pos++]<128)return a;e=0}else{for(;e<3;++e){if(this.pos>=this.len)throw _t(this);if(a.lo=(a.lo|(this.buf[this.pos]&127)<<e*7)>>>0,this.buf[this.pos++]<128)return a}return a.lo=(a.lo|(this.buf[this.pos++]&127)<<e*7)>>>0,a}if(this.len-this.pos>4){for(;e<5;++e)if(a.hi=(a.hi|(this.buf[this.pos]&127)<<e*7+3)>>>0,this.buf[this.pos++]<128)return a}else for(;e<5;++e){if(this.pos>=this.len)throw _t(this);if(a.hi=(a.hi|(this.buf[this.pos]&127)<<e*7+3)>>>0,this.buf[this.pos++]<128)return a}throw Error("invalid varint encoding")}K.prototype.bool=function(){return this.uint32()!==0};function tr(a,e){return(a[e-4]|a[e-3]<<8|a[e-2]<<16|a[e-1]<<24)>>>0}K.prototype.fixed32=function(){if(this.pos+4>this.len)throw _t(this,4);return tr(this.buf,this.pos+=4)};K.prototype.sfixed32=function(){if(this.pos+4>this.len)throw _t(this,4);return tr(this.buf,this.pos+=4)|0};function xi(){if(this.pos+8>this.len)throw _t(this,8);return new Ti(tr(this.buf,this.pos+=4),tr(this.buf,this.pos+=4))}K.prototype.float=function(){if(this.pos+4>this.len)throw _t(this,4);var e=It.float.readFloatLE(this.buf,this.pos);return this.pos+=4,e};K.prototype.double=function(){if(this.pos+8>this.len)throw _t(this,4);var e=It.float.readDoubleLE(this.buf,this.pos);return this.pos+=8,e};K.prototype.bytes=function(){var e=this.uint32(),o=this.pos,t=this.pos+e;if(t>this.len)throw _t(this,e);if(this.pos+=e,Array.isArray(this.buf))return this.buf.slice(o,t);if(o===t){var n=It.Buffer;return n?n.alloc(0):new this.buf.constructor(0)}return this._slice.call(this.buf,o,t)};K.prototype.string=function(){var e=this.bytes();return Xl.read(e,0,e.length)};K.prototype.skip=function(e){if(typeof e=="number"){if(this.pos+e>this.len)throw _t(this,e);this.pos+=e}else do if(this.pos>=this.len)throw _t(this);while(this.buf[this.pos++]&128);return this};K.prototype.skipType=function(a){switch(a){case 0:this.skip();break;case 1:this.skip(8);break;case 2:this.skip(this.uint32());break;case 3:for(;(a=this.uint32()&7)!==4;)this.skipType(a);break;case 5:this.skip(4);break;default:throw Error("invalid wire type "+a+" at offset "+this.pos)}return this};K._configure=function(a){rn=a,K.create=vi(),rn._configure();var e=It.Long?"toLong":"toNumber";It.merge(K.prototype,{int64:function(){return en.call(this)[e](!1)},uint64:function(){return en.call(this)[e](!0)},sint64:function(){return en.call(this).zzDecode()[e](!1)},fixed64:function(){return xi.call(this)[e](!0)},sfixed64:function(){return xi.call(this)[e](!1)}})}});var Ai=Z((Th,Si)=>{"use strict";Si.exports=jt;var _i=nn();(jt.prototype=Object.create(_i.prototype)).constructor=jt;var Ii=Gt();function jt(a){_i.call(this,a)}jt._configure=function(){Ii.Buffer&&(jt.prototype._slice=Ii.Buffer.prototype.slice)};jt.prototype.string=function(){var e=this.uint32();return this.buf.utf8Slice?this.buf.utf8Slice(this.pos,this.pos=Math.min(this.pos+e,this.len)):this.buf.toString("utf-8",this.pos,this.pos=Math.min(this.pos+e,this.len))};jt._configure()});var Pi=Z((vh,Oi)=>{"use strict";Oi.exports=_e;var on=Gt();(_e.prototype=Object.create(on.EventEmitter.prototype)).constructor=_e;function _e(a,e,o){if(typeof a!="function")throw TypeError("rpcImpl must be a function");on.EventEmitter.call(this),this.rpcImpl=a,this.requestDelimited=!!e,this.responseDelimited=!!o}_e.prototype.rpcCall=function a(e,o,t,n,r){if(!n)throw TypeError("request must be specified");var s=this;if(!r)return on.asPromise(a,s,e,o,t,n);if(!s.rpcImpl){setTimeout(function(){r(Error("already ended"))},0);return}try{return s.rpcImpl(e,o[s.requestDelimited?"encodeDelimited":"encode"](n).finish(),function(u,l){if(u)return s.emit("error",u,e),r(u);if(l===null){s.end(!0);return}if(!(l instanceof t))try{l=t[s.responseDelimited?"decodeDelimited":"decode"](l)}catch(f){return s.emit("error",f,e),r(f)}return s.emit("data",l,e),r(null,l)})}catch(i){s.emit("error",i,e),setTimeout(function(){r(i)},0);return}};_e.prototype.end=function(e){return this.rpcImpl&&(e||this.rpcImpl(null,null,null),this.rpcImpl=null,this.emit("end").off()),this}});var Di=Z(Ei=>{"use strict";var Jl=Ei;Jl.Service=Pi()});var $i=Z((Ih,Li)=>{"use strict";Li.exports={}});var Fi=Z(Bi=>{"use strict";var lt=Bi;lt.build="minimal";lt.Writer=tn();lt.BufferWriter=yi();lt.Reader=nn();lt.BufferReader=Ai();lt.util=Gt();lt.rpc=Di();lt.roots=$i();lt.configure=ki;function ki(){lt.util._configure(),lt.Writer._configure(lt.BufferWriter),lt.Reader._configure(lt.BufferReader)}ki()});var Ci=Z((Sh,Ni)=>{"use strict";Ni.exports=Fi()});var se=Z((Ah,Gi)=>{"use strict";var W=Ci(),w=W.Reader,X=W.Writer,h=W.util,c=W.roots.default||(W.roots.default={});c.onnx=function(){var a={};return a.Version=function(){var e={},o=Object.create(e);return o[e[0]="_START_VERSION"]=0,o[e[1]="IR_VERSION_2017_10_10"]=1,o[e[2]="IR_VERSION_2017_10_30"]=2,o[e[3]="IR_VERSION_2017_11_3"]=3,o[e[4]="IR_VERSION_2019_1_22"]=4,o[e[5]="IR_VERSION_2019_3_18"]=5,o[e[6]="IR_VERSION_2019_9_19"]=6,o[e[7]="IR_VERSION_2020_5_8"]=7,o[e[8]="IR_VERSION_2021_7_30"]=8,o[e[9]="IR_VERSION"]=9,o}(),a.AttributeProto=function(){function e(o){if(this.floats=[],this.ints=[],this.strings=[],this.tensors=[],this.graphs=[],this.sparseTensors=[],this.typeProtos=[],o)for(var t=Object.keys(o),n=0;n<t.length;++n)o[t[n]]!=null&&(this[t[n]]=o[t[n]])}return e.prototype.name="",e.prototype.refAttrName="",e.prototype.docString="",e.prototype.type=0,e.prototype.f=0,e.prototype.i=h.Long?h.Long.fromBits(0,0,!1):0,e.prototype.s=h.newBuffer([]),e.prototype.t=null,e.prototype.g=null,e.prototype.sparseTensor=null,e.prototype.tp=null,e.prototype.floats=h.emptyArray,e.prototype.ints=h.emptyArray,e.prototype.strings=h.emptyArray,e.prototype.tensors=h.emptyArray,e.prototype.graphs=h.emptyArray,e.prototype.sparseTensors=h.emptyArray,e.prototype.typeProtos=h.emptyArray,e.create=function(t){return new e(t)},e.encode=function(t,n){if(n||(n=X.create()),t.name!=null&&Object.hasOwnProperty.call(t,"name")&&n.uint32(10).string(t.name),t.f!=null&&Object.hasOwnProperty.call(t,"f")&&n.uint32(21).float(t.f),t.i!=null&&Object.hasOwnProperty.call(t,"i")&&n.uint32(24).int64(t.i),t.s!=null&&Object.hasOwnProperty.call(t,"s")&&n.uint32(34).bytes(t.s),t.t!=null&&Object.hasOwnProperty.call(t,"t")&&c.onnx.TensorProto.encode(t.t,n.uint32(42).fork()).ldelim(),t.g!=null&&Object.hasOwnProperty.call(t,"g")&&c.onnx.GraphProto.encode(t.g,n.uint32(50).fork()).ldelim(),t.floats!=null&&t.floats.length){n.uint32(58).fork();for(var r=0;r<t.floats.length;++r)n.float(t.floats[r]);n.ldelim()}if(t.ints!=null&&t.ints.length){n.uint32(66).fork();for(var r=0;r<t.ints.length;++r)n.int64(t.ints[r]);n.ldelim()}if(t.strings!=null&&t.strings.length)for(var r=0;r<t.strings.length;++r)n.uint32(74).bytes(t.strings[r]);if(t.tensors!=null&&t.tensors.length)for(var r=0;r<t.tensors.length;++r)c.onnx.TensorProto.encode(t.tensors[r],n.uint32(82).fork()).ldelim();if(t.graphs!=null&&t.graphs.length)for(var r=0;r<t.graphs.length;++r)c.onnx.GraphProto.encode(t.graphs[r],n.uint32(90).fork()).ldelim();if(t.docString!=null&&Object.hasOwnProperty.call(t,"docString")&&n.uint32(106).string(t.docString),t.tp!=null&&Object.hasOwnProperty.call(t,"tp")&&c.onnx.TypeProto.encode(t.tp,n.uint32(114).fork()).ldelim(),t.typeProtos!=null&&t.typeProtos.length)for(var r=0;r<t.typeProtos.length;++r)c.onnx.TypeProto.encode(t.typeProtos[r],n.uint32(122).fork()).ldelim();if(t.type!=null&&Object.hasOwnProperty.call(t,"type")&&n.uint32(160).int32(t.type),t.refAttrName!=null&&Object.hasOwnProperty.call(t,"refAttrName")&&n.uint32(170).string(t.refAttrName),t.sparseTensor!=null&&Object.hasOwnProperty.call(t,"sparseTensor")&&c.onnx.SparseTensorProto.encode(t.sparseTensor,n.uint32(178).fork()).ldelim(),t.sparseTensors!=null&&t.sparseTensors.length)for(var r=0;r<t.sparseTensors.length;++r)c.onnx.SparseTensorProto.encode(t.sparseTensors[r],n.uint32(186).fork()).ldelim();return n},e.encodeDelimited=function(t,n){return this.encode(t,n).ldelim()},e.decode=function(t,n){t instanceof w||(t=w.create(t));for(var r=n===void 0?t.len:t.pos+n,s=new c.onnx.AttributeProto;t.pos<r;){var i=t.uint32();switch(i>>>3){case 1:{s.name=t.string();break}case 21:{s.refAttrName=t.string();break}case 13:{s.docString=t.string();break}case 20:{s.type=t.int32();break}case 2:{s.f=t.float();break}case 3:{s.i=t.int64();break}case 4:{s.s=t.bytes();break}case 5:{s.t=c.onnx.TensorProto.decode(t,t.uint32());break}case 6:{s.g=c.onnx.GraphProto.decode(t,t.uint32());break}case 22:{s.sparseTensor=c.onnx.SparseTensorProto.decode(t,t.uint32());break}case 14:{s.tp=c.onnx.TypeProto.decode(t,t.uint32());break}case 7:{if(s.floats&&s.floats.length||(s.floats=[]),(i&7)===2)for(var u=t.uint32()+t.pos;t.pos<u;)s.floats.push(t.float());else s.floats.push(t.float());break}case 8:{if(s.ints&&s.ints.length||(s.ints=[]),(i&7)===2)for(var u=t.uint32()+t.pos;t.pos<u;)s.ints.push(t.int64());else s.ints.push(t.int64());break}case 9:{s.strings&&s.strings.length||(s.strings=[]),s.strings.push(t.bytes());break}case 10:{s.tensors&&s.tensors.length||(s.tensors=[]),s.tensors.push(c.onnx.TensorProto.decode(t,t.uint32()));break}case 11:{s.graphs&&s.graphs.length||(s.graphs=[]),s.graphs.push(c.onnx.GraphProto.decode(t,t.uint32()));break}case 23:{s.sparseTensors&&s.sparseTensors.length||(s.sparseTensors=[]),s.sparseTensors.push(c.onnx.SparseTensorProto.decode(t,t.uint32()));break}case 15:{s.typeProtos&&s.typeProtos.length||(s.typeProtos=[]),s.typeProtos.push(c.onnx.TypeProto.decode(t,t.uint32()));break}default:t.skipType(i&7);break}}return s},e.decodeDelimited=function(t){return t instanceof w||(t=new w(t)),this.decode(t,t.uint32())},e.verify=function(t){if(typeof t!="object"||t===null)return"object expected";if(t.name!=null&&t.hasOwnProperty("name")&&!h.isString(t.name))return"name: string expected";if(t.refAttrName!=null&&t.hasOwnProperty("refAttrName")&&!h.isString(t.refAttrName))return"refAttrName: string expected";if(t.docString!=null&&t.hasOwnProperty("docString")&&!h.isString(t.docString))return"docString: string expected";if(t.type!=null&&t.hasOwnProperty("type"))switch(t.type){default:return"type: enum value expected";case 0:case 1:case 2:case 3:case 4:case 5:case 11:case 13:case 6:case 7:case 8:case 9:case 10:case 12:case 14:break}if(t.f!=null&&t.hasOwnProperty("f")&&typeof t.f!="number")return"f: number expected";if(t.i!=null&&t.hasOwnProperty("i")&&!h.isInteger(t.i)&&!(t.i&&h.isInteger(t.i.low)&&h.isInteger(t.i.high)))return"i: integer|Long expected";if(t.s!=null&&t.hasOwnProperty("s")&&!(t.s&&typeof t.s.length=="number"||h.isString(t.s)))return"s: buffer expected";if(t.t!=null&&t.hasOwnProperty("t")){var n=c.onnx.TensorProto.verify(t.t);if(n)return"t."+n}if(t.g!=null&&t.hasOwnProperty("g")){var n=c.onnx.GraphProto.verify(t.g);if(n)return"g."+n}if(t.sparseTensor!=null&&t.hasOwnProperty("sparseTensor")){var n=c.onnx.SparseTensorProto.verify(t.sparseTensor);if(n)return"sparseTensor."+n}if(t.tp!=null&&t.hasOwnProperty("tp")){var n=c.onnx.TypeProto.verify(t.tp);if(n)return"tp."+n}if(t.floats!=null&&t.hasOwnProperty("floats")){if(!Array.isArray(t.floats))return"floats: array expected";for(var r=0;r<t.floats.length;++r)if(typeof t.floats[r]!="number")return"floats: number[] expected"}if(t.ints!=null&&t.hasOwnProperty("ints")){if(!Array.isArray(t.ints))return"ints: array expected";for(var r=0;r<t.ints.length;++r)if(!h.isInteger(t.ints[r])&&!(t.ints[r]&&h.isInteger(t.ints[r].low)&&h.isInteger(t.ints[r].high)))return"ints: integer|Long[] expected"}if(t.strings!=null&&t.hasOwnProperty("strings")){if(!Array.isArray(t.strings))return"strings: array expected";for(var r=0;r<t.strings.length;++r)if(!(t.strings[r]&&typeof t.strings[r].length=="number"||h.isString(t.strings[r])))return"strings: buffer[] expected"}if(t.tensors!=null&&t.hasOwnProperty("tensors")){if(!Array.isArray(t.tensors))return"tensors: array expected";for(var r=0;r<t.tensors.length;++r){var n=c.onnx.TensorProto.verify(t.tensors[r]);if(n)return"tensors."+n}}if(t.graphs!=null&&t.hasOwnProperty("graphs")){if(!Array.isArray(t.graphs))return"graphs: array expected";for(var r=0;r<t.graphs.length;++r){var n=c.onnx.GraphProto.verify(t.graphs[r]);if(n)return"graphs."+n}}if(t.sparseTensors!=null&&t.hasOwnProperty("sparseTensors")){if(!Array.isArray(t.sparseTensors))return"sparseTensors: array expected";for(var r=0;r<t.sparseTensors.length;++r){var n=c.onnx.SparseTensorProto.verify(t.sparseTensors[r]);if(n)return"sparseTensors."+n}}if(t.typeProtos!=null&&t.hasOwnProperty("typeProtos")){if(!Array.isArray(t.typeProtos))return"typeProtos: array expected";for(var r=0;r<t.typeProtos.length;++r){var n=c.onnx.TypeProto.verify(t.typeProtos[r]);if(n)return"typeProtos."+n}}return null},e.fromObject=function(t){if(t instanceof c.onnx.AttributeProto)return t;var n=new c.onnx.AttributeProto;switch(t.name!=null&&(n.name=String(t.name)),t.refAttrName!=null&&(n.refAttrName=String(t.refAttrName)),t.docString!=null&&(n.docString=String(t.docString)),t.type){default:if(typeof t.type=="number"){n.type=t.type;break}break;case"UNDEFINED":case 0:n.type=0;break;case"FLOAT":case 1:n.type=1;break;case"INT":case 2:n.type=2;break;case"STRING":case 3:n.type=3;break;case"TENSOR":case 4:n.type=4;break;case"GRAPH":case 5:n.type=5;break;case"SPARSE_TENSOR":case 11:n.type=11;break;case"TYPE_PROTO":case 13:n.type=13;break;case"FLOATS":case 6:n.type=6;break;case"INTS":case 7:n.type=7;break;case"STRINGS":case 8:n.type=8;break;case"TENSORS":case 9:n.type=9;break;case"GRAPHS":case 10:n.type=10;break;case"SPARSE_TENSORS":case 12:n.type=12;break;case"TYPE_PROTOS":case 14:n.type=14;break}if(t.f!=null&&(n.f=Number(t.f)),t.i!=null&&(h.Long?(n.i=h.Long.fromValue(t.i)).unsigned=!1:typeof t.i=="string"?n.i=parseInt(t.i,10):typeof t.i=="number"?n.i=t.i:typeof t.i=="object"&&(n.i=new h.LongBits(t.i.low>>>0,t.i.high>>>0).toNumber())),t.s!=null&&(typeof t.s=="string"?h.base64.decode(t.s,n.s=h.newBuffer(h.base64.length(t.s)),0):t.s.length>=0&&(n.s=t.s)),t.t!=null){if(typeof t.t!="object")throw TypeError(".onnx.AttributeProto.t: object expected");n.t=c.onnx.TensorProto.fromObject(t.t)}if(t.g!=null){if(typeof t.g!="object")throw TypeError(".onnx.AttributeProto.g: object expected");n.g=c.onnx.GraphProto.fromObject(t.g)}if(t.sparseTensor!=null){if(typeof t.sparseTensor!="object")throw TypeError(".onnx.AttributeProto.sparseTensor: object expected");n.sparseTensor=c.onnx.SparseTensorProto.fromObject(t.sparseTensor)}if(t.tp!=null){if(typeof t.tp!="object")throw TypeError(".onnx.AttributeProto.tp: object expected");n.tp=c.onnx.TypeProto.fromObject(t.tp)}if(t.floats){if(!Array.isArray(t.floats))throw TypeError(".onnx.AttributeProto.floats: array expected");n.floats=[];for(var r=0;r<t.floats.length;++r)n.floats[r]=Number(t.floats[r])}if(t.ints){if(!Array.isArray(t.ints))throw TypeError(".onnx.AttributeProto.ints: array expected");n.ints=[];for(var r=0;r<t.ints.length;++r)h.Long?(n.ints[r]=h.Long.fromValue(t.ints[r])).unsigned=!1:typeof t.ints[r]=="string"?n.ints[r]=parseInt(t.ints[r],10):typeof t.ints[r]=="number"?n.ints[r]=t.ints[r]:typeof t.ints[r]=="object"&&(n.ints[r]=new h.LongBits(t.ints[r].low>>>0,t.ints[r].high>>>0).toNumber())}if(t.strings){if(!Array.isArray(t.strings))throw TypeError(".onnx.AttributeProto.strings: array expected");n.strings=[];for(var r=0;r<t.strings.length;++r)typeof t.strings[r]=="string"?h.base64.decode(t.strings[r],n.strings[r]=h.newBuffer(h.base64.length(t.strings[r])),0):t.strings[r].length>=0&&(n.strings[r]=t.strings[r])}if(t.tensors){if(!Array.isArray(t.tensors))throw TypeError(".onnx.AttributeProto.tensors: array expected");n.tensors=[];for(var r=0;r<t.tensors.length;++r){if(typeof t.tensors[r]!="object")throw TypeError(".onnx.AttributeProto.tensors: object expected");n.tensors[r]=c.onnx.TensorProto.fromObject(t.tensors[r])}}if(t.graphs){if(!Array.isArray(t.graphs))throw TypeError(".onnx.AttributeProto.graphs: array expected");n.graphs=[];for(var r=0;r<t.graphs.length;++r){if(typeof t.graphs[r]!="object")throw TypeError(".onnx.AttributeProto.graphs: object expected");n.graphs[r]=c.onnx.GraphProto.fromObject(t.graphs[r])}}if(t.sparseTensors){if(!Array.isArray(t.sparseTensors))throw TypeError(".onnx.AttributeProto.sparseTensors: array expected");n.sparseTensors=[];for(var r=0;r<t.sparseTensors.length;++r){if(typeof t.sparseTensors[r]!="object")throw TypeError(".onnx.AttributeProto.sparseTensors: object expected");n.sparseTensors[r]=c.onnx.SparseTensorProto.fromObject(t.sparseTensors[r])}}if(t.typeProtos){if(!Array.isArray(t.typeProtos))throw TypeError(".onnx.AttributeProto.typeProtos: array expected");n.typeProtos=[];for(var r=0;r<t.typeProtos.length;++r){if(typeof t.typeProtos[r]!="object")throw TypeError(".onnx.AttributeProto.typeProtos: object expected");n.typeProtos[r]=c.onnx.TypeProto.fromObject(t.typeProtos[r])}}return n},e.toObject=function(t,n){n||(n={});var r={};if((n.arrays||n.defaults)&&(r.floats=[],r.ints=[],r.strings=[],r.tensors=[],r.graphs=[],r.typeProtos=[],r.sparseTensors=[]),n.defaults){if(r.name="",r.f=0,h.Long){var s=new h.Long(0,0,!1);r.i=n.longs===String?s.toString():n.longs===Number?s.toNumber():s}else r.i=n.longs===String?"0":0;n.bytes===String?r.s="":(r.s=[],n.bytes!==Array&&(r.s=h.newBuffer(r.s))),r.t=null,r.g=null,r.docString="",r.tp=null,r.type=n.enums===String?"UNDEFINED":0,r.refAttrName="",r.sparseTensor=null}if(t.name!=null&&t.hasOwnProperty("name")&&(r.name=t.name),t.f!=null&&t.hasOwnProperty("f")&&(r.f=n.json&&!isFinite(t.f)?String(t.f):t.f),t.i!=null&&t.hasOwnProperty("i")&&(typeof t.i=="number"?r.i=n.longs===String?String(t.i):t.i:r.i=n.longs===String?h.Long.prototype.toString.call(t.i):n.longs===Number?new h.LongBits(t.i.low>>>0,t.i.high>>>0).toNumber():t.i),t.s!=null&&t.hasOwnProperty("s")&&(r.s=n.bytes===String?h.base64.encode(t.s,0,t.s.length):n.bytes===Array?Array.prototype.slice.call(t.s):t.s),t.t!=null&&t.hasOwnProperty("t")&&(r.t=c.onnx.TensorProto.toObject(t.t,n)),t.g!=null&&t.hasOwnProperty("g")&&(r.g=c.onnx.GraphProto.toObject(t.g,n)),t.floats&&t.floats.length){r.floats=[];for(var i=0;i<t.floats.length;++i)r.floats[i]=n.json&&!isFinite(t.floats[i])?String(t.floats[i]):t.floats[i]}if(t.ints&&t.ints.length){r.ints=[];for(var i=0;i<t.ints.length;++i)typeof t.ints[i]=="number"?r.ints[i]=n.longs===String?String(t.ints[i]):t.ints[i]:r.ints[i]=n.longs===String?h.Long.prototype.toString.call(t.ints[i]):n.longs===Number?new h.LongBits(t.ints[i].low>>>0,t.ints[i].high>>>0).toNumber():t.ints[i]}if(t.strings&&t.strings.length){r.strings=[];for(var i=0;i<t.strings.length;++i)r.strings[i]=n.bytes===String?h.base64.encode(t.strings[i],0,t.strings[i].length):n.bytes===Array?Array.prototype.slice.call(t.strings[i]):t.strings[i]}if(t.tensors&&t.tensors.length){r.tensors=[];for(var i=0;i<t.tensors.length;++i)r.tensors[i]=c.onnx.TensorProto.toObject(t.tensors[i],n)}if(t.graphs&&t.graphs.length){r.graphs=[];for(var i=0;i<t.graphs.length;++i)r.graphs[i]=c.onnx.GraphProto.toObject(t.graphs[i],n)}if(t.docString!=null&&t.hasOwnProperty("docString")&&(r.docString=t.docString),t.tp!=null&&t.hasOwnProperty("tp")&&(r.tp=c.onnx.TypeProto.toObject(t.tp,n)),t.typeProtos&&t.typeProtos.length){r.typeProtos=[];for(var i=0;i<t.typeProtos.length;++i)r.typeProtos[i]=c.onnx.TypeProto.toObject(t.typeProtos[i],n)}if(t.type!=null&&t.hasOwnProperty("type")&&(r.type=n.enums===String?c.onnx.AttributeProto.AttributeType[t.type]===void 0?t.type:c.onnx.AttributeProto.AttributeType[t.type]:t.type),t.refAttrName!=null&&t.hasOwnProperty("refAttrName")&&(r.refAttrName=t.refAttrName),t.sparseTensor!=null&&t.hasOwnProperty("sparseTensor")&&(r.sparseTensor=c.onnx.SparseTensorProto.toObject(t.sparseTensor,n)),t.sparseTensors&&t.sparseTensors.length){r.sparseTensors=[];for(var i=0;i<t.sparseTensors.length;++i)r.sparseTensors[i]=c.onnx.SparseTensorProto.toObject(t.sparseTensors[i],n)}return r},e.prototype.toJSON=function(){return this.constructor.toObject(this,W.util.toJSONOptions)},e.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.AttributeProto"},e.AttributeType=function(){var o={},t=Object.create(o);return t[o[0]="UNDEFINED"]=0,t[o[1]="FLOAT"]=1,t[o[2]="INT"]=2,t[o[3]="STRING"]=3,t[o[4]="TENSOR"]=4,t[o[5]="GRAPH"]=5,t[o[11]="SPARSE_TENSOR"]=11,t[o[13]="TYPE_PROTO"]=13,t[o[6]="FLOATS"]=6,t[o[7]="INTS"]=7,t[o[8]="STRINGS"]=8,t[o[9]="TENSORS"]=9,t[o[10]="GRAPHS"]=10,t[o[12]="SPARSE_TENSORS"]=12,t[o[14]="TYPE_PROTOS"]=14,t}(),e}(),a.ValueInfoProto=function(){function e(o){if(o)for(var t=Object.keys(o),n=0;n<t.length;++n)o[t[n]]!=null&&(this[t[n]]=o[t[n]])}return e.prototype.name="",e.prototype.type=null,e.prototype.docString="",e.create=function(t){return new e(t)},e.encode=function(t,n){return n||(n=X.create()),t.name!=null&&Object.hasOwnProperty.call(t,"name")&&n.uint32(10).string(t.name),t.type!=null&&Object.hasOwnProperty.call(t,"type")&&c.onnx.TypeProto.encode(t.type,n.uint32(18).fork()).ldelim(),t.docString!=null&&Object.hasOwnProperty.call(t,"docString")&&n.uint32(26).string(t.docString),n},e.encodeDelimited=function(t,n){return this.encode(t,n).ldelim()},e.decode=function(t,n){t instanceof w||(t=w.create(t));for(var r=n===void 0?t.len:t.pos+n,s=new c.onnx.ValueInfoProto;t.pos<r;){var i=t.uint32();switch(i>>>3){case 1:{s.name=t.string();break}case 2:{s.type=c.onnx.TypeProto.decode(t,t.uint32());break}case 3:{s.docString=t.string();break}default:t.skipType(i&7);break}}return s},e.decodeDelimited=function(t){return t instanceof w||(t=new w(t)),this.decode(t,t.uint32())},e.verify=function(t){if(typeof t!="object"||t===null)return"object expected";if(t.name!=null&&t.hasOwnProperty("name")&&!h.isString(t.name))return"name: string expected";if(t.type!=null&&t.hasOwnProperty("type")){var n=c.onnx.TypeProto.verify(t.type);if(n)return"type."+n}return t.docString!=null&&t.hasOwnProperty("docString")&&!h.isString(t.docString)?"docString: string expected":null},e.fromObject=function(t){if(t instanceof c.onnx.ValueInfoProto)return t;var n=new c.onnx.ValueInfoProto;if(t.name!=null&&(n.name=String(t.name)),t.type!=null){if(typeof t.type!="object")throw TypeError(".onnx.ValueInfoProto.type: object expected");n.type=c.onnx.TypeProto.fromObject(t.type)}return t.docString!=null&&(n.docString=String(t.docString)),n},e.toObject=function(t,n){n||(n={});var r={};return n.defaults&&(r.name="",r.type=null,r.docString=""),t.name!=null&&t.hasOwnProperty("name")&&(r.name=t.name),t.type!=null&&t.hasOwnProperty("type")&&(r.type=c.onnx.TypeProto.toObject(t.type,n)),t.docString!=null&&t.hasOwnProperty("docString")&&(r.docString=t.docString),r},e.prototype.toJSON=function(){return this.constructor.toObject(this,W.util.toJSONOptions)},e.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.ValueInfoProto"},e}(),a.NodeProto=function(){function e(o){if(this.input=[],this.output=[],this.attribute=[],o)for(var t=Object.keys(o),n=0;n<t.length;++n)o[t[n]]!=null&&(this[t[n]]=o[t[n]])}return e.prototype.input=h.emptyArray,e.prototype.output=h.emptyArray,e.prototype.name="",e.prototype.opType="",e.prototype.domain="",e.prototype.attribute=h.emptyArray,e.prototype.docString="",e.create=function(t){return new e(t)},e.encode=function(t,n){if(n||(n=X.create()),t.input!=null&&t.input.length)for(var r=0;r<t.input.length;++r)n.uint32(10).string(t.input[r]);if(t.output!=null&&t.output.length)for(var r=0;r<t.output.length;++r)n.uint32(18).string(t.output[r]);if(t.name!=null&&Object.hasOwnProperty.call(t,"name")&&n.uint32(26).string(t.name),t.opType!=null&&Object.hasOwnProperty.call(t,"opType")&&n.uint32(34).string(t.opType),t.attribute!=null&&t.attribute.length)for(var r=0;r<t.attribute.length;++r)c.onnx.AttributeProto.encode(t.attribute[r],n.uint32(42).fork()).ldelim();return t.docString!=null&&Object.hasOwnProperty.call(t,"docString")&&n.uint32(50).string(t.docString),t.domain!=null&&Object.hasOwnProperty.call(t,"domain")&&n.uint32(58).string(t.domain),n},e.encodeDelimited=function(t,n){return this.encode(t,n).ldelim()},e.decode=function(t,n){t instanceof w||(t=w.create(t));for(var r=n===void 0?t.len:t.pos+n,s=new c.onnx.NodeProto;t.pos<r;){var i=t.uint32();switch(i>>>3){case 1:{s.input&&s.input.length||(s.input=[]),s.input.push(t.string());break}case 2:{s.output&&s.output.length||(s.output=[]),s.output.push(t.string());break}case 3:{s.name=t.string();break}case 4:{s.opType=t.string();break}case 7:{s.domain=t.string();break}case 5:{s.attribute&&s.attribute.length||(s.attribute=[]),s.attribute.push(c.onnx.AttributeProto.decode(t,t.uint32()));break}case 6:{s.docString=t.string();break}default:t.skipType(i&7);break}}return s},e.decodeDelimited=function(t){return t instanceof w||(t=new w(t)),this.decode(t,t.uint32())},e.verify=function(t){if(typeof t!="object"||t===null)return"object expected";if(t.input!=null&&t.hasOwnProperty("input")){if(!Array.isArray(t.input))return"input: array expected";for(var n=0;n<t.input.length;++n)if(!h.isString(t.input[n]))return"input: string[] expected"}if(t.output!=null&&t.hasOwnProperty("output")){if(!Array.isArray(t.output))return"output: array expected";for(var n=0;n<t.output.length;++n)if(!h.isString(t.output[n]))return"output: string[] expected"}if(t.name!=null&&t.hasOwnProperty("name")&&!h.isString(t.name))return"name: string expected";if(t.opType!=null&&t.hasOwnProperty("opType")&&!h.isString(t.opType))return"opType: string expected";if(t.domain!=null&&t.hasOwnProperty("domain")&&!h.isString(t.domain))return"domain: string expected";if(t.attribute!=null&&t.hasOwnProperty("attribute")){if(!Array.isArray(t.attribute))return"attribute: array expected";for(var n=0;n<t.attribute.length;++n){var r=c.onnx.AttributeProto.verify(t.attribute[n]);if(r)return"attribute."+r}}return t.docString!=null&&t.hasOwnProperty("docString")&&!h.isString(t.docString)?"docString: string expected":null},e.fromObject=function(t){if(t instanceof c.onnx.NodeProto)return t;var n=new c.onnx.NodeProto;if(t.input){if(!Array.isArray(t.input))throw TypeError(".onnx.NodeProto.input: array expected");n.input=[];for(var r=0;r<t.input.length;++r)n.input[r]=String(t.input[r])}if(t.output){if(!Array.isArray(t.output))throw TypeError(".onnx.NodeProto.output: array expected");n.output=[];for(var r=0;r<t.output.length;++r)n.output[r]=String(t.output[r])}if(t.name!=null&&(n.name=String(t.name)),t.opType!=null&&(n.opType=String(t.opType)),t.domain!=null&&(n.domain=String(t.domain)),t.attribute){if(!Array.isArray(t.attribute))throw TypeError(".onnx.NodeProto.attribute: array expected");n.attribute=[];for(var r=0;r<t.attribute.length;++r){if(typeof t.attribute[r]!="object")throw TypeError(".onnx.NodeProto.attribute: object expected");n.attribute[r]=c.onnx.AttributeProto.fromObject(t.attribute[r])}}return t.docString!=null&&(n.docString=String(t.docString)),n},e.toObject=function(t,n){n||(n={});var r={};if((n.arrays||n.defaults)&&(r.input=[],r.output=[],r.attribute=[]),n.defaults&&(r.name="",r.opType="",r.docString="",r.domain=""),t.input&&t.input.length){r.input=[];for(var s=0;s<t.input.length;++s)r.input[s]=t.input[s]}if(t.output&&t.output.length){r.output=[];for(var s=0;s<t.output.length;++s)r.output[s]=t.output[s]}if(t.name!=null&&t.hasOwnProperty("name")&&(r.name=t.name),t.opType!=null&&t.hasOwnProperty("opType")&&(r.opType=t.opType),t.attribute&&t.attribute.length){r.attribute=[];for(var s=0;s<t.attribute.length;++s)r.attribute[s]=c.onnx.AttributeProto.toObject(t.attribute[s],n)}return t.docString!=null&&t.hasOwnProperty("docString")&&(r.docString=t.docString),t.domain!=null&&t.hasOwnProperty("domain")&&(r.domain=t.domain),r},e.prototype.toJSON=function(){return this.constructor.toObject(this,W.util.toJSONOptions)},e.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.NodeProto"},e}(),a.TrainingInfoProto=function(){function e(o){if(this.initializationBinding=[],this.updateBinding=[],o)for(var t=Object.keys(o),n=0;n<t.length;++n)o[t[n]]!=null&&(this[t[n]]=o[t[n]])}return e.prototype.initialization=null,e.prototype.algorithm=null,e.prototype.initializationBinding=h.emptyArray,e.prototype.updateBinding=h.emptyArray,e.create=function(t){return new e(t)},e.encode=function(t,n){if(n||(n=X.create()),t.initialization!=null&&Object.hasOwnProperty.call(t,"initialization")&&c.onnx.GraphProto.encode(t.initialization,n.uint32(10).fork()).ldelim(),t.algorithm!=null&&Object.hasOwnProperty.call(t,"algorithm")&&c.onnx.GraphProto.encode(t.algorithm,n.uint32(18).fork()).ldelim(),t.initializationBinding!=null&&t.initializationBinding.length)for(var r=0;r<t.initializationBinding.length;++r)c.onnx.StringStringEntryProto.encode(t.initializationBinding[r],n.uint32(26).fork()).ldelim();if(t.updateBinding!=null&&t.updateBinding.length)for(var r=0;r<t.updateBinding.length;++r)c.onnx.StringStringEntryProto.encode(t.updateBinding[r],n.uint32(34).fork()).ldelim();return n},e.encodeDelimited=function(t,n){return this.encode(t,n).ldelim()},e.decode=function(t,n){t instanceof w||(t=w.create(t));for(var r=n===void 0?t.len:t.pos+n,s=new c.onnx.TrainingInfoProto;t.pos<r;){var i=t.uint32();switch(i>>>3){case 1:{s.initialization=c.onnx.GraphProto.decode(t,t.uint32());break}case 2:{s.algorithm=c.onnx.GraphProto.decode(t,t.uint32());break}case 3:{s.initializationBinding&&s.initializationBinding.length||(s.initializationBinding=[]),s.initializationBinding.push(c.onnx.StringStringEntryProto.decode(t,t.uint32()));break}case 4:{s.updateBinding&&s.updateBinding.length||(s.updateBinding=[]),s.updateBinding.push(c.onnx.StringStringEntryProto.decode(t,t.uint32()));break}default:t.skipType(i&7);break}}return s},e.decodeDelimited=function(t){return t instanceof w||(t=new w(t)),this.decode(t,t.uint32())},e.verify=function(t){if(typeof t!="object"||t===null)return"object expected";if(t.initialization!=null&&t.hasOwnProperty("initialization")){var n=c.onnx.GraphProto.verify(t.initialization);if(n)return"initialization."+n}if(t.algorithm!=null&&t.hasOwnProperty("algorithm")){var n=c.onnx.GraphProto.verify(t.algorithm);if(n)return"algorithm."+n}if(t.initializationBinding!=null&&t.hasOwnProperty("initializationBinding")){if(!Array.isArray(t.initializationBinding))return"initializationBinding: array expected";for(var r=0;r<t.initializationBinding.length;++r){var n=c.onnx.StringStringEntryProto.verify(t.initializationBinding[r]);if(n)return"initializationBinding."+n}}if(t.updateBinding!=null&&t.hasOwnProperty("updateBinding")){if(!Array.isArray(t.updateBinding))return"updateBinding: array expected";for(var r=0;r<t.updateBinding.length;++r){var n=c.onnx.StringStringEntryProto.verify(t.updateBinding[r]);if(n)return"updateBinding."+n}}return null},e.fromObject=function(t){if(t instanceof c.onnx.TrainingInfoProto)return t;var n=new c.onnx.TrainingInfoProto;if(t.initialization!=null){if(typeof t.initialization!="object")throw TypeError(".onnx.TrainingInfoProto.initialization: object expected");n.initialization=c.onnx.GraphProto.fromObject(t.initialization)}if(t.algorithm!=null){if(typeof t.algorithm!="object")throw TypeError(".onnx.TrainingInfoProto.algorithm: object expected");n.algorithm=c.onnx.GraphProto.fromObject(t.algorithm)}if(t.initializationBinding){if(!Array.isArray(t.initializationBinding))throw TypeError(".onnx.TrainingInfoProto.initializationBinding: array expected");n.initializationBinding=[];for(var r=0;r<t.initializationBinding.length;++r){if(typeof t.initializationBinding[r]!="object")throw TypeError(".onnx.TrainingInfoProto.initializationBinding: object expected");n.initializationBinding[r]=c.onnx.StringStringEntryProto.fromObject(t.initializationBinding[r])}}if(t.updateBinding){if(!Array.isArray(t.updateBinding))throw TypeError(".onnx.TrainingInfoProto.updateBinding: array expected");n.updateBinding=[];for(var r=0;r<t.updateBinding.length;++r){if(typeof t.updateBinding[r]!="object")throw TypeError(".onnx.TrainingInfoProto.updateBinding: object expected");n.updateBinding[r]=c.onnx.StringStringEntryProto.fromObject(t.updateBinding[r])}}return n},e.toObject=function(t,n){n||(n={});var r={};if((n.arrays||n.defaults)&&(r.initializationBinding=[],r.updateBinding=[]),n.defaults&&(r.initialization=null,r.algorithm=null),t.initialization!=null&&t.hasOwnProperty("initialization")&&(r.initialization=c.onnx.GraphProto.toObject(t.initialization,n)),t.algorithm!=null&&t.hasOwnProperty("algorithm")&&(r.algorithm=c.onnx.GraphProto.toObject(t.algorithm,n)),t.initializationBinding&&t.initializationBinding.length){r.initializationBinding=[];for(var s=0;s<t.initializationBinding.length;++s)r.initializationBinding[s]=c.onnx.StringStringEntryProto.toObject(t.initializationBinding[s],n)}if(t.updateBinding&&t.updateBinding.length){r.updateBinding=[];for(var s=0;s<t.updateBinding.length;++s)r.updateBinding[s]=c.onnx.StringStringEntryProto.toObject(t.updateBinding[s],n)}return r},e.prototype.toJSON=function(){return this.constructor.toObject(this,W.util.toJSONOptions)},e.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.TrainingInfoProto"},e}(),a.ModelProto=function(){function e(o){if(this.opsetImport=[],this.metadataProps=[],this.trainingInfo=[],this.functions=[],o)for(var t=Object.keys(o),n=0;n<t.length;++n)o[t[n]]!=null&&(this[t[n]]=o[t[n]])}return e.prototype.irVersion=h.Long?h.Long.fromBits(0,0,!1):0,e.prototype.opsetImport=h.emptyArray,e.prototype.producerName="",e.prototype.producerVersion="",e.prototype.domain="",e.prototype.modelVersion=h.Long?h.Long.fromBits(0,0,!1):0,e.prototype.docString="",e.prototype.graph=null,e.prototype.metadataProps=h.emptyArray,e.prototype.trainingInfo=h.emptyArray,e.prototype.functions=h.emptyArray,e.create=function(t){return new e(t)},e.encode=function(t,n){if(n||(n=X.create()),t.irVersion!=null&&Object.hasOwnProperty.call(t,"irVersion")&&n.uint32(8).int64(t.irVersion),t.producerName!=null&&Object.hasOwnProperty.call(t,"producerName")&&n.uint32(18).string(t.producerName),t.producerVersion!=null&&Object.hasOwnProperty.call(t,"producerVersion")&&n.uint32(26).string(t.producerVersion),t.domain!=null&&Object.hasOwnProperty.call(t,"domain")&&n.uint32(34).string(t.domain),t.modelVersion!=null&&Object.hasOwnProperty.call(t,"modelVersion")&&n.uint32(40).int64(t.modelVersion),t.docString!=null&&Object.hasOwnProperty.call(t,"docString")&&n.uint32(50).string(t.docString),t.graph!=null&&Object.hasOwnProperty.call(t,"graph")&&c.onnx.GraphProto.encode(t.graph,n.uint32(58).fork()).ldelim(),t.opsetImport!=null&&t.opsetImport.length)for(var r=0;r<t.opsetImport.length;++r)c.onnx.OperatorSetIdProto.encode(t.opsetImport[r],n.uint32(66).fork()).ldelim();if(t.metadataProps!=null&&t.metadataProps.length)for(var r=0;r<t.metadataProps.length;++r)c.onnx.StringStringEntryProto.encode(t.metadataProps[r],n.uint32(114).fork()).ldelim();if(t.trainingInfo!=null&&t.trainingInfo.length)for(var r=0;r<t.trainingInfo.length;++r)c.onnx.TrainingInfoProto.encode(t.trainingInfo[r],n.uint32(162).fork()).ldelim();if(t.functions!=null&&t.functions.length)for(var r=0;r<t.functions.length;++r)c.onnx.FunctionProto.encode(t.functions[r],n.uint32(202).fork()).ldelim();return n},e.encodeDelimited=function(t,n){return this.encode(t,n).ldelim()},e.decode=function(t,n){t instanceof w||(t=w.create(t));for(var r=n===void 0?t.len:t.pos+n,s=new c.onnx.ModelProto;t.pos<r;){var i=t.uint32();switch(i>>>3){case 1:{s.irVersion=t.int64();break}case 8:{s.opsetImport&&s.opsetImport.length||(s.opsetImport=[]),s.opsetImport.push(c.onnx.OperatorSetIdProto.decode(t,t.uint32()));break}case 2:{s.producerName=t.string();break}case 3:{s.producerVersion=t.string();break}case 4:{s.domain=t.string();break}case 5:{s.modelVersion=t.int64();break}case 6:{s.docString=t.string();break}case 7:{s.graph=c.onnx.GraphProto.decode(t,t.uint32());break}case 14:{s.metadataProps&&s.metadataProps.length||(s.metadataProps=[]),s.metadataProps.push(c.onnx.StringStringEntryProto.decode(t,t.uint32()));break}case 20:{s.trainingInfo&&s.trainingInfo.length||(s.trainingInfo=[]),s.trainingInfo.push(c.onnx.TrainingInfoProto.decode(t,t.uint32()));break}case 25:{s.functions&&s.functions.length||(s.functions=[]),s.functions.push(c.onnx.FunctionProto.decode(t,t.uint32()));break}default:t.skipType(i&7);break}}return s},e.decodeDelimited=function(t){return t instanceof w||(t=new w(t)),this.decode(t,t.uint32())},e.verify=function(t){if(typeof t!="object"||t===null)return"object expected";if(t.irVersion!=null&&t.hasOwnProperty("irVersion")&&!h.isInteger(t.irVersion)&&!(t.irVersion&&h.isInteger(t.irVersion.low)&&h.isInteger(t.irVersion.high)))return"irVersion: integer|Long expected";if(t.opsetImport!=null&&t.hasOwnProperty("opsetImport")){if(!Array.isArray(t.opsetImport))return"opsetImport: array expected";for(var n=0;n<t.opsetImport.length;++n){var r=c.onnx.OperatorSetIdProto.verify(t.opsetImport[n]);if(r)return"opsetImport."+r}}if(t.producerName!=null&&t.hasOwnProperty("producerName")&&!h.isString(t.producerName))return"producerName: string expected";if(t.producerVersion!=null&&t.hasOwnProperty("producerVersion")&&!h.isString(t.producerVersion))return"producerVersion: string expected";if(t.domain!=null&&t.hasOwnProperty("domain")&&!h.isString(t.domain))return"domain: string expected";if(t.modelVersion!=null&&t.hasOwnProperty("modelVersion")&&!h.isInteger(t.modelVersion)&&!(t.modelVersion&&h.isInteger(t.modelVersion.low)&&h.isInteger(t.modelVersion.high)))return"modelVersion: integer|Long expected";if(t.docString!=null&&t.hasOwnProperty("docString")&&!h.isString(t.docString))return"docString: string expected";if(t.graph!=null&&t.hasOwnProperty("graph")){var r=c.onnx.GraphProto.verify(t.graph);if(r)return"graph."+r}if(t.metadataProps!=null&&t.hasOwnProperty("metadataProps")){if(!Array.isArray(t.metadataProps))return"metadataProps: array expected";for(var n=0;n<t.metadataProps.length;++n){var r=c.onnx.StringStringEntryProto.verify(t.metadataProps[n]);if(r)return"metadataProps."+r}}if(t.trainingInfo!=null&&t.hasOwnProperty("trainingInfo")){if(!Array.isArray(t.trainingInfo))return"trainingInfo: array expected";for(var n=0;n<t.trainingInfo.length;++n){var r=c.onnx.TrainingInfoProto.verify(t.trainingInfo[n]);if(r)return"trainingInfo."+r}}if(t.functions!=null&&t.hasOwnProperty("functions")){if(!Array.isArray(t.functions))return"functions: array expected";for(var n=0;n<t.functions.length;++n){var r=c.onnx.FunctionProto.verify(t.functions[n]);if(r)return"functions."+r}}return null},e.fromObject=function(t){if(t instanceof c.onnx.ModelProto)return t;var n=new c.onnx.ModelProto;if(t.irVersion!=null&&(h.Long?(n.irVersion=h.Long.fromValue(t.irVersion)).unsigned=!1:typeof t.irVersion=="string"?n.irVersion=parseInt(t.irVersion,10):typeof t.irVersion=="number"?n.irVersion=t.irVersion:typeof t.irVersion=="object"&&(n.irVersion=new h.LongBits(t.irVersion.low>>>0,t.irVersion.high>>>0).toNumber())),t.opsetImport){if(!Array.isArray(t.opsetImport))throw TypeError(".onnx.ModelProto.opsetImport: array expected");n.opsetImport=[];for(var r=0;r<t.opsetImport.length;++r){if(typeof t.opsetImport[r]!="object")throw TypeError(".onnx.ModelProto.opsetImport: object expected");n.opsetImport[r]=c.onnx.OperatorSetIdProto.fromObject(t.opsetImport[r])}}if(t.producerName!=null&&(n.producerName=String(t.producerName)),t.producerVersion!=null&&(n.producerVersion=String(t.producerVersion)),t.domain!=null&&(n.domain=String(t.domain)),t.modelVersion!=null&&(h.Long?(n.modelVersion=h.Long.fromValue(t.modelVersion)).unsigned=!1:typeof t.modelVersion=="string"?n.modelVersion=parseInt(t.modelVersion,10):typeof t.modelVersion=="number"?n.modelVersion=t.modelVersion:typeof t.modelVersion=="object"&&(n.modelVersion=new h.LongBits(t.modelVersion.low>>>0,t.modelVersion.high>>>0).toNumber())),t.docString!=null&&(n.docString=String(t.docString)),t.graph!=null){if(typeof t.graph!="object")throw TypeError(".onnx.ModelProto.graph: object expected");n.graph=c.onnx.GraphProto.fromObject(t.graph)}if(t.metadataProps){if(!Array.isArray(t.metadataProps))throw TypeError(".onnx.ModelProto.metadataProps: array expected");n.metadataProps=[];for(var r=0;r<t.metadataProps.length;++r){if(typeof t.metadataProps[r]!="object")throw TypeError(".onnx.ModelProto.metadataProps: object expected");n.metadataProps[r]=c.onnx.StringStringEntryProto.fromObject(t.metadataProps[r])}}if(t.trainingInfo){if(!Array.isArray(t.trainingInfo))throw TypeError(".onnx.ModelProto.trainingInfo: array expected");n.trainingInfo=[];for(var r=0;r<t.trainingInfo.length;++r){if(typeof t.trainingInfo[r]!="object")throw TypeError(".onnx.ModelProto.trainingInfo: object expected");n.trainingInfo[r]=c.onnx.TrainingInfoProto.fromObject(t.trainingInfo[r])}}if(t.functions){if(!Array.isArray(t.functions))throw TypeError(".onnx.ModelProto.functions: array expected");n.functions=[];for(var r=0;r<t.functions.length;++r){if(typeof t.functions[r]!="object")throw TypeError(".onnx.ModelProto.functions: object expected");n.functions[r]=c.onnx.FunctionProto.fromObject(t.functions[r])}}return n},e.toObject=function(t,n){n||(n={});var r={};if((n.arrays||n.defaults)&&(r.opsetImport=[],r.metadataProps=[],r.trainingInfo=[],r.functions=[]),n.defaults){if(h.Long){var s=new h.Long(0,0,!1);r.irVersion=n.longs===String?s.toString():n.longs===Number?s.toNumber():s}else r.irVersion=n.longs===String?"0":0;if(r.producerName="",r.producerVersion="",r.domain="",h.Long){var s=new h.Long(0,0,!1);r.modelVersion=n.longs===String?s.toString():n.longs===Number?s.toNumber():s}else r.modelVersion=n.longs===String?"0":0;r.docString="",r.graph=null}if(t.irVersion!=null&&t.hasOwnProperty("irVersion")&&(typeof t.irVersion=="number"?r.irVersion=n.longs===String?String(t.irVersion):t.irVersion:r.irVersion=n.longs===String?h.Long.prototype.toString.call(t.irVersion):n.longs===Number?new h.LongBits(t.irVersion.low>>>0,t.irVersion.high>>>0).toNumber():t.irVersion),t.producerName!=null&&t.hasOwnProperty("producerName")&&(r.producerName=t.producerName),t.producerVersion!=null&&t.hasOwnProperty("producerVersion")&&(r.producerVersion=t.producerVersion),t.domain!=null&&t.hasOwnProperty("domain")&&(r.domain=t.domain),t.modelVersion!=null&&t.hasOwnProperty("modelVersion")&&(typeof t.modelVersion=="number"?r.modelVersion=n.longs===String?String(t.modelVersion):t.modelVersion:r.modelVersion=n.longs===String?h.Long.prototype.toString.call(t.modelVersion):n.longs===Number?new h.LongBits(t.modelVersion.low>>>0,t.modelVersion.high>>>0).toNumber():t.modelVersion),t.docString!=null&&t.hasOwnProperty("docString")&&(r.docString=t.docString),t.graph!=null&&t.hasOwnProperty("graph")&&(r.graph=c.onnx.GraphProto.toObject(t.graph,n)),t.opsetImport&&t.opsetImport.length){r.opsetImport=[];for(var i=0;i<t.opsetImport.length;++i)r.opsetImport[i]=c.onnx.OperatorSetIdProto.toObject(t.opsetImport[i],n)}if(t.metadataProps&&t.metadataProps.length){r.metadataProps=[];for(var i=0;i<t.metadataProps.length;++i)r.metadataProps[i]=c.onnx.StringStringEntryProto.toObject(t.metadataProps[i],n)}if(t.trainingInfo&&t.trainingInfo.length){r.trainingInfo=[];for(var i=0;i<t.trainingInfo.length;++i)r.trainingInfo[i]=c.onnx.TrainingInfoProto.toObject(t.trainingInfo[i],n)}if(t.functions&&t.functions.length){r.functions=[];for(var i=0;i<t.functions.length;++i)r.functions[i]=c.onnx.FunctionProto.toObject(t.functions[i],n)}return r},e.prototype.toJSON=function(){return this.constructor.toObject(this,W.util.toJSONOptions)},e.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.ModelProto"},e}(),a.StringStringEntryProto=function(){function e(o){if(o)for(var t=Object.keys(o),n=0;n<t.length;++n)o[t[n]]!=null&&(this[t[n]]=o[t[n]])}return e.prototype.key="",e.prototype.value="",e.create=function(t){return new e(t)},e.encode=function(t,n){return n||(n=X.create()),t.key!=null&&Object.hasOwnProperty.call(t,"key")&&n.uint32(10).string(t.key),t.value!=null&&Object.hasOwnProperty.call(t,"value")&&n.uint32(18).string(t.value),n},e.encodeDelimited=function(t,n){return this.encode(t,n).ldelim()},e.decode=function(t,n){t instanceof w||(t=w.create(t));for(var r=n===void 0?t.len:t.pos+n,s=new c.onnx.StringStringEntryProto;t.pos<r;){var i=t.uint32();switch(i>>>3){case 1:{s.key=t.string();break}case 2:{s.value=t.string();break}default:t.skipType(i&7);break}}return s},e.decodeDelimited=function(t){return t instanceof w||(t=new w(t)),this.decode(t,t.uint32())},e.verify=function(t){return typeof t!="object"||t===null?"object expected":t.key!=null&&t.hasOwnProperty("key")&&!h.isString(t.key)?"key: string expected":t.value!=null&&t.hasOwnProperty("value")&&!h.isString(t.value)?"value: string expected":null},e.fromObject=function(t){if(t instanceof c.onnx.StringStringEntryProto)return t;var n=new c.onnx.StringStringEntryProto;return t.key!=null&&(n.key=String(t.key)),t.value!=null&&(n.value=String(t.value)),n},e.toObject=function(t,n){n||(n={});var r={};return n.defaults&&(r.key="",r.value=""),t.key!=null&&t.hasOwnProperty("key")&&(r.key=t.key),t.value!=null&&t.hasOwnProperty("value")&&(r.value=t.value),r},e.prototype.toJSON=function(){return this.constructor.toObject(this,W.util.toJSONOptions)},e.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.StringStringEntryProto"},e}(),a.TensorAnnotation=function(){function e(o){if(this.quantParameterTensorNames=[],o)for(var t=Object.keys(o),n=0;n<t.length;++n)o[t[n]]!=null&&(this[t[n]]=o[t[n]])}return e.prototype.tensorName="",e.prototype.quantParameterTensorNames=h.emptyArray,e.create=function(t){return new e(t)},e.encode=function(t,n){if(n||(n=X.create()),t.tensorName!=null&&Object.hasOwnProperty.call(t,"tensorName")&&n.uint32(10).string(t.tensorName),t.quantParameterTensorNames!=null&&t.quantParameterTensorNames.length)for(var r=0;r<t.quantParameterTensorNames.length;++r)c.onnx.StringStringEntryProto.encode(t.quantParameterTensorNames[r],n.uint32(18).fork()).ldelim();return n},e.encodeDelimited=function(t,n){return this.encode(t,n).ldelim()},e.decode=function(t,n){t instanceof w||(t=w.create(t));for(var r=n===void 0?t.len:t.pos+n,s=new c.onnx.TensorAnnotation;t.pos<r;){var i=t.uint32();switch(i>>>3){case 1:{s.tensorName=t.string();break}case 2:{s.quantParameterTensorNames&&s.quantParameterTensorNames.length||(s.quantParameterTensorNames=[]),s.quantParameterTensorNames.push(c.onnx.StringStringEntryProto.decode(t,t.uint32()));break}default:t.skipType(i&7);break}}return s},e.decodeDelimited=function(t){return t instanceof w||(t=new w(t)),this.decode(t,t.uint32())},e.verify=function(t){if(typeof t!="object"||t===null)return"object expected";if(t.tensorName!=null&&t.hasOwnProperty("tensorName")&&!h.isString(t.tensorName))return"tensorName: string expected";if(t.quantParameterTensorNames!=null&&t.hasOwnProperty("quantParameterTensorNames")){if(!Array.isArray(t.quantParameterTensorNames))return"quantParameterTensorNames: array expected";for(var n=0;n<t.quantParameterTensorNames.length;++n){var r=c.onnx.StringStringEntryProto.verify(t.quantParameterTensorNames[n]);if(r)return"quantParameterTensorNames."+r}}return null},e.fromObject=function(t){if(t instanceof c.onnx.TensorAnnotation)return t;var n=new c.onnx.TensorAnnotation;if(t.tensorName!=null&&(n.tensorName=String(t.tensorName)),t.quantParameterTensorNames){if(!Array.isArray(t.quantParameterTensorNames))throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: array expected");n.quantParameterTensorNames=[];for(var r=0;r<t.quantParameterTensorNames.length;++r){if(typeof t.quantParameterTensorNames[r]!="object")throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: object expected");n.quantParameterTensorNames[r]=c.onnx.StringStringEntryProto.fromObject(t.quantParameterTensorNames[r])}}return n},e.toObject=function(t,n){n||(n={});var r={};if((n.arrays||n.defaults)&&(r.quantParameterTensorNames=[]),n.defaults&&(r.tensorName=""),t.tensorName!=null&&t.hasOwnProperty("tensorName")&&(r.tensorName=t.tensorName),t.quantParameterTensorNames&&t.quantParameterTensorNames.length){r.quantParameterTensorNames=[];for(var s=0;s<t.quantParameterTensorNames.length;++s)r.quantParameterTensorNames[s]=c.onnx.StringStringEntryProto.toObject(t.quantParameterTensorNames[s],n)}return r},e.prototype.toJSON=function(){return this.constructor.toObject(this,W.util.toJSONOptions)},e.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.TensorAnnotation"},e}(),a.GraphProto=function(){function e(o){if(this.node=[],this.initializer=[],this.sparseInitializer=[],this.input=[],this.output=[],this.valueInfo=[],this.quantizationAnnotation=[],o)for(var t=Object.keys(o),n=0;n<t.length;++n)o[t[n]]!=null&&(this[t[n]]=o[t[n]])}return e.prototype.node=h.emptyArray,e.prototype.name="",e.prototype.initializer=h.emptyArray,e.prototype.sparseInitializer=h.emptyArray,e.prototype.docString="",e.prototype.input=h.emptyArray,e.prototype.output=h.emptyArray,e.prototype.valueInfo=h.emptyArray,e.prototype.quantizationAnnotation=h.emptyArray,e.create=function(t){return new e(t)},e.encode=function(t,n){if(n||(n=X.create()),t.node!=null&&t.node.length)for(var r=0;r<t.node.length;++r)c.onnx.NodeProto.encode(t.node[r],n.uint32(10).fork()).ldelim();if(t.name!=null&&Object.hasOwnProperty.call(t,"name")&&n.uint32(18).string(t.name),t.initializer!=null&&t.initializer.length)for(var r=0;r<t.initializer.length;++r)c.onnx.TensorProto.encode(t.initializer[r],n.uint32(42).fork()).ldelim();if(t.docString!=null&&Object.hasOwnProperty.call(t,"docString")&&n.uint32(82).string(t.docString),t.input!=null&&t.input.length)for(var r=0;r<t.input.length;++r)c.onnx.ValueInfoProto.encode(t.input[r],n.uint32(90).fork()).ldelim();if(t.output!=null&&t.output.length)for(var r=0;r<t.output.length;++r)c.onnx.ValueInfoProto.encode(t.output[r],n.uint32(98).fork()).ldelim();if(t.valueInfo!=null&&t.valueInfo.length)for(var r=0;r<t.valueInfo.length;++r)c.onnx.ValueInfoProto.encode(t.valueInfo[r],n.uint32(106).fork()).ldelim();if(t.quantizationAnnotation!=null&&t.quantizationAnnotation.length)for(var r=0;r<t.quantizationAnnotation.length;++r)c.onnx.TensorAnnotation.encode(t.quantizationAnnotation[r],n.uint32(114).fork()).ldelim();if(t.sparseInitializer!=null&&t.sparseInitializer.length)for(var r=0;r<t.sparseInitializer.length;++r)c.onnx.SparseTensorProto.encode(t.sparseInitializer[r],n.uint32(122).fork()).ldelim();return n},e.encodeDelimited=function(t,n){return this.encode(t,n).ldelim()},e.decode=function(t,n){t instanceof w||(t=w.create(t));for(var r=n===void 0?t.len:t.pos+n,s=new c.onnx.GraphProto;t.pos<r;){var i=t.uint32();switch(i>>>3){case 1:{s.node&&s.node.length||(s.node=[]),s.node.push(c.onnx.NodeProto.decode(t,t.uint32()));break}case 2:{s.name=t.string();break}case 5:{s.initializer&&s.initializer.length||(s.initializer=[]),s.initializer.push(c.onnx.TensorProto.decode(t,t.uint32()));break}case 15:{s.sparseInitializer&&s.sparseInitializer.length||(s.sparseInitializer=[]),s.sparseInitializer.push(c.onnx.SparseTensorProto.decode(t,t.uint32()));break}case 10:{s.docString=t.string();break}case 11:{s.input&&s.input.length||(s.input=[]),s.input.push(c.onnx.ValueInfoProto.decode(t,t.uint32()));break}case 12:{s.output&&s.output.length||(s.output=[]),s.output.push(c.onnx.ValueInfoProto.decode(t,t.uint32()));break}case 13:{s.valueInfo&&s.valueInfo.length||(s.valueInfo=[]),s.valueInfo.push(c.onnx.ValueInfoProto.decode(t,t.uint32()));break}case 14:{s.quantizationAnnotation&&s.quantizationAnnotation.length||(s.quantizationAnnotation=[]),s.quantizationAnnotation.push(c.onnx.TensorAnnotation.decode(t,t.uint32()));break}default:t.skipType(i&7);break}}return s},e.decodeDelimited=function(t){return t instanceof w||(t=new w(t)),this.decode(t,t.uint32())},e.verify=function(t){if(typeof t!="object"||t===null)return"object expected";if(t.node!=null&&t.hasOwnProperty("node")){if(!Array.isArray(t.node))return"node: array expected";for(var n=0;n<t.node.length;++n){var r=c.onnx.NodeProto.verify(t.node[n]);if(r)return"node."+r}}if(t.name!=null&&t.hasOwnProperty("name")&&!h.isString(t.name))return"name: string expected";if(t.initializer!=null&&t.hasOwnProperty("initializer")){if(!Array.isArray(t.initializer))return"initializer: array expected";for(var n=0;n<t.initializer.length;++n){var r=c.onnx.TensorProto.verify(t.initializer[n]);if(r)return"initializer."+r}}if(t.sparseInitializer!=null&&t.hasOwnProperty("sparseInitializer")){if(!Array.isArray(t.sparseInitializer))return"sparseInitializer: array expected";for(var n=0;n<t.sparseInitializer.length;++n){var r=c.onnx.SparseTensorProto.verify(t.sparseInitializer[n]);if(r)return"sparseInitializer."+r}}if(t.docString!=null&&t.hasOwnProperty("docString")&&!h.isString(t.docString))return"docString: string expected";if(t.input!=null&&t.hasOwnProperty("input")){if(!Array.isArray(t.input))return"input: array expected";for(var n=0;n<t.input.length;++n){var r=c.onnx.ValueInfoProto.verify(t.input[n]);if(r)return"input."+r}}if(t.output!=null&&t.hasOwnProperty("output")){if(!Array.isArray(t.output))return"output: array expected";for(var n=0;n<t.output.length;++n){var r=c.onnx.ValueInfoProto.verify(t.output[n]);if(r)return"output."+r}}if(t.valueInfo!=null&&t.hasOwnProperty("valueInfo")){if(!Array.isArray(t.valueInfo))return"valueInfo: array expected";for(var n=0;n<t.valueInfo.length;++n){var r=c.onnx.ValueInfoProto.verify(t.valueInfo[n]);if(r)return"valueInfo."+r}}if(t.quantizationAnnotation!=null&&t.hasOwnProperty("quantizationAnnotation")){if(!Array.isArray(t.quantizationAnnotation))return"quantizationAnnotation: array expected";for(var n=0;n<t.quantizationAnnotation.length;++n){var r=c.onnx.TensorAnnotation.verify(t.quantizationAnnotation[n]);if(r)return"quantizationAnnotation."+r}}return null},e.fromObject=function(t){if(t instanceof c.onnx.GraphProto)return t;var n=new c.onnx.GraphProto;if(t.node){if(!Array.isArray(t.node))throw TypeError(".onnx.GraphProto.node: array expected");n.node=[];for(var r=0;r<t.node.length;++r){if(typeof t.node[r]!="object")throw TypeError(".onnx.GraphProto.node: object expected");n.node[r]=c.onnx.NodeProto.fromObject(t.node[r])}}if(t.name!=null&&(n.name=String(t.name)),t.initializer){if(!Array.isArray(t.initializer))throw TypeError(".onnx.GraphProto.initializer: array expected");n.initializer=[];for(var r=0;r<t.initializer.length;++r){if(typeof t.initializer[r]!="object")throw TypeError(".onnx.GraphProto.initializer: object expected");n.initializer[r]=c.onnx.TensorProto.fromObject(t.initializer[r])}}if(t.sparseInitializer){if(!Array.isArray(t.sparseInitializer))throw TypeError(".onnx.GraphProto.sparseInitializer: array expected");n.sparseInitializer=[];for(var r=0;r<t.sparseInitializer.length;++r){if(typeof t.sparseInitializer[r]!="object")throw TypeError(".onnx.GraphProto.sparseInitializer: object expected");n.sparseInitializer[r]=c.onnx.SparseTensorProto.fromObject(t.sparseInitializer[r])}}if(t.docString!=null&&(n.docString=String(t.docString)),t.input){if(!Array.isArray(t.input))throw TypeError(".onnx.GraphProto.input: array expected");n.input=[];for(var r=0;r<t.input.length;++r){if(typeof t.input[r]!="object")throw TypeError(".onnx.GraphProto.input: object expected");n.input[r]=c.onnx.ValueInfoProto.fromObject(t.input[r])}}if(t.output){if(!Array.isArray(t.output))throw TypeError(".onnx.GraphProto.output: array expected");n.output=[];for(var r=0;r<t.output.length;++r){if(typeof t.output[r]!="object")throw TypeError(".onnx.GraphProto.output: object expected");n.output[r]=c.onnx.ValueInfoProto.fromObject(t.output[r])}}if(t.valueInfo){if(!Array.isArray(t.valueInfo))throw TypeError(".onnx.GraphProto.valueInfo: array expected");n.valueInfo=[];for(var r=0;r<t.valueInfo.length;++r){if(typeof t.valueInfo[r]!="object")throw TypeError(".onnx.GraphProto.valueInfo: object expected");n.valueInfo[r]=c.onnx.ValueInfoProto.fromObject(t.valueInfo[r])}}if(t.quantizationAnnotation){if(!Array.isArray(t.quantizationAnnotation))throw TypeError(".onnx.GraphProto.quantizationAnnotation: array expected");n.quantizationAnnotation=[];for(var r=0;r<t.quantizationAnnotation.length;++r){if(typeof t.quantizationAnnotation[r]!="object")throw TypeError(".onnx.GraphProto.quantizationAnnotation: object expected");n.quantizationAnnotation[r]=c.onnx.TensorAnnotation.fromObject(t.quantizationAnnotation[r])}}return n},e.toObject=function(t,n){n||(n={});var r={};if((n.arrays||n.defaults)&&(r.node=[],r.initializer=[],r.input=[],r.output=[],r.valueInfo=[],r.quantizationAnnotation=[],r.sparseInitializer=[]),n.defaults&&(r.name="",r.docString=""),t.node&&t.node.length){r.node=[];for(var s=0;s<t.node.length;++s)r.node[s]=c.onnx.NodeProto.toObject(t.node[s],n)}if(t.name!=null&&t.hasOwnProperty("name")&&(r.name=t.name),t.initializer&&t.initializer.length){r.initializer=[];for(var s=0;s<t.initializer.length;++s)r.initializer[s]=c.onnx.TensorProto.toObject(t.initializer[s],n)}if(t.docString!=null&&t.hasOwnProperty("docString")&&(r.docString=t.docString),t.input&&t.input.length){r.input=[];for(var s=0;s<t.input.length;++s)r.input[s]=c.onnx.ValueInfoProto.toObject(t.input[s],n)}if(t.output&&t.output.length){r.output=[];for(var s=0;s<t.output.length;++s)r.output[s]=c.onnx.ValueInfoProto.toObject(t.output[s],n)}if(t.valueInfo&&t.valueInfo.length){r.valueInfo=[];for(var s=0;s<t.valueInfo.length;++s)r.valueInfo[s]=c.onnx.ValueInfoProto.toObject(t.valueInfo[s],n)}if(t.quantizationAnnotation&&t.quantizationAnnotation.length){r.quantizationAnnotation=[];for(var s=0;s<t.quantizationAnnotation.length;++s)r.quantizationAnnotation[s]=c.onnx.TensorAnnotation.toObject(t.quantizationAnnotation[s],n)}if(t.sparseInitializer&&t.sparseInitializer.length){r.sparseInitializer=[];for(var s=0;s<t.sparseInitializer.length;++s)r.sparseInitializer[s]=c.onnx.SparseTensorProto.toObject(t.sparseInitializer[s],n)}return r},e.prototype.toJSON=function(){return this.constructor.toObject(this,W.util.toJSONOptions)},e.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.GraphProto"},e}(),a.TensorProto=function(){function e(o){if(this.dims=[],this.floatData=[],this.int32Data=[],this.stringData=[],this.int64Data=[],this.externalData=[],this.doubleData=[],this.uint64Data=[],o)for(var t=Object.keys(o),n=0;n<t.length;++n)o[t[n]]!=null&&(this[t[n]]=o[t[n]])}return e.prototype.dims=h.emptyArray,e.prototype.dataType=0,e.prototype.segment=null,e.prototype.floatData=h.emptyArray,e.prototype.int32Data=h.emptyArray,e.prototype.stringData=h.emptyArray,e.prototype.int64Data=h.emptyArray,e.prototype.name="",e.prototype.docString="",e.prototype.rawData=h.newBuffer([]),e.prototype.externalData=h.emptyArray,e.prototype.dataLocation=0,e.prototype.doubleData=h.emptyArray,e.prototype.uint64Data=h.emptyArray,e.create=function(t){return new e(t)},e.encode=function(t,n){if(n||(n=X.create()),t.dims!=null&&t.dims.length){n.uint32(10).fork();for(var r=0;r<t.dims.length;++r)n.int64(t.dims[r]);n.ldelim()}if(t.dataType!=null&&Object.hasOwnProperty.call(t,"dataType")&&n.uint32(16).int32(t.dataType),t.segment!=null&&Object.hasOwnProperty.call(t,"segment")&&c.onnx.TensorProto.Segment.encode(t.segment,n.uint32(26).fork()).ldelim(),t.floatData!=null&&t.floatData.length){n.uint32(34).fork();for(var r=0;r<t.floatData.length;++r)n.float(t.floatData[r]);n.ldelim()}if(t.int32Data!=null&&t.int32Data.length){n.uint32(42).fork();for(var r=0;r<t.int32Data.length;++r)n.int32(t.int32Data[r]);n.ldelim()}if(t.stringData!=null&&t.stringData.length)for(var r=0;r<t.stringData.length;++r)n.uint32(50).bytes(t.stringData[r]);if(t.int64Data!=null&&t.int64Data.length){n.uint32(58).fork();for(var r=0;r<t.int64Data.length;++r)n.int64(t.int64Data[r]);n.ldelim()}if(t.name!=null&&Object.hasOwnProperty.call(t,"name")&&n.uint32(66).string(t.name),t.rawData!=null&&Object.hasOwnProperty.call(t,"rawData")&&n.uint32(74).bytes(t.rawData),t.doubleData!=null&&t.doubleData.length){n.uint32(82).fork();for(var r=0;r<t.doubleData.length;++r)n.double(t.doubleData[r]);n.ldelim()}if(t.uint64Data!=null&&t.uint64Data.length){n.uint32(90).fork();for(var r=0;r<t.uint64Data.length;++r)n.uint64(t.uint64Data[r]);n.ldelim()}if(t.docString!=null&&Object.hasOwnProperty.call(t,"docString")&&n.uint32(98).string(t.docString),t.externalData!=null&&t.externalData.length)for(var r=0;r<t.externalData.length;++r)c.onnx.StringStringEntryProto.encode(t.externalData[r],n.uint32(106).fork()).ldelim();return t.dataLocation!=null&&Object.hasOwnProperty.call(t,"dataLocation")&&n.uint32(112).int32(t.dataLocation),n},e.encodeDelimited=function(t,n){return this.encode(t,n).ldelim()},e.decode=function(t,n){t instanceof w||(t=w.create(t));for(var r=n===void 0?t.len:t.pos+n,s=new c.onnx.TensorProto;t.pos<r;){var i=t.uint32();switch(i>>>3){case 1:{if(s.dims&&s.dims.length||(s.dims=[]),(i&7)===2)for(var u=t.uint32()+t.pos;t.pos<u;)s.dims.push(t.int64());else s.dims.push(t.int64());break}case 2:{s.dataType=t.int32();break}case 3:{s.segment=c.onnx.TensorProto.Segment.decode(t,t.uint32());break}case 4:{if(s.floatData&&s.floatData.length||(s.floatData=[]),(i&7)===2)for(var u=t.uint32()+t.pos;t.pos<u;)s.floatData.push(t.float());else s.floatData.push(t.float());break}case 5:{if(s.int32Data&&s.int32Data.length||(s.int32Data=[]),(i&7)===2)for(var u=t.uint32()+t.pos;t.pos<u;)s.int32Data.push(t.int32());else s.int32Data.push(t.int32());break}case 6:{s.stringData&&s.stringData.length||(s.stringData=[]),s.stringData.push(t.bytes());break}case 7:{if(s.int64Data&&s.int64Data.length||(s.int64Data=[]),(i&7)===2)for(var u=t.uint32()+t.pos;t.pos<u;)s.int64Data.push(t.int64());else s.int64Data.push(t.int64());break}case 8:{s.name=t.string();break}case 12:{s.docString=t.string();break}case 9:{s.rawData=t.bytes();break}case 13:{s.externalData&&s.externalData.length||(s.externalData=[]),s.externalData.push(c.onnx.StringStringEntryProto.decode(t,t.uint32()));break}case 14:{s.dataLocation=t.int32();break}case 10:{if(s.doubleData&&s.doubleData.length||(s.doubleData=[]),(i&7)===2)for(var u=t.uint32()+t.pos;t.pos<u;)s.doubleData.push(t.double());else s.doubleData.push(t.double());break}case 11:{if(s.uint64Data&&s.uint64Data.length||(s.uint64Data=[]),(i&7)===2)for(var u=t.uint32()+t.pos;t.pos<u;)s.uint64Data.push(t.uint64());else s.uint64Data.push(t.uint64());break}default:t.skipType(i&7);break}}return s},e.decodeDelimited=function(t){return t instanceof w||(t=new w(t)),this.decode(t,t.uint32())},e.verify=function(t){if(typeof t!="object"||t===null)return"object expected";if(t.dims!=null&&t.hasOwnProperty("dims")){if(!Array.isArray(t.dims))return"dims: array expected";for(var n=0;n<t.dims.length;++n)if(!h.isInteger(t.dims[n])&&!(t.dims[n]&&h.isInteger(t.dims[n].low)&&h.isInteger(t.dims[n].high)))return"dims: integer|Long[] expected"}if(t.dataType!=null&&t.hasOwnProperty("dataType")&&!h.isInteger(t.dataType))return"dataType: integer expected";if(t.segment!=null&&t.hasOwnProperty("segment")){var r=c.onnx.TensorProto.Segment.verify(t.segment);if(r)return"segment."+r}if(t.floatData!=null&&t.hasOwnProperty("floatData")){if(!Array.isArray(t.floatData))return"floatData: array expected";for(var n=0;n<t.floatData.length;++n)if(typeof t.floatData[n]!="number")return"floatData: number[] expected"}if(t.int32Data!=null&&t.hasOwnProperty("int32Data")){if(!Array.isArray(t.int32Data))return"int32Data: array expected";for(var n=0;n<t.int32Data.length;++n)if(!h.isInteger(t.int32Data[n]))return"int32Data: integer[] expected"}if(t.stringData!=null&&t.hasOwnProperty("stringData")){if(!Array.isArray(t.stringData))return"stringData: array expected";for(var n=0;n<t.stringData.length;++n)if(!(t.stringData[n]&&typeof t.stringData[n].length=="number"||h.isString(t.stringData[n])))return"stringData: buffer[] expected"}if(t.int64Data!=null&&t.hasOwnProperty("int64Data")){if(!Array.isArray(t.int64Data))return"int64Data: array expected";for(var n=0;n<t.int64Data.length;++n)if(!h.isInteger(t.int64Data[n])&&!(t.int64Data[n]&&h.isInteger(t.int64Data[n].low)&&h.isInteger(t.int64Data[n].high)))return"int64Data: integer|Long[] expected"}if(t.name!=null&&t.hasOwnProperty("name")&&!h.isString(t.name))return"name: string expected";if(t.docString!=null&&t.hasOwnProperty("docString")&&!h.isString(t.docString))return"docString: string expected";if(t.rawData!=null&&t.hasOwnProperty("rawData")&&!(t.rawData&&typeof t.rawData.length=="number"||h.isString(t.rawData)))return"rawData: buffer expected";if(t.externalData!=null&&t.hasOwnProperty("externalData")){if(!Array.isArray(t.externalData))return"externalData: array expected";for(var n=0;n<t.externalData.length;++n){var r=c.onnx.StringStringEntryProto.verify(t.externalData[n]);if(r)return"externalData."+r}}if(t.dataLocation!=null&&t.hasOwnProperty("dataLocation"))switch(t.dataLocation){default:return"dataLocation: enum value expected";case 0:case 1:break}if(t.doubleData!=null&&t.hasOwnProperty("doubleData")){if(!Array.isArray(t.doubleData))return"doubleData: array expected";for(var n=0;n<t.doubleData.length;++n)if(typeof t.doubleData[n]!="number")return"doubleData: number[] expected"}if(t.uint64Data!=null&&t.hasOwnProperty("uint64Data")){if(!Array.isArray(t.uint64Data))return"uint64Data: array expected";for(var n=0;n<t.uint64Data.length;++n)if(!h.isInteger(t.uint64Data[n])&&!(t.uint64Data[n]&&h.isInteger(t.uint64Data[n].low)&&h.isInteger(t.uint64Data[n].high)))return"uint64Data: integer|Long[] expected"}return null},e.fromObject=function(t){if(t instanceof c.onnx.TensorProto)return t;var n=new c.onnx.TensorProto;if(t.dims){if(!Array.isArray(t.dims))throw TypeError(".onnx.TensorProto.dims: array expected");n.dims=[];for(var r=0;r<t.dims.length;++r)h.Long?(n.dims[r]=h.Long.fromValue(t.dims[r])).unsigned=!1:typeof t.dims[r]=="string"?n.dims[r]=parseInt(t.dims[r],10):typeof t.dims[r]=="number"?n.dims[r]=t.dims[r]:typeof t.dims[r]=="object"&&(n.dims[r]=new h.LongBits(t.dims[r].low>>>0,t.dims[r].high>>>0).toNumber())}if(t.dataType!=null&&(n.dataType=t.dataType|0),t.segment!=null){if(typeof t.segment!="object")throw TypeError(".onnx.TensorProto.segment: object expected");n.segment=c.onnx.TensorProto.Segment.fromObject(t.segment)}if(t.floatData){if(!Array.isArray(t.floatData))throw TypeError(".onnx.TensorProto.floatData: array expected");n.floatData=[];for(var r=0;r<t.floatData.length;++r)n.floatData[r]=Number(t.floatData[r])}if(t.int32Data){if(!Array.isArray(t.int32Data))throw TypeError(".onnx.TensorProto.int32Data: array expected");n.int32Data=[];for(var r=0;r<t.int32Data.length;++r)n.int32Data[r]=t.int32Data[r]|0}if(t.stringData){if(!Array.isArray(t.stringData))throw TypeError(".onnx.TensorProto.stringData: array expected");n.stringData=[];for(var r=0;r<t.stringData.length;++r)typeof t.stringData[r]=="string"?h.base64.decode(t.stringData[r],n.stringData[r]=h.newBuffer(h.base64.length(t.stringData[r])),0):t.stringData[r].length>=0&&(n.stringData[r]=t.stringData[r])}if(t.int64Data){if(!Array.isArray(t.int64Data))throw TypeError(".onnx.TensorProto.int64Data: array expected");n.int64Data=[];for(var r=0;r<t.int64Data.length;++r)h.Long?(n.int64Data[r]=h.Long.fromValue(t.int64Data[r])).unsigned=!1:typeof t.int64Data[r]=="string"?n.int64Data[r]=parseInt(t.int64Data[r],10):typeof t.int64Data[r]=="number"?n.int64Data[r]=t.int64Data[r]:typeof t.int64Data[r]=="object"&&(n.int64Data[r]=new h.LongBits(t.int64Data[r].low>>>0,t.int64Data[r].high>>>0).toNumber())}if(t.name!=null&&(n.name=String(t.name)),t.docString!=null&&(n.docString=String(t.docString)),t.rawData!=null&&(typeof t.rawData=="string"?h.base64.decode(t.rawData,n.rawData=h.newBuffer(h.base64.length(t.rawData)),0):t.rawData.length>=0&&(n.rawData=t.rawData)),t.externalData){if(!Array.isArray(t.externalData))throw TypeError(".onnx.TensorProto.externalData: array expected");n.externalData=[];for(var r=0;r<t.externalData.length;++r){if(typeof t.externalData[r]!="object")throw TypeError(".onnx.TensorProto.externalData: object expected");n.externalData[r]=c.onnx.StringStringEntryProto.fromObject(t.externalData[r])}}switch(t.dataLocation){default:if(typeof t.dataLocation=="number"){n.dataLocation=t.dataLocation;break}break;case"DEFAULT":case 0:n.dataLocation=0;break;case"EXTERNAL":case 1:n.dataLocation=1;break}if(t.doubleData){if(!Array.isArray(t.doubleData))throw TypeError(".onnx.TensorProto.doubleData: array expected");n.doubleData=[];for(var r=0;r<t.doubleData.length;++r)n.doubleData[r]=Number(t.doubleData[r])}if(t.uint64Data){if(!Array.isArray(t.uint64Data))throw TypeError(".onnx.TensorProto.uint64Data: array expected");n.uint64Data=[];for(var r=0;r<t.uint64Data.length;++r)h.Long?(n.uint64Data[r]=h.Long.fromValue(t.uint64Data[r])).unsigned=!0:typeof t.uint64Data[r]=="string"?n.uint64Data[r]=parseInt(t.uint64Data[r],10):typeof t.uint64Data[r]=="number"?n.uint64Data[r]=t.uint64Data[r]:typeof t.uint64Data[r]=="object"&&(n.uint64Data[r]=new h.LongBits(t.uint64Data[r].low>>>0,t.uint64Data[r].high>>>0).toNumber(!0))}return n},e.toObject=function(t,n){n||(n={});var r={};if((n.arrays||n.defaults)&&(r.dims=[],r.floatData=[],r.int32Data=[],r.stringData=[],r.int64Data=[],r.doubleData=[],r.uint64Data=[],r.externalData=[]),n.defaults&&(r.dataType=0,r.segment=null,r.name="",n.bytes===String?r.rawData="":(r.rawData=[],n.bytes!==Array&&(r.rawData=h.newBuffer(r.rawData))),r.docString="",r.dataLocation=n.enums===String?"DEFAULT":0),t.dims&&t.dims.length){r.dims=[];for(var s=0;s<t.dims.length;++s)typeof t.dims[s]=="number"?r.dims[s]=n.longs===String?String(t.dims[s]):t.dims[s]:r.dims[s]=n.longs===String?h.Long.prototype.toString.call(t.dims[s]):n.longs===Number?new h.LongBits(t.dims[s].low>>>0,t.dims[s].high>>>0).toNumber():t.dims[s]}if(t.dataType!=null&&t.hasOwnProperty("dataType")&&(r.dataType=t.dataType),t.segment!=null&&t.hasOwnProperty("segment")&&(r.segment=c.onnx.TensorProto.Segment.toObject(t.segment,n)),t.floatData&&t.floatData.length){r.floatData=[];for(var s=0;s<t.floatData.length;++s)r.floatData[s]=n.json&&!isFinite(t.floatData[s])?String(t.floatData[s]):t.floatData[s]}if(t.int32Data&&t.int32Data.length){r.int32Data=[];for(var s=0;s<t.int32Data.length;++s)r.int32Data[s]=t.int32Data[s]}if(t.stringData&&t.stringData.length){r.stringData=[];for(var s=0;s<t.stringData.length;++s)r.stringData[s]=n.bytes===String?h.base64.encode(t.stringData[s],0,t.stringData[s].length):n.bytes===Array?Array.prototype.slice.call(t.stringData[s]):t.stringData[s]}if(t.int64Data&&t.int64Data.length){r.int64Data=[];for(var s=0;s<t.int64Data.length;++s)typeof t.int64Data[s]=="number"?r.int64Data[s]=n.longs===String?String(t.int64Data[s]):t.int64Data[s]:r.int64Data[s]=n.longs===String?h.Long.prototype.toString.call(t.int64Data[s]):n.longs===Number?new h.LongBits(t.int64Data[s].low>>>0,t.int64Data[s].high>>>0).toNumber():t.int64Data[s]}if(t.name!=null&&t.hasOwnProperty("name")&&(r.name=t.name),t.rawData!=null&&t.hasOwnProperty("rawData")&&(r.rawData=n.bytes===String?h.base64.encode(t.rawData,0,t.rawData.length):n.bytes===Array?Array.prototype.slice.call(t.rawData):t.rawData),t.doubleData&&t.doubleData.length){r.doubleData=[];for(var s=0;s<t.doubleData.length;++s)r.doubleData[s]=n.json&&!isFinite(t.doubleData[s])?String(t.doubleData[s]):t.doubleData[s]}if(t.uint64Data&&t.uint64Data.length){r.uint64Data=[];for(var s=0;s<t.uint64Data.length;++s)typeof t.uint64Data[s]=="number"?r.uint64Data[s]=n.longs===String?String(t.uint64Data[s]):t.uint64Data[s]:r.uint64Data[s]=n.longs===String?h.Long.prototype.toString.call(t.uint64Data[s]):n.longs===Number?new h.LongBits(t.uint64Data[s].low>>>0,t.uint64Data[s].high>>>0).toNumber(!0):t.uint64Data[s]}if(t.docString!=null&&t.hasOwnProperty("docString")&&(r.docString=t.docString),t.externalData&&t.externalData.length){r.externalData=[];for(var s=0;s<t.externalData.length;++s)r.externalData[s]=c.onnx.StringStringEntryProto.toObject(t.externalData[s],n)}return t.dataLocation!=null&&t.hasOwnProperty("dataLocation")&&(r.dataLocation=n.enums===String?c.onnx.TensorProto.DataLocation[t.dataLocation]===void 0?t.dataLocation:c.onnx.TensorProto.DataLocation[t.dataLocation]:t.dataLocation),r},e.prototype.toJSON=function(){return this.constructor.toObject(this,W.util.toJSONOptions)},e.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.TensorProto"},e.DataType=function(){var o={},t=Object.create(o);return t[o[0]="UNDEFINED"]=0,t[o[1]="FLOAT"]=1,t[o[2]="UINT8"]=2,t[o[3]="INT8"]=3,t[o[4]="UINT16"]=4,t[o[5]="INT16"]=5,t[o[6]="INT32"]=6,t[o[7]="INT64"]=7,t[o[8]="STRING"]=8,t[o[9]="BOOL"]=9,t[o[10]="FLOAT16"]=10,t[o[11]="DOUBLE"]=11,t[o[12]="UINT32"]=12,t[o[13]="UINT64"]=13,t[o[14]="COMPLEX64"]=14,t[o[15]="COMPLEX128"]=15,t[o[16]="BFLOAT16"]=16,t[o[17]="FLOAT8E4M3FN"]=17,t[o[18]="FLOAT8E4M3FNUZ"]=18,t[o[19]="FLOAT8E5M2"]=19,t[o[20]="FLOAT8E5M2FNUZ"]=20,t}(),e.Segment=function(){function o(t){if(t)for(var n=Object.keys(t),r=0;r<n.length;++r)t[n[r]]!=null&&(this[n[r]]=t[n[r]])}return o.prototype.begin=h.Long?h.Long.fromBits(0,0,!1):0,o.prototype.end=h.Long?h.Long.fromBits(0,0,!1):0,o.create=function(n){return new o(n)},o.encode=function(n,r){return r||(r=X.create()),n.begin!=null&&Object.hasOwnProperty.call(n,"begin")&&r.uint32(8).int64(n.begin),n.end!=null&&Object.hasOwnProperty.call(n,"end")&&r.uint32(16).int64(n.end),r},o.encodeDelimited=function(n,r){return this.encode(n,r).ldelim()},o.decode=function(n,r){n instanceof w||(n=w.create(n));for(var s=r===void 0?n.len:n.pos+r,i=new c.onnx.TensorProto.Segment;n.pos<s;){var u=n.uint32();switch(u>>>3){case 1:{i.begin=n.int64();break}case 2:{i.end=n.int64();break}default:n.skipType(u&7);break}}return i},o.decodeDelimited=function(n){return n instanceof w||(n=new w(n)),this.decode(n,n.uint32())},o.verify=function(n){return typeof n!="object"||n===null?"object expected":n.begin!=null&&n.hasOwnProperty("begin")&&!h.isInteger(n.begin)&&!(n.begin&&h.isInteger(n.begin.low)&&h.isInteger(n.begin.high))?"begin: integer|Long expected":n.end!=null&&n.hasOwnProperty("end")&&!h.isInteger(n.end)&&!(n.end&&h.isInteger(n.end.low)&&h.isInteger(n.end.high))?"end: integer|Long expected":null},o.fromObject=function(n){if(n instanceof c.onnx.TensorProto.Segment)return n;var r=new c.onnx.TensorProto.Segment;return n.begin!=null&&(h.Long?(r.begin=h.Long.fromValue(n.begin)).unsigned=!1:typeof n.begin=="string"?r.begin=parseInt(n.begin,10):typeof n.begin=="number"?r.begin=n.begin:typeof n.begin=="object"&&(r.begin=new h.LongBits(n.begin.low>>>0,n.begin.high>>>0).toNumber())),n.end!=null&&(h.Long?(r.end=h.Long.fromValue(n.end)).unsigned=!1:typeof n.end=="string"?r.end=parseInt(n.end,10):typeof n.end=="number"?r.end=n.end:typeof n.end=="object"&&(r.end=new h.LongBits(n.end.low>>>0,n.end.high>>>0).toNumber())),r},o.toObject=function(n,r){r||(r={});var s={};if(r.defaults){if(h.Long){var i=new h.Long(0,0,!1);s.begin=r.longs===String?i.toString():r.longs===Number?i.toNumber():i}else s.begin=r.longs===String?"0":0;if(h.Long){var i=new h.Long(0,0,!1);s.end=r.longs===String?i.toString():r.longs===Number?i.toNumber():i}else s.end=r.longs===String?"0":0}return n.begin!=null&&n.hasOwnProperty("begin")&&(typeof n.begin=="number"?s.begin=r.longs===String?String(n.begin):n.begin:s.begin=r.longs===String?h.Long.prototype.toString.call(n.begin):r.longs===Number?new h.LongBits(n.begin.low>>>0,n.begin.high>>>0).toNumber():n.begin),n.end!=null&&n.hasOwnProperty("end")&&(typeof n.end=="number"?s.end=r.longs===String?String(n.end):n.end:s.end=r.longs===String?h.Long.prototype.toString.call(n.end):r.longs===Number?new h.LongBits(n.end.low>>>0,n.end.high>>>0).toNumber():n.end),s},o.prototype.toJSON=function(){return this.constructor.toObject(this,W.util.toJSONOptions)},o.getTypeUrl=function(n){return n===void 0&&(n="type.googleapis.com"),n+"/onnx.TensorProto.Segment"},o}(),e.DataLocation=function(){var o={},t=Object.create(o);return t[o[0]="DEFAULT"]=0,t[o[1]="EXTERNAL"]=1,t}(),e}(),a.SparseTensorProto=function(){function e(o){if(this.dims=[],o)for(var t=Object.keys(o),n=0;n<t.length;++n)o[t[n]]!=null&&(this[t[n]]=o[t[n]])}return e.prototype.values=null,e.prototype.indices=null,e.prototype.dims=h.emptyArray,e.create=function(t){return new e(t)},e.encode=function(t,n){if(n||(n=X.create()),t.values!=null&&Object.hasOwnProperty.call(t,"values")&&c.onnx.TensorProto.encode(t.values,n.uint32(10).fork()).ldelim(),t.indices!=null&&Object.hasOwnProperty.call(t,"indices")&&c.onnx.TensorProto.encode(t.indices,n.uint32(18).fork()).ldelim(),t.dims!=null&&t.dims.length){n.uint32(26).fork();for(var r=0;r<t.dims.length;++r)n.int64(t.dims[r]);n.ldelim()}return n},e.encodeDelimited=function(t,n){return this.encode(t,n).ldelim()},e.decode=function(t,n){t instanceof w||(t=w.create(t));for(var r=n===void 0?t.len:t.pos+n,s=new c.onnx.SparseTensorProto;t.pos<r;){var i=t.uint32();switch(i>>>3){case 1:{s.values=c.onnx.TensorProto.decode(t,t.uint32());break}case 2:{s.indices=c.onnx.TensorProto.decode(t,t.uint32());break}case 3:{if(s.dims&&s.dims.length||(s.dims=[]),(i&7)===2)for(var u=t.uint32()+t.pos;t.pos<u;)s.dims.push(t.int64());else s.dims.push(t.int64());break}default:t.skipType(i&7);break}}return s},e.decodeDelimited=function(t){return t instanceof w||(t=new w(t)),this.decode(t,t.uint32())},e.verify=function(t){if(typeof t!="object"||t===null)return"object expected";if(t.values!=null&&t.hasOwnProperty("values")){var n=c.onnx.TensorProto.verify(t.values);if(n)return"values."+n}if(t.indices!=null&&t.hasOwnProperty("indices")){var n=c.onnx.TensorProto.verify(t.indices);if(n)return"indices."+n}if(t.dims!=null&&t.hasOwnProperty("dims")){if(!Array.isArray(t.dims))return"dims: array expected";for(var r=0;r<t.dims.length;++r)if(!h.isInteger(t.dims[r])&&!(t.dims[r]&&h.isInteger(t.dims[r].low)&&h.isInteger(t.dims[r].high)))return"dims: integer|Long[] expected"}return null},e.fromObject=function(t){if(t instanceof c.onnx.SparseTensorProto)return t;var n=new c.onnx.SparseTensorProto;if(t.values!=null){if(typeof t.values!="object")throw TypeError(".onnx.SparseTensorProto.values: object expected");n.values=c.onnx.TensorProto.fromObject(t.values)}if(t.indices!=null){if(typeof t.indices!="object")throw TypeError(".onnx.SparseTensorProto.indices: object expected");n.indices=c.onnx.TensorProto.fromObject(t.indices)}if(t.dims){if(!Array.isArray(t.dims))throw TypeError(".onnx.SparseTensorProto.dims: array expected");n.dims=[];for(var r=0;r<t.dims.length;++r)h.Long?(n.dims[r]=h.Long.fromValue(t.dims[r])).unsigned=!1:typeof t.dims[r]=="string"?n.dims[r]=parseInt(t.dims[r],10):typeof t.dims[r]=="number"?n.dims[r]=t.dims[r]:typeof t.dims[r]=="object"&&(n.dims[r]=new h.LongBits(t.dims[r].low>>>0,t.dims[r].high>>>0).toNumber())}return n},e.toObject=function(t,n){n||(n={});var r={};if((n.arrays||n.defaults)&&(r.dims=[]),n.defaults&&(r.values=null,r.indices=null),t.values!=null&&t.hasOwnProperty("values")&&(r.values=c.onnx.TensorProto.toObject(t.values,n)),t.indices!=null&&t.hasOwnProperty("indices")&&(r.indices=c.onnx.TensorProto.toObject(t.indices,n)),t.dims&&t.dims.length){r.dims=[];for(var s=0;s<t.dims.length;++s)typeof t.dims[s]=="number"?r.dims[s]=n.longs===String?String(t.dims[s]):t.dims[s]:r.dims[s]=n.longs===String?h.Long.prototype.toString.call(t.dims[s]):n.longs===Number?new h.LongBits(t.dims[s].low>>>0,t.dims[s].high>>>0).toNumber():t.dims[s]}return r},e.prototype.toJSON=function(){return this.constructor.toObject(this,W.util.toJSONOptions)},e.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.SparseTensorProto"},e}(),a.TensorShapeProto=function(){function e(o){if(this.dim=[],o)for(var t=Object.keys(o),n=0;n<t.length;++n)o[t[n]]!=null&&(this[t[n]]=o[t[n]])}return e.prototype.dim=h.emptyArray,e.create=function(t){return new e(t)},e.encode=function(t,n){if(n||(n=X.create()),t.dim!=null&&t.dim.length)for(var r=0;r<t.dim.length;++r)c.onnx.TensorShapeProto.Dimension.encode(t.dim[r],n.uint32(10).fork()).ldelim();return n},e.encodeDelimited=function(t,n){return this.encode(t,n).ldelim()},e.decode=function(t,n){t instanceof w||(t=w.create(t));for(var r=n===void 0?t.len:t.pos+n,s=new c.onnx.TensorShapeProto;t.pos<r;){var i=t.uint32();switch(i>>>3){case 1:{s.dim&&s.dim.length||(s.dim=[]),s.dim.push(c.onnx.TensorShapeProto.Dimension.decode(t,t.uint32()));break}default:t.skipType(i&7);break}}return s},e.decodeDelimited=function(t){return t instanceof w||(t=new w(t)),this.decode(t,t.uint32())},e.verify=function(t){if(typeof t!="object"||t===null)return"object expected";if(t.dim!=null&&t.hasOwnProperty("dim")){if(!Array.isArray(t.dim))return"dim: array expected";for(var n=0;n<t.dim.length;++n){var r=c.onnx.TensorShapeProto.Dimension.verify(t.dim[n]);if(r)return"dim."+r}}return null},e.fromObject=function(t){if(t instanceof c.onnx.TensorShapeProto)return t;var n=new c.onnx.TensorShapeProto;if(t.dim){if(!Array.isArray(t.dim))throw TypeError(".onnx.TensorShapeProto.dim: array expected");n.dim=[];for(var r=0;r<t.dim.length;++r){if(typeof t.dim[r]!="object")throw TypeError(".onnx.TensorShapeProto.dim: object expected");n.dim[r]=c.onnx.TensorShapeProto.Dimension.fromObject(t.dim[r])}}return n},e.toObject=function(t,n){n||(n={});var r={};if((n.arrays||n.defaults)&&(r.dim=[]),t.dim&&t.dim.length){r.dim=[];for(var s=0;s<t.dim.length;++s)r.dim[s]=c.onnx.TensorShapeProto.Dimension.toObject(t.dim[s],n)}return r},e.prototype.toJSON=function(){return this.constructor.toObject(this,W.util.toJSONOptions)},e.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.TensorShapeProto"},e.Dimension=function(){function o(n){if(n)for(var r=Object.keys(n),s=0;s<r.length;++s)n[r[s]]!=null&&(this[r[s]]=n[r[s]])}o.prototype.dimValue=null,o.prototype.dimParam=null,o.prototype.denotation="";var t;return Object.defineProperty(o.prototype,"value",{get:h.oneOfGetter(t=["dimValue","dimParam"]),set:h.oneOfSetter(t)}),o.create=function(r){return new o(r)},o.encode=function(r,s){return s||(s=X.create()),r.dimValue!=null&&Object.hasOwnProperty.call(r,"dimValue")&&s.uint32(8).int64(r.dimValue),r.dimParam!=null&&Object.hasOwnProperty.call(r,"dimParam")&&s.uint32(18).string(r.dimParam),r.denotation!=null&&Object.hasOwnProperty.call(r,"denotation")&&s.uint32(26).string(r.denotation),s},o.encodeDelimited=function(r,s){return this.encode(r,s).ldelim()},o.decode=function(r,s){r instanceof w||(r=w.create(r));for(var i=s===void 0?r.len:r.pos+s,u=new c.onnx.TensorShapeProto.Dimension;r.pos<i;){var l=r.uint32();switch(l>>>3){case 1:{u.dimValue=r.int64();break}case 2:{u.dimParam=r.string();break}case 3:{u.denotation=r.string();break}default:r.skipType(l&7);break}}return u},o.decodeDelimited=function(r){return r instanceof w||(r=new w(r)),this.decode(r,r.uint32())},o.verify=function(r){if(typeof r!="object"||r===null)return"object expected";var s={};if(r.dimValue!=null&&r.hasOwnProperty("dimValue")&&(s.value=1,!h.isInteger(r.dimValue)&&!(r.dimValue&&h.isInteger(r.dimValue.low)&&h.isInteger(r.dimValue.high))))return"dimValue: integer|Long expected";if(r.dimParam!=null&&r.hasOwnProperty("dimParam")){if(s.value===1)return"value: multiple values";if(s.value=1,!h.isString(r.dimParam))return"dimParam: string expected"}return r.denotation!=null&&r.hasOwnProperty("denotation")&&!h.isString(r.denotation)?"denotation: string expected":null},o.fromObject=function(r){if(r instanceof c.onnx.TensorShapeProto.Dimension)return r;var s=new c.onnx.TensorShapeProto.Dimension;return r.dimValue!=null&&(h.Long?(s.dimValue=h.Long.fromValue(r.dimValue)).unsigned=!1:typeof r.dimValue=="string"?s.dimValue=parseInt(r.dimValue,10):typeof r.dimValue=="number"?s.dimValue=r.dimValue:typeof r.dimValue=="object"&&(s.dimValue=new h.LongBits(r.dimValue.low>>>0,r.dimValue.high>>>0).toNumber())),r.dimParam!=null&&(s.dimParam=String(r.dimParam)),r.denotation!=null&&(s.denotation=String(r.denotation)),s},o.toObject=function(r,s){s||(s={});var i={};return s.defaults&&(i.denotation=""),r.dimValue!=null&&r.hasOwnProperty("dimValue")&&(typeof r.dimValue=="number"?i.dimValue=s.longs===String?String(r.dimValue):r.dimValue:i.dimValue=s.longs===String?h.Long.prototype.toString.call(r.dimValue):s.longs===Number?new h.LongBits(r.dimValue.low>>>0,r.dimValue.high>>>0).toNumber():r.dimValue,s.oneofs&&(i.value="dimValue")),r.dimParam!=null&&r.hasOwnProperty("dimParam")&&(i.dimParam=r.dimParam,s.oneofs&&(i.value="dimParam")),r.denotation!=null&&r.hasOwnProperty("denotation")&&(i.denotation=r.denotation),i},o.prototype.toJSON=function(){return this.constructor.toObject(this,W.util.toJSONOptions)},o.getTypeUrl=function(r){return r===void 0&&(r="type.googleapis.com"),r+"/onnx.TensorShapeProto.Dimension"},o}(),e}(),a.TypeProto=function(){function e(t){if(t)for(var n=Object.keys(t),r=0;r<n.length;++r)t[n[r]]!=null&&(this[n[r]]=t[n[r]])}e.prototype.tensorType=null,e.prototype.sequenceType=null,e.prototype.mapType=null,e.prototype.optionalType=null,e.prototype.sparseTensorType=null,e.prototype.denotation="";var o;return Object.defineProperty(e.prototype,"value",{get:h.oneOfGetter(o=["tensorType","sequenceType","mapType","optionalType","sparseTensorType"]),set:h.oneOfSetter(o)}),e.create=function(n){return new e(n)},e.encode=function(n,r){return r||(r=X.create()),n.tensorType!=null&&Object.hasOwnProperty.call(n,"tensorType")&&c.onnx.TypeProto.Tensor.encode(n.tensorType,r.uint32(10).fork()).ldelim(),n.sequenceType!=null&&Object.hasOwnProperty.call(n,"sequenceType")&&c.onnx.TypeProto.Sequence.encode(n.sequenceType,r.uint32(34).fork()).ldelim(),n.mapType!=null&&Object.hasOwnProperty.call(n,"mapType")&&c.onnx.TypeProto.Map.encode(n.mapType,r.uint32(42).fork()).ldelim(),n.denotation!=null&&Object.hasOwnProperty.call(n,"denotation")&&r.uint32(50).string(n.denotation),n.sparseTensorType!=null&&Object.hasOwnProperty.call(n,"sparseTensorType")&&c.onnx.TypeProto.SparseTensor.encode(n.sparseTensorType,r.uint32(66).fork()).ldelim(),n.optionalType!=null&&Object.hasOwnProperty.call(n,"optionalType")&&c.onnx.TypeProto.Optional.encode(n.optionalType,r.uint32(74).fork()).ldelim(),r},e.encodeDelimited=function(n,r){return this.encode(n,r).ldelim()},e.decode=function(n,r){n instanceof w||(n=w.create(n));for(var s=r===void 0?n.len:n.pos+r,i=new c.onnx.TypeProto;n.pos<s;){var u=n.uint32();switch(u>>>3){case 1:{i.tensorType=c.onnx.TypeProto.Tensor.decode(n,n.uint32());break}case 4:{i.sequenceType=c.onnx.TypeProto.Sequence.decode(n,n.uint32());break}case 5:{i.mapType=c.onnx.TypeProto.Map.decode(n,n.uint32());break}case 9:{i.optionalType=c.onnx.TypeProto.Optional.decode(n,n.uint32());break}case 8:{i.sparseTensorType=c.onnx.TypeProto.SparseTensor.decode(n,n.uint32());break}case 6:{i.denotation=n.string();break}default:n.skipType(u&7);break}}return i},e.decodeDelimited=function(n){return n instanceof w||(n=new w(n)),this.decode(n,n.uint32())},e.verify=function(n){if(typeof n!="object"||n===null)return"object expected";var r={};if(n.tensorType!=null&&n.hasOwnProperty("tensorType")){r.value=1;{var s=c.onnx.TypeProto.Tensor.verify(n.tensorType);if(s)return"tensorType."+s}}if(n.sequenceType!=null&&n.hasOwnProperty("sequenceType")){if(r.value===1)return"value: multiple values";r.value=1;{var s=c.onnx.TypeProto.Sequence.verify(n.sequenceType);if(s)return"sequenceType."+s}}if(n.mapType!=null&&n.hasOwnProperty("mapType")){if(r.value===1)return"value: multiple values";r.value=1;{var s=c.onnx.TypeProto.Map.verify(n.mapType);if(s)return"mapType."+s}}if(n.optionalType!=null&&n.hasOwnProperty("optionalType")){if(r.value===1)return"value: multiple values";r.value=1;{var s=c.onnx.TypeProto.Optional.verify(n.optionalType);if(s)return"optionalType."+s}}if(n.sparseTensorType!=null&&n.hasOwnProperty("sparseTensorType")){if(r.value===1)return"value: multiple values";r.value=1;{var s=c.onnx.TypeProto.SparseTensor.verify(n.sparseTensorType);if(s)return"sparseTensorType."+s}}return n.denotation!=null&&n.hasOwnProperty("denotation")&&!h.isString(n.denotation)?"denotation: string expected":null},e.fromObject=function(n){if(n instanceof c.onnx.TypeProto)return n;var r=new c.onnx.TypeProto;if(n.tensorType!=null){if(typeof n.tensorType!="object")throw TypeError(".onnx.TypeProto.tensorType: object expected");r.tensorType=c.onnx.TypeProto.Tensor.fromObject(n.tensorType)}if(n.sequenceType!=null){if(typeof n.sequenceType!="object")throw TypeError(".onnx.TypeProto.sequenceType: object expected");r.sequenceType=c.onnx.TypeProto.Sequence.fromObject(n.sequenceType)}if(n.mapType!=null){if(typeof n.mapType!="object")throw TypeError(".onnx.TypeProto.mapType: object expected");r.mapType=c.onnx.TypeProto.Map.fromObject(n.mapType)}if(n.optionalType!=null){if(typeof n.optionalType!="object")throw TypeError(".onnx.TypeProto.optionalType: object expected");r.optionalType=c.onnx.TypeProto.Optional.fromObject(n.optionalType)}if(n.sparseTensorType!=null){if(typeof n.sparseTensorType!="object")throw TypeError(".onnx.TypeProto.sparseTensorType: object expected");r.sparseTensorType=c.onnx.TypeProto.SparseTensor.fromObject(n.sparseTensorType)}return n.denotation!=null&&(r.denotation=String(n.denotation)),r},e.toObject=function(n,r){r||(r={});var s={};return r.defaults&&(s.denotation=""),n.tensorType!=null&&n.hasOwnProperty("tensorType")&&(s.tensorType=c.onnx.TypeProto.Tensor.toObject(n.tensorType,r),r.oneofs&&(s.value="tensorType")),n.sequenceType!=null&&n.hasOwnProperty("sequenceType")&&(s.sequenceType=c.onnx.TypeProto.Sequence.toObject(n.sequenceType,r),r.oneofs&&(s.value="sequenceType")),n.mapType!=null&&n.hasOwnProperty("mapType")&&(s.mapType=c.onnx.TypeProto.Map.toObject(n.mapType,r),r.oneofs&&(s.value="mapType")),n.denotation!=null&&n.hasOwnProperty("denotation")&&(s.denotation=n.denotation),n.sparseTensorType!=null&&n.hasOwnProperty("sparseTensorType")&&(s.sparseTensorType=c.onnx.TypeProto.SparseTensor.toObject(n.sparseTensorType,r),r.oneofs&&(s.value="sparseTensorType")),n.optionalType!=null&&n.hasOwnProperty("optionalType")&&(s.optionalType=c.onnx.TypeProto.Optional.toObject(n.optionalType,r),r.oneofs&&(s.value="optionalType")),s},e.prototype.toJSON=function(){return this.constructor.toObject(this,W.util.toJSONOptions)},e.getTypeUrl=function(n){return n===void 0&&(n="type.googleapis.com"),n+"/onnx.TypeProto"},e.Tensor=function(){function t(n){if(n)for(var r=Object.keys(n),s=0;s<r.length;++s)n[r[s]]!=null&&(this[r[s]]=n[r[s]])}return t.prototype.elemType=0,t.prototype.shape=null,t.create=function(r){return new t(r)},t.encode=function(r,s){return s||(s=X.create()),r.elemType!=null&&Object.hasOwnProperty.call(r,"elemType")&&s.uint32(8).int32(r.elemType),r.shape!=null&&Object.hasOwnProperty.call(r,"shape")&&c.onnx.TensorShapeProto.encode(r.shape,s.uint32(18).fork()).ldelim(),s},t.encodeDelimited=function(r,s){return this.encode(r,s).ldelim()},t.decode=function(r,s){r instanceof w||(r=w.create(r));for(var i=s===void 0?r.len:r.pos+s,u=new c.onnx.TypeProto.Tensor;r.pos<i;){var l=r.uint32();switch(l>>>3){case 1:{u.elemType=r.int32();break}case 2:{u.shape=c.onnx.TensorShapeProto.decode(r,r.uint32());break}default:r.skipType(l&7);break}}return u},t.decodeDelimited=function(r){return r instanceof w||(r=new w(r)),this.decode(r,r.uint32())},t.verify=function(r){if(typeof r!="object"||r===null)return"object expected";if(r.elemType!=null&&r.hasOwnProperty("elemType")&&!h.isInteger(r.elemType))return"elemType: integer expected";if(r.shape!=null&&r.hasOwnProperty("shape")){var s=c.onnx.TensorShapeProto.verify(r.shape);if(s)return"shape."+s}return null},t.fromObject=function(r){if(r instanceof c.onnx.TypeProto.Tensor)return r;var s=new c.onnx.TypeProto.Tensor;if(r.elemType!=null&&(s.elemType=r.elemType|0),r.shape!=null){if(typeof r.shape!="object")throw TypeError(".onnx.TypeProto.Tensor.shape: object expected");s.shape=c.onnx.TensorShapeProto.fromObject(r.shape)}return s},t.toObject=function(r,s){s||(s={});var i={};return s.defaults&&(i.elemType=0,i.shape=null),r.elemType!=null&&r.hasOwnProperty("elemType")&&(i.elemType=r.elemType),r.shape!=null&&r.hasOwnProperty("shape")&&(i.shape=c.onnx.TensorShapeProto.toObject(r.shape,s)),i},t.prototype.toJSON=function(){return this.constructor.toObject(this,W.util.toJSONOptions)},t.getTypeUrl=function(r){return r===void 0&&(r="type.googleapis.com"),r+"/onnx.TypeProto.Tensor"},t}(),e.Sequence=function(){function t(n){if(n)for(var r=Object.keys(n),s=0;s<r.length;++s)n[r[s]]!=null&&(this[r[s]]=n[r[s]])}return t.prototype.elemType=null,t.create=function(r){return new t(r)},t.encode=function(r,s){return s||(s=X.create()),r.elemType!=null&&Object.hasOwnProperty.call(r,"elemType")&&c.onnx.TypeProto.encode(r.elemType,s.uint32(10).fork()).ldelim(),s},t.encodeDelimited=function(r,s){return this.encode(r,s).ldelim()},t.decode=function(r,s){r instanceof w||(r=w.create(r));for(var i=s===void 0?r.len:r.pos+s,u=new c.onnx.TypeProto.Sequence;r.pos<i;){var l=r.uint32();switch(l>>>3){case 1:{u.elemType=c.onnx.TypeProto.decode(r,r.uint32());break}default:r.skipType(l&7);break}}return u},t.decodeDelimited=function(r){return r instanceof w||(r=new w(r)),this.decode(r,r.uint32())},t.verify=function(r){if(typeof r!="object"||r===null)return"object expected";if(r.elemType!=null&&r.hasOwnProperty("elemType")){var s=c.onnx.TypeProto.verify(r.elemType);if(s)return"elemType."+s}return null},t.fromObject=function(r){if(r instanceof c.onnx.TypeProto.Sequence)return r;var s=new c.onnx.TypeProto.Sequence;if(r.elemType!=null){if(typeof r.elemType!="object")throw TypeError(".onnx.TypeProto.Sequence.elemType: object expected");s.elemType=c.onnx.TypeProto.fromObject(r.elemType)}return s},t.toObject=function(r,s){s||(s={});var i={};return s.defaults&&(i.elemType=null),r.elemType!=null&&r.hasOwnProperty("elemType")&&(i.elemType=c.onnx.TypeProto.toObject(r.elemType,s)),i},t.prototype.toJSON=function(){return this.constructor.toObject(this,W.util.toJSONOptions)},t.getTypeUrl=function(r){return r===void 0&&(r="type.googleapis.com"),r+"/onnx.TypeProto.Sequence"},t}(),e.Map=function(){function t(n){if(n)for(var r=Object.keys(n),s=0;s<r.length;++s)n[r[s]]!=null&&(this[r[s]]=n[r[s]])}return t.prototype.keyType=0,t.prototype.valueType=null,t.create=function(r){return new t(r)},t.encode=function(r,s){return s||(s=X.create()),r.keyType!=null&&Object.hasOwnProperty.call(r,"keyType")&&s.uint32(8).int32(r.keyType),r.valueType!=null&&Object.hasOwnProperty.call(r,"valueType")&&c.onnx.TypeProto.encode(r.valueType,s.uint32(18).fork()).ldelim(),s},t.encodeDelimited=function(r,s){return this.encode(r,s).ldelim()},t.decode=function(r,s){r instanceof w||(r=w.create(r));for(var i=s===void 0?r.len:r.pos+s,u=new c.onnx.TypeProto.Map;r.pos<i;){var l=r.uint32();switch(l>>>3){case 1:{u.keyType=r.int32();break}case 2:{u.valueType=c.onnx.TypeProto.decode(r,r.uint32());break}default:r.skipType(l&7);break}}return u},t.decodeDelimited=function(r){return r instanceof w||(r=new w(r)),this.decode(r,r.uint32())},t.verify=function(r){if(typeof r!="object"||r===null)return"object expected";if(r.keyType!=null&&r.hasOwnProperty("keyType")&&!h.isInteger(r.keyType))return"keyType: integer expected";if(r.valueType!=null&&r.hasOwnProperty("valueType")){var s=c.onnx.TypeProto.verify(r.valueType);if(s)return"valueType."+s}return null},t.fromObject=function(r){if(r instanceof c.onnx.TypeProto.Map)return r;var s=new c.onnx.TypeProto.Map;if(r.keyType!=null&&(s.keyType=r.keyType|0),r.valueType!=null){if(typeof r.valueType!="object")throw TypeError(".onnx.TypeProto.Map.valueType: object expected");s.valueType=c.onnx.TypeProto.fromObject(r.valueType)}return s},t.toObject=function(r,s){s||(s={});var i={};return s.defaults&&(i.keyType=0,i.valueType=null),r.keyType!=null&&r.hasOwnProperty("keyType")&&(i.keyType=r.keyType),r.valueType!=null&&r.hasOwnProperty("valueType")&&(i.valueType=c.onnx.TypeProto.toObject(r.valueType,s)),i},t.prototype.toJSON=function(){return this.constructor.toObject(this,W.util.toJSONOptions)},t.getTypeUrl=function(r){return r===void 0&&(r="type.googleapis.com"),r+"/onnx.TypeProto.Map"},t}(),e.Optional=function(){function t(n){if(n)for(var r=Object.keys(n),s=0;s<r.length;++s)n[r[s]]!=null&&(this[r[s]]=n[r[s]])}return t.prototype.elemType=null,t.create=function(r){return new t(r)},t.encode=function(r,s){return s||(s=X.create()),r.elemType!=null&&Object.hasOwnProperty.call(r,"elemType")&&c.onnx.TypeProto.encode(r.elemType,s.uint32(10).fork()).ldelim(),s},t.encodeDelimited=function(r,s){return this.encode(r,s).ldelim()},t.decode=function(r,s){r instanceof w||(r=w.create(r));for(var i=s===void 0?r.len:r.pos+s,u=new c.onnx.TypeProto.Optional;r.pos<i;){var l=r.uint32();switch(l>>>3){case 1:{u.elemType=c.onnx.TypeProto.decode(r,r.uint32());break}default:r.skipType(l&7);break}}return u},t.decodeDelimited=function(r){return r instanceof w||(r=new w(r)),this.decode(r,r.uint32())},t.verify=function(r){if(typeof r!="object"||r===null)return"object expected";if(r.elemType!=null&&r.hasOwnProperty("elemType")){var s=c.onnx.TypeProto.verify(r.elemType);if(s)return"elemType."+s}return null},t.fromObject=function(r){if(r instanceof c.onnx.TypeProto.Optional)return r;var s=new c.onnx.TypeProto.Optional;if(r.elemType!=null){if(typeof r.elemType!="object")throw TypeError(".onnx.TypeProto.Optional.elemType: object expected");s.elemType=c.onnx.TypeProto.fromObject(r.elemType)}return s},t.toObject=function(r,s){s||(s={});var i={};return s.defaults&&(i.elemType=null),r.elemType!=null&&r.hasOwnProperty("elemType")&&(i.elemType=c.onnx.TypeProto.toObject(r.elemType,s)),i},t.prototype.toJSON=function(){return this.constructor.toObject(this,W.util.toJSONOptions)},t.getTypeUrl=function(r){return r===void 0&&(r="type.googleapis.com"),r+"/onnx.TypeProto.Optional"},t}(),e.SparseTensor=function(){function t(n){if(n)for(var r=Object.keys(n),s=0;s<r.length;++s)n[r[s]]!=null&&(this[r[s]]=n[r[s]])}return t.prototype.elemType=0,t.prototype.shape=null,t.create=function(r){return new t(r)},t.encode=function(r,s){return s||(s=X.create()),r.elemType!=null&&Object.hasOwnProperty.call(r,"elemType")&&s.uint32(8).int32(r.elemType),r.shape!=null&&Object.hasOwnProperty.call(r,"shape")&&c.onnx.TensorShapeProto.encode(r.shape,s.uint32(18).fork()).ldelim(),s},t.encodeDelimited=function(r,s){return this.encode(r,s).ldelim()},t.decode=function(r,s){r instanceof w||(r=w.create(r));for(var i=s===void 0?r.len:r.pos+s,u=new c.onnx.TypeProto.SparseTensor;r.pos<i;){var l=r.uint32();switch(l>>>3){case 1:{u.elemType=r.int32();break}case 2:{u.shape=c.onnx.TensorShapeProto.decode(r,r.uint32());break}default:r.skipType(l&7);break}}return u},t.decodeDelimited=function(r){return r instanceof w||(r=new w(r)),this.decode(r,r.uint32())},t.verify=function(r){if(typeof r!="object"||r===null)return"object expected";if(r.elemType!=null&&r.hasOwnProperty("elemType")&&!h.isInteger(r.elemType))return"elemType: integer expected";if(r.shape!=null&&r.hasOwnProperty("shape")){var s=c.onnx.TensorShapeProto.verify(r.shape);if(s)return"shape."+s}return null},t.fromObject=function(r){if(r instanceof c.onnx.TypeProto.SparseTensor)return r;var s=new c.onnx.TypeProto.SparseTensor;if(r.elemType!=null&&(s.elemType=r.elemType|0),r.shape!=null){if(typeof r.shape!="object")throw TypeError(".onnx.TypeProto.SparseTensor.shape: object expected");s.shape=c.onnx.TensorShapeProto.fromObject(r.shape)}return s},t.toObject=function(r,s){s||(s={});var i={};return s.defaults&&(i.elemType=0,i.shape=null),r.elemType!=null&&r.hasOwnProperty("elemType")&&(i.elemType=r.elemType),r.shape!=null&&r.hasOwnProperty("shape")&&(i.shape=c.onnx.TensorShapeProto.toObject(r.shape,s)),i},t.prototype.toJSON=function(){return this.constructor.toObject(this,W.util.toJSONOptions)},t.getTypeUrl=function(r){return r===void 0&&(r="type.googleapis.com"),r+"/onnx.TypeProto.SparseTensor"},t}(),e}(),a.OperatorSetIdProto=function(){function e(o){if(o)for(var t=Object.keys(o),n=0;n<t.length;++n)o[t[n]]!=null&&(this[t[n]]=o[t[n]])}return e.prototype.domain="",e.prototype.version=h.Long?h.Long.fromBits(0,0,!1):0,e.create=function(t){return new e(t)},e.encode=function(t,n){return n||(n=X.create()),t.domain!=null&&Object.hasOwnProperty.call(t,"domain")&&n.uint32(10).string(t.domain),t.version!=null&&Object.hasOwnProperty.call(t,"version")&&n.uint32(16).int64(t.version),n},e.encodeDelimited=function(t,n){return this.encode(t,n).ldelim()},e.decode=function(t,n){t instanceof w||(t=w.create(t));for(var r=n===void 0?t.len:t.pos+n,s=new c.onnx.OperatorSetIdProto;t.pos<r;){var i=t.uint32();switch(i>>>3){case 1:{s.domain=t.string();break}case 2:{s.version=t.int64();break}default:t.skipType(i&7);break}}return s},e.decodeDelimited=function(t){return t instanceof w||(t=new w(t)),this.decode(t,t.uint32())},e.verify=function(t){return typeof t!="object"||t===null?"object expected":t.domain!=null&&t.hasOwnProperty("domain")&&!h.isString(t.domain)?"domain: string expected":t.version!=null&&t.hasOwnProperty("version")&&!h.isInteger(t.version)&&!(t.version&&h.isInteger(t.version.low)&&h.isInteger(t.version.high))?"version: integer|Long expected":null},e.fromObject=function(t){if(t instanceof c.onnx.OperatorSetIdProto)return t;var n=new c.onnx.OperatorSetIdProto;return t.domain!=null&&(n.domain=String(t.domain)),t.version!=null&&(h.Long?(n.version=h.Long.fromValue(t.version)).unsigned=!1:typeof t.version=="string"?n.version=parseInt(t.version,10):typeof t.version=="number"?n.version=t.version:typeof t.version=="object"&&(n.version=new h.LongBits(t.version.low>>>0,t.version.high>>>0).toNumber())),n},e.toObject=function(t,n){n||(n={});var r={};if(n.defaults)if(r.domain="",h.Long){var s=new h.Long(0,0,!1);r.version=n.longs===String?s.toString():n.longs===Number?s.toNumber():s}else r.version=n.longs===String?"0":0;return t.domain!=null&&t.hasOwnProperty("domain")&&(r.domain=t.domain),t.version!=null&&t.hasOwnProperty("version")&&(typeof t.version=="number"?r.version=n.longs===String?String(t.version):t.version:r.version=n.longs===String?h.Long.prototype.toString.call(t.version):n.longs===Number?new h.LongBits(t.version.low>>>0,t.version.high>>>0).toNumber():t.version),r},e.prototype.toJSON=function(){return this.constructor.toObject(this,W.util.toJSONOptions)},e.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.OperatorSetIdProto"},e}(),a.OperatorStatus=function(){var e={},o=Object.create(e);return o[e[0]="EXPERIMENTAL"]=0,o[e[1]="STABLE"]=1,o}(),a.FunctionProto=function(){function e(o){if(this.input=[],this.output=[],this.attribute=[],this.attributeProto=[],this.node=[],this.opsetImport=[],o)for(var t=Object.keys(o),n=0;n<t.length;++n)o[t[n]]!=null&&(this[t[n]]=o[t[n]])}return e.prototype.name="",e.prototype.input=h.emptyArray,e.prototype.output=h.emptyArray,e.prototype.attribute=h.emptyArray,e.prototype.attributeProto=h.emptyArray,e.prototype.node=h.emptyArray,e.prototype.docString="",e.prototype.opsetImport=h.emptyArray,e.prototype.domain="",e.create=function(t){return new e(t)},e.encode=function(t,n){if(n||(n=X.create()),t.name!=null&&Object.hasOwnProperty.call(t,"name")&&n.uint32(10).string(t.name),t.input!=null&&t.input.length)for(var r=0;r<t.input.length;++r)n.uint32(34).string(t.input[r]);if(t.output!=null&&t.output.length)for(var r=0;r<t.output.length;++r)n.uint32(42).string(t.output[r]);if(t.attribute!=null&&t.attribute.length)for(var r=0;r<t.attribute.length;++r)n.uint32(50).string(t.attribute[r]);if(t.node!=null&&t.node.length)for(var r=0;r<t.node.length;++r)c.onnx.NodeProto.encode(t.node[r],n.uint32(58).fork()).ldelim();if(t.docString!=null&&Object.hasOwnProperty.call(t,"docString")&&n.uint32(66).string(t.docString),t.opsetImport!=null&&t.opsetImport.length)for(var r=0;r<t.opsetImport.length;++r)c.onnx.OperatorSetIdProto.encode(t.opsetImport[r],n.uint32(74).fork()).ldelim();if(t.domain!=null&&Object.hasOwnProperty.call(t,"domain")&&n.uint32(82).string(t.domain),t.attributeProto!=null&&t.attributeProto.length)for(var r=0;r<t.attributeProto.length;++r)c.onnx.AttributeProto.encode(t.attributeProto[r],n.uint32(90).fork()).ldelim();return n},e.encodeDelimited=function(t,n){return this.encode(t,n).ldelim()},e.decode=function(t,n){t instanceof w||(t=w.create(t));for(var r=n===void 0?t.len:t.pos+n,s=new c.onnx.FunctionProto;t.pos<r;){var i=t.uint32();switch(i>>>3){case 1:{s.name=t.string();break}case 4:{s.input&&s.input.length||(s.input=[]),s.input.push(t.string());break}case 5:{s.output&&s.output.length||(s.output=[]),s.output.push(t.string());break}case 6:{s.attribute&&s.attribute.length||(s.attribute=[]),s.attribute.push(t.string());break}case 11:{s.attributeProto&&s.attributeProto.length||(s.attributeProto=[]),s.attributeProto.push(c.onnx.AttributeProto.decode(t,t.uint32()));break}case 7:{s.node&&s.node.length||(s.node=[]),s.node.push(c.onnx.NodeProto.decode(t,t.uint32()));break}case 8:{s.docString=t.string();break}case 9:{s.opsetImport&&s.opsetImport.length||(s.opsetImport=[]),s.opsetImport.push(c.onnx.OperatorSetIdProto.decode(t,t.uint32()));break}case 10:{s.domain=t.string();break}default:t.skipType(i&7);break}}return s},e.decodeDelimited=function(t){return t instanceof w||(t=new w(t)),this.decode(t,t.uint32())},e.verify=function(t){if(typeof t!="object"||t===null)return"object expected";if(t.name!=null&&t.hasOwnProperty("name")&&!h.isString(t.name))return"name: string expected";if(t.input!=null&&t.hasOwnProperty("input")){if(!Array.isArray(t.input))return"input: array expected";for(var n=0;n<t.input.length;++n)if(!h.isString(t.input[n]))return"input: string[] expected"}if(t.output!=null&&t.hasOwnProperty("output")){if(!Array.isArray(t.output))return"output: array expected";for(var n=0;n<t.output.length;++n)if(!h.isString(t.output[n]))return"output: string[] expected"}if(t.attribute!=null&&t.hasOwnProperty("attribute")){if(!Array.isArray(t.attribute))return"attribute: array expected";for(var n=0;n<t.attribute.length;++n)if(!h.isString(t.attribute[n]))return"attribute: string[] expected"}if(t.attributeProto!=null&&t.hasOwnProperty("attributeProto")){if(!Array.isArray(t.attributeProto))return"attributeProto: array expected";for(var n=0;n<t.attributeProto.length;++n){var r=c.onnx.AttributeProto.verify(t.attributeProto[n]);if(r)return"attributeProto."+r}}if(t.node!=null&&t.hasOwnProperty("node")){if(!Array.isArray(t.node))return"node: array expected";for(var n=0;n<t.node.length;++n){var r=c.onnx.NodeProto.verify(t.node[n]);if(r)return"node."+r}}if(t.docString!=null&&t.hasOwnProperty("docString")&&!h.isString(t.docString))return"docString: string expected";if(t.opsetImport!=null&&t.hasOwnProperty("opsetImport")){if(!Array.isArray(t.opsetImport))return"opsetImport: array expected";for(var n=0;n<t.opsetImport.length;++n){var r=c.onnx.OperatorSetIdProto.verify(t.opsetImport[n]);if(r)return"opsetImport."+r}}return t.domain!=null&&t.hasOwnProperty("domain")&&!h.isString(t.domain)?"domain: string expected":null},e.fromObject=function(t){if(t instanceof c.onnx.FunctionProto)return t;var n=new c.onnx.FunctionProto;if(t.name!=null&&(n.name=String(t.name)),t.input){if(!Array.isArray(t.input))throw TypeError(".onnx.FunctionProto.input: array expected");n.input=[];for(var r=0;r<t.input.length;++r)n.input[r]=String(t.input[r])}if(t.output){if(!Array.isArray(t.output))throw TypeError(".onnx.FunctionProto.output: array expected");n.output=[];for(var r=0;r<t.output.length;++r)n.output[r]=String(t.output[r])}if(t.attribute){if(!Array.isArray(t.attribute))throw TypeError(".onnx.FunctionProto.attribute: array expected");n.attribute=[];for(var r=0;r<t.attribute.length;++r)n.attribute[r]=String(t.attribute[r])}if(t.attributeProto){if(!Array.isArray(t.attributeProto))throw TypeError(".onnx.FunctionProto.attributeProto: array expected");n.attributeProto=[];for(var r=0;r<t.attributeProto.length;++r){if(typeof t.attributeProto[r]!="object")throw TypeError(".onnx.FunctionProto.attributeProto: object expected");n.attributeProto[r]=c.onnx.AttributeProto.fromObject(t.attributeProto[r])}}if(t.node){if(!Array.isArray(t.node))throw TypeError(".onnx.FunctionProto.node: array expected");n.node=[];for(var r=0;r<t.node.length;++r){if(typeof t.node[r]!="object")throw TypeError(".onnx.FunctionProto.node: object expected");n.node[r]=c.onnx.NodeProto.fromObject(t.node[r])}}if(t.docString!=null&&(n.docString=String(t.docString)),t.opsetImport){if(!Array.isArray(t.opsetImport))throw TypeError(".onnx.FunctionProto.opsetImport: array expected");n.opsetImport=[];for(var r=0;r<t.opsetImport.length;++r){if(typeof t.opsetImport[r]!="object")throw TypeError(".onnx.FunctionProto.opsetImport: object expected");n.opsetImport[r]=c.onnx.OperatorSetIdProto.fromObject(t.opsetImport[r])}}return t.domain!=null&&(n.domain=String(t.domain)),n},e.toObject=function(t,n){n||(n={});var r={};if((n.arrays||n.defaults)&&(r.input=[],r.output=[],r.attribute=[],r.node=[],r.opsetImport=[],r.attributeProto=[]),n.defaults&&(r.name="",r.docString="",r.domain=""),t.name!=null&&t.hasOwnProperty("name")&&(r.name=t.name),t.input&&t.input.length){r.input=[];for(var s=0;s<t.input.length;++s)r.input[s]=t.input[s]}if(t.output&&t.output.length){r.output=[];for(var s=0;s<t.output.length;++s)r.output[s]=t.output[s]}if(t.attribute&&t.attribute.length){r.attribute=[];for(var s=0;s<t.attribute.length;++s)r.attribute[s]=t.attribute[s]}if(t.node&&t.node.length){r.node=[];for(var s=0;s<t.node.length;++s)r.node[s]=c.onnx.NodeProto.toObject(t.node[s],n)}if(t.docString!=null&&t.hasOwnProperty("docString")&&(r.docString=t.docString),t.opsetImport&&t.opsetImport.length){r.opsetImport=[];for(var s=0;s<t.opsetImport.length;++s)r.opsetImport[s]=c.onnx.OperatorSetIdProto.toObject(t.opsetImport[s],n)}if(t.domain!=null&&t.hasOwnProperty("domain")&&(r.domain=t.domain),t.attributeProto&&t.attributeProto.length){r.attributeProto=[];for(var s=0;s<t.attributeProto.length;++s)r.attributeProto[s]=c.onnx.AttributeProto.toObject(t.attributeProto[s],n)}return r},e.prototype.toJSON=function(){return this.constructor.toObject(this,W.util.toJSONOptions)},e.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.FunctionProto"},e}(),a}();Gi.exports=c});function ue(a,e){if(!a)throw new Error(typeof e=="string"?e:e())}function Ae(a){return new TextDecoder().decode(a)}var H,Kt,an,it,er,et,ft,O,Se,Xt,Jt,Zt,z=x(()=>{"use strict";Je();Hr();H=ne(se());Yt();Kt=class{static arraysEqual(e,o){if(e.length!==o.length)return!1;for(let t=0;t<e.length;t++)if(e[t]!==o[t])return!1;return!0}},an=class{static preprocessInputShapes(e,o){let t=e.length===1?[1,e[0]]:e,n=o.length===1?[o[0],1]:o;return[t,n]}static postprocessOutputShape(e,o,t){o===1&&e.splice(e.length-2,1),t===1&&e.pop()}static calcMatMulShape(e,o){return e[1]!==o[0]?void 0:[e[0],o[1]]}},it=class a{static calcShape(e,o,t=!1){let n=e.length,r=o.length;if(n===0)return o;if(r===0)return e;let s=Math.max(e.length,o.length),i=new Array(s);if(t){if(n<2||r<2)return;let u=an.calcMatMulShape([e[n-2],e[n-1]],[o[r-2],o[r-1]]);if(u===void 0)return;[i[s-2],i[s-1]]=u}for(let u=t?3:1;u<=s;u++){let l=n-u<0?1:e[n-u],f=r-u<0?1:o[r-u];if(l!==f&&l>1&&f>1)return;i[s-u]=Math.max(l,f)}return i}static index(e,o){let t=new Array(o.length);return a.fillIndex(e,o,t),t}static fillIndex(e,o,t){let n=e.length-o.length;for(let r=0;r<o.length;r++)t[r]=e[n+r]%o[r]}static calc(e,o,t,n,r){let s=a.calcShape(e.dims,o.dims);if(s){if(n&&!O.areEqual(s,e.dims))return;let i=O.size(s),u=n?e:new Y(s,r||e.type);if(s.length===0)u.set([],t(e.get([]),o.get([])));else{let l=new Array(s.length),f=new Array(e.dims.length),p=new Array(o.dims.length),d=0,b=0,g=!1,y=!1;e.dims.length===0&&(d=e.get([]),g=!0),o.dims.length===0&&(b=o.get([]),y=!0);let v;for(let _=0;_<i;_++){v=_;for(let A=s.length-1;A>=0;A--)l[A]=v%s[A],v=Math.floor(v/s[A]);g||(a.fillIndex(l,e.dims,f),d=e.get(f)),y||(a.fillIndex(l,o.dims,p),b=o.get(p)),u.set(l,t(d,b))}}return u}}static isValidBroadcast(e,o){let t=e.length,n=o.length;if(t>n)return!1;for(let r=1;r<=t;r++)if(e[t-r]!==1&&e[t-r]!==o[n-r])return!1;return!0}static getBroadcastDims(e,o){let t=e.length,n=[];for(let r=0;r<t;r++){let s=t-1-r,i=e[s]||1;(o[o.length-1-r]||1)>1&&i===1&&n.unshift(s)}return n}},er=class{static getShapeOfGemmResult(e,o,t,n,r){if(e.length!==2||t.length!==2)throw new Error("shape need to be of size 2");let s,i,u;o?(s=e[1],i=e[0]):(s=e[0],i=e[1]);let l=-1;if(n?(u=t[0],l=1):(u=t[1],l=0),t[l]!==i)throw new Error("dimension mismatch");if(s<=0||u<=0||i<=0)throw new Error("invalid shape specified");if(r&&!it.isValidBroadcast(r,[s,u]))throw new Error("gemm: invalid bias shape for broadcast");return[s,u,i]}},et=class a{static tensorDataTypeFromProto(e){switch(e){case H.onnx.TensorProto.DataType.INT8:return"int8";case H.onnx.TensorProto.DataType.UINT8:return"uint8";case H.onnx.TensorProto.DataType.BOOL:return"bool";case H.onnx.TensorProto.DataType.INT16:return"int16";case H.onnx.TensorProto.DataType.UINT16:return"uint16";case H.onnx.TensorProto.DataType.INT32:return"int32";case H.onnx.TensorProto.DataType.UINT32:return"uint32";case H.onnx.TensorProto.DataType.FLOAT:return"float32";case H.onnx.TensorProto.DataType.DOUBLE:return"float64";case H.onnx.TensorProto.DataType.STRING:return"string";case H.onnx.TensorProto.DataType.INT64:return"int32";case H.onnx.TensorProto.DataType.UINT64:return"uint32";default:throw new Error(`unsupported data type: ${H.onnx.TensorProto.DataType[e]}`)}}static tensorDataTypeStringToEnum(e){switch(e){case"int8":return H.onnx.TensorProto.DataType.INT8;case"uint8":return H.onnx.TensorProto.DataType.UINT8;case"bool":return H.onnx.TensorProto.DataType.BOOL;case"int16":return H.onnx.TensorProto.DataType.INT16;case"uint16":return H.onnx.TensorProto.DataType.UINT16;case"int32":return H.onnx.TensorProto.DataType.INT32;case"uint32":return H.onnx.TensorProto.DataType.UINT32;case"float32":return H.onnx.TensorProto.DataType.FLOAT;case"float64":return H.onnx.TensorProto.DataType.DOUBLE;case"string":return H.onnx.TensorProto.DataType.STRING;case"int64":return H.onnx.TensorProto.DataType.INT64;case"uint64":return H.onnx.TensorProto.DataType.UINT64;default:throw new Error(`unsupported data type: ${e}`)}}static tensorDimsFromProto(e){return e.map(o=>kt.isLong(o)?o.toNumber():o)}static tensorValueTypeFromProto(e){return{tensorType:a.tensorDataTypeFromProto(e.elemType),shape:{dims:a.tensorDimsFromProto(e.shape.dim.map(o=>o.dimValue))}}}static tensorDimsFromORTFormat(e){let o=[];for(let t=0;t<e.dimsLength();t++)o.push(ft.longToNumber(e.dims(t)));return o}static tensorAttributesFromORTFormat(e){let o=[];for(let t=0;t<e.attributesLength();t++)o.push(e.attributes(t));return o}},ft=class{static longToNumber(e,o){return kt.isLong(e)?e.toNumber():e instanceof m.Long?kt.fromValue({low:e.low,high:e.high,unsigned:o??!1}).toNumber():e}static isLong(e){return kt.isLong(e)||e instanceof m.Long}},O=class a{static size(e){return a.getSizeFromDimensionRange(e,0,e.length)}static sizeFromDimension(e,o){if(o<0||o>e.length)throw new Error(`invalid dimension of ${o} for sizeFromDimension as Tensor has ${e.length} dimensions.`);return a.getSizeFromDimensionRange(e,o,e.length)}static sizeToDimension(e,o){if(o<0||o>e.length)throw new Error(`invalid dimension of ${o} for sizeToDimension as Tensor has ${e.length} dimensions.`);return a.getSizeFromDimensionRange(e,0,o)}static getSizeFromDimensionRange(e,o,t){let n=1;for(let r=o;r<t;r++){if(e[r]<=0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains 0 or negative values in them.");n*=e[r]}return n}static computeStrides(e){let o=e.length;if(o===0)return[];if(o===1)return[1];let t=new Array(o);t[o-1]=1,t[o-2]=e[o-1];for(let n=o-3;n>=0;--n)t[n]=t[n+1]*e[n+1];return t}static transpose(e){return e.slice().reverse()}static indicesToOffset(e,o,t){t===void 0&&(t=e.length);let n=0;for(let r=0;r<t;++r)n+=o[r]*e[r];return n}static offsetToIndices(e,o){let t=o.length;if(t===0)return[];if(t===1)return[e*o[0]];let n=new Array(o.length);for(let r=0;r<n.length-1;++r)n[r]=Math.floor(e/o[r]),e-=n[r]*o[r];return n[n.length-1]=e,n}static normalizeAxis(e,o){if(e<-o&&e>=o)throw new Error("unsupported axis for this operation.");return e<0?e+o:e}static normalizeAxes(e,o){return e.map(t=>this.normalizeAxis(t,o))}static incrementIndex(e,o,t){if(o.length===0||e.length===0)throw new Error("Index incrementing unsupported for scalar Tensor");if(t===void 0)t=o.length;else if(t<=0||t>o.length)throw new Error("Incorrect axis to increment on");for(let n=t-1;n>=0&&(e[n]++,!(e[n]<o[n]));--n)e[n]=0}static calculateReshapedDims(e,o){if(o.length===0){if(e.length===0||a.size(e)===1)return[];throw new Error("cannot reshape to a scalar Tensor")}let t=o.length,n=new Array(t),r=-1,s=1;for(let u=0;u<t;u++){if(o[u]<-1)throw new Error("a dimension in shape hints cannot be less than -1");if(o[u]===-1){if(r!==-1)throw new Error("at most one dimension in shape hints can be -1");r=u}else{if(o[u]===0){if(u>=e.length)throw new Error("the dimension with value zero exceeds the dimension size of the input tensor");n[u]=e[u]}else n[u]=o[u];s*=n[u]}}let i=a.size(e);if(r!==-1){if(i%s!==0)throw new Error(`the input tensor cannot be reshaped to the requested shape. Input shape: [${e}] Output shape: [${o}]`);n[r]=i/s}else if(s!==i)throw new Error("reshapedDims and originalDims don't have matching sizes");return n}static sortBasedOnPerm(e,o){return o?o.map(t=>e[t]):e.slice().reverse()}static padShape(e,o){let t=e.length;return e.map((n,r)=>n+o[r]+o[r+t])}static areEqual(e,o){return e.length!==o.length?!1:e.every((t,n)=>t===o[n])}static validateDimsAndCalcSize(e){if(e.length>6)throw new TypeError("Only rank 0 to 6 is supported for tensor shape.");let o=1;for(let t of e){if(!Number.isInteger(t))throw new TypeError(`Invalid shape: ${t} is not an integer`);if(t<0||t>2147483647)throw new TypeError(`Invalid shape: length ${t} is not allowed`);o*=t}return o}static flattenShape(e,o){o<0&&(o+=e.length);let t=e.reduce((s,i)=>s*i,1),n=e.slice(o).reduce((s,i)=>s*i,1);return[t/n,n]}static squeezeShape(e,o){let t=new Array;o=a.normalizeAxes(o,e.length);for(let n=0;n<e.length;n++){let r=o.indexOf(n)>=0;if(r&&e[n]!==1)throw new Error("squeeze an axis of size different than 1");(o.length===0&&e[n]>1||o.length>0&&!r)&&t.push(e[n])}return t}static unsqueezeShape(e,o){let t=new Array(e.length+o.length);t.fill(0);for(let r=0;r<o.length;r++){let s=a.normalizeAxis(o[r],t.length);if(s>=t.length)throw new Error("'axes' has an out of range axis");if(t[s]!==0)throw new Error("'axes' has a duplicate axis");t[s]=1}let n=0;for(let r=0;r<t.length;r++)t[r]===0&&(t[r]=e[n++]);if(n!==e.length)throw new Error("the unsqueezed dimension could not be established");return t}},Se=class a{static splitShape(e,o,t,n){if(t.length===0){if(!n)throw new Error("need to know number of outputs when the 'split' attribute is not specified");a.determineSplit(e[o],n,t)}let r=[],s=[0];for(let i=0;i<t.length;++i){i!==0&&s.push(s[i-1]+t[i-1]);let u=e.slice();u[o]=t[i],r.push(u)}return[r,s]}static determineSplit(e,o,t){if(e%o!==0)throw new Error("cannot split tensor to equal sized parts");for(let n=0;n<o;++n)t.push(e/o)}},Xt=class a{static adjustPoolAttributes(e,o,t,n,r,s){if(!e&&t.length!==o.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(e)for(let i=0;i<o.length-2;i++)i>=t.length?t.push(o[i+2]):t[i]=o[i+2];for(let i=0;i<t.length;i++)if(i<n.length){if(n[i]<0)throw new Error("strides should be greater than or equal to 1")}else n.push(1);for(let i=0;i<t.length;i++)if(i<r.length){if(r[i]<0)throw new Error("dilations should be greater than or equal to 1")}else r.push(1);for(let i=0;i<t.length*2;i++)if(i<s.length){if(s[i]<0)throw new Error("pad should be greater than or equal to 1")}else s.push(0);for(let i=0;i<t.length;i++){if(t[i]<=0)throw new Error("kernel shapes need to be greater than 0");if(s[i]>=t[i]||s[i+t.length]>=t[i])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(e,o,t,n,r,s){if(s){if(r.length!==2*(e.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(o.length!==e.length-2)throw new Error("length of strides should be the length of data dimensions");if(n.length!==e.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let i=0;i<e.length-2;i++)a.adjustPadAndReturnShape(e[i+2],o[i],t[i],n[i],r,i,i+e.length-2,s)}}static computePoolOutputShape(e,o,t,n,r,s,i){if(o.length<=0)throw new Error("input shape must be of size greater than 0");let u=[o[0],o[1]];return a.computeShapeHelper(e,o,u,t,n,r,s,i),u}static computeConvOutputShape(e,o,t,n,r,s,i){if(e.length<=0||o.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");let u=[e[0],o[0]];return a.computeShapeHelper(!1,e,u,t,n,r,s,i),u}static computeShapeHelper(e,o,t,n,r,s,i,u){if(e)for(let l=0;l<o.length-2;l++)t.push(1);else for(let l=0;l<o.length-2;l++)t.push(a.adjustPadAndReturnShape(o[l+2],n[l],r[l],s[l],i,l,l+o.length-2,u))}static adjustPadAndReturnShape(e,o,t,n,r,s,i,u){let l=t*(n-1)+1;if(u&&u!=="NOTSET")switch(u){case"VALID":return r[s]=0,r[i]=0,Math.floor((e-l)/o+1);case"SAME_LOWER":case"SAME_UPPER":if(t!==1)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{let p=((e+o-1)/o-1)*o+n-e;return r[s]=Math.floor(u==="SAME_LOWER"?(p+1)/2:p/2),r[i]=p-r[s],Math.floor((e+p-n)/o+1)}default:throw new Error("Unsupported AutoPad type")}else return Math.floor((e+r[s]+r[i]-l)/o+1)}},Jt=-34028234663852886e22,Zt=34028234663852886e22});function Zl(a){switch(a){case"bool":case"int8":case"uint8":return 1;case"int16":case"uint16":return 2;case"int32":case"uint32":case"float32":return 4;case"float64":return 8;default:throw new Error(`cannot calculate sizeof() on type ${a}`)}}function Ri(a){switch(a){case k.onnx.TensorProto.DataType.UINT8:case k.onnx.TensorProto.DataType.INT8:case k.onnx.TensorProto.DataType.BOOL:return 1;case k.onnx.TensorProto.DataType.UINT16:case k.onnx.TensorProto.DataType.INT16:return 2;case k.onnx.TensorProto.DataType.FLOAT:case k.onnx.TensorProto.DataType.INT32:case k.onnx.TensorProto.DataType.UINT32:return 4;case k.onnx.TensorProto.DataType.INT64:case k.onnx.TensorProto.DataType.DOUBLE:case k.onnx.TensorProto.DataType.UINT64:return 8;default:throw new Error(`cannot calculate sizeof() on type ${k.onnx.TensorProto.DataType[a]}`)}}function Yl(a,e){return new(Mi(e))(a)}function Mi(a){switch(a){case"bool":case"uint8":return Uint8Array;case"int8":return Int8Array;case"int16":return Int16Array;case"uint16":return Uint16Array;case"int32":return Int32Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"float32":return Float32Array;case"float64":return Float64Array;default:throw new Error("unspecified error")}}function un(a,e){if(e===k.onnx.TensorProto.DataType.INT64||e===sn.TensorDataType.INT64){if(a.greaterThanOrEqual(2147483648)||a.lessThan(-2147483648))throw new TypeError("int64 is not supported")}else if(e===k.onnx.TensorProto.DataType.UINT32||e===sn.TensorDataType.UINT32||e===k.onnx.TensorProto.DataType.UINT64||e===sn.TensorDataType.UINT64){if(a.greaterThanOrEqual(4294967296)||a.lessThan(0))throw new TypeError("uint64 is not supported")}else throw new TypeError(`not a LONG type: ${k.onnx.TensorProto.DataType[e]}`);return a.toNumber()}function Vi(a,e,o){switch(e){case k.onnx.TensorProto.DataType.BOOL:case k.onnx.TensorProto.DataType.UINT8:return a.getUint8(o);case k.onnx.TensorProto.DataType.INT8:return a.getInt8(o);case k.onnx.TensorProto.DataType.UINT16:return a.getUint16(o,!0);case k.onnx.TensorProto.DataType.INT16:return a.getInt16(o,!0);case k.onnx.TensorProto.DataType.FLOAT:return a.getFloat32(o,!0);case k.onnx.TensorProto.DataType.INT32:return a.getInt32(o,!0);case k.onnx.TensorProto.DataType.UINT32:return a.getUint32(o,!0);case k.onnx.TensorProto.DataType.INT64:return un(kt.fromBits(a.getUint32(o,!0),a.getUint32(o+4,!0),!1),e);case k.onnx.TensorProto.DataType.DOUBLE:return a.getFloat64(o,!0);case k.onnx.TensorProto.DataType.UINT64:return un(kt.fromBits(a.getUint32(o,!0),a.getUint32(o+4,!0),!0),e);default:throw new Error(`cannot read from DataView for type ${k.onnx.TensorProto.DataType[e]}`)}}var zi,k,sn,Y,Yt=x(()=>{"use strict";zi=ne(Do());Hr();ve();k=ne(se());z();sn=P.experimental.fbs,Y=class a{constructor(e,o,t,n,r,s=zi.Guid.create()){this.dims=e;this.type=o;this.dataProvider=t;this.asyncDataProvider=n;this.cache=r;this.dataId=s;this.size=O.validateDimsAndCalcSize(e);let i=this.size,u=t===void 0&&n===void 0&&r===void 0;if(r!==void 0&&r.length!==i)throw new RangeError("Input dims doesn't match data length.");if(o==="string"){if(r!==void 0&&(!Array.isArray(r)||!r.every(l=>typeof l=="string")))throw new TypeError("cache should be a string array");u&&(this.cache=new Array(i))}else{if(r!==void 0){let l=Mi(o);if(!(r instanceof l))throw new TypeError(`cache should be type ${l.name}`)}if(u){let l=new ArrayBuffer(i*Zl(o));this.cache=Yl(l,o)}}}get data(){if(this.cache===void 0){let e=this.dataProvider(this.dataId);if(e.length!==this.size)throw new Error("Length of data provided by the Data Provider is inconsistent with the dims of this Tensor.");this.cache=e}return this.cache}get stringData(){if(this.type!=="string")throw new TypeError("data type is not string");return this.data}get integerData(){switch(this.type){case"uint8":case"int8":case"uint16":case"int16":case"int32":case"uint32":case"bool":return this.data;default:throw new TypeError("data type is not integer (uint8, int8, uint16, int16, int32, uint32, bool)")}}get floatData(){switch(this.type){case"float32":case"float64":return this.data;default:throw new TypeError("data type is not float (float32, float64)")}}get numberData(){if(this.type!=="string")return this.data;throw new TypeError("type cannot be non-number (string)")}get(e){return this.data[O.indicesToOffset(e,this.strides)]}set(e,o){this.data[O.indicesToOffset(e,this.strides)]=o}async getData(){return this.cache===void 0&&(this.cache=await this.asyncDataProvider(this.dataId)),this.cache}get strides(){return this._strides||(this._strides=O.computeStrides(this.dims)),this._strides}static fromProto(e){if(!e)throw new Error("cannot construct Value from an empty tensor");let o=et.tensorDataTypeFromProto(e.dataType),t=et.tensorDimsFromProto(e.dims),n=new a(t,o);if(o==="string")e.stringData.forEach((r,s)=>{n.data[s]=Ae(r)});else if(e.rawData&&typeof e.rawData.byteLength=="number"&&e.rawData.byteLength>0){let r=n.data,s=new DataView(e.rawData.buffer,e.rawData.byteOffset,e.rawData.byteLength),i=Ri(e.dataType),u=e.rawData.byteLength/i;if(e.rawData.byteLength%i!==0)throw new Error("invalid buffer length");if(r.length!==u)throw new Error("buffer length mismatch");for(let l=0;l<u;l++){let f=Vi(s,e.dataType,l*i);r[l]=f}}else{let r;switch(e.dataType){case k.onnx.TensorProto.DataType.FLOAT:r=e.floatData;break;case k.onnx.TensorProto.DataType.INT32:case k.onnx.TensorProto.DataType.INT16:case k.onnx.TensorProto.DataType.UINT16:case k.onnx.TensorProto.DataType.INT8:case k.onnx.TensorProto.DataType.UINT8:case k.onnx.TensorProto.DataType.BOOL:r=e.int32Data;break;case k.onnx.TensorProto.DataType.INT64:r=e.int64Data;break;case k.onnx.TensorProto.DataType.DOUBLE:r=e.doubleData;break;case k.onnx.TensorProto.DataType.UINT32:case k.onnx.TensorProto.DataType.UINT64:r=e.uint64Data;break;default:throw new Error("unspecific error")}if(r==null)throw new Error("failed to populate data from a tensorproto value");let s=n.data;if(s.length!==r.length)throw new Error("array length mismatch");for(let i=0;i<r.length;i++){let u=r[i];kt.isLong(u)?s[i]=un(u,e.dataType):s[i]=u}}return n}static fromData(e,o,t){return new a(o,t,void 0,void 0,e)}static fromOrtTensor(e){if(!e)throw new Error("cannot construct Value from an empty tensor");let o=et.tensorDimsFromORTFormat(e),t=et.tensorDataTypeFromProto(e.dataType()),n=new a(o,t);if(t==="string")for(let r=0;r<e.stringDataLength();r++)n.data[r]=e.stringData(r);else if(e.rawDataArray()&&typeof e.rawDataLength()=="number"&&e.rawDataLength()>0){let r=n.data,s=new DataView(e.rawDataArray().buffer,e.rawDataArray().byteOffset,e.rawDataLength()),i=Ri(e.dataType()),u=e.rawDataLength()/i;if(e.rawDataLength()%i!==0)throw new Error("invalid buffer length");if(r.length!==u)throw new Error("buffer length mismatch");for(let l=0;l<u;l++){let f=Vi(s,e.dataType(),l*i);r[l]=f}}return n}}});function D(a){return a===1?Ql:tf}function Ui(a){let e=D(a);return`${e.version}
      precision highp float;
      ${e.attribute} vec3 position;
      ${e.attribute} vec2 textureCoord;

      ${e.varyingVertex} vec2 TexCoords;

      void main()
      {
          gl_Position = vec4(position, 1.0);
          TexCoords = textureCoord;
      }`}function Wi(a){let e=D(a);return`${e.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${e.varyingFrag} vec2 TexCoords;
    ${e.outputDeclaration}
    const vec2 halfCR = vec2(0.5, 0.5);

    // Custom vector types to handle higher dimenalities.
    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    `}function Hi(a,e){let o=D(a);return`
  void main() {
    int indices[${e}];
    toVec(TexCoords, indices);
    vec4 result = vec4(process(indices));
    ${o.output} = result;
  }
  `}var Ql,tf,q=x(()=>{"use strict";Ql={version:"",attribute:"attribute",varyingVertex:"varying",varyingFrag:"varying",texture2D:"texture2D",output:"gl_FragColor",outputDeclaration:""},tf={version:"#version 300 es",attribute:"in",varyingVertex:"out",varyingFrag:"in",texture2D:"texture",output:"outputColor",outputDeclaration:"out vec4 outputColor;"}});var N=x(()=>{"use strict"});async function ln(a,e=t=>0,o){return new Promise((t,n)=>{let r=0,s=()=>{if(a()){t();return}r++;let i=e(r);if(o!=null&&r>=o){n();return}setTimeout(s,i)};s()})}function rr(a){return ue(typeof a<"u"&&a.length!==0,()=>"empty string found for sampler name"),"get"+a.charAt(0).toUpperCase()+a.slice(1)}function qi(a){return ue(typeof a<"u"&&a.length!==0,()=>"empty string found for sampler name"),"get"+a.charAt(0).toUpperCase()+a.slice(1)+"AtOutCoords"}function le(a,e){let o=JSON.parse(JSON.stringify(a));return o=e,o}function fe(a,e){return e.map(o=>a[o]).join(", ")}function at(a){if(a<=1)return"int";if(a===2)return"ivec2";if(a===3)return"ivec3";if(a===4)return"ivec4";if(a===5)return"ivec5";if(a===6)return"ivec6";throw Error(`GPU for rank ${a} is not yet supported`)}function St(a=6){return["x","y","z","w","u","v"].slice(0,a)}var Pt=x(()=>{"use strict";z()});function ef(a,e){return St(e).map(o=>`${a}.${o}`)}function ce(a,e){return e===1?[a]:ef(a,e)}function Et(){return`
    float getChannel(vec4 frag, int dim) {
      int modCoord = imod(dim, 2);
      return modCoord == 0 ? frag.r : frag.g;
    }

    float getChannel(vec4 frag, vec2 innerDims) {
      vec2 modCoord = mod(innerDims, 2.);
      return modCoord.x == 0. ?
        (modCoord.y == 0. ? frag.r : frag.g) :
        (modCoord.y == 0. ? frag.b : frag.a);
    }
  `}var Qt=x(()=>{"use strict";Pt()});function nf(a,e,o){if(a===0)return"false";if(a===1)return`rc > ${e[0]}`;let t="";for(let n=a-2;n<a;n++)t+=`${o[n]} >= ${e[n-a+2]}`,n<a-1&&(t+="||");return t}function of(a,e){let o=a.length;if(o===0)return"getA(), 0, 0, 0";if(o===1)return`getA(rc),
            rc + 1 >= ${a[0]} ? 0. : getA(rc + 1),
            0, 0`;let t="r, c",n="r, cp1",r="rp1, c",s="rp1, cp1",i="";if(o>2)for(let u=0;u<o-2;++u)i=i+`${e[u]},`;return`getA(${i}${t}),
          rEdge ? 0. : getA(${i}${r}),
          cEdge ? 0. : getA(${i}${n}),
          rEdge || cEdge ? 0. : getA(${i}${s})`}function af(a,e,o,t){return a===0||a===1?"":`
    int r = ${e[a-2]};
    int c = ${e[a-1]};
    int rp1 = ${e[a-2]} + 1;
    int cp1 = ${e[a-1]} + 1;
    bool rEdge = rp1 >= ${t};
    bool cEdge = cp1 >= ${o};
    `}var ji,rf,Ki,Xi=x(()=>{"use strict";q();N();Pt();Qt();ji={name:"pack",inputNames:["A"],inputTypes:[1]},rf=(a,e)=>{let o=D(a.session.backend.glContext.version),t=e.dims,n=t.length,r=e.dims.length,s=at(r),i=ce("rc",r),u=af(r,i,t[t.length-2],t[t.length-1]),l;n===0?l=[1,1]:n===1?l=[t[0],1]:l=[t[r-1],t[r-2]];let f=nf(r,l,i),p=of(t,i),d=`
        void main() {
          ${s} rc = getOutputCoords();

          if(${f}) {
            ${o.output} = vec4(0);
          } else {
            ${u}

            ${o.output} = vec4(${p});
          }
        }
      `;return{...ji,hasMain:!0,output:{dims:e.dims,type:e.type,textureType:2},shaderSource:d}},Ki=(a,e)=>({...ji,get:()=>rf(a,e)})});function fn(a){if(a.length===0)return[1,1,1];let e=1;for(let o=0;o<a.length-2;++o)e*=a[o];return[e,a.length>1?a[a.length-2]:1,a[a.length-1]]}function Zi(a,e){let o=!1;return a.length===0||e.length===0?o=!0:a.length<2||e.length<2?o=a[a.length-1]===e[e.length-1]:o=a[a.length-1]===e[e.length-1]&&a[a.length-2]===e[e.length-2],o}function lf(a){let e=O.computeStrides(a),o=["b","r","c"],t="index";return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${e.map((r,s)=>{let i=`int ${o[s]} = ${t} / ${r}`,u=s===e.length-1?`int ${o[s+1]} = ${t} - ${o[s]} * ${r}`:`index -= ${o[s]} * ${r}`;return`${i}; ${u};`}).join("")}
      return ivec3(b, r, c);
    }
  `}function ff(a){let e=O.computeStrides(a);return`
  int getFlattenedIndex(ivec3 coords) {
    // reverse y, z order
    return coords.x * ${e[0]} + coords.z * ${e[1]} + coords.y;
  }
`}var sf,uf,Ji,Yi=x(()=>{"use strict";z();q();N();Qt();sf=a=>({name:"Reshape (packed)",inputTypes:[2],inputNames:["A"],cacheHint:`${a}`}),uf=(a,e,o,t)=>{let n=e.dims,r=t,s="";for(let l=0;l<4;l++){let f="";switch(l){case 0:f="outputCoords = rc;";break;case 1:f="outputCoords = ivec3(rc.x, rc.y+1, rc.z);";break;case 2:f="outputCoords = ivec3(rc.x, rc.y, rc.z+1);";break;case 3:f="outputCoords = ivec3(rc.x, rc.y+1, rc.z+1);";break;default:throw new Error}s+=`
        ${f}
        ${l>0?"if(outputCoords.y < rows && outputCoords.z < cols){":""}
          int flattenedIndex = getFlattenedIndex(outputCoords);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flattenedIndex);
          vec2 innerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${l}] = getChannel(getA(inputRC.x, inputRC.y, inputRC.z), innerDims);

        ${l>0?"}":""}
      `}let i=D(a.session.backend.glContext.version),u=`
      ${lf(n)}
      ${ff(r)}
      ${Et()}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.0);

        ivec3 outputCoords;
        int rows = ${r[2]};
        int cols = ${r[1]};

        ${s}
        ${i.output} = result;
      }
    `;return{...o,output:{dims:r,type:e.type,textureType:2},shaderSource:u,hasMain:!0}},Ji=(a,e,o)=>{let t=sf(o);return{...t,get:()=>uf(a,e,t,o)}}});var cn,Qi=x(()=>{"use strict";q();N();cn=(a,e)=>{let o=e.shape,t=D(a.session.backend.glContext.version),n=`
    const float FLOAT_MAX = 1.70141184e38;
    const float FLOAT_MIN = 1.17549435e-38;

    bool isNaN(float val) {
      return (val < 1.0 || 0.0 < val || val == 0.0) ? false : true;
    }

    highp vec4 encodeAsUint8(highp float v) {
      if (isNaN(v)) {
        return vec4(255, 255, 255, 255);
      }

      highp float av = abs(v);

      if(av < FLOAT_MIN) {
        return vec4(0.0, 0.0, 0.0, 0.0);
      } else if(v > FLOAT_MAX) {
        return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
      } else if(v < -FLOAT_MAX) {
        return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
      }

      highp vec4 c = vec4(0,0,0,0);

      highp float e = floor(log2(av));
      highp float m = exp2(fract(log2(av))) - 1.0;

      c[2] = floor(128.0 * m);
      m -= c[2] / 128.0;
      c[1] = floor(32768.0 * m);
      m -= c[1] / 32768.0;
      c[0] = floor(8388608.0 * m);

      highp float ebias = e + 127.0;
      c[3] = floor(ebias / 2.0);
      ebias -= c[3] * 2.0;
      c[2] += floor(ebias) * 128.0;

      c[3] += 128.0 * step(0.0, -v);

      return c / 255.0;
    }

    void main() {
      float value = ${t.texture2D}(X,TexCoords).r;
      ${t.output} = encodeAsUint8(value);
    }`,r={name:"Uint8Encode",inputTypes:[0],inputNames:["X"],output:{dims:o,type:e.tensor.type,textureType:3},shaderSource:n,hasMain:!0};return a.executeProgram(r,[e.tensor])}});function pf(a,e){if(a===1)return"rc";let o="";for(let t=0;t<a;t++)o+=e[t],t<a-1&&(o+=",");return o}var ta,cf,ea,ra=x(()=>{"use strict";q();N();Pt();Qt();ta={name:"unpack",inputNames:["A"],inputTypes:[2]},cf=(a,e)=>{let o=e.dims.length,t=ce("rc",o),n=t.slice(-2),r=at(o),s=Et(),u=e.dims.length===0?"":pf(o,t),l=o<=1?"rc":`vec2(${n.join(",")})`,f=D(a.session.backend.glContext.version),p=`
    ${s}
    void main() {
      ${r} rc = getOutputCoords();

       // Sample the texture with the coords to get the rgba channel value.
       vec4 packedInput = getA(${u});

       ${f.output} = vec4(getChannel(packedInput, ${l}), 0, 0, 0);
     }
   `;return{...ta,hasMain:!0,output:{dims:e.dims,type:e.type,textureType:0},shaderSource:p}},ea=(a,e)=>({...ta,get:()=>cf(a,e)})});var nr,Oe,or,Pe=x(()=>{"use strict";pt();nr=class{constructor(e,o=1){if(o===1)this.internalFormat=e.R32F,this.format=e.RED,this.textureType=e.FLOAT,this.channelSize=o;else if(o===4)this.internalFormat=e.RGBA32F,this.format=e.RGBA,this.textureType=e.FLOAT,this.channelSize=o;else throw new Error(`Invalid number of channels: ${o}`)}encode(e,o){let t,n;return e.constructor!==Float32Array&&(M.warning("Encoder","data was not of type Float32; creating new Float32Array"),n=new Float32Array(e)),o*this.channelSize>e.length?(M.warning("Encoder","Source data too small. Allocating larger array"),n=e,t=this.allocate(o*this.channelSize),n.forEach((r,s)=>t[s]=r)):(n=e,t=n),t}allocate(e){return new Float32Array(e*4)}decode(e,o){return this.channelSize===1?e.filter((n,r)=>r%4===0).subarray(0,o):e.subarray(0,o)}},Oe=class{constructor(e,o=1,t){if(o!==1&&o!==4)throw new Error(`Invalid number of channels: ${o}`);this.internalFormat=e.RGBA,this.format=e.RGBA,this.channelSize=o,this.textureType=t||e.FLOAT}encode(e,o){let t=e;return this.channelSize===1&&(M.verbose("Encoder","Exploding into a larger array"),t=this.allocate(o),e.forEach((n,r)=>t[r*4]=n)),t}allocate(e){return new Float32Array(e*4)}decode(e,o){return this.channelSize===1?e.filter((n,r)=>r%4===0).subarray(0,o):e.subarray(0,o)}},or=class{constructor(e,o=1){this.channelSize=4;if(o===1)this.internalFormat=e.ALPHA,this.format=e.ALPHA,this.textureType=e.UNSIGNED_BYTE,this.channelSize=o;else if(o===4)this.internalFormat=e.RGBA,this.format=e.RGBA,this.textureType=e.UNSIGNED_BYTE,this.channelSize=o;else throw new Error(`Invalid number of channels: ${o}`)}encode(e,o){return new Uint8Array(e.buffer,e.byteOffset,e.byteLength)}allocate(e){return new Uint8Array(e*this.channelSize)}decode(e,o){if(e instanceof Uint8Array)return e.subarray(0,o);throw new Error(`Invalid array type: ${e.constructor}`)}}});var Ee,na,pn,oa=x(()=>{"use strict";z();N();Ee=(a,e,o)=>{let t=o===0||o===1?1:4,n=o===2,r=o===1||o===2,s=o===4?e.length-1:void 0,i=o===4?e.map((u,l)=>l===e.length-1?u*4:u):void 0;return pn(a,e,t,i,{isPacked:n,reverseWH:r,breakAxis:s})},na=(a,e,o)=>{let t=Ee(a,e,o);return[t.width,t.height]},pn=(a,e,o=1,t,n)=>{let r=!!(n&&n.isPacked),[s,i]=a.computeTextureWH(r&&t||e,n),u=e.length,l=e.slice(0);if(u===0&&(l=[1]),o===1)t=e;else if(r){if(o!==4)throw new Error("a packed texture must be 4-channel");t=e,u>0&&(l[u-1]=Math.ceil(l[u-1]/2)),u>1&&(l[u-2]=Math.ceil(l[u-2]/2))}else if(!t)throw new Error("Unpacked shape is needed when using channels > 1");return{width:s,height:i,channels:o,isPacked:r,shape:l,strides:O.computeStrides(l),unpackedShape:t,reversedWH:n&&n.reverseWH}}});var hf,ir,aa=x(()=>{"use strict";pt();Yt();z();Xi();Yi();Qi();ra();Pe();oa();N();hf=(a,e)=>{let o=e.map(n=>`${n.unpackedShape.join(",")};${n.width}x${n.height}`).join("_"),t=a.name;return a.cacheHint&&(t+="["+a.cacheHint+"]"),t+=":"+o,t},ir=class{constructor(e){this.session=e;this.packedTextureDataCache=new Map,this.unpackedTextureDataCache=new Map}calculateTextureWidthAndHeight(e,o){return na(this.session.layoutStrategy,e,o)}executeProgram(e,o){if(o.length<e.inputNames.length)throw new Error(`Input size mustn't be less than ${e.inputNames.length}.`);if(e.inputNames.length!==e.inputTypes.length)throw new Error("input names size does not match input types");let t=[];for(let l=0;l<e.inputNames.length;++l)t[l]=this.getOrCreateTextureData(o[l],e.inputTypes[l]);let n=hf(e,t),r=this.session.programManager.getArtifact(n),s=r?r.programInfo:typeof e.get=="function"?e.get():e,i=Ee(this.session.layoutStrategy,s.output.dims,s.output.textureType),u=this.createTextureData(i,s.output.type);return r||(r=this.session.programManager.build(s,t,u),this.session.programManager.setArtifact(n,r)),this.runProgram(r,t,u),u}run(e,o){return this.executeProgram(e,o).tensor}runProgram(e,o,t){for(let n=0;n<o.length;++n)if(!!o[n].isPacked!=(e.programInfo.inputTypes[n]===2))throw new Error(`input[${n}] property packed inconsistent`);if(!!t.isPacked!=(e.programInfo.output.textureType===2))throw new Error("output property packed inconsistent");this.session.programManager.run(e,o,t)}getOrCreateTextureData(e,o){let t=this.getTextureData(e.dataId,o===2);if(!t&&(t=this.getTextureData(e.dataId,o!==2),t))return o===2?this.pack(t):this.unpack(t);if(!t){let n=Ee(this.session.layoutStrategy,e.dims,o);if(o===4){let i=e.dims;if(i.length===4){let u=[i[0],Math.ceil(i[1]*i[2]*i[3]/4)],l=Ee(this.session.layoutStrategy,u,o),f=e.numberData;if(i[1]*i[2]*i[3]%4!==0){let p=i[0],d=i[1]*i[2]*i[3],b=Math.ceil(d*1/4)*4,g=p*b;f=new Float32Array(g);for(let y=0;y<p;++y){let v=y*d,_=y*b+y%1*d;f.set(e.numberData.subarray(v,v+d),_)}}return this.createTextureData(l,e.type,f,e,1)}}if(o===2){let r=pn(this.session.layoutStrategy,e.dims,1,[],{reverseWH:!0}),s=this.createTextureData(r,e.type,e.numberData,e,1);t=this.pack(s)}else t=this.createTextureData(n,e.type,e.numberData,e,1)}return t}createTextureDataFromLayoutBindTensor(e,o,t,n){return this.createTextureData(e,o,t,n,1)}createTextureData(e,o,t,n,r){M.verbose("InferenceHandler",`Creating TextureData: layout:[${JSON.stringify(e)}]`);let s=this.session.textureManager.createTextureFromLayout(o,e,t,r);return this.createTextureDataFromTexture(e,o,s,n)}reshapeUnpacked(e,o){let t=this.getOrCreateTextureData(e,0),n={channels:t.channels,height:t.height,width:t.width,shape:o.length!==0?o:[1],strides:O.computeStrides(o),unpackedShape:o};return this.createTextureDataFromTexture(n,e.type,t.texture).tensor}reshapePacked(e,o){let t=this.getOrCreateTextureData(e,2);if(Zi(e.dims,o)){let l={channels:t.channels,height:t.height,width:t.width,shape:o.length!==0?o:[1],strides:O.computeStrides(o),unpackedShape:o,isPacked:!0};return this.createTextureDataFromTexture(l,e.type,t.texture).tensor}let n=fn(e.dims),r=fn(o),s=this.reshapePacked(e,n),i=this.run(Ji(this,s,r),[s]);return this.reshapePacked(i,o)}cast(e,o){let t=this.getOrCreateTextureData(e,0);return this.createTextureDataFromTexture(t,o,t.texture).tensor}createTextureDataFromTexture(e,o,t,n,r){let s={...e,tensor:n||new Y(e.unpackedShape,o,i=>this.readTexture(s),async i=>this.readTextureAsync(s),void 0,r),texture:t};return this.setTextureData(s.tensor.dataId,s,e.isPacked),s}getTextureData(e,o=!1){return this.session.isInitializer(e)?this.session.getTextureData(e,o):o?this.packedTextureDataCache.get(e):this.unpackedTextureDataCache.get(e)}setTextureData(e,o,t=!1){this.session.isInitializer(e)?this.session.setTextureData(e,o,t):(t?this.packedTextureDataCache:this.unpackedTextureDataCache).set(e,o)}isTextureLayoutCached(e,o=!1){return!!this.getTextureData(e.dataId,o)}dispose(){this.session.textureManager.clearActiveTextures(),this.packedTextureDataCache.forEach(e=>this.session.textureManager.releaseTexture(e)),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache.forEach(e=>this.session.textureManager.releaseTexture(e)),this.unpackedTextureDataCache=new Map}readTexture(e){return e.isPacked?this.readTexture(this.unpack(e)):this.session.backend.glContext.isFloat32DownloadSupported?this.session.textureManager.readTexture(e,e.tensor.type,e.channels):this.session.textureManager.readUint8TextureAsFloat(cn(this,e))}async readTextureAsync(e){return e.isPacked?this.readTextureAsync(this.unpack(e)):this.session.backend.glContext.isFloat32DownloadSupported?this.session.textureManager.readTextureAsync(e,e.tensor.type,e.channels):this.session.textureManager.readUint8TextureAsFloat(cn(this,e))}pack(e){return this.executeProgram(Ki(this,e.tensor),[e.tensor])}unpack(e){return this.executeProgram(ea(this,e.tensor),[e.tensor])}}});var dn,$,tt=x(()=>{"use strict";dn=class{constructor(e){Object.assign(this,e)}get cacheKey(){return this.key||(this.key=Object.getOwnPropertyNames(this).sort().map(e=>`${this[e]}`).join(";")),this.key}},$=a=>new dn(a)});var sa,ua,la,mf,bf,fa=x(()=>{"use strict";tt();q();N();sa={name:"BatchNormalization",inputNames:["A","Scale","B","Mean","Variance"],inputTypes:[0,0,0,0,0]},ua=(a,e,o)=>(bf(e),[a.run({...sa,cacheHint:o.cacheKey,get:()=>mf(a,e,o)},e)]),la=a=>{let e=a.attributes.getFloat("epsilon",1e-5),o=a.attributes.getFloat("momentum",.9),t=a.attributes.getInt("spatial",1);return $({epsilon:e,momentum:o,spatial:t})},mf=(a,e,o)=>{let t=D(a.session.backend.glContext.version),n=e[0].dims.length,[r,s]=a.calculateTextureWidthAndHeight(e[1].dims,0),i=`
  float process(int[${n}] indices) {
    vec2 position = offsetToCoords(indices[1], ${r}, ${s});
    float scale = getColorAsFloat(${t.texture2D}(Scale, position));
    float mean = getColorAsFloat(${t.texture2D}(Mean, position));
    float variance = getColorAsFloat(${t.texture2D}(Variance, position));
    float b = getColorAsFloat(${t.texture2D}(B, position));

    return scale * ( (_A(indices) - mean) / sqrt(variance + float(${o.epsilon})) ) + b;
  }`;return{...sa,output:{dims:e[0].dims,type:e[0].type,textureType:0},shaderSource:i}},bf=a=>{if(!a||a.length!==5)throw new Error("BatchNormalization requires 5 inputs.");let e=a[0],o=a[1],t=a[2],n=a[3],r=a[4];if(e.dims.length<3||o.dims.length!==1||t.dims.length!==1||n.dims.length!==1||r.dims.length!==1)throw new Error("invalid input shape.");if(o.dims[0]!==e.dims[1]||t.dims[0]!==e.dims[1]||n.dims[0]!==e.dims[1]||r.dims[0]!==e.dims[1])throw new Error("invalid input shape.");if(e.type!=="float32"&&e.type!=="float64"||o.type!=="float32"&&o.type!=="float64"||t.type!=="float32"&&t.type!=="float64"||n.type!=="float32"&&n.type!=="float64"||r.type!=="float32"&&r.type!=="float64")throw new Error("invalid input tensor types.")}});var ar,bt,I,De,sr,Bt=x(()=>{"use strict";ar=class{constructor(e,o,t,n){this.glContext=e;this.programInfo=o;this.inputTextureLayouts=t;this.outputTextureLayout=n}},bt=class{constructor(e){this.context=e}},I=class{constructor(e,o){this.routineBody=e;this.dependencies=o}},De=class{constructor(e,o,t){this.name=e;t?this.dependencies=t:this.dependencies=[],o&&(this.routineBody=o)}addDependency(e){e&&this.dependencies.push(e)}},sr=class{static returnOrderedNodes(e){if(!e||e.length===0)return[];if(e.length===1)return e;let o=new Set,t=new Set,n=new Array;return this.createOrderedNodes(e,o,t,n),n}static createOrderedNodes(e,o,t,n){for(let r=0;r<e.length;++r)this.dfsTraverse(e[r],o,t,n)}static dfsTraverse(e,o,t,n){if(!e||t.has(e.name))return;if(o.has(e.name))throw new Error("Cyclic dependency detected. Can't topologically sort routines needed for shader.");o.add(e.name);let r=e.dependencies;if(r&&r.length>0)for(let s=0;s<r.length;++s)this.dfsTraverse(r[s],o,t,n);n.push(e),t.add(e.name),o.delete(e.name)}}});function gf(){let a="add_";return{body:`
  float ${a}(float a, float b) {
    return a + b;
  }
  vec4 ${a}(vec4 v1, vec4 v2) {
    return v1 + v2;
  }
  `,name:a,type:0}}function xf(){let a="div_";return{body:`
  float ${a}(float a, float b) {
    return a / b;
  }
  vec4 ${a}(vec4 v1, vec4 v2) {
    return v1 / v2;
  }
  `,name:a,type:0}}function Tf(){let a="mul_";return{body:`
  float ${a}(float a, float b) {
    return a * b;
  }
  vec4 ${a}(vec4 v1, vec4 v2) {
    return v1 * v2;
  }
  `,name:a,type:0}}function vf(){let a="sub_";return{body:`
  float ${a}(float a, float b) {
    return a - b;
  }
  vec4 ${a}(vec4 v1, vec4 v2) {
    return v1 - v2;
  }
  `,name:a,type:0}}function wf(){let a="equal_";return{body:`
  float ${a}(float a, float b) {
    return float(a == b);
  }
  vec4 ${a}(vec4 v1, vec4 v2) {
    return vec4(equal(v1, v2));
  }
  `,name:a,type:0}}function If(){let a="greater_";return{body:`
  float ${a}(float a, float b) {
    return float(a > b);
  }
  vec4 ${a}(vec4 v1, vec4 v2) {
    return vec4( v1.r > v2.r ,
      v1.g > v2.g,
      v1.b > v2.b,
      v1.a > v2.a );
  }
  `,name:a,type:0}}function _f(){let a="less_";return{body:`
  float ${a}(float a, float b) {
    return float(a < b);
  }
  vec4 ${a}(vec4 v1, vec4 v2) {
    return vec4( v1.r < v2.r ,
                v1.g < v2.g,
                v1.b < v2.b,
                v1.a < v2.a );
  }
  `,name:a,type:0}}function Sf(){let a="and_";return{body:`
  float ${a}(float a, float b) {
    return float( bool(a) && bool(b) );
  }
  vec4 ${a}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r && b2.r ,
                b1.g && b2.g,
                b1.b && b2.b,
                b1.a && b2.a );
  }
  `,name:a,type:0}}function Af(){let a="or_";return{body:`
  float ${a}(float a, float b) {
    return float( bool(a) || bool(b) );
  }
  vec4 ${a}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r || b2.r ,
                b1.g || b2.g,
                b1.b || b2.b,
                b1.a || b2.a );
  }
  `,name:a,type:0}}function Of(){let a="xor_";return{body:`
  float ${a}(float a, float b) {
    return float( bool(a) ^^ bool(b) );
  }
  vec4 ${a}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r ^^ b2.r ,
                b1.g ^^ b2.g,
                b1.b ^^ b2.b,
                b1.a ^^ b2.a );
  }
  `,name:a,type:0}}function Pf(){return Df("pow")}function Ef(){let a="prelu_";return{body:`
  float ${a}(float a, float b) {
    return a < 0.0 ? a * b: a;
  }
  vec4 ${a}(vec4 v1, vec4 v2) {
    return vec4(
      v1.r < 0.0 ? v1.r * v2.r: v1.r,
      v1.g < 0.0 ? v1.g * v2.g: v1.g,
      v1.b < 0.0 ? v1.b * v2.b: v1.b,
      v1.a < 0.0 ? v1.a * v2.a: v1.a
      );
  }
  `,name:a,type:0}}function Df(a){let e=`${a}_`;return{body:`
  float ${e}(float a, float b) {
    return ${a}(a, b);
  }
  vec4 ${e}(vec4 v1, vec4 v2) {
    return ${a}(v1, v2);
  }
  `,name:e,type:0}}var yt,Lf,ca,pa,da,ha,ma,ba,ya,ga,xa,Ta,va,wa,Ia=x(()=>{"use strict";z();Bt();q();N();yt=(a,e,o,t=e[0].type,n)=>{let r=a.session.pack?2:0;return{name:o.name,inputNames:["A","B"],inputTypes:[r,r],cacheHint:n,get:()=>Lf(a,e,o,t)}},Lf=(a,e,o,t=e[0].type)=>{let n=a.session.pack?2:0,r=!O.areEqual(e[0].dims,e[1].dims),s=e[0].dims,i=a.session.pack;if(r){let f=it.calcShape(e[0].dims,e[1].dims,!1);if(!f)throw new Error("Can't perform binary op on the given tensors");s=f;let p=s.length,d=e[0].dims.length!==0?e[0].dims.length:1,b=e[1].dims.length!==0?e[1].dims.length:1,g=e[0].dims.length!==0?"bcastIndices_A(indices, aindices);":"aindices[0] = 0;",y=e[1].dims.length!==0?"bcastIndices_B(indices, bindices);":"bindices[0] = 0;",v=D(a.session.backend.glContext.version),_=i?`
      ${o.body}
      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();
        vec4 result = ${o.name}(a, b);
        ${v.output} = result;
      }`:`
      ${o.body}
      float process(int indices[${p}]) {
        int aindices[${d}];
        int bindices[${b}];
        ${g}
        ${y}
        return ${o.name}(_A(aindices), _B(bindices));
      }`;return{name:o.name,inputNames:["A","B"],inputTypes:[n,n],output:{dims:s,type:t,textureType:n},shaderSource:_,hasMain:i}}let u=D(a.session.backend.glContext.version),l=`
    ${o.body}
    void main() {
      vec4 v1 = ${u.texture2D}(A, TexCoords);
      vec4 v2 = ${u.texture2D}(B, TexCoords);
      vec4 result = ${o.name}(v1, v2);
      ${u.output} = result;
    }
    `;return{name:o.name,inputNames:["A","B"],inputTypes:[n,n],output:{dims:e[0].dims,type:t,textureType:n},shaderSource:l,hasMain:!0}},ca=(a,e)=>[a.run(yt(a,e,gf()),e)],pa=(a,e)=>[a.run(yt(a,e,Sf(),"bool"),e)],da=(a,e)=>[a.run(yt(a,e,xf()),e)],ha=(a,e)=>[a.run(yt(a,e,wf(),"bool"),e)],ma=(a,e)=>[a.run(yt(a,e,If(),"bool"),e)],ba=(a,e)=>[a.run(yt(a,e,_f(),"bool"),e)],ya=(a,e)=>[a.run(yt(a,e,Tf()),e)],ga=(a,e)=>[a.run(yt(a,e,Af(),"bool"),e)],xa=(a,e)=>[a.run(yt(a,e,Pf()),e)],Ta=(a,e)=>[a.run(yt(a,e,Ef()),e)],va=(a,e)=>[a.run(yt(a,e,vf()),e)],wa=(a,e)=>[a.run(yt(a,e,Of(),"bool"),e)]});var _a,Sa,kf,Aa=x(()=>{"use strict";z();_a=(a,e,o)=>(kf(e),[a.cast(e[0],o)]),Sa=a=>et.tensorDataTypeFromProto(a.attributes.getInt("to")),kf=a=>{if(!a||a.length!==1)throw new Error("Cast requires 1 input.");if(a[0].type==="string")throw new Error("Invalid input type.")}});var Bf,Ff,Oa,ur,Pa=x(()=>{"use strict";q();N();Pt();Qt();Bf=(a,e)=>({name:"Concat (packed)",inputNames:Array.from({length:a},(o,t)=>`X${t}`),inputTypes:Array(a).fill(2),cacheHint:e}),Ff=(a,e,o,t)=>{let n=o[0].dims.slice();if(t>=n.length||t<-1*n.length)throw new Error("axis specified for concat doesn't match input dimensionality");t<0&&(t=n.length+t);let r=n.slice(0);for(let F=1;F<o.length;F++){let st=o[F].dims.slice();for(let At=0;At<n.length;At++)if(At===t)r[t]+=st[At];else if(n[At]!==st[At])throw new Error("non concat dimensions must match")}let s=r.length,i=ce("coords",s),u=at(s),l=Et(),f=o.map(F=>F.dims),p=St(s),d=new Array(f.length-1);d[0]=f[0][t];for(let F=1;F<d.length;F++)d[F]=d[F-1]+f[F][t];let b=p[t],g=p.slice(-2),y=p.join(),v=`if (${b} < ${d[0]}) {
        return getChannel(
            getX0(${y}), vec2(${g.join()}));
        }`;for(let F=1;F<d.length;F++){let st=d[F-1];v+=`
            if (${b} < ${d[F]}  && ${b} >= ${d[F-1]}) {
              return getChannel(
                getX${F}(${ur(p,b,st)}),
                vec2(${ur(g,b,st)}));
            }`}let _=d.length,A=d[d.length-1];v+=`
            return getChannel(
              getX${_}(${ur(p,b,A)}),
              vec2(${ur(g,b,A)}));`;let S=D(a.session.backend.glContext.version),C=`
          ${l}
          float getValue(${p.map(F=>"int "+F)}) {
            ${v}
          }

          void main() {
            ${u} coords = getOutputCoords();
            int lastDim = coords.${p[s-1]};
            coords.${p[s-1]} = coords.${p[s-2]};
            coords.${p[s-2]} = lastDim;

            vec4 result = vec4(getValue(${i}), 0., 0., 0.);

            ${i[s-1]} = ${i[s-1]} + 1;
            if (${i[s-1]} < ${r[s-1]}) {
              result.g = getValue(${i});
            }

            ${i[s-2]} = ${i[s-2]} + 1;
            if (${i[s-2]} < ${r[s-2]}) {
              result.a = getValue(${i});
            }

            ${i[s-1]} = ${i[s-1]} - 1;
            if (${i[s-2]} < ${r[s-2]} &&
                ${i[s-1]} < ${r[s-1]}) {
              result.b = getValue(${i});
            }
            ${S.output} = result;
          }
        `;return{...e,output:{dims:r,type:o[0].type,textureType:2},shaderSource:C,hasMain:!0}},Oa=(a,e,o)=>{let t=Bf(e.length,o.cacheKey);return{...t,get:()=>Ff(a,t,e,o.axis)}},ur=(a,e,o)=>{let t=a.indexOf(e);return a.map((r,s)=>s===t?`${r} - ${o}`:r).join()}});var Ea,Nf,Cf,Gf,Da,Rf,Vf,zf,La,Mf,$a=x(()=>{"use strict";tt();N();Pa();Ea=(a,e,o)=>(Mf(e),a.session.pack&&e[0].dims.length>1?[a.run(Oa(a,e,o),e)]:[a.run(Gf(a,e,o),e)]),Nf=(a,e)=>({name:"Concat",inputNames:Array.from({length:a},(o,t)=>`X${t}`),inputTypes:Array(a).fill(0),cacheHint:e}),Cf=(a,e,o,t)=>{let n=o[0].dims.slice();if(t>=n.length||t<-1*n.length)throw new Error("axis specified for concat doesn't match input dimensionality");t<0&&(t=n.length+t);let r=n.slice(0);for(let b=1;b<o.length;b++){let g=o[b].dims.slice();for(let y=0;y<n.length;y++)if(y===t)r[t]+=g[y];else if(n[y]!==g[y])throw new Error("non concat dimensions must match")}let s=r.length,i=new Array(o.length),u=0;for(let b=0;b<i.length;++b)u+=o[b].dims[t],i[b]=u;let l="";o.length<5?l=Da(i):l=Rf(i);let f=Vf(o.length,s),p=zf(i),d=`
        ${f}
        ${p}
        ${l}
        float process(int indices[${s}]) {
          int textureIndex = getTextureWhereDataResides (indices[${t}]);

          if(textureIndex != 0) {
            indices[${t}] = indices[${t}] - int(getSizeInConcatAxisValueFromIndex(textureIndex-int(1)));
          }

          return fetchDataFromCorrectTexture(textureIndex, indices);
        }`;return{...e,output:{dims:r,type:o[0].type,textureType:0},shaderSource:d}},Gf=(a,e,o)=>{let t=Nf(e.length,o.cacheKey);return{...t,get:()=>Cf(a,t,e,o.axis)}},Da=a=>`int getTextureWhereDataResides(int index) {
      ${a.map((o,t)=>`if(index<${o}) {return ${t};}
`).join("")}
    }`,Rf=a=>Da(a),Vf=(a,e)=>{let o=[`float fetchDataFromCorrectTexture(int textureIndex, int indices[${e}]) {`];for(let t=0;t<a;++t)t===0?o.push(`	if (textureIndex == ${t}) { return _X${t}(indices); }`):t===a-1?o.push(`	else { return _X${t}(indices); }`):o.push(`	else if (textureIndex == ${t}) { return _X${t}(indices); }`);return o.push("	}"),o.join(`
`)},zf=a=>{let e=["int getSizeInConcatAxisValueFromIndex(int index) {"];for(let o=0;o<a.length;++o)o===0?e.push(`	if (index == ${o}) { return ${a[o]}; }`):o===a.length-1?e.push(`	else { return ${a[o]}; }`):e.push(`	else if (index == ${o}) { return ${a[o]}; }`);return e.push("	}"),e.join(`
`)},La=a=>$({axis:a.attributes.getInt("axis")}),Mf=a=>{if(!a||a.length<1)throw new Error("too few inputs");let e=a[0].type,o=a[0].dims.length;if(e==="string")throw new Error("string tensor is not supported yet");for(let t of a){if(t.type!==e)throw new Error("input tensors should be one type");if(t.dims.length!==o)throw new Error("input tensors should have the same shape")}}});function Uf(){return gt("abs")}function Wf(){return gt("acos")}function Hf(){return gt("asin")}function qf(){return gt("atan")}function jf(){return gt("ceil")}function Kf(){return gt("cos")}function Xf(a){let e="elu";return{body:`
  const float alpha = float(${a});

  float ${e}_(float a) {
    return a >= 0.0 ? a: (exp(a) - 1.0) * alpha;
  }
  vec4 ${e}_(vec4 v) {
    return vec4(${e}_(v.x), ${e}_(v.y), ${e}_(v.z), ${e}_(v.w));
  }
  `,name:e,type:0}}function Jf(){return gt("exp")}function Zf(){return gt("floor")}function hn(a,e){let o="clip";return{body:`
  const float min = float(${a});
  const float max = float(${e});

  float ${o}_(float a) {
    return clamp(a, min, max);
  }
  vec4 ${o}_(vec4 v) {
    return clamp(v, min, max);
  }
  `,name:o,type:0}}function Yf(){let a="indentity";return{body:`
  float ${a}_(float a) {
    return a;
  }
  vec4 ${a}_(vec4 v) {
    return v;
  }
  `,name:a,type:0}}function Qf(a){let e="leakyRelu";return{body:`
  const float alpha = float(${a});

  float ${e}_(float a) {
    return a < 0.0 ? a * alpha : a;
  }
  vec4 ${e}_(vec4 v) {
    return vec4(${e}_(v.x), ${e}_(v.y), ${e}_(v.z), ${e}_(v.w));
  }
  `,name:e,type:0}}function tc(){return gt("log")}function ec(){let a="neg";return{body:`
  float ${a}_(float a) {
    return -a;
  }
  vec4 ${a}_(vec4 v) {
    return -v;
  }
  `,name:a,type:0}}function rc(){let a="not";return{body:`
  float ${a}_(float a) {
    return float( ! bool(a) );
  }
  bool ${a}_(bool a) {
    return !a;
  }
  vec4 ${a}_(vec4 v) {
    return vec4(!bool(v.x), !bool(v.y), !bool(v.z), !bool(v.w));
  }
  bvec4 ${a}_(bvec4 v) {
    return bvec4(!v.x, !v.y, !v.z, !v.w);
  }
  `,name:a,type:0}}function nc(){return gt("sin")}function mn(){let a="relu";return{body:`
  float ${a}_(float a) {
    return max( a, 0.0 );
  }
  vec4 ${a}_(vec4 v) {
    return max( v, 0.0 );
  }
  `,name:a,type:0}}function bn(){let a="sigmoid";return{body:`
  float ${a}_(float a) {
    return 1.0 / (1.0 + exp(-a));
  }
  vec4 ${a}_(vec4 v) {
    return 1.0 / (1.0 + exp(-v));
  }
  `,name:a,type:0}}function oc(){return gt("sqrt")}function ic(){return gt("tan")}function ac(){let a="tanh";return{body:`
  float ${a}_(float a) {
    a = clamp(a, -10., 10.);
    a = exp(2.*a);
    return (a - 1.) / (a + 1.);
  }
  vec4 ${a}_(vec4 v) {
    v = clamp(v, -10., 10.);
    v = exp(2.*v);
    return (v - 1.) / (v + 1.);
  }
  `,name:a,type:0}}function gt(a){return{body:`
  float ${a}_(float a) {
    return ${a}(a);
  }
  vec4 ${a}_(vec4 v) {
    return ${a}(v);
  }
  `,name:a,type:0}}var sc,J,ka,Ba,Fa,Na,yn,Ca,Ga,uc,Ra,Va,za,Ma,Ua,Wa,gn,Ha,qa,ja,Ka,Xa,Ja,Za,Ya,Qa,ts,es,xn=x(()=>{"use strict";tt();z();Bt();q();N();sc=(a,e,o,t)=>{let n=a.session.pack?2:0,r=D(a.session.backend.glContext.version);return{...e,output:{dims:o.dims,type:o.type,textureType:n},shaderSource:`
     ${t.body}
     void main() {
       vec4 v = ${r.texture2D}(A, TexCoords);
       v = ${t.name}_(v);
       ${r.output} = v;
     }
     `,hasMain:!0}},J=(a,e,o,t)=>{let n=a.session.pack?2:0,r={name:o.name,inputTypes:[n],inputNames:["A"],cacheHint:t};return{...r,get:()=>sc(a,r,e,o)}},ka=(a,e)=>[a.run(J(a,e[0],Uf()),e)],Ba=(a,e)=>[a.run(J(a,e[0],Wf()),e)],Fa=(a,e)=>[a.run(J(a,e[0],Hf()),e)],Na=(a,e)=>[a.run(J(a,e[0],qf()),e)],yn=(a,e,o)=>[a.run(J(a,e[0],hn(o.min,o.max),o.cacheKey),e)],Ca=a=>$({min:a.attributes.getFloat("min",Jt),max:a.attributes.getFloat("max",Zt)}),Ga=(a,e)=>{let o=uc(a,e);return yn(a,[e[0]],o)},uc=(a,e)=>{if(e.length>=3&&(!a.session.isInitializer(e[1].dataId)||!a.session.isInitializer(e[2].dataId)))throw new Error("dynamic clip attributes are not allowed");let o=e.length>=3?e[1].numberData[0]:Jt,t=e.length>=3?e[2].numberData[0]:Zt;return $({min:o,max:t})},Ra=(a,e)=>[a.run(J(a,e[0],jf()),e)],Va=(a,e)=>[a.run(J(a,e[0],Kf()),e)],za=(a,e,o)=>[a.run(J(a,e[0],Xf(o.alpha),o.cacheKey),e)],Ma=a=>$({alpha:a.attributes.getFloat("alpha",1)}),Ua=(a,e)=>[a.run(J(a,e[0],Jf()),e)],Wa=(a,e)=>[a.run(J(a,e[0],Zf()),e)],gn=(a,e)=>[a.run(J(a,e[0],Yf()),e)],Ha=(a,e,o)=>[a.run(J(a,e[0],Qf(o.alpha),o.cacheKey),e)],qa=a=>$({alpha:a.attributes.getFloat("alpha",.01)}),ja=(a,e)=>[a.run(J(a,e[0],tc()),e)],Ka=(a,e)=>[a.run(J(a,e[0],ec()),e)],Xa=(a,e)=>[a.run(J(a,e[0],rc()),e)],Ja=(a,e)=>[a.run(J(a,e[0],mn()),e)],Za=(a,e)=>[a.run(J(a,e[0],bn()),e)],Ya=(a,e)=>[a.run(J(a,e[0],nc()),e)],Qa=(a,e)=>[a.run(J(a,e[0],oc()),e)],ts=(a,e)=>[a.run(J(a,e[0],ic()),e)],es=(a,e)=>[a.run(J(a,e[0],ac()),e)]});function Dt(a){let e;switch(a.activation){case"Relu":e=mn();break;case"Sigmoid":e=bn();break;case"Clip":e=hn(a.clipMin,a.clipMax);break;default:return{activationFunction:"",applyActivation:""}}let o=e.name,t=e.body,n=`value = ${o}_(value);`;return{activationFunction:t,applyActivation:n}}var pe,te=x(()=>{"use strict";z();xn();pe=a=>{let e=a.getString("activation","");if(e==="Clip"){let[o,t]=a.getFloats("activation_params",[Jt,Zt]);return{activation:e,clipMax:t,clipMin:o,activationCacheKey:`${e}:${o},${t}`}}return{activation:e,activationCacheKey:e}}});var fc,cc,rs,ns=x(()=>{"use strict";pt();q();N();lr();te();fc=(a,e)=>({name:"GroupedConv",inputNames:a?["X","W","Bias"]:["X","W"],inputTypes:a?[0,0,0]:[0,0],cacheHint:e}),cc=(a,e,o,t)=>{let r=e.length>2?"value += getBias(output_channel);":"",s=e[0].dims.slice(),i=e[1].dims.slice(),u=i[0]/t.group;M.verbose("GroupedConv",`autpPad:${t.autoPad}, dilations:${t.dilations}, group:${t.group}, kernelShape:${t.kernelShape}, pads:${t.pads}, strides:${t.strides}`);let l=de(s,i,t.dilations,t.pads,t.strides),f=D(a.session.backend.glContext.version),{activationFunction:p,applyActivation:d}=Dt(t),b=`
  const ivec2 strides = ivec2(${t.strides[0]}, ${t.strides[1]});
  const ivec2 pads = ivec2(${t.pads[0]}, ${t.pads[1]});
  ${p}
  void main() {
    ivec4 coords = getOutputCoords();
    int batch = coords.x;
    int output_channel = coords.y;
    ivec2 xRCCorner = coords.zw * strides - pads;
    int group_id = output_channel / ${u};

    float value = 0.0;
    for (int wInChannel = 0; wInChannel < ${i[1]}; wInChannel++) {
      int input_channel = group_id * ${i[1]} + wInChannel;
      for (int wHeight = 0; wHeight < ${i[2]}; wHeight++) {
        int xHeight = xRCCorner.x + wHeight * ${t.dilations[0]};

        if (xHeight < 0 || xHeight >= ${s[2]}) {
          continue;
        }

        for (int wWidth = 0; wWidth < ${i[3]}; wWidth++) {
          int xWidth = xRCCorner.y + wWidth * ${t.dilations[1]};
          if (xWidth < 0 || xWidth >= ${s[3]}) {
            continue;
          }

          float xVal = getX(batch, input_channel, xWidth, xHeight);
          float wVal = getW(output_channel, wInChannel, wWidth, wHeight);
          value += xVal*wVal;
        }
      }
    }
    ${r}
    ${d}
    ${f.output} = vec4(value, .0, .0, .0);
  }
`;return{...o,output:{dims:l,type:e[0].type,textureType:0},shaderSource:b,hasMain:!0}},rs=(a,e,o)=>{let t=fc(e.length>2,o.cacheKey);return{...t,get:()=>cc(a,e,t,o)}}});var pc,dc,os,is=x(()=>{"use strict";q();N();Qt();pc=a=>({name:"Im2Col (packed)",inputNames:["A"],inputTypes:[2],cacheHint:a}),dc=(a,e,o,t,n,r)=>{let s=o.dims,i=t.dims,u=2,l=3,f=n.length,p=[i[1]*i[2]*i[3],n[2]*n[3]],d=i[2]*i[3],b=Et(),g=D(a.session.backend.glContext.version),y="";for(let _=0;_<=1;_++)for(let A=0;A<=1;A++)y+=`
            blockIndex = rc.x + ${A};
            pos = rc.y + ${_};

            if(blockIndex < ${p[1]} && pos < ${p[0]}) {
              offsetY = int(blockIndex / (${n[f-1]})) * ${r.strides[0]} -
                ${r.pads[0]};
              d0 = offsetY + ${r.dilations[0]} * (imod(pos, ${d}) / ${i[2]});

              if(d0 < ${s[u]} && d0 >= 0) {
                offsetX = imod(blockIndex, ${n[f-1]}) * ${r.strides[1]} -
                  ${r.pads[1]};
                d1 = offsetX + ${r.dilations[1]} * imod(imod(pos, ${d}), ${i[2]});

                if(d1 < ${s[l]} && d1 >= 0) {

                  ch = int(float(pos)/ ${d}.);
                    innerDims = vec2(d0, d1);
                    result[${_*2+A}] = getChannel(
                      getA(0, ch, int(innerDims.x),
                      int(innerDims.y)), innerDims);
                }
              }
            }

          `;let v=`
      ${b}

      void main() {
        ivec2 rc = getOutputCoords();
          vec4 result = vec4(0.0);
          int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
          vec2 innerDims;
          ${y}
          ${g.output} = result;
      }
            `;return{...e,output:{dims:p,type:o.type,textureType:2},shaderSource:v,hasMain:!0}},os=(a,e,o,t,n)=>{let r=pc(n.cacheKey);return{...r,get:()=>dc(a,r,e,o,t,n)}}});function mc(a,e,o){let t=e[0].dims,n=e[1].dims,r=it.calcShape(t,n,!0);if(!r)throw new Error("Can't use matmul on the given tensors");let s=at(r.length),i=St(),{activationFunction:u,applyActivation:l}=Dt(o),f=e.length>2,p=f?"value += getBiasForMatmul();":"",d=f?`${vn(s,i,e[2].dims,r,!1)}`:"",b=r.length,g=t.length,y=n.length,v=t[t.length-1],_=`
    ${u}
    ${d}
    float process(int indices[${b}]) {
        int a[${g}];
        int b[${y}];
        bcastMatmulIndices_A(indices, a);
        bcastMatmulIndices_B(indices, b);

        float value;
        for (int k=0; k<${v}; ++k) {
            a[${g-1}] = k;
            b[${y-2}] = k;
            value += _A(a) * _B(b);
        }
        ${p}
        ${l}
        return value;
    }`;return{...a,output:{dims:r,type:e[0].type,textureType:0},shaderSource:_}}function Tn(a,e){let o=hc(a.length>2,e.activationCacheKey);return{...o,get:()=>mc(o,a,e)}}function vn(a,e,o,t,n){let r="",s=o.length,i=t.length,u=i-s;i<2&&s>0?r="coords":r=o.map((y,v)=>`coords.${e[v+u]}`).join(", ");let f=it.getBroadcastDims(o,t).map(y=>`coords.${e[y+u]} = 0;`).join(`
`),d=O.size(o)===1,b="vec4(outputValue.xx, outputValue.yy)";return d&&(b="vec4(outputValue.x)"),n?`
vec4 getBiasForMatmul() {
  ${a} coords = getOutputCoords();
  ${f}
  vec4 outputValue = getBias(${r});
  return ${b};
}`:`
float getBiasForMatmul() {
  ${a} coords = getOutputCoords();
  ${f}
  return getBias(coords.x);
}`}var as,ss,hc,bc,fr=x(()=>{"use strict";z();N();Pt();te();wn();as=(a,e,o)=>(bc(e),a.session.pack?[a.run(cr(a,e,o),e)]:[a.run(Tn(e,o),e)]),ss=a=>pe(a.attributes),hc=(a,e)=>({name:"MatMul",inputNames:a?["A","B","Bias"]:["A","B"],inputTypes:a?[0,0,0]:[0,0],cacheHint:e});bc=a=>{if(!a||a.length!==2)throw new Error("MatMul requires 2 inputs.");if(a[0].dims[a[0].dims.length-1]!==a[1].dims[a[1].dims.length-2])throw new Error("shared dimension does not match.");if(a[0].type!=="float32"&&a[0].type!=="float64"||a[1].type!=="float32"&&a[1].type!=="float64")throw new Error("inputs should be float type");if(a[0].type!==a[1].type)throw new Error("inputs types should match")}});function xc(a,e,o,t){let n=[],r=[],s=o[0].dims,i=o[1].dims,u=s.length,l=i.length,f=t.length,p=f-u,d=f-l;n=s.map((S,C)=>`coords.${e[C+p]}`),n[u-1]="i*2",n.join(", "),r=i.map((S,C)=>`coords.${e[C+d]}`),r[l-2]="i*2",r.join(", ");let b=it.getBroadcastDims(s,t),g=it.getBroadcastDims(i,t),y=b.map(S=>`coords.${e[S+p]} = 0;`).join(`
`),v=g.map(S=>`coords.${e[S+d]} = 0;`).join(`
`),_=`int lastDim = coords.${e[f-1]};
  coords.${e[f-1]} = coords.${e[f-2]};
  coords.${e[f-2]} = lastDim;`;return`
vec4 getAAtOutCoordsMatmul(int i) {
  ${a} coords = getOutputCoords();
  ${_}
  ${y}
  vec4 outputValue = getA(${n});
  return outputValue;
}

vec4 getBAtOutCoordsMatmul(int i) {
  ${a} coords = getOutputCoords();
  ${_}
  ${v}
  vec4 outputValue = getB(${r});
  return outputValue;
}`}function Tc(a,e){let o="";for(let t=0;t<e-2;t++)o+=`rc.${a[t]}, `;return o+=`rc.${a[e-2]}, i*2`,o}function vc(a,e){let o="";for(let t=0;t<e-2;t++)o+=`rc.${a[t]}, `;return o+=`i*2, rc.${a[e-1]}`,o}var yc,gc,cr,wn=x(()=>{"use strict";z();q();N();Pt();te();fr();yc=(a,e)=>({name:"MatMul (packed)",inputNames:a?["A","B","Bias"]:["A","B"],inputTypes:a?[2,2,2]:[2,2],cacheHint:e}),gc=(a,e,o,t)=>{let n=o.length>2,r=n?"value += getBiasForMatmul();":"",s=o[0].dims,i=o[1].dims,u=it.calcShape(s,i,!0),l=!O.areEqual(o[0].dims,o[1].dims);if(!u)throw new Error("Can't use matmul on the given tensors");let f=s[s.length-1],p=Math.ceil(f/2),d=s.length,b=i.length,g=D(a.session.backend.glContext.version),y=at(u.length),v=u.length,_=St(),{activationFunction:A,applyActivation:S}=Dt(t),C=n?`${vn(y,_,o[2].dims,u,!0)}`:"",F=l?`${xc(y,_,o,u)}`:"",st=l?"getAAtOutCoordsMatmul(i)":`getA(${Tc(_,d)})`,At=l?"getBAtOutCoordsMatmul(i)":`getB(${vc(_,b)})`,kr=l?"":`${y} rc =
          getOutputCoords(); int lastDim = rc.${_[v-1]}; rc.${_[v-1]} =
          rc.${_[v-2]}; rc.${_[v-2]} = lastDim;
      `,Mt=`
            ${F}
            ${C}
            ${A}
            void main() {
              ${kr}

              vec4 value = vec4(0);
              for (int i = 0; i < ${p}; i++) {
                vec4 a = ${st};
                vec4 b = ${At};

                value += (a.rrbb * b.rgrg);
                value += (a.ggaa * b.baba);
              }
              ${r}
              ${S}
              ${g.output} = value;
            }`;return{...e,output:{dims:u,type:o[0].type,textureType:2},shaderSource:Mt,hasMain:!0}},cr=(a,e,o)=>{let t=yc(e.length>2,o.activationCacheKey);return{...t,get:()=>gc(a,t,e,o)}}});var us,ls=x(()=>{"use strict";lr();is();wn();us=(a,e,o)=>{let t=e[0].dims,n=e[1].dims,r=de(t,n,o.dilations,o.pads,o.strides),s=a.run(os(a,e[0],e[1],r,o),[e[0]]),i=a.reshapePacked(e[1],[n[0],n[1]*n[2]*n[3]]),u=e.length===3?[i,s,e[2]]:[i,s],l=a.run(cr(a,u,o),u);return a.reshapePacked(l,r)}});var wc,Ic,fs,In,_n=x(()=>{"use strict";N();wc=a=>({name:"Im2Col",inputNames:["X"],inputTypes:[0],cacheHint:a}),Ic=(a,e,o,t,n,r)=>{let s=o.dims,i=t.dims,u=n.length,l=In(s,i,n,4),f=`
        const int XC = ${s[1]};
        const int XH = ${s[2]};
        const int XW = ${s[3]};
        const int KH = ${r.kernelShape[0]};
        const int KW = ${r.kernelShape[1]};
        const int dilationH = ${r.dilations[0]};
        const int dilationW = ${r.dilations[1]};
        const int strideH = ${r.strides[0]};
        const int strideW = ${r.strides[1]};
        const int padH = ${r.pads[0]};
        const int padW = ${r.pads[1]};
        const int KHKW = KH*KW;
        const int XCKHKW = XC * KHKW;
        const int outputChannels = 4;
        vec4 process(int indices[${u}]) {
          int b  = indices[0]; // batch size
          int oh = indices[1] * strideH - padH; //output height
          int ow = indices[2] * strideW - padW; //output width
          int p = indices[3] * outputChannels; //patch
          vec4 value = vec4(0.0);
          for(int i=0; i < outputChannels; ++i) {
            if(p < XCKHKW) {
              int patchC = p / KHKW;
              int patchH = (p - patchC*KHKW) / KW;
              int patchW = (p - patchC*KHKW) - patchH * KW;
              int xh2 = oh + patchH * dilationH;
              int xw2 = ow + patchW * dilationW;
              int x[${s.length}];
              x[0] = b;
              x[1] = patchC;
              x[2] = xh2;
              x[3] = xw2;
              if(xh2 >= 0 &&
                  xh2 < XH &&
                  xw2 >= 0 &&
                  xw2 < XW) {
                value[i] = _X(x);
              }
            }
            ++p;
          }
          return value;
        }
        `;return{...e,output:{dims:l,type:o.type,textureType:4},shaderSource:f}},fs=(a,e,o,t,n)=>{let r=wc(n.cacheKey);return{...r,get:()=>Ic(a,r,e,o,t,n)}},In=(a,e,o,t=4)=>[o[0],o[2],o[3],Math.ceil(a[1]*e[2]*e[3]/t)]});var _c,Sc,cs,ps=x(()=>{"use strict";z();q();N();te();_n();_c=(a,e)=>({name:"ConvDotProduct",inputNames:a?["Im2Col","K","B"]:["Im2Col","K"],inputTypes:a?[0,4,0]:[0,4],cacheKey:e.activationCacheKey}),Sc=(a,e,o,t,n)=>{let r=o[0].dims,s=o[1].dims,i=[s[0],Math.ceil(r[1]*s[2]*s[3]/4)],u=In(r,s,t),[l,f]=a.calculateTextureWidthAndHeight(i,4),p=O.computeStrides(u),[d,b]=a.calculateTextureWidthAndHeight(u,4),g=t.length,y=o.length<3?"0.0":"_B(b)",v=Math.ceil(r[1]*s[2]*s[3]/4),{activationFunction:_,applyActivation:A}=Dt(n),S=D(a.session.backend.glContext.version),C=`
${_}
float process(int indices[${g}]) {
  int b[1];
  b[0] = indices[1];
  int im2col[4];
  im2col[0] = indices[0];
  im2col[1] = indices[2];
  im2col[2] = indices[3];
  int im2colOffset = im2col[0] * ${p[0]} + im2col[1] * ${p[1]} + im2col[2] * ${p[2]};
  int kernelOffset = indices[1] * ${i[1]};
  float value = ${y};
  for (int i = 0; i < ${v}; ++i) {
    vec2 im2colCoords = offsetToCoords(im2colOffset, ${d}, ${b});
    vec2 kernelCoords = offsetToCoords(kernelOffset, ${l}, ${f});
    value += dot(${S.texture2D}(Im2Col, im2colCoords), ${S.texture2D}(K, kernelCoords));
    ++im2colOffset;
    ++kernelOffset;
  }
  ${A}
  return value;
}`;return{...e,output:{dims:t,type:o[0].type,textureType:0},shaderSource:C}},cs=(a,e,o,t)=>{let n=_c(e.length>2,t);return{...n,get:()=>Sc(a,n,e,o,t)}}});var de,Sn,Ac,Oc,Pc,Ec,An,Dc,lr=x(()=>{"use strict";tt();z();ns();ls();ps();te();_n();fr();de=(a,e,o,t,n)=>{let r=a[0],s=a.slice(2),i=s.length,u=e[0],f=e.slice(2).map((g,y)=>g+(g-1)*(o[y]-1)),d=s.map((g,y)=>g+t[y]+t[y+i]).map((g,y)=>Math.floor((g-f[y]+n[y])/n[y]));return[r,u].concat(...d)},Sn=(a,e,o)=>(Dc(e,o),Ac(a,e,o)),Ac=(a,e,o)=>{let t=Ec(o,e),n=a.session.pack,r=t.kernelShape[0]===1&&t.kernelShape[1]===1;return t.group>1?[a.run(rs(a,e,t),e)]:r&&n?[Oc(a,e,t)]:n&&e[0].dims.length===4&&e[0].dims[0]===1&&!r?[us(a,e,t)]:[Pc(a,e,t)]},Oc=(a,e,o)=>{let t=e[0].dims,n=e[1].dims,r=de(t,n,o.dilations,o.pads,o.strides),s=a.reshapeUnpacked(e[0],[t[1],t[2]*t[3]]),i=a.reshapeUnpacked(e[1],[n[0],n[1]]),u=e.length>2?[i,s,e[2]]:[i,s],l=a.run(Tn(u,o),u);return a.reshapeUnpacked(l,r)},Pc=(a,e,o)=>{let t=e[0].dims,n=e[1].dims,r=de(t,n,o.dilations,o.pads,o.strides),s=a.run(fs(a,e[0],e[1],r,o),[e[0]]),i=e.length===3?[s,e[1],e[2]]:[s,e[1]];return a.run(cs(a,e,r,o),i)},Ec=(a,e)=>{let o=a.kernelShape.slice();if(a.kernelShape.length===0)for(let r=2;r<e[1].dims.length;++r)o.push(e[1].dims[r]);let t=a.pads.slice();Xt.adjustPadsBasedOnAutoPad(e[0].dims,a.strides,a.dilations,o,t,a.autoPad);let n=Object.assign({},a);return Object.assign(n,{kernelShape:o,pads:t,cacheKey:a.cacheKey}),n},An=a=>{let e=a.attributes,o=pe(e),t=e.getString("auto_pad","NOTSET"),n=e.getInts("dilations",[1,1]),r=e.getInt("group",1),s=e.getInts("kernel_shape",[]),i=e.getInts("pads",[0,0,0,0]),u=e.getInts("strides",[1,1]);return $({autoPad:t,dilations:n,group:r,kernelShape:s,pads:i,strides:u,...o})},Dc=(a,e)=>{if(!a||a.length!==2&&a.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(a[0].dims.length!==4||a[1].dims.length!==4)throw new Error("currently only support 2-dimensional conv");let o=a[0].dims[1],t=a[1].dims[1]*e.group;if(o!==t)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(a.length===3&&(a[2].dims.length!==1||a[1].dims[0]!==a[2].dims[0]))throw new Error("invalid bias");let n=a[0].dims.length-2;if(e.dilations.length!==n)throw new Error(`dilations should be ${n}D`);if(e.strides.length!==n)throw new Error(`strides should be ${n}D`);if(e.pads.length!==n*2)throw new Error(`pads should be ${n*2}D`);if(e.kernelShape.length!==0&&e.kernelShape.length!==a[1].dims.length-2)throw new Error("invalid kernel shape");if(a[0].type!=="float32"||a[1].type!=="float32")throw new Error("Conv input(X,W) should be float tensor");if(a.length===3&&a[2].type!=="float32")throw new Error("Conv input(bias) should be float tensor")}});var Lc,$c,kc,ds,Bc,Fc,Nc,Cc,Gc,Rc,hs,Vc,ms=x(()=>{"use strict";tt();q();N();te();Lc=(a,e,o,t,n,r)=>(a-1)*e+o+(t-1)*n+1-r,$c=(a,e,o,t,n)=>{let r=Math.floor(a/2);e==="SAME_UPPER"?(o[t]=r,o[n]=a-r):e==="SAME_LOWER"&&(o[t]=a-r,o[n]=r)},kc=(a,e,o,t,n,r,s,i)=>{let u=a.length-2,l=i.length===0;for(let f=0;f<u;++f){let p=l?a[f+2]*r[f]:i[f],d=Lc(a[f+2],r[f],n[f],e[f],o[f],p);$c(d,t,n,f,f+u),l&&i.push(r[f]*(a[f+2]-1)+s[f]+(e[f]-1)*o[f]+1-n[f]-n[f+u])}},ds=(a,e,o)=>(Vc(e,o),Bc(a,e,o)),Bc=(a,e,o)=>{let t=Rc(o,e);return[Gc(a,e,t)]},Fc=(a,e)=>({name:"ConvTranspose",inputNames:a?["X","W","B"]:["X","W"],inputTypes:a?[0,0,0]:[0,0],cacheHint:e}),Nc=(a,e,o,t)=>{let r=e.length>2?"getB(output_channel)":"0.0",s=e[0].dims,i=e[1].dims,u=i[1],l=i[0]/t.group,f=[e[0].dims[0],e[1].dims[1]*t.group,...t.outputShape],p=D(a.session.backend.glContext.version),{activationFunction:d,applyActivation:b}=Dt(t),g=`
  const ivec2 strides = ivec2(${t.strides[0]}, ${t.strides[1]});
  const ivec2 pads = ivec2(${t.pads[0]}, ${t.pads[1]});
  ${d}
  void main() {
    ivec4 coords = getOutputCoords();
    int batch = coords.x;
    int output_channel = coords.y;

    ivec2 loc = coords.zw + pads;

    int group_id = output_channel / ${u};
    int wOutChannel = output_channel - group_id * ${u};

    float value = ${r};
    for (int inChannelOffset = 0; inChannelOffset < ${l}; inChannelOffset++) {
      int input_channel = group_id * ${l} + inChannelOffset;
      for (int wWOff = 0; wWOff < ${i[2]}; wWOff++) {
        for (int wHOff = 0; wHOff < ${i[3]}; wHOff++) {
          ivec2 wOff = ivec2(wWOff * ${t.dilations[0]}, wHOff * ${t.dilations[1]});
          ivec2 wLoc = loc - wOff;
          ivec2 wLocIn = wLoc / strides;
          if (
            wLocIn * strides == wLoc &&
            wLocIn.x >= 0 && wLocIn.x < ${s[2]} &&
            wLocIn.y >= 0 && wLocIn.y < ${s[3]}
          ) {
            float xVal = getX(batch, input_channel, wLocIn.y, wLocIn.x);
            float wVal = getW(input_channel, wOutChannel, wHOff, wWOff);
            value += xVal * wVal;
          }
        }
      }
    }
    ${b}
    ${p.output} = vec4(value, .0, .0, .0);
  }
`;return{...o,output:{dims:f,type:e[0].type,textureType:0},shaderSource:g,hasMain:!0}},Cc=(a,e,o)=>{let t=Fc(e.length>2,o.cacheKey);return{...t,get:()=>Nc(a,e,t,o)}},Gc=(a,e,o)=>a.run(Cc(a,e,o),e),Rc=(a,e)=>{let o=a.kernelShape.slice();if(a.kernelShape.length===0)for(let i=2;i<e[1].dims.length;++i)o.push(e[1].dims[i]);let t=a.pads.slice(),n=a.outputShape.slice(),r=e[0].dims;kc(r,o,a.dilations,a.autoPad,t,a.strides,a.outputPadding,n);let s=Object.assign({},a);return Object.assign(s,{kernelShape:o,pads:t,outputShape:n,cacheKey:a.cacheKey}),s},hs=a=>{let e=a.attributes,o=pe(e),t=e.getString("auto_pad","NOTSET"),n=e.getInts("dilations",[1,1]),r=e.getInt("group",1),s=e.getInts("kernel_shape",[]),i=e.getInts("output_padding",[0,0]),u=e.getInts("output_shape",[]),l=e.getInts("pads",[0,0,0,0]),f=e.getInts("strides",[1,1]);return $({autoPad:t,dilations:n,group:r,kernelShape:s,outputPadding:i,outputShape:u,pads:l,strides:f,...o})},Vc=(a,e)=>{if(!a||a.length!==2&&a.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(a[0].dims.length!==4||a[1].dims.length!==4)throw new Error("currently only support 2-dimensional conv");let o=a[0].dims[1],t=a[1].dims[0];if(o!==t)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");let n=a[1].dims[1]*e.group;if(a.length===3&&(a[2].dims.length!==1||a[2].dims[0]!==n))throw new Error("invalid bias");let r=a[0].dims.length-2;if(e.dilations.length!==r)throw new Error(`dilations should be ${r}D`);if(e.strides.length!==r)throw new Error(`strides should be ${r}D`);if(e.pads.length!==r*2)throw new Error(`pads should be ${r*2}D`);if(e.outputPadding.length!==r)throw new Error(`output_padding should be ${r}D`);if(e.kernelShape.length!==0&&e.kernelShape.length!==a[1].dims.length-2)throw new Error("invalid kernel shape");if(e.outputShape.length!==0&&e.outputShape.length!==a[0].dims.length-2)throw new Error("invalid output shape");if(a[0].type!=="float32"||a[1].type!=="float32")throw new Error("ConvTranspose input(X,W) should be float tensor");if(a.length===3&&a[2].type!=="float32")throw new Error("ConvTranspose input(bias) should be float tensor")}});var bs,ee,ys,zc,gs,Mc,Uc,Wc,pr=x(()=>{"use strict";tt();z();N();bs={name:"Transpose",inputNames:["A"],inputTypes:[0]},ee=(a,e,o)=>(Wc(e),[a.run({...bs,cacheHint:o.cacheKey,get:()=>zc(a,e[0],o.perm)},e)]),ys=a=>$({perm:a.attributes.getInts("perm",[])}),zc=(a,e,o)=>{let t=e.dims;o=gs(t,o);let n=Mc(t,o),r=t.length,s=`
      ${Uc("perm",o,r)}
      float process(int indices[${r}]) {
        int a[${r}];
        perm(a, indices);
        return _A(a);
      }`;return{...bs,output:{dims:n,type:e.type,textureType:0},shaderSource:s}},gs=(a,e)=>(e&&e.length!==a.length&&(e=[...a.keys()].reverse()),e),Mc=(a,e)=>(e=gs(a,e),O.sortBasedOnPerm(a,e)),Uc=(a,e,o)=>{let t=[];t.push(`void ${a}(out int a[${o}], int src[${o}]) {`);for(let n=0;n<o;++n)t.push(`	a[${e[n]}]=src[${n}];`);return t.push("	}"),t.join(`
`)},Wc=a=>{if(!a||a.length!==1)throw new Error("Transpose requires 1 input.");if(a[0].type!=="float32"&&a[0].type!=="float64")throw new Error("input should be float tensor")}});var xs,Ts,Hc,vs=x(()=>{"use strict";pr();xs=(a,e,o)=>{Hc(e);let t=o.blocksize,n=t*t,r=o.mode==="DCR"?[0,3,4,1,5,2]:[0,1,4,2,5,3],s=o.mode==="DCR"?[e[0].dims[0],t,t,e[0].dims[1]/n,e[0].dims[2],e[0].dims[3]]:[e[0].dims[0],e[0].dims[1]/n,t,t,e[0].dims[2],e[0].dims[3]],i=a.reshapeUnpacked(e[0],s),u={perm:r,cacheKey:`${r}`},[l]=ee(a,[i],u),f=[e[0].dims[0],e[0].dims[1]/n,e[0].dims[2]*t,e[0].dims[3]*t];return[a.reshapeUnpacked(l,f)]},Ts=a=>{let e=a.attributes.getInt("blocksize");if(e<1)throw new Error(`blocksize must be >= 1, but got : ${e} for DepthToSpace`);let o=a.attributes.getString("mode","DCR");if(o!=="DCR"&&o!=="CRD")throw new Error(`unrecognized mode: ${o} for DepthToSpace`);return{mode:o,blocksize:e}},Hc=a=>{if(a.length!==1)throw new Error(`DepthToSpace expect 1 inputs, but got ${a.length}`);if(a[0].type==="string"||a[0].dims.length!==4)throw new TypeError("DepthToSpace input should be a 4-D numeric tensor")}});var ws,Is,qc,_s=x(()=>{"use strict";z();ws=(a,e,o)=>{qc(e,o);let t=O.flattenShape(e[0].dims,o);return[a.reshapeUnpacked(e[0],t)]},Is=a=>a.attributes.getInt("axis",1),qc=(a,e)=>{if(!a||a.length!==1)throw new Error("Flatten requires 1 input.");let o=a[0].dims.length;if(o===0)throw new Error("scalar tensor is not supported.");if(e<-o||e>o)throw new Error("Invalid axis");if(a[0].type==="string")throw new Error("string tensor is not supported.")}});var Vt,Le=x(()=>{"use strict";Vt=["float32","float64","int32","int16","int8","uint16","uint32","uint8"]});var Ss,As,jc,Kc,Xc,Jc,Os=x(()=>{"use strict";tt();Le();z();N();Ss=(a,e,o)=>(Jc(e,o.axis),[a.run(Xc(a,e,o),e)]),As=a=>$({axis:a.attributes.getInt("axis",0)}),jc={name:"Gather",inputNames:["A","B"],inputTypes:[0,0]},Kc=(a,e,o,t)=>{let n=o[0].dims.slice(),r=o[1].dims.slice(),s=new Array(n.length+r.length-1);t=O.normalizeAxis(t,n.length);let i=[];for(let d=0;d<s.length;d++)d<t?(s[d]=n[d],i.push(`inputIdx[${d}] = outputIdx[${d}];`)):d<t+r.length?(s[d]=r[d-t],i.push(`indexDataIdx[${d-t}] = outputIdx[${d}];`)):(s[d]=n[d-r.length+1],i.push(`inputIdx[${d-r.length+1}] = outputIdx[${d}];`));let u=s.length||1,l=n.length,f=r.length||1,p=`
      float process(int outputIdx[${u}]) {
        int inputIdx[${l}];
        int indexDataIdx[${f}];
        indexDataIdx[0] = 0;
        ${i.join(`
        `)}
        int idx = int(_B(indexDataIdx));
        inputIdx[${t}] = idx < 0 ? idx + ${n[t]} : idx;
        return _A(inputIdx);
      }`;return{...e,output:{dims:s,type:o[0].type,textureType:0},shaderSource:p}},Xc=(a,e,o)=>{let t={...jc,cacheHint:o.cacheKey};return{...t,get:()=>Kc(a,t,e,o.axis)}},Jc=(a,e)=>{if(!a||a.length!==2)throw new Error("Gather requires 2 inputs.");let o=a[0].dims.length;if(o<1)throw new Error("Invalid input shape.");if(e<-o||e>o-1)throw new Error("Invalid axis.");if(Vt.indexOf(a[0].type)===-1)throw new Error("Invaid input type.");if(a[1].type!=="int32"&&a[1].type!=="int16")throw new Error("Invaid input type.")}});var On,Ps,Es,Ds,Zc,Yc,Qc,Ls=x(()=>{"use strict";tt();z();N();On=(a,e,o)=>(Qc(e,o),[a.run(Zc(e,o),e)]),Ps=(a,e)=>{let o=a.attributes.getInt("transA",0)!==0,t=a.attributes.getInt("transB",0)!==0,n=a.attributes.getFloat("alpha",1),r=a.attributes.getFloat("beta",1);return $({transA:o,transB:t,alpha:n,beta:r,isOptionalC:e})},Es=a=>Ps(a,!1),Ds=a=>Ps(a,!0),Zc=(a,e)=>{let o={name:"Gemm",inputNames:a.length===3?["A","B","C"]:["A","B"],inputTypes:a.length===3?[0,0,0]:[0,0],key:e.cacheKey};return{...o,get:()=>Yc(o,a,e)}},Yc=(a,e,o)=>{let t=e[0].dims.slice(),n=e[1].dims.slice(),[r,s]=er.getShapeOfGemmResult(t,o.transA,n,o.transB,e.length===3?e[2].dims:void 0),i=[r,s];if(!i)throw new Error("Can't use gemm on the given tensors");let u=t[t.length-1],l="";o.transA&&(u=t[0]),o.transA&&o.transB?l="value += _A_T(a) * _B_T(b);":o.transA&&!o.transB?l="value += _A_T(a) * _B(b);":!o.transA&&o.transB?l="value += _A(a) * _B_T(b);":!o.transA&&!o.transB&&(l="value += _A(a) * _B(b);");let f=i.length,p=e.length===3?`int c[${e[2].dims.length}];`:"",d=e.length===3?"bcastIndices_C(indices, c);":"",b=e.length===3?"value += beta * _C(c);":"",g=`
      float process(int indices[${f}]) {
          int a[${f}];
          int b[${f}];
          ${p}

          copyVec(indices, a);
          copyVec(indices, b);
          ${d}

          float value = 0.0;
          for (int k=0; k<${u}; ++k) {
              a[${f-1}] = k;
              b[${f-2}] = k;
              ${l}
          }

          value = value * alpha;
          ${b}
          return value;
      }`;return{...a,output:{dims:i,type:e[0].type,textureType:0},variables:[{name:"alpha",type:"float",data:o.alpha},{name:"beta",type:"float",data:o.beta}],shaderSource:g}},Qc=(a,e)=>{if(!a)throw new Error("Input is missing");if(e.isOptionalC&&(a.length<2||a.length>3))throw new Error("Invaid input shape.");if(!e.isOptionalC&&a.length!==3)throw new Error("Gemm requires 3 inputs");if(a.length===3&&a[2].dims.length!==1&&a[2].dims.length!==2)throw new Error("Invalid input shape of C");if(a[0].type!=="float32"&&a[0].type!=="float64"||a[1].type!=="float32"&&a[1].type!=="float64"||a.length===3&&a[2].type!=="float32"&&a[2].type!=="float64")throw new Error("Invalid input type.");if(a[0].type!==a[1].type||a.length===3&&a[0].type!==a[2].type)throw new Error("Input types are mismatched")}});var $s,ks,tp,ep,rp,np,op,Bs=x(()=>{"use strict";tt();N();$s=(a,e,o)=>(op(e),[a.run(rp(a,e,o),e)]),ks=a=>{let e=a.attributes.getFloat("scale"),o=a.attributes.getFloats("bias");return $({scale:e,bias:o})},tp={name:"ImageScaler",inputNames:["X"],inputTypes:[0]},ep=(a,e,o,t)=>{let n=o[0].dims.slice(),r=n.length,i=`
      ${np(t.bias.length)}
      float process(int indices[${r}]) {
        return _X(indices) * scale + getBias(bias, indices[1]);
      }`;return{...e,output:{dims:n,type:o[0].type,textureType:0},variables:[{name:"bias",type:"float",arrayLength:t.bias.length,data:t.bias},{name:"scale",type:"float",data:t.scale}],shaderSource:i}},rp=(a,e,o)=>{let t={...tp,cacheHint:o.cacheKey};return{...t,get:()=>ep(a,t,e,o)}},np=a=>{let e=[`float getBias(float bias[${a}], int channel) {`];for(let o=0;o<a;++o)o===0?e.push(`	if (channel == ${o}) { return bias[${o}]; }`):o===a-1?e.push(`	else { return bias[${o}]; }`):e.push(`	else if (channel == ${o}) { return bias[${o}]; }`);return e.push("	}"),e.join(`
`)},op=a=>{if(!a||a.length!==1)throw new Error("ImageScaler requires 1 input.");if(a[0].dims.length!==4)throw new Error("Invalid input shape.");if(a[0].type!=="float32"&&a[0].type!=="float64")throw new Error("Invalid input type.")}});var Ns,Cs,Fs,ip,ap,sp,up,lp,fp,Gs=x(()=>{"use strict";q();N();Ns=(a,e,o)=>{fp(e);let t=a.run(ap(e[0]),e);return[a.run(lp(a,e[0],o,t.dims),[e[0],t,e[1],e[2]])]},Cs=a=>a.attributes.getFloat("epsilon",1e-5),Fs={name:"InstanceNormalization_MeanAndVariance",inputNames:["X"],inputTypes:[0]},ip=(a,e)=>{let o=e.dims.slice(),t=o[1],n=o[2]*o[3],r=[o[0],t],s=`
      vec4 process(int[2] indices) {
        vec4 v = vec4(0.0);
        int a[4];
        a[0] = indices[0];
        a[1] = indices[1];
        float temp = 0.0;
        for(int a2=0; a2<${o[2]}; a2++) {
          a[2] = a2;
          for(int a3=0; a3<${o[3]}; a3++) {
            a[3] = a3;
            float x = _X(a);
            temp += x;
          }
        }
        float mean = temp / float(${n});
        temp = 0.0;
        for(int a2=0; a2<${o[2]}; a2++) {
          a[2] = a2;
          for(int a3=0; a3<${o[3]}; a3++) {
            a[3] = a3;
            float x = _X(a);
            temp += (x - mean) * (x - mean);
          }
        }
        v.r = mean;
        v.g = temp / float(${n});

        return v;
      }`;return{...a,output:{dims:r,type:e.type,textureType:4},shaderSource:s}},ap=a=>({...Fs,get:()=>ip(Fs,a)}),sp={name:"InstanceNormalization_ComputeOutput",inputNames:["X","MeanAndVariance","Scale","B"],inputTypes:[0,4,0,0]},up=(a,e,o,t,n)=>{let r=D(a.session.backend.glContext.version),[s,i]=a.calculateTextureWidthAndHeight(n,4),[u,l]=[s/4,i],f=`
      vec4 get_MeanAndVariance(int[2] mv) {
        int offset = indicesToOffset_MeanAndVariance(mv);
        vec2 coords = offsetToCoords(offset, ${u}, ${l});
        return ${r.texture2D}(MeanAndVariance, coords);
      }

      float process(int[4] indices) {
        int mv[2];
        mv[0] = indices[0];
        mv[1] = indices[1];
        vec4 mean_and_variance = get_MeanAndVariance(mv);
        float mean = mean_and_variance.r;
        float variance = mean_and_variance.g;

        int sb[1];
        sb[0] = indices[1];
        float scale = _Scale(sb);
        float b = _B(sb);

        return scale * (_X(indices) - mean) / sqrt(variance + epsilon) + b;
      }`;return{...e,output:{dims:o.dims,type:o.type,textureType:0},variables:[{name:"epsilon",type:"float",data:t}],shaderSource:f}},lp=(a,e,o,t)=>{let n={...sp,cacheHint:`${o}`};return{...n,get:()=>up(a,n,e,o,t)}},fp=a=>{if(!a||a.length!==3)throw new Error("InstanceNormalization requires 3 inputs.");let e=a[0],o=a[1],t=a[2];if(e.dims.length<3||o.dims.length!==1||t.dims.length!==1)throw new Error("Invalid input shape.");if(o.dims[0]!==e.dims[1]||t.dims[0]!==e.dims[1])throw new Error("Input shapes are mismatched.");if(e.type!=="float32"&&e.type!=="float64"||o.type!=="float32"&&o.type!=="float64"||t.type!=="float32"&&t.type!=="float64")throw new Error("Invalid input type.");if(a[0].dims.length!==4)throw new Error("Only support 4-D input shape.")}});function cp(a,e){let o=a[0].dims[1],t=a[0].dims.length,n=-Math.floor((e.size-1)/2),r=Math.ceil((e.size-1)/2),s=`float(${e.alpha}) / float(${e.size})`,i=`float(${e.bias})`,u=`float(${e.beta})`,l=`
    float process(int indices[${t}]) {
        int c = indices[1];
        float x = _X(indices);
        float square_sum = 0.0;

        for (int i = ${n}; i <= ${r}; i++) {
          int idx = c + i;
          if (c >= 0 && c < ${o}) {
            indices[1] = idx;
            float j = _X(indices);
            square_sum += j * j;
          }
        }
        return x / pow(${i} + ${s} * square_sum, ${u});
    }`;return{...zs,cacheHint:e.cacheKey,output:{dims:a[0].dims,type:a[0].type,textureType:0},shaderSource:l}}function pp(a,e){return{...zs,cacheHint:e.cacheKey,get:()=>cp(a,e)}}var Rs,Vs,zs,dp,Ms=x(()=>{"use strict";tt();N();Rs=(a,e,o)=>(dp(e),[a.run(pp(e,o),e)]),Vs=a=>{let e=a.attributes.getFloat("alpha",1e-4),o=a.attributes.getFloat("beta",.75),t=a.attributes.getFloat("bias",1),n=a.attributes.getInt("size");return $({alpha:e,beta:o,bias:t,size:n})},zs={name:"LRN",inputNames:["X"],inputTypes:[0]};dp=a=>{if(!a||a.length!==1)throw new Error("LRN requires 1 input.");if(a[0].dims.length!==4)throw new Error('currently only support LRN for input with "NCHW" format');if(a[0].type!=="float32")throw new Error("input should be float type")}});var hp,Pn,Us,Ws,Hs,mp,bp,yp,gp,xp,Tp,vp,wp,qs=x(()=>{"use strict";tt();z();q();N();hp={name:"Pad",inputNames:["A"],inputTypes:[0]},Pn=(a,e,o)=>(yp(e),[a.run({...hp,cacheHint:o.cacheKey,get:()=>bp(a,e[0],o)},e)]),Us=a=>{let e=a.attributes.getString("mode","constant"),o=a.attributes.getFloat("value",0),t=a.attributes.getInts("pads");return $({mode:e,value:o,pads:t})},Ws=(a,e,o)=>{gp(e);let t=mp(a,e,o);return Pn(a,[e[0]],t)},Hs=a=>a.attributes.getString("mode","constant"),mp=(a,e,o)=>{if(!a.session.isInitializer(e[1].dataId)||e.length>=3&&!a.session.isInitializer(e[2].dataId))throw new Error("dynamic pad attributes are not allowed");let t=Array.from(e[1].integerData),n=e.length>=3?e[2].floatData[0]:0;return $({mode:o,pads:t,value:n})},bp=(a,e,o)=>{let t=O.padShape(e.dims.slice(),o.pads),n=t.length,s=`
      ${xp(a,e,o)}
      float process(int[${n}] indices) {
          return padA(indices);
      }`;return{name:"Pad",inputNames:["A"],inputTypes:[0],output:{dims:t,type:e.type,textureType:0},shaderSource:s}},yp=a=>{if(!a||a.length!==1)throw new Error("Pad requires 1 input");if(a[0].type!=="float32"&&a[0].type!=="float64")throw new Error("Invalid input type.")},gp=a=>{if(!a||a.length!==2&&a.length!==3)throw new Error("Pad requires 2 or 3 inputs");if(a[1].type!=="int32")throw new Error("Invalid input type.");if(a.length>=3&&a[2].type==="string")throw new Error("Invalid input type.")},xp=(a,e,o)=>{let t=D(a.session.backend.glContext.version),[n,r]=a.calculateTextureWidthAndHeight(e.dims,0),s=O.computeStrides(e.dims);switch(o.mode){case"constant":return Tp(t,e.dims,s,n,r,o.pads,o.value);case"reflect":return vp(t,e.dims,s,n,r,o.pads);case"edge":return wp(t,e.dims,s,n,r,o.pads);default:throw new Error("Invalid mode")}},Tp=(a,e,o,t,n,r,s)=>{let i=e.length,u="";for(let l=i-1;l>=0;--l)u+=`
        k = m[${l}] - ${r[l]};
        if (k < 0)  return constant;
        if (k >= ${e[l]}) return constant;
        offset += k * ${o[l]};
        `;return`
      float padA(int m[${i}]) {
        const float constant = float(${s});
        int offset = 0;
        int k = 0;
        ${u}
        vec2 coords = offsetToCoords(offset, ${t}, ${n});
        float value = getColorAsFloat(${a.texture2D}(A, coords));
        return value;
      }
      `},vp=(a,e,o,t,n,r)=>{let s=e.length,i="";for(let u=s-1;u>=0;--u)i+=`
        k = m[${u}] - ${r[u]};
        if (k < 0) { k = -k; }
        {
          const int _2n_1 = ${2*(e[u]-1)};
          k = int( mod( float(k), float(_2n_1) ) ) ;
          if(k >= ${e[u]}) { k = _2n_1 - k; }
        }
        offset += k * ${o[u]};
        `;return`
      float padA(int m[${s}]) {
        int offset = 0;
        int k = 0;
        ${i}
        vec2 coords = offsetToCoords(offset, ${t}, ${n});
        float value = getColorAsFloat(${a.texture2D}(A, coords));
        return value;
      }
      `},wp=(a,e,o,t,n,r)=>{let s=e.length,i="";for(let u=s-1;u>=0;--u)i+=`
        k = m[${u}] - ${r[u]};
        if (k < 0)  k = 0;
        if (k >= ${e[u]}) k = ${e[u]-1};
        offset += k * ${o[u]};
      `;return`
      float padA(int m[${s}]) {
        int offset = 0;
        int k = 0;
        ${i}
        vec2 coords = offsetToCoords(offset, ${t}, ${n});
        float value = getColorAsFloat(${a.texture2D}(A, coords));
        return value;
      }
      `}});var Ks,Xs,Js,Zs,Ys,Qs,tu,eu,ru,Ip,js,nu,hr,ou,dr,_p,iu=x(()=>{"use strict";tt();z();N();Ks=(a,e,o)=>{hr(e);let t={name:"AveragePool",inputNames:["X"],inputTypes:[0],cacheHint:o.cacheKey};return[a.run({...t,get:()=>Js(e,t,!1,o)},e)]},Xs=a=>{let e=a.attributes.getString("auto_pad","NOTSET"),o=a.attributes.getInt("ceil_mode",0),t=a.attributes.getInt("count_include_pad",0)!==0,n=a.attributes.getInts("kernel_shape"),r=a.attributes.getInts("strides",[]),s=a.attributes.getInts("pads",[]);if(o!==0)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");return $({autoPad:e,ceilMode:o,countIncludePad:t,kernelShape:n,strides:r,pads:s})},Js=(a,e,o,t)=>{let[n,r]=ru(a,t,o),s=O.size(n.kernelShape),i="value += _X(x);",u="";n.countIncludePad?u+=`value /= float(${s});`:u+=`value /= float(${s} - pad);`;let f=`
        ${ou(a[0].dims,n,i,u,"0.0")}
      `;return{...e,output:{dims:r,type:a[0].type,textureType:0},shaderSource:f}},Zs=(a,e,o)=>{hr(e);let t={name:"GlobalAveragePool",inputNames:["X"],inputTypes:[0],cacheHint:`${o.countIncludePad}`};return[a.run({...t,get:()=>Js(e,t,!0,o)},e)]},Ys=a=>{let e=a.attributes.getInt("count_include_pad",0)!==0;return $({autoPad:"",ceilMode:0,countIncludePad:e,kernelShape:[],strides:[],pads:[]})},Qs=(a,e,o)=>{hr(e);let t={name:"MaxPool",inputNames:["X"],inputTypes:[0],cacheHint:o.cacheKey};return[a.run({...t,get:()=>eu(e,t,!1,o)},e)]},tu=a=>{let e=a.attributes.getString("auto_pad","NOTSET"),o=a.attributes.getInt("ceil_mode",0),t=a.attributes.getInts("kernel_shape"),n=a.attributes.getInts("strides",[]),r=a.attributes.getInts("pads",[]),s=a.attributes.getInt("storage_order",0),i=a.attributes.getInts("dilations",[]);if(s!==0)throw new Error("column major storage order is not yet supported for MaxPool");if(o!==0)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");return $({autoPad:e,ceilMode:o,countIncludePad:!1,kernelShape:t,strides:n,pads:r,storageOrder:s,dilations:i})},eu=(a,e,o,t)=>{let[n,r]=ru(a,t,o),s=`
      value = max(_X(x), value);
    `,i="",l=`
      ${ou(a[0].dims,n,s,i,"-1e5")}
    `;return{...e,output:{dims:r,type:a[0].type,textureType:0},shaderSource:l}},ru=(a,e,o)=>{let t=a[0].dims.slice(),n=Object.hasOwnProperty.call(e,"dilations"),r=e.kernelShape.slice(),s=e.strides.slice(),i=n?e.dilations.slice():[],u=e.pads.slice();Xt.adjustPoolAttributes(o,t,r,s,i,u);let l=Xt.computePoolOutputShape(o,t,s,i,r,u,e.autoPad),f=Object.assign({},e);return n?Object.assign(f,{kernelShape:r,strides:s,pads:u,dilations:i,cacheKey:e.cacheKey}):Object.assign(f,{kernelShape:r,strides:s,pads:u,cacheKey:e.cacheKey}),[f,l]},Ip={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[],cacheKey:""},js={name:"GlobalMaxPool",inputNames:["X"],inputTypes:[0]},nu=(a,e)=>(hr(e),[a.run({...js,get:()=>eu(e,js,!0,Ip)},e)]),hr=a=>{if(!a||a.length!==1)throw new Error("Pool ops requires 1 input.");if(a[0].type!=="float32"&&a[0].type!=="float64")throw new Error("Invalid input type.")},ou=(a,e,o,t,n)=>{let r=a.length;if(e.kernelShape.length<=2){let s=e.kernelShape[e.kernelShape.length-1],i=e.strides[e.strides.length-1],u=e.pads[e.pads.length/2-1],l=e.pads[e.pads.length-1],f=a[r-1],p="",d="",b="";if(u+l!==0?p=`
          for (int i = 0; i < ${s}; i++) {
            x[${r} - 1] = indices[${r} - 1] * ${i} - ${u} + i;
            if (x[${r} - 1] < 0 || x[${r} - 1] >= ${f}) {
              pad++;
              continue;
            }
            ${o}
          }`:p=`
          for (int i = 0; i < ${s}; i++) {
            x[${r} - 1] = indices[${r} - 1] * ${i} - ${u} + i;
            ${o}
          }`,e.kernelShape.length===2){let y=e.kernelShape[e.kernelShape.length-2],v=e.strides[e.strides.length-2],_=e.pads[e.pads.length/2-2],A=e.pads[e.pads.length-2],S=a[r-2];_+A!==0?d=`
            for (int j = 0; j < ${y}; j++) {
              x[${r} - 2] = indices[${r} - 2] * ${v} - ${_} + j;
              if (x[${r} - 2] < 0 || x[${r} - 2] >= ${S}) {
                pad+= ${s};
                continue;
              }
          `:d=`
            for (int j = 0; j < ${y}; j++) {
              x[${r} - 2] = indices[${r} - 2] * ${v} - ${_} + j;
            `,b=`
          }
        `}return`
        float process(int indices[${r}]) {
          int x[${r}];
          copyVec(indices, x);

          float value = ${n};
          int pad = 0;
          ${d}
          ${p}
          ${b}
          ${t}
          return value;
        }
      `}else{let s=O.size(e.kernelShape),i=O.computeStrides(e.kernelShape),u=i.length,l=e.pads.length,f=_p(u),p=dr(a,"inputDims"),d=dr(e.pads,"pads"),b=dr(i,"kernelStrides"),g=dr(e.strides,"strides"),y=e.pads.reduce((A,S)=>A+S),v="";return y?v=`
            if (x[j] >= inputDims[j] || x[j] < 0) {
              pad++;
              isPad = true;
              break;
            }
          }
          if (!isPad) {
            ${o}
          }`:v=`
          }
          ${o}
        `,`
        ${f}
        float process(int indices[${r}]) {
          int x[${r}];
          copyVec(indices, x);
          int offset[${u}];
          int pads[${l}];
          int inputDims[${r}];
          int kernelStrides[${u}];
          int strides[${u}];
          ${d}
          ${p}
          ${g}
          ${b}

          float value = ${n};
          int pad = 0;
          bool isPad = false;
          for (int i = 0; i < ${s}; i++) {
            offsetToIndices(i, kernelStrides, offset);
            isPad = false;
            for (int j = ${r} - ${u}; j < ${r}; j++) {
              x[j] = indices[j] * strides[j - ${r} + ${u}]
                + offset[j - ${r} + ${u}] - pads[j - 2];
              ${v}
          }
          ${t}

          return value;
        }
      `}},dr=(a,e)=>{let o="";for(let t=0;t<a.length;t++)o+=`
      ${e}[${t}] = ${a[t]};
    `;return o},_p=a=>`
  void offsetToIndices(int offset, int[${a}] strides, out int[${a}] indices) {
    if (${a} == 0) {
      return;
    }
    for (int i = 0; i < ${a} - 1; ++i) {
      indices[i] = offset / strides[i];
      offset -= indices[i] * strides[i];
    }
    indices[${a} - 1] = offset;
  }`});var re,zt,Sp,Ap,au,su,uu,lu,fu,cu,pu,du=x(()=>{"use strict";tt();Le();z();N();re=(a,e,o,t,n)=>{Ap(e);let r={name:t,inputNames:["A"],inputTypes:[0]};return[a.run({...r,cacheHint:o.cacheKey,get:()=>Sp(a,e,o,t,n,r)},e)]},zt=a=>{let e=a.attributes.getInts("axes",[]),o=a.attributes.getInt("keepdims",1)===1;return $({axes:e,keepDims:o})},Sp=(a,e,o,t,n,r)=>{let s=[],i=e[0].dims.length||1,u=[],l=O.normalizeAxes(o.axes,e[0].dims.length),f=n(e,l),p=f[1];for(let g=0;g<e[0].dims.length;g++)l.indexOf(g)>=0||l.length===0?(o.keepDims&&s.push(1),p=`
          for(int j${g} = 0; j${g} < ${e[0].dims[g]}; j${g}++) {
            inputIdx[${g}] = j${g};
            ${p}
          }`):(u.push(`inputIdx[${g}] = outputIdx[${s.length}];`),s.push(e[0].dims[g]));let b=`
      float process(int outputIdx[${s.length||1}]) {
        float value;                 // final result
        int inputIdx[${i}];      // addressing input data
        ${u.join(`
`)}
        ${f[0]}       // init ops for reduce max/min
        ${p}
        ${f[2]}       // final computation for reduce mean
        return value;
      }`;return{...r,output:{dims:s,type:e[0].type,textureType:0},shaderSource:b}},Ap=a=>{if(!a||a.length!==1)throw new Error("Reduce op requires 1 input.");if(Vt.indexOf(a[0].type)===-1)throw new Error("Invalid input type.")},au=(a,e,o)=>re(a,e,o,"ReduceSum",()=>["value = 0.0;","value += _A(inputIdx);",""]),su=(a,e,o)=>re(a,e,o,"ReduceMean",(n,r)=>{let s=1;for(let i=0;i<n[0].dims.length;i++)(r.indexOf(i)>=0||r.length===0)&&(s*=n[0].dims[i]);return["value = 0.0;","value += _A(inputIdx);",`value /= ${s}.;`]}),uu=(a,e,o)=>re(a,e,o,"ReduceMax",(n,r)=>{let s=[];for(let i=0;i<n[0].dims.length;i++)(r.indexOf(i)>=0||r.length===0)&&s.push(`inputIdx[${i}] = 0;`);return[`${s.join(`
`)}
value = _A(inputIdx);`,"value = max(value, _A(inputIdx));",""]}),lu=(a,e,o)=>re(a,e,o,"ReduceMin",(n,r)=>{let s=[];for(let i=0;i<n[0].dims.length;i++)(r.indexOf(i)>=0||r.length===0)&&s.push(`inputIdx[${i}] = 0;`);return[`${s.join(`
`)}
value = _A(inputIdx);`,"value = min(value, _A(inputIdx));",""]}),fu=(a,e,o)=>re(a,e,o,"ReduceProd",()=>["value = 1.0;","value *= _A(inputIdx);",""]),cu=(a,e,o)=>re(a,e,o,"ReduceLogSum",()=>["value = 0.0;","value += _A(inputIdx);","value = log(value);"]),pu=(a,e,o)=>re(a,e,o,"ReduceLogSumSquare",()=>["float t; value = 0.0;","t = _A(inputIdx); value += t * t;",""])});var hu,mu=x(()=>{"use strict";z();hu=(a,e)=>{let o=O.calculateReshapedDims(e[0].dims,e[1].integerData);return a.session.pack?[a.reshapePacked(e[0],o)]:[a.reshapeUnpacked(e[0],o)]}});var bu,En,yu,gu,$e,Op,Dn,mr,Ln=x(()=>{"use strict";tt();q();N();bu={name:"Upsample",inputNames:["X"],inputTypes:[0]},En=(a,e,o)=>(Dn(e,o),[a.run({...bu,cacheHint:o.cacheKey,get:()=>Op(a,e,o)},e)]),yu=a=>$e(a,7),gu=a=>$e(a,9),$e=(a,e)=>{let o=e>=10,t=a.attributes.getString("mode","nearest");if(t!=="nearest"&&t!=="linear"&&(e<11||t!=="cubic"))throw new Error(`unrecognized mode: ${t}`);let n=[];e<9&&(n=a.attributes.getFloats("scales"),mr(n,t,o));let r=a.attributes.getFloat("extrapolation_value",0),s=e>10?a.attributes.getString("coordinate_transformation_mode","half_pixel"):"asymmetric";if(["asymmetric","pytorch_half_pixel","tf_half_pixel_for_nn","align_corners","tf_crop_and_resize","half_pixel"].indexOf(s)===-1)throw new Error(`coordinate_transform_mode '${s}' is not supported`);let i=s==="tf_crop_and_resize",u=i,l=t==="nearest"&&e>=11?a.attributes.getString("nearest_mode","round_prefer_floor"):"";if(["round_prefer_floor","round_prefer_ceil","floor","ceil",""].indexOf(l)===-1)throw new Error(`nearest_mode '${l}' is not supported`);let f=a.attributes.getFloat("cubic_coeff_a",-.75),p=a.attributes.getInt("exclude_outside",0)!==0;if(p&&t!=="cubic")throw new Error("exclude_outside can be set to 1 only when mode is CUBIC.");let d=e<11?!0:t==="nearest"&&s==="asymmetric"&&l==="floor",b=0,g=0,y=0;return e>10?a.inputs.length>2?(b=1,g=2,y=3):(g=1,y=2):e===9&&(g=1),$({opset:e,isResize:o,mode:t,scales:n,extrapolationValue:r,coordinateTransformMode:s,useExtrapolation:u,needRoiInput:i,nearestMode:l,cubicCoefficientA:f,excludeOutside:p,useNearest2xOptimization:d,roiInputIdx:b,scalesInputIdx:g,sizesInputIdx:y})},Op=(a,e,o)=>{let t=D(a.session.backend.glContext.version),[n,r]=a.calculateTextureWidthAndHeight(e[0].dims,0),s=e[0].dims.map((y,v)=>Math.floor(y*o.scales[v])),[i,u]=a.calculateTextureWidthAndHeight(s,0),l=s.length,f=new Array(l),p=new Array(l),d=`
      int output_pitches[${l}];
      int input_pitches[${l}];
      `;for(let y=l-1;y>=0;y--)f[y]=y===l-1?1:f[y+1]*s[y+1],p[y]=y===l-1?1:p[y+1]*e[0].dims[y+1],d+=`
        output_pitches[${y}] = ${f[y]};
        input_pitches[${y}] = ${p[y]};
        `;let b=`
      float getInputFloat(int index) {
        vec2 coords = offsetToCoords(index, ${n}, ${r});
        float value = getColorAsFloat(${t.texture2D}(X, coords));
        return value;
      }
      `,g=o.mode==="nearest"?`
    ${b}
    float process(int indices[${l}]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${i}, ${u});

      ${d}

      int d, m;
      for (int dim = 0; dim < ${l}; ++dim) {
        d = output_index / output_pitches[dim];
        m = output_index - d * output_pitches[dim];
        output_index = m;

        if (scales[dim] != 1 && d > 0) {
          int d2 = d / scales[dim];
          m = d - d2 * scales[dim];
          d = d2;
        }
        input_index += input_pitches[dim] * d;
      }

      return getInputFloat(input_index);
    }`:l===4?`
    ${b}
    float process(int indices[4]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${i}, ${u});

      ${d}

      int m;
      int index_of_dim0, index_of_dim1, index_of_dim2, index_of_dim3;
      index_of_dim0 = output_index / output_pitches[0];
      m = output_index - index_of_dim0 * output_pitches[0];
      index_of_dim1 = m / output_pitches[1];
      m = m - index_of_dim1 * output_pitches[1];
      index_of_dim2 = m / output_pitches[2];
      m = m - index_of_dim2 * output_pitches[2];
      index_of_dim3 = m;

      int index_of_input_dim2, index_of_input_dim3, x_offset, y_offset;
      index_of_input_dim2 = index_of_dim2 / scales[2];
      y_offset = index_of_dim2 - index_of_input_dim2 * scales[2];
      index_of_input_dim3 = index_of_dim3 / scales[3];
      x_offset = index_of_dim3 - index_of_input_dim3 * scales[3];

      input_index = index_of_dim0 * input_pitches[0] +
            index_of_dim1 * input_pitches[1] +
            index_of_input_dim2 * input_pitches[2] +
            index_of_input_dim3;

      float x00 = getInputFloat(input_index);
      float x10, x01, x11;

      bool end_of_dim2 = false;
      if (index_of_input_dim2 == (${e[0].dims[2]} - 1)) {
        // It's the end in dimension 2
        x01 = x00;
        end_of_dim2 = true;
      } else {
        x01 = getInputFloat(input_index + input_pitches[2]);
      }

      if (index_of_input_dim3 == (input_pitches[2] - 1)) {
        // It's the end in dimension 3
        x10 = x00;
        x11 = x01;
      }
      else {
        x10 = getInputFloat(input_index + 1);
        x11 = end_of_dim2 ? x10 : getInputFloat(input_index + input_pitches[2] + 1);
      }

      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[2]);
      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[2]);
      return y0 + float(x_offset) * (y1 - y0) / float(scales[3]);
    }`:`
    ${b}
    float process(int indices[2]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${i}, ${u});

      ${d}

      int m;
      int index_of_dim0, index_of_dim1;
      index_of_dim0 = output_index / output_pitches[0];
      m = output_index - index_of_dim0 * output_pitches[0];
      index_of_dim1 = m;

      int index_of_input_dim0, index_of_input_dim1, x_offset, y_offset;
      index_of_input_dim0 = index_of_dim0 / scales[0];
      y_offset = index_of_dim0 - index_of_input_dim0 * scales[0];
      index_of_input_dim1 = index_of_dim1 / scales[1];
      x_offset = index_of_dim1 - index_of_input_dim1 * scales[1];

      input_index = index_of_input_dim0 * input_pitches[0] + index_of_input_dim1;

      float x00 = getInputFloat(input_index);
      float x10, x01, x11;

      bool end_of_dim0 = false;
      if (index_of_input_dim0 == (${e[0].dims[0]} - 1)) {
        // It's the end in dimension 0
        x01 = x00;
        end_of_dim0 = true;
      } else {
        x01 = getInputFloat(input_index + input_pitches[0]);
      }

      if (index_of_input_dim1 == (input_pitches[0] - 1)) {
        // It's the end in dimension 1
        x10 = x00;
        x11 = x01;
      }
      else {
        x10 = getInputFloat(input_index + 1);
        x11 = end_of_dim0 ? x10 : getInputFloat(input_index + input_pitches[0] + 1);
      }

      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[0]);
      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[0]);
      return y0 + float(x_offset) * (y1 - y0) / float(scales[1]);
    }`;return{...bu,output:{dims:s,type:e[0].type,textureType:0},shaderSource:g,variables:[{name:"scales",type:"int",arrayLength:o.scales.length,data:o.scales.map(y=>Math.ceil(y))}]}},Dn=(a,e)=>{if(!a||e.opset<9&&a.length!==1||e.opset>=9&&e.opset<11&&a.length!==2||e.opset>=11&&a.length<2)throw new Error("invalid inputs.");if(e.scales.length>0&&a[0].dims.length!==e.scales.length)throw new Error("Invalid input shape.");if(a[0].type==="string")throw new Error("Invalid input tensor types.")},mr=(a,e,o)=>{if(o){for(let t of a)if(t<=0)throw new Error("Scale value should be greater than 0.")}else for(let t of a)if(t<1)throw new Error("Scale value should be greater than or equal to 1.");if((e==="linear"||e==="cubic")&&a.length!==2&&(a.length!==4||a[0]!==1||a[1]!==1))throw new Error(`'Linear' mode and 'Cubic' mode only support 2-D inputs ('Bilinear', 'Bicubic')         or 4-D inputs with the corresponding outermost 2 scale values being 1         in the ${o?"Resize":"Upsample"} opeartor.`)}});var $n,kn,xu,Tu,Pp,Ep,Dp,Lp,vu=x(()=>{"use strict";q();N();Pt();Qt();Ln();$n={name:"Resize",inputNames:["A"],inputTypes:[2]},kn=(a,e,o)=>(Dn(e,o),[a.run({...$n,cacheHint:o.cacheKey,get:()=>Pp(a,e,o)},e)]),xu=a=>$e(a,10),Tu=a=>$e(a,11),Pp=(a,e,o)=>{let t=D(a.session.backend.glContext.version),[n,r]=Ep(e,o);if(n.every(S=>S===1)&&o.coordinateTransformMode!=="tf_crop_and_resize")return{...$n,output:{dims:r,type:e[0].type,textureType:2},hasMain:!0,shaderSource:`void main() {
                    vec4 v = ${t.texture2D}(X, TexCoords);
                    ${t.output} = v;
                }`};let i=r.length;if(i<2)throw new Error(`output dimension should be at least 2, but got ${i}`);let u=r[i-2],l=r[i-1],f=e[0].dims;if(i!==f.length)throw new Error(`output dimension should match input ${f.length}, but got ${i}`);let p=f[i-2],d=f[i-1],b=n[i-2],g=n[i-1],y="";if(o.mode!=="linear")throw new Error(`resize (packed) does not support mode: '${o.mode}'`);switch(o.coordinateTransformMode){case"asymmetric":y=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        return vec4(coords) / scaleWHWH;
                    }
                `;break;case"half_pixel":y=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        return (vec4(coords) + 0.5) / scaleWHWH - 0.5;
                    }
                `;break;case"pytorch_half_pixel":y=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        vec4 fcoords = vec4(coords);
                        return vec4(
                            ${l}.0 > 1.0 ? (fcoords.x + 0.5) / scaleWHWH.x - 0.5 : 0.0,
                            ${u}.0 > 1.0 ? (fcoords.y + 0.5) / scaleWHWH.y - 0.5 : 0.0,
                            ${l}.0 > 1.0 ? (fcoords.z + 0.5) / scaleWHWH.z - 0.5 : 0.0,
                            ${u}.0 > 1.0 ? (fcoords.w + 0.5) / scaleWHWH.w - 0.5 : 0.0
                          );
                    }
                `;break;case"align_corners":y=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        vec4 resized = vec4(${l}.0 - 1.0, ${u}.0 - 1.0, ${l}.0 - 1.0,
                            ${u}.0 - 1.0);
                        vec4 original = vec4(${d}.0 - 1.0, ${p}.0 - 1.0, ${d}.0 - 1.0,
                            ${p}.0 - 1.0);
                        vec4 new_scale = original / resized;
                        return vec4(coords) * new_scale;
                    }
                `;break;default:throw new Error(`resize (packed) does not support coordinateTransformMode:                                 '${o.coordinateTransformMode}'`)}let v=at(i),_=Et(),A=`
            const vec2 inputWH = vec2(${p}.0, ${d}.0);
            const vec4 scaleWHWH = vec4(float(${b}), float(${g}), float(${b}), float(${g}));
            ${_}
            ${y}
            float getAValue(int x10, int r, int c, int d) {
                return getChannel(getA(x10, r, c, d), vec2(c, d));
            }
            void main() {
                ${v} rc = getOutputCoords();

                int batch = rc[0];
                int depth = rc[1];

                // retrieve the 4 coordinates that is used in the 4 packed output values.
                ivec4 coords = ivec4(rc.wz, rc.w + 1, rc.z + 1);

                // calculate the source index in fraction
                vec4 sourceFrac = getSourceFracIndex(coords);

                // get the lower and upper bound of the 4 values that will be packed into one texel.
                ivec4 x00 = ivec4(max(sourceFrac.xy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xy)));
                ivec4 x01 = ivec4(max(sourceFrac.xw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xw)));
                ivec4 x10 = ivec4(max(sourceFrac.zy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zy)));
                ivec4 x11 = ivec4(max(sourceFrac.zw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zw)));

                bool hasNextRow = rc.w < ${u-1};
                bool hasNextCol = rc.z < ${l-1};

                // pack x00, x01, x10, x11's top-left corner into one vec4 structure
                vec4 topLeft = vec4(
                    getAValue(batch, depth, x00.x, x00.y),
                    hasNextCol ? getAValue(batch, depth, x01.x, x01.y) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.x, x10.y) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.y) : 0.0);

                // pack x00, x01, x10, x11's top-right corner into one vec4 structure
                vec4 topRight = vec4(
                    getAValue(batch, depth, x00.x, x00.w),
                    hasNextCol ? getAValue(batch, depth, x01.x, x01.w) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.x, x10.w) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.w) : 0.0);

                // pack x00, x01, x10, x11's bottom-left corner into one vec4 structure
                vec4 bottomLeft = vec4(
                    getAValue(batch, depth, x00.z, x00.y),
                    hasNextCol ? getAValue(batch, depth, x01.z, x01.y) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.z, x10.y) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.y) : 0.0);

                // pack x00, x01, x10, x11's bottom-right corner into one vec4 structure
                vec4 bottomRight = vec4(
                    getAValue(batch, depth, x00.z, x00.w),
                    hasNextCol ? getAValue(batch, depth, x01.z, x01.w) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.z, x10.w) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.w) : 0.0);

                // calculate the interpolation fraction on u and v direction
                vec4 frac = vec4(sourceFrac) - floor(sourceFrac);
                vec4 clampFrac = clamp(frac, vec4(0.0), vec4(1.0));

                vec4 top = mix(topLeft, topRight, clampFrac.ywyw);
                vec4 bottom = mix(bottomLeft, bottomRight, clampFrac.ywyw);
                vec4 newValue = mix(top, bottom, clampFrac.xxzz);

                ${t.output} = vec4(newValue);
            }
        `;return{...$n,output:{dims:r,type:e[0].type,textureType:2},hasMain:!0,shaderSource:A}},Ep=(a,e)=>{let t=a[0].dims,n=e.scales,r;if(n.length===0){let i=a[e.scalesInputIdx];if(i&&i.size!==0){if(a[e.sizesInputIdx])throw new Error("Only one of scales or sizes must be provided as input.");n=Dp(i,e.mode,e.isResize)}else{let u=a[e.sizesInputIdx];if(!u||u.size===0)throw new Error("Either scales or sizes MUST be provided as input.");r=Array.from(u.integerData),n=Lp(r,t,e.mode,e.isResize)}}else if(a[e.sizesInputIdx])throw new Error("Only one of scales or sizes must be provided as input.");let s=r||t.map((i,u)=>Math.floor(i*n[u]));return[n,s]},Dp=(a,e,o)=>{let t=Array.from(a.floatData);return mr(t,e,o),t},Lp=(a,e,o,t)=>{let n=e.length,r=new Array(n);for(let s=0,i=n;s<i;s++)if(e[s]===0){if(a[s]!==0)throw new Error("Input dim is zero but required output dim is non-zero.");r[s]=1}else r[s]=a[s]/e[s];return mr(r,o,t),r}});var wu,$p,Iu=x(()=>{"use strict";Yt();wu=(a,e)=>($p(e),[new Y([e[0].dims.length],"int32",void 0,void 0,new Int32Array(e[0].dims))]),$p=a=>{if(!a||a.length!==1)throw new Error("Shape requires 1 input.")}});var Bn,_u,Su,Au,kp,Ou,Bp,Fp,Pu=x(()=>{"use strict";tt();Le();z();N();Bn={name:"Slice",inputNames:["A"],inputTypes:[0]},_u=(a,e,o)=>(kp(e),[a.run({...Bn,cacheHint:o.cacheKey,get:()=>Au(a,e[0],o)},e)]),Su=a=>{let e=a.attributes.getInts("starts"),o=a.attributes.getInts("ends"),t=a.attributes.getInts("axes",[]);return $({starts:e,ends:o,axes:t})},Au=(a,e,o)=>{let t=o.axes.length===0?e.dims.slice(0).map((p,d)=>d):o.axes,n=O.normalizeAxes(t,e.dims.length),r=o.starts.map((p,d)=>p>e.dims[n[d]]-1?e.dims[n[d]]:O.normalizeAxis(p,e.dims[n[d]])),s=o.ends.map((p,d)=>p>e.dims[n[d]]-1?e.dims[n[d]]:O.normalizeAxis(p,e.dims[n[d]])),i=e.dims.slice(),u=[];for(let p=0;p<n.length;p++)i[n[p]]=s[p]-r[p],r[p]>0&&u.push(`outputIdx[${n[p]}] += ${r[p]};`);let f=`
      float process(int outputIdx[${i.length}]) {
        ${u.join(`
      `)}
        return _A(outputIdx);
      }`;return{...Bn,output:{dims:i,type:e.type,textureType:0},shaderSource:f}},kp=a=>{if(!a||a.length!==1)throw new Error("Slice requires 1 input.");if(Vt.indexOf(a[0].type)===-1)throw new Error("Invalid input type.")},Ou=(a,e)=>{Fp(e);let o=Bp(a,e);return[a.run({...Bn,cacheHint:o.cacheKey,get:()=>Au(a,e[0],o)},[e[0]])]},Bp=(a,e)=>{if(!a.session.isInitializer(e[1].dataId)||!a.session.isInitializer(e[2].dataId)||e.length>=4&&!a.session.isInitializer(e[3].dataId)||e.length>=5&&!a.session.isInitializer(e[4].dataId))throw new Error("dynamic slice attributes are not allowed");if(e.length>=5&&e[4].integerData.some(s=>s!==1))throw new Error("currently non-1 steps is not supported for Slice");let o=Array.from(e[1].integerData),t=Array.from(e[2].integerData),n=e.length>=4?Array.from(e[3].integerData):[],r=`${n};${o};${t}`;return{starts:o,ends:t,axes:n,cacheKey:r}},Fp=a=>{if(!a||a.length<3||a.length>5)throw new Error("Invalid input number.");if(a[1].type!=="int32"||a[1].dims.length!==1)throw new Error("Invalid input type.");if(a[2].type!=="int32"||a[2].dims.length!==1)throw new Error("Invalid input type.");if(a.length>=4&&(a[3].type!=="int32"||a[3].dims.length!==1))throw new Error("Invalid input type.");if(a.length>=5&&(a[4].type!=="int32"||a[4].dims.length!==1))throw new Error("Invalid input type.")}});var Eu,Du,Lu,$u,ku,Bu,Fu,Nu,Np,Cp,Gp,Cu,Gu=x(()=>{"use strict";tt();z();q();N();pr();Eu={name:"SoftmaxComputeMax",inputNames:["A"],inputTypes:[0]},Du={name:"SoftmaxComputeScale",inputNames:["A","Max"],inputTypes:[0,0]},Lu={name:"SoftMax",inputNames:["A","Max","Norm"],inputTypes:[0,0,0]},$u=(a,e,o)=>{Cu(e);let t=e[0].dims.slice(),n=O.normalizeAxis(o.axis,t.length),r=O.sizeToDimension(t,n),s=O.sizeFromDimension(t,n);return Nu(a,e,o,r,s)},ku=a=>$({axis:a.attributes.getInt("axis",1)}),Bu=a=>$({axis:a.attributes.getInt("axis",-1)}),Fu=(a,e,o)=>{Cu(e);let t=e[0].dims.slice(),n=O.normalizeAxis(o.axis,t.length),r=t.length,s=n!==r-1,i=[],u=[],l=[],f;s&&(u=Array.from({length:r}).map((g,y)=>y),u[n]=r-1,u[r-1]=n,u.map(g=>i.push(t[g])),f=$({perm:u}),l=ee(a,e,f));let p=s?O.sizeToDimension(i,r-1):O.sizeToDimension(t,r-1),d=s?O.sizeFromDimension(i,r-1):O.sizeFromDimension(t,r-1),b=Nu(a,s?l:e,o,p,d);return s?ee(a,b,f):b},Nu=(a,e,o,t,n)=>{let r=Np(a,e[0],t,n,[t]),s=a.run({...Eu,cacheHint:o.cacheKey,get:()=>r},e),i=Cp(a,e[0],t,n,r.output.dims,[t]),u=a.run({...Du,cacheHint:o.cacheKey,get:()=>i},[e[0],s]),l=Gp(a,e[0],t,n,r.output.dims,i.output.dims);return[a.run({...Lu,cacheHint:o.cacheKey,get:()=>l},[e[0],s,u])]},Np=(a,e,o,t,n)=>{let[r,s]=a.calculateTextureWidthAndHeight(e.dims,0),i=n.length;if(o<1||t<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(n.length!==1)throw new Error("Dimensionality of the output should be 1");if(n[0]!==o)throw new Error("Shape of the output should be equal to logical row count");let u=D(a.session.backend.glContext.version),l=`
      float process(int[${i}] indices) {
        int logical_row_start_offset = indices[0] * ${t};

        float max = getColorAsFloat(${u.texture2D}(A, offsetToCoords(logical_row_start_offset, ${r},
        ${s} )));
        for(int i=1; i<${t}; ++i)
        {
          float current = getColorAsFloat(${u.texture2D}(A, offsetToCoords(logical_row_start_offset + i,
            ${r}, ${s})));
          if(current > max)
          max = current;
        }

        return max;
      }`;return{...Eu,output:{dims:n,type:e.type,textureType:0},shaderSource:l}},Cp=(a,e,o,t,n,r)=>{let[s,i]=a.calculateTextureWidthAndHeight(e.dims,0),u=r.length;if(o<1||t<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(r.length!==1)throw new Error("Dimensionality of the output should be 1");if(r[0]!==o)throw new Error("Shape of the output should be equal to logical row count");if(n.length!==1)throw new Error("Dimensionality of the intermediate results should be 1");if(n[0]!==o)throw new Error("Shape of the intermediate results should be equal to logical row count");let l=D(a.session.backend.glContext.version),f=`
      float process(int[${u}] indices) {
        int logical_row_start_offset = indices[0] * ${t};

        float norm_factor = 0.0;
        float max = _Max(indices);
        for(int i=0; i<${t}; ++i)
        {
          norm_factor += exp(getColorAsFloat(${l.texture2D}(A, offsetToCoords(logical_row_start_offset + i,
            ${s}, ${i}))) - max);
        }

        return norm_factor;
      }`;return{...Du,output:{dims:r,type:e.type,textureType:0},shaderSource:f}},Gp=(a,e,o,t,n,r)=>{let[s,i]=a.calculateTextureWidthAndHeight(e.dims,0),u=e.dims.length;if(o<1||t<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(n.length!==1||r.length!==1)throw new Error("Dimensionality of the intermediate results should be 1");if(n[0]!==o||r[0]!==o)throw new Error("Shape of the intermediate results should be equal to logical row count");let l=`
      float process(int[${u}] indices) {

      // get offset of current logical tensor index from the 2-D texture coordinates (TexCoords)
      int offset = coordsToOffset(TexCoords, ${s}, ${i});

      //determine the logical row for this index
      int logical_row_index[1];
      logical_row_index[0] = offset / ${t};

      float norm_factor = _Norm(logical_row_index);

      // avoid possible division by 0
      // if norm_facor is 0, all elements are zero
      // if so, return 0
      if(norm_factor == 0.0)
        return 0.0;

      return exp(_A(indices) - _Max(logical_row_index)) / norm_factor;
    }`;return{...Lu,output:{dims:e.dims,type:e.type,textureType:0},shaderSource:l}},Cu=a=>{if(!a||a.length!==1)throw new Error("Softmax requires 1 input.");if(a[0].type!=="float32"&&a[0].type!=="float64")throw new Error("Invalid input type")}});var Ru,Vu,zu,Rp,Vp,zp,Mu=x(()=>{"use strict";tt();z();N();Ru={name:"Split",inputNames:["A"],inputTypes:[0]},Vu=(a,e,o)=>{zp(e);let t=O.normalizeAxis(o.axis,e[0].dims.length),n=Rp(a,e,t,o),r=[];for(let s=0;s<n;++s)r.push(a.run({...Ru,cacheHint:`${o.cacheKey};${s}`,get:()=>Vp(a,e[0],o,t,s)},e));return r},zu=a=>{let e=a.attributes.getInt("axis",0),o=a.attributes.getInts("split",[]),t=a.outputs.length;return $({axis:e,split:o,numOutputs:t})},Rp=(a,e,o,t)=>{let[,n]=Se.splitShape(e[0].dims,o,t.split,t.numOutputs);return n.length},Vp=(a,e,o,t,n)=>{let[r,s]=Se.splitShape(e.dims,t,o.split,o.numOutputs),i=s[n],u=r[n],f=`
      float process(int indices[${u.length}]) {
        indices[${t}] += ${i};
        return _A(indices);
      }
    `;return{...Ru,cacheHint:`${o.cacheKey}:${n}`,output:{dims:u,type:e.type,textureType:0},shaderSource:f}},zp=a=>{if(!a||a.length!==1)throw new Error("Split requires one input.");if(a[0].type!=="int8"&&a[0].type!=="uint8"&&a[0].type!=="int16"&&a[0].type!=="uint16"&&a[0].type!=="int32"&&a[0].type!=="uint32"&&a[0].type!=="float32"&&a[0].type!=="float64"&&a[0].type!=="bool")throw new Error("Invalid input type.")}});var Fn,Uu,Wu,Mp,Up,Hu=x(()=>{"use strict";z();Fn=(a,e,o)=>{Mp(e);let t=O.squeezeShape(e[0].dims,o);return[a.reshapeUnpacked(e[0],t)]},Uu=(a,e)=>(Up(e),Fn(a,[e[0]],Array.from(e[1].integerData))),Wu=a=>a.attributes.getInts("axes"),Mp=a=>{if(!a||a.length!==1)throw new Error("Squeeze requires 1 input.");if(a[0].type==="string")throw new Error("invalid input tensor types.")},Up=a=>{if(!a||a.length!==2)throw new Error("Squeeze requires 2 inputs.");if(a[1].type!=="int32")throw new Error("Invalid input type.")}});var qu,Wp,Hp,ju=x(()=>{"use strict";q();N();qu=(a,e)=>{Hp(e);let o={name:"Sum",inputNames:e.map((n,r)=>`X${r}`),inputTypes:new Array(e.length).fill(0)};return[a.run({...o,get:()=>Wp(a,e,o)},e)]},Wp=(a,e,o)=>{let t=D(a.session.backend.glContext.version),n=e[0].dims.slice(),s=`
      void main() {
        vec4 result = ${e.map((i,u)=>`${t.texture2D}(X${u},TexCoords)`).join(" + ")};
        ${t.output} = result;
      }
    `;return{...o,output:{dims:n,type:e[0].type,textureType:0},hasMain:!0,shaderSource:s}},Hp=a=>{if(!a||a.length===0)throw new Error("Sum requires inputs.");let e=a[0].dims.length;for(let o=1;o<a.length;o++){if(e!==a[o].dims.length)throw new Error("Input shapes are mismatched.");for(let t=0;t<e;t++)if(a[0].dims[t]!==a[o].dims[t])throw new Error("Input shapes are not matched.")}if(a[0].type!=="float32"&&a[0].type!=="float64")throw new Error("Invalid input type.");for(let o=1;o<a.length;o++)if(a[0].type!==a[o].type)throw new Error("Input types are not matched.")}});var Ku,qp,jp,Xu=x(()=>{"use strict";Le();N();Ku=(a,e)=>{jp(e);let o={name:"Tile",inputNames:["A"],inputTypes:[0]};return[a.run({...o,get:()=>qp(a,e,o)},e)]},qp=(a,e,o)=>{let t=e[0].dims.slice(),n=new Array(t.length),r=[];for(let u=0;u<t.length;u++)n[u]=t[u]*e[1].numberData[u],r.push(`inputIdx[${u}] = int(mod(float(outputIdx[${u}]), ${t[u]}.));`);let s=n.length,i=`
      float process(int outputIdx[${s}]) {
        int inputIdx[${s}];
        ${r.join(`
`)}
        return _A(inputIdx);
      }
    `;return{...o,output:{dims:n,type:e[0].type,textureType:0},shaderSource:i}},jp=a=>{if(!a||a.length!==2)throw new Error("Tile requires 2 input.");if(a[1].dims.length!==1)throw new Error("The second input shape must 1 dimension.");if(a[1].dims[0]!==a[0].dims.length)throw new Error("Invalid input shape.");if(Vt.indexOf(a[0].type)===-1)throw new Error("Invalid input type.");if(a[1].type!=="int32"&&a[1].type!=="int16")throw new Error("Invalid repeat type.")}});var Nn,Ju,Zu,Kp,Xp,Yu=x(()=>{"use strict";z();Nn=(a,e,o)=>{Kp(e);let t=O.unsqueezeShape(e[0].dims,o);return[a.reshapeUnpacked(e[0],t)]},Ju=(a,e)=>(Xp(e),Nn(a,[e[0]],Array.from(e[1].integerData))),Zu=a=>a.attributes.getInts("axes"),Kp=a=>{if(!a||a.length!==1)throw new Error("Unsqueeze requires 1 input.");if(a[0].type==="string")throw new Error("invalid input tensor types.")},Xp=a=>{if(!a||a.length!==2)throw new Error("Unsqueeze requires 2 inputs.");if(a[1].type!=="int32")throw new Error("Invalid input type.")}});var Qu,tl=x(()=>{"use strict";fa();Ia();Aa();$a();lr();ms();vs();_s();Os();Ls();Bs();Gs();Ms();fr();qs();iu();du();mu();vu();Iu();Pu();Gu();Mu();Hu();ju();Xu();pr();xn();Yu();Ln();Qu=[["Abs","","6+",ka],["Acos","","7+",Ba],["Add","","7+",ca],["And","","7+",pa],["Asin","","7+",Fa],["Atan","","7+",Na],["AveragePool","","7+",Ks,Xs],["BatchNormalization","","7+",ua,la],["Cast","","6+",_a,Sa],["Ceil","","6+",Ra],["Clip","","6-10",yn,Ca],["Clip","","11+",Ga],["Concat","","4+",Ea,La],["Conv","","1+",Sn,An],["ConvTranspose","","1+",ds,hs],["Cos","","7+",Va],["Div","","7+",da],["Dropout","","7+",gn],["DepthToSpace","","1+",xs,Ts],["Equal","","7+",ha],["Elu","","6+",za,Ma],["Exp","","6+",Ua],["Flatten","","1+",ws,Is],["Floor","","6+",Wa],["FusedConv","com.microsoft","1+",Sn,An],["Gather","","1+",Ss,As],["Gemm","","7-10",On,Es],["Gemm","","11+",On,Ds],["GlobalAveragePool","","1+",Zs,Ys],["GlobalMaxPool","","1+",nu],["Greater","","7+",ma],["Identity","","1+",gn],["ImageScaler","","1+",$s,ks],["InstanceNormalization","","6+",Ns,Cs],["LeakyRelu","","6+",Ha,qa],["Less","","7+",ba],["LRN","","1+",Rs,Vs],["Log","","6+",ja],["MatMul","","1+",as,ss],["MaxPool","","1+",Qs,tu],["Mul","","7+",ya],["Neg","","6+",Ka],["Not","","1+",Xa],["Or","","7+",ga],["Pad","","2-10",Pn,Us],["Pad","","11+",Ws,Hs],["Pow","","7+",xa],["PRelu","","7+",Ta],["ReduceLogSum","","1+",cu,zt],["ReduceMax","","1+",uu,zt],["ReduceMean","","1+",su,zt],["ReduceMin","","1+",lu,zt],["ReduceProd","","1+",fu,zt],["ReduceSum","","1-12",au,zt],["ReduceSumSquare","","1+",pu,zt],["Relu","","6+",Ja],["Reshape","","5+",hu],["Resize","","10",kn,xu],["Resize","","11+",kn,Tu],["Shape","","1+",wu],["Sigmoid","","6+",Za],["Sin","","7+",Ya],["Slice","","10+",Ou],["Slice","","1-9",_u,Su],["Softmax","","1-12",$u,ku],["Softmax","","13+",Fu,Bu],["Split","","2-12",Vu,zu],["Sqrt","","6+",Qa],["Squeeze","","1-12",Fn,Wu],["Squeeze","","13+",Uu],["Sub","","7+",va],["Sum","","6+",qu],["Tan","","7+",ts],["Tanh","","6+",es],["Tile","","6+",Ku],["Transpose","","1+",ee,ys],["Upsample","","7-8",En,yu],["Upsample","","9",En,gu],["Unsqueeze","","1-12",Nn,Zu],["Unsqueeze","","13+",Ju],["Xor","","7+",wa]]});function rl(a){let e={},o;for(;(o=el.exec(a))!==null;){let t=o[3].split(",").map(n=>{let r=n.trim().split(" ");return r&&r.length===2?{type:r[0],name:r[1]}:null}).filter(n=>n!==null);e[o[2]]={params:t,body:o[4]}}for(let t in e){let n=Jp.replace("__FUNC__",t),r=new RegExp(n,"gm");for(;(o=r.exec(a))!==null;){let s=o[1],i=o[2],u=o[3].split(","),l=s?`${s} ${i};`:"",f=e[t].body,p="";e[t].params.forEach((b,g)=>{b&&(p+=`${b.type} ${b.name} = ${u[g]};
`)}),f=`${p}
 ${f}`,f=f.replace("return",`${i} = `);let d=`
      ${l}
      {
        ${f}
      }
      `;a=a.replace(o[0],d)}}return a=a.replace(el,""),a}var el,Jp,nl=x(()=>{"use strict";el=/@inline[\s\n\r]+(\w+)[\s\n\r]+([0-9a-zA-Z_]+)\s*\(([^)]*)\)\s*{(([^}]|[\n\r])*)}/gm,Jp="(\\w+)?\\s+([_0-9a-zA-Z]+)\\s+=\\s+__FUNC__\\((.*)\\)\\s*;"});function he(a,e){let o=[],t=[],n=e!=null&&Array.isArray(e)&&e.length===0,r=e==null||n?null:Zp(e,a).sort(),s=0;for(let i=0;i<a.length;++i){if(r!=null){if(r[s]===i&&a[i]!==1)throw new Error(`Can't squeeze axis ${i} since its dim '${a[i]}' is not 1`);(r[s]==null||r[s]>i)&&a[i]===1&&(o.push(a[i]),t.push(i)),r[s]<=i&&s++}a[i]!==1&&(o.push(a[i]),t.push(i))}return{newShape:o,keptDims:t}}function Zp(a,e){let o=e.length;return a=a==null?e.map((t,n)=>n):[].concat(a),ue(a.every(t=>t>=-o&&t<o),()=>`All values in axis param must be in range [-${o}, ${o}) but got axis ${a}`),ue(a.every(Yp),()=>`All values in axis param must be integers but got axis ${a}`),a.map(t=>t<0?o+t:t)}function Yp(a){return a%1===0}function Qp(a){if(a.length===0)return 1;let e=a[0];for(let o=1;o<a.length;o++)e*=a[o];return e}function ol(a){let e=Math.ceil(Math.sqrt(a));return[e,Math.ceil(a/e)]}var br,Cn=x(()=>{"use strict";pt();z();br=class{constructor(e){this.maxTextureSize=e}computeTextureWH(e,o){let t=this.computeTexture(e,o);return o&&o.isPacked&&(t[0]/=2,t[1]/=2),o&&o.reverseWH?[t[1],t[0]]:t}computeTexture(e,o){let t=o&&o.isPacked;if(e.length===0)return t?[2,2]:[1,1];let n=this.maxTextureSize;if(o&&o.breakAxis!==void 0){let i=o.breakAxis>=e.length?1:e.slice(o.breakAxis).reduce((l,f)=>l*f),u=o.breakAxis<=0?1:e.slice(0,o.breakAxis).reduce((l,f)=>l*f);if(i>n||u>n)M.verbose("TextureLayout",`Given width/height preferences were unattainable: shape:${e}, breakAxis:${o.breakAxis}`);else return[i,u]}let r=e.slice(0);t&&(n=n*2,r=r.map((i,u)=>u>=r.length-2?r[u]%2===0?r[u]:r[u]+1:r[u]),r.length===1&&(r=[2,r[0]])),r.length!==2&&(r=he(r).newShape);let s=Qp(r);return r.length<=1&&s<=n?[1,s]:r.length===2&&r[0]<=n&&r[1]<=n?r:r.length===3&&r[0]*r[1]<=n&&r[2]<=n?[r[0]*r[1],r[2]]:r.length===3&&r[0]<=n&&r[1]*r[2]<=n?[r[0],r[1]*r[2]]:r.length===4&&r[0]*r[1]*r[2]<=n&&r[3]<=n?[r[0]*r[1]*r[2],r[3]]:r.length===4&&r[0]<=n&&r[1]*r[2]*r[3]<=n?[r[0],r[1]*r[2]*r[3]]:t?ol(s/4).map(i=>i*2):ol(s)}}});var yr,il=x(()=>{"use strict";z();Bt();q();Cn();Pt();yr=class extends bt{constructor(o){super(o)}getFunctions(){return{...this.offsetToCoords(),...this.coordsToOffset(),...this.toVec(),...this.valueFrom(),...this.getCommonUtilFuncs(),...this.getInputsSamplingSnippets(),...this.getOutputSamplingSnippet()}}getCustomTypes(){return{}}offsetToCoords(){let o="offsetToCoords";return{offsetToCoords:new I(`
      vec2 ${o}(int offset, int width, int height) {
        int t = offset / width;
        int s = offset - t*width;
        vec2 coords = (vec2(s,t) + vec2(0.5,0.5)) / vec2(width, height);
        return coords;
      }
      `)}}coordsToOffset(){let o="coordsToOffset";return{coordsToOffset:new I(`
      int ${o}(vec2 coords, int width, int height) {
        float s = coords.s * float(width);
        float t = coords.t * float(height);
        int offset = int(t) * width + int(s);
        return offset;
      }
      `)}}getOutputSamplingSnippet(){let o=this.context.outputTextureLayout;return o.isPacked?this.getPackedOutputSamplingSnippet(o):this.getUnpackedOutputSamplingSnippet(o)}getPackedOutputSamplingSnippet(o){let t=o.unpackedShape,n=[o.width,o.height],r={},s="getOutputCoords";switch(t.length){case 0:r[s]=this.getOutputScalarCoords();break;case 1:r[s]=this.getOutputPacked1DCoords(t,n);break;case 2:r[s]=this.getOutputPacked2DCoords(t,n);break;case 3:r[s]=this.getOutputPacked3DCoords(t,n);break;default:r[s]=this.getOutputPackedNDCoords(t,n)}let u=`
      void setOutput(vec4 val) {
        ${D(this.context.glContext.version).output} = val;
      }
    `,l="floatTextureSetRGBA";return r[l]=new I(u),r}getUnpackedOutputSamplingSnippet(o){let t=o.unpackedShape,n=[o.width,o.height],r={},s="getOutputCoords";switch(t.length){case 0:r[s]=this.getOutputScalarCoords();break;case 1:r[s]=this.getOutputUnpacked1DCoords(t,n);break;case 2:r[s]=this.getOutputUnpacked2DCoords(t,n);break;case 3:r[s]=this.getOutputUnpacked3DCoords(t,n);break;case 4:r[s]=this.getOutputUnpacked4DCoords(t,n);break;case 5:r[s]=this.getOutputUnpacked5DCoords(t,n);break;case 6:r[s]=this.getOutputUnpacked6DCoords(t,n);break;default:throw new Error(`Unsupported output dimensionality: ${t.length}`)}let u=`
        void setOutput(float val) {
          ${D(this.context.glContext.version).output} = vec4(val, 0, 0, 0);
        }
    `,l="floatTextureSetR";return r[l]=new I(u),r}getOutputScalarCoords(){return new I(`
      int getOutputCoords() {
        return 0;
      }
    `)}getOutputPacked1DCoords(o,t){let n=t,r="";return n[0]===1?(r=`
          int getOutputCoords() {
            return 2 * int(TexCoords.y * ${n[1]}.0);
          }
        `,new I(r)):n[1]===1?(r=`
          int getOutputCoords() {
            return 2 * int(TexCoords.x * ${n[0]}.0);
          }
        `,new I(r)):(r=`
        int getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                 vec2(${n[0]}, ${n[1]}));
          return 2 * (resTexRC.y * ${n[0]} + resTexRC.x);
        }
      `,new I(r))}getOutputPacked2DCoords(o,t){let n="";if(Kt.arraysEqual(o,t))return n=`
        ivec2 getOutputCoords() {
          return 2 * ivec2(TexCoords.xy * vec2(${t[0]}, ${t[1]}));
        }
      `,new I(n);let r=t,s=Math.ceil(o[1]/2);return n=`
        ivec2 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${r[0]}, ${r[1]}));

          int index = resTexRC.y * ${r[0]} + resTexRC.x;

          // reverse r and c order for packed texture
          int r = imod(index, ${s}) * 2;
          int c = 2 * (index / ${s});

          return ivec2(r, c);
        }
      `,new I(n)}getOutputPacked3DCoords(o,t){let n=[t[0],t[1]],r=Math.ceil(o[2]/2),s=r*Math.ceil(o[1]/2),i=`
        ivec3 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${n[0]}, ${n[1]}));
          int index = resTexRC.y * ${n[0]} + resTexRC.x;

          int b = index / ${s};
          index -= b * ${s};

          // reverse r and c order for packed texture
          int r = imod(index, ${r}) * 2;
          int c = 2 * (index / ${r});

          return ivec3(b, r, c);
        }
      `;return new I(i)}getOutputPackedNDCoords(o,t){let n=[t[0],t[1]],r=Math.ceil(o[o.length-1]/2),s=r*Math.ceil(o[o.length-2]/2),i=s,u="",l="b, r, c";for(let p=2;p<o.length-1;p++)i*=o[o.length-p-1],u=`
      int b${p} = index / ${i};
      index -= b${p} * ${i};
    `+u,l=`b${p}, `+l;let f=`
      ivec${o.length} getOutputCoords() {
        ivec2 resTexRC = ivec2(TexCoords.xy *
                              vec2(${n[0]}, ${n[1]}));
        int index = resTexRC.y * ${n[0]} + resTexRC.x;

        ${u}

        int b = index / ${s};
        index -= b * ${s};

        // reverse r and c order for packed texture
        int r = imod(index, ${r}) * 2;
        int c = 2 * (index / ${r});

        return ivec${o.length}(${l});
      }
    `;return new I(f)}getOutputUnpacked1DCoords(o,t){let n=`
        int getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${t[0]}, ${t[1]}));
          return resTexRC.y * ${t[0]} + resTexRC.x;
        }
      `;return new I(n)}getOutputUnpacked2DCoords(o,t){let n=`
        ivec2 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${t[0]}, ${t[1]}));
          int index = resTexRC.y * ${t[0]} + resTexRC.x;
          int r = index / ${o[1]};
          int c = index - r * ${o[1]};
          return ivec2(r, c);
        }
      `;return new I(n)}getOutputUnpacked3DCoords(o,t){let n="",r=o.length,s=null;r<2&&(s=[]),s=new Array(r-1),s[r-2]=o[r-1];for(let l=r-3;l>=0;--l)s[l]=s[l+1]*o[l+1];let i=["r","c","d"],u=s.map((l,f)=>{let p=`int ${i[f]} = index / ${l}`,d=f===s.length-1?`int ${i[f+1]} = index - ${i[f]} * ${l}`:`index -= ${i[f]} * ${l}`;return`${p}; ${d};`}).join("");return n=`
        ivec3 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${t[0]}, ${t[1]}));
          int index = resTexRC.y * ${t[0]} + resTexRC.x;
          ${u}
          return ivec3(r, c, d);
        }
      `,new I(n)}getOutputUnpacked4DCoords(o,t){let n="",r=o.length,s=null;r<2&&(s=[]),s=new Array(r-1),s[r-2]=o[r-1];for(let l=r-3;l>=0;--l)s[l]=s[l+1]*o[l+1];let i=["r","c","d","d2"],u=s.map((l,f)=>{let p=`int ${i[f]} = index / ${l}`,d=f===s.length-1?`int ${i[f+1]} = index - ${i[f]} * ${l}`:`index -= ${i[f]} * ${l}`;return`${p}; ${d};`}).join("");return n=`
      ivec4 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${t[0]}, ${t[1]}));
          int index = resTexRC.y * ${t[0]} + resTexRC.x;
          ${u}
          return ivec4(r, c, d, d2);
        }
      `,new I(n)}getOutputUnpacked5DCoords(o,t){let n="",r=o.length,s=null;r<2&&(s=[]),s=new Array(r-1),s[r-2]=o[r-1];for(let l=r-3;l>=0;--l)s[l]=s[l+1]*o[l+1];let i=["r","c","d","d2","d3"],u=s.map((l,f)=>{let p=`int ${i[f]} = index / ${l}`,d=f===s.length-1?`int ${i[f+1]} = index - ${i[f]} * ${l}`:`index -= ${i[f]} * ${l}`;return`${p}; ${d};`}).join("");return n=`
      ivec5 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${t[0]}, ${t[1]}));
          int index = resTexRC.y * ${t[0]} + resTexRC.x;
          ${u}
          return ivec5(r, c, d, d2, d3);
        }
      `,new I(n)}getOutputUnpacked6DCoords(o,t){let n="",r=o.length,s=null;r<2&&(s=[]),s=new Array(r-1),s[r-2]=o[r-1];for(let l=r-3;l>=0;--l)s[l]=s[l+1]*o[l+1];let i=["r","c","d","d2","d3","d4"],u=s.map((l,f)=>{let p=`int ${i[f]} = index / ${l}`,d=f===s.length-1?`int ${i[f+1]} = index - ${i[f]} * ${l}`:`index -= ${i[f]} * ${l}`;return`${p}; ${d};`}).join("");return n=`
     ivec6 getOutputCoords() {
         ivec2 resTexRC = ivec2(TexCoords.xy *
                               vec2(${t[0]}, ${t[1]}));
         int index = resTexRC.y * ${t[0]} + resTexRC.x;
         ${u}
         return ivec6(r, c, d, d2, d3, d4);
       }
     `,new I(n)}getCommonUtilFuncs(){let o={},t="uvFromFlat";o[t]=new I(`
    vec2 uvFromFlat(int texNumR, int texNumC, int index) {
      int texC = index / texNumR;
      int texR = index - texC * texNumR;
      // TODO: swap texR, texC order in following function so row is corresponding to u and column is corresponding to
      //       v.
      return (vec2(texR, texC) + halfCR) / vec2(texNumR, texNumC);
    }
    `),t="packedUVfrom1D",o[t]=new I(`
      vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
        int texelIndex = index / 2;
        int texR = texelIndex / texNumC;
        int texC = texelIndex - texR * texNumC;
        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
      }
      `),t="packedUVfrom2D",o[t]=new I(`
      vec2 packedUVfrom2D(int texNumR, int texNumC, int texelsInLogicalRow, int row, int col) {
        int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
        int texR = texelIndex / texNumC;
        int texC = texelIndex - texR * texNumC;
        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
      }
      `),t="packedUVfrom3D",o[t]=new I(`
      vec2 packedUVfrom3D(int texNumR, int texNumC,
          int texelsInBatch, int texelsInLogicalRow, int b,
          int row, int col) {
        int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
        int texR = index / texNumC;
        int texC = index - texR * texNumC;
        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
      }
      `),t="sampleTexture";let n=D(this.context.glContext.version);return o[t]=new I(`
        float sampleTexture(sampler2D textureSampler, vec2 uv) {
            return ${n.texture2D}(textureSampler, uv).r;
        }`),o}getInputsSamplingSnippets(){let o={},t=this.context.outputTextureLayout;return this.context.programInfo.inputNames.forEach((n,r)=>{let s=this.context.inputTextureLayouts[r],i=rr(n);s.isPacked?o[i]=this.getPackedSamplerFromInput(i,n,s):o[i]=this.getUnpackedSamplerFromInput(i,n,s);let u=qi(n);s.unpackedShape.length<=t.unpackedShape.length&&(s.isPacked?o[u]=this.getPackedSamplerAtOutputCoords(u,s,t,n):o[u]=this.getUnpackedSamplerAtOutputCoords(u,s,t,n))}),o}getPackedSamplerAtOutputCoords(o,t,n,r){let s=t.unpackedShape,i=n.unpackedShape,l=rr(r),f=s.length,p=i.length,d=it.getBroadcastDims(s,i),b=at(p),g=p-f,y,v=St();f===0?y="":p<2&&d.length>=1?y="coords = 0;":y=d.map(Mt=>`coords.${v[Mt+g]} = 0;`).join(`
`);let _="";p<2&&f>0?_="coords":_=s.map((Mt,Fe)=>`coords.${v[Fe+g]}`).join(", ");let A="return outputValue;",C=O.size(s)===1,st=O.size(i)===1;if(f===1&&!C&&!st)A=`
        return vec4(outputValue.xy, outputValue.xy);
      `;else if(C&&!st)p===1?A=`
          return vec4(outputValue.x, outputValue.x, 0., 0.);
        `:A=`
          return vec4(outputValue.x);
        `;else if(d.length){let Mt=f-2,Fe=f-1;d.indexOf(Mt)>-1&&d.indexOf(Fe)>-1?A="return vec4(outputValue.x);":d.indexOf(Mt)>-1?A="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":d.indexOf(Fe)>-1&&(A="return vec4(outputValue.xx, outputValue.zz);")}let At=`
        int lastDim = coords.${v[p-1]};
        coords.${v[p-1]} = coords.${v[p-2]};
        coords.${v[p-2]} = lastDim;
      `,kr=`
      vec4 ${o}() {
        ${b} coords = getOutputCoords();
        ${At}
        ${y}
        vec4 outputValue = ${l}(${_});
        ${A}
      }
    `;return new I(kr,["coordinates.getOutputCoords"])}getUnpackedSamplerAtOutputCoords(o,t,n,r){let s=[n.width,n.height],i=[t.width,t.height],u=t.unpackedShape.length,l=n.unpackedShape.length,f=t.unpackedShape,p=n.unpackedShape,d=rr(r);if(u===l&&Kt.arraysEqual(i,s)){let C=`
          float ${o}() {
            return sampleTexture(${r}, TexCoords);
          }
        `;return new I(C,["coordinates.sampleTexture"])}let b=at(l),g=it.getBroadcastDims(f,p),y=l-u,v,_=St();u===0?v="":l<2&&g.length>=1?v="coords = 0;":v=g.map(C=>`coords.${_[C+y]} = 0;`).join(`
`);let A="";l<2&&u>0?A="coords":A=t.unpackedShape.map((C,F)=>`coords.${_[F+y]}`).join(", ");let S=`
        float ${o}() {
          ${b} coords = getOutputCoords();
          ${v}
          return ${d}(${A});
        }
      `;return new I(S,["coordinates.getOutputCoords"])}getPackedSamplerFromInput(o,t,n){switch(n.unpackedShape.length){case 0:return this.getPackedSamplerScalar(o,t);case 1:return this.getPackedSampler1D(o,t,n);case 2:return this.getPackedSampler2D(o,t,n);case 3:return this.getPackedSampler3D(o,t,n);default:return this.getPackedSamplerND(o,t,n)}}getUnpackedSamplerFromInput(o,t,n){let r=n.unpackedShape;switch(r.length){case 0:return this.getUnpackedSamplerScalar(o,t,n);case 1:return this.getUnpackedSampler1D(o,t,n);case 2:return this.getUnpackedSampler2D(o,t,n);case 3:return this.getUnpackedSampler3D(o,t,n);case 4:return this.getUnpackedSampler4D(o,t,n);case 5:return this.getUnpackedSampler5D(o,t,n);case 6:return this.getUnpackedSampler6D(o,t,n);default:throw new Error(`Unsupported dimension ${r.length}-D`)}}getPackedSamplerScalar(o,t){let n=D(this.context.glContext.version),r=`
          vec4 ${o}() {
            return ${n.texture2D}(${t}, halfCR);
          }
        `;return new I(r)}getPackedSampler1D(o,t,n){let r=[n.width,n.height],s=[r[1],r[0]],i=D(this.context.glContext.version),l=`vec4 ${o}(int index) {
      vec2 uv = packedUVfrom1D(
      ${s[0]}, ${s[1]}, index);
      return ${i.texture2D}(${t}, uv);
    }`;return new I(l,["coordinates.packedUVfrom1D"])}getPackedSampler2D(o,t,n){let r=n.unpackedShape,s=[n.width,n.height],i=D(this.context.glContext.version),u=s[0],l=s[1];if(s!=null&&Kt.arraysEqual(r,s)){let g=`vec4 ${o}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${l}.0, ${u}.0);
        return ${i.texture2D}(${t}, uv);
      }`;return new I(g)}let f=s,p=Math.ceil(r[1]/2),b=`vec4 ${o}(int row, int col) {
      vec2 uv = packedUVfrom2D(${f[1]}, ${f[0]}, ${p}, row, col);
      return ${i.texture2D}(${t}, uv);
    }`;return new I(b,["coordinates.packedUVfrom2D"])}getPackedSampler3D(o,t,n){let r=n.unpackedShape,s=[n.width,n.height],i=[s[0],s[1]],u=D(this.context.glContext.version);if(r[0]===1){let y=r.slice(1),v=[1,2],_=le(r,y),A=["b","row","col"],S=JSON.parse(JSON.stringify(n));S.unpackedShape=_;let C=this.getPackedSamplerFromInput(o,t,S),st=`${C.routineBody}
      vec4 ${o}(int b, int row, int col) {
        return ${o}(${fe(A,v)});
      } `;return new I(st,C.dependencies)}let l=i[0],f=i[1],p=Math.ceil(r[2]/2),d=p*Math.ceil(r[1]/2),g=`vec4 ${o}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${f}, ${l}, ${d}, ${p}, b, row, col);
      return ${u.texture2D}(${t}, uv);}`;return new I(g,["coordinates.packedUVfrom3D"])}getPackedSamplerND(o,t,n){let r=n.unpackedShape,s=r.length,i=[n.width,n.height],u=D(this.context.glContext.version),l=[i[0],i[1]],f=l[1],p=l[0],d=Math.ceil(r[s-1]/2),b=d*Math.ceil(r[s-2]/2),g="int b, int row, int col",y=`b * ${b} + (row / 2) * ${d} + (col / 2)`;for(let A=2;A<s-1;A++)g=`int b${A}, `+g,b*=r[s-A-1],y=`b${A} * ${b} + `+y;let _=`vec4 ${o}(${g}) {
      int index = ${y};
      int texR = index / ${p};
      int texC = index - texR * ${p};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${p}, ${f});
      return ${u.texture2D}(${t}, uv);
    }`;return new I(_)}getUnpackedSamplerScalar(o,t,n){let[r,s]=[n.width,n.height];if(r===1&&s===1){let u=`
          float ${o}() {
            return sampleTexture(${t}, halfCR);
          }
        `;return new I(u,["coordinates.sampleTexture"])}let i=`
        float ${o}() {
          int offset_${t} = coordsToOffset(TexCoords, ${r}, ${s});
          vec2 uv = uvFromFlat(${r}, ${s}, offset_${t});
          return sampleTexture(${t}, uv);
        }
      `;return new I(i,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler1D(o,t,n){let r=n.width,s=n.height;if(s===1&&r===1){let u=`
        float ${o}(int index) {
          return sampleTexture(${t}, halfCR);
        }
      `;return new I(u,["coordinates.sampleTexture"])}if(s===1){let u=`
          float ${o}(int index) {
            vec2 uv = vec2((float(index) + 0.5) / ${r}.0, 0.5);
            return sampleTexture(${t}, uv);
          }
        `;return new I(u,["coordinates.sampleTexture"])}if(r===1){let u=`
          float ${o}(int index) {
            vec2 uv = vec2(0.5, (float(index) + 0.5) / ${s}.0);
            return sampleTexture(${t}, uv);
          }
        `;return new I(u,["coordinates.sampleTexture"])}let i=`
        float ${o}(int index) {
          vec2 uv = uvFromFlat(${r}, ${s}, index);
          return sampleTexture(${t}, uv);
        }
      `;return new I(i,["coordinates.uvFromFlat","coordinates.sampleTexture"])}getUnpackedSampler2D(o,t,n){let r=n.unpackedShape,s=[n.height,n.width];if(s!=null&&Kt.arraysEqual(r,s)){let b=s[1],g=s[0],y=`
          float ${o}(int row, int col) {
            vec2 uv = (vec2(row, col) + halfCR) / vec2(${b}.0, ${g}.0);
            return sampleTexture(${t}, uv);
          }
        `;return new I(y,["coordinates.sampleTexture"])}let{newShape:i,keptDims:u}=he(r),l=i;if(l.length<r.length){let b=le(r,l),g=JSON.parse(JSON.stringify(n));g.unpackedShape=b;let y=["col","row"],v=`
          ${this.getUnpackedSamplerFromInput(o,t,g).routineBody}
          float ${o}(int row, int col) {
            return ${o}(${fe(y,u)});
          }
        `;return new I(v,["coordinates.sampleTexture"])}let f=s[1],p=s[0];if(p===1){let b=`
          float ${o}(int row, int col) {
            int offset_${t} = coordsToOffset(TexCoords, ${f}, ${p});
            float index = dot(vec3(row, col, offset_${t}), vec3(${r[1]}, 1, 1));
            vec2 uv = vec2(0.5, (index + 0.5) / ${f}.0);
            return sampleTexture(${t}, uv);
          }
        `;return new I(b,["coordinates.sampleTexture","coordinates.coordsToOffset"])}if(f===1){let b=`
          float ${o}(int row, int col) {
            int offset_${t} = coordsToOffset(TexCoords, ${f}, ${p});
            float index = dot(vec3(row, col, offset_${t}), vec3(${r[1]}, 1, 1));
            vec2 uv = vec2((index + 0.5) / ${p}.0, 0.5);
            return sampleTexture(${t}, uv);
          }
        `;return new I(b,["coordinates.sampleTexture","coordinates.coordsToOffset"])}let d=`
        float ${o}(int row, int col) {
          int index = col * ${r[1]} + row;
          vec2 uv = uvFromFlat(${f}, ${p}, index);
          return sampleTexture(${t}, uv);
        }
      `;return new I(d,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler3D(o,t,n){let r=n.unpackedShape,s=r[1]*r[2],i=r[2],{newShape:u,keptDims:l}=he(r),f=u;if(f.length<r.length){let g=le(r,f),y=["batch","col","row"],v=JSON.parse(JSON.stringify(n));v.unpackedShape=g;let _=this.getUnpackedSamplerFromInput(o,t,v),A=l.reverse(),S=`
          ${_.routineBody}
          float ${o}(int batch, int row, int col) {
            return ${o}(${fe(y,A)});
          }
        `;return new I(S,_.dependencies)}let p=n.width,d=n.height,b=`
          float ${o}(int depth, int row, int col) {
            // Explicitly use integer operations as dot() only works on floats.
            int index = depth * ${s} + col * ${i} + row;
            vec2 uv = uvFromFlat(${p}, ${d}, index);
            return sampleTexture(${t}, uv);
          }
      `;return new I(b,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler4D(o,t,n){let r=n.unpackedShape,s=r[3],i=r[2]*s,u=r[1]*i,l=n.width,f=n.height,p=`
        float ${o}(int row, int col, int depth, int depth2) {
          int index = row * ${u} + col * ${i} +
              depth2 * ${s} + depth;
          vec2 uv = uvFromFlat(${l}, ${f}, index);
          return sampleTexture(${t}, uv);
        }
      `;return new I(p,["coordinates.uvFromFlat","coordinates.sampleTexture"])}getUnpackedSampler5D(o,t,n){let r=n.unpackedShape,s=r[4],i=r[3]*s,u=r[2]*i,l=r[1]*u,{newShape:f,keptDims:p}=he(r);if(f.length<r.length){let y=le(r,f),v=["row","col","depth","depth2","depth3"],_=JSON.parse(JSON.stringify(n));_.unpackedShape=y;let A=`
          ${this.getUnpackedSamplerFromInput(o,t,_).routineBody}
          float ${o}(int row, int col, int depth, int depth2, int depth3) {
            return ${o}(${fe(v,p)});
          }
        `;return new I(A,["coordinates.sampleTexture","coordinates.uvFromFlat"])}let d=n.width,b=n.height,g=`
        float ${o}(int row, int col, int depth, int depth2, int depth3) {
          int index = row * ${l} + col * ${u} + depth * ${i} +
          depth3 * ${s} + depth2;
          vec2 uv = uvFromFlat(${d}, ${b}, index);
          return sampleTexture(${t}, uv);
        }
      `;return new I(g,["coordinates.sampleTexture","coordinates.uvFromFlat"])}getUnpackedSampler6D(o,t,n){let r=n.unpackedShape,s=r[5],i=r[4]*s,u=r[3]*i,l=r[2]*u,f=r[1]*l,{newShape:p,keptDims:d}=he(r);if(p.length<r.length){let v=le(r,p),_=["row","col","depth","depth2","depth3","depth4"],A=JSON.parse(JSON.stringify(n));A.unpackedShape=v;let S=`
            ${this.getUnpackedSamplerFromInput(o,t,A).routineBody}
            float ${o}(int row, int col, int depth,
              int depth2, int depth3, int depth4) {
              return ${o}(${fe(_,d)});
            }
          `;return new I(S,["coordinates.sampleTexture","coordinates.uvFromFlat"])}let b=n.width,g=n.height,y=`
          float ${o}(int row, int col, int depth,
            int depth2, int depth3, int depth4) {
            int index = row * ${f} + col * ${l} + depth * ${u} +
            depth2 * ${i} + depth3 * ${s} + depth4;
            vec2 uv = uvFromFlat(${b}, ${g}, index);
            return sampleTexture(${t}, uv);
          }
        `;return new I(y,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}toVec(){let o=this.context.outputTextureLayout,t=o.shape.length,n=o.strides,r=o.width,s=o.height,i=[];for(let l=0;l<t-1;++l)i.push(`
        c[${l}] = offset / ${n[l]};`),i.push(`
        offset -= c[${l}] * ${n[l]};`);i.push(`
        c[${t-1}] = offset;`);let u=`
      void toVec(vec2 texCoords, out int c[${t}]) {
        int offset = coordsToOffset(texCoords, ${r}, ${s});
        ${i.join("")}
      }
      void toVec(int offset, out int c[${t}]) {
        ${i.join("")}
      }
    `;return{toVec:new I(u,["coordinates.coordsToOffset"])}}valueFrom(){let o={};return this.context.programInfo.inputNames.forEach((t,n)=>{let r=this.context.inputTextureLayouts[n],i=(r.unpackedShape.length>0?r.unpackedShape:r.shape).length,u=`_${t}`;o[u]=new I(this.getValueFromSingle(t,i,r.width,r.height,!1),[`shapeUtils.indicesToOffset${u}`,"coordinates.offsetToCoords","fragcolor.getColorAsFloat"]),u=u+"_T",o[u]=new I(this.getValueFromSingle(t,i,r.width,r.height,!0),[`shapeUtils.indicesToOffset${u}`,"coordinates.offsetToCoords","fragcolor.getColorAsFloat"])}),o}getValueFromSingle(o,t,n,r,s){let i=`_${o}`;s&&(i=i+"_T");let u=D(this.context.glContext.version);return`
        float ${i}(int m[${t}]) {
          int offset = indicesToOffset${i}(m);
          vec2 coords = offsetToCoords(offset, ${n}, ${r});
          float value = getColorAsFloat(${u.texture2D}(${o}, coords));
          return value;
        }
        `}getPackedValueFrom(o,t,n,r,s){let i=`_${o}_Pack`;s&&(i=i+"_T");let u=D(this.context.glContext.version);return`
        vec4 ${i}(int m[${t}]) {
          int offset = indicesToOffset_${o}(m);
          vec2 coords = offsetToCoords(offset, ${n}, ${r});
          return ${u.texture2D}(${o}, coords);
        }
        `}}});var gr,al=x(()=>{"use strict";Bt();gr=class a extends bt{constructor(e){super(e)}getFunctions(){return{...this.encodeFloat32(),...this.decodeFloat32()}}getCustomTypes(){return{}}encodeFloat32(){return{encode:new I(`highp vec4 encode(highp float f) {
        return vec4(f, 0.0, 0.0, 0.0);
      }
        `)}}decodeFloat32(){return{decode:new I(`highp float decode(highp vec4 rgba) {
        return rgba.r;
      }
        `)}}encodeUint8(){let e=a.isLittleEndian()?"rgba.rgba=rgba.abgr;":"";return{encode:new I(`
      highp vec4 encode(highp float f) {
        highp float F = abs(f);
        highp float Sign = step(0.0,-f);
        highp float Exponent = floor(log2(F));
        highp float Mantissa = (exp2(- Exponent) * F);
        Exponent = floor(log2(F) + 127.0) + floor(log2(Mantissa));
        highp vec4 rgba;
        rgba[0] = 128.0 * Sign  + floor(Exponent*exp2(-1.0));
        rgba[1] = 128.0 * mod(Exponent,2.0) + mod(floor(Mantissa*128.0),128.0);
        rgba[2] = floor(mod(floor(Mantissa*exp2(23.0 -8.0)),exp2(8.0)));
        rgba[3] = floor(exp2(23.0)*mod(Mantissa,exp2(-15.0)));
        ${e}
        rgba = rgba / 255.0; // values need to be normalized to [0,1]
        return rgba;
    }
        `)}}decodeUint8(){let e=a.isLittleEndian()?"rgba.rgba=rgba.abgr;":"";return{decode:new I(`
        highp float decode(highp vec4 rgba) {
          rgba = rgba * 255.0; // values need to be de-normalized from [0,1] to [0,255]
          ${e}
          highp float Sign = 1.0 - step(128.0,rgba[0])*2.0;
          highp float Exponent = 2.0 * mod(rgba[0],128.0) + step(128.0,rgba[1]) - 127.0;
          highp float Mantissa = mod(rgba[1],128.0)*65536.0 + rgba[2]*256.0 +rgba[3] + float(0x800000);
          highp float Result =  Sign * exp2(Exponent) * (Mantissa * exp2(-23.0 ));
          return Result;
      }
        `)}}static isLittleEndian(){let e=new ArrayBuffer(4),o=new Uint32Array(e),t=new Uint8Array(e);if(o[0]=3735928559,t[0]===239)return!0;if(t[0]===222)return!1;throw new Error("unknown endianness")}}});var xr,sl=x(()=>{"use strict";Bt();q();xr=class extends bt{constructor(e){super(e)}getFunctions(){return{...this.setFragColor(),...this.getColorAsFloat()}}getCustomTypes(){return{}}setFragColor(){let e=D(this.context.glContext.version);return{setFragColor:new I(`
        void setFragColor(float value) {
            ${e.output} = encode(value);
        }
        `,["encoding.encode"])}}getColorAsFloat(){return{getColorAsFloat:new I(`
        float getColorAsFloat(vec4 color) {
            return decode(color);
        }
        `,["encoding.decode"])}}}});var Tr,ul=x(()=>{"use strict";Bt();Tr=class a extends bt{constructor(e){super(e)}getFunctions(){return{...this.bcastIndex(),...this.bcastMatmulIndex(),...this.offsetToIndices(),...this.indicesToOffset(),...this.incrementIndices()}}getCustomTypes(){return{}}bcastIndex(){let e=this.context.outputTextureLayout.shape.length,o={};return this.context.programInfo.inputNames.forEach((t,n)=>{let r=this.context.inputTextureLayouts[n].unpackedShape;if(r.length<=e){let s=r.length,i=e-s,u=`bcastIndices_${t}`,l="";for(let p=0;p<s;++p)l+=`
          realIndices[${p}] = int( mod(float(bcastedIndices[${i+p}]), ${r[p]}.0) );
          `;let f=`
        void ${u} (int bcastedIndices[${e}], out int realIndices[${s}]) {
          ${l}
        }
        `;o[u]=new I(f)}}),o}bcastMatmulIndex(){let e=this.context.outputTextureLayout.shape.length,o={};return this.context.programInfo.inputNames.forEach((t,n)=>{let r=this.context.inputTextureLayouts[n].shape;if(!(r.length<2||r.length>e)){let s=r.length,i=e-s,u=`bcastMatmulIndices_${t}`,l="";for(let p=0;p<s-2;++p)l+=`
          realIndices[${p}] = int( mod(float(bcastedIndices[${i+p}]), ${r[p]}.0) );
          `;let f=`
        void ${u}(int bcastedIndices[${e}], out int realIndices[${s}]) {
          ${l}
          realIndices[${s-1}] = bcastedIndices[${e-1}];
          realIndices[${s-2}] = bcastedIndices[${e-2}];
        }
        `;o[u]=new I(f)}}),o}indicesToOffset(){let e={};return this.context.programInfo.inputNames.forEach((o,t)=>{let n=this.context.inputTextureLayouts[t].shape,r=this.context.inputTextureLayouts[t].strides,s=n.length,i=`indicesToOffset_${o}`;e[i]=new I(a.indexToOffsetSingle(i,s,r)),i=`indicesToOffset_${o}_T`,e[i]=new I(a.indexToOffsetSingle(i,s,r.slice().reverse()))}),e}static indexToOffsetSingle(e,o,t){let n="";for(let r=o-1;r>=0;--r)n+=`
        offset += indices[${r}] * ${t[r]};
        `;return`
      int ${e}(int indices[${o}]) {
        int offset = 0;
        ${n}
        return offset;
      }
      `}offsetToIndices(){let e={};return this.context.programInfo.inputNames.forEach((o,t)=>{let n=this.context.inputTextureLayouts[t].shape,r=this.context.inputTextureLayouts[t].strides,s=n.length,i=`offsetToIndices_${o}`;e[i]=new I(a.offsetToIndicesSingle(i,s,r)),i=`offsetToIndices_${o}_T`,e[i]=new I(a.offsetToIndicesSingle(i,s,r.slice().reverse()))}),e}static offsetToIndicesSingle(e,o,t){let n=[];for(let r=0;r<o-1;++r)n.push(`
      indices[${r}] = offset / ${t[r]};`),n.push(`
        offset -= indices[${r}] * ${t[r]};`);return n.push(`
      indices[${o-1}] = offset;`),`
      void ${e}(int offset, out int indices[${o}]) {
        ${n.join("")}
      }
      `}incrementIndices(){let e={};return this.context.programInfo.inputNames.forEach((o,t)=>{let n=this.context.inputTextureLayouts[t].shape,r=n.length,s=`incrementIndices_${o}`,i="";for(let l=0;l<r;++l)i+=`
        shape[${l}] = ${n[l]};`;let u=`
        void ${s}(int axis, out int indices[${r}]) {
          int shape[${r}];
          ${i};
          for(int i = ${r} -1 ; i >= 0; --i) {
            if(i > axis) continue;
            indices[i] += 1;
            if(indices[i] < shape[i]) {
              break;
            }
            indices[i] = 0;
          }
        }
        `;e[s]=new I(u)}),e}}});var vr,ll=x(()=>{"use strict";Bt();vr=class extends bt{constructor(e){super(e)}getCustomTypes(){return{}}getFunctions(){return{...this.binaryVecFunctions(),...this.copyVec(),...this.setVecItem(),...this.getVecItem()}}binaryVecFunctions(){let o=this.context.outputTextureLayout.shape.length,t={add:"+=",sub:"-=",mul:"*=",div:"/="},n={};for(let r in t){let s=`${r}Vec`,i="";for(let l=0;l<o;++l)i+=`
          dest[${l}] ${t[r]} src[${l}];
          `;let u=`
        void ${s}(int src[${o}], out int dest[${o}]) {
          ${i}
        }
        `;n[s]=new I(u)}return n}copyVec(){let o=this.context.outputTextureLayout.shape.length,t="";for(let r=0;r<o;++r)t+=`
        dest[${r}] = src[${r}];
        `;let n=`
      void copyVec(int src[${o}], out int dest[${o}]) {
        ${t}
      }
      `;return{copyVec:new I(n)}}setVecItem(){let o=this.context.outputTextureLayout.shape.length,t=`
        if(index < 0)
            index =${o} + index;
        if (index == 0)
            m[0] = value;
        `;for(let r=1;r<o-1;++r)t+=`
        else if (index == ${r})
            m[${r}] = value;
            `;t+=`
        else
            m[${o-1}] = value;
        `;let n=`
      void setVecItem(out int m[${o}], int index, int value) {
        ${t}
      }
        `;return{setVecItem:new I(n)}}getVecItem(){let o=this.context.outputTextureLayout.shape.length,t=`
        if(index < 0)
            index = ${o} + index;
        if (index == 0)
            return m[0];
      `;for(let r=1;r<o-1;++r)t+=`
        else if (index == ${r})
            return m[${r}];
      `;t+=`
        else
            return m[${o-1}];
        `;let n=`
      int getVecItem(int m[${o}], int index) {
        ${t}
      }
    `;return{getVecItem:new I(n)}}}});var Gn,fl=x(()=>{"use strict";il();al();sl();ul();ll();Gn={encoding:gr,fragcolor:xr,vec:vr,shapeUtils:Tr,coordinates:yr}});var wr,cl=x(()=>{"use strict";Bt();nl();fl();q();wr=class{constructor(e,o,t,n){this.libs={};this.glslLibRoutineDependencyGraph={};this.context=new ar(e,o,t,n),Object.keys(Gn).forEach(s=>{let i=new Gn[s](this.context);this.libs[s]=i});let r=this.glslLibRoutineDependencyGraph;for(let s in this.libs){let u=this.libs[s].getFunctions();for(let l in u){let f=s+"."+l,p;r[f]?(p=r[f],p.routineBody=u[l].routineBody):(p=new De(f,u[l].routineBody),r[f]=p);let d=u[l].dependencies;if(d)for(let b=0;b<d.length;++b)if(r[d[b]])p.addDependency(r[d[b]]);else{let g=new De(d[b]);r[d[b]]=g,p.addDependency(g)}}}}preprocess(){let e=this.context.programInfo,o=e.shaderSource;return this.context.programInfo.hasMain||(o=`${o}
      ${Hi(this.context.glContext.version,this.context.outputTextureLayout.shape.length)}`),o=rl(o),`${Wi(this.context.glContext.version)}
    ${this.getUniforms(e.inputNames,e.variables)}
    ${this.getImports(o)}
    ${o}`}getImports(e){let o=this.selectGlslLibRoutinesToBeIncluded(e);if(o.length===0)return"";let t="";for(let n=0;n<o.length;++n)if(o[n].routineBody)t+=o[n].routineBody+`
`;else throw new Error(`Missing body for the Glsl Library routine: ${o[n].name}`);return t}selectGlslLibRoutinesToBeIncluded(e){let o=[];return Object.keys(this.glslLibRoutineDependencyGraph).forEach(t=>{let n=t.split(".")[1];e.indexOf(n)!==-1&&o.push(this.glslLibRoutineDependencyGraph[t])}),sr.returnOrderedNodes(o)}getUniforms(e,o){let t=[];if(e)for(let n of e)t.push(`uniform sampler2D ${n};`);if(o)for(let n of o)t.push(`uniform ${n.type} ${n.name}${n.arrayLength?`[${n.arrayLength}]`:""};`);return t.join(`
`)}}});var Ir,pl=x(()=>{"use strict";Ft();pt();cl();q();Ir=class{constructor(e,o,t){this.profiler=e;this.glContext=o;this.textureLayoutStrategy=t;this.repo=new Map,this.attributesBound=!1}getArtifact(e){return this.repo.get(e)}setArtifact(e,o){this.repo.set(e,o)}run(e,o,t){this.profiler.event("op",`ProgramManager.run ${e.programInfo.name??"unknown kernel"}`,()=>{let n=this.glContext.gl,r=e.program;n.useProgram(r);try{this.bindOutput(t),this.attributesBound||this.bindAttributes(e.attribLocations),this.bindUniforms(e.uniformLocations,e.programInfo.variables??[],o)}catch(s){throw M.error("ProgramManager",e.programInfo.shaderSource),s}this.profiler.event("backend","GlContext.draw()",()=>{this.glContext.draw()})},this.glContext)}dispose(){this.vertexShader&&this.glContext.deleteShader(this.vertexShader),this.repo.forEach(e=>this.glContext.deleteProgram(e.program))}build(e,o,t){return this.profiler.event("backend","ProgramManager.build",()=>{let n=new wr(this.glContext,e,o,t),r=n.preprocess(),s=this.compile(r);return{programInfo:e,program:s,uniformLocations:this.getUniformLocations(s,n.context.programInfo.inputNames,n.context.programInfo.variables),attribLocations:this.getAttribLocations(s)}})}compile(e){if(!this.vertexShader){M.verbose("ProrgramManager","Compiling and caching Vertex shader for the first time");let n=Ui(this.glContext.version);this.vertexShader=this.glContext.compileShader(n,this.glContext.gl.VERTEX_SHADER)}j.debug&&M.verbose("ProrgramManager",`FragShader:
${e}
`);let o=this.glContext.compileShader(e,this.glContext.gl.FRAGMENT_SHADER),t=this.glContext.createProgram(this.vertexShader,o);return this.glContext.deleteShader(o),t}bindOutput(e){let o=e.width,t=e.height;M.verbose("ProrgramManager",`Binding output texture to Framebuffer: w/h=${o}/${t}, shape=${e.shape}, type=${e.tensor.type}`),this.glContext.attachFramebuffer(e.texture,o,t)}bindAttributes(e){let o=e.position,t=e.textureCoord;this.glContext.setVertexAttributes(o,t),this.attributesBound=!0}bindUniforms(e,o,t){let n=this.glContext.gl,r=0;for(let{name:s,type:i,location:u,arrayLength:l}of e){let f=o.find(p=>p.name===s)?.data;if(i!=="sampler2D"&&!f)throw new Error(`variable '${s}' does not have data defined in program info`);switch(i){case"sampler2D":this.bindTexture(t[r],u,r),r++;break;case"float":l?n.uniform1fv(u,f):n.uniform1f(u,f);break;case"int":l?n.uniform1iv(u,f):n.uniform1i(u,f);break;default:throw new Error(`Uniform not implemented: ${i}`)}}}bindTexture(e,o,t){this.glContext.bindTextureToUniform(e.texture,t,o)}getAttribLocations(e){return{position:this.getAttribLocation(e,"position"),textureCoord:this.getAttribLocation(e,"textureCoord")}}getUniformLocations(e,o,t){let n=[];if(o)for(let r of o)n.push({name:r,type:"sampler2D",location:this.getUniformLocation(e,r)});if(t)for(let r of t)n.push({...r,location:this.getUniformLocation(e,r.name)});return n}getUniformLocation(e,o){let n=this.glContext.gl.getUniformLocation(e,o);if(n===null)throw new Error(`Uniform ${o} not found.`);return n}getAttribLocation(e,o){return this.glContext.gl.getAttribLocation(e,o)}}});var _r,dl=x(()=>{"use strict";pt();Pe();_r=class{constructor(e,o,t,n){this.glContext=e;this.layoutStrategy=o;this.profiler=t;this.config=n;this.pendingRead=new Map;n.reuseTextures&&(this.inUseTextures=new Map,this.idleTextures=new Map,this.textureLookup=new Map)}createTextureFromLayout(e,o,t,n){let r=this.toEncoderType(e),s=this.glContext.getEncoder(r,o.channels||1,n);if(o.isPacked&&n===1)throw new Error("not implemented");let i=o.width,u=o.height,l,f;if(this.config.reuseTextures){l=`${i}x${u}_${s.format}_${s.internalFormat}_${s.textureType}`,f=this.inUseTextures.get(l),f||(f=[],this.inUseTextures.set(l,f));let d=this.idleTextures.get(l);if(d&&d.length>0){let b=d.pop();return f.push(b),n===1&&this.glContext.updateTexture(b,i,u,s,this.toTextureData(e,t)),b}}M.verbose("TextureManager",`Creating new texture of size ${o.width}x${o.height}`);let p=this.glContext.allocateTexture(i,u,s,this.toTextureData(e,t));return this.config.reuseTextures&&(f.push(p),this.textureLookup.set(p,l)),p}readTexture(e,o,t){return t||(t=1),this.profiler.event("backend","TextureManager.readTexture",()=>{let n=e.shape.reduce((s,i)=>s*i)*t,r=this.glContext.readTexture(e.texture,e.width,e.height,n,this.toEncoderType(o),t);return this.toTensorData(o,r)})}async readTextureAsync(e,o,t){let n=e.tensor.dataId;if(t||(t=1),this.pendingRead.has(n)){let r=this.pendingRead.get(n);return new Promise(s=>r?.push(s))}return this.profiler.event("backend","TextureManager.readTextureAsync",async()=>{this.pendingRead.set(n,[]);let r=e.shape.reduce((l,f)=>l*f)*t;await this.glContext.createAndWaitForFence();let s=this.glContext.readTexture(e.texture,e.width,e.height,r,this.toEncoderType(o),t),i=this.toTensorData(o,s),u=this.pendingRead.get(n);return this.pendingRead.delete(n),u?.forEach(l=>l(i)),i})}readUint8TextureAsFloat(e){return this.profiler.event("backend","TextureManager.readUint8TextureAsFloat",()=>{let o=e.shape.reduce((n,r)=>n*r),t=this.glContext.readTexture(e.texture,e.width,e.height,o*4,"byte",4);return new Float32Array(t.buffer,t.byteOffset,o)})}releaseTexture(e,o){let t;if(this.config.reuseTextures&&(t=this.textureLookup.get(e.texture),t)){o&&this.textureLookup.delete(t);let n=this.inUseTextures.get(t);if(n){let r=n.indexOf(e.texture);if(r!==-1){n.splice(r,1);let s=this.idleTextures.get(t);s||(s=[],this.idleTextures.set(t,s)),s.push(e.texture)}}}(!t||o)&&(M.verbose("TextureManager",`Deleting texture of size ${e.width}x${e.height}`),this.glContext.deleteTexture(e.texture))}toTensorData(e,o){switch(e){case"int16":return o instanceof Int16Array?o:Int16Array.from(o);case"int32":return o instanceof Int32Array?o:Int32Array.from(o);case"int8":return o instanceof Int8Array?o:Int8Array.from(o);case"uint16":return o instanceof Uint16Array?o:Uint16Array.from(o);case"uint32":return o instanceof Uint32Array?o:Uint32Array.from(o);case"uint8":case"bool":return o instanceof Uint8Array?o:Uint8Array.from(o);case"float32":return o instanceof Float32Array?o:Float32Array.from(o);case"float64":return o instanceof Float64Array?o:Float64Array.from(o);default:throw new Error(`TensorData type ${e} is not supported`)}}toTextureData(e,o){if(o)return o instanceof Float32Array?o:new Float32Array(o)}toEncoderType(e){return"float"}clearActiveTextures(){this.glContext.clearActiveTextures()}}});var Sr,hl=x(()=>{"use strict";pt();Eo();aa();tl();pl();Cn();dl();Sr=class{constructor(e,o){this.backend=e;this.context=o;this.layoutStrategy=new br(e.glContext.maxTextureSize),this.programManager=new Ir(this.context.profiler,e.glContext,this.layoutStrategy),this.textureManager=new _r(e.glContext,this.layoutStrategy,this.context.profiler,{reuseTextures:e.textureCacheMode==="full"}),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache=new Map,this.pack=e.pack,this.pack2unpackMap=new Map,this.unpack2packMap=new Map}createInferenceHandler(){return new ir(this)}onGraphInitialized(e){let o=e.getValues().filter(t=>t.from===-1&&t.tensor).map(t=>t.tensor.dataId);this.initializers=new Set(o)}isInitializer(e){return this.initializers?this.initializers.has(e):!1}addInitializer(e){this.initializers.add(e)}getTextureData(e,o){return o?this.packedTextureDataCache.get(e):this.unpackedTextureDataCache.get(e)}setTextureData(e,o,t=!1){M.verbose("WebGLSessionHandler","Storing Texture data in cache"),t?this.packedTextureDataCache.set(e,o):this.unpackedTextureDataCache.set(e,o)}dispose(){this.programManager.dispose(),this.textureManager.clearActiveTextures(),this.packedTextureDataCache.forEach(e=>this.textureManager.releaseTexture(e,!0)),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache.forEach(e=>this.textureManager.releaseTexture(e,!0)),this.unpackedTextureDataCache=new Map}resolve(e,o,t){let n=Po(e,o,Qu);return{impl:n.opImpl,context:n.opInit?n.opInit(e,t):e}}}});function td(a){let e=0;for(;e<a.length&&a[e]();++e);return e-1}var ke,ml=x(()=>{"use strict";Ft();Pe();Pe();Pt();ke=class{constructor(e,o){this.frameBufferBound=!1;this.itemsToPoll=[];this.gl=e,this.version=o,this.getExtensions(),this.vertexbuffer=this.createVertexbuffer(),this.framebuffer=this.createFramebuffer(),this.queryVitalParameters()}allocateTexture(e,o,t,n){let r=this.gl,s=r.createTexture();r.bindTexture(r.TEXTURE_2D,s),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_MIN_FILTER,r.NEAREST),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_MAG_FILTER,r.NEAREST),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_WRAP_S,r.CLAMP_TO_EDGE),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_WRAP_T,r.CLAMP_TO_EDGE);let i=n?t.encode(n,e*o):null;return r.texImage2D(r.TEXTURE_2D,0,t.internalFormat,e,o,0,t.format,t.textureType,i),this.checkError(),s}updateTexture(e,o,t,n,r){let s=this.gl;s.bindTexture(s.TEXTURE_2D,e);let i=n.encode(r,o*t);s.texSubImage2D(s.TEXTURE_2D,0,0,0,o,t,n.format,n.textureType,i),this.checkError()}attachFramebuffer(e,o,t){let n=this.gl;n.bindTexture(n.TEXTURE_2D,e),n.bindFramebuffer(n.FRAMEBUFFER,this.framebuffer),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,e,0),this.checkError(),n.viewport(0,0,o,t),n.scissor(0,0,o,t)}readTexture(e,o,t,n,r,s){let i=this.gl;s||(s=1),this.frameBufferBound||this.attachFramebuffer(e,o,t);let u=this.getEncoder(r,s),l=u.allocate(o*t);return i.bindTexture(i.TEXTURE_2D,e),i.framebufferTexture2D(i.FRAMEBUFFER,i.COLOR_ATTACHMENT0,i.TEXTURE_2D,e,0),i.readPixels(0,0,o,t,i.RGBA,u.textureType,l),this.checkError(),u.decode(l,n)}isFramebufferReady(){return!0}getActiveTexture(){let e=this.gl;return`TEXTURE${e.getParameter(this.gl.ACTIVE_TEXTURE)-e.TEXTURE0}`}getTextureBinding(){return this.gl.getParameter(this.gl.TEXTURE_BINDING_2D)}getFramebufferBinding(){return this.gl.getParameter(this.gl.FRAMEBUFFER_BINDING)}setVertexAttributes(e,o){let t=this.gl;t.vertexAttribPointer(e,3,t.FLOAT,!1,20,0),t.enableVertexAttribArray(e),o!==-1&&(t.vertexAttribPointer(o,2,t.FLOAT,!1,20,12),t.enableVertexAttribArray(o)),this.checkError()}createProgram(e,o){let t=this.gl,n=t.createProgram();return t.attachShader(n,e),t.attachShader(n,o),t.linkProgram(n),n}compileShader(e,o){let t=this.gl,n=t.createShader(o);if(!n)throw new Error(`createShader() returned null with type ${o}`);if(t.shaderSource(n,e),t.compileShader(n),t.getShaderParameter(n,t.COMPILE_STATUS)===!1)throw new Error(`Failed to compile shader: ${t.getShaderInfoLog(n)}
Shader source:
${e}`);return n}deleteShader(e){this.gl.deleteShader(e)}bindTextureToUniform(e,o,t){let n=this.gl;n.activeTexture(n.TEXTURE0+o),this.checkError(),n.bindTexture(n.TEXTURE_2D,e),this.checkError(),n.uniform1i(t,o),this.checkError()}draw(){this.gl.drawArrays(this.gl.TRIANGLE_STRIP,0,4),this.checkError()}checkError(){if(j.debug){let e=this.gl,o=e.getError(),t="";switch(o){case e.NO_ERROR:return;case e.INVALID_ENUM:t="INVALID_ENUM";break;case e.INVALID_VALUE:t="INVALID_VALUE";break;case e.INVALID_OPERATION:t="INVALID_OPERATION";break;case e.INVALID_FRAMEBUFFER_OPERATION:t="INVALID_FRAMEBUFFER_OPERATION";break;case e.OUT_OF_MEMORY:t="OUT_OF_MEMORY";break;case e.CONTEXT_LOST_WEBGL:t="CONTEXT_LOST_WEBGL";break;default:t=`Unknown WebGL Error: ${o.toString(16)}`}throw new Error(t)}}deleteTexture(e){this.gl.deleteTexture(e)}deleteProgram(e){this.gl.deleteProgram(e)}getEncoder(e,o,t=0){if(this.version===2)return new nr(this.gl,o);switch(e){case"float":return t===1||this.isRenderFloat32Supported?new Oe(this.gl,o):new Oe(this.gl,o,this.textureHalfFloatExtension.HALF_FLOAT_OES);case"int":throw new Error("not implemented");case"byte":return new or(this.gl,o);default:throw new Error(`Invalid dataType: ${e}`)}}clearActiveTextures(){let e=this.gl;for(let o=0;o<this.maxTextureImageUnits;++o)e.activeTexture(e.TEXTURE0+o),e.bindTexture(e.TEXTURE_2D,null)}dispose(){if(this.disposed)return;let e=this.gl;e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteFramebuffer(this.framebuffer),e.bindBuffer(e.ARRAY_BUFFER,null),e.deleteBuffer(this.vertexbuffer),e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null),e.finish(),this.disposed=!0}createDefaultGeometry(){return new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0])}createVertexbuffer(){let e=this.gl,o=e.createBuffer();if(!o)throw new Error("createBuffer() returned null");let t=this.createDefaultGeometry();return e.bindBuffer(e.ARRAY_BUFFER,o),e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW),this.checkError(),o}createFramebuffer(){let e=this.gl.createFramebuffer();if(!e)throw new Error("createFramebuffer returned null");return e}queryVitalParameters(){let e=this.gl;if(this.isFloatTextureAttachableToFrameBuffer=this.checkFloatTextureAttachableToFrameBuffer(),this.isRenderFloat32Supported=this.checkRenderFloat32(),this.isFloat32DownloadSupported=this.checkFloat32Download(),this.version===1&&!this.textureHalfFloatExtension&&!this.isRenderFloat32Supported)throw new Error("both float32 and float16 TextureType are not supported");this.isBlendSupported=!this.isRenderFloat32Supported||this.checkFloat32Blend(),this.maxTextureSize=e.getParameter(e.MAX_TEXTURE_SIZE),this.maxTextureImageUnits=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS),this.version}getExtensions(){this.version===2?(this.colorBufferFloatExtension=this.gl.getExtension("EXT_color_buffer_float"),this.disjointTimerQueryWebgl2Extension=this.gl.getExtension("EXT_disjoint_timer_query_webgl2")):(this.textureFloatExtension=this.gl.getExtension("OES_texture_float"),this.textureHalfFloatExtension=this.gl.getExtension("OES_texture_half_float"))}checkFloatTextureAttachableToFrameBuffer(){let e=this.gl,o=e.createTexture();e.bindTexture(e.TEXTURE_2D,o);let t=this.version===2?e.RGBA32F:e.RGBA;e.texImage2D(e.TEXTURE_2D,0,t,1,1,0,e.RGBA,e.FLOAT,null);let n=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,n),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,o,0);let r=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(o),e.deleteFramebuffer(n),r}checkRenderFloat32(){if(this.version===2){if(!this.colorBufferFloatExtension)return!1}else if(!this.textureFloatExtension)return!1;return this.isFloatTextureAttachableToFrameBuffer}checkFloat32Download(){if(this.version===2){if(!this.colorBufferFloatExtension)return!1}else if(!this.textureFloatExtension||!this.gl.getExtension("WEBGL_color_buffer_float"))return!1;return this.isFloatTextureAttachableToFrameBuffer}checkFloat32Blend(){let e=this.gl,o,t,n,r,s;try{o=e.createTexture(),t=e.createFramebuffer(),e.bindTexture(e.TEXTURE_2D,o);let i=this.version===2?e.RGBA32F:e.RGBA;return e.texImage2D(e.TEXTURE_2D,0,i,1,1,0,e.RGBA,e.FLOAT,null),e.bindFramebuffer(e.FRAMEBUFFER,t),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,o,0),e.enable(e.BLEND),n=e.createShader(e.VERTEX_SHADER),!n||(e.shaderSource(n,"void main(){}"),e.compileShader(n),r=e.createShader(e.FRAGMENT_SHADER),!r)||(e.shaderSource(r,"precision highp float;void main(){gl_FragColor=vec4(0.5);}"),e.compileShader(r),s=e.createProgram(),!s)?!1:(e.attachShader(s,n),e.attachShader(s,r),e.linkProgram(s),e.useProgram(s),e.drawArrays(e.POINTS,0,1),e.getError()===e.NO_ERROR)}finally{e.disable(e.BLEND),s&&e.deleteProgram(s),n&&e.deleteShader(n),r&&e.deleteShader(r),t&&(e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteFramebuffer(t)),o&&(e.bindTexture(e.TEXTURE_2D,null),e.deleteTexture(o))}}beginTimer(){if(this.version===2&&this.disjointTimerQueryWebgl2Extension){let e=this.gl,o=this.disjointTimerQueryWebgl2Extension,t=e.createQuery();return e.beginQuery(o.TIME_ELAPSED_EXT,t),t}else throw new Error("WebGL1 profiling currently not supported.")}endTimer(){if(this.version===2&&this.disjointTimerQueryWebgl2Extension){let e=this.gl,o=this.disjointTimerQueryWebgl2Extension;e.endQuery(o.TIME_ELAPSED_EXT);return}else throw new Error("WebGL1 profiling currently not supported")}isTimerResultAvailable(e){let o=!1,t=!1;if(this.version===2&&this.disjointTimerQueryWebgl2Extension){let n=this.gl,r=this.disjointTimerQueryWebgl2Extension;o=n.getQueryParameter(e,n.QUERY_RESULT_AVAILABLE),t=n.getParameter(r.GPU_DISJOINT_EXT)}else throw new Error("WebGL1 profiling currently not supported");return o&&!t}getTimerResult(e){let o=0;if(this.version===2){let t=this.gl;o=t.getQueryParameter(e,t.QUERY_RESULT),t.deleteQuery(e)}else throw new Error("WebGL1 profiling currently not supported");return o/1e6}async waitForQueryAndGetTime(e){return await ln(()=>this.isTimerResultAvailable(e)),this.getTimerResult(e)}async createAndWaitForFence(){let e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let o,t=e,n=t.fenceSync(t.SYNC_GPU_COMMANDS_COMPLETE,0);return e.flush(),n===null?o=()=>!0:o=()=>{let r=t.clientWaitSync(n,0,0);return r===t.ALREADY_SIGNALED||r===t.CONDITION_SATISFIED},{query:n,isFencePassed:o}}async pollFence(e){return new Promise(o=>{this.addItemToPoll(()=>e.isFencePassed(),()=>o())})}pollItems(){let e=td(this.itemsToPoll.map(o=>o.isDoneFn));for(let o=0;o<=e;++o){let{resolveFn:t}=this.itemsToPoll[o];t()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}async addItemToPoll(e,o){this.itemsToPoll.push({isDoneFn:e,resolveFn:o}),!(this.itemsToPoll.length>1)&&await ln(()=>(this.pollItems(),this.itemsToPoll.length===0))}}});function Rn(a){let e;if((!a||a==="webgl2")&&"webgl2"in me?e=me.webgl2:(!a||a==="webgl")&&"webgl"in me&&(e=me.webgl),!e)try{let t=rd();e=bl(t,a)}catch{let n=ed();e=bl(n,a)}a=a||e.version===1?"webgl":"webgl2";let o=e.gl;return me[a]=e,o.isContextLost()?(delete me[a],Rn(a)):(o.disable(o.DEPTH_TEST),o.disable(o.STENCIL_TEST),o.disable(o.BLEND),o.disable(o.DITHER),o.disable(o.POLYGON_OFFSET_FILL),o.disable(o.SAMPLE_COVERAGE),o.enable(o.SCISSOR_TEST),o.enable(o.CULL_FACE),o.cullFace(o.BACK),e)}function bl(a,e){let o={alpha:!1,depth:!1,antialias:!1,stencil:!1,preserveDrawingBuffer:!1,premultipliedAlpha:!1,failIfMajorPerformanceCaveat:!1},t,n=o;if((!e||e==="webgl2")&&(t=a.getContext("webgl2",n),t))try{return new ke(t,2)}catch(r){M.warning("GlContextFactory",`failed to create WebGLContext using contextId 'webgl2'. Error: ${r}`)}if((!e||e==="webgl")&&(t=a.getContext("webgl",n)||a.getContext("experimental-webgl",n),t))try{return new ke(t,1)}catch(r){M.warning("GlContextFactory",`failed to create WebGLContext using contextId 'webgl' or 'experimental-webgl'. Error: ${r}`)}throw new Error("WebGL is not supported")}function ed(){if(typeof document>"u")throw new TypeError("failed to create canvas: document is not supported");let a=document.createElement("canvas");return a.width=1,a.height=1,a}function rd(){if(typeof OffscreenCanvas>"u")throw new TypeError("failed to create offscreen canvas: OffscreenCanvas is not supported");return new OffscreenCanvas(1,1)}var me,yl=x(()=>{"use strict";pt();ml();me={}});var Ar,gl=x(()=>{"use strict";Ft();pt();hl();yl();Ar=class{get contextId(){return j.webgl.contextId}set contextId(e){j.webgl.contextId=e}get matmulMaxBatchSize(){return j.webgl.matmulMaxBatchSize}set matmulMaxBatchSize(e){j.webgl.matmulMaxBatchSize=e}get textureCacheMode(){return j.webgl.textureCacheMode}set textureCacheMode(e){j.webgl.textureCacheMode=e}get pack(){return j.webgl.pack}set pack(e){j.webgl.pack=e}get async(){return j.webgl.async}set async(e){j.webgl.async=e}initialize(){try{return this.glContext=Rn(this.contextId),typeof this.matmulMaxBatchSize!="number"&&(this.matmulMaxBatchSize=16),typeof this.textureCacheMode!="string"&&(this.textureCacheMode="full"),typeof this.pack!="boolean"&&(this.pack=!1),typeof this.async!="boolean"&&(this.async=!1),M.setWithEnv(j),j.webgl.context||Object.defineProperty(j.webgl,"context",{value:this.glContext.gl}),M.verbose("WebGLBackend",`Created WebGLContext: ${typeof this.glContext} with matmulMaxBatchSize: ${this.matmulMaxBatchSize}; textureCacheMode: ${this.textureCacheMode}; pack: ${this.pack}; async: ${this.async}.`),!0}catch(e){return M.warning("WebGLBackend",`Unable to initialize WebGLBackend. ${e}`),!1}}createSessionHandler(e){return new Sr(this,e)}dispose(){this.glContext.dispose()}}});async function Vn(a){if(a){let e=typeof a=="string"?[a]:a;for(let o of e){let t=xl.get(o);if(t)return t;let n=await od(o);if(n)return n}}else return Vn(["webgl"]);throw new Error("no available backend to use")}async function od(a){let e=nd;if(typeof e[a]<"u"&&id(e[a])){let o=e[a],t=o.initialize();if(typeof t=="object"&&"then"in t&&(t=await t),t)return xl.set(a,o),o}}function id(a){let e=a;return"initialize"in e&&typeof e.initialize=="function"&&"createSessionHandler"in e&&typeof e.createSessionHandler=="function"&&"dispose"in e&&typeof e.dispose=="function"}var xl,nd,Tl=x(()=>{"use strict";gl();xl=new Map,nd={webgl:new Ar}});var zn,Or,vl=x(()=>{"use strict";pt();zn=class{constructor(e,o){this.op=e;this.node=o}},Or=class{constructor(e,o,t){this.graph=e;this.profiler=t;this.initialize(o)}initialize(e){this.profiler.event("session","ExecutionPlan.initialize",()=>{let o=this.graph.getNodes();if(o.length!==e.length)throw new Error("The size of nodes and OPs do not match.");this._ops=e.map((t,n)=>new zn(t,o[n])),this.reset(),this._starter=[],this._ops.forEach((t,n)=>{let r=!0;for(let s of t.node.inputs)if(!this._values[s]&&this.graph.getInputIndices().indexOf(s)===-1){r=!1;break}r&&this._starter.push(n)})})}reset(){this._values=this.graph.getValues().map(e=>e.tensor)}async execute(e,o){return this.profiler.event("session","ExecutionPlan.execute",async()=>{this.reset();let t=e.createInferenceHandler(),n=this.graph.getInputIndices();if(o.length!==n.length)throw new Error(`number of input tensors don't match the number of inputs to the model: actual: ${o.length} expected: ${n.length}`);o.forEach((f,p)=>{let d=n[p];this._values[d]=f});let r=this._starter.slice(0),s=this.graph.getValues(),i=this.graph.getNodes(),u=0;for(;u<r.length;){let f=r[u++],p=this._ops[f],d=p.node.inputs.map(v=>this._values[v]);if(d.indexOf(void 0)!==-1)throw new Error(`unresolved input detected: op: ${p.node}`);let b=d;M.verbose("ExecPlan",`Runing op:${p.node.name} (${b.map((v,_)=>`'${p.node.inputs[_]}': ${v.type}[${v.dims.join(",")}]`).join(", ")})`);let g=await this.profiler.event("node",p.node.name,async()=>p.op.impl(t,b,p.op.context));if(g.length!==p.node.outputs.length)throw new Error("the size of output does not match model definition.");g.forEach((v,_)=>{let A=p.node.outputs[_];if(this._values[A])throw new Error(`output [${A}] already has value: op:${p.node.name}`);this._values[A]=v});let y=new Set;g.forEach((v,_)=>{let A=p.node.outputs[_];for(let S of s[A].to){let C=i[S],F=!0;for(let st of C.inputs)if(!this._values[st]){F=!1;break}F&&y.add(S)}}),r.push(...y)}let l=[];for(let f=0;f<this.graph.getOutputIndices().length;f++){let p=this.graph.getOutputIndices()[f],d=this._values[p];if(d===void 0)throw new Error(`required output [${p}] does not have value`);p===0?await d.getData():d.data,l.push(d)}return M.verbose("ExecPlan","disposing of inferenceHandler"),t.dispose(),l})}}});var B,xt,Be,wl=x(()=>{"use strict";ve();B=ne(se());Yt();z();xt=P.experimental.fbs,Be=class a{constructor(e){if(this._attributes=new Map,e!=null){for(let o of e)o instanceof B.onnx.AttributeProto?this._attributes.set(o.name,[a.getValue(o),a.getType(o)]):o instanceof xt.Attribute&&this._attributes.set(o.name(),[a.getValue(o),a.getType(o)]);if(this._attributes.size<e.length)throw new Error("duplicated attribute names")}}set(e,o,t){this._attributes.set(e,[t,o])}delete(e){this._attributes.delete(e)}getFloat(e,o){return this.get(e,"float",o)}getInt(e,o){return this.get(e,"int",o)}getString(e,o){return this.get(e,"string",o)}getTensor(e,o){return this.get(e,"tensor",o)}getFloats(e,o){return this.get(e,"floats",o)}getInts(e,o){return this.get(e,"ints",o)}getStrings(e,o){return this.get(e,"strings",o)}getTensors(e,o){return this.get(e,"tensors",o)}get(e,o,t){let n=this._attributes.get(e);if(n===void 0){if(t!==void 0)return t;throw new Error(`required attribute not found: ${e}`)}if(n[1]!==o)throw new Error(`type mismatch: expected ${o} but got ${n[1]}`);return n[0]}static getType(e){let o=e instanceof B.onnx.AttributeProto?e.type:e.type();switch(o){case B.onnx.AttributeProto.AttributeType.FLOAT:return"float";case B.onnx.AttributeProto.AttributeType.INT:return"int";case B.onnx.AttributeProto.AttributeType.STRING:return"string";case B.onnx.AttributeProto.AttributeType.TENSOR:return"tensor";case B.onnx.AttributeProto.AttributeType.FLOATS:return"floats";case B.onnx.AttributeProto.AttributeType.INTS:return"ints";case B.onnx.AttributeProto.AttributeType.STRINGS:return"strings";case B.onnx.AttributeProto.AttributeType.TENSORS:return"tensors";default:throw new Error(`attribute type is not supported yet: ${B.onnx.AttributeProto.AttributeType[o]}`)}}static getValue(e){let o=e instanceof B.onnx.AttributeProto?e.type:e.type();if(o===B.onnx.AttributeProto.AttributeType.GRAPH||o===B.onnx.AttributeProto.AttributeType.GRAPHS)throw new Error("graph attribute is not supported yet");let t=this.getValueNoCheck(e);if(o===B.onnx.AttributeProto.AttributeType.INT&&ft.isLong(t))return ft.longToNumber(t);if(o===B.onnx.AttributeProto.AttributeType.INTS){let n=t,r=new Array(n.length);for(let s=0;s<n.length;s++){let i=n[s];r[s]=ft.longToNumber(i)}return r}if(o===B.onnx.AttributeProto.AttributeType.TENSOR)return e instanceof B.onnx.AttributeProto?Y.fromProto(t):Y.fromOrtTensor(t);if(o===B.onnx.AttributeProto.AttributeType.TENSORS){if(e instanceof B.onnx.AttributeProto)return t.map(r=>Y.fromProto(r));if(e instanceof xt.Attribute)return t.map(r=>Y.fromOrtTensor(r))}return o===B.onnx.AttributeProto.AttributeType.STRING&&e instanceof B.onnx.AttributeProto?Ae(t):o===B.onnx.AttributeProto.AttributeType.STRINGS&&e instanceof B.onnx.AttributeProto?t.map(Ae):t}static getValueNoCheck(e){return e instanceof B.onnx.AttributeProto?this.getValueNoCheckFromOnnxFormat(e):this.getValueNoCheckFromOrtFormat(e)}static getValueNoCheckFromOnnxFormat(e){switch(e.type){case B.onnx.AttributeProto.AttributeType.FLOAT:return e.f;case B.onnx.AttributeProto.AttributeType.INT:return e.i;case B.onnx.AttributeProto.AttributeType.STRING:return e.s;case B.onnx.AttributeProto.AttributeType.TENSOR:return e.t;case B.onnx.AttributeProto.AttributeType.GRAPH:return e.g;case B.onnx.AttributeProto.AttributeType.FLOATS:return e.floats;case B.onnx.AttributeProto.AttributeType.INTS:return e.ints;case B.onnx.AttributeProto.AttributeType.STRINGS:return e.strings;case B.onnx.AttributeProto.AttributeType.TENSORS:return e.tensors;case B.onnx.AttributeProto.AttributeType.GRAPHS:return e.graphs;default:throw new Error(`unsupported attribute type: ${B.onnx.AttributeProto.AttributeType[e.type]}`)}}static getValueNoCheckFromOrtFormat(e){switch(e.type()){case xt.AttributeType.FLOAT:return e.f();case xt.AttributeType.INT:return e.i();case xt.AttributeType.STRING:return e.s();case xt.AttributeType.TENSOR:return e.t();case xt.AttributeType.GRAPH:return e.g();case xt.AttributeType.FLOATS:return e.floatsArray();case xt.AttributeType.INTS:{let o=[];for(let t=0;t<e.intsLength();t++)o.push(e.ints(t));return o}case xt.AttributeType.STRINGS:{let o=[];for(let t=0;t<e.stringsLength();t++)o.push(e.strings(t));return o}case xt.AttributeType.TENSORS:{let o=[];for(let t=0;t<e.tensorsLength();t++)o.push(e.tensors(t));return o}default:throw new Error(`unsupported attribute type: ${xt.AttributeType[e.type()]}`)}}}});var Un,Pr,Wn,Lt,Er,Mn,Il=x(()=>{"use strict";wl();ve();Un=ne(se());Yt();z();Pr=P.experimental.fbs,Wn={from:(a,e)=>new Mn(a,e)},Lt=class{constructor(e){this._from=void 0,this._to=[],this.tensor=void 0,this.type=void 0,e&&(this.type=et.tensorValueTypeFromProto(e.type.tensorType))}get from(){return this._from}get to(){return this._to}},Er=class{constructor(e,o){e instanceof Un.onnx.NodeProto?(this.name=e.name,this.opType=e.opType,this.attributes=new Be(e.attribute)):e instanceof Pr.Node&&(this.name=o??e.name(),this.opType=e.opType(),this.attributes=new Be(et.tensorAttributesFromORTFormat(e))),this.inputs=[],this.outputs=[],this.executeNode=!0}},Mn=class{constructor(e,o){if(!e)throw new TypeError("graph is empty");this.buildGraph(e),this.transformGraph(o),this.checkIsAcyclic()}getInputIndices(){return this._allInputIndices}getInputNames(){return this._allInputNames}getOutputIndices(){return this._allOutputIndices}getOutputNames(){return this._allOutputNames}getValues(){return this._allData}getNodes(){return this._nodes}buildGraph(e){if(e instanceof Un.onnx.GraphProto)this.buildGraphFromOnnxFormat(e);else if(e instanceof Pr.Graph)this.buildGraphFromOrtFormat(e);else throw new TypeError("Graph type is not supported.")}buildGraphFromOnnxFormat(e){let o=new Map;this._allData=[],this._allInputIndices=[],this._allInputNames=[],this._allOutputIndices=[],this._allOutputNames=[],this._nodes=[];let t=new Map;if(!e.input)throw new Error("missing information in graph: input");let n=[];for(let r of e.input){if(o.has(r.name))throw new Error(`duplicated input name: ${r.name}`);let s=this._allData.push(new Lt(r))-1;o.set(r.name,s),n.push(r.name)}if(!e.initializer)throw new Error("missing information in graph: initializer");for(let r of e.initializer){let s=o.get(r.name);if(s===void 0){let i=new Lt;i.type={shape:{dims:et.tensorDimsFromProto(r.dims)},tensorType:et.tensorDataTypeFromProto(r.dataType)},s=this._allData.push(i)-1,o.set(r.name,s)}this._allData[s]._from=-1,this._allData[s].tensor=Y.fromProto(r)}for(let r=0;r<this._allData.length;r++)this._allData[r].tensor||(this._allInputIndices.push(r),this._allInputNames.push(n[r]));if(!e.output)throw new Error("missing information in graph: output");for(let r of e.output){if(o.has(r.name))throw new Error(`duplicated output name: ${r.name}`);let s=this._allData.push(new Lt(r))-1;o.set(r.name,s),this._allOutputIndices.push(s),this._allOutputNames.push(r.name)}if(!e.node)throw new Error("missing information in graph: node");for(let r of e.node){if(!r.name)for(let i=0;;i++){let u=`unnamed_${r.opType}_${i}`;if(!t.has(u)){r.name=u;break}}if(t.has(r.name))throw new Error(`duplicated node name: ${r.name}`);let s=this._nodes.push(new Er(r))-1;t.set(r.name,s)}for(let r=0;r<this._nodes.length;r++){let s=this._nodes[r],i=e.node[r];if(!i.output)throw new Error(`missing output for node: ${i.name}`);for(let u of i.output){let l=o.get(u);if(typeof l>"u"&&(l=this._allData.push(new Lt)-1,o.set(u,l)),s.outputs.push(l),this._allData[l]._from!==void 0)throw new Error(`multiple nodes output to one data value: ${l}`);if(this._allData[l]._from=r,i.opType==="Constant"){if(!i.attribute||i.attribute.length!==1||!i.attribute[0].t)throw new Error("missing attributes or missing tensor value in attributes for this Constant operator");if(!i.output||i.output.length!==1)throw new Error("missing output or incorrect number of outputs for this Constant operator");s.outputs.pop(),s.executeNode=!1,this._allData[l]._from=-1,this._allData[l].tensor=Y.fromProto(i.attribute[0].t)}}}for(let r=0;r<this._nodes.length;r++){let s=this._nodes[r],i=e.node[r];if(!i.input)throw new Error(`missing input for node: ${i.name}`);for(let u of i.input){let l=o.get(u);if(typeof l>"u"){if(u===""&&(i.input.length===3||i.input.length===4)&&i.opType==="Resize")continue;throw new Error(`unrecognized input '${u}' for node: ${i.name}`)}s.inputs.push(l),this._allData[l]._to.push(r)}}return!0}buildGraphFromOrtFormat(e){let o=new Map;this._allData=[],this._allInputIndices=[],this._allInputNames=[],this._allOutputIndices=[],this._allOutputNames=[],this._nodes=[];let t=new Map,n=[];for(let r=0;r<e.inputsLength();r++){let s=e.inputs(r);if(o.has(s))throw new Error(`duplicated input name: ${s}`);for(let i=0;i<e.nodeArgsLength();i++)if(e.nodeArgs(i)?.name()===s){let u=new Lt;if(e.nodeArgs(i)?.type()?.valueType()!==Pr.TypeInfoValue.tensor_type)throw new Error("Unexpected value type for the nodeArg.");let f=e.nodeArgs(i).type().value(new Pr.TensorTypeAndShape),p=et.tensorDataTypeFromProto(f.elemType()),d=f.shape(),b=[];for(let y=0;y<d.dimLength();y++)b.push(ft.longToNumber(d.dim(y).value().dimValue()));u.type={shape:{dims:b},tensorType:p};let g=this._allData.push(u)-1;o.set(s,g),n.push(s)}}for(let r=0;r<e.initializersLength();r++){let s=e.initializers(r),i=o.get(s.name());if(i===void 0){let u=new Lt,l=et.tensorDimsFromORTFormat(s),f=et.tensorDataTypeFromProto(s.dataType());u.type={shape:{dims:l},tensorType:f},i=this._allData.push(u)-1,o.set(s.name(),i)}this._allData[i]._from=-1,this._allData[i].tensor=Y.fromOrtTensor(s)}for(let r=0;r<this._allData.length;r++)this._allData[r].tensor||(this._allInputIndices.push(r),this._allInputNames.push(n[r]));for(let r=0;r<e.outputsLength();r++){let s=e.outputs(r);if(o.has(s))throw new Error(`duplicated output name: ${s}`);let i=this._allData.push(new Lt)-1;o.set(s,i),this._allOutputIndices.push(i),this._allOutputNames.push(s)}if(!e.nodes)throw new Error("missing information in graph: node");for(let r=0;r<e.nodesLength();r++){let s=e.nodes(r),i=s.name();if(!i)for(let l=0;i=`unnamed_${s.opType()}_${l}`,!!t.has(i);l++);if(t.has(i))throw new Error(`duplicated node name: ${i}`);let u=this._nodes.push(new Er(s,i))-1;t.set(i,u)}for(let r=0;r<this._nodes.length;r++){let s=this._nodes[r],i=e.nodes(r);if(i==null)throw new Error(`No node exists at index ${r}`);if(i?.outputsLength()===0)throw new Error(`missing output for node: ${i.name}`);for(let u=0;u<i?.outputsLength();u++){let l=i?.outputs(u),f=o.get(l);if(typeof f>"u"&&(f=this._allData.push(new Lt)-1,o.set(l,f)),s.outputs.push(f),this._allData[f]._from!==void 0)throw new Error(`multiple nodes output to one data value: ${f}`);if(this._allData[f]._from=r,i.opType()==="Constant"){if(i.attributesLength()!==1||!i.attributes(0).t())throw new Error("missing attributes or missing tensor value in attributes for this Constant operator");if(i.outputsLength()!==1)throw new Error("missing output or incorrect number of outputs for this Constant operator");s.outputs.pop(),s.executeNode=!1,this._allData[f]._from=-1,this._allData[f].tensor=Y.fromOrtTensor(i.attributes(0).t())}}}for(let r=0;r<this._nodes.length;r++){let s=this._nodes[r],i=e.nodes(r);if(i.inputsLength()===0)throw new Error(`missing input for node: ${i.name}`);for(let u=0;u<i.inputsLength();u++){let l=i.inputs(u),f=o.get(l);if(typeof f>"u")throw new Error(`unrecognized input '${l}' for node: ${i.name()}`);s.inputs.push(f),this._allData[f]._to.push(r)}}}checkIsAcyclic(){let e=new Set;this._allInputIndices.forEach(n=>{this._allData[n]._to.forEach(s=>{e.add(s)})});let o=Array.from(e),t=new Array(this._nodes.length).fill("white");for(;o.length>0;){let n=o.pop();t[n]==="gray"?t[n]="black":(o.push(n),t[n]="gray",this._nodes[n].outputs.forEach(r=>{let s=this._allData[r];if(typeof s.tensor<"u")throw new Error("node outputs should not be initialized");if(s._from!==n)throw new Error("from property of the Value object doesn't match index of Node being processed");s._to.forEach(i=>{if(t[i]==="gray")throw new Error("model graph is cyclic");t[i]==="white"&&o.push(i)})}))}}transformGraph(e){this.removeAllIdentityNodes(),this.removeAllDropoutNodes(),this.fuseConvActivationNodes(),e&&e.transformGraph(this),this.finalizeGraph()}finalizeGraph(){let e=0,o=new Array(this._nodes.length,0),t=0;for(let n=0;n<this._nodes.length;n++)o[n]=t,this._nodes[n].executeNode?(t!==n&&(this._nodes[t]=this._nodes[n]),t++):this._nodes[n].outputs.forEach(r=>{this._allData[r]._from=-2});this._nodes.splice(t,this._nodes.length-t);for(let n=0;n<this._allData.length;n++){let r=this._allData[n];r._from!==void 0&&r._from!==-1&&r._from!==-2&&(r._from=o[r._from]);for(let s=0;s<r._to.length;s++)if(r._to[s]>=0)r._to[s]=o[r._to[s]];else throw new Error("Trying to update a removed node")}e=0;for(let n=0;n<this._allData.length;n++){if(this._allData[n].from===-2&&this._allOutputIndices.indexOf(n+e)===-1){e++,this._allData.splice(n,1),n--;continue}if(e>0){let r=-1;this._allData[n].from!==void 0&&this._allData[n].from!==-1?(r=this._nodes[this._allData[n].from].outputs.indexOf(n+e),r!==-1&&(this._nodes[this._allData[n].from].outputs[r]=n)):(r=this._allInputIndices.indexOf(n+e),r!==-1&&(this._allInputIndices[r]=n)),this._allData[n].to.forEach(s=>{r=this._nodes[s].inputs.indexOf(n+e),r!==-1&&(this._nodes[s].inputs[r]=n)}),this._allData[n].to.length===0&&(r=this._allOutputIndices.indexOf(n+e),r!==-1&&(this._allOutputIndices[r]=n))}}}deleteNode(e){let o=this._nodes[e];if(o.outputs.length>1){for(let i=1;i<o.outputs.length;i++)if(this._allData[o.outputs[i]].to.length>0)throw new Error("Node deletion with more than one output connected to other nodes is not supported. ")}o.executeNode=!1;let t=o.inputs[0],n=o.outputs[0],r=this._allData[n].to;for(let i=0;i<o.inputs.length;i++){let u=this._allData[o.inputs[i]].to.indexOf(e);if(u===-1)throw new Error("The Value object doesn't have the current Node in it's 'to' property ");this._allData[o.inputs[i]].to.splice(u,1)}this._allData[n]._to=[];let s=this._allOutputIndices.indexOf(n);if(s!==-1&&(this._allOutputIndices[s]=t),r&&r.length>0)for(let i of r){let u=this._nodes[i].inputs.indexOf(n);if(u===-1)throw new Error("The Node object doesn't have the output Value in it's 'inputs' property ");this._nodes[i].inputs[u]=t,this._allData[t].to.push(i)}}removeAllDropoutNodes(){let e=0;for(let o of this._nodes){if(o.opType==="Dropout"){if(o.inputs.length!==1)throw new Error("Dropout nodes should only contain one input. ");if(o.outputs.length!==1&&o.outputs.length!==2)throw new Error("Dropout nodes should contain either 1 or 2 output(s)");if(o.outputs.length===2&&this._allData[o.outputs[1]]._to.length!==0)throw new Error("Dropout nodes's second output should not be referenced by other nodes");this.deleteNode(e)}e++}}removeAllIdentityNodes(){let e=0;for(let o of this._nodes)o.opType==="Identity"&&this.deleteNode(e),e++}isActivation(e){switch(e.opType){case"Relu":case"Sigmoid":case"Clip":return!0;default:return!1}}fuseConvActivationNodes(){for(let e of this._nodes)if(e.opType==="Conv"){let o=this._allData[e.outputs[0]]._to;if(o.length===1&&this.isActivation(this._nodes[o[0]])){let t=this._nodes[o[0]];if(t.opType==="Clip")if(t.inputs.length===1)try{e.attributes.set("activation_params","floats",[t.attributes.getFloat("min"),t.attributes.getFloat("max")])}catch{e.attributes.set("activation_params","floats",[Jt,Zt])}else if(t.inputs.length>=3&&this._allData[t.inputs[1]].tensor!==void 0&&this._allData[t.inputs[2]].tensor!==void 0)e.attributes.set("activation_params","floats",[this._allData[t.inputs[1]].tensor.floatData[0],this._allData[t.inputs[2]].tensor.floatData[0]]);else continue;e.attributes.set("activation","string",t.opType),this.deleteNode(o[0])}}}}});var _l,ad,Dr,Sl=x(()=>{"use strict";Je();Il();ve();_l=ne(se());z();ad=P.experimental.fbs,Dr=class{constructor(){}load(e,o,t){let n;if(!t)try{this.loadFromOnnxFormat(e,o);return}catch(r){if(t!==void 0)throw r;n=r}try{this.loadFromOrtFormat(e,o)}catch(r){throw t!==void 0?r:new Error(`Failed to load model as ONNX format: ${n}
as ORT format: ${r}`)}}loadFromOnnxFormat(e,o){let t=_l.onnx.ModelProto.decode(e);if(ft.longToNumber(t.irVersion)<3)throw new Error("only support ONNX model with IR_VERSION>=3");this._opsets=t.opsetImport.map(r=>({domain:r.domain,version:ft.longToNumber(r.version)})),this._graph=Wn.from(t.graph,o)}loadFromOrtFormat(e,o){let t=new m.ByteBuffer(e),n=ad.InferenceSession.getRootAsInferenceSession(t).model();if(ft.longToNumber(n.irVersion())<3)throw new Error("only support ONNX model with IR_VERSION>=3");this._opsets=[];for(let s=0;s<n.opsetImportLength();s++){let i=n.opsetImport(s);this._opsets.push({domain:i?.domain(),version:ft.longToNumber(i.version())})}this._graph=Wn.from(n.graph(),o)}get graph(){return this._graph}get opsets(){return this._opsets}}});var Lr,Al=x(()=>{"use strict";Tl();vl();pt();Sl();Lr=class{constructor(e={}){this._initialized=!1,this.backendHint=e.backendHint,this.profiler=Ke.create(e.profiler),this.context={profiler:this.profiler,graphInputTypes:[],graphInputDims:[]}}get inputNames(){return this._model.graph.getInputNames()}get outputNames(){return this._model.graph.getOutputNames()}startProfiling(){this.profiler.start()}endProfiling(){this.profiler.stop()}async loadModel(e,o,t){await this.profiler.event("session","Session.loadModel",async()=>{let n=await Vn(this.backendHint);if(this.sessionHandler=n.createSessionHandler(this.context),this._model=new Dr,typeof e=="string"){let r=e.endsWith(".ort");if(typeof process<"u"&&process.versions&&process.versions.node){let s=await(void 0)(e);this.initialize(s,r)}else{let i=await(await fetch(e)).arrayBuffer();this.initialize(new Uint8Array(i),r)}}else if(ArrayBuffer.isView(e))this.initialize(e);else{let r=new Uint8Array(e,o||0,t||e.byteLength);this.initialize(r)}})}initialize(e,o){if(this._initialized)throw new Error("already initialized");this.profiler.event("session","Session.initialize",()=>{let t=this.sessionHandler.transformGraph?this.sessionHandler:void 0;this._model.load(e,t,o),this.sessionHandler.onGraphInitialized&&this.sessionHandler.onGraphInitialized(this._model.graph),this.initializeOps(this._model.graph),this._executionPlan=new Or(this._model.graph,this._ops,this.profiler)}),this._initialized=!0}async run(e){if(!this._initialized)throw new Error("session not initialized yet");return this.profiler.event("session","Session.run",async()=>{let o=this.normalizeAndValidateInputs(e),t=await this._executionPlan.execute(this.sessionHandler,o);return this.createOutput(t)})}normalizeAndValidateInputs(e){let o=this._model.graph.getInputNames();if(Array.isArray(e)){if(e.length!==o.length)throw new Error(`incorrect input array length: expected ${o.length} but got ${e.length}`)}else{if(e.size!==o.length)throw new Error(`incorrect input map size: expected ${o.length} but got ${e.size}`);let t=new Array(e.size),n=0;for(let r=0;r<o.length;++r){let s=e.get(o[r]);if(!s)throw new Error(`missing input tensor for: '${name}'`);t[n++]=s}e=t}if(!this.context.graphInputTypes||this.context.graphInputTypes.length===0||!this.context.graphInputDims||this.context.graphInputDims.length===0){let t=this._model.graph.getInputIndices(),n=this._model.graph.getValues(),r=new Array(t.length);for(let s=0;s<t.length;++s){let i=n[t[s]];r[s]=i.type.shape.dims,this.context.graphInputTypes.push(i.type.tensorType),this.context.graphInputDims.push(e[s].dims)}this.validateInputTensorDims(r,e,!0)}else this.validateInputTensorDims(this.context.graphInputDims,e,!1);return this.validateInputTensorTypes(this.context.graphInputTypes,e),e}validateInputTensorTypes(e,o){for(let t=0;t<o.length;t++){let n=e[t],r=o[t].type;if(n!==r)throw new Error(`input tensor[${t}] check failed: expected type '${n}' but got ${r}`)}}validateInputTensorDims(e,o,t){for(let n=0;n<o.length;n++){let r=e[n],s=o[n].dims;if(!this.compareTensorDims(r,s,t))throw new Error(`input tensor[${n}] check failed: expected shape '[${r.join(",")}]' but got [${s.join(",")}]`)}}compareTensorDims(e,o,t){if(e.length!==o.length)return!1;for(let n=0;n<e.length;++n)if(e[n]!==o[n]&&(!t||e[n]!==0))return!1;return!0}createOutput(e){let o=this._model.graph.getOutputNames();if(e.length!==o.length)throw new Error("expected number of outputs do not match number of generated outputs");let t=new Map;for(let n=0;n<o.length;++n)t.set(o[n],e[n]);return t}initializeOps(e){let o=e.getNodes();this._ops=new Array(o.length);for(let t=0;t<o.length;t++)this._ops[t]=this.sessionHandler.resolve(o[t],this._model.opsets,e)}}});var $r,Ol=x(()=>{"use strict";Ft();Yt();$r=class{constructor(e){this.session=e;this.inputNames=this.session.inputNames,this.outputNames=this.session.outputNames}async dispose(){}async run(e,o,t){let n=new Map;for(let i in e)if(Object.hasOwnProperty.call(e,i)){let u=e[i];n.set(i,new Y(u.dims,u.type,void 0,void 0,u.data))}let r=await this.session.run(n),s={};return r.forEach((i,u)=>{s[u]=new rt(i.type,i.data,i.dims)}),s}startProfiling(){this.session.startProfiling()}endProfiling(){this.session.endProfiling()}}});var Pl={};Br(Pl,{onnxjsBackend:()=>sd});var Hn,sd,El=x(()=>{"use strict";Al();Ol();Hn=class{async init(){}async createInferenceSessionHandler(e,o){let t=new Lr(o);return typeof e=="string"?await t.loadModel(e):await t.loadModel(e),new $r(t)}},sd=new Hn});var ld={};Br(ld,{InferenceSession:()=>bo,TRACE:()=>Cr,TRACE_FUNC_BEGIN:()=>ge,TRACE_FUNC_END:()=>xe,Tensor:()=>rt,TrainingSession:()=>Io,default:()=>ud,env:()=>j,registerBackend:()=>be});Ft();Ft();Ft();var So="1.18.0";var ud=Rr;{let a=(El(),jn(Pl)).onnxjsBackend;be("webgl",a,-10)}Object.defineProperty(j.versions,"web",{value:So,enumerable:!0});return jn(ld);})();
/*! Bundled license information:

long/index.js:
  (**
   * @license
   * Copyright 2009 The Closure Library Authors
   * Copyright 2020 Daniel Wirtz / The long.js Authors.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   *)
*/
//# sourceMappingURL=ort.webgl.min.js.map
