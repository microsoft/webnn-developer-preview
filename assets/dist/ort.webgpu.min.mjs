/*!
 * ONNX Runtime Web v1.23.0-dev.20250911-930e64086c
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
var tt=Object.defineProperty;var Jr=Object.getOwnPropertyDescriptor;var Yr=Object.getOwnPropertyNames;var qr=Object.prototype.hasOwnProperty;var rt=(t=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(t,{get:(e,r)=>(typeof require<"u"?require:e)[r]}):t)(function(t){if(typeof require<"u")return require.apply(this,arguments);throw Error('Dynamic require of "'+t+'" is not supported')});var T=(t,e)=>()=>(t&&(e=t(t=0)),e);var Le=(t,e)=>{for(var r in e)tt(t,r,{get:e[r],enumerable:!0})},Xr=(t,e,r,o)=>{if(e&&typeof e=="object"||typeof e=="function")for(let n of Yr(e))!qr.call(t,n)&&n!==r&&tt(t,n,{get:()=>e[n],enumerable:!(o=Jr(e,n))||o.enumerable});return t};var nt=t=>Xr(tt({},"__esModule",{value:!0}),t);var Ae,re,ne,Zr,xt,ot=T(()=>{"use strict";Ae=new Map,re=[],ne=(t,e,r)=>{if(e&&typeof e.init=="function"&&typeof e.createInferenceSessionHandler=="function"){let o=Ae.get(t);if(o===void 0)Ae.set(t,{backend:e,priority:r});else{if(o.priority>r)return;if(o.priority===r&&o.backend!==e)throw new Error(`cannot register backend "${t}" using priority ${r}`)}if(r>=0){let n=re.indexOf(t);n!==-1&&re.splice(n,1);for(let s=0;s<re.length;s++)if(Ae.get(re[s]).priority<=r){re.splice(s,0,t);return}re.push(t)}return}throw new TypeError("not a valid backend")},Zr=async t=>{let e=Ae.get(t);if(!e)return"backend not found.";if(e.initialized)return e.backend;if(e.aborted)return e.error;{let r=!!e.initPromise;try{return r||(e.initPromise=e.backend.init(t)),await e.initPromise,e.initialized=!0,e.backend}catch(o){return r||(e.error=`${o}`,e.aborted=!0),e.error}finally{delete e.initPromise}}},xt=async t=>{let e=t.executionProviders||[],r=e.map(u=>typeof u=="string"?u:u.name),o=r.length===0?re:r,n,s=[],a=new Set;for(let u of o){let f=await Zr(u);typeof f=="string"?s.push({name:u,err:f}):(n||(n=f),n===f&&a.add(u))}if(!n)throw new Error(`no available backend found. ERR: ${s.map(u=>`[${u.name}] ${u.err}`).join(", ")}`);for(let{name:u,err:f}of s)r.includes(u)&&console.warn(`removing requested execution provider "${u}" from session options because it is not available: ${f}`);let i=e.filter(u=>a.has(typeof u=="string"?u:u.name));return[n,new Proxy(t,{get:(u,f)=>f==="executionProviders"?i:Reflect.get(u,f)})]}});var Ot=T(()=>{"use strict";ot()});var Bt,Ut=T(()=>{"use strict";Bt="1.23.0"});var Dt,U,st=T(()=>{"use strict";Ut();Dt="warning",U={wasm:{},webgl:{},webgpu:{},versions:{common:Bt},set logLevel(t){if(t!==void 0){if(typeof t!="string"||["verbose","info","warning","error","fatal"].indexOf(t)===-1)throw new Error(`Unsupported logging level: ${t}`);Dt=t}},get logLevel(){return Dt}};Object.defineProperty(U,"logLevel",{enumerable:!0})});var v,Ct=T(()=>{"use strict";st();v=U});var Pt,_t,Rt=T(()=>{"use strict";Pt=(t,e)=>{let r=typeof document<"u"?document.createElement("canvas"):new OffscreenCanvas(1,1);r.width=t.dims[3],r.height=t.dims[2];let o=r.getContext("2d");if(o!=null){let n,s;e?.tensorLayout!==void 0&&e.tensorLayout==="NHWC"?(n=t.dims[2],s=t.dims[3]):(n=t.dims[3],s=t.dims[2]);let a=e?.format!==void 0?e.format:"RGB",i=e?.norm,u,f;i===void 0||i.mean===void 0?u=[255,255,255,255]:typeof i.mean=="number"?u=[i.mean,i.mean,i.mean,i.mean]:(u=[i.mean[0],i.mean[1],i.mean[2],0],i.mean[3]!==void 0&&(u[3]=i.mean[3])),i===void 0||i.bias===void 0?f=[0,0,0,0]:typeof i.bias=="number"?f=[i.bias,i.bias,i.bias,i.bias]:(f=[i.bias[0],i.bias[1],i.bias[2],0],i.bias[3]!==void 0&&(f[3]=i.bias[3]));let c=s*n,l=0,d=c,p=c*2,y=-1;a==="RGBA"?(l=0,d=c,p=c*2,y=c*3):a==="RGB"?(l=0,d=c,p=c*2):a==="RBG"&&(l=0,p=c,d=c*2);for(let g=0;g<s;g++)for(let L=0;L<n;L++){let h=(t.data[l++]-f[0])*u[0],m=(t.data[d++]-f[1])*u[1],A=(t.data[p++]-f[2])*u[2],w=y===-1?255:(t.data[y++]-f[3])*u[3];o.fillStyle="rgba("+h+","+m+","+A+","+w+")",o.fillRect(L,g,1,1)}if("toDataURL"in r)return r.toDataURL();throw new Error("toDataURL is not supported")}else throw new Error("Can not access image data")},_t=(t,e)=>{let r=typeof document<"u"?document.createElement("canvas").getContext("2d"):new OffscreenCanvas(1,1).getContext("2d"),o;if(r!=null){let n,s,a;e?.tensorLayout!==void 0&&e.tensorLayout==="NHWC"?(n=t.dims[2],s=t.dims[1],a=t.dims[3]):(n=t.dims[3],s=t.dims[2],a=t.dims[1]);let i=e!==void 0&&e.format!==void 0?e.format:"RGB",u=e?.norm,f,c;u===void 0||u.mean===void 0?f=[255,255,255,255]:typeof u.mean=="number"?f=[u.mean,u.mean,u.mean,u.mean]:(f=[u.mean[0],u.mean[1],u.mean[2],255],u.mean[3]!==void 0&&(f[3]=u.mean[3])),u===void 0||u.bias===void 0?c=[0,0,0,0]:typeof u.bias=="number"?c=[u.bias,u.bias,u.bias,u.bias]:(c=[u.bias[0],u.bias[1],u.bias[2],0],u.bias[3]!==void 0&&(c[3]=u.bias[3]));let l=s*n;if(e!==void 0&&(e.format!==void 0&&a===4&&e.format!=="RGBA"||a===3&&e.format!=="RGB"&&e.format!=="BGR"))throw new Error("Tensor format doesn't match input tensor dims");let d=4,p=0,y=1,g=2,L=3,h=0,m=l,A=l*2,w=-1;i==="RGBA"?(h=0,m=l,A=l*2,w=l*3):i==="RGB"?(h=0,m=l,A=l*2):i==="RBG"&&(h=0,A=l,m=l*2),o=r.createImageData(n,s);for(let I=0;I<s*n;p+=d,y+=d,g+=d,L+=d,I++)o.data[p]=(t.data[h++]-c[0])*f[0],o.data[y]=(t.data[m++]-c[1])*f[1],o.data[g]=(t.data[A++]-c[2])*f[2],o.data[L]=w===-1?255:(t.data[w++]-c[3])*f[3]}else throw new Error("Can not access image data");return o}});var at,Nt,Ft,Wt,kt,Gt,$t=T(()=>{"use strict";ve();at=(t,e)=>{if(t===void 0)throw new Error("Image buffer must be defined");if(e.height===void 0||e.width===void 0)throw new Error("Image height and width must be defined");if(e.tensorLayout==="NHWC")throw new Error("NHWC Tensor layout is not supported yet");let{height:r,width:o}=e,n=e.norm??{mean:255,bias:0},s,a;typeof n.mean=="number"?s=[n.mean,n.mean,n.mean,n.mean]:s=[n.mean[0],n.mean[1],n.mean[2],n.mean[3]??255],typeof n.bias=="number"?a=[n.bias,n.bias,n.bias,n.bias]:a=[n.bias[0],n.bias[1],n.bias[2],n.bias[3]??0];let i=e.format!==void 0?e.format:"RGBA",u=e.tensorFormat!==void 0&&e.tensorFormat!==void 0?e.tensorFormat:"RGB",f=r*o,c=u==="RGBA"?new Float32Array(f*4):new Float32Array(f*3),l=4,d=0,p=1,y=2,g=3,L=0,h=f,m=f*2,A=-1;i==="RGB"&&(l=3,d=0,p=1,y=2,g=-1),u==="RGBA"?A=f*3:u==="RBG"?(L=0,m=f,h=f*2):u==="BGR"&&(m=0,h=f,L=f*2);for(let I=0;I<f;I++,d+=l,y+=l,p+=l,g+=l)c[L++]=(t[d]+a[0])/s[0],c[h++]=(t[p]+a[1])/s[1],c[m++]=(t[y]+a[2])/s[2],A!==-1&&g!==-1&&(c[A++]=(t[g]+a[3])/s[3]);return u==="RGBA"?new _("float32",c,[1,4,r,o]):new _("float32",c,[1,3,r,o])},Nt=async(t,e)=>{let r=typeof HTMLImageElement<"u"&&t instanceof HTMLImageElement,o=typeof ImageData<"u"&&t instanceof ImageData,n=typeof ImageBitmap<"u"&&t instanceof ImageBitmap,s=typeof t=="string",a,i=e??{},u=()=>{if(typeof document<"u")return document.createElement("canvas");if(typeof OffscreenCanvas<"u")return new OffscreenCanvas(1,1);throw new Error("Canvas is not supported")},f=c=>typeof HTMLCanvasElement<"u"&&c instanceof HTMLCanvasElement||c instanceof OffscreenCanvas?c.getContext("2d"):null;if(r){let c=u();c.width=t.width,c.height=t.height;let l=f(c);if(l!=null){let d=t.height,p=t.width;if(e!==void 0&&e.resizedHeight!==void 0&&e.resizedWidth!==void 0&&(d=e.resizedHeight,p=e.resizedWidth),e!==void 0){if(i=e,e.tensorFormat!==void 0)throw new Error("Image input config format must be RGBA for HTMLImageElement");i.tensorFormat="RGBA",i.height=d,i.width=p}else i.tensorFormat="RGBA",i.height=d,i.width=p;l.drawImage(t,0,0),a=l.getImageData(0,0,p,d).data}else throw new Error("Can not access image data")}else if(o){let c,l;if(e!==void 0&&e.resizedWidth!==void 0&&e.resizedHeight!==void 0?(c=e.resizedHeight,l=e.resizedWidth):(c=t.height,l=t.width),e!==void 0&&(i=e),i.format="RGBA",i.height=c,i.width=l,e!==void 0){let d=u();d.width=l,d.height=c;let p=f(d);if(p!=null)p.putImageData(t,0,0),a=p.getImageData(0,0,l,c).data;else throw new Error("Can not access image data")}else a=t.data}else if(n){if(e===void 0)throw new Error("Please provide image config with format for Imagebitmap");let c=u();c.width=t.width,c.height=t.height;let l=f(c);if(l!=null){let d=t.height,p=t.width;return l.drawImage(t,0,0,p,d),a=l.getImageData(0,0,p,d).data,i.height=d,i.width=p,at(a,i)}else throw new Error("Can not access image data")}else{if(s)return new Promise((c,l)=>{let d=u(),p=f(d);if(!t||!p)return l();let y=new Image;y.crossOrigin="Anonymous",y.src=t,y.onload=()=>{d.width=y.width,d.height=y.height,p.drawImage(y,0,0,d.width,d.height);let g=p.getImageData(0,0,d.width,d.height);i.height=d.height,i.width=d.width,c(at(g.data,i))}});throw new Error("Input data provided is not supported - aborted tensor creation")}if(a!==void 0)return at(a,i);throw new Error("Input data provided is not supported - aborted tensor creation")},Ft=(t,e)=>{let{width:r,height:o,download:n,dispose:s}=e,a=[1,o,r,4];return new _({location:"texture",type:"float32",texture:t,dims:a,download:n,dispose:s})},Wt=(t,e)=>{let{dataType:r,dims:o,download:n,dispose:s}=e;return new _({location:"gpu-buffer",type:r??"float32",gpuBuffer:t,dims:o,download:n,dispose:s})},kt=(t,e)=>{let{dataType:r,dims:o,download:n,dispose:s}=e;return new _({location:"ml-tensor",type:r??"float32",mlTensor:t,dims:o,download:n,dispose:s})},Gt=(t,e,r)=>new _({location:"cpu-pinned",type:t,data:e,dims:r??[e.length]})});var oe,we,zt,Vt,Ht=T(()=>{"use strict";oe=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array],["int4",Uint8Array],["uint4",Uint8Array]]),we=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]),zt=!1,Vt=()=>{if(!zt){zt=!0;let t=typeof BigInt64Array<"u"&&BigInt64Array.from,e=typeof BigUint64Array<"u"&&BigUint64Array.from,r=globalThis.Float16Array,o=typeof r<"u"&&r.from;t&&(oe.set("int64",BigInt64Array),we.set(BigInt64Array,"int64")),e&&(oe.set("uint64",BigUint64Array),we.set(BigUint64Array,"uint64")),o?(oe.set("float16",r),we.set(r,"float16")):oe.set("float16",Uint16Array)}}});var jt,Jt,Yt=T(()=>{"use strict";ve();jt=t=>{let e=1;for(let r=0;r<t.length;r++){let o=t[r];if(typeof o!="number"||!Number.isSafeInteger(o))throw new TypeError(`dims[${r}] must be an integer, got: ${o}`);if(o<0)throw new RangeError(`dims[${r}] must be a non-negative integer, got: ${o}`);e*=o}return e},Jt=(t,e)=>{switch(t.location){case"cpu":return new _(t.type,t.data,e);case"cpu-pinned":return new _({location:"cpu-pinned",data:t.data,type:t.type,dims:e});case"texture":return new _({location:"texture",texture:t.texture,type:t.type,dims:e});case"gpu-buffer":return new _({location:"gpu-buffer",gpuBuffer:t.gpuBuffer,type:t.type,dims:e});case"ml-tensor":return new _({location:"ml-tensor",mlTensor:t.mlTensor,type:t.type,dims:e});default:throw new Error(`tensorReshape: tensor location ${t.location} is not supported`)}}});var _,ve=T(()=>{"use strict";Rt();$t();Ht();Yt();_=class{constructor(e,r,o){Vt();let n,s;if(typeof e=="object"&&"location"in e)switch(this.dataLocation=e.location,n=e.type,s=e.dims,e.location){case"cpu-pinned":{let i=oe.get(n);if(!i)throw new TypeError(`unsupported type "${n}" to create tensor from pinned buffer`);if(!(e.data instanceof i))throw new TypeError(`buffer should be of type ${i.name}`);this.cpuData=e.data;break}case"texture":{if(n!=="float32")throw new TypeError(`unsupported type "${n}" to create tensor from texture`);this.gpuTextureData=e.texture,this.downloader=e.download,this.disposer=e.dispose;break}case"gpu-buffer":{if(n!=="float32"&&n!=="float16"&&n!=="int32"&&n!=="int64"&&n!=="uint32"&&n!=="uint8"&&n!=="bool"&&n!=="uint4"&&n!=="int4")throw new TypeError(`unsupported type "${n}" to create tensor from gpu buffer`);this.gpuBufferData=e.gpuBuffer,this.downloader=e.download,this.disposer=e.dispose;break}case"ml-tensor":{if(n!=="float32"&&n!=="float16"&&n!=="int32"&&n!=="int64"&&n!=="uint32"&&n!=="uint64"&&n!=="int8"&&n!=="uint8"&&n!=="bool"&&n!=="uint4"&&n!=="int4")throw new TypeError(`unsupported type "${n}" to create tensor from MLTensor`);this.mlTensorData=e.mlTensor,this.downloader=e.download,this.disposer=e.dispose;break}default:throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`)}else{let i,u;if(typeof e=="string")if(n=e,u=o,e==="string"){if(!Array.isArray(r))throw new TypeError("A string tensor's data must be a string array.");i=r}else{let f=oe.get(e);if(f===void 0)throw new TypeError(`Unsupported tensor type: ${e}.`);if(Array.isArray(r)){if(e==="float16"&&f===Uint16Array||e==="uint4"||e==="int4")throw new TypeError(`Creating a ${e} tensor from number array is not supported. Please use ${f.name} as data.`);e==="uint64"||e==="int64"?i=f.from(r,BigInt):i=f.from(r)}else if(r instanceof f)i=r;else if(r instanceof Uint8ClampedArray)if(e==="uint8")i=Uint8Array.from(r);else throw new TypeError("A Uint8ClampedArray tensor's data must be type of uint8");else if(e==="float16"&&r instanceof Uint16Array&&f!==Uint16Array)i=new globalThis.Float16Array(r.buffer,r.byteOffset,r.length);else throw new TypeError(`A ${n} tensor's data must be type of ${f}`)}else if(u=r,Array.isArray(e)){if(e.length===0)throw new TypeError("Tensor type cannot be inferred from an empty array.");let f=typeof e[0];if(f==="string")n="string",i=e;else if(f==="boolean")n="bool",i=Uint8Array.from(e);else throw new TypeError(`Invalid element type of data array: ${f}.`)}else if(e instanceof Uint8ClampedArray)n="uint8",i=Uint8Array.from(e);else{let f=we.get(e.constructor);if(f===void 0)throw new TypeError(`Unsupported type for tensor data: ${e.constructor}.`);n=f,i=e}if(u===void 0)u=[i.length];else if(!Array.isArray(u))throw new TypeError("A tensor's dims must be a number array");s=u,this.cpuData=i,this.dataLocation="cpu"}let a=jt(s);if(this.cpuData&&a!==this.cpuData.length&&!((n==="uint4"||n==="int4")&&Math.ceil(a/2)===this.cpuData.length))throw new Error(`Tensor's size(${a}) does not match data length(${this.cpuData.length}).`);this.type=n,this.dims=s,this.size=a}static async fromImage(e,r){return Nt(e,r)}static fromTexture(e,r){return Ft(e,r)}static fromGpuBuffer(e,r){return Wt(e,r)}static fromMLTensor(e,r){return kt(e,r)}static fromPinnedBuffer(e,r,o){return Gt(e,r,o)}toDataURL(e){return Pt(this,e)}toImageData(e){return _t(this,e)}get data(){if(this.ensureValid(),!this.cpuData)throw new Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");return this.cpuData}get location(){return this.dataLocation}get texture(){if(this.ensureValid(),!this.gpuTextureData)throw new Error("The data is not stored as a WebGL texture.");return this.gpuTextureData}get gpuBuffer(){if(this.ensureValid(),!this.gpuBufferData)throw new Error("The data is not stored as a WebGPU buffer.");return this.gpuBufferData}get mlTensor(){if(this.ensureValid(),!this.mlTensorData)throw new Error("The data is not stored as a WebNN MLTensor.");return this.mlTensorData}async getData(e){switch(this.ensureValid(),this.dataLocation){case"cpu":case"cpu-pinned":return this.data;case"texture":case"gpu-buffer":case"ml-tensor":{if(!this.downloader)throw new Error("The current tensor is not created with a specified data downloader.");if(this.isDownloading)throw new Error("The current tensor is being downloaded.");try{this.isDownloading=!0;let r=await this.downloader();return this.downloader=void 0,this.dataLocation="cpu",this.cpuData=r,e&&this.disposer&&(this.disposer(),this.disposer=void 0),r}finally{this.isDownloading=!1}}default:throw new Error(`cannot get data from location: ${this.dataLocation}`)}}dispose(){if(this.isDownloading)throw new Error("The current tensor is being downloaded.");this.disposer&&(this.disposer(),this.disposer=void 0),this.cpuData=void 0,this.gpuTextureData=void 0,this.gpuBufferData=void 0,this.mlTensorData=void 0,this.downloader=void 0,this.isDownloading=void 0,this.dataLocation="none"}ensureValid(){if(this.dataLocation==="none")throw new Error("The tensor is disposed.")}reshape(e){if(this.ensureValid(),this.downloader||this.disposer)throw new Error("Cannot reshape a tensor that owns GPU resource.");return Jt(this,e)}}});var V,it=T(()=>{"use strict";ve();V=_});var qt,Xt,se,ae,Z,K,ut=T(()=>{"use strict";st();qt=(t,e)=>{(typeof U.trace>"u"?!U.wasm.trace:!U.trace)||console.timeStamp(`${t}::ORT::${e}`)},Xt=(t,e)=>{let r=new Error().stack?.split(/\r\n|\r|\n/g)||[],o=!1;for(let n=0;n<r.length;n++){if(o&&!r[n].includes("TRACE_FUNC")){let s=`FUNC_${t}::${r[n].trim().split(" ")[1]}`;e&&(s+=`::${e}`),qt("CPU",s);return}r[n].includes("TRACE_FUNC")&&(o=!0)}},se=t=>{(typeof U.trace>"u"?!U.wasm.trace:!U.trace)||Xt("BEGIN",t)},ae=t=>{(typeof U.trace>"u"?!U.wasm.trace:!U.trace)||Xt("END",t)},Z=t=>{(typeof U.trace>"u"?!U.wasm.trace:!U.trace)||console.time(`ORT::${t}`)},K=t=>{(typeof U.trace>"u"?!U.wasm.trace:!U.trace)||console.timeEnd(`ORT::${t}`)}});var Me,Zt=T(()=>{"use strict";ot();it();ut();Me=class t{constructor(e){this.handler=e}async run(e,r,o){se(),Z("InferenceSession.run");let n={},s={};if(typeof e!="object"||e===null||e instanceof V||Array.isArray(e))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let a=!0;if(typeof r=="object"){if(r===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(r instanceof V)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(r)){if(r.length===0)throw new TypeError("'fetches' cannot be an empty array.");a=!1;for(let f of r){if(typeof f!="string")throw new TypeError("'fetches' must be a string array or an object.");if(this.outputNames.indexOf(f)===-1)throw new RangeError(`'fetches' contains invalid output name: ${f}.`);n[f]=null}if(typeof o=="object"&&o!==null)s=o;else if(typeof o<"u")throw new TypeError("'options' must be an object.")}else{let f=!1,c=Object.getOwnPropertyNames(r);for(let l of this.outputNames)if(c.indexOf(l)!==-1){let d=r[l];(d===null||d instanceof V)&&(f=!0,a=!1,n[l]=d)}if(f){if(typeof o=="object"&&o!==null)s=o;else if(typeof o<"u")throw new TypeError("'options' must be an object.")}else s=r}}else if(typeof r<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let f of this.inputNames)if(typeof e[f]>"u")throw new Error(`input '${f}' is missing in 'feeds'.`);if(a)for(let f of this.outputNames)n[f]=null;let i=await this.handler.run(e,n,s),u={};for(let f in i)if(Object.hasOwnProperty.call(i,f)){let c=i[f];c instanceof V?u[f]=c:u[f]=new V(c.type,c.data,c.dims)}return K("InferenceSession.run"),ae(),u}async release(){return this.handler.dispose()}static async create(e,r,o,n){se(),Z("InferenceSession.create");let s,a={};if(typeof e=="string"){if(s=e,typeof r=="object"&&r!==null)a=r;else if(typeof r<"u")throw new TypeError("'options' must be an object.")}else if(e instanceof Uint8Array){if(s=e,typeof r=="object"&&r!==null)a=r;else if(typeof r<"u")throw new TypeError("'options' must be an object.")}else if(e instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&e instanceof SharedArrayBuffer){let c=e,l=0,d=e.byteLength;if(typeof r=="object"&&r!==null)a=r;else if(typeof r=="number"){if(l=r,!Number.isSafeInteger(l))throw new RangeError("'byteOffset' must be an integer.");if(l<0||l>=c.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${c.byteLength}).`);if(d=e.byteLength-l,typeof o=="number"){if(d=o,!Number.isSafeInteger(d))throw new RangeError("'byteLength' must be an integer.");if(d<=0||l+d>c.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${c.byteLength-l}].`);if(typeof n=="object"&&n!==null)a=n;else if(typeof n<"u")throw new TypeError("'options' must be an object.")}else if(typeof o<"u")throw new TypeError("'byteLength' must be a number.")}else if(typeof r<"u")throw new TypeError("'options' must be an object.");s=new Uint8Array(c,l,d)}else throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");let[i,u]=await xt(a),f=await i.createInferenceSessionHandler(s,u);return K("InferenceSession.create"),ae(),new t(f)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}get inputMetadata(){return this.handler.inputMetadata}get outputMetadata(){return this.handler.outputMetadata}}});var Kr,Kt=T(()=>{"use strict";Zt();Kr=Me});var Qt=T(()=>{"use strict"});var er=T(()=>{"use strict"});var tr=T(()=>{"use strict"});var rr=T(()=>{"use strict"});var ft={};Le(ft,{InferenceSession:()=>Kr,TRACE:()=>qt,TRACE_EVENT_BEGIN:()=>Z,TRACE_EVENT_END:()=>K,TRACE_FUNC_BEGIN:()=>se,TRACE_FUNC_END:()=>ae,Tensor:()=>V,env:()=>v,registerBackend:()=>ne});var Q=T(()=>{"use strict";Ot();Ct();Kt();it();Qt();er();ut();tr();rr()});var xe=T(()=>{"use strict"});var ar={};Le(ar,{default:()=>Qr});var or,sr,Qr,ir=T(()=>{"use strict";ct();ee();Oe();or="ort-wasm-proxy-worker",sr=globalThis.self?.name===or;sr&&(self.onmessage=t=>{let{type:e,in:r}=t.data;try{switch(e){case"init-wasm":Be(r.wasm).then(()=>{Ue(r).then(()=>{postMessage({type:e})},o=>{postMessage({type:e,err:o})})},o=>{postMessage({type:e,err:o})});break;case"init-ep":{let{epName:o,env:n}=r;De(n,o).then(()=>{postMessage({type:e})},s=>{postMessage({type:e,err:s})});break}case"copy-from":{let{buffer:o}=r,n=be(o);postMessage({type:e,out:n});break}case"create":{let{model:o,options:n}=r;Ce(o,n).then(s=>{postMessage({type:e,out:s})},s=>{postMessage({type:e,err:s})});break}case"release":Pe(r),postMessage({type:e});break;case"run":{let{sessionId:o,inputIndices:n,inputs:s,outputIndices:a,options:i}=r;_e(o,n,s,a,new Array(a.length).fill(null),i).then(u=>{u.some(f=>f[3]!=="cpu")?postMessage({type:e,err:"Proxy does not support non-cpu tensor location."}):postMessage({type:e,out:u},Ne([...s,...u]))},u=>{postMessage({type:e,err:u})});break}case"end-profiling":Re(r),postMessage({type:e});break;default:}}catch(o){postMessage({type:e,err:o})}});Qr=sr?null:t=>new Worker(t??G,{type:"module",name:or})});var cr,en,tn,G,Fe,dt,rn,nn,dr,on,ur,lr,fr,pr,Oe=T(()=>{"use strict";xe();cr=typeof location>"u"?void 0:location.origin,en=import.meta.url>"file:"&&import.meta.url<"file;",tn=()=>{if(!!1){if(en){let t=URL;return new URL(new t("ort.webgpu.min.mjs",import.meta.url).href,cr).href}return import.meta.url}},G=tn(),Fe=()=>{if(G&&!G.startsWith("blob:"))return G.substring(0,G.lastIndexOf("/")+1)},dt=(t,e)=>{try{let r=e??G;return(r?new URL(t,r):new URL(t)).origin===cr}catch{return!1}},rn=(t,e)=>{let r=e??G;try{return(r?new URL(t,r):new URL(t)).href}catch{return}},nn=(t,e)=>`${e??"./"}${t}`,dr=async t=>{let r=await(await fetch(t,{credentials:"same-origin"})).blob();return URL.createObjectURL(r)},on=async t=>(await import(/*webpackIgnore:true*/t)).default,ur=(ir(),nt(ar)).default,lr=async()=>{if(!G)throw new Error("Failed to load proxy worker: cannot determine the script source URL.");if(dt(G))return[void 0,ur()];let t=await dr(G);return[t,ur(t)]},fr=void 0,pr=async(t,e,r,o)=>{let n=fr&&!(t||e);if(n)if(G)n=dt(G);else if(o&&!r)n=!0;else throw new Error("cannot determine the script source URL.");if(n)return[void 0,fr];{let s="ort-wasm-simd-threaded.asyncify.mjs",a=t??rn(s,e),i=!!1&&r&&a&&!dt(a,e),u=i?await dr(a):a??nn(s,e);return[i?u:void 0,await on(u)]}}});var lt,pt,We,mr,sn,an,un,Be,S,ee=T(()=>{"use strict";Oe();pt=!1,We=!1,mr=!1,sn=()=>{if(typeof SharedArrayBuffer>"u")return!1;try{return typeof MessageChannel<"u"&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch{return!1}},an=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}},un=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,5,1,96,0,1,123,3,2,1,0,10,19,1,17,0,65,1,253,15,65,2,253,15,65,3,253,15,253,147,2,11]))}catch{return!1}},Be=async t=>{if(pt)return Promise.resolve();if(We)throw new Error("multiple calls to 'initializeWebAssembly()' detected.");if(mr)throw new Error("previous call to 'initializeWebAssembly()' failed.");We=!0;let e=t.initTimeout,r=t.numThreads;if(t.simd!==!1){if(t.simd==="relaxed"){if(!un())throw new Error("Relaxed WebAssembly SIMD is not supported in the current environment.")}else if(!an())throw new Error("WebAssembly SIMD is not supported in the current environment.")}let o=sn();r>1&&!o&&(typeof self<"u"&&!self.crossOriginIsolated&&console.warn("env.wasm.numThreads is set to "+r+", but this will not work unless you enable crossOriginIsolated mode. See https://web.dev/cross-origin-isolation-guide/ for more info."),console.warn("WebAssembly multi-threading is not supported in the current environment. Falling back to single-threading."),t.numThreads=r=1);let n=t.wasmPaths,s=typeof n=="string"?n:void 0,a=n?.mjs,i=a?.href??a,u=n?.wasm,f=u?.href??u,c=t.wasmBinary,[l,d]=await pr(i,s,r>1,!!c||!!f),p=!1,y=[];if(e>0&&y.push(new Promise(g=>{setTimeout(()=>{p=!0,g()},e)})),y.push(new Promise((g,L)=>{let h={numThreads:r};if(c)h.wasmBinary=c;else if(f||s)h.locateFile=m=>f??s+m;else if(i&&i.indexOf("blob:")!==0)h.locateFile=m=>new URL(m,i).href;else if(l){let m=Fe();m&&(h.locateFile=A=>m+A)}d(h).then(m=>{We=!1,pt=!0,lt=m,g(),l&&URL.revokeObjectURL(l)},m=>{We=!1,mr=!0,L(m)})})),await Promise.race(y),p)throw new Error(`WebAssembly backend initializing failed due to timeout: ${e}ms`)},S=()=>{if(pt&&lt)return lt;throw new Error("WebAssembly is not initialized yet.")}});var F,ge,E,ke=T(()=>{"use strict";ee();F=(t,e)=>{let r=S(),o=r.lengthBytesUTF8(t)+1,n=r._malloc(o);return r.stringToUTF8(t,n,o),e.push(n),n},ge=(t,e,r,o)=>{if(typeof t=="object"&&t!==null){if(r.has(t))throw new Error("Circular reference in options");r.add(t)}Object.entries(t).forEach(([n,s])=>{let a=e?e+n:n;if(typeof s=="object")ge(s,a+".",r,o);else if(typeof s=="string"||typeof s=="number")o(a,s.toString());else if(typeof s=="boolean")o(a,s?"1":"0");else throw new Error(`Can't handle extra config type: ${typeof s}`)})},E=t=>{let e=S(),r=e.stackSave();try{let o=e.PTR_SIZE,n=e.stackAlloc(2*o);e._OrtGetLastError(n,n+o);let s=Number(e.getValue(n,o===4?"i32":"i64")),a=e.getValue(n+o,"*"),i=a?e.UTF8ToString(a):"";throw new Error(`${t} ERROR_CODE: ${s}, ERROR_MESSAGE: ${i}`)}finally{e.stackRestore(r)}}});var hr,yr=T(()=>{"use strict";ee();ke();hr=t=>{let e=S(),r=0,o=[],n=t||{};try{if(t?.logSeverityLevel===void 0)n.logSeverityLevel=2;else if(typeof t.logSeverityLevel!="number"||!Number.isInteger(t.logSeverityLevel)||t.logSeverityLevel<0||t.logSeverityLevel>4)throw new Error(`log severity level is not valid: ${t.logSeverityLevel}`);if(t?.logVerbosityLevel===void 0)n.logVerbosityLevel=0;else if(typeof t.logVerbosityLevel!="number"||!Number.isInteger(t.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${t.logVerbosityLevel}`);t?.terminate===void 0&&(n.terminate=!1);let s=0;return t?.tag!==void 0&&(s=F(t.tag,o)),r=e._OrtCreateRunOptions(n.logSeverityLevel,n.logVerbosityLevel,!!n.terminate,s),r===0&&E("Can't create run options."),t?.extra!==void 0&&ge(t.extra,"",new WeakSet,(a,i)=>{let u=F(a,o),f=F(i,o);e._OrtAddRunConfigEntry(r,u,f)!==0&&E(`Can't set a run config entry: ${a} - ${i}.`)}),[r,o]}catch(s){throw r!==0&&e._OrtReleaseRunOptions(r),o.forEach(a=>e._free(a)),s}}});var fn,cn,dn,ht,mt,ln,wr,br=T(()=>{"use strict";ee();ke();fn=t=>{switch(t){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"layout":return 3;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${t}`)}},cn=t=>{switch(t){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${t}`)}},dn=t=>{t.extra||(t.extra={}),t.extra.session||(t.extra.session={});let e=t.extra.session;e.use_ort_model_bytes_directly||(e.use_ort_model_bytes_directly="1"),t.executionProviders&&t.executionProviders.some(r=>(typeof r=="string"?r:r.name)==="webgpu")&&(t.enableMemPattern=!1)},ht=(t,e,r,o)=>{let n=F(e,o),s=F(r,o);S()._OrtAddSessionConfigEntry(t,n,s)!==0&&E(`Can't set a session config entry: ${e} - ${r}.`)},mt=(t,e,r,o)=>{let n=F(e,o),s=F(r,o);t.push([n,s])},ln=async(t,e,r)=>{for(let o of e){let n=typeof o=="string"?o:o.name,s=[];switch(n){case"webnn":if(n="WEBNN",typeof o!="string"){let l=o?.deviceType;l&&ht(t,"deviceType",l,r)}break;case"webgpu":{n="WebGPU";let c;if(typeof o!="string"){let d=o;if(d.device)if(typeof GPUDevice<"u"&&d.device instanceof GPUDevice)c=d.device;else throw new Error("Invalid GPU device set in WebGPU EP options.")}let l=S().webgpuRegisterDevice(c);if(l){let[d,p,y]=l;mt(s,"deviceId",d.toString(),r),mt(s,"webgpuInstance",p.toString(),r),mt(s,"webgpuDevice",y.toString(),r)}}break;case"wasm":case"cpu":continue;default:throw new Error(`not supported execution provider: ${n}`)}let a=F(n,r),i=s.length,u=0,f=0;if(i>0){u=S()._malloc(i*S().PTR_SIZE),r.push(u),f=S()._malloc(i*S().PTR_SIZE),r.push(f);for(let c=0;c<i;c++)S().setValue(u+c*S().PTR_SIZE,s[c][0],"*"),S().setValue(f+c*S().PTR_SIZE,s[c][1],"*")}await S()._OrtAppendExecutionProvider(t,a,u,f,i)!==0&&E(`Can't append execution provider: ${n}.`)}},wr=async t=>{let e=S(),r=0,o=[],n=t||{};dn(n);try{let s=fn(n.graphOptimizationLevel??"all"),a=cn(n.executionMode??"sequential"),i=typeof n.logId=="string"?F(n.logId,o):0,u=n.logSeverityLevel??2;if(!Number.isInteger(u)||u<0||u>4)throw new Error(`log severity level is not valid: ${u}`);let f=n.logVerbosityLevel??0;if(!Number.isInteger(f)||f<0||f>4)throw new Error(`log verbosity level is not valid: ${f}`);let c=typeof n.optimizedModelFilePath=="string"?F(n.optimizedModelFilePath,o):0;if(r=e._OrtCreateSessionOptions(s,!!n.enableCpuMemArena,!!n.enableMemPattern,a,!!n.enableProfiling,0,i,u,f,c),r===0&&E("Can't create session options."),n.executionProviders&&await ln(r,n.executionProviders,o),n.enableGraphCapture!==void 0){if(typeof n.enableGraphCapture!="boolean")throw new Error(`enableGraphCapture must be a boolean value: ${n.enableGraphCapture}`);ht(r,"enableGraphCapture",n.enableGraphCapture.toString(),o)}if(n.freeDimensionOverrides)for(let[l,d]of Object.entries(n.freeDimensionOverrides)){if(typeof l!="string")throw new Error(`free dimension override name must be a string: ${l}`);if(typeof d!="number"||!Number.isInteger(d)||d<0)throw new Error(`free dimension override value must be a non-negative integer: ${d}`);let p=F(l,o);e._OrtAddFreeDimensionOverride(r,p,d)!==0&&E(`Can't set a free dimension override: ${l} - ${d}.`)}return n.extra!==void 0&&ge(n.extra,"",new WeakSet,(l,d)=>{ht(r,l,d,o)}),[r,o]}catch(s){throw r!==0&&e._OrtReleaseSessionOptions(r)!==0&&E("Can't release session options."),o.forEach(a=>e._free(a)),s}}});var te,Ge,le,ue,Te,$e,ze,yt,fe=T(()=>{"use strict";te=t=>{switch(t){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;case"int4":return 22;case"uint4":return 21;default:throw new Error(`unsupported data type: ${t}`)}},Ge=t=>{switch(t){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";case 22:return"int4";case 21:return"uint4";default:throw new Error(`unsupported data type: ${t}`)}},le=(t,e)=>{let r=[-1,4,1,1,2,2,4,8,-1,1,2,8,4,8,-1,-1,-1,-1,-1,-1,-1,.5,.5][t],o=typeof e=="number"?e:e.reduce((n,s)=>n*s,1);return r>0?Math.ceil(o*r):void 0},ue=t=>{switch(t){case"float16":return typeof Float16Array<"u"&&Float16Array.from?Float16Array:Uint16Array;case"float32":return Float32Array;case"uint8":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"bool":return Uint8Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${t}`)}},Te=t=>{switch(t){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${t}`)}},$e=t=>t==="float32"||t==="float16"||t==="int32"||t==="int64"||t==="uint32"||t==="uint8"||t==="bool"||t==="uint4"||t==="int4",ze=t=>t==="float32"||t==="float16"||t==="int32"||t==="int64"||t==="uint32"||t==="uint64"||t==="int8"||t==="uint8"||t==="bool"||t==="uint4"||t==="int4",yt=t=>{switch(t){case"none":return 0;case"cpu":return 1;case"cpu-pinned":return 2;case"texture":return 3;case"gpu-buffer":return 4;case"ml-tensor":return 5;default:throw new Error(`unsupported data location: ${t}`)}}});var Ee,wt=T(()=>{"use strict";xe();Ee=async t=>{if(typeof t=="string")if(!1)try{let{readFile:e}=rt("node:fs/promises");return new Uint8Array(await e(t))}catch(e){if(e.code==="ERR_FS_FILE_TOO_LARGE"){let{createReadStream:r}=rt("node:fs"),o=r(t),n=[];for await(let s of o)n.push(s);return new Uint8Array(Buffer.concat(n))}throw e}else{let e=await fetch(t);if(!e.ok)throw new Error(`failed to load external data file: ${t}`);let r=e.headers.get("Content-Length"),o=r?parseInt(r,10):0;if(o<1073741824)return new Uint8Array(await e.arrayBuffer());{if(!e.body)throw new Error(`failed to load external data file: ${t}, no response body.`);let n=e.body.getReader(),s;try{s=new ArrayBuffer(o)}catch(i){if(i instanceof RangeError){let u=Math.ceil(o/65536);s=new WebAssembly.Memory({initial:u,maximum:u}).buffer}else throw i}let a=0;for(;;){let{done:i,value:u}=await n.read();if(i)break;let f=u.byteLength;new Uint8Array(s,a,f).set(u),a+=f}return new Uint8Array(s,0,o)}}else return t instanceof Blob?new Uint8Array(await t.arrayBuffer()):t instanceof Uint8Array?t:new Uint8Array(t)}});var gr,Tr=T(()=>{"use strict";fe();gr=(t,e)=>new(ue(e))(t)});var pn,mn,Er,Sr,Ir,hn,R,bt=T(()=>{"use strict";fe();pn=["V","I","W","E","F"],mn=(t,e)=>{console.log(`[${pn[t]},${new Date().toISOString()}]${e}`)},Ir=(t,e)=>{Er=t,Sr=e},hn=(t,e)=>{let r=Te(t),o=Te(Er);r>=o&&mn(r,typeof e=="function"?e():e)},R=(...t)=>{Sr&&hn(...t)}});var Ar,Tt,vr,yn,Lr,wn,Mr,Ve,He,gt,xr,Or=T(()=>{"use strict";fe();bt();Ar=new Map([["float32",32],["float16",16],["int32",32],["uint32",32],["int64",64],["uint64",64],["int8",8],["uint8",8],["int4",4],["uint4",4]]),Tt=(t,e)=>{if(e==="int32")return t;let r=Ar.get(e);if(!r)throw new Error(`WebNN backend does not support data type: ${e}`);let o=r/8;if(t.byteLength%o!==0)throw new Error(`Invalid Uint8Array length - must be a multiple of ${o}.`);let n=t.byteLength/o,s=new(ue(e))(t.buffer,t.byteOffset,n);switch(e){case"int64":case"uint64":{let a=new Int32Array(n);for(let i=0;i<n;i++){let u=s[i];if(u>2147483647n||u<-2147483648n)throw new Error("Can not convert int64 data to int32 - value out of range.");a[i]=Number(u)}return new Uint8Array(a.buffer)}case"int8":case"uint8":case"uint32":{if(e==="uint32"&&s.some(i=>i>2147483647))throw new Error("Can not convert uint32 data to int32 - value out of range.");let a=Int32Array.from(s,Number);return new Uint8Array(a.buffer)}default:throw new Error(`Unsupported data conversion from ${e} to 'int32'`)}},vr=(t,e)=>{if(e==="int32")return t;if(t.byteLength%4!==0)throw new Error("Invalid Uint8Array length - must be a multiple of 4 (int32).");let r=t.byteLength/4,o=new Int32Array(t.buffer,t.byteOffset,r);switch(e){case"int64":{let n=BigInt64Array.from(o,BigInt);return new Uint8Array(n.buffer)}case"uint64":{if(o.some(s=>s<0))throw new Error("Can not convert int32 data to uin64 - negative value found.");let n=BigUint64Array.from(o,BigInt);return new Uint8Array(n.buffer)}case"int8":{if(o.some(s=>s<-128||s>127))throw new Error("Can not convert int32 data to int8 - value out of range.");let n=Int8Array.from(o,Number);return new Uint8Array(n.buffer)}case"uint8":{if(o.some(n=>n<0||n>255))throw new Error("Can not convert int32 data to uint8 - value out of range.");return Uint8Array.from(o,Number)}case"uint32":{if(o.some(s=>s<0))throw new Error("Can not convert int32 data to uint32 - negative value found.");let n=Uint32Array.from(o,Number);return new Uint8Array(n.buffer)}default:throw new Error(`Unsupported data conversion from 'int32' to ${e}`)}},yn=1,Lr=()=>yn++,wn=new Map([["int8","int32"],["uint8","int32"],["uint32","int32"],["int64","int32"]]),Mr=(t,e)=>{let r=Ar.get(t);if(!r)throw new Error(`WebNN backend does not support data type: ${t}`);return e.length>0?Math.ceil(e.reduce((o,n)=>o*n)*r/8):0},Ve=class{constructor(e){this.isDataConverted=!1;let{sessionId:r,context:o,tensor:n,dataType:s,shape:a,fallbackDataType:i}=e;this.sessionId=r,this.mlContext=o,this.mlTensor=n,this.dataType=s,this.tensorShape=a,this.fallbackDataType=i}get tensor(){return this.mlTensor}get type(){return this.dataType}get fallbackType(){return this.fallbackDataType}get shape(){return this.tensorShape}get byteLength(){return Mr(this.dataType,this.tensorShape)}destroy(){R("verbose",()=>"[WebNN] TensorWrapper.destroy"),this.mlTensor.destroy()}write(e){this.mlContext.writeTensor(this.mlTensor,e)}async read(e){if(this.fallbackDataType){let r=await this.mlContext.readTensor(this.mlTensor),o=vr(new Uint8Array(r),this.dataType);if(e){(e instanceof ArrayBuffer?new Uint8Array(e):new Uint8Array(e.buffer,e.byteOffset,e.byteLength)).set(o);return}else return o.buffer}else return e?this.mlContext.readTensor(this.mlTensor,e):this.mlContext.readTensor(this.mlTensor)}canReuseTensor(e,r,o){return this.mlContext===e&&this.dataType===r&&this.tensorShape.length===o.length&&this.tensorShape.every((n,s)=>n===o[s])}setIsDataConverted(e){this.isDataConverted=e}},He=class{constructor(e,r){this.tensorManager=e;this.wrapper=r}get tensorWrapper(){return this.wrapper}releaseTensor(){this.tensorWrapper&&(this.tensorManager.releaseTensor(this.tensorWrapper),this.wrapper=void 0)}async ensureTensor(e,r,o,n){let s=this.tensorManager.getMLContext(e),a=this.tensorManager.getMLOpSupportLimits(e),i;if(!a?.input.dataTypes.includes(r)){if(i=wn.get(r),!i||a?.input.dataTypes.includes(i))throw new Error(`WebNN backend does not support data type: ${r}`);R("verbose",()=>`[WebNN] TensorIdTracker.ensureTensor: fallback dataType from ${r} to ${i}`)}if(this.wrapper){if(this.wrapper.canReuseTensor(s,r,o))return this.wrapper.tensor;if(n){if(this.wrapper.byteLength!==Mr(r,o))throw new Error("Unable to copy data to tensor with different size.");this.activeUpload=new Uint8Array(await this.wrapper.read())}this.tensorManager.releaseTensor(this.wrapper)}let u=typeof MLTensorUsage>"u"?void 0:MLTensorUsage.READ|MLTensorUsage.WRITE;return this.wrapper=await this.tensorManager.getCachedTensor(e,r,o,u,!0,!0,i),n&&this.activeUpload&&(this.wrapper.write(this.activeUpload),this.activeUpload=void 0),this.wrapper.tensor}upload(e){let r=e;if(this.wrapper){if(this.wrapper.fallbackType)if(this.wrapper.fallbackType==="int32")r=Tt(e,this.wrapper.type),this.wrapper.setIsDataConverted(!0);else throw new Error(`Unsupported fallback data type: ${this.wrapper.fallbackType}`);if(e.byteLength===this.wrapper.byteLength){this.wrapper.write(r);return}else R("verbose",()=>"Data size does not match tensor size. Releasing tensor."),this.releaseTensor()}this.activeUpload?this.activeUpload.set(r):this.activeUpload=new Uint8Array(r)}async download(e){if(this.activeUpload){let r=this.wrapper?.isDataConverted?vr(this.activeUpload,this.wrapper?.type):this.activeUpload;if(e){e instanceof ArrayBuffer?new Uint8Array(e).set(r):new Uint8Array(e.buffer,e.byteOffset,e.byteLength).set(r);return}else return r.buffer}if(!this.wrapper)throw new Error("Tensor has not been created.");return e?this.wrapper.read(e):this.wrapper.read()}},gt=class{constructor(e){this.backend=e;this.tensorTrackersById=new Map;this.freeTensors=[];this.externalTensors=new Set}getMLContext(e){let r=this.backend.getMLContext(e);if(!r)throw new Error("MLContext not found for session.");return r}getMLOpSupportLimits(e){return this.backend.getMLOpSupportLimits(e)}reserveTensorId(){let e=Lr();return this.tensorTrackersById.set(e,new He(this)),e}releaseTensorId(e){let r=this.tensorTrackersById.get(e);r&&(this.tensorTrackersById.delete(e),r.tensorWrapper&&this.releaseTensor(r.tensorWrapper))}async ensureTensor(e,r,o,n,s){R("verbose",()=>`[WebNN] TensorManager.ensureTensor {tensorId: ${r}, dataType: ${o}, shape: ${n}, copyOld: ${s}}`);let a=this.tensorTrackersById.get(r);if(!a)throw new Error("Tensor not found.");return a.ensureTensor(e,o,n,s)}upload(e,r){let o=this.tensorTrackersById.get(e);if(!o)throw new Error("Tensor not found.");o.upload(r)}async download(e,r){R("verbose",()=>`[WebNN] TensorManager.download {tensorId: ${e}, dstBuffer: ${r?.byteLength}}`);let o=this.tensorTrackersById.get(e);if(!o)throw new Error("Tensor not found.");return o.download(r)}releaseTensorsForSession(e){for(let r of this.freeTensors)r.sessionId===e&&r.destroy();this.freeTensors=this.freeTensors.filter(r=>r.sessionId!==e)}registerTensor(e,r,o,n){let s=this.getMLContext(e),a=Lr(),i=new Ve({sessionId:e,context:s,tensor:r,dataType:o,shape:n});return this.tensorTrackersById.set(a,new He(this,i)),this.externalTensors.add(i),a}async getCachedTensor(e,r,o,n,s,a,i){let u=this.getMLContext(e);for(let[c,l]of this.freeTensors.entries())if(l.canReuseTensor(u,r,o)){R("verbose",()=>`[WebNN] Reusing tensor {dataType: ${r}, ${i?`fallbackDataType: ${i},`:""} shape: ${o}`);let d=this.freeTensors.splice(c,1)[0];return d.sessionId=e,d}R("verbose",()=>`[WebNN] MLContext.createTensor {dataType: ${r}, ${i?`fallbackDataType: ${i},`:""} shape: ${o}}`);let f=await u.createTensor({dataType:i??r,shape:o,dimensions:o,usage:n,writable:s,readable:a});return new Ve({sessionId:e,context:u,tensor:f,dataType:r,shape:o,fallbackDataType:i})}releaseTensor(e){this.externalTensors.has(e)&&this.externalTensors.delete(e),this.freeTensors.push(e)}},xr=(...t)=>new gt(...t)});var Br={};Le(Br,{WebNNBackend:()=>Et});var je,bn,Et,Ur=T(()=>{"use strict";fe();ee();Tr();Or();bt();je=new Map([[1,"float32"],[10,"float16"],[6,"int32"],[12,"uint32"],[7,"int64"],[13,"uint64"],[22,"int4"],[21,"uint4"],[3,"int8"],[2,"uint8"],[9,"uint8"]]),bn=(t,e)=>{if(t===e)return!0;if(t===void 0||e===void 0)return!1;let r=Object.keys(t).sort(),o=Object.keys(e).sort();return r.length===o.length&&r.every((n,s)=>n===o[s]&&t[n]===e[n])},Et=class{constructor(e){this.tensorManager=xr(this);this.mlContextBySessionId=new Map;this.sessionIdsByMLContext=new Map;this.mlContextCache=[];this.sessionGraphInputs=new Map;this.sessionGraphOutputs=new Map;this.temporaryGraphInputs=[];this.temporaryGraphOutputs=[];this.temporarySessionTensorIds=new Map;this.mlOpSupportLimitsBySessionId=new Map;Ir(e.logLevel,!!e.debug)}get currentSessionId(){if(this.activeSessionId===void 0)throw new Error("No active session");return this.activeSessionId}onRunStart(e){R("verbose",()=>`[WebNN] onRunStart {sessionId: ${e}}`),this.activeSessionId=e}onRunEnd(e){R("verbose",()=>`[WebNN] onRunEnd {sessionId: ${e}}`);let r=this.temporarySessionTensorIds.get(e);if(r){for(let o of r)R("verbose",()=>`[WebNN] releasing temporary tensor {tensorId: ${o}}`),this.tensorManager.releaseTensorId(o);this.temporarySessionTensorIds.delete(e),this.activeSessionId=void 0}}async createMLContext(e){if(e instanceof GPUDevice){let o=this.mlContextCache.findIndex(n=>n.gpuDevice===e);if(o!==-1)return this.mlContextCache[o].mlContext;{let n=await navigator.ml.createContext(e);return this.mlContextCache.push({gpuDevice:e,mlContext:n}),n}}else if(e===void 0){let o=this.mlContextCache.findIndex(n=>n.options===void 0&&n.gpuDevice===void 0);if(o!==-1)return this.mlContextCache[o].mlContext;{let n=await navigator.ml.createContext();return this.mlContextCache.push({mlContext:n}),n}}let r=this.mlContextCache.findIndex(o=>bn(o.options,e));if(r!==-1)return this.mlContextCache[r].mlContext;{let o=await navigator.ml.createContext(e);return this.mlContextCache.push({options:e,mlContext:o}),o}}registerMLContext(e,r){this.mlContextBySessionId.set(e,r);let o=this.sessionIdsByMLContext.get(r);o||(o=new Set,this.sessionIdsByMLContext.set(r,o)),o.add(e),this.mlOpSupportLimitsBySessionId.has(e)||this.mlOpSupportLimitsBySessionId.set(e,r.opSupportLimits()),this.temporaryGraphInputs.length>0&&(this.sessionGraphInputs.set(e,this.temporaryGraphInputs),this.temporaryGraphInputs=[]),this.temporaryGraphOutputs.length>0&&(this.sessionGraphOutputs.set(e,this.temporaryGraphOutputs),this.temporaryGraphOutputs=[])}onReleaseSession(e){this.sessionGraphInputs.delete(e),this.sessionGraphOutputs.delete(e);let r=this.mlContextBySessionId.get(e);if(!r)return;this.tensorManager.releaseTensorsForSession(e),this.mlContextBySessionId.delete(e),this.mlOpSupportLimitsBySessionId.delete(e);let o=this.sessionIdsByMLContext.get(r);if(o.delete(e),o.size===0){this.sessionIdsByMLContext.delete(r);let n=this.mlContextCache.findIndex(s=>s.mlContext===r);n!==-1&&this.mlContextCache.splice(n,1)}}getMLContext(e){return this.mlContextBySessionId.get(e)}getMLOpSupportLimits(e){return this.mlOpSupportLimitsBySessionId.get(e)}reserveTensorId(){return this.tensorManager.reserveTensorId()}releaseTensorId(e){R("verbose",()=>`[WebNN] releaseTensorId {tensorId: ${e}}`),this.tensorManager.releaseTensorId(e)}async ensureTensor(e,r,o,n,s){let a=je.get(o);if(!a)throw new Error(`Unsupported ONNX data type: ${o}`);return this.tensorManager.ensureTensor(e??this.currentSessionId,r,a,n,s)}async createTemporaryTensor(e,r,o){R("verbose",()=>`[WebNN] createTemporaryTensor {onnxDataType: ${r}, shape: ${o}}`);let n=je.get(r);if(!n)throw new Error(`Unsupported ONNX data type: ${r}`);let s=this.tensorManager.reserveTensorId();await this.tensorManager.ensureTensor(e,s,n,o,!1);let a=this.temporarySessionTensorIds.get(e);return a?a.push(s):this.temporarySessionTensorIds.set(e,[s]),s}uploadTensor(e,r){if(!S().shouldTransferToMLTensor)throw new Error("Trying to upload to a MLTensor while shouldTransferToMLTensor is false");R("verbose",()=>`[WebNN] uploadTensor {tensorId: ${e}, data: ${r.byteLength}}`),this.tensorManager.upload(e,r)}async downloadTensor(e,r){return this.tensorManager.download(e,r)}createMLTensorDownloader(e,r){return async()=>{let o=await this.tensorManager.download(e);return gr(o,r)}}registerMLTensor(e,r,o,n){let s=je.get(o);if(!s)throw new Error(`Unsupported ONNX data type: ${o}`);let a=this.tensorManager.registerTensor(e,r,s,n);return R("verbose",()=>`[WebNN] registerMLTensor {tensor: ${r}, dataType: ${s}, dimensions: ${n}} -> {tensorId: ${a}}`),a}registerMLConstant(e,r,o,n,s,a,i=!1){if(!a)throw new Error("External mounted files are not available.");let u=e;e.startsWith("./")&&(u=e.substring(2));let f=a.get(u);if(!f)throw new Error(`File with name ${u} not found in preloaded files.`);if(r+o>f.byteLength)throw new Error("Out of bounds: data offset and length exceed the external file data size.");let c=f.slice(r,r+o).buffer,l;switch(s.dataType){case"float32":l=new Float32Array(c);break;case"float16":l=typeof Float16Array<"u"&&Float16Array.from?new Float16Array(c):new Uint16Array(c);break;case"int32":l=new Int32Array(c);break;case"uint32":l=new Uint32Array(c);break;case"int64":if(i){let d=Tt(new Uint8Array(c),"int64");l=new Int32Array(d.buffer),s.dataType="int32"}else l=new BigInt64Array(c);break;case"uint64":l=new BigUint64Array(c);break;case"int8":l=new Int8Array(c);break;case"int4":case"uint4":case"uint8":l=new Uint8Array(c);break;default:throw new Error(`Unsupported data type: ${s.dataType} in creating WebNN Constant from external data.`)}return R("verbose",()=>`[WebNN] registerMLConstant {dataType: ${s.dataType}, shape: ${s.shape}}} ${i?"(Note: it was int64 data type and registered to int32 as workaround)":""}`),n.constant(s,l)}registerGraphInput(e){this.temporaryGraphInputs.push(e)}registerGraphOutput(e){this.temporaryGraphOutputs.push(e)}isGraphInput(e,r){let o=this.sessionGraphInputs.get(e);return o?o.includes(r):!1}isGraphOutput(e,r){let o=this.sessionGraphOutputs.get(e);return o?o.includes(r):!1}isGraphInputOutputTypeSupported(e,r,o=!0){let n=je.get(te(r)),s=this.mlOpSupportLimitsBySessionId.get(e);return typeof n>"u"?!1:o?!!s?.input.dataTypes.includes(n):!!s?.output.dataTypes.includes(n)}flush(){}}});var gn,Ue,De,ce,Tn,Dr,be,Ce,Pe,Cr,_e,Re,Ne,ct=T(()=>{"use strict";Q();yr();br();fe();ee();ke();wt();gn=(t,e)=>{S()._OrtInit(t,e)!==0&&E("Can't initialize onnxruntime.")},Ue=async t=>{gn(t.wasm.numThreads,Te(t.logLevel))},De=async(t,e)=>{S().asyncInit?.();let r=t.webgpu.adapter;if(e==="webgpu"){if(typeof navigator>"u"||!navigator.gpu)throw new Error("WebGPU is not supported in current environment");if(r){if(typeof r.limits!="object"||typeof r.features!="object"||typeof r.requestDevice!="function")throw new Error("Invalid GPU adapter set in `env.webgpu.adapter`. It must be a GPUAdapter object.")}else{let o=t.webgpu.powerPreference;if(o!==void 0&&o!=="low-power"&&o!=="high-performance")throw new Error(`Invalid powerPreference setting: "${o}"`);let n=t.webgpu.forceFallbackAdapter;if(n!==void 0&&typeof n!="boolean")throw new Error(`Invalid forceFallbackAdapter setting: "${n}"`);if(r=await navigator.gpu.requestAdapter({powerPreference:o,forceFallbackAdapter:n}),!r)throw new Error('Failed to get GPU adapter. You may need to enable flag "--enable-unsafe-webgpu" if you are using Chrome.')}}if(e==="webnn"&&(typeof navigator>"u"||!navigator.ml))throw new Error("WebNN is not supported in current environment");if(e==="webgpu"&&S().webgpuInit(o=>{t.webgpu.device=o}),e==="webnn"){let o=new(Ur(),nt(Br)).WebNNBackend(t);S().webnnInit([o,()=>o.reserveTensorId(),n=>o.releaseTensorId(n),async(n,s,a,i,u)=>o.ensureTensor(n,s,a,i,u),(n,s)=>{o.uploadTensor(n,s)},async(n,s)=>o.downloadTensor(n,s),(n,s)=>o.registerMLContext(n,s),!!t.trace])}},ce=new Map,Tn=t=>{let e=S(),r=e.stackSave();try{let o=e.PTR_SIZE,n=e.stackAlloc(2*o);e._OrtGetInputOutputCount(t,n,n+o)!==0&&E("Can't get session input/output count.");let a=o===4?"i32":"i64";return[Number(e.getValue(n,a)),Number(e.getValue(n+o,a))]}finally{e.stackRestore(r)}},Dr=(t,e)=>{let r=S(),o=r.stackSave(),n=0;try{let s=r.PTR_SIZE,a=r.stackAlloc(2*s);r._OrtGetInputOutputMetadata(t,e,a,a+s)!==0&&E("Can't get session input/output metadata.");let u=Number(r.getValue(a,"*"));n=Number(r.getValue(a+s,"*"));let f=r.HEAP32[n/4];if(f===0)return[u,0];let c=r.HEAPU32[n/4+1],l=[];for(let d=0;d<c;d++){let p=Number(r.getValue(n+8+d*s,"*"));l.push(p!==0?r.UTF8ToString(p):Number(r.getValue(n+8+(d+c)*s,"*")))}return[u,f,l]}finally{r.stackRestore(o),n!==0&&r._OrtFree(n)}},be=t=>{let e=S(),r=e._malloc(t.byteLength);if(r===0)throw new Error(`Can't create a session. failed to allocate a buffer of size ${t.byteLength}.`);return e.HEAPU8.set(t,r),[r,t.byteLength]},Ce=async(t,e)=>{let r,o,n=S();Array.isArray(t)?[r,o]=t:t.buffer===n.HEAPU8.buffer?[r,o]=[t.byteOffset,t.byteLength]:[r,o]=be(t);let s=0,a=0,i=0,u=[],f=[],c=[];try{if([a,u]=await wr(e),e?.externalData&&n.mountExternalData){let w=[];for(let I of e.externalData){let D=typeof I=="string"?I:I.path;w.push(Ee(typeof I=="string"?I:I.data).then(k=>{n.mountExternalData(D,k)}))}await Promise.all(w)}for(let w of e?.executionProviders??[])if((typeof w=="string"?w:w.name)==="webnn"){if(n.shouldTransferToMLTensor=!1,typeof w!="string"){let D=w,k=D?.context,C=D?.gpuDevice,W=D?.deviceType,j=D?.powerPreference;k?n.currentContext=k:C?n.currentContext=await n.webnnCreateMLContext(C):n.currentContext=await n.webnnCreateMLContext({deviceType:W,powerPreference:j})}else n.currentContext=await n.webnnCreateMLContext();break}s=await n._OrtCreateSession(r,o,a),n.webgpuOnCreateSession?.(s),s===0&&E("Can't create a session."),n.jsepOnCreateSession?.(),n.currentContext&&(n.webnnRegisterMLContext(s,n.currentContext),n.currentContext=void 0,n.shouldTransferToMLTensor=!0);let[l,d]=Tn(s),p=!!e?.enableGraphCapture,y=[],g=[],L=[],h=[],m=[];for(let w=0;w<l;w++){let[I,D,k]=Dr(s,w);I===0&&E("Can't get an input name."),f.push(I);let C=n.UTF8ToString(I);y.push(C),L.push(D===0?{name:C,isTensor:!1}:{name:C,isTensor:!0,type:Ge(D),shape:k})}for(let w=0;w<d;w++){let[I,D,k]=Dr(s,w+l);I===0&&E("Can't get an output name."),c.push(I);let C=n.UTF8ToString(I);g.push(C),h.push(D===0?{name:C,isTensor:!1}:{name:C,isTensor:!0,type:Ge(D),shape:k});{if(p&&e?.preferredOutputLocation===void 0){m.push("gpu-buffer");continue}let W=typeof e?.preferredOutputLocation=="string"?e.preferredOutputLocation:e?.preferredOutputLocation?.[C]??"cpu",j=n.webnnIsGraphOutput;if(W==="cpu"&&j&&j(s,C)){m.push("ml-tensor-cpu-output");continue}if(W!=="cpu"&&W!=="cpu-pinned"&&W!=="gpu-buffer"&&W!=="ml-tensor")throw new Error(`Not supported preferred output location: ${W}.`);if(p&&W!=="gpu-buffer")throw new Error(`Not supported preferred output location: ${W}. Only 'gpu-buffer' location is supported when enableGraphCapture is true.`);m.push(W)}}let A=null;return m.some(w=>w==="gpu-buffer"||w==="ml-tensor"||w==="ml-tensor-cpu-output")&&(i=n._OrtCreateBinding(s),i===0&&E("Can't create IO binding."),A={handle:i,outputPreferredLocations:m,outputPreferredLocationsEncoded:m.map(w=>w==="ml-tensor-cpu-output"?"ml-tensor":w).map(w=>yt(w))}),ce.set(s,[s,f,c,A,p,!1]),[s,y,g,L,h]}catch(l){throw f.forEach(d=>n._OrtFree(d)),c.forEach(d=>n._OrtFree(d)),i!==0&&n._OrtReleaseBinding(i)!==0&&E("Can't release IO binding."),s!==0&&n._OrtReleaseSession(s)!==0&&E("Can't release session."),l}finally{n._free(r),a!==0&&n._OrtReleaseSessionOptions(a)!==0&&E("Can't release session options."),u.forEach(l=>n._free(l)),n.unmountExternalData?.()}},Pe=t=>{let e=S(),r=ce.get(t);if(!r)throw new Error(`cannot release session. invalid session id: ${t}`);let[o,n,s,a,i]=r;a&&(i&&e._OrtClearBoundOutputs(a.handle)!==0&&E("Can't clear bound outputs."),e._OrtReleaseBinding(a.handle)!==0&&E("Can't release IO binding.")),e.jsepOnReleaseSession?.(t),e.webnnOnReleaseSession?.(t),e.webgpuOnReleaseSession?.(t),n.forEach(u=>e._OrtFree(u)),s.forEach(u=>e._OrtFree(u)),e._OrtReleaseSession(o)!==0&&E("Can't release session."),ce.delete(t)},Cr=async(t,e,r,o,n,s,a=!1)=>{if(!t){e.push(0);return}let i=S(),u=i.PTR_SIZE,f=t[0],c=t[1],l=t[3],d=l,p,y;if(f==="string"&&(l==="gpu-buffer"||l==="ml-tensor"))throw new Error("String tensor is not supported on GPU.");if(a&&l!=="gpu-buffer")throw new Error(`External buffer must be provided for input/output index ${s} when enableGraphCapture is true.`);if(l==="gpu-buffer"){let h=t[2].gpuBuffer;y=le(te(f),c);{let m=i.webgpuRegisterBuffer;if(!m)throw new Error('Tensor location "gpu-buffer" is not supported without using WebGPU.');p=m(h,o)}}else if(l==="ml-tensor"){let h=t[2].mlTensor;y=le(te(f),c);let m=i.webnnRegisterMLTensor;if(!m)throw new Error('Tensor location "ml-tensor" is not supported without using WebNN.');p=m(o,h,te(f),c)}else{let h=t[2];if(Array.isArray(h)){y=u*h.length,p=i._malloc(y),r.push(p);for(let m=0;m<h.length;m++){if(typeof h[m]!="string")throw new TypeError(`tensor data at index ${m} is not a string`);i.setValue(p+m*u,F(h[m],r),"*")}}else{let m=i.webnnIsGraphInput,A=i.webnnIsGraphOutput;if(f!=="string"&&m&&A){let w=i.UTF8ToString(n);if(m(o,w)||A(o,w)){let I=te(f);y=le(I,c),d="ml-tensor";let D=i.webnnCreateTemporaryTensor,k=i.webnnUploadTensor;if(!D||!k)throw new Error('Tensor location "ml-tensor" is not supported without using WebNN.');let C=await D(o,I,c);k(C,new Uint8Array(h.buffer,h.byteOffset,h.byteLength)),p=C}else y=h.byteLength,p=i._malloc(y),r.push(p),i.HEAPU8.set(new Uint8Array(h.buffer,h.byteOffset,y),p)}else y=h.byteLength,p=i._malloc(y),r.push(p),i.HEAPU8.set(new Uint8Array(h.buffer,h.byteOffset,y),p)}}let g=i.stackSave(),L=i.stackAlloc(4*c.length);try{c.forEach((m,A)=>i.setValue(L+A*u,m,u===4?"i32":"i64"));let h=i._OrtCreateTensor(te(f),p,y,L,c.length,yt(d));h===0&&E(`Can't create tensor for input/output. session=${o}, index=${s}.`),e.push(h)}finally{i.stackRestore(g)}},_e=async(t,e,r,o,n,s)=>{let a=S(),i=a.PTR_SIZE,u=ce.get(t);if(!u)throw new Error(`cannot run inference. invalid session id: ${t}`);let f=u[0],c=u[1],l=u[2],d=u[3],p=u[4],y=u[5],g=e.length,L=o.length,h=0,m=[],A=[],w=[],I=[],D=[],k=a.stackSave(),C=a.stackAlloc(g*i),W=a.stackAlloc(g*i),j=a.stackAlloc(L*i),At=a.stackAlloc(L*i);try{[h,m]=hr(s),Z("wasm prepareInputOutputTensor");for(let b=0;b<g;b++)await Cr(r[b],A,I,t,c[e[b]],e[b],p);for(let b=0;b<L;b++)await Cr(n[b],w,I,t,l[o[b]],g+o[b],p);K("wasm prepareInputOutputTensor");for(let b=0;b<g;b++)a.setValue(C+b*i,A[b],"*"),a.setValue(W+b*i,c[e[b]],"*");for(let b=0;b<L;b++)a.setValue(j+b*i,w[b],"*"),a.setValue(At+b*i,l[o[b]],"*");if(d&&!y){let{handle:b,outputPreferredLocations:$,outputPreferredLocationsEncoded:Ke}=d;if(c.length!==g)throw new Error(`input count from feeds (${g}) is expected to be always equal to model's input count (${c.length}).`);Z("wasm bindInputsOutputs");for(let M=0;M<g;M++){let H=e[M];await a._OrtBindInput(b,c[H],A[M])!==0&&E(`Can't bind input[${M}] for session=${t}.`)}for(let M=0;M<L;M++){let H=o[M];n[M]?.[3]?(D.push(w[M]),a._OrtBindOutput(b,l[H],w[M],0)!==0&&E(`Can't bind pre-allocated output[${M}] for session=${t}.`)):a._OrtBindOutput(b,l[H],0,Ke[H])!==0&&E(`Can't bind output[${M}] to ${$[M]} for session=${t}.`)}K("wasm bindInputsOutputs"),ce.set(t,[f,c,l,d,p,!0])}a.jsepOnRunStart?.(f),a.webnnOnRunStart?.(f);let B;d?B=await a._OrtRunWithBinding(f,d.handle,L,j,h):B=await a._OrtRun(f,W,C,g,At,L,j,h),B!==0&&E("failed to call OrtRun().");let J=[],vt=[];Z("wasm ProcessOutputTensor");for(let b=0;b<L;b++){let $=Number(a.getValue(j+b*i,"*"));if($===w[b]||D.includes(w[b])){J.push(n[b]),$!==w[b]&&a._OrtReleaseTensor($)!==0&&E("Can't release tensor.");continue}let Ke=a.stackSave(),M=a.stackAlloc(4*i),H=!1,O,N=0;try{a._OrtGetTensorData($,M,M+i,M+2*i,M+3*i)!==0&&E(`Can't access output tensor data on index ${b}.`);let Qe=i===4?"i32":"i64",Ie=Number(a.getValue(M,Qe));N=a.getValue(M+i,"*");let Mt=a.getValue(M+i*2,"*"),jr=Number(a.getValue(M+i*3,Qe)),Y=[];for(let P=0;P<jr;P++)Y.push(Number(a.getValue(Mt+P*i,Qe)));a._OrtFree(Mt)!==0&&E("Can't free memory for tensor dims.");let q=Y.reduce((P,x)=>P*x,1);O=Ge(Ie);let he=d?.outputPreferredLocations[o[b]];if(O==="string"){if(he==="gpu-buffer"||he==="ml-tensor")throw new Error("String tensor is not supported on GPU.");let P=[];for(let x=0;x<q;x++){let X=a.getValue(N+x*i,"*"),ye=a.getValue(N+(x+1)*i,"*"),et=x===q-1?void 0:ye-X;P.push(a.UTF8ToString(X,et))}J.push([O,Y,P,"cpu"])}else if(he==="gpu-buffer"&&q>0){let P=a.webgpuGetBuffer;if(!P)throw new Error('preferredLocation "gpu-buffer" is not supported without using WebGPU.');let x=P(N),X=le(Ie,q);if(X===void 0||!$e(O))throw new Error(`Unsupported data type: ${O}`);H=!0;{a.webgpuRegisterBuffer(x,t,N);let ye=a.webgpuCreateDownloader(x,X,t);J.push([O,Y,{gpuBuffer:x,download:async()=>{let et=await ye();return new(ue(O))(et)},dispose:()=>{a._OrtReleaseTensor($)!==0&&E("Can't release tensor.")}},"gpu-buffer"])}}else if(he==="ml-tensor"&&q>0){let P=a.webnnEnsureTensor,x=a.webnnIsGraphInputOutputTypeSupported;if(!P||!x)throw new Error('preferredLocation "ml-tensor" is not supported without using WebNN.');if(le(Ie,q)===void 0||!ze(O))throw new Error(`Unsupported data type: ${O}`);if(!x(t,O,!1))throw new Error(`preferredLocation "ml-tensor" for ${O} output is not supported by current WebNN Context.`);let ye=await P(t,N,Ie,Y,!1);H=!0,J.push([O,Y,{mlTensor:ye,download:a.webnnCreateMLTensorDownloader(N,O),dispose:()=>{a.webnnReleaseTensorId(N),a._OrtReleaseTensor($)}},"ml-tensor"])}else if(he==="ml-tensor-cpu-output"&&q>0){let P=a.webnnCreateMLTensorDownloader(N,O)(),x=J.length;H=!0,vt.push((async()=>{let X=[x,await P];return a.webnnReleaseTensorId(N),a._OrtReleaseTensor($),X})()),J.push([O,Y,[],"cpu"])}else{let P=ue(O),x=new P(q);new Uint8Array(x.buffer,x.byteOffset,x.byteLength).set(a.HEAPU8.subarray(N,N+x.byteLength)),J.push([O,Y,x,"cpu"])}}finally{a.stackRestore(Ke),O==="string"&&N&&a._free(N),H||a._OrtReleaseTensor($)}}d&&!p&&(a._OrtClearBoundOutputs(d.handle)!==0&&E("Can't clear bound outputs."),ce.set(t,[f,c,l,d,p,!1]));for(let[b,$]of await Promise.all(vt))J[b][2]=$;return K("wasm ProcessOutputTensor"),J}finally{a.webnnOnRunEnd?.(f),a.stackRestore(k),r.forEach(B=>{B&&B[3]==="gpu-buffer"&&a.webgpuUnregisterBuffer(B[2].gpuBuffer)}),n.forEach(B=>{B&&B[3]==="gpu-buffer"&&a.webgpuUnregisterBuffer(B[2].gpuBuffer)}),A.forEach(B=>a._OrtReleaseTensor(B)),w.forEach(B=>a._OrtReleaseTensor(B)),I.forEach(B=>a._free(B)),h!==0&&a._OrtReleaseRunOptions(h),m.forEach(B=>a._free(B))}},Re=t=>{let e=S(),r=ce.get(t);if(!r)throw new Error("invalid session id");let o=r[0],n=e._OrtEndProfiling(o);n===0&&E("Can't get an profile file name."),e._OrtFree(n)},Ne=t=>{let e=[];for(let r of t){let o=r[2];!Array.isArray(o)&&"buffer"in o&&e.push(o.buffer)}return e}});var de,z,Se,Ye,qe,Je,St,It,pe,me,Sn,Pr,_r,Rr,Nr,Fr,Wr,kr,Lt=T(()=>{"use strict";Q();ct();ee();Oe();de=()=>!!v.wasm.proxy&&typeof document<"u",Se=!1,Ye=!1,qe=!1,It=new Map,pe=(t,e)=>{let r=It.get(t);r?r.push(e):It.set(t,[e])},me=()=>{if(Se||!Ye||qe||!z)throw new Error("worker not ready")},Sn=t=>{switch(t.data.type){case"init-wasm":Se=!1,t.data.err?(qe=!0,St[1](t.data.err)):(Ye=!0,St[0]()),Je&&(URL.revokeObjectURL(Je),Je=void 0);break;case"init-ep":case"copy-from":case"create":case"release":case"run":case"end-profiling":{let e=It.get(t.data.type);t.data.err?e.shift()[1](t.data.err):e.shift()[0](t.data.out);break}default:}},Pr=async()=>{if(!Ye){if(Se)throw new Error("multiple calls to 'initWasm()' detected.");if(qe)throw new Error("previous call to 'initWasm()' failed.");if(Se=!0,de())return new Promise((t,e)=>{z?.terminate(),lr().then(([r,o])=>{try{z=o,z.onerror=s=>e(s),z.onmessage=Sn,St=[t,e];let n={type:"init-wasm",in:v};if(!n.in.wasm.wasmPaths&&r){let s=Fe();s&&(n.in.wasm.wasmPaths=s)}z.postMessage(n),Je=r}catch(n){e(n)}},e)});try{await Be(v.wasm),await Ue(v),Ye=!0}catch(t){throw qe=!0,t}finally{Se=!1}}},_r=async t=>{if(de())return me(),new Promise((e,r)=>{pe("init-ep",[e,r]);let o={type:"init-ep",in:{epName:t,env:v}};z.postMessage(o)});await De(v,t)},Rr=async t=>de()?(me(),new Promise((e,r)=>{pe("copy-from",[e,r]);let o={type:"copy-from",in:{buffer:t}};z.postMessage(o,[t.buffer])})):be(t),Nr=async(t,e)=>{if(de()){if(e?.preferredOutputLocation)throw new Error('session option "preferredOutputLocation" is not supported for proxy.');return me(),new Promise((r,o)=>{pe("create",[r,o]);let n={type:"create",in:{model:t,options:{...e}}},s=[];t instanceof Uint8Array&&s.push(t.buffer),z.postMessage(n,s)})}else return Ce(t,e)},Fr=async t=>{if(de())return me(),new Promise((e,r)=>{pe("release",[e,r]);let o={type:"release",in:t};z.postMessage(o)});Pe(t)},Wr=async(t,e,r,o,n,s)=>{if(de()){if(r.some(a=>a[3]!=="cpu"))throw new Error("input tensor on GPU is not supported for proxy.");if(n.some(a=>a))throw new Error("pre-allocated output tensor is not supported for proxy.");return me(),new Promise((a,i)=>{pe("run",[a,i]);let u=r,f={type:"run",in:{sessionId:t,inputIndices:e,inputs:u,outputIndices:o,options:s}};z.postMessage(f,Ne(u))})}else return _e(t,e,r,o,n,s)},kr=async t=>{if(de())return me(),new Promise((e,r)=>{pe("end-profiling",[e,r]);let o={type:"end-profiling",in:t};z.postMessage(o)});Re(t)}});var Gr,In,Xe,$r=T(()=>{"use strict";Q();Lt();fe();xe();wt();Gr=(t,e)=>{switch(t.location){case"cpu":return[t.type,t.dims,t.data,"cpu"];case"gpu-buffer":return[t.type,t.dims,{gpuBuffer:t.gpuBuffer},"gpu-buffer"];case"ml-tensor":return[t.type,t.dims,{mlTensor:t.mlTensor},"ml-tensor"];default:throw new Error(`invalid data location: ${t.location} for ${e()}`)}},In=t=>{switch(t[3]){case"cpu":return new V(t[0],t[2],t[1]);case"gpu-buffer":{let e=t[0];if(!$e(e))throw new Error(`not supported data type: ${e} for deserializing GPU tensor`);let{gpuBuffer:r,download:o,dispose:n}=t[2];return V.fromGpuBuffer(r,{dataType:e,dims:t[1],download:o,dispose:n})}case"ml-tensor":{let e=t[0];if(!ze(e))throw new Error(`not supported data type: ${e} for deserializing MLTensor tensor`);let{mlTensor:r,download:o,dispose:n}=t[2];return V.fromMLTensor(r,{dataType:e,dims:t[1],download:o,dispose:n})}default:throw new Error(`invalid data location: ${t[3]}`)}},Xe=class{async fetchModelAndCopyToWasmMemory(e){return Rr(await Ee(e))}async loadModel(e,r){se();let o;typeof e=="string"?o=await this.fetchModelAndCopyToWasmMemory(e):o=e,[this.sessionId,this.inputNames,this.outputNames,this.inputMetadata,this.outputMetadata]=await Nr(o,r),ae()}async dispose(){return Fr(this.sessionId)}async run(e,r,o){se();let n=[],s=[];Object.entries(e).forEach(d=>{let p=d[0],y=d[1],g=this.inputNames.indexOf(p);if(g===-1)throw new Error(`invalid input '${p}'`);n.push(y),s.push(g)});let a=[],i=[];Object.entries(r).forEach(d=>{let p=d[0],y=d[1],g=this.outputNames.indexOf(p);if(g===-1)throw new Error(`invalid output '${p}'`);a.push(y),i.push(g)});let u=n.map((d,p)=>Gr(d,()=>`input "${this.inputNames[s[p]]}"`)),f=a.map((d,p)=>d?Gr(d,()=>`output "${this.outputNames[i[p]]}"`):null),c=await Wr(this.sessionId,s,u,i,f,o),l={};for(let d=0;d<c.length;d++)l[this.outputNames[i[d]]]=a[d]??In(c[d]);return ae(),l}startProfiling(){}endProfiling(){kr(this.sessionId)}}});var Vr={};Le(Vr,{OnnxruntimeWebAssemblyBackend:()=>Ze,initializeFlags:()=>zr,wasmBackend:()=>Ln});var zr,Ze,Ln,Hr=T(()=>{"use strict";Q();Lt();$r();zr=()=>{(typeof v.wasm.initTimeout!="number"||v.wasm.initTimeout<0)&&(v.wasm.initTimeout=0);let t=v.wasm.simd;if(typeof t!="boolean"&&t!==void 0&&t!=="fixed"&&t!=="relaxed"&&(console.warn(`Property "env.wasm.simd" is set to unknown value "${t}". Reset it to \`false\` and ignore SIMD feature checking.`),v.wasm.simd=!1),typeof v.wasm.proxy!="boolean"&&(v.wasm.proxy=!1),typeof v.wasm.trace!="boolean"&&(v.wasm.trace=!1),typeof v.wasm.numThreads!="number"||!Number.isInteger(v.wasm.numThreads)||v.wasm.numThreads<=0)if(typeof self<"u"&&!self.crossOriginIsolated)v.wasm.numThreads=1;else{let e=typeof navigator>"u"?rt("node:os").cpus().length:navigator.hardwareConcurrency;v.wasm.numThreads=Math.min(4,Math.ceil((e||1)/2))}},Ze=class{async init(e){zr(),await Pr(),await _r(e)}async createInferenceSessionHandler(e,r){let o=new Xe;return await o.loadModel(e,r),o}},Ln=new Ze});Q();Q();Q();var nr="1.23.0";var Ls=ft;{let t=(Hr(),nt(Vr)).wasmBackend;ne("webgpu",t,5),ne("webnn",t,5),ne("cpu",t,10),ne("wasm",t,10)}Object.defineProperty(v.versions,"web",{value:nr,enumerable:!0});export{Kr as InferenceSession,qt as TRACE,Z as TRACE_EVENT_BEGIN,K as TRACE_EVENT_END,se as TRACE_FUNC_BEGIN,ae as TRACE_FUNC_END,V as Tensor,Ls as default,v as env,ne as registerBackend};
//# sourceMappingURL=ort.webgpu.min.mjs.map
