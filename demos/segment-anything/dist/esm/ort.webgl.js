/*!
 * ONNX Runtime Web v1.18.0
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod2) => function __require() {
  return mod2 || (0, cb[__getOwnPropNames(cb)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;
};
var __export = (target, all) => {
  for (var name2 in all)
    __defProp(target, name2, { get: all[name2], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod2, isNodeMode, target) => (target = mod2 != null ? __create(__getProtoOf(mod2)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod2 || !mod2.__esModule ? __defProp(target, "default", { value: mod2, enumerable: true }) : target,
  mod2
));
var __toCommonJS = (mod2) => __copyProps(__defProp({}, "__esModule", { value: true }), mod2);

// common/dist/esm/backend-impl.js
var backends, backendsSortedByPriority, registerBackend, tryResolveAndInitializeBackend, resolveBackendAndExecutionProviders;
var init_backend_impl = __esm({
  "common/dist/esm/backend-impl.js"() {
    "use strict";
    backends = /* @__PURE__ */ new Map();
    backendsSortedByPriority = [];
    registerBackend = (name2, backend2, priority) => {
      if (backend2 && typeof backend2.init === "function" && typeof backend2.createInferenceSessionHandler === "function") {
        const currentBackend = backends.get(name2);
        if (currentBackend === void 0) {
          backends.set(name2, { backend: backend2, priority });
        } else if (currentBackend.priority > priority) {
          return;
        } else if (currentBackend.priority === priority) {
          if (currentBackend.backend !== backend2) {
            throw new Error(`cannot register backend "${name2}" using priority ${priority}`);
          }
        }
        if (priority >= 0) {
          const i = backendsSortedByPriority.indexOf(name2);
          if (i !== -1) {
            backendsSortedByPriority.splice(i, 1);
          }
          for (let i2 = 0; i2 < backendsSortedByPriority.length; i2++) {
            if (backends.get(backendsSortedByPriority[i2]).priority <= priority) {
              backendsSortedByPriority.splice(i2, 0, name2);
              return;
            }
          }
          backendsSortedByPriority.push(name2);
        }
        return;
      }
      throw new TypeError("not a valid backend");
    };
    tryResolveAndInitializeBackend = async (backendName) => {
      const backendInfo = backends.get(backendName);
      if (!backendInfo) {
        return "backend not found.";
      }
      if (backendInfo.initialized) {
        return backendInfo.backend;
      } else if (backendInfo.aborted) {
        return backendInfo.error;
      } else {
        const isInitializing = !!backendInfo.initPromise;
        try {
          if (!isInitializing) {
            backendInfo.initPromise = backendInfo.backend.init(backendName);
          }
          await backendInfo.initPromise;
          backendInfo.initialized = true;
          return backendInfo.backend;
        } catch (e) {
          if (!isInitializing) {
            backendInfo.error = `${e}`;
            backendInfo.aborted = true;
          }
          return backendInfo.error;
        } finally {
          delete backendInfo.initPromise;
        }
      }
    };
    resolveBackendAndExecutionProviders = async (options) => {
      const eps = options.executionProviders || [];
      const backendHints = eps.map((i) => typeof i === "string" ? i : i.name);
      const backendNames = backendHints.length === 0 ? backendsSortedByPriority : backendHints;
      let backend2;
      const errors = [];
      const availableBackendNames = /* @__PURE__ */ new Set();
      for (const backendName of backendNames) {
        const resolveResult = await tryResolveAndInitializeBackend(backendName);
        if (typeof resolveResult === "string") {
          errors.push({ name: backendName, err: resolveResult });
        } else {
          if (!backend2) {
            backend2 = resolveResult;
          }
          if (backend2 === resolveResult) {
            availableBackendNames.add(backendName);
          }
        }
      }
      if (!backend2) {
        throw new Error(`no available backend found. ERR: ${errors.map((e) => `[${e.name}] ${e.err}`).join(", ")}`);
      }
      for (const { name: name2, err } of errors) {
        if (backendHints.includes(name2)) {
          console.warn(`removing requested execution provider "${name2}" from session options because it is not available: ${err}`);
        }
      }
      const filteredEps = eps.filter((i) => availableBackendNames.has(typeof i === "string" ? i : i.name));
      return [
        backend2,
        new Proxy(options, {
          get: (target, prop) => {
            if (prop === "executionProviders") {
              return filteredEps;
            }
            return Reflect.get(target, prop);
          }
        })
      ];
    };
  }
});

// common/dist/esm/backend.js
var init_backend = __esm({
  "common/dist/esm/backend.js"() {
    "use strict";
    init_backend_impl();
  }
});

// common/dist/esm/version.js
var version;
var init_version = __esm({
  "common/dist/esm/version.js"() {
    "use strict";
    version = "1.18.0";
  }
});

// common/dist/esm/env-impl.js
var logLevelValue, env;
var init_env_impl = __esm({
  "common/dist/esm/env-impl.js"() {
    "use strict";
    init_version();
    logLevelValue = "warning";
    env = {
      wasm: {},
      webgl: {},
      webgpu: {},
      versions: { common: version },
      set logLevel(value) {
        if (value === void 0) {
          return;
        }
        if (typeof value !== "string" || ["verbose", "info", "warning", "error", "fatal"].indexOf(value) === -1) {
          throw new Error(`Unsupported logging level: ${value}`);
        }
        logLevelValue = value;
      },
      get logLevel() {
        return logLevelValue;
      }
    };
    Object.defineProperty(env, "logLevel", { enumerable: true });
  }
});

// common/dist/esm/env.js
var env2;
var init_env = __esm({
  "common/dist/esm/env.js"() {
    "use strict";
    init_env_impl();
    env2 = env;
  }
});

// common/dist/esm/tensor-conversion-impl.js
var tensorToDataURL, tensorToImageData;
var init_tensor_conversion_impl = __esm({
  "common/dist/esm/tensor-conversion-impl.js"() {
    "use strict";
    tensorToDataURL = (tensor, options) => {
      const canvas = typeof document !== "undefined" ? document.createElement("canvas") : new OffscreenCanvas(1, 1);
      canvas.width = tensor.dims[3];
      canvas.height = tensor.dims[2];
      const pixels2DContext = canvas.getContext("2d");
      if (pixels2DContext != null) {
        let width;
        let height;
        if (options?.tensorLayout !== void 0 && options.tensorLayout === "NHWC") {
          width = tensor.dims[2];
          height = tensor.dims[3];
        } else {
          width = tensor.dims[3];
          height = tensor.dims[2];
        }
        const inputformat = options?.format !== void 0 ? options.format : "RGB";
        const norm = options?.norm;
        let normMean;
        let normBias;
        if (norm === void 0 || norm.mean === void 0) {
          normMean = [255, 255, 255, 255];
        } else {
          if (typeof norm.mean === "number") {
            normMean = [norm.mean, norm.mean, norm.mean, norm.mean];
          } else {
            normMean = [norm.mean[0], norm.mean[1], norm.mean[2], 0];
            if (norm.mean[3] !== void 0) {
              normMean[3] = norm.mean[3];
            }
          }
        }
        if (norm === void 0 || norm.bias === void 0) {
          normBias = [0, 0, 0, 0];
        } else {
          if (typeof norm.bias === "number") {
            normBias = [norm.bias, norm.bias, norm.bias, norm.bias];
          } else {
            normBias = [norm.bias[0], norm.bias[1], norm.bias[2], 0];
            if (norm.bias[3] !== void 0) {
              normBias[3] = norm.bias[3];
            }
          }
        }
        const stride = height * width;
        let rTensorPointer = 0, gTensorPointer = stride, bTensorPointer = stride * 2, aTensorPointer = -1;
        if (inputformat === "RGBA") {
          rTensorPointer = 0;
          gTensorPointer = stride;
          bTensorPointer = stride * 2;
          aTensorPointer = stride * 3;
        } else if (inputformat === "RGB") {
          rTensorPointer = 0;
          gTensorPointer = stride;
          bTensorPointer = stride * 2;
        } else if (inputformat === "RBG") {
          rTensorPointer = 0;
          bTensorPointer = stride;
          gTensorPointer = stride * 2;
        }
        for (let i = 0; i < height; i++) {
          for (let j = 0; j < width; j++) {
            const R = (tensor.data[rTensorPointer++] - normBias[0]) * normMean[0];
            const G = (tensor.data[gTensorPointer++] - normBias[1]) * normMean[1];
            const B = (tensor.data[bTensorPointer++] - normBias[2]) * normMean[2];
            const A = aTensorPointer === -1 ? 255 : (tensor.data[aTensorPointer++] - normBias[3]) * normMean[3];
            pixels2DContext.fillStyle = "rgba(" + R + "," + G + "," + B + "," + A + ")";
            pixels2DContext.fillRect(j, i, 1, 1);
          }
        }
        if ("toDataURL" in canvas) {
          return canvas.toDataURL();
        } else {
          throw new Error("toDataURL is not supported");
        }
      } else {
        throw new Error("Can not access image data");
      }
    };
    tensorToImageData = (tensor, options) => {
      const pixels2DContext = typeof document !== "undefined" ? document.createElement("canvas").getContext("2d") : new OffscreenCanvas(1, 1).getContext("2d");
      let image;
      if (pixels2DContext != null) {
        let width;
        let height;
        let channels;
        if (options?.tensorLayout !== void 0 && options.tensorLayout === "NHWC") {
          width = tensor.dims[2];
          height = tensor.dims[1];
          channels = tensor.dims[3];
        } else {
          width = tensor.dims[3];
          height = tensor.dims[2];
          channels = tensor.dims[1];
        }
        const inputformat = options !== void 0 ? options.format !== void 0 ? options.format : "RGB" : "RGB";
        const norm = options?.norm;
        let normMean;
        let normBias;
        if (norm === void 0 || norm.mean === void 0) {
          normMean = [255, 255, 255, 255];
        } else {
          if (typeof norm.mean === "number") {
            normMean = [norm.mean, norm.mean, norm.mean, norm.mean];
          } else {
            normMean = [norm.mean[0], norm.mean[1], norm.mean[2], 255];
            if (norm.mean[3] !== void 0) {
              normMean[3] = norm.mean[3];
            }
          }
        }
        if (norm === void 0 || norm.bias === void 0) {
          normBias = [0, 0, 0, 0];
        } else {
          if (typeof norm.bias === "number") {
            normBias = [norm.bias, norm.bias, norm.bias, norm.bias];
          } else {
            normBias = [norm.bias[0], norm.bias[1], norm.bias[2], 0];
            if (norm.bias[3] !== void 0) {
              normBias[3] = norm.bias[3];
            }
          }
        }
        const stride = height * width;
        if (options !== void 0) {
          if (options.format !== void 0 && (channels === 4 && options.format !== "RGBA") || channels === 3 && (options.format !== "RGB" && options.format !== "BGR")) {
            throw new Error("Tensor format doesn't match input tensor dims");
          }
        }
        const step = 4;
        let rImagePointer = 0, gImagePointer = 1, bImagePointer = 2, aImagePointer = 3;
        let rTensorPointer = 0, gTensorPointer = stride, bTensorPointer = stride * 2, aTensorPointer = -1;
        if (inputformat === "RGBA") {
          rTensorPointer = 0;
          gTensorPointer = stride;
          bTensorPointer = stride * 2;
          aTensorPointer = stride * 3;
        } else if (inputformat === "RGB") {
          rTensorPointer = 0;
          gTensorPointer = stride;
          bTensorPointer = stride * 2;
        } else if (inputformat === "RBG") {
          rTensorPointer = 0;
          bTensorPointer = stride;
          gTensorPointer = stride * 2;
        }
        image = pixels2DContext.createImageData(width, height);
        for (let i = 0; i < height * width; rImagePointer += step, gImagePointer += step, bImagePointer += step, aImagePointer += step, i++) {
          image.data[rImagePointer] = (tensor.data[rTensorPointer++] - normBias[0]) * normMean[0];
          image.data[gImagePointer] = (tensor.data[gTensorPointer++] - normBias[1]) * normMean[1];
          image.data[bImagePointer] = (tensor.data[bTensorPointer++] - normBias[2]) * normMean[2];
          image.data[aImagePointer] = aTensorPointer === -1 ? 255 : (tensor.data[aTensorPointer++] - normBias[3]) * normMean[3];
        }
      } else {
        throw new Error("Can not access image data");
      }
      return image;
    };
  }
});

// common/dist/esm/tensor-factory-impl.js
var bufferToTensor, tensorFromImage, tensorFromTexture, tensorFromGpuBuffer, tensorFromPinnedBuffer;
var init_tensor_factory_impl = __esm({
  "common/dist/esm/tensor-factory-impl.js"() {
    "use strict";
    init_tensor_impl();
    bufferToTensor = (buffer, options) => {
      if (buffer === void 0) {
        throw new Error("Image buffer must be defined");
      }
      if (options.height === void 0 || options.width === void 0) {
        throw new Error("Image height and width must be defined");
      }
      if (options.tensorLayout === "NHWC") {
        throw new Error("NHWC Tensor layout is not supported yet");
      }
      const { height, width } = options;
      const norm = options.norm ?? { mean: 255, bias: 0 };
      let normMean;
      let normBias;
      if (typeof norm.mean === "number") {
        normMean = [norm.mean, norm.mean, norm.mean, norm.mean];
      } else {
        normMean = [norm.mean[0], norm.mean[1], norm.mean[2], norm.mean[3] ?? 255];
      }
      if (typeof norm.bias === "number") {
        normBias = [norm.bias, norm.bias, norm.bias, norm.bias];
      } else {
        normBias = [norm.bias[0], norm.bias[1], norm.bias[2], norm.bias[3] ?? 0];
      }
      const inputformat = options.format !== void 0 ? options.format : "RGBA";
      const outputformat = options.tensorFormat !== void 0 ? options.tensorFormat !== void 0 ? options.tensorFormat : "RGB" : "RGB";
      const stride = height * width;
      const float32Data = outputformat === "RGBA" ? new Float32Array(stride * 4) : new Float32Array(stride * 3);
      let step = 4, rImagePointer = 0, gImagePointer = 1, bImagePointer = 2, aImagePointer = 3;
      let rTensorPointer = 0, gTensorPointer = stride, bTensorPointer = stride * 2, aTensorPointer = -1;
      if (inputformat === "RGB") {
        step = 3;
        rImagePointer = 0;
        gImagePointer = 1;
        bImagePointer = 2;
        aImagePointer = -1;
      }
      if (outputformat === "RGBA") {
        aTensorPointer = stride * 3;
      } else if (outputformat === "RBG") {
        rTensorPointer = 0;
        bTensorPointer = stride;
        gTensorPointer = stride * 2;
      } else if (outputformat === "BGR") {
        bTensorPointer = 0;
        gTensorPointer = stride;
        rTensorPointer = stride * 2;
      }
      for (let i = 0; i < stride; i++, rImagePointer += step, bImagePointer += step, gImagePointer += step, aImagePointer += step) {
        float32Data[rTensorPointer++] = (buffer[rImagePointer] + normBias[0]) / normMean[0];
        float32Data[gTensorPointer++] = (buffer[gImagePointer] + normBias[1]) / normMean[1];
        float32Data[bTensorPointer++] = (buffer[bImagePointer] + normBias[2]) / normMean[2];
        if (aTensorPointer !== -1 && aImagePointer !== -1) {
          float32Data[aTensorPointer++] = (buffer[aImagePointer] + normBias[3]) / normMean[3];
        }
      }
      const outputTensor = outputformat === "RGBA" ? new Tensor("float32", float32Data, [1, 4, height, width]) : new Tensor("float32", float32Data, [1, 3, height, width]);
      return outputTensor;
    };
    tensorFromImage = async (image, options) => {
      const isHTMLImageEle = typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement;
      const isImageDataEle = typeof ImageData !== "undefined" && image instanceof ImageData;
      const isImageBitmap = typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap;
      const isString = typeof image === "string";
      let data;
      let bufferToTensorOptions = options ?? {};
      const createCanvas2 = () => {
        if (typeof document !== "undefined") {
          return document.createElement("canvas");
        } else if (typeof OffscreenCanvas !== "undefined") {
          return new OffscreenCanvas(1, 1);
        } else {
          throw new Error("Canvas is not supported");
        }
      };
      const createCanvasContext = (canvas) => {
        if (canvas instanceof HTMLCanvasElement) {
          return canvas.getContext("2d");
        } else if (canvas instanceof OffscreenCanvas) {
          return canvas.getContext("2d");
        } else {
          return null;
        }
      };
      if (isHTMLImageEle) {
        const canvas = createCanvas2();
        canvas.width = image.width;
        canvas.height = image.height;
        const pixels2DContext = createCanvasContext(canvas);
        if (pixels2DContext != null) {
          let height = image.height;
          let width = image.width;
          if (options !== void 0 && options.resizedHeight !== void 0 && options.resizedWidth !== void 0) {
            height = options.resizedHeight;
            width = options.resizedWidth;
          }
          if (options !== void 0) {
            bufferToTensorOptions = options;
            if (options.tensorFormat !== void 0) {
              throw new Error("Image input config format must be RGBA for HTMLImageElement");
            } else {
              bufferToTensorOptions.tensorFormat = "RGBA";
            }
            bufferToTensorOptions.height = height;
            bufferToTensorOptions.width = width;
          } else {
            bufferToTensorOptions.tensorFormat = "RGBA";
            bufferToTensorOptions.height = height;
            bufferToTensorOptions.width = width;
          }
          pixels2DContext.drawImage(image, 0, 0);
          data = pixels2DContext.getImageData(0, 0, width, height).data;
        } else {
          throw new Error("Can not access image data");
        }
      } else if (isImageDataEle) {
        let height;
        let width;
        if (options !== void 0 && options.resizedWidth !== void 0 && options.resizedHeight !== void 0) {
          height = options.resizedHeight;
          width = options.resizedWidth;
        } else {
          height = image.height;
          width = image.width;
        }
        if (options !== void 0) {
          bufferToTensorOptions = options;
        }
        bufferToTensorOptions.format = "RGBA";
        bufferToTensorOptions.height = height;
        bufferToTensorOptions.width = width;
        if (options !== void 0) {
          const tempCanvas = createCanvas2();
          tempCanvas.width = width;
          tempCanvas.height = height;
          const pixels2DContext = createCanvasContext(tempCanvas);
          if (pixels2DContext != null) {
            pixels2DContext.putImageData(image, 0, 0);
            data = pixels2DContext.getImageData(0, 0, width, height).data;
          } else {
            throw new Error("Can not access image data");
          }
        } else {
          data = image.data;
        }
      } else if (isImageBitmap) {
        if (options === void 0) {
          throw new Error("Please provide image config with format for Imagebitmap");
        }
        const canvas = createCanvas2();
        canvas.width = image.width;
        canvas.height = image.height;
        const pixels2DContext = createCanvasContext(canvas);
        if (pixels2DContext != null) {
          const height = image.height;
          const width = image.width;
          pixels2DContext.drawImage(image, 0, 0, width, height);
          data = pixels2DContext.getImageData(0, 0, width, height).data;
          bufferToTensorOptions.height = height;
          bufferToTensorOptions.width = width;
          return bufferToTensor(data, bufferToTensorOptions);
        } else {
          throw new Error("Can not access image data");
        }
      } else if (isString) {
        return new Promise((resolve, reject) => {
          const canvas = createCanvas2();
          const context = createCanvasContext(canvas);
          if (!image || !context) {
            return reject();
          }
          const newImage = new Image();
          newImage.crossOrigin = "Anonymous";
          newImage.src = image;
          newImage.onload = () => {
            canvas.width = newImage.width;
            canvas.height = newImage.height;
            context.drawImage(newImage, 0, 0, canvas.width, canvas.height);
            const img = context.getImageData(0, 0, canvas.width, canvas.height);
            bufferToTensorOptions.height = canvas.height;
            bufferToTensorOptions.width = canvas.width;
            resolve(bufferToTensor(img.data, bufferToTensorOptions));
          };
        });
      } else {
        throw new Error("Input data provided is not supported - aborted tensor creation");
      }
      if (data !== void 0) {
        return bufferToTensor(data, bufferToTensorOptions);
      } else {
        throw new Error("Input data provided is not supported - aborted tensor creation");
      }
    };
    tensorFromTexture = (texture, options) => {
      const { width, height, download, dispose } = options;
      const dims = [1, height, width, 4];
      return new Tensor({ location: "texture", type: "float32", texture, dims, download, dispose });
    };
    tensorFromGpuBuffer = (gpuBuffer, options) => {
      const { dataType, dims, download, dispose } = options;
      return new Tensor({ location: "gpu-buffer", type: dataType ?? "float32", gpuBuffer, dims, download, dispose });
    };
    tensorFromPinnedBuffer = (type, buffer, dims) => new Tensor({ location: "cpu-pinned", type, data: buffer, dims: dims ?? [buffer.length] });
  }
});

// common/dist/esm/tensor-impl-type-mapping.js
var NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP, NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP, isTypedArrayChecked, checkTypedArray;
var init_tensor_impl_type_mapping = __esm({
  "common/dist/esm/tensor-impl-type-mapping.js"() {
    "use strict";
    NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP = /* @__PURE__ */ new Map([
      ["float32", Float32Array],
      ["uint8", Uint8Array],
      ["int8", Int8Array],
      ["uint16", Uint16Array],
      ["int16", Int16Array],
      ["int32", Int32Array],
      ["bool", Uint8Array],
      ["float64", Float64Array],
      ["uint32", Uint32Array]
    ]);
    NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP = /* @__PURE__ */ new Map([
      [Float32Array, "float32"],
      [Uint8Array, "uint8"],
      [Int8Array, "int8"],
      [Uint16Array, "uint16"],
      [Int16Array, "int16"],
      [Int32Array, "int32"],
      [Float64Array, "float64"],
      [Uint32Array, "uint32"]
    ]);
    isTypedArrayChecked = false;
    checkTypedArray = () => {
      if (!isTypedArrayChecked) {
        isTypedArrayChecked = true;
        const isBigInt64ArrayAvailable = typeof BigInt64Array !== "undefined" && BigInt64Array.from;
        const isBigUint64ArrayAvailable = typeof BigUint64Array !== "undefined" && BigUint64Array.from;
        const isFloat16ArrayAvailable = typeof Float16Array !== "undefined" && Float16Array.from;
        if (isBigInt64ArrayAvailable) {
          NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set("int64", BigInt64Array);
          NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(BigInt64Array, "int64");
        }
        if (isBigUint64ArrayAvailable) {
          NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set("uint64", BigUint64Array);
          NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(BigUint64Array, "uint64");
        }
        if (isFloat16ArrayAvailable) {
          NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set("float16", Float16Array);
          NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(Float16Array, "float16");
        } else {
          NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set("float16", Uint16Array);
        }
      }
    };
  }
});

// common/dist/esm/tensor-utils-impl.js
var calculateSize, tensorReshape;
var init_tensor_utils_impl = __esm({
  "common/dist/esm/tensor-utils-impl.js"() {
    "use strict";
    init_tensor_impl();
    calculateSize = (dims) => {
      let size = 1;
      for (let i = 0; i < dims.length; i++) {
        const dim = dims[i];
        if (typeof dim !== "number" || !Number.isSafeInteger(dim)) {
          throw new TypeError(`dims[${i}] must be an integer, got: ${dim}`);
        }
        if (dim < 0) {
          throw new RangeError(`dims[${i}] must be a non-negative integer, got: ${dim}`);
        }
        size *= dim;
      }
      return size;
    };
    tensorReshape = (tensor, dims) => {
      switch (tensor.location) {
        case "cpu":
          return new Tensor(tensor.type, tensor.data, dims);
        case "cpu-pinned":
          return new Tensor({
            location: "cpu-pinned",
            data: tensor.data,
            type: tensor.type,
            dims
          });
        case "texture":
          return new Tensor({
            location: "texture",
            texture: tensor.texture,
            type: tensor.type,
            dims
          });
        case "gpu-buffer":
          return new Tensor({
            location: "gpu-buffer",
            gpuBuffer: tensor.gpuBuffer,
            type: tensor.type,
            dims
          });
        default:
          throw new Error(`tensorReshape: tensor location ${tensor.location} is not supported`);
      }
    };
  }
});

// common/dist/esm/tensor-impl.js
var Tensor;
var init_tensor_impl = __esm({
  "common/dist/esm/tensor-impl.js"() {
    "use strict";
    init_tensor_conversion_impl();
    init_tensor_factory_impl();
    init_tensor_impl_type_mapping();
    init_tensor_utils_impl();
    Tensor = class {
      /**
       * implementation.
       */
      constructor(arg0, arg1, arg2) {
        checkTypedArray();
        let type;
        let dims;
        if (typeof arg0 === "object" && "location" in arg0) {
          this.dataLocation = arg0.location;
          type = arg0.type;
          dims = arg0.dims;
          switch (arg0.location) {
            case "cpu-pinned": {
              const expectedTypedArrayConstructor = NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.get(type);
              if (!expectedTypedArrayConstructor) {
                throw new TypeError(`unsupported type "${type}" to create tensor from pinned buffer`);
              }
              if (!(arg0.data instanceof expectedTypedArrayConstructor)) {
                throw new TypeError(`buffer should be of type ${expectedTypedArrayConstructor.name}`);
              }
              this.cpuData = arg0.data;
              break;
            }
            case "texture": {
              if (type !== "float32") {
                throw new TypeError(`unsupported type "${type}" to create tensor from texture`);
              }
              this.gpuTextureData = arg0.texture;
              this.downloader = arg0.download;
              this.disposer = arg0.dispose;
              break;
            }
            case "gpu-buffer": {
              if (type !== "float32" && type !== "float16" && type !== "int32" && type !== "int64" && type !== "uint32" && type !== "uint8" && type !== "bool") {
                throw new TypeError(`unsupported type "${type}" to create tensor from gpu buffer`);
              }
              this.gpuBufferData = arg0.gpuBuffer;
              this.downloader = arg0.download;
              this.disposer = arg0.dispose;
              break;
            }
            default:
              throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`);
          }
        } else {
          let data;
          let maybeDims;
          if (typeof arg0 === "string") {
            type = arg0;
            maybeDims = arg2;
            if (arg0 === "string") {
              if (!Array.isArray(arg1)) {
                throw new TypeError("A string tensor's data must be a string array.");
              }
              data = arg1;
            } else {
              const typedArrayConstructor = NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.get(arg0);
              if (typedArrayConstructor === void 0) {
                throw new TypeError(`Unsupported tensor type: ${arg0}.`);
              }
              if (Array.isArray(arg1)) {
                if (arg0 === "float16" && typedArrayConstructor === Uint16Array) {
                  throw new TypeError("Creating a float16 tensor from number array is not supported. Please use Uint16Array as data.");
                } else if (arg0 === "uint64" || arg0 === "int64") {
                  data = typedArrayConstructor.from(arg1, BigInt);
                } else {
                  data = typedArrayConstructor.from(arg1);
                }
              } else if (arg1 instanceof typedArrayConstructor) {
                data = arg1;
              } else {
                throw new TypeError(`A ${type} tensor's data must be type of ${typedArrayConstructor}`);
              }
            }
          } else {
            maybeDims = arg1;
            if (Array.isArray(arg0)) {
              if (arg0.length === 0) {
                throw new TypeError("Tensor type cannot be inferred from an empty array.");
              }
              const firstElementType = typeof arg0[0];
              if (firstElementType === "string") {
                type = "string";
                data = arg0;
              } else if (firstElementType === "boolean") {
                type = "bool";
                data = Uint8Array.from(arg0);
              } else {
                throw new TypeError(`Invalid element type of data array: ${firstElementType}.`);
              }
            } else {
              const mappedType = NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.get(arg0.constructor);
              if (mappedType === void 0) {
                throw new TypeError(`Unsupported type for tensor data: ${arg0.constructor}.`);
              }
              type = mappedType;
              data = arg0;
            }
          }
          if (maybeDims === void 0) {
            maybeDims = [data.length];
          } else if (!Array.isArray(maybeDims)) {
            throw new TypeError("A tensor's dims must be a number array");
          }
          dims = maybeDims;
          this.cpuData = data;
          this.dataLocation = "cpu";
        }
        const size = calculateSize(dims);
        if (this.cpuData && size !== this.cpuData.length) {
          throw new Error(`Tensor's size(${size}) does not match data length(${this.cpuData.length}).`);
        }
        this.type = type;
        this.dims = dims;
        this.size = size;
      }
      // #endregion
      // #region factory
      static async fromImage(image, options) {
        return tensorFromImage(image, options);
      }
      static fromTexture(texture, options) {
        return tensorFromTexture(texture, options);
      }
      static fromGpuBuffer(gpuBuffer, options) {
        return tensorFromGpuBuffer(gpuBuffer, options);
      }
      static fromPinnedBuffer(type, buffer, dims) {
        return tensorFromPinnedBuffer(type, buffer, dims);
      }
      // #endregion
      // #region conversions
      toDataURL(options) {
        return tensorToDataURL(this, options);
      }
      toImageData(options) {
        return tensorToImageData(this, options);
      }
      // #endregion
      // #region properties
      get data() {
        this.ensureValid();
        if (!this.cpuData) {
          throw new Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");
        }
        return this.cpuData;
      }
      get location() {
        return this.dataLocation;
      }
      get texture() {
        this.ensureValid();
        if (!this.gpuTextureData) {
          throw new Error("The data is not stored as a WebGL texture.");
        }
        return this.gpuTextureData;
      }
      get gpuBuffer() {
        this.ensureValid();
        if (!this.gpuBufferData) {
          throw new Error("The data is not stored as a WebGPU buffer.");
        }
        return this.gpuBufferData;
      }
      // #endregion
      // #region methods
      async getData(releaseData) {
        this.ensureValid();
        switch (this.dataLocation) {
          case "cpu":
          case "cpu-pinned":
            return this.data;
          case "texture":
          case "gpu-buffer": {
            if (!this.downloader) {
              throw new Error("The current tensor is not created with a specified data downloader.");
            }
            if (this.isDownloading) {
              throw new Error("The current tensor is being downloaded.");
            }
            try {
              this.isDownloading = true;
              const data = await this.downloader();
              this.downloader = void 0;
              this.dataLocation = "cpu";
              this.cpuData = data;
              if (releaseData && this.disposer) {
                this.disposer();
                this.disposer = void 0;
              }
              return data;
            } finally {
              this.isDownloading = false;
            }
          }
          default:
            throw new Error(`cannot get data from location: ${this.dataLocation}`);
        }
      }
      dispose() {
        if (this.isDownloading) {
          throw new Error("The current tensor is being downloaded.");
        }
        if (this.disposer) {
          this.disposer();
          this.disposer = void 0;
        }
        this.cpuData = void 0;
        this.gpuTextureData = void 0;
        this.gpuBufferData = void 0;
        this.downloader = void 0;
        this.isDownloading = void 0;
        this.dataLocation = "none";
      }
      // #endregion
      // #region tensor utilities
      ensureValid() {
        if (this.dataLocation === "none") {
          throw new Error("The tensor is disposed.");
        }
      }
      reshape(dims) {
        this.ensureValid();
        if (this.downloader || this.disposer) {
          throw new Error("Cannot reshape a tensor that owns GPU resource.");
        }
        return tensorReshape(this, dims);
      }
    };
  }
});

// common/dist/esm/tensor.js
var Tensor2;
var init_tensor = __esm({
  "common/dist/esm/tensor.js"() {
    "use strict";
    init_tensor_impl();
    Tensor2 = Tensor;
  }
});

// common/dist/esm/trace.js
var TRACE, TRACE_FUNC, TRACE_FUNC_BEGIN, TRACE_FUNC_END;
var init_trace = __esm({
  "common/dist/esm/trace.js"() {
    "use strict";
    init_env_impl();
    TRACE = (deviceType, label) => {
      if (typeof env.trace === "undefined" ? !env.wasm.trace : !env.trace) {
        return;
      }
      console.timeStamp(`${deviceType}::ORT::${label}`);
    };
    TRACE_FUNC = (msg, extraMsg) => {
      const stack = new Error().stack?.split(/\r\n|\r|\n/g) || [];
      let hasTraceFunc = false;
      for (let i = 0; i < stack.length; i++) {
        if (hasTraceFunc && !stack[i].includes("TRACE_FUNC")) {
          let label = `FUNC_${msg}::${stack[i].trim().split(" ")[1]}`;
          if (extraMsg) {
            label += `::${extraMsg}`;
          }
          TRACE("CPU", label);
          return;
        }
        if (stack[i].includes("TRACE_FUNC")) {
          hasTraceFunc = true;
        }
      }
    };
    TRACE_FUNC_BEGIN = (extraMsg) => {
      if (typeof env.trace === "undefined" ? !env.wasm.trace : !env.trace) {
        return;
      }
      TRACE_FUNC("BEGIN", extraMsg);
    };
    TRACE_FUNC_END = (extraMsg) => {
      if (typeof env.trace === "undefined" ? !env.wasm.trace : !env.trace) {
        return;
      }
      TRACE_FUNC("END", extraMsg);
    };
  }
});

// common/dist/esm/inference-session-impl.js
var InferenceSession;
var init_inference_session_impl = __esm({
  "common/dist/esm/inference-session-impl.js"() {
    "use strict";
    init_backend_impl();
    init_tensor();
    init_trace();
    InferenceSession = class _InferenceSession {
      constructor(handler) {
        this.handler = handler;
      }
      async run(feeds, arg1, arg2) {
        TRACE_FUNC_BEGIN();
        const fetches = {};
        let options = {};
        if (typeof feeds !== "object" || feeds === null || feeds instanceof Tensor2 || Array.isArray(feeds)) {
          throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");
        }
        let isFetchesEmpty = true;
        if (typeof arg1 === "object") {
          if (arg1 === null) {
            throw new TypeError("Unexpected argument[1]: cannot be null.");
          }
          if (arg1 instanceof Tensor2) {
            throw new TypeError("'fetches' cannot be a Tensor");
          }
          if (Array.isArray(arg1)) {
            if (arg1.length === 0) {
              throw new TypeError("'fetches' cannot be an empty array.");
            }
            isFetchesEmpty = false;
            for (const name2 of arg1) {
              if (typeof name2 !== "string") {
                throw new TypeError("'fetches' must be a string array or an object.");
              }
              if (this.outputNames.indexOf(name2) === -1) {
                throw new RangeError(`'fetches' contains invalid output name: ${name2}.`);
              }
              fetches[name2] = null;
            }
            if (typeof arg2 === "object" && arg2 !== null) {
              options = arg2;
            } else if (typeof arg2 !== "undefined") {
              throw new TypeError("'options' must be an object.");
            }
          } else {
            let isFetches = false;
            const arg1Keys = Object.getOwnPropertyNames(arg1);
            for (const name2 of this.outputNames) {
              if (arg1Keys.indexOf(name2) !== -1) {
                const v = arg1[name2];
                if (v === null || v instanceof Tensor2) {
                  isFetches = true;
                  isFetchesEmpty = false;
                  fetches[name2] = v;
                }
              }
            }
            if (isFetches) {
              if (typeof arg2 === "object" && arg2 !== null) {
                options = arg2;
              } else if (typeof arg2 !== "undefined") {
                throw new TypeError("'options' must be an object.");
              }
            } else {
              options = arg1;
            }
          }
        } else if (typeof arg1 !== "undefined") {
          throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");
        }
        for (const name2 of this.inputNames) {
          if (typeof feeds[name2] === "undefined") {
            throw new Error(`input '${name2}' is missing in 'feeds'.`);
          }
        }
        if (isFetchesEmpty) {
          for (const name2 of this.outputNames) {
            fetches[name2] = null;
          }
        }
        const results = await this.handler.run(feeds, fetches, options);
        const returnValue = {};
        for (const key in results) {
          if (Object.hasOwnProperty.call(results, key)) {
            const result = results[key];
            if (result instanceof Tensor2) {
              returnValue[key] = result;
            } else {
              returnValue[key] = new Tensor2(result.type, result.data, result.dims);
            }
          }
        }
        TRACE_FUNC_END();
        return returnValue;
      }
      async release() {
        return this.handler.dispose();
      }
      static async create(arg0, arg1, arg2, arg3) {
        TRACE_FUNC_BEGIN();
        let filePathOrUint8Array;
        let options = {};
        if (typeof arg0 === "string") {
          filePathOrUint8Array = arg0;
          if (typeof arg1 === "object" && arg1 !== null) {
            options = arg1;
          } else if (typeof arg1 !== "undefined") {
            throw new TypeError("'options' must be an object.");
          }
        } else if (arg0 instanceof Uint8Array) {
          filePathOrUint8Array = arg0;
          if (typeof arg1 === "object" && arg1 !== null) {
            options = arg1;
          } else if (typeof arg1 !== "undefined") {
            throw new TypeError("'options' must be an object.");
          }
        } else if (arg0 instanceof ArrayBuffer || typeof SharedArrayBuffer !== "undefined" && arg0 instanceof SharedArrayBuffer) {
          const buffer = arg0;
          let byteOffset = 0;
          let byteLength = arg0.byteLength;
          if (typeof arg1 === "object" && arg1 !== null) {
            options = arg1;
          } else if (typeof arg1 === "number") {
            byteOffset = arg1;
            if (!Number.isSafeInteger(byteOffset)) {
              throw new RangeError("'byteOffset' must be an integer.");
            }
            if (byteOffset < 0 || byteOffset >= buffer.byteLength) {
              throw new RangeError(`'byteOffset' is out of range [0, ${buffer.byteLength}).`);
            }
            byteLength = arg0.byteLength - byteOffset;
            if (typeof arg2 === "number") {
              byteLength = arg2;
              if (!Number.isSafeInteger(byteLength)) {
                throw new RangeError("'byteLength' must be an integer.");
              }
              if (byteLength <= 0 || byteOffset + byteLength > buffer.byteLength) {
                throw new RangeError(`'byteLength' is out of range (0, ${buffer.byteLength - byteOffset}].`);
              }
              if (typeof arg3 === "object" && arg3 !== null) {
                options = arg3;
              } else if (typeof arg3 !== "undefined") {
                throw new TypeError("'options' must be an object.");
              }
            } else if (typeof arg2 !== "undefined") {
              throw new TypeError("'byteLength' must be a number.");
            }
          } else if (typeof arg1 !== "undefined") {
            throw new TypeError("'options' must be an object.");
          }
          filePathOrUint8Array = new Uint8Array(buffer, byteOffset, byteLength);
        } else {
          throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");
        }
        const [backend2, optionsWithValidatedEPs] = await resolveBackendAndExecutionProviders(options);
        const handler = await backend2.createInferenceSessionHandler(filePathOrUint8Array, optionsWithValidatedEPs);
        TRACE_FUNC_END();
        return new _InferenceSession(handler);
      }
      startProfiling() {
        this.handler.startProfiling();
      }
      endProfiling() {
        this.handler.endProfiling();
      }
      get inputNames() {
        return this.handler.inputNames;
      }
      get outputNames() {
        return this.handler.outputNames;
      }
    };
  }
});

// common/dist/esm/inference-session.js
var InferenceSession2;
var init_inference_session = __esm({
  "common/dist/esm/inference-session.js"() {
    "use strict";
    init_inference_session_impl();
    InferenceSession2 = InferenceSession;
  }
});

// common/dist/esm/tensor-conversion.js
var init_tensor_conversion = __esm({
  "common/dist/esm/tensor-conversion.js"() {
    "use strict";
  }
});

// common/dist/esm/tensor-factory.js
var init_tensor_factory = __esm({
  "common/dist/esm/tensor-factory.js"() {
    "use strict";
  }
});

// common/dist/esm/onnx-model.js
var init_onnx_model = __esm({
  "common/dist/esm/onnx-model.js"() {
    "use strict";
  }
});

// common/dist/esm/onnx-value.js
var init_onnx_value = __esm({
  "common/dist/esm/onnx-value.js"() {
    "use strict";
  }
});

// common/dist/esm/training-session-impl.js
var noBackendErrMsg, TrainingSession;
var init_training_session_impl = __esm({
  "common/dist/esm/training-session-impl.js"() {
    "use strict";
    init_backend_impl();
    init_tensor();
    noBackendErrMsg = "Training backend could not be resolved. Make sure you're using the correct configuration & WebAssembly files.";
    TrainingSession = class _TrainingSession {
      constructor(handler, hasOptimizerModel, hasEvalModel) {
        this.handler = handler;
        this.hasOptimizerModel = hasOptimizerModel;
        this.hasEvalModel = hasEvalModel;
      }
      get trainingInputNames() {
        return this.handler.inputNames;
      }
      get trainingOutputNames() {
        return this.handler.outputNames;
      }
      get evalInputNames() {
        if (this.hasEvalModel) {
          return this.handler.evalInputNames;
        } else {
          throw new Error("This training session has no evalModel loaded.");
        }
      }
      get evalOutputNames() {
        if (this.hasEvalModel) {
          return this.handler.evalOutputNames;
        } else {
          throw new Error("This training session has no evalModel loaded.");
        }
      }
      static async create(trainingOptions, sessionOptions) {
        const evalModel = trainingOptions.evalModel || "";
        const optimizerModel = trainingOptions.optimizerModel || "";
        const options = sessionOptions || {};
        const [backend2, optionsWithValidatedEPs] = await resolveBackendAndExecutionProviders(options);
        if (backend2.createTrainingSessionHandler) {
          const handler = await backend2.createTrainingSessionHandler(trainingOptions.checkpointState, trainingOptions.trainModel, evalModel, optimizerModel, optionsWithValidatedEPs);
          return new _TrainingSession(handler, !!trainingOptions.optimizerModel, !!trainingOptions.evalModel);
        } else {
          throw new Error(noBackendErrMsg);
        }
      }
      /**
       * Helper function for runTrainStep and future runStep methods that handles the type-narrowing conversion from
       * the given parameters to SessionHandler.FetchesType and RunOptions.
       *
       * @param inputNames the feeds object is checked that they contain all input names in the provided list of input
       * names.
       * @param outputNames the fetches object is checked that their keys match up with valid names in the list of output
       * names.
       * @param feeds the required input
       * @param arg1 narrowed & converted into the SessionHandler.FetchesType or RunOptions object
       * @param arg2 optional RunOptions object.
       * @returns
       */
      typeNarrowingForRunStep(inputNames, outputNames, feeds, arg1, arg2) {
        const fetches = {};
        let options = {};
        if (typeof feeds !== "object" || feeds === null || feeds instanceof Tensor2 || Array.isArray(feeds)) {
          throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");
        }
        let isFetchesEmpty = true;
        if (typeof arg1 === "object") {
          if (arg1 === null) {
            throw new TypeError("Unexpected argument[1]: cannot be null.");
          }
          if (arg1 instanceof Tensor2) {
            throw new TypeError("'fetches' cannot be a Tensor");
          }
          if (Array.isArray(arg1)) {
            if (arg1.length === 0) {
              throw new TypeError("'fetches' cannot be an empty array.");
            }
            isFetchesEmpty = false;
            for (const name2 of arg1) {
              if (typeof name2 !== "string") {
                throw new TypeError("'fetches' must be a string array or an object.");
              }
              if (outputNames.indexOf(name2) === -1) {
                throw new RangeError(`'fetches' contains invalid output name: ${name2}.`);
              }
              fetches[name2] = null;
            }
            if (typeof arg2 === "object" && arg2 !== null) {
              options = arg2;
            } else if (typeof arg2 !== "undefined") {
              throw new TypeError("'options' must be an object.");
            }
          } else {
            let isFetches = false;
            const arg1Keys = Object.getOwnPropertyNames(arg1);
            for (const name2 of outputNames) {
              if (arg1Keys.indexOf(name2) !== -1) {
                const v = arg1[name2];
                if (v === null || v instanceof Tensor2) {
                  isFetches = true;
                  isFetchesEmpty = false;
                  fetches[name2] = v;
                }
              }
            }
            if (isFetches) {
              if (typeof arg2 === "object" && arg2 !== null) {
                options = arg2;
              } else if (typeof arg2 !== "undefined") {
                throw new TypeError("'options' must be an object.");
              }
            } else {
              options = arg1;
            }
          }
        } else if (typeof arg1 !== "undefined") {
          throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");
        }
        for (const name2 of inputNames) {
          if (typeof feeds[name2] === "undefined") {
            throw new Error(`input '${name2}' is missing in 'feeds'.`);
          }
        }
        if (isFetchesEmpty) {
          for (const name2 of outputNames) {
            fetches[name2] = null;
          }
        }
        return [fetches, options];
      }
      /**
       * Helper method for runTrainStep and any other runStep methods. Takes the ReturnType result from the SessionHandler
       * and changes it into a map of Tensors.
       *
       * @param results
       * @returns
       */
      convertHandlerReturnTypeToMapOfTensors(results) {
        const returnValue = {};
        for (const key in results) {
          if (Object.hasOwnProperty.call(results, key)) {
            const result = results[key];
            if (result instanceof Tensor2) {
              returnValue[key] = result;
            } else {
              returnValue[key] = new Tensor2(result.type, result.data, result.dims);
            }
          }
        }
        return returnValue;
      }
      async lazyResetGrad() {
        await this.handler.lazyResetGrad();
      }
      async runTrainStep(feeds, arg1, arg2) {
        const [fetches, options] = this.typeNarrowingForRunStep(this.trainingInputNames, this.trainingOutputNames, feeds, arg1, arg2);
        const results = await this.handler.runTrainStep(feeds, fetches, options);
        return this.convertHandlerReturnTypeToMapOfTensors(results);
      }
      async runOptimizerStep(options) {
        if (this.hasOptimizerModel) {
          await this.handler.runOptimizerStep(options || {});
        } else {
          throw new Error("This TrainingSession has no OptimizerModel loaded.");
        }
      }
      async runEvalStep(feeds, arg1, arg2) {
        if (this.hasEvalModel) {
          const [fetches, options] = this.typeNarrowingForRunStep(this.evalInputNames, this.evalOutputNames, feeds, arg1, arg2);
          const results = await this.handler.runEvalStep(feeds, fetches, options);
          return this.convertHandlerReturnTypeToMapOfTensors(results);
        } else {
          throw new Error("This TrainingSession has no EvalModel loaded.");
        }
      }
      async getParametersSize(trainableOnly = true) {
        return this.handler.getParametersSize(trainableOnly);
      }
      async loadParametersBuffer(array, trainableOnly = true) {
        const paramsSize = await this.getParametersSize(trainableOnly);
        if (array.length !== 4 * paramsSize) {
          throw new Error("Size of the buffer passed into loadParametersBuffer must match the number of parameters in the model. Please use getParametersSize method to check.");
        }
        return this.handler.loadParametersBuffer(array, trainableOnly);
      }
      async getContiguousParameters(trainableOnly = true) {
        return this.handler.getContiguousParameters(trainableOnly);
      }
      async release() {
        return this.handler.dispose();
      }
    };
  }
});

// common/dist/esm/training-session.js
var TrainingSession2;
var init_training_session = __esm({
  "common/dist/esm/training-session.js"() {
    "use strict";
    init_training_session_impl();
    TrainingSession2 = TrainingSession;
  }
});

// common/dist/esm/index.js
var esm_exports = {};
__export(esm_exports, {
  InferenceSession: () => InferenceSession2,
  TRACE: () => TRACE,
  TRACE_FUNC_BEGIN: () => TRACE_FUNC_BEGIN,
  TRACE_FUNC_END: () => TRACE_FUNC_END,
  Tensor: () => Tensor2,
  TrainingSession: () => TrainingSession2,
  env: () => env2,
  registerBackend: () => registerBackend
});
var init_esm = __esm({
  "common/dist/esm/index.js"() {
    "use strict";
    init_backend();
    init_env();
    init_inference_session();
    init_tensor();
    init_tensor_conversion();
    init_tensor_factory();
    init_trace();
    init_onnx_model();
    init_onnx_value();
    init_training_session();
  }
});

// nodejs-ignore:node:fs/promises
var readFile;
var init_promises = __esm({
  "nodejs-ignore:node:fs/promises"() {
    readFile = void 0;
  }
});

// web/lib/onnxjs/instrument.ts
function log(arg0, arg1, arg2, arg3) {
  if (arg1 === void 0) {
    return createCategorizedLogger(arg0);
  } else if (arg2 === void 0) {
    logInternal(arg0, arg1, 1);
  } else if (typeof arg2 === "number" && arg3 === void 0) {
    logInternal(arg0, arg1, arg2);
  } else if (typeof arg2 === "string" && arg3 === void 0) {
    logInternal(arg0, arg2, 1, arg1);
  } else if (typeof arg2 === "string" && typeof arg3 === "number") {
    logInternal(arg0, arg2, arg3, arg1);
  } else {
    throw new TypeError("input is valid");
  }
}
function createCategorizedLogger(category) {
  return {
    verbose: log.verbose.bind(null, category),
    info: log.info.bind(null, category),
    warning: log.warning.bind(null, category),
    error: log.error.bind(null, category),
    fatal: log.fatal.bind(null, category)
  };
}
function logInternal(severity, content, _stack, category) {
  const config = LOGGER_CONFIG_MAP[category || ""] || LOGGER_CONFIG_MAP[""];
  if (SEVERITY_VALUE[severity] < SEVERITY_VALUE[config.minimalSeverity]) {
    return;
  }
  if (config.logDateTime) {
    content = `${(/* @__PURE__ */ new Date()).toISOString()}|${content}`;
  }
  if (config.logSourceLocation) {
  }
  LOGGER_PROVIDER_MAP[config.provider].log(severity, content, category);
}
var NoOpLoggerProvider, ConsoleLoggerProvider, SEVERITY_VALUE, LOGGER_PROVIDER_MAP, LOGGER_DEFAULT_CONFIG, LOGGER_CONFIG_MAP, Logger, Event, EventRecord, Profiler, now;
var init_instrument = __esm({
  "web/lib/onnxjs/instrument.ts"() {
    "use strict";
    NoOpLoggerProvider = class {
      log(_severity, _content, _category) {
      }
    };
    ConsoleLoggerProvider = class {
      log(severity, content, category) {
        console.log(`${this.color(severity)} ${category ? "\x1B[35m" + category + "\x1B[0m " : ""}${content}`);
      }
      color(severity) {
        switch (severity) {
          case "verbose":
            return "\x1B[34;40mv\x1B[0m";
          case "info":
            return "\x1B[32mi\x1B[0m";
          case "warning":
            return "\x1B[30;43mw\x1B[0m";
          case "error":
            return "\x1B[31;40me\x1B[0m";
          case "fatal":
            return "\x1B[101mf\x1B[0m";
          default:
            throw new Error(`unsupported severity: ${severity}`);
        }
      }
    };
    SEVERITY_VALUE = {
      verbose: 1e3,
      info: 2e3,
      warning: 4e3,
      error: 5e3,
      fatal: 6e3
    };
    LOGGER_PROVIDER_MAP = {
      ["none"]: new NoOpLoggerProvider(),
      ["console"]: new ConsoleLoggerProvider()
    };
    LOGGER_DEFAULT_CONFIG = {
      provider: "console",
      minimalSeverity: "warning",
      logDateTime: true,
      logSourceLocation: false
    };
    LOGGER_CONFIG_MAP = { [""]: LOGGER_DEFAULT_CONFIG };
    ((log3) => {
      function verbose(arg0, arg1) {
        log3("verbose", arg0, arg1);
      }
      log3.verbose = verbose;
      function info(arg0, arg1) {
        log3("info", arg0, arg1);
      }
      log3.info = info;
      function warning(arg0, arg1) {
        log3("warning", arg0, arg1);
      }
      log3.warning = warning;
      function error(arg0, arg1) {
        log3("error", arg0, arg1);
      }
      log3.error = error;
      function fatal(arg0, arg1) {
        log3("fatal", arg0, arg1);
      }
      log3.fatal = fatal;
      function reset(config) {
        LOGGER_CONFIG_MAP = {};
        set("", config || {});
      }
      log3.reset = reset;
      function set(category, config) {
        if (category === "*") {
          reset(config);
        } else {
          const previousConfig = LOGGER_CONFIG_MAP[category] || LOGGER_DEFAULT_CONFIG;
          LOGGER_CONFIG_MAP[category] = {
            provider: config.provider || previousConfig.provider,
            minimalSeverity: config.minimalSeverity || previousConfig.minimalSeverity,
            logDateTime: config.logDateTime === void 0 ? previousConfig.logDateTime : config.logDateTime,
            logSourceLocation: config.logSourceLocation === void 0 ? previousConfig.logSourceLocation : config.logSourceLocation
          };
        }
      }
      log3.set = set;
      function setWithEnv(env3) {
        const config = {};
        if (env3.logLevel) {
          config.minimalSeverity = env3.logLevel;
        }
        set("", config);
      }
      log3.setWithEnv = setWithEnv;
    })(log || (log = {}));
    Logger = log;
    Event = class {
      constructor(category, name2, startTime, endCallback, timer, ctx) {
        this.category = category;
        this.name = name2;
        this.startTime = startTime;
        this.endCallback = endCallback;
        this.timer = timer;
        this.ctx = ctx;
      }
      async end() {
        return this.endCallback(this);
      }
      async checkTimer() {
        if (this.ctx === void 0 || this.timer === void 0) {
          throw new Error("No webgl timer found");
        } else {
          this.ctx.endTimer();
          return this.ctx.waitForQueryAndGetTime(this.timer);
        }
      }
    };
    EventRecord = class {
      constructor(category, name2, startTime, endTime) {
        this.category = category;
        this.name = name2;
        this.startTime = startTime;
        this.endTime = endTime;
      }
    };
    Profiler = class {
      constructor(maxNumberEvents, flushBatchSize, flushIntervalInMilliseconds) {
        this._started = false;
        this._flushPointer = 0;
        this._started = false;
        this._maxNumberEvents = maxNumberEvents === void 0 ? 1e4 : maxNumberEvents;
        this._flushBatchSize = flushBatchSize === void 0 ? 10 : flushBatchSize;
        this._flushIntervalInMilliseconds = flushIntervalInMilliseconds === void 0 ? 5e3 : flushIntervalInMilliseconds;
      }
      static create(config) {
        if (config === void 0) {
          return new this();
        }
        return new this(config.maxNumberEvents, config.flushBatchSize, config.flushIntervalInMilliseconds);
      }
      // start profiling
      start() {
        this._started = true;
        this._timingEvents = [];
        this._flushTime = now();
        this._flushPointer = 0;
      }
      // stop profiling
      stop() {
        this._started = false;
        for (; this._flushPointer < this._timingEvents.length; this._flushPointer++) {
          this.logOneEvent(this._timingEvents[this._flushPointer]);
        }
      }
      event(category, name2, func, ctx) {
        const event = this._started ? this.begin(category, name2, ctx) : void 0;
        let isPromise = false;
        const res = func();
        if (res && typeof res.then === "function") {
          isPromise = true;
          return new Promise((resolve, reject) => {
            res.then(
              async (value) => {
                if (event) {
                  await event.end();
                }
                resolve(value);
              },
              async (reason) => {
                if (event) {
                  await event.end();
                }
                reject(reason);
              }
            );
          });
        }
        if (!isPromise && event) {
          const eventRes = event.end();
          if (eventRes && typeof eventRes.then === "function") {
            return new Promise((resolve, reject) => {
              eventRes.then(
                () => {
                  resolve(res);
                },
                (reason) => {
                  reject(reason);
                }
              );
            });
          }
        }
        return res;
      }
      // begin an event
      begin(category, name2, ctx) {
        if (!this._started) {
          throw new Error("profiler is not started yet");
        }
        if (ctx === void 0) {
          const startTime = now();
          this.flush(startTime);
          return new Event(category, name2, startTime, (e) => this.endSync(e));
        } else {
          const timer = ctx.beginTimer();
          return new Event(category, name2, 0, async (e) => this.end(e), timer, ctx);
        }
      }
      // end the specific event
      async end(event) {
        const endTime = await event.checkTimer();
        if (this._timingEvents.length < this._maxNumberEvents) {
          this._timingEvents.push(new EventRecord(event.category, event.name, event.startTime, endTime));
          this.flush(endTime);
        }
      }
      endSync(event) {
        const endTime = now();
        if (this._timingEvents.length < this._maxNumberEvents) {
          this._timingEvents.push(new EventRecord(event.category, event.name, event.startTime, endTime));
          this.flush(endTime);
        }
      }
      logOneEvent(event) {
        Logger.verbose(
          `Profiler.${event.category}`,
          `${(event.endTime - event.startTime).toFixed(2)}ms on event '${event.name}' at ${event.endTime.toFixed(2)}`
        );
      }
      flush(currentTime) {
        if (this._timingEvents.length - this._flushPointer >= this._flushBatchSize || currentTime - this._flushTime >= this._flushIntervalInMilliseconds) {
          for (const previousPointer = this._flushPointer; this._flushPointer < previousPointer + this._flushBatchSize && this._flushPointer < this._timingEvents.length; this._flushPointer++) {
            this.logOneEvent(this._timingEvents[this._flushPointer]);
          }
          this._flushTime = now();
        }
      }
      get started() {
        return this._started;
      }
    };
    now = typeof performance !== "undefined" && performance.now ? () => performance.now() : Date.now;
  }
});

// web/lib/onnxjs/opset.ts
function resolveOperator(node, opsets, rules) {
  for (const rule of rules) {
    const opType = rule[0];
    const domain = rule[1];
    const versionSelector = rule[2];
    const opImpl = rule[3];
    const opInit = rule[4];
    if (node.opType === opType) {
      for (const opset of opsets) {
        if (opset.domain === domain || opset.domain === "ai.onnx" && domain === "") {
          if (matchSelector(opset.version, versionSelector)) {
            return { opImpl, opInit };
          }
        }
      }
    }
  }
  throw new TypeError(`cannot resolve operator '${node.opType}' with opsets: ${opsets.map((set) => `${set.domain || "ai.onnx"} v${set.version}`).join(", ")}`);
}
function matchSelector(version3, selector) {
  if (selector.endsWith("+")) {
    const rangeStart = Number.parseInt(selector.substring(0, selector.length - 1), 10);
    return !isNaN(rangeStart) && rangeStart <= version3;
  } else if (selector.split("-").length === 2) {
    const pair = selector.split("-");
    const rangeStart = Number.parseInt(pair[0], 10);
    const rangeEnd = Number.parseInt(pair[1], 10);
    return !isNaN(rangeStart) && !isNaN(rangeEnd) && rangeStart <= version3 && version3 <= rangeEnd;
  } else {
    return Number.parseInt(selector, 10) === version3;
  }
}
var init_opset = __esm({
  "web/lib/onnxjs/opset.ts"() {
    "use strict";
  }
});

// web/node_modules/guid-typescript/dist/guid.js
var require_guid = __commonJS({
  "web/node_modules/guid-typescript/dist/guid.js"(exports2) {
    "use strict";
    exports2.__esModule = true;
    var Guid2 = (
      /** @class */
      function() {
        function Guid3(guid) {
          if (!guid) {
            throw new TypeError("Invalid argument; `value` has no value.");
          }
          this.value = Guid3.EMPTY;
          if (guid && Guid3.isGuid(guid)) {
            this.value = guid;
          }
        }
        Guid3.isGuid = function(guid) {
          var value = guid.toString();
          return guid && (guid instanceof Guid3 || Guid3.validator.test(value));
        };
        Guid3.create = function() {
          return new Guid3([Guid3.gen(2), Guid3.gen(1), Guid3.gen(1), Guid3.gen(1), Guid3.gen(3)].join("-"));
        };
        Guid3.createEmpty = function() {
          return new Guid3("emptyguid");
        };
        Guid3.parse = function(guid) {
          return new Guid3(guid);
        };
        Guid3.raw = function() {
          return [Guid3.gen(2), Guid3.gen(1), Guid3.gen(1), Guid3.gen(1), Guid3.gen(3)].join("-");
        };
        Guid3.gen = function(count) {
          var out = "";
          for (var i = 0; i < count; i++) {
            out += ((1 + Math.random()) * 65536 | 0).toString(16).substring(1);
          }
          return out;
        };
        Guid3.prototype.equals = function(other) {
          return Guid3.isGuid(other) && this.value === other.toString();
        };
        Guid3.prototype.isEmpty = function() {
          return this.value === Guid3.EMPTY;
        };
        Guid3.prototype.toString = function() {
          return this.value;
        };
        Guid3.prototype.toJSON = function() {
          return {
            value: this.value
          };
        };
        Guid3.validator = new RegExp("^[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}$", "i");
        Guid3.EMPTY = "00000000-0000-0000-0000-000000000000";
        return Guid3;
      }()
    );
    exports2.Guid = Guid2;
  }
});

// web/node_modules/long/index.js
function Long(low, high, unsigned) {
  this.low = low | 0;
  this.high = high | 0;
  this.unsigned = !!unsigned;
}
function isLong(obj) {
  return (obj && obj["__isLong__"]) === true;
}
function ctz32(value) {
  var c = Math.clz32(value & -value);
  return value ? 31 - c : c;
}
function fromInt(value, unsigned) {
  var obj, cachedObj, cache2;
  if (unsigned) {
    value >>>= 0;
    if (cache2 = 0 <= value && value < 256) {
      cachedObj = UINT_CACHE[value];
      if (cachedObj)
        return cachedObj;
    }
    obj = fromBits(value, 0, true);
    if (cache2)
      UINT_CACHE[value] = obj;
    return obj;
  } else {
    value |= 0;
    if (cache2 = -128 <= value && value < 128) {
      cachedObj = INT_CACHE[value];
      if (cachedObj)
        return cachedObj;
    }
    obj = fromBits(value, value < 0 ? -1 : 0, false);
    if (cache2)
      INT_CACHE[value] = obj;
    return obj;
  }
}
function fromNumber(value, unsigned) {
  if (isNaN(value))
    return unsigned ? UZERO : ZERO;
  if (unsigned) {
    if (value < 0)
      return UZERO;
    if (value >= TWO_PWR_64_DBL)
      return MAX_UNSIGNED_VALUE;
  } else {
    if (value <= -TWO_PWR_63_DBL)
      return MIN_VALUE;
    if (value + 1 >= TWO_PWR_63_DBL)
      return MAX_VALUE;
  }
  if (value < 0)
    return fromNumber(-value, unsigned).neg();
  return fromBits(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0, unsigned);
}
function fromBits(lowBits, highBits, unsigned) {
  return new Long(lowBits, highBits, unsigned);
}
function fromString(str, unsigned, radix) {
  if (str.length === 0)
    throw Error("empty string");
  if (typeof unsigned === "number") {
    radix = unsigned;
    unsigned = false;
  } else {
    unsigned = !!unsigned;
  }
  if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
    return unsigned ? UZERO : ZERO;
  radix = radix || 10;
  if (radix < 2 || 36 < radix)
    throw RangeError("radix");
  var p;
  if ((p = str.indexOf("-")) > 0)
    throw Error("interior hyphen");
  else if (p === 0) {
    return fromString(str.substring(1), unsigned, radix).neg();
  }
  var radixToPower = fromNumber(pow_dbl(radix, 8));
  var result = ZERO;
  for (var i = 0; i < str.length; i += 8) {
    var size = Math.min(8, str.length - i), value = parseInt(str.substring(i, i + size), radix);
    if (size < 8) {
      var power = fromNumber(pow_dbl(radix, size));
      result = result.mul(power).add(fromNumber(value));
    } else {
      result = result.mul(radixToPower);
      result = result.add(fromNumber(value));
    }
  }
  result.unsigned = unsigned;
  return result;
}
function fromValue(val, unsigned) {
  if (typeof val === "number")
    return fromNumber(val, unsigned);
  if (typeof val === "string")
    return fromString(val, unsigned);
  return fromBits(val.low, val.high, typeof unsigned === "boolean" ? unsigned : val.unsigned);
}
var wasm, INT_CACHE, UINT_CACHE, pow_dbl, TWO_PWR_16_DBL, TWO_PWR_24_DBL, TWO_PWR_32_DBL, TWO_PWR_64_DBL, TWO_PWR_63_DBL, TWO_PWR_24, ZERO, UZERO, ONE, UONE, NEG_ONE, MAX_VALUE, MAX_UNSIGNED_VALUE, MIN_VALUE, LongPrototype, long_default;
var init_long = __esm({
  "web/node_modules/long/index.js"() {
    wasm = null;
    try {
      wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([
        0,
        97,
        115,
        109,
        1,
        0,
        0,
        0,
        1,
        13,
        2,
        96,
        0,
        1,
        127,
        96,
        4,
        127,
        127,
        127,
        127,
        1,
        127,
        3,
        7,
        6,
        0,
        1,
        1,
        1,
        1,
        1,
        6,
        6,
        1,
        127,
        1,
        65,
        0,
        11,
        7,
        50,
        6,
        3,
        109,
        117,
        108,
        0,
        1,
        5,
        100,
        105,
        118,
        95,
        115,
        0,
        2,
        5,
        100,
        105,
        118,
        95,
        117,
        0,
        3,
        5,
        114,
        101,
        109,
        95,
        115,
        0,
        4,
        5,
        114,
        101,
        109,
        95,
        117,
        0,
        5,
        8,
        103,
        101,
        116,
        95,
        104,
        105,
        103,
        104,
        0,
        0,
        10,
        191,
        1,
        6,
        4,
        0,
        35,
        0,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        126,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        127,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        128,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        129,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        130,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11
      ])), {}).exports;
    } catch (e) {
    }
    Long.prototype.__isLong__;
    Object.defineProperty(Long.prototype, "__isLong__", { value: true });
    Long.isLong = isLong;
    INT_CACHE = {};
    UINT_CACHE = {};
    Long.fromInt = fromInt;
    Long.fromNumber = fromNumber;
    Long.fromBits = fromBits;
    pow_dbl = Math.pow;
    Long.fromString = fromString;
    Long.fromValue = fromValue;
    TWO_PWR_16_DBL = 1 << 16;
    TWO_PWR_24_DBL = 1 << 24;
    TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;
    TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;
    TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;
    TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);
    ZERO = fromInt(0);
    Long.ZERO = ZERO;
    UZERO = fromInt(0, true);
    Long.UZERO = UZERO;
    ONE = fromInt(1);
    Long.ONE = ONE;
    UONE = fromInt(1, true);
    Long.UONE = UONE;
    NEG_ONE = fromInt(-1);
    Long.NEG_ONE = NEG_ONE;
    MAX_VALUE = fromBits(4294967295 | 0, 2147483647 | 0, false);
    Long.MAX_VALUE = MAX_VALUE;
    MAX_UNSIGNED_VALUE = fromBits(4294967295 | 0, 4294967295 | 0, true);
    Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;
    MIN_VALUE = fromBits(0, 2147483648 | 0, false);
    Long.MIN_VALUE = MIN_VALUE;
    LongPrototype = Long.prototype;
    LongPrototype.toInt = function toInt() {
      return this.unsigned ? this.low >>> 0 : this.low;
    };
    LongPrototype.toNumber = function toNumber() {
      if (this.unsigned)
        return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);
      return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
    };
    LongPrototype.toString = function toString(radix) {
      radix = radix || 10;
      if (radix < 2 || 36 < radix)
        throw RangeError("radix");
      if (this.isZero())
        return "0";
      if (this.isNegative()) {
        if (this.eq(MIN_VALUE)) {
          var radixLong = fromNumber(radix), div2 = this.div(radixLong), rem1 = div2.mul(radixLong).sub(this);
          return div2.toString(radix) + rem1.toInt().toString(radix);
        } else
          return "-" + this.neg().toString(radix);
      }
      var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned), rem = this;
      var result = "";
      while (true) {
        var remDiv = rem.div(radixToPower), intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0, digits = intval.toString(radix);
        rem = remDiv;
        if (rem.isZero())
          return digits + result;
        else {
          while (digits.length < 6)
            digits = "0" + digits;
          result = "" + digits + result;
        }
      }
    };
    LongPrototype.getHighBits = function getHighBits() {
      return this.high;
    };
    LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
      return this.high >>> 0;
    };
    LongPrototype.getLowBits = function getLowBits() {
      return this.low;
    };
    LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
      return this.low >>> 0;
    };
    LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
      if (this.isNegative())
        return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
      var val = this.high != 0 ? this.high : this.low;
      for (var bit = 31; bit > 0; bit--)
        if ((val & 1 << bit) != 0)
          break;
      return this.high != 0 ? bit + 33 : bit + 1;
    };
    LongPrototype.isZero = function isZero() {
      return this.high === 0 && this.low === 0;
    };
    LongPrototype.eqz = LongPrototype.isZero;
    LongPrototype.isNegative = function isNegative() {
      return !this.unsigned && this.high < 0;
    };
    LongPrototype.isPositive = function isPositive() {
      return this.unsigned || this.high >= 0;
    };
    LongPrototype.isOdd = function isOdd() {
      return (this.low & 1) === 1;
    };
    LongPrototype.isEven = function isEven() {
      return (this.low & 1) === 0;
    };
    LongPrototype.equals = function equals(other) {
      if (!isLong(other))
        other = fromValue(other);
      if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1)
        return false;
      return this.high === other.high && this.low === other.low;
    };
    LongPrototype.eq = LongPrototype.equals;
    LongPrototype.notEquals = function notEquals(other) {
      return !this.eq(
        /* validates */
        other
      );
    };
    LongPrototype.neq = LongPrototype.notEquals;
    LongPrototype.ne = LongPrototype.notEquals;
    LongPrototype.lessThan = function lessThan(other) {
      return this.comp(
        /* validates */
        other
      ) < 0;
    };
    LongPrototype.lt = LongPrototype.lessThan;
    LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
      return this.comp(
        /* validates */
        other
      ) <= 0;
    };
    LongPrototype.lte = LongPrototype.lessThanOrEqual;
    LongPrototype.le = LongPrototype.lessThanOrEqual;
    LongPrototype.greaterThan = function greaterThan(other) {
      return this.comp(
        /* validates */
        other
      ) > 0;
    };
    LongPrototype.gt = LongPrototype.greaterThan;
    LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
      return this.comp(
        /* validates */
        other
      ) >= 0;
    };
    LongPrototype.gte = LongPrototype.greaterThanOrEqual;
    LongPrototype.ge = LongPrototype.greaterThanOrEqual;
    LongPrototype.compare = function compare(other) {
      if (!isLong(other))
        other = fromValue(other);
      if (this.eq(other))
        return 0;
      var thisNeg = this.isNegative(), otherNeg = other.isNegative();
      if (thisNeg && !otherNeg)
        return -1;
      if (!thisNeg && otherNeg)
        return 1;
      if (!this.unsigned)
        return this.sub(other).isNegative() ? -1 : 1;
      return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
    };
    LongPrototype.comp = LongPrototype.compare;
    LongPrototype.negate = function negate() {
      if (!this.unsigned && this.eq(MIN_VALUE))
        return MIN_VALUE;
      return this.not().add(ONE);
    };
    LongPrototype.neg = LongPrototype.negate;
    LongPrototype.add = function add(addend) {
      if (!isLong(addend))
        addend = fromValue(addend);
      var a48 = this.high >>> 16;
      var a32 = this.high & 65535;
      var a16 = this.low >>> 16;
      var a00 = this.low & 65535;
      var b48 = addend.high >>> 16;
      var b32 = addend.high & 65535;
      var b16 = addend.low >>> 16;
      var b00 = addend.low & 65535;
      var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
      c00 += a00 + b00;
      c16 += c00 >>> 16;
      c00 &= 65535;
      c16 += a16 + b16;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c32 += a32 + b32;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c48 += a48 + b48;
      c48 &= 65535;
      return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
    };
    LongPrototype.subtract = function subtract(subtrahend) {
      if (!isLong(subtrahend))
        subtrahend = fromValue(subtrahend);
      return this.add(subtrahend.neg());
    };
    LongPrototype.sub = LongPrototype.subtract;
    LongPrototype.multiply = function multiply(multiplier) {
      if (this.isZero())
        return this;
      if (!isLong(multiplier))
        multiplier = fromValue(multiplier);
      if (wasm) {
        var low = wasm["mul"](
          this.low,
          this.high,
          multiplier.low,
          multiplier.high
        );
        return fromBits(low, wasm["get_high"](), this.unsigned);
      }
      if (multiplier.isZero())
        return this.unsigned ? UZERO : ZERO;
      if (this.eq(MIN_VALUE))
        return multiplier.isOdd() ? MIN_VALUE : ZERO;
      if (multiplier.eq(MIN_VALUE))
        return this.isOdd() ? MIN_VALUE : ZERO;
      if (this.isNegative()) {
        if (multiplier.isNegative())
          return this.neg().mul(multiplier.neg());
        else
          return this.neg().mul(multiplier).neg();
      } else if (multiplier.isNegative())
        return this.mul(multiplier.neg()).neg();
      if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))
        return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);
      var a48 = this.high >>> 16;
      var a32 = this.high & 65535;
      var a16 = this.low >>> 16;
      var a00 = this.low & 65535;
      var b48 = multiplier.high >>> 16;
      var b32 = multiplier.high & 65535;
      var b16 = multiplier.low >>> 16;
      var b00 = multiplier.low & 65535;
      var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
      c00 += a00 * b00;
      c16 += c00 >>> 16;
      c00 &= 65535;
      c16 += a16 * b00;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c16 += a00 * b16;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c32 += a32 * b00;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c32 += a16 * b16;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c32 += a00 * b32;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
      c48 &= 65535;
      return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
    };
    LongPrototype.mul = LongPrototype.multiply;
    LongPrototype.divide = function divide(divisor) {
      if (!isLong(divisor))
        divisor = fromValue(divisor);
      if (divisor.isZero())
        throw Error("division by zero");
      if (wasm) {
        if (!this.unsigned && this.high === -2147483648 && divisor.low === -1 && divisor.high === -1) {
          return this;
        }
        var low = (this.unsigned ? wasm["div_u"] : wasm["div_s"])(
          this.low,
          this.high,
          divisor.low,
          divisor.high
        );
        return fromBits(low, wasm["get_high"](), this.unsigned);
      }
      if (this.isZero())
        return this.unsigned ? UZERO : ZERO;
      var approx, rem, res;
      if (!this.unsigned) {
        if (this.eq(MIN_VALUE)) {
          if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
            return MIN_VALUE;
          else if (divisor.eq(MIN_VALUE))
            return ONE;
          else {
            var halfThis = this.shr(1);
            approx = halfThis.div(divisor).shl(1);
            if (approx.eq(ZERO)) {
              return divisor.isNegative() ? ONE : NEG_ONE;
            } else {
              rem = this.sub(divisor.mul(approx));
              res = approx.add(rem.div(divisor));
              return res;
            }
          }
        } else if (divisor.eq(MIN_VALUE))
          return this.unsigned ? UZERO : ZERO;
        if (this.isNegative()) {
          if (divisor.isNegative())
            return this.neg().div(divisor.neg());
          return this.neg().div(divisor).neg();
        } else if (divisor.isNegative())
          return this.div(divisor.neg()).neg();
        res = ZERO;
      } else {
        if (!divisor.unsigned)
          divisor = divisor.toUnsigned();
        if (divisor.gt(this))
          return UZERO;
        if (divisor.gt(this.shru(1)))
          return UONE;
        res = UZERO;
      }
      rem = this;
      while (rem.gte(divisor)) {
        approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));
        var log22 = Math.ceil(Math.log(approx) / Math.LN2), delta = log22 <= 48 ? 1 : pow_dbl(2, log22 - 48), approxRes = fromNumber(approx), approxRem = approxRes.mul(divisor);
        while (approxRem.isNegative() || approxRem.gt(rem)) {
          approx -= delta;
          approxRes = fromNumber(approx, this.unsigned);
          approxRem = approxRes.mul(divisor);
        }
        if (approxRes.isZero())
          approxRes = ONE;
        res = res.add(approxRes);
        rem = rem.sub(approxRem);
      }
      return res;
    };
    LongPrototype.div = LongPrototype.divide;
    LongPrototype.modulo = function modulo(divisor) {
      if (!isLong(divisor))
        divisor = fromValue(divisor);
      if (wasm) {
        var low = (this.unsigned ? wasm["rem_u"] : wasm["rem_s"])(
          this.low,
          this.high,
          divisor.low,
          divisor.high
        );
        return fromBits(low, wasm["get_high"](), this.unsigned);
      }
      return this.sub(this.div(divisor).mul(divisor));
    };
    LongPrototype.mod = LongPrototype.modulo;
    LongPrototype.rem = LongPrototype.modulo;
    LongPrototype.not = function not() {
      return fromBits(~this.low, ~this.high, this.unsigned);
    };
    LongPrototype.countLeadingZeros = function countLeadingZeros() {
      return this.high ? Math.clz32(this.high) : Math.clz32(this.low) + 32;
    };
    LongPrototype.clz = LongPrototype.countLeadingZeros;
    LongPrototype.countTrailingZeros = function countTrailingZeros() {
      return this.low ? ctz32(this.low) : ctz32(this.high) + 32;
    };
    LongPrototype.ctz = LongPrototype.countTrailingZeros;
    LongPrototype.and = function and(other) {
      if (!isLong(other))
        other = fromValue(other);
      return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
    };
    LongPrototype.or = function or(other) {
      if (!isLong(other))
        other = fromValue(other);
      return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
    };
    LongPrototype.xor = function xor(other) {
      if (!isLong(other))
        other = fromValue(other);
      return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
    };
    LongPrototype.shiftLeft = function shiftLeft(numBits) {
      if (isLong(numBits))
        numBits = numBits.toInt();
      if ((numBits &= 63) === 0)
        return this;
      else if (numBits < 32)
        return fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);
      else
        return fromBits(0, this.low << numBits - 32, this.unsigned);
    };
    LongPrototype.shl = LongPrototype.shiftLeft;
    LongPrototype.shiftRight = function shiftRight(numBits) {
      if (isLong(numBits))
        numBits = numBits.toInt();
      if ((numBits &= 63) === 0)
        return this;
      else if (numBits < 32)
        return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);
      else
        return fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);
    };
    LongPrototype.shr = LongPrototype.shiftRight;
    LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
      if (isLong(numBits))
        numBits = numBits.toInt();
      if ((numBits &= 63) === 0)
        return this;
      if (numBits < 32)
        return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >>> numBits, this.unsigned);
      if (numBits === 32)
        return fromBits(this.high, 0, this.unsigned);
      return fromBits(this.high >>> numBits - 32, 0, this.unsigned);
    };
    LongPrototype.shru = LongPrototype.shiftRightUnsigned;
    LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;
    LongPrototype.rotateLeft = function rotateLeft(numBits) {
      var b;
      if (isLong(numBits))
        numBits = numBits.toInt();
      if ((numBits &= 63) === 0)
        return this;
      if (numBits === 32)
        return fromBits(this.high, this.low, this.unsigned);
      if (numBits < 32) {
        b = 32 - numBits;
        return fromBits(this.low << numBits | this.high >>> b, this.high << numBits | this.low >>> b, this.unsigned);
      }
      numBits -= 32;
      b = 32 - numBits;
      return fromBits(this.high << numBits | this.low >>> b, this.low << numBits | this.high >>> b, this.unsigned);
    };
    LongPrototype.rotl = LongPrototype.rotateLeft;
    LongPrototype.rotateRight = function rotateRight(numBits) {
      var b;
      if (isLong(numBits))
        numBits = numBits.toInt();
      if ((numBits &= 63) === 0)
        return this;
      if (numBits === 32)
        return fromBits(this.high, this.low, this.unsigned);
      if (numBits < 32) {
        b = 32 - numBits;
        return fromBits(this.high << b | this.low >>> numBits, this.low << b | this.high >>> numBits, this.unsigned);
      }
      numBits -= 32;
      b = 32 - numBits;
      return fromBits(this.low << b | this.high >>> numBits, this.high << b | this.low >>> numBits, this.unsigned);
    };
    LongPrototype.rotr = LongPrototype.rotateRight;
    LongPrototype.toSigned = function toSigned() {
      if (!this.unsigned)
        return this;
      return fromBits(this.low, this.high, false);
    };
    LongPrototype.toUnsigned = function toUnsigned() {
      if (this.unsigned)
        return this;
      return fromBits(this.low, this.high, true);
    };
    LongPrototype.toBytes = function toBytes(le) {
      return le ? this.toBytesLE() : this.toBytesBE();
    };
    LongPrototype.toBytesLE = function toBytesLE() {
      var hi = this.high, lo = this.low;
      return [
        lo & 255,
        lo >>> 8 & 255,
        lo >>> 16 & 255,
        lo >>> 24,
        hi & 255,
        hi >>> 8 & 255,
        hi >>> 16 & 255,
        hi >>> 24
      ];
    };
    LongPrototype.toBytesBE = function toBytesBE() {
      var hi = this.high, lo = this.low;
      return [
        hi >>> 24,
        hi >>> 16 & 255,
        hi >>> 8 & 255,
        hi & 255,
        lo >>> 24,
        lo >>> 16 & 255,
        lo >>> 8 & 255,
        lo & 255
      ];
    };
    Long.fromBytes = function fromBytes(bytes, unsigned, le) {
      return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);
    };
    Long.fromBytesLE = function fromBytesLE(bytes, unsigned) {
      return new Long(
        bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24,
        bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24,
        unsigned
      );
    };
    Long.fromBytesBE = function fromBytesBE(bytes, unsigned) {
      return new Long(
        bytes[4] << 24 | bytes[5] << 16 | bytes[6] << 8 | bytes[7],
        bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3],
        unsigned
      );
    };
    long_default = Long;
  }
});

// web/node_modules/flatbuffers/js/flatbuffers.mjs
var flatbuffers;
var init_flatbuffers = __esm({
  "web/node_modules/flatbuffers/js/flatbuffers.mjs"() {
    flatbuffers = {};
    flatbuffers.Offset;
    flatbuffers.Table;
    flatbuffers.SIZEOF_SHORT = 2;
    flatbuffers.SIZEOF_INT = 4;
    flatbuffers.FILE_IDENTIFIER_LENGTH = 4;
    flatbuffers.SIZE_PREFIX_LENGTH = 4;
    flatbuffers.Encoding = {
      UTF8_BYTES: 1,
      UTF16_STRING: 2
    };
    flatbuffers.int32 = new Int32Array(2);
    flatbuffers.float32 = new Float32Array(flatbuffers.int32.buffer);
    flatbuffers.float64 = new Float64Array(flatbuffers.int32.buffer);
    flatbuffers.isLittleEndian = new Uint16Array(new Uint8Array([1, 0]).buffer)[0] === 1;
    flatbuffers.Long = function(low, high) {
      this.low = low | 0;
      this.high = high | 0;
    };
    flatbuffers.Long.create = function(low, high) {
      return low == 0 && high == 0 ? flatbuffers.Long.ZERO : new flatbuffers.Long(low, high);
    };
    flatbuffers.Long.prototype.toFloat64 = function() {
      return (this.low >>> 0) + this.high * 4294967296;
    };
    flatbuffers.Long.prototype.equals = function(other) {
      return this.low == other.low && this.high == other.high;
    };
    flatbuffers.Long.ZERO = new flatbuffers.Long(0, 0);
    flatbuffers.Builder = function(opt_initial_size) {
      if (!opt_initial_size) {
        var initial_size = 1024;
      } else {
        var initial_size = opt_initial_size;
      }
      this.bb = flatbuffers.ByteBuffer.allocate(initial_size);
      this.space = initial_size;
      this.minalign = 1;
      this.vtable = null;
      this.vtable_in_use = 0;
      this.isNested = false;
      this.object_start = 0;
      this.vtables = [];
      this.vector_num_elems = 0;
      this.force_defaults = false;
    };
    flatbuffers.Builder.prototype.clear = function() {
      this.bb.clear();
      this.space = this.bb.capacity();
      this.minalign = 1;
      this.vtable = null;
      this.vtable_in_use = 0;
      this.isNested = false;
      this.object_start = 0;
      this.vtables = [];
      this.vector_num_elems = 0;
      this.force_defaults = false;
    };
    flatbuffers.Builder.prototype.forceDefaults = function(forceDefaults) {
      this.force_defaults = forceDefaults;
    };
    flatbuffers.Builder.prototype.dataBuffer = function() {
      return this.bb;
    };
    flatbuffers.Builder.prototype.asUint8Array = function() {
      return this.bb.bytes().subarray(this.bb.position(), this.bb.position() + this.offset());
    };
    flatbuffers.Builder.prototype.prep = function(size, additional_bytes) {
      if (size > this.minalign) {
        this.minalign = size;
      }
      var align_size = ~(this.bb.capacity() - this.space + additional_bytes) + 1 & size - 1;
      while (this.space < align_size + size + additional_bytes) {
        var old_buf_size = this.bb.capacity();
        this.bb = flatbuffers.Builder.growByteBuffer(this.bb);
        this.space += this.bb.capacity() - old_buf_size;
      }
      this.pad(align_size);
    };
    flatbuffers.Builder.prototype.pad = function(byte_size) {
      for (var i = 0; i < byte_size; i++) {
        this.bb.writeInt8(--this.space, 0);
      }
    };
    flatbuffers.Builder.prototype.writeInt8 = function(value) {
      this.bb.writeInt8(this.space -= 1, value);
    };
    flatbuffers.Builder.prototype.writeInt16 = function(value) {
      this.bb.writeInt16(this.space -= 2, value);
    };
    flatbuffers.Builder.prototype.writeInt32 = function(value) {
      this.bb.writeInt32(this.space -= 4, value);
    };
    flatbuffers.Builder.prototype.writeInt64 = function(value) {
      this.bb.writeInt64(this.space -= 8, value);
    };
    flatbuffers.Builder.prototype.writeFloat32 = function(value) {
      this.bb.writeFloat32(this.space -= 4, value);
    };
    flatbuffers.Builder.prototype.writeFloat64 = function(value) {
      this.bb.writeFloat64(this.space -= 8, value);
    };
    flatbuffers.Builder.prototype.addInt8 = function(value) {
      this.prep(1, 0);
      this.writeInt8(value);
    };
    flatbuffers.Builder.prototype.addInt16 = function(value) {
      this.prep(2, 0);
      this.writeInt16(value);
    };
    flatbuffers.Builder.prototype.addInt32 = function(value) {
      this.prep(4, 0);
      this.writeInt32(value);
    };
    flatbuffers.Builder.prototype.addInt64 = function(value) {
      this.prep(8, 0);
      this.writeInt64(value);
    };
    flatbuffers.Builder.prototype.addFloat32 = function(value) {
      this.prep(4, 0);
      this.writeFloat32(value);
    };
    flatbuffers.Builder.prototype.addFloat64 = function(value) {
      this.prep(8, 0);
      this.writeFloat64(value);
    };
    flatbuffers.Builder.prototype.addFieldInt8 = function(voffset, value, defaultValue) {
      if (this.force_defaults || value != defaultValue) {
        this.addInt8(value);
        this.slot(voffset);
      }
    };
    flatbuffers.Builder.prototype.addFieldInt16 = function(voffset, value, defaultValue) {
      if (this.force_defaults || value != defaultValue) {
        this.addInt16(value);
        this.slot(voffset);
      }
    };
    flatbuffers.Builder.prototype.addFieldInt32 = function(voffset, value, defaultValue) {
      if (this.force_defaults || value != defaultValue) {
        this.addInt32(value);
        this.slot(voffset);
      }
    };
    flatbuffers.Builder.prototype.addFieldInt64 = function(voffset, value, defaultValue) {
      if (this.force_defaults || !value.equals(defaultValue)) {
        this.addInt64(value);
        this.slot(voffset);
      }
    };
    flatbuffers.Builder.prototype.addFieldFloat32 = function(voffset, value, defaultValue) {
      if (this.force_defaults || value != defaultValue) {
        this.addFloat32(value);
        this.slot(voffset);
      }
    };
    flatbuffers.Builder.prototype.addFieldFloat64 = function(voffset, value, defaultValue) {
      if (this.force_defaults || value != defaultValue) {
        this.addFloat64(value);
        this.slot(voffset);
      }
    };
    flatbuffers.Builder.prototype.addFieldOffset = function(voffset, value, defaultValue) {
      if (this.force_defaults || value != defaultValue) {
        this.addOffset(value);
        this.slot(voffset);
      }
    };
    flatbuffers.Builder.prototype.addFieldStruct = function(voffset, value, defaultValue) {
      if (value != defaultValue) {
        this.nested(value);
        this.slot(voffset);
      }
    };
    flatbuffers.Builder.prototype.nested = function(obj) {
      if (obj != this.offset()) {
        throw new Error("FlatBuffers: struct must be serialized inline.");
      }
    };
    flatbuffers.Builder.prototype.notNested = function() {
      if (this.isNested) {
        throw new Error("FlatBuffers: object serialization must not be nested.");
      }
    };
    flatbuffers.Builder.prototype.slot = function(voffset) {
      this.vtable[voffset] = this.offset();
    };
    flatbuffers.Builder.prototype.offset = function() {
      return this.bb.capacity() - this.space;
    };
    flatbuffers.Builder.growByteBuffer = function(bb) {
      var old_buf_size = bb.capacity();
      if (old_buf_size & 3221225472) {
        throw new Error("FlatBuffers: cannot grow buffer beyond 2 gigabytes.");
      }
      var new_buf_size = old_buf_size << 1;
      var nbb = flatbuffers.ByteBuffer.allocate(new_buf_size);
      nbb.setPosition(new_buf_size - old_buf_size);
      nbb.bytes().set(bb.bytes(), new_buf_size - old_buf_size);
      return nbb;
    };
    flatbuffers.Builder.prototype.addOffset = function(offset) {
      this.prep(flatbuffers.SIZEOF_INT, 0);
      this.writeInt32(this.offset() - offset + flatbuffers.SIZEOF_INT);
    };
    flatbuffers.Builder.prototype.startObject = function(numfields) {
      this.notNested();
      if (this.vtable == null) {
        this.vtable = [];
      }
      this.vtable_in_use = numfields;
      for (var i = 0; i < numfields; i++) {
        this.vtable[i] = 0;
      }
      this.isNested = true;
      this.object_start = this.offset();
    };
    flatbuffers.Builder.prototype.endObject = function() {
      if (this.vtable == null || !this.isNested) {
        throw new Error("FlatBuffers: endObject called without startObject");
      }
      this.addInt32(0);
      var vtableloc = this.offset();
      var i = this.vtable_in_use - 1;
      for (; i >= 0 && this.vtable[i] == 0; i--) {
      }
      var trimmed_size = i + 1;
      for (; i >= 0; i--) {
        this.addInt16(this.vtable[i] != 0 ? vtableloc - this.vtable[i] : 0);
      }
      var standard_fields = 2;
      this.addInt16(vtableloc - this.object_start);
      var len = (trimmed_size + standard_fields) * flatbuffers.SIZEOF_SHORT;
      this.addInt16(len);
      var existing_vtable = 0;
      var vt1 = this.space;
      outer_loop:
        for (i = 0; i < this.vtables.length; i++) {
          var vt2 = this.bb.capacity() - this.vtables[i];
          if (len == this.bb.readInt16(vt2)) {
            for (var j = flatbuffers.SIZEOF_SHORT; j < len; j += flatbuffers.SIZEOF_SHORT) {
              if (this.bb.readInt16(vt1 + j) != this.bb.readInt16(vt2 + j)) {
                continue outer_loop;
              }
            }
            existing_vtable = this.vtables[i];
            break;
          }
        }
      if (existing_vtable) {
        this.space = this.bb.capacity() - vtableloc;
        this.bb.writeInt32(this.space, existing_vtable - vtableloc);
      } else {
        this.vtables.push(this.offset());
        this.bb.writeInt32(this.bb.capacity() - vtableloc, this.offset() - vtableloc);
      }
      this.isNested = false;
      return vtableloc;
    };
    flatbuffers.Builder.prototype.finish = function(root_table, opt_file_identifier, opt_size_prefix) {
      var size_prefix = opt_size_prefix ? flatbuffers.SIZE_PREFIX_LENGTH : 0;
      if (opt_file_identifier) {
        var file_identifier = opt_file_identifier;
        this.prep(this.minalign, flatbuffers.SIZEOF_INT + flatbuffers.FILE_IDENTIFIER_LENGTH + size_prefix);
        if (file_identifier.length != flatbuffers.FILE_IDENTIFIER_LENGTH) {
          throw new Error("FlatBuffers: file identifier must be length " + flatbuffers.FILE_IDENTIFIER_LENGTH);
        }
        for (var i = flatbuffers.FILE_IDENTIFIER_LENGTH - 1; i >= 0; i--) {
          this.writeInt8(file_identifier.charCodeAt(i));
        }
      }
      this.prep(this.minalign, flatbuffers.SIZEOF_INT + size_prefix);
      this.addOffset(root_table);
      if (size_prefix) {
        this.addInt32(this.bb.capacity() - this.space);
      }
      this.bb.setPosition(this.space);
    };
    flatbuffers.Builder.prototype.finishSizePrefixed = function(root_table, opt_file_identifier) {
      this.finish(root_table, opt_file_identifier, true);
    };
    flatbuffers.Builder.prototype.requiredField = function(table, field) {
      var table_start = this.bb.capacity() - table;
      var vtable_start = table_start - this.bb.readInt32(table_start);
      var ok = this.bb.readInt16(vtable_start + field) != 0;
      if (!ok) {
        throw new Error("FlatBuffers: field " + field + " must be set");
      }
    };
    flatbuffers.Builder.prototype.startVector = function(elem_size, num_elems, alignment) {
      this.notNested();
      this.vector_num_elems = num_elems;
      this.prep(flatbuffers.SIZEOF_INT, elem_size * num_elems);
      this.prep(alignment, elem_size * num_elems);
    };
    flatbuffers.Builder.prototype.endVector = function() {
      this.writeInt32(this.vector_num_elems);
      return this.offset();
    };
    flatbuffers.Builder.prototype.createString = function(s) {
      if (s instanceof Uint8Array) {
        var utf8 = s;
      } else {
        var utf8 = [];
        var i = 0;
        while (i < s.length) {
          var codePoint;
          var a = s.charCodeAt(i++);
          if (a < 55296 || a >= 56320) {
            codePoint = a;
          } else {
            var b = s.charCodeAt(i++);
            codePoint = (a << 10) + b + (65536 - (55296 << 10) - 56320);
          }
          if (codePoint < 128) {
            utf8.push(codePoint);
          } else {
            if (codePoint < 2048) {
              utf8.push(codePoint >> 6 & 31 | 192);
            } else {
              if (codePoint < 65536) {
                utf8.push(codePoint >> 12 & 15 | 224);
              } else {
                utf8.push(
                  codePoint >> 18 & 7 | 240,
                  codePoint >> 12 & 63 | 128
                );
              }
              utf8.push(codePoint >> 6 & 63 | 128);
            }
            utf8.push(codePoint & 63 | 128);
          }
        }
      }
      this.addInt8(0);
      this.startVector(1, utf8.length, 1);
      this.bb.setPosition(this.space -= utf8.length);
      for (var i = 0, offset = this.space, bytes = this.bb.bytes(); i < utf8.length; i++) {
        bytes[offset++] = utf8[i];
      }
      return this.endVector();
    };
    flatbuffers.Builder.prototype.createLong = function(low, high) {
      return flatbuffers.Long.create(low, high);
    };
    flatbuffers.ByteBuffer = function(bytes) {
      this.bytes_ = bytes;
      this.position_ = 0;
    };
    flatbuffers.ByteBuffer.allocate = function(byte_size) {
      return new flatbuffers.ByteBuffer(new Uint8Array(byte_size));
    };
    flatbuffers.ByteBuffer.prototype.clear = function() {
      this.position_ = 0;
    };
    flatbuffers.ByteBuffer.prototype.bytes = function() {
      return this.bytes_;
    };
    flatbuffers.ByteBuffer.prototype.position = function() {
      return this.position_;
    };
    flatbuffers.ByteBuffer.prototype.setPosition = function(position) {
      this.position_ = position;
    };
    flatbuffers.ByteBuffer.prototype.capacity = function() {
      return this.bytes_.length;
    };
    flatbuffers.ByteBuffer.prototype.readInt8 = function(offset) {
      return this.readUint8(offset) << 24 >> 24;
    };
    flatbuffers.ByteBuffer.prototype.readUint8 = function(offset) {
      return this.bytes_[offset];
    };
    flatbuffers.ByteBuffer.prototype.readInt16 = function(offset) {
      return this.readUint16(offset) << 16 >> 16;
    };
    flatbuffers.ByteBuffer.prototype.readUint16 = function(offset) {
      return this.bytes_[offset] | this.bytes_[offset + 1] << 8;
    };
    flatbuffers.ByteBuffer.prototype.readInt32 = function(offset) {
      return this.bytes_[offset] | this.bytes_[offset + 1] << 8 | this.bytes_[offset + 2] << 16 | this.bytes_[offset + 3] << 24;
    };
    flatbuffers.ByteBuffer.prototype.readUint32 = function(offset) {
      return this.readInt32(offset) >>> 0;
    };
    flatbuffers.ByteBuffer.prototype.readInt64 = function(offset) {
      return new flatbuffers.Long(this.readInt32(offset), this.readInt32(offset + 4));
    };
    flatbuffers.ByteBuffer.prototype.readUint64 = function(offset) {
      return new flatbuffers.Long(this.readUint32(offset), this.readUint32(offset + 4));
    };
    flatbuffers.ByteBuffer.prototype.readFloat32 = function(offset) {
      flatbuffers.int32[0] = this.readInt32(offset);
      return flatbuffers.float32[0];
    };
    flatbuffers.ByteBuffer.prototype.readFloat64 = function(offset) {
      flatbuffers.int32[flatbuffers.isLittleEndian ? 0 : 1] = this.readInt32(offset);
      flatbuffers.int32[flatbuffers.isLittleEndian ? 1 : 0] = this.readInt32(offset + 4);
      return flatbuffers.float64[0];
    };
    flatbuffers.ByteBuffer.prototype.writeInt8 = function(offset, value) {
      this.bytes_[offset] = /** @type {number} */
      value;
    };
    flatbuffers.ByteBuffer.prototype.writeUint8 = function(offset, value) {
      this.bytes_[offset] = value;
    };
    flatbuffers.ByteBuffer.prototype.writeInt16 = function(offset, value) {
      this.bytes_[offset] = value;
      this.bytes_[offset + 1] = value >> 8;
    };
    flatbuffers.ByteBuffer.prototype.writeUint16 = function(offset, value) {
      this.bytes_[offset] = value;
      this.bytes_[offset + 1] = value >> 8;
    };
    flatbuffers.ByteBuffer.prototype.writeInt32 = function(offset, value) {
      this.bytes_[offset] = value;
      this.bytes_[offset + 1] = value >> 8;
      this.bytes_[offset + 2] = value >> 16;
      this.bytes_[offset + 3] = value >> 24;
    };
    flatbuffers.ByteBuffer.prototype.writeUint32 = function(offset, value) {
      this.bytes_[offset] = value;
      this.bytes_[offset + 1] = value >> 8;
      this.bytes_[offset + 2] = value >> 16;
      this.bytes_[offset + 3] = value >> 24;
    };
    flatbuffers.ByteBuffer.prototype.writeInt64 = function(offset, value) {
      this.writeInt32(offset, value.low);
      this.writeInt32(offset + 4, value.high);
    };
    flatbuffers.ByteBuffer.prototype.writeUint64 = function(offset, value) {
      this.writeUint32(offset, value.low);
      this.writeUint32(offset + 4, value.high);
    };
    flatbuffers.ByteBuffer.prototype.writeFloat32 = function(offset, value) {
      flatbuffers.float32[0] = value;
      this.writeInt32(offset, flatbuffers.int32[0]);
    };
    flatbuffers.ByteBuffer.prototype.writeFloat64 = function(offset, value) {
      flatbuffers.float64[0] = value;
      this.writeInt32(offset, flatbuffers.int32[flatbuffers.isLittleEndian ? 0 : 1]);
      this.writeInt32(offset + 4, flatbuffers.int32[flatbuffers.isLittleEndian ? 1 : 0]);
    };
    flatbuffers.ByteBuffer.prototype.getBufferIdentifier = function() {
      if (this.bytes_.length < this.position_ + flatbuffers.SIZEOF_INT + flatbuffers.FILE_IDENTIFIER_LENGTH) {
        throw new Error(
          "FlatBuffers: ByteBuffer is too short to contain an identifier."
        );
      }
      var result = "";
      for (var i = 0; i < flatbuffers.FILE_IDENTIFIER_LENGTH; i++) {
        result += String.fromCharCode(
          this.readInt8(this.position_ + flatbuffers.SIZEOF_INT + i)
        );
      }
      return result;
    };
    flatbuffers.ByteBuffer.prototype.__offset = function(bb_pos, vtable_offset) {
      var vtable = bb_pos - this.readInt32(bb_pos);
      return vtable_offset < this.readInt16(vtable) ? this.readInt16(vtable + vtable_offset) : 0;
    };
    flatbuffers.ByteBuffer.prototype.__union = function(t, offset) {
      t.bb_pos = offset + this.readInt32(offset);
      t.bb = this;
      return t;
    };
    flatbuffers.ByteBuffer.prototype.__string = function(offset, opt_encoding) {
      offset += this.readInt32(offset);
      var length = this.readInt32(offset);
      var result = "";
      var i = 0;
      offset += flatbuffers.SIZEOF_INT;
      if (opt_encoding === flatbuffers.Encoding.UTF8_BYTES) {
        return this.bytes_.subarray(offset, offset + length);
      }
      while (i < length) {
        var codePoint;
        var a = this.readUint8(offset + i++);
        if (a < 192) {
          codePoint = a;
        } else {
          var b = this.readUint8(offset + i++);
          if (a < 224) {
            codePoint = (a & 31) << 6 | b & 63;
          } else {
            var c = this.readUint8(offset + i++);
            if (a < 240) {
              codePoint = (a & 15) << 12 | (b & 63) << 6 | c & 63;
            } else {
              var d = this.readUint8(offset + i++);
              codePoint = (a & 7) << 18 | (b & 63) << 12 | (c & 63) << 6 | d & 63;
            }
          }
        }
        if (codePoint < 65536) {
          result += String.fromCharCode(codePoint);
        } else {
          codePoint -= 65536;
          result += String.fromCharCode(
            (codePoint >> 10) + 55296,
            (codePoint & (1 << 10) - 1) + 56320
          );
        }
      }
      return result;
    };
    flatbuffers.ByteBuffer.prototype.__indirect = function(offset) {
      return offset + this.readInt32(offset);
    };
    flatbuffers.ByteBuffer.prototype.__vector = function(offset) {
      return offset + this.readInt32(offset) + flatbuffers.SIZEOF_INT;
    };
    flatbuffers.ByteBuffer.prototype.__vector_len = function(offset) {
      return this.readInt32(offset + this.readInt32(offset));
    };
    flatbuffers.ByteBuffer.prototype.__has_identifier = function(ident) {
      if (ident.length != flatbuffers.FILE_IDENTIFIER_LENGTH) {
        throw new Error("FlatBuffers: file identifier must be length " + flatbuffers.FILE_IDENTIFIER_LENGTH);
      }
      for (var i = 0; i < flatbuffers.FILE_IDENTIFIER_LENGTH; i++) {
        if (ident.charCodeAt(i) != this.readInt8(this.position_ + flatbuffers.SIZEOF_INT + i)) {
          return false;
        }
      }
      return true;
    };
    flatbuffers.ByteBuffer.prototype.createLong = function(low, high) {
      return flatbuffers.Long.create(low, high);
    };
  }
});

// web/lib/onnxjs/ort-schema/flatbuffers/ort-generated.ts
var onnxruntime;
var init_ort_generated = __esm({
  "web/lib/onnxjs/ort-schema/flatbuffers/ort-generated.ts"() {
    "use strict";
    init_flatbuffers();
    ((onnxruntime2) => {
      let experimental;
      ((experimental2) => {
        let fbs;
        ((fbs2) => {
          let AttributeType;
          ((AttributeType2) => {
            AttributeType2[AttributeType2["UNDEFINED"] = 0] = "UNDEFINED";
            AttributeType2[AttributeType2["FLOAT"] = 1] = "FLOAT";
            AttributeType2[AttributeType2["INT"] = 2] = "INT";
            AttributeType2[AttributeType2["STRING"] = 3] = "STRING";
            AttributeType2[AttributeType2["TENSOR"] = 4] = "TENSOR";
            AttributeType2[AttributeType2["GRAPH"] = 5] = "GRAPH";
            AttributeType2[AttributeType2["FLOATS"] = 6] = "FLOATS";
            AttributeType2[AttributeType2["INTS"] = 7] = "INTS";
            AttributeType2[AttributeType2["STRINGS"] = 8] = "STRINGS";
            AttributeType2[AttributeType2["TENSORS"] = 9] = "TENSORS";
            AttributeType2[AttributeType2["GRAPHS"] = 10] = "GRAPHS";
            AttributeType2[AttributeType2["SPARSE_TENSOR"] = 11] = "SPARSE_TENSOR";
            AttributeType2[AttributeType2["SPARSE_TENSORS"] = 12] = "SPARSE_TENSORS";
          })(AttributeType = fbs2.AttributeType || (fbs2.AttributeType = {}));
        })(fbs = experimental2.fbs || (experimental2.fbs = {}));
      })(experimental = onnxruntime2.experimental || (onnxruntime2.experimental = {}));
    })(onnxruntime || (onnxruntime = {}));
    ((onnxruntime2) => {
      let experimental;
      ((experimental2) => {
        let fbs;
        ((fbs2) => {
          let DimensionValueType;
          ((DimensionValueType2) => {
            DimensionValueType2[DimensionValueType2["UNKNOWN"] = 0] = "UNKNOWN";
            DimensionValueType2[DimensionValueType2["VALUE"] = 1] = "VALUE";
            DimensionValueType2[DimensionValueType2["PARAM"] = 2] = "PARAM";
          })(DimensionValueType = fbs2.DimensionValueType || (fbs2.DimensionValueType = {}));
        })(fbs = experimental2.fbs || (experimental2.fbs = {}));
      })(experimental = onnxruntime2.experimental || (onnxruntime2.experimental = {}));
    })(onnxruntime || (onnxruntime = {}));
    ((onnxruntime2) => {
      let experimental;
      ((experimental2) => {
        let fbs;
        ((fbs2) => {
          let TensorDataType;
          ((TensorDataType2) => {
            TensorDataType2[TensorDataType2["UNDEFINED"] = 0] = "UNDEFINED";
            TensorDataType2[TensorDataType2["FLOAT"] = 1] = "FLOAT";
            TensorDataType2[TensorDataType2["UINT8"] = 2] = "UINT8";
            TensorDataType2[TensorDataType2["INT8"] = 3] = "INT8";
            TensorDataType2[TensorDataType2["UINT16"] = 4] = "UINT16";
            TensorDataType2[TensorDataType2["INT16"] = 5] = "INT16";
            TensorDataType2[TensorDataType2["INT32"] = 6] = "INT32";
            TensorDataType2[TensorDataType2["INT64"] = 7] = "INT64";
            TensorDataType2[TensorDataType2["STRING"] = 8] = "STRING";
            TensorDataType2[TensorDataType2["BOOL"] = 9] = "BOOL";
            TensorDataType2[TensorDataType2["FLOAT16"] = 10] = "FLOAT16";
            TensorDataType2[TensorDataType2["DOUBLE"] = 11] = "DOUBLE";
            TensorDataType2[TensorDataType2["UINT32"] = 12] = "UINT32";
            TensorDataType2[TensorDataType2["UINT64"] = 13] = "UINT64";
            TensorDataType2[TensorDataType2["COMPLEX64"] = 14] = "COMPLEX64";
            TensorDataType2[TensorDataType2["COMPLEX128"] = 15] = "COMPLEX128";
            TensorDataType2[TensorDataType2["BFLOAT16"] = 16] = "BFLOAT16";
            TensorDataType2[TensorDataType2["FLOAT8E4M3FN"] = 17] = "FLOAT8E4M3FN";
            TensorDataType2[TensorDataType2["FLOAT8E4M3FNUZ"] = 18] = "FLOAT8E4M3FNUZ";
            TensorDataType2[TensorDataType2["FLOAT8E5M2"] = 19] = "FLOAT8E5M2";
            TensorDataType2[TensorDataType2["FLOAT8E5M2FNUZ"] = 20] = "FLOAT8E5M2FNUZ";
          })(TensorDataType = fbs2.TensorDataType || (fbs2.TensorDataType = {}));
        })(fbs = experimental2.fbs || (experimental2.fbs = {}));
      })(experimental = onnxruntime2.experimental || (onnxruntime2.experimental = {}));
    })(onnxruntime || (onnxruntime = {}));
    ((onnxruntime2) => {
      let experimental;
      ((experimental2) => {
        let fbs;
        ((fbs2) => {
          let NodeType;
          ((NodeType2) => {
            NodeType2[NodeType2["Primitive"] = 0] = "Primitive";
            NodeType2[NodeType2["Fused"] = 1] = "Fused";
          })(NodeType = fbs2.NodeType || (fbs2.NodeType = {}));
        })(fbs = experimental2.fbs || (experimental2.fbs = {}));
      })(experimental = onnxruntime2.experimental || (onnxruntime2.experimental = {}));
    })(onnxruntime || (onnxruntime = {}));
    ((onnxruntime2) => {
      let experimental;
      ((experimental2) => {
        let fbs;
        ((fbs2) => {
          let TypeInfoValue;
          ((TypeInfoValue2) => {
            TypeInfoValue2[TypeInfoValue2["NONE"] = 0] = "NONE";
            TypeInfoValue2[TypeInfoValue2["tensor_type"] = 1] = "tensor_type";
            TypeInfoValue2[TypeInfoValue2["sequence_type"] = 2] = "sequence_type";
            TypeInfoValue2[TypeInfoValue2["map_type"] = 3] = "map_type";
          })(TypeInfoValue = fbs2.TypeInfoValue || (fbs2.TypeInfoValue = {}));
        })(fbs = experimental2.fbs || (experimental2.fbs = {}));
      })(experimental = onnxruntime2.experimental || (onnxruntime2.experimental = {}));
    })(onnxruntime || (onnxruntime = {}));
    ((onnxruntime2) => {
      let experimental;
      ((experimental2) => {
        let fbs;
        ((fbs2) => {
          class Shape {
            constructor() {
              this.bb = null;
              this.bb_pos = 0;
            }
            /**
             * @param number i
             * @param flatbuffers.ByteBuffer bb
             * @returns Shape
             */
            __init(i, bb) {
              this.bb_pos = i;
              this.bb = bb;
              return this;
            }
            /**
             * @param flatbuffers.ByteBuffer bb
             * @param Shape= obj
             * @returns Shape
             */
            static getRootAsShape(bb, obj) {
              return (obj || new Shape()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
            }
            /**
             * @param flatbuffers.ByteBuffer bb
             * @param Shape= obj
             * @returns Shape
             */
            static getSizePrefixedRootAsShape(bb, obj) {
              bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
              return (obj || new Shape()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
            }
            /**
             * @param number index
             * @param onnxruntime.experimental.fbs.Dimension= obj
             * @returns onnxruntime.experimental.fbs.Dimension
             */
            dim(index, obj) {
              let offset = this.bb.__offset(this.bb_pos, 4);
              return offset ? (obj || new onnxruntime2.experimental.fbs.Dimension()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
            }
            /**
             * @returns number
             */
            dimLength() {
              let offset = this.bb.__offset(this.bb_pos, 4);
              return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
            }
            /**
             * @param flatbuffers.Builder builder
             */
            static startShape(builder) {
              builder.startObject(1);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset dimOffset
             */
            static addDim(builder, dimOffset) {
              builder.addFieldOffset(0, dimOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param Array.<flatbuffers.Offset> data
             * @returns flatbuffers.Offset
             */
            static createDimVector(builder, data) {
              builder.startVector(4, data.length, 4);
              for (let i = data.length - 1; i >= 0; i--) {
                builder.addOffset(data[i]);
              }
              return builder.endVector();
            }
            /**
             * @param flatbuffers.Builder builder
             * @param number numElems
             */
            static startDimVector(builder, numElems) {
              builder.startVector(4, numElems, 4);
            }
            /**
             * @param flatbuffers.Builder builder
             * @returns flatbuffers.Offset
             */
            static endShape(builder) {
              let offset = builder.endObject();
              return offset;
            }
            static createShape(builder, dimOffset) {
              Shape.startShape(builder);
              Shape.addDim(builder, dimOffset);
              return Shape.endShape(builder);
            }
          }
          fbs2.Shape = Shape;
        })(fbs = experimental2.fbs || (experimental2.fbs = {}));
      })(experimental = onnxruntime2.experimental || (onnxruntime2.experimental = {}));
    })(onnxruntime || (onnxruntime = {}));
    ((onnxruntime2) => {
      let experimental;
      ((experimental2) => {
        let fbs;
        ((fbs2) => {
          class Dimension {
            constructor() {
              this.bb = null;
              this.bb_pos = 0;
            }
            /**
             * @param number i
             * @param flatbuffers.ByteBuffer bb
             * @returns Dimension
             */
            __init(i, bb) {
              this.bb_pos = i;
              this.bb = bb;
              return this;
            }
            /**
             * @param flatbuffers.ByteBuffer bb
             * @param Dimension= obj
             * @returns Dimension
             */
            static getRootAsDimension(bb, obj) {
              return (obj || new Dimension()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
            }
            /**
             * @param flatbuffers.ByteBuffer bb
             * @param Dimension= obj
             * @returns Dimension
             */
            static getSizePrefixedRootAsDimension(bb, obj) {
              bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
              return (obj || new Dimension()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
            }
            /**
             * @param onnxruntime.experimental.fbs.DimensionValue= obj
             * @returns onnxruntime.experimental.fbs.DimensionValue|null
             */
            value(obj) {
              let offset = this.bb.__offset(this.bb_pos, 4);
              return offset ? (obj || new onnxruntime2.experimental.fbs.DimensionValue()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
            }
            denotation(optionalEncoding) {
              let offset = this.bb.__offset(this.bb_pos, 6);
              return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
            }
            /**
             * @param flatbuffers.Builder builder
             */
            static startDimension(builder) {
              builder.startObject(2);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset valueOffset
             */
            static addValue(builder, valueOffset) {
              builder.addFieldOffset(0, valueOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset denotationOffset
             */
            static addDenotation(builder, denotationOffset) {
              builder.addFieldOffset(1, denotationOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @returns flatbuffers.Offset
             */
            static endDimension(builder) {
              let offset = builder.endObject();
              return offset;
            }
            static createDimension(builder, valueOffset, denotationOffset) {
              Dimension.startDimension(builder);
              Dimension.addValue(builder, valueOffset);
              Dimension.addDenotation(builder, denotationOffset);
              return Dimension.endDimension(builder);
            }
          }
          fbs2.Dimension = Dimension;
        })(fbs = experimental2.fbs || (experimental2.fbs = {}));
      })(experimental = onnxruntime2.experimental || (onnxruntime2.experimental = {}));
    })(onnxruntime || (onnxruntime = {}));
    ((onnxruntime2) => {
      let experimental;
      ((experimental2) => {
        let fbs;
        ((fbs2) => {
          class DimensionValue {
            constructor() {
              this.bb = null;
              this.bb_pos = 0;
            }
            /**
             * @param number i
             * @param flatbuffers.ByteBuffer bb
             * @returns DimensionValue
             */
            __init(i, bb) {
              this.bb_pos = i;
              this.bb = bb;
              return this;
            }
            /**
             * @param flatbuffers.ByteBuffer bb
             * @param DimensionValue= obj
             * @returns DimensionValue
             */
            static getRootAsDimensionValue(bb, obj) {
              return (obj || new DimensionValue()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
            }
            /**
             * @param flatbuffers.ByteBuffer bb
             * @param DimensionValue= obj
             * @returns DimensionValue
             */
            static getSizePrefixedRootAsDimensionValue(bb, obj) {
              bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
              return (obj || new DimensionValue()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
            }
            /**
             * @returns onnxruntime.experimental.fbs.DimensionValueType
             */
            dimType() {
              let offset = this.bb.__offset(this.bb_pos, 4);
              return offset ? (
                /**  */
                this.bb.readInt8(this.bb_pos + offset)
              ) : 0 /* UNKNOWN */;
            }
            /**
             * @returns flatbuffers.Long
             */
            dimValue() {
              let offset = this.bb.__offset(this.bb_pos, 6);
              return offset ? this.bb.readInt64(this.bb_pos + offset) : this.bb.createLong(0, 0);
            }
            dimParam(optionalEncoding) {
              let offset = this.bb.__offset(this.bb_pos, 8);
              return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
            }
            /**
             * @param flatbuffers.Builder builder
             */
            static startDimensionValue(builder) {
              builder.startObject(3);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param onnxruntime.experimental.fbs.DimensionValueType dimType
             */
            static addDimType(builder, dimType) {
              builder.addFieldInt8(0, dimType, 0 /* UNKNOWN */);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Long dimValue
             */
            static addDimValue(builder, dimValue) {
              builder.addFieldInt64(1, dimValue, builder.createLong(0, 0));
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset dimParamOffset
             */
            static addDimParam(builder, dimParamOffset) {
              builder.addFieldOffset(2, dimParamOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @returns flatbuffers.Offset
             */
            static endDimensionValue(builder) {
              let offset = builder.endObject();
              return offset;
            }
            static createDimensionValue(builder, dimType, dimValue, dimParamOffset) {
              DimensionValue.startDimensionValue(builder);
              DimensionValue.addDimType(builder, dimType);
              DimensionValue.addDimValue(builder, dimValue);
              DimensionValue.addDimParam(builder, dimParamOffset);
              return DimensionValue.endDimensionValue(builder);
            }
          }
          fbs2.DimensionValue = DimensionValue;
        })(fbs = experimental2.fbs || (experimental2.fbs = {}));
      })(experimental = onnxruntime2.experimental || (onnxruntime2.experimental = {}));
    })(onnxruntime || (onnxruntime = {}));
    ((onnxruntime2) => {
      let experimental;
      ((experimental2) => {
        let fbs;
        ((fbs2) => {
          class TensorTypeAndShape {
            constructor() {
              this.bb = null;
              this.bb_pos = 0;
            }
            /**
             * @param number i
             * @param flatbuffers.ByteBuffer bb
             * @returns TensorTypeAndShape
             */
            __init(i, bb) {
              this.bb_pos = i;
              this.bb = bb;
              return this;
            }
            /**
             * @param flatbuffers.ByteBuffer bb
             * @param TensorTypeAndShape= obj
             * @returns TensorTypeAndShape
             */
            static getRootAsTensorTypeAndShape(bb, obj) {
              return (obj || new TensorTypeAndShape()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
            }
            /**
             * @param flatbuffers.ByteBuffer bb
             * @param TensorTypeAndShape= obj
             * @returns TensorTypeAndShape
             */
            static getSizePrefixedRootAsTensorTypeAndShape(bb, obj) {
              bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
              return (obj || new TensorTypeAndShape()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
            }
            /**
             * @returns onnxruntime.experimental.fbs.TensorDataType
             */
            elemType() {
              let offset = this.bb.__offset(this.bb_pos, 4);
              return offset ? (
                /**  */
                this.bb.readInt32(this.bb_pos + offset)
              ) : 0 /* UNDEFINED */;
            }
            /**
             * @param onnxruntime.experimental.fbs.Shape= obj
             * @returns onnxruntime.experimental.fbs.Shape|null
             */
            shape(obj) {
              let offset = this.bb.__offset(this.bb_pos, 6);
              return offset ? (obj || new onnxruntime2.experimental.fbs.Shape()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
            }
            /**
             * @param flatbuffers.Builder builder
             */
            static startTensorTypeAndShape(builder) {
              builder.startObject(2);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param onnxruntime.experimental.fbs.TensorDataType elemType
             */
            static addElemType(builder, elemType) {
              builder.addFieldInt32(0, elemType, 0 /* UNDEFINED */);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset shapeOffset
             */
            static addShape(builder, shapeOffset) {
              builder.addFieldOffset(1, shapeOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @returns flatbuffers.Offset
             */
            static endTensorTypeAndShape(builder) {
              let offset = builder.endObject();
              return offset;
            }
            static createTensorTypeAndShape(builder, elemType, shapeOffset) {
              TensorTypeAndShape.startTensorTypeAndShape(builder);
              TensorTypeAndShape.addElemType(builder, elemType);
              TensorTypeAndShape.addShape(builder, shapeOffset);
              return TensorTypeAndShape.endTensorTypeAndShape(builder);
            }
          }
          fbs2.TensorTypeAndShape = TensorTypeAndShape;
        })(fbs = experimental2.fbs || (experimental2.fbs = {}));
      })(experimental = onnxruntime2.experimental || (onnxruntime2.experimental = {}));
    })(onnxruntime || (onnxruntime = {}));
    ((onnxruntime2) => {
      let experimental;
      ((experimental2) => {
        let fbs;
        ((fbs2) => {
          class MapType {
            constructor() {
              this.bb = null;
              this.bb_pos = 0;
            }
            /**
             * @param number i
             * @param flatbuffers.ByteBuffer bb
             * @returns MapType
             */
            __init(i, bb) {
              this.bb_pos = i;
              this.bb = bb;
              return this;
            }
            /**
             * @param flatbuffers.ByteBuffer bb
             * @param MapType= obj
             * @returns MapType
             */
            static getRootAsMapType(bb, obj) {
              return (obj || new MapType()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
            }
            /**
             * @param flatbuffers.ByteBuffer bb
             * @param MapType= obj
             * @returns MapType
             */
            static getSizePrefixedRootAsMapType(bb, obj) {
              bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
              return (obj || new MapType()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
            }
            /**
             * @returns onnxruntime.experimental.fbs.TensorDataType
             */
            keyType() {
              let offset = this.bb.__offset(this.bb_pos, 4);
              return offset ? (
                /**  */
                this.bb.readInt32(this.bb_pos + offset)
              ) : 0 /* UNDEFINED */;
            }
            /**
             * @param onnxruntime.experimental.fbs.TypeInfo= obj
             * @returns onnxruntime.experimental.fbs.TypeInfo|null
             */
            valueType(obj) {
              let offset = this.bb.__offset(this.bb_pos, 6);
              return offset ? (obj || new onnxruntime2.experimental.fbs.TypeInfo()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
            }
            /**
             * @param flatbuffers.Builder builder
             */
            static startMapType(builder) {
              builder.startObject(2);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param onnxruntime.experimental.fbs.TensorDataType keyType
             */
            static addKeyType(builder, keyType) {
              builder.addFieldInt32(0, keyType, 0 /* UNDEFINED */);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset valueTypeOffset
             */
            static addValueType(builder, valueTypeOffset) {
              builder.addFieldOffset(1, valueTypeOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @returns flatbuffers.Offset
             */
            static endMapType(builder) {
              let offset = builder.endObject();
              return offset;
            }
            static createMapType(builder, keyType, valueTypeOffset) {
              MapType.startMapType(builder);
              MapType.addKeyType(builder, keyType);
              MapType.addValueType(builder, valueTypeOffset);
              return MapType.endMapType(builder);
            }
          }
          fbs2.MapType = MapType;
        })(fbs = experimental2.fbs || (experimental2.fbs = {}));
      })(experimental = onnxruntime2.experimental || (onnxruntime2.experimental = {}));
    })(onnxruntime || (onnxruntime = {}));
    ((onnxruntime2) => {
      let experimental;
      ((experimental2) => {
        let fbs;
        ((fbs2) => {
          class SequenceType {
            constructor() {
              this.bb = null;
              this.bb_pos = 0;
            }
            /**
             * @param number i
             * @param flatbuffers.ByteBuffer bb
             * @returns SequenceType
             */
            __init(i, bb) {
              this.bb_pos = i;
              this.bb = bb;
              return this;
            }
            /**
             * @param flatbuffers.ByteBuffer bb
             * @param SequenceType= obj
             * @returns SequenceType
             */
            static getRootAsSequenceType(bb, obj) {
              return (obj || new SequenceType()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
            }
            /**
             * @param flatbuffers.ByteBuffer bb
             * @param SequenceType= obj
             * @returns SequenceType
             */
            static getSizePrefixedRootAsSequenceType(bb, obj) {
              bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
              return (obj || new SequenceType()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
            }
            /**
             * @param onnxruntime.experimental.fbs.TypeInfo= obj
             * @returns onnxruntime.experimental.fbs.TypeInfo|null
             */
            elemType(obj) {
              let offset = this.bb.__offset(this.bb_pos, 4);
              return offset ? (obj || new onnxruntime2.experimental.fbs.TypeInfo()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
            }
            /**
             * @param flatbuffers.Builder builder
             */
            static startSequenceType(builder) {
              builder.startObject(1);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset elemTypeOffset
             */
            static addElemType(builder, elemTypeOffset) {
              builder.addFieldOffset(0, elemTypeOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @returns flatbuffers.Offset
             */
            static endSequenceType(builder) {
              let offset = builder.endObject();
              return offset;
            }
            static createSequenceType(builder, elemTypeOffset) {
              SequenceType.startSequenceType(builder);
              SequenceType.addElemType(builder, elemTypeOffset);
              return SequenceType.endSequenceType(builder);
            }
          }
          fbs2.SequenceType = SequenceType;
        })(fbs = experimental2.fbs || (experimental2.fbs = {}));
      })(experimental = onnxruntime2.experimental || (onnxruntime2.experimental = {}));
    })(onnxruntime || (onnxruntime = {}));
    ((onnxruntime2) => {
      let experimental;
      ((experimental2) => {
        let fbs;
        ((fbs2) => {
          class EdgeEnd {
            constructor() {
              this.bb = null;
              this.bb_pos = 0;
            }
            /**
             * @param number i
             * @param flatbuffers.ByteBuffer bb
             * @returns EdgeEnd
             */
            __init(i, bb) {
              this.bb_pos = i;
              this.bb = bb;
              return this;
            }
            /**
             * @returns number
             */
            nodeIndex() {
              return this.bb.readUint32(this.bb_pos);
            }
            /**
             * @returns number
             */
            srcArgIndex() {
              return this.bb.readInt32(this.bb_pos + 4);
            }
            /**
             * @returns number
             */
            dstArgIndex() {
              return this.bb.readInt32(this.bb_pos + 8);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param number node_index
             * @param number src_arg_index
             * @param number dst_arg_index
             * @returns flatbuffers.Offset
             */
            static createEdgeEnd(builder, node_index, src_arg_index, dst_arg_index) {
              builder.prep(4, 12);
              builder.writeInt32(dst_arg_index);
              builder.writeInt32(src_arg_index);
              builder.writeInt32(node_index);
              return builder.offset();
            }
          }
          fbs2.EdgeEnd = EdgeEnd;
        })(fbs = experimental2.fbs || (experimental2.fbs = {}));
      })(experimental = onnxruntime2.experimental || (onnxruntime2.experimental = {}));
    })(onnxruntime || (onnxruntime = {}));
    ((onnxruntime2) => {
      let experimental;
      ((experimental2) => {
        let fbs;
        ((fbs2) => {
          class NodeEdge {
            constructor() {
              this.bb = null;
              this.bb_pos = 0;
            }
            /**
             * @param number i
             * @param flatbuffers.ByteBuffer bb
             * @returns NodeEdge
             */
            __init(i, bb) {
              this.bb_pos = i;
              this.bb = bb;
              return this;
            }
            /**
             * @param flatbuffers.ByteBuffer bb
             * @param NodeEdge= obj
             * @returns NodeEdge
             */
            static getRootAsNodeEdge(bb, obj) {
              return (obj || new NodeEdge()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
            }
            /**
             * @param flatbuffers.ByteBuffer bb
             * @param NodeEdge= obj
             * @returns NodeEdge
             */
            static getSizePrefixedRootAsNodeEdge(bb, obj) {
              bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
              return (obj || new NodeEdge()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
            }
            /**
             * @returns number
             */
            nodeIndex() {
              let offset = this.bb.__offset(this.bb_pos, 4);
              return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
            }
            /**
             * @param number index
             * @param onnxruntime.experimental.fbs.EdgeEnd= obj
             * @returns onnxruntime.experimental.fbs.EdgeEnd
             */
            inputEdges(index, obj) {
              let offset = this.bb.__offset(this.bb_pos, 6);
              return offset ? (obj || new onnxruntime2.experimental.fbs.EdgeEnd()).__init(this.bb.__vector(this.bb_pos + offset) + index * 12, this.bb) : null;
            }
            /**
             * @returns number
             */
            inputEdgesLength() {
              let offset = this.bb.__offset(this.bb_pos, 6);
              return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
            }
            /**
             * @param number index
             * @param onnxruntime.experimental.fbs.EdgeEnd= obj
             * @returns onnxruntime.experimental.fbs.EdgeEnd
             */
            outputEdges(index, obj) {
              let offset = this.bb.__offset(this.bb_pos, 8);
              return offset ? (obj || new onnxruntime2.experimental.fbs.EdgeEnd()).__init(this.bb.__vector(this.bb_pos + offset) + index * 12, this.bb) : null;
            }
            /**
             * @returns number
             */
            outputEdgesLength() {
              let offset = this.bb.__offset(this.bb_pos, 8);
              return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
            }
            /**
             * @param flatbuffers.Builder builder
             */
            static startNodeEdge(builder) {
              builder.startObject(3);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param number nodeIndex
             */
            static addNodeIndex(builder, nodeIndex) {
              builder.addFieldInt32(0, nodeIndex, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset inputEdgesOffset
             */
            static addInputEdges(builder, inputEdgesOffset) {
              builder.addFieldOffset(1, inputEdgesOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param number numElems
             */
            static startInputEdgesVector(builder, numElems) {
              builder.startVector(12, numElems, 4);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset outputEdgesOffset
             */
            static addOutputEdges(builder, outputEdgesOffset) {
              builder.addFieldOffset(2, outputEdgesOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param number numElems
             */
            static startOutputEdgesVector(builder, numElems) {
              builder.startVector(12, numElems, 4);
            }
            /**
             * @param flatbuffers.Builder builder
             * @returns flatbuffers.Offset
             */
            static endNodeEdge(builder) {
              let offset = builder.endObject();
              return offset;
            }
            static createNodeEdge(builder, nodeIndex, inputEdgesOffset, outputEdgesOffset) {
              NodeEdge.startNodeEdge(builder);
              NodeEdge.addNodeIndex(builder, nodeIndex);
              NodeEdge.addInputEdges(builder, inputEdgesOffset);
              NodeEdge.addOutputEdges(builder, outputEdgesOffset);
              return NodeEdge.endNodeEdge(builder);
            }
          }
          fbs2.NodeEdge = NodeEdge;
        })(fbs = experimental2.fbs || (experimental2.fbs = {}));
      })(experimental = onnxruntime2.experimental || (onnxruntime2.experimental = {}));
    })(onnxruntime || (onnxruntime = {}));
    ((onnxruntime2) => {
      let experimental;
      ((experimental2) => {
        let fbs;
        ((fbs2) => {
          class Node2 {
            constructor() {
              this.bb = null;
              this.bb_pos = 0;
            }
            /**
             * @param number i
             * @param flatbuffers.ByteBuffer bb
             * @returns Node
             */
            __init(i, bb) {
              this.bb_pos = i;
              this.bb = bb;
              return this;
            }
            /**
             * @param flatbuffers.ByteBuffer bb
             * @param Node= obj
             * @returns Node
             */
            static getRootAsNode(bb, obj) {
              return (obj || new Node2()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
            }
            /**
             * @param flatbuffers.ByteBuffer bb
             * @param Node= obj
             * @returns Node
             */
            static getSizePrefixedRootAsNode(bb, obj) {
              bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
              return (obj || new Node2()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
            }
            name(optionalEncoding) {
              let offset = this.bb.__offset(this.bb_pos, 4);
              return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
            }
            docString(optionalEncoding) {
              let offset = this.bb.__offset(this.bb_pos, 6);
              return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
            }
            domain(optionalEncoding) {
              let offset = this.bb.__offset(this.bb_pos, 8);
              return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
            }
            /**
             * @returns number
             */
            sinceVersion() {
              let offset = this.bb.__offset(this.bb_pos, 10);
              return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
            }
            /**
             * @returns number
             */
            index() {
              let offset = this.bb.__offset(this.bb_pos, 12);
              return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
            }
            opType(optionalEncoding) {
              let offset = this.bb.__offset(this.bb_pos, 14);
              return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
            }
            /**
             * @returns onnxruntime.experimental.fbs.NodeType
             */
            type() {
              let offset = this.bb.__offset(this.bb_pos, 16);
              return offset ? (
                /**  */
                this.bb.readInt32(this.bb_pos + offset)
              ) : 0 /* Primitive */;
            }
            executionProviderType(optionalEncoding) {
              let offset = this.bb.__offset(this.bb_pos, 18);
              return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
            }
            inputs(index, optionalEncoding) {
              let offset = this.bb.__offset(this.bb_pos, 20);
              return offset ? this.bb.__string(this.bb.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
            }
            /**
             * @returns number
             */
            inputsLength() {
              let offset = this.bb.__offset(this.bb_pos, 20);
              return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
            }
            outputs(index, optionalEncoding) {
              let offset = this.bb.__offset(this.bb_pos, 22);
              return offset ? this.bb.__string(this.bb.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
            }
            /**
             * @returns number
             */
            outputsLength() {
              let offset = this.bb.__offset(this.bb_pos, 22);
              return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
            }
            /**
             * @param number index
             * @param onnxruntime.experimental.fbs.Attribute= obj
             * @returns onnxruntime.experimental.fbs.Attribute
             */
            attributes(index, obj) {
              let offset = this.bb.__offset(this.bb_pos, 24);
              return offset ? (obj || new onnxruntime2.experimental.fbs.Attribute()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
            }
            /**
             * @returns number
             */
            attributesLength() {
              let offset = this.bb.__offset(this.bb_pos, 24);
              return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
            }
            /**
             * @param number index
             * @returns number
             */
            inputArgCounts(index) {
              let offset = this.bb.__offset(this.bb_pos, 26);
              return offset ? this.bb.readInt32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
            }
            /**
             * @returns number
             */
            inputArgCountsLength() {
              let offset = this.bb.__offset(this.bb_pos, 26);
              return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
            }
            /**
             * @returns Int32Array
             */
            inputArgCountsArray() {
              let offset = this.bb.__offset(this.bb_pos, 26);
              return offset ? new Int32Array(
                this.bb.bytes().buffer,
                this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset),
                this.bb.__vector_len(this.bb_pos + offset)
              ) : null;
            }
            implicitInputs(index, optionalEncoding) {
              let offset = this.bb.__offset(this.bb_pos, 28);
              return offset ? this.bb.__string(this.bb.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
            }
            /**
             * @returns number
             */
            implicitInputsLength() {
              let offset = this.bb.__offset(this.bb_pos, 28);
              return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
            }
            /**
             * @param flatbuffers.Builder builder
             */
            static startNode(builder) {
              builder.startObject(13);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset nameOffset
             */
            static addName(builder, nameOffset) {
              builder.addFieldOffset(0, nameOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset docStringOffset
             */
            static addDocString(builder, docStringOffset) {
              builder.addFieldOffset(1, docStringOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset domainOffset
             */
            static addDomain(builder, domainOffset) {
              builder.addFieldOffset(2, domainOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param number sinceVersion
             */
            static addSinceVersion(builder, sinceVersion) {
              builder.addFieldInt32(3, sinceVersion, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param number index
             */
            static addIndex(builder, index) {
              builder.addFieldInt32(4, index, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset opTypeOffset
             */
            static addOpType(builder, opTypeOffset) {
              builder.addFieldOffset(5, opTypeOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param onnxruntime.experimental.fbs.NodeType type
             */
            static addType(builder, type) {
              builder.addFieldInt32(6, type, 0 /* Primitive */);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset executionProviderTypeOffset
             */
            static addExecutionProviderType(builder, executionProviderTypeOffset) {
              builder.addFieldOffset(7, executionProviderTypeOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset inputsOffset
             */
            static addInputs(builder, inputsOffset) {
              builder.addFieldOffset(8, inputsOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param Array.<flatbuffers.Offset> data
             * @returns flatbuffers.Offset
             */
            static createInputsVector(builder, data) {
              builder.startVector(4, data.length, 4);
              for (let i = data.length - 1; i >= 0; i--) {
                builder.addOffset(data[i]);
              }
              return builder.endVector();
            }
            /**
             * @param flatbuffers.Builder builder
             * @param number numElems
             */
            static startInputsVector(builder, numElems) {
              builder.startVector(4, numElems, 4);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset outputsOffset
             */
            static addOutputs(builder, outputsOffset) {
              builder.addFieldOffset(9, outputsOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param Array.<flatbuffers.Offset> data
             * @returns flatbuffers.Offset
             */
            static createOutputsVector(builder, data) {
              builder.startVector(4, data.length, 4);
              for (let i = data.length - 1; i >= 0; i--) {
                builder.addOffset(data[i]);
              }
              return builder.endVector();
            }
            /**
             * @param flatbuffers.Builder builder
             * @param number numElems
             */
            static startOutputsVector(builder, numElems) {
              builder.startVector(4, numElems, 4);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset attributesOffset
             */
            static addAttributes(builder, attributesOffset) {
              builder.addFieldOffset(10, attributesOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param Array.<flatbuffers.Offset> data
             * @returns flatbuffers.Offset
             */
            static createAttributesVector(builder, data) {
              builder.startVector(4, data.length, 4);
              for (let i = data.length - 1; i >= 0; i--) {
                builder.addOffset(data[i]);
              }
              return builder.endVector();
            }
            /**
             * @param flatbuffers.Builder builder
             * @param number numElems
             */
            static startAttributesVector(builder, numElems) {
              builder.startVector(4, numElems, 4);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset inputArgCountsOffset
             */
            static addInputArgCounts(builder, inputArgCountsOffset) {
              builder.addFieldOffset(11, inputArgCountsOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param Array.<number> data
             * @returns flatbuffers.Offset
             */
            static createInputArgCountsVector(builder, data) {
              builder.startVector(4, data.length, 4);
              for (let i = data.length - 1; i >= 0; i--) {
                builder.addInt32(data[i]);
              }
              return builder.endVector();
            }
            /**
             * @param flatbuffers.Builder builder
             * @param number numElems
             */
            static startInputArgCountsVector(builder, numElems) {
              builder.startVector(4, numElems, 4);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset implicitInputsOffset
             */
            static addImplicitInputs(builder, implicitInputsOffset) {
              builder.addFieldOffset(12, implicitInputsOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param Array.<flatbuffers.Offset> data
             * @returns flatbuffers.Offset
             */
            static createImplicitInputsVector(builder, data) {
              builder.startVector(4, data.length, 4);
              for (let i = data.length - 1; i >= 0; i--) {
                builder.addOffset(data[i]);
              }
              return builder.endVector();
            }
            /**
             * @param flatbuffers.Builder builder
             * @param number numElems
             */
            static startImplicitInputsVector(builder, numElems) {
              builder.startVector(4, numElems, 4);
            }
            /**
             * @param flatbuffers.Builder builder
             * @returns flatbuffers.Offset
             */
            static endNode(builder) {
              let offset = builder.endObject();
              return offset;
            }
            static createNode(builder, nameOffset, docStringOffset, domainOffset, sinceVersion, index, opTypeOffset, type, executionProviderTypeOffset, inputsOffset, outputsOffset, attributesOffset, inputArgCountsOffset, implicitInputsOffset) {
              Node2.startNode(builder);
              Node2.addName(builder, nameOffset);
              Node2.addDocString(builder, docStringOffset);
              Node2.addDomain(builder, domainOffset);
              Node2.addSinceVersion(builder, sinceVersion);
              Node2.addIndex(builder, index);
              Node2.addOpType(builder, opTypeOffset);
              Node2.addType(builder, type);
              Node2.addExecutionProviderType(builder, executionProviderTypeOffset);
              Node2.addInputs(builder, inputsOffset);
              Node2.addOutputs(builder, outputsOffset);
              Node2.addAttributes(builder, attributesOffset);
              Node2.addInputArgCounts(builder, inputArgCountsOffset);
              Node2.addImplicitInputs(builder, implicitInputsOffset);
              return Node2.endNode(builder);
            }
          }
          fbs2.Node = Node2;
        })(fbs = experimental2.fbs || (experimental2.fbs = {}));
      })(experimental = onnxruntime2.experimental || (onnxruntime2.experimental = {}));
    })(onnxruntime || (onnxruntime = {}));
    ((onnxruntime2) => {
      let experimental;
      ((experimental2) => {
        let fbs;
        ((fbs2) => {
          class ValueInfo {
            constructor() {
              this.bb = null;
              this.bb_pos = 0;
            }
            /**
             * @param number i
             * @param flatbuffers.ByteBuffer bb
             * @returns ValueInfo
             */
            __init(i, bb) {
              this.bb_pos = i;
              this.bb = bb;
              return this;
            }
            /**
             * @param flatbuffers.ByteBuffer bb
             * @param ValueInfo= obj
             * @returns ValueInfo
             */
            static getRootAsValueInfo(bb, obj) {
              return (obj || new ValueInfo()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
            }
            /**
             * @param flatbuffers.ByteBuffer bb
             * @param ValueInfo= obj
             * @returns ValueInfo
             */
            static getSizePrefixedRootAsValueInfo(bb, obj) {
              bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
              return (obj || new ValueInfo()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
            }
            name(optionalEncoding) {
              let offset = this.bb.__offset(this.bb_pos, 4);
              return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
            }
            docString(optionalEncoding) {
              let offset = this.bb.__offset(this.bb_pos, 6);
              return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
            }
            /**
             * @param onnxruntime.experimental.fbs.TypeInfo= obj
             * @returns onnxruntime.experimental.fbs.TypeInfo|null
             */
            type(obj) {
              let offset = this.bb.__offset(this.bb_pos, 8);
              return offset ? (obj || new onnxruntime2.experimental.fbs.TypeInfo()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
            }
            /**
             * @param flatbuffers.Builder builder
             */
            static startValueInfo(builder) {
              builder.startObject(3);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset nameOffset
             */
            static addName(builder, nameOffset) {
              builder.addFieldOffset(0, nameOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset docStringOffset
             */
            static addDocString(builder, docStringOffset) {
              builder.addFieldOffset(1, docStringOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset typeOffset
             */
            static addType(builder, typeOffset) {
              builder.addFieldOffset(2, typeOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @returns flatbuffers.Offset
             */
            static endValueInfo(builder) {
              let offset = builder.endObject();
              return offset;
            }
            static createValueInfo(builder, nameOffset, docStringOffset, typeOffset) {
              ValueInfo.startValueInfo(builder);
              ValueInfo.addName(builder, nameOffset);
              ValueInfo.addDocString(builder, docStringOffset);
              ValueInfo.addType(builder, typeOffset);
              return ValueInfo.endValueInfo(builder);
            }
          }
          fbs2.ValueInfo = ValueInfo;
        })(fbs = experimental2.fbs || (experimental2.fbs = {}));
      })(experimental = onnxruntime2.experimental || (onnxruntime2.experimental = {}));
    })(onnxruntime || (onnxruntime = {}));
    ((onnxruntime2) => {
      let experimental;
      ((experimental2) => {
        let fbs;
        ((fbs2) => {
          class TypeInfo {
            constructor() {
              this.bb = null;
              this.bb_pos = 0;
            }
            /**
             * @param number i
             * @param flatbuffers.ByteBuffer bb
             * @returns TypeInfo
             */
            __init(i, bb) {
              this.bb_pos = i;
              this.bb = bb;
              return this;
            }
            /**
             * @param flatbuffers.ByteBuffer bb
             * @param TypeInfo= obj
             * @returns TypeInfo
             */
            static getRootAsTypeInfo(bb, obj) {
              return (obj || new TypeInfo()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
            }
            /**
             * @param flatbuffers.ByteBuffer bb
             * @param TypeInfo= obj
             * @returns TypeInfo
             */
            static getSizePrefixedRootAsTypeInfo(bb, obj) {
              bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
              return (obj || new TypeInfo()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
            }
            denotation(optionalEncoding) {
              let offset = this.bb.__offset(this.bb_pos, 4);
              return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
            }
            /**
             * @returns onnxruntime.experimental.fbs.TypeInfoValue
             */
            valueType() {
              let offset = this.bb.__offset(this.bb_pos, 6);
              return offset ? (
                /**  */
                this.bb.readUint8(this.bb_pos + offset)
              ) : 0 /* NONE */;
            }
            /**
             * @param flatbuffers.Table obj
             * @returns ?flatbuffers.Table
             */
            value(obj) {
              let offset = this.bb.__offset(this.bb_pos, 8);
              return offset ? this.bb.__union(obj, this.bb_pos + offset) : null;
            }
            /**
             * @param flatbuffers.Builder builder
             */
            static startTypeInfo(builder) {
              builder.startObject(3);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset denotationOffset
             */
            static addDenotation(builder, denotationOffset) {
              builder.addFieldOffset(0, denotationOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param onnxruntime.experimental.fbs.TypeInfoValue valueType
             */
            static addValueType(builder, valueType) {
              builder.addFieldInt8(1, valueType, 0 /* NONE */);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset valueOffset
             */
            static addValue(builder, valueOffset) {
              builder.addFieldOffset(2, valueOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @returns flatbuffers.Offset
             */
            static endTypeInfo(builder) {
              let offset = builder.endObject();
              return offset;
            }
            static createTypeInfo(builder, denotationOffset, valueType, valueOffset) {
              TypeInfo.startTypeInfo(builder);
              TypeInfo.addDenotation(builder, denotationOffset);
              TypeInfo.addValueType(builder, valueType);
              TypeInfo.addValue(builder, valueOffset);
              return TypeInfo.endTypeInfo(builder);
            }
          }
          fbs2.TypeInfo = TypeInfo;
        })(fbs = experimental2.fbs || (experimental2.fbs = {}));
      })(experimental = onnxruntime2.experimental || (onnxruntime2.experimental = {}));
    })(onnxruntime || (onnxruntime = {}));
    ((onnxruntime2) => {
      let experimental;
      ((experimental2) => {
        let fbs;
        ((fbs2) => {
          class OperatorSetId {
            constructor() {
              this.bb = null;
              this.bb_pos = 0;
            }
            /**
             * @param number i
             * @param flatbuffers.ByteBuffer bb
             * @returns OperatorSetId
             */
            __init(i, bb) {
              this.bb_pos = i;
              this.bb = bb;
              return this;
            }
            /**
             * @param flatbuffers.ByteBuffer bb
             * @param OperatorSetId= obj
             * @returns OperatorSetId
             */
            static getRootAsOperatorSetId(bb, obj) {
              return (obj || new OperatorSetId()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
            }
            /**
             * @param flatbuffers.ByteBuffer bb
             * @param OperatorSetId= obj
             * @returns OperatorSetId
             */
            static getSizePrefixedRootAsOperatorSetId(bb, obj) {
              bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
              return (obj || new OperatorSetId()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
            }
            domain(optionalEncoding) {
              let offset = this.bb.__offset(this.bb_pos, 4);
              return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
            }
            /**
             * @returns flatbuffers.Long
             */
            version() {
              let offset = this.bb.__offset(this.bb_pos, 6);
              return offset ? this.bb.readInt64(this.bb_pos + offset) : this.bb.createLong(0, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             */
            static startOperatorSetId(builder) {
              builder.startObject(2);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset domainOffset
             */
            static addDomain(builder, domainOffset) {
              builder.addFieldOffset(0, domainOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Long version
             */
            static addVersion(builder, version3) {
              builder.addFieldInt64(1, version3, builder.createLong(0, 0));
            }
            /**
             * @param flatbuffers.Builder builder
             * @returns flatbuffers.Offset
             */
            static endOperatorSetId(builder) {
              let offset = builder.endObject();
              return offset;
            }
            static createOperatorSetId(builder, domainOffset, version3) {
              OperatorSetId.startOperatorSetId(builder);
              OperatorSetId.addDomain(builder, domainOffset);
              OperatorSetId.addVersion(builder, version3);
              return OperatorSetId.endOperatorSetId(builder);
            }
          }
          fbs2.OperatorSetId = OperatorSetId;
        })(fbs = experimental2.fbs || (experimental2.fbs = {}));
      })(experimental = onnxruntime2.experimental || (onnxruntime2.experimental = {}));
    })(onnxruntime || (onnxruntime = {}));
    ((onnxruntime2) => {
      let experimental;
      ((experimental2) => {
        let fbs;
        ((fbs2) => {
          class Tensor4 {
            constructor() {
              this.bb = null;
              this.bb_pos = 0;
            }
            /**
             * @param number i
             * @param flatbuffers.ByteBuffer bb
             * @returns Tensor
             */
            __init(i, bb) {
              this.bb_pos = i;
              this.bb = bb;
              return this;
            }
            /**
             * @param flatbuffers.ByteBuffer bb
             * @param Tensor= obj
             * @returns Tensor
             */
            static getRootAsTensor(bb, obj) {
              return (obj || new Tensor4()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
            }
            /**
             * @param flatbuffers.ByteBuffer bb
             * @param Tensor= obj
             * @returns Tensor
             */
            static getSizePrefixedRootAsTensor(bb, obj) {
              bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
              return (obj || new Tensor4()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
            }
            name(optionalEncoding) {
              let offset = this.bb.__offset(this.bb_pos, 4);
              return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
            }
            docString(optionalEncoding) {
              let offset = this.bb.__offset(this.bb_pos, 6);
              return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
            }
            /**
             * @param number index
             * @returns flatbuffers.Long
             */
            dims(index) {
              let offset = this.bb.__offset(this.bb_pos, 8);
              return offset ? this.bb.readInt64(this.bb.__vector(this.bb_pos + offset) + index * 8) : this.bb.createLong(0, 0);
            }
            /**
             * @returns number
             */
            dimsLength() {
              let offset = this.bb.__offset(this.bb_pos, 8);
              return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
            }
            /**
             * @returns onnxruntime.experimental.fbs.TensorDataType
             */
            dataType() {
              let offset = this.bb.__offset(this.bb_pos, 10);
              return offset ? (
                /**  */
                this.bb.readInt32(this.bb_pos + offset)
              ) : 0 /* UNDEFINED */;
            }
            /**
             * @param number index
             * @returns number
             */
            rawData(index) {
              let offset = this.bb.__offset(this.bb_pos, 12);
              return offset ? this.bb.readUint8(this.bb.__vector(this.bb_pos + offset) + index) : 0;
            }
            /**
             * @returns number
             */
            rawDataLength() {
              let offset = this.bb.__offset(this.bb_pos, 12);
              return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
            }
            /**
             * @returns Uint8Array
             */
            rawDataArray() {
              let offset = this.bb.__offset(this.bb_pos, 12);
              return offset ? new Uint8Array(
                this.bb.bytes().buffer,
                this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset),
                this.bb.__vector_len(this.bb_pos + offset)
              ) : null;
            }
            stringData(index, optionalEncoding) {
              let offset = this.bb.__offset(this.bb_pos, 14);
              return offset ? this.bb.__string(this.bb.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
            }
            /**
             * @returns number
             */
            stringDataLength() {
              let offset = this.bb.__offset(this.bb_pos, 14);
              return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
            }
            /**
             * @param flatbuffers.Builder builder
             */
            static startTensor(builder) {
              builder.startObject(6);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset nameOffset
             */
            static addName(builder, nameOffset) {
              builder.addFieldOffset(0, nameOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset docStringOffset
             */
            static addDocString(builder, docStringOffset) {
              builder.addFieldOffset(1, docStringOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset dimsOffset
             */
            static addDims(builder, dimsOffset) {
              builder.addFieldOffset(2, dimsOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param Array.<flatbuffers.Long> data
             * @returns flatbuffers.Offset
             */
            static createDimsVector(builder, data) {
              builder.startVector(8, data.length, 8);
              for (let i = data.length - 1; i >= 0; i--) {
                builder.addInt64(data[i]);
              }
              return builder.endVector();
            }
            /**
             * @param flatbuffers.Builder builder
             * @param number numElems
             */
            static startDimsVector(builder, numElems) {
              builder.startVector(8, numElems, 8);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param onnxruntime.experimental.fbs.TensorDataType dataType
             */
            static addDataType(builder, dataType) {
              builder.addFieldInt32(3, dataType, 0 /* UNDEFINED */);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset rawDataOffset
             */
            static addRawData(builder, rawDataOffset) {
              builder.addFieldOffset(4, rawDataOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param Array.<number> data
             * @returns flatbuffers.Offset
             */
            static createRawDataVector(builder, data) {
              builder.startVector(1, data.length, 1);
              for (let i = data.length - 1; i >= 0; i--) {
                builder.addInt8(data[i]);
              }
              return builder.endVector();
            }
            /**
             * @param flatbuffers.Builder builder
             * @param number numElems
             */
            static startRawDataVector(builder, numElems) {
              builder.startVector(1, numElems, 1);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset stringDataOffset
             */
            static addStringData(builder, stringDataOffset) {
              builder.addFieldOffset(5, stringDataOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param Array.<flatbuffers.Offset> data
             * @returns flatbuffers.Offset
             */
            static createStringDataVector(builder, data) {
              builder.startVector(4, data.length, 4);
              for (let i = data.length - 1; i >= 0; i--) {
                builder.addOffset(data[i]);
              }
              return builder.endVector();
            }
            /**
             * @param flatbuffers.Builder builder
             * @param number numElems
             */
            static startStringDataVector(builder, numElems) {
              builder.startVector(4, numElems, 4);
            }
            /**
             * @param flatbuffers.Builder builder
             * @returns flatbuffers.Offset
             */
            static endTensor(builder) {
              let offset = builder.endObject();
              return offset;
            }
            static createTensor(builder, nameOffset, docStringOffset, dimsOffset, dataType, rawDataOffset, stringDataOffset) {
              Tensor4.startTensor(builder);
              Tensor4.addName(builder, nameOffset);
              Tensor4.addDocString(builder, docStringOffset);
              Tensor4.addDims(builder, dimsOffset);
              Tensor4.addDataType(builder, dataType);
              Tensor4.addRawData(builder, rawDataOffset);
              Tensor4.addStringData(builder, stringDataOffset);
              return Tensor4.endTensor(builder);
            }
          }
          fbs2.Tensor = Tensor4;
        })(fbs = experimental2.fbs || (experimental2.fbs = {}));
      })(experimental = onnxruntime2.experimental || (onnxruntime2.experimental = {}));
    })(onnxruntime || (onnxruntime = {}));
    ((onnxruntime2) => {
      let experimental;
      ((experimental2) => {
        let fbs;
        ((fbs2) => {
          class SparseTensor {
            constructor() {
              this.bb = null;
              this.bb_pos = 0;
            }
            /**
             * @param number i
             * @param flatbuffers.ByteBuffer bb
             * @returns SparseTensor
             */
            __init(i, bb) {
              this.bb_pos = i;
              this.bb = bb;
              return this;
            }
            /**
             * @param flatbuffers.ByteBuffer bb
             * @param SparseTensor= obj
             * @returns SparseTensor
             */
            static getRootAsSparseTensor(bb, obj) {
              return (obj || new SparseTensor()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
            }
            /**
             * @param flatbuffers.ByteBuffer bb
             * @param SparseTensor= obj
             * @returns SparseTensor
             */
            static getSizePrefixedRootAsSparseTensor(bb, obj) {
              bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
              return (obj || new SparseTensor()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
            }
            /**
             * @param onnxruntime.experimental.fbs.Tensor= obj
             * @returns onnxruntime.experimental.fbs.Tensor|null
             */
            values(obj) {
              let offset = this.bb.__offset(this.bb_pos, 4);
              return offset ? (obj || new onnxruntime2.experimental.fbs.Tensor()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
            }
            /**
             * @param onnxruntime.experimental.fbs.Tensor= obj
             * @returns onnxruntime.experimental.fbs.Tensor|null
             */
            indices(obj) {
              let offset = this.bb.__offset(this.bb_pos, 6);
              return offset ? (obj || new onnxruntime2.experimental.fbs.Tensor()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
            }
            /**
             * @param number index
             * @returns flatbuffers.Long
             */
            dims(index) {
              let offset = this.bb.__offset(this.bb_pos, 8);
              return offset ? this.bb.readInt64(this.bb.__vector(this.bb_pos + offset) + index * 8) : this.bb.createLong(0, 0);
            }
            /**
             * @returns number
             */
            dimsLength() {
              let offset = this.bb.__offset(this.bb_pos, 8);
              return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
            }
            /**
             * @param flatbuffers.Builder builder
             */
            static startSparseTensor(builder) {
              builder.startObject(3);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset valuesOffset
             */
            static addValues(builder, valuesOffset) {
              builder.addFieldOffset(0, valuesOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset indicesOffset
             */
            static addIndices(builder, indicesOffset) {
              builder.addFieldOffset(1, indicesOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset dimsOffset
             */
            static addDims(builder, dimsOffset) {
              builder.addFieldOffset(2, dimsOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param Array.<flatbuffers.Long> data
             * @returns flatbuffers.Offset
             */
            static createDimsVector(builder, data) {
              builder.startVector(8, data.length, 8);
              for (let i = data.length - 1; i >= 0; i--) {
                builder.addInt64(data[i]);
              }
              return builder.endVector();
            }
            /**
             * @param flatbuffers.Builder builder
             * @param number numElems
             */
            static startDimsVector(builder, numElems) {
              builder.startVector(8, numElems, 8);
            }
            /**
             * @param flatbuffers.Builder builder
             * @returns flatbuffers.Offset
             */
            static endSparseTensor(builder) {
              let offset = builder.endObject();
              return offset;
            }
            static createSparseTensor(builder, valuesOffset, indicesOffset, dimsOffset) {
              SparseTensor.startSparseTensor(builder);
              SparseTensor.addValues(builder, valuesOffset);
              SparseTensor.addIndices(builder, indicesOffset);
              SparseTensor.addDims(builder, dimsOffset);
              return SparseTensor.endSparseTensor(builder);
            }
          }
          fbs2.SparseTensor = SparseTensor;
        })(fbs = experimental2.fbs || (experimental2.fbs = {}));
      })(experimental = onnxruntime2.experimental || (onnxruntime2.experimental = {}));
    })(onnxruntime || (onnxruntime = {}));
    ((onnxruntime2) => {
      let experimental;
      ((experimental2) => {
        let fbs;
        ((fbs2) => {
          class Attribute2 {
            constructor() {
              this.bb = null;
              this.bb_pos = 0;
            }
            /**
             * @param number i
             * @param flatbuffers.ByteBuffer bb
             * @returns Attribute
             */
            __init(i, bb) {
              this.bb_pos = i;
              this.bb = bb;
              return this;
            }
            /**
             * @param flatbuffers.ByteBuffer bb
             * @param Attribute= obj
             * @returns Attribute
             */
            static getRootAsAttribute(bb, obj) {
              return (obj || new Attribute2()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
            }
            /**
             * @param flatbuffers.ByteBuffer bb
             * @param Attribute= obj
             * @returns Attribute
             */
            static getSizePrefixedRootAsAttribute(bb, obj) {
              bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
              return (obj || new Attribute2()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
            }
            name(optionalEncoding) {
              let offset = this.bb.__offset(this.bb_pos, 4);
              return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
            }
            docString(optionalEncoding) {
              let offset = this.bb.__offset(this.bb_pos, 6);
              return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
            }
            /**
             * @returns onnxruntime.experimental.fbs.AttributeType
             */
            type() {
              let offset = this.bb.__offset(this.bb_pos, 8);
              return offset ? (
                /**  */
                this.bb.readInt32(this.bb_pos + offset)
              ) : 0 /* UNDEFINED */;
            }
            /**
             * @returns number
             */
            f() {
              let offset = this.bb.__offset(this.bb_pos, 10);
              return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0;
            }
            /**
             * @returns flatbuffers.Long
             */
            i() {
              let offset = this.bb.__offset(this.bb_pos, 12);
              return offset ? this.bb.readInt64(this.bb_pos + offset) : this.bb.createLong(0, 0);
            }
            s(optionalEncoding) {
              let offset = this.bb.__offset(this.bb_pos, 14);
              return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
            }
            /**
             * @param onnxruntime.experimental.fbs.Tensor= obj
             * @returns onnxruntime.experimental.fbs.Tensor|null
             */
            t(obj) {
              let offset = this.bb.__offset(this.bb_pos, 16);
              return offset ? (obj || new onnxruntime2.experimental.fbs.Tensor()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
            }
            /**
             * @param onnxruntime.experimental.fbs.Graph= obj
             * @returns onnxruntime.experimental.fbs.Graph|null
             */
            g(obj) {
              let offset = this.bb.__offset(this.bb_pos, 18);
              return offset ? (obj || new onnxruntime2.experimental.fbs.Graph()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
            }
            /**
             * @param number index
             * @returns number
             */
            floats(index) {
              let offset = this.bb.__offset(this.bb_pos, 20);
              return offset ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
            }
            /**
             * @returns number
             */
            floatsLength() {
              let offset = this.bb.__offset(this.bb_pos, 20);
              return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
            }
            /**
             * @returns Float32Array
             */
            floatsArray() {
              let offset = this.bb.__offset(this.bb_pos, 20);
              return offset ? new Float32Array(
                this.bb.bytes().buffer,
                this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset),
                this.bb.__vector_len(this.bb_pos + offset)
              ) : null;
            }
            /**
             * @param number index
             * @returns flatbuffers.Long
             */
            ints(index) {
              let offset = this.bb.__offset(this.bb_pos, 22);
              return offset ? this.bb.readInt64(this.bb.__vector(this.bb_pos + offset) + index * 8) : this.bb.createLong(0, 0);
            }
            /**
             * @returns number
             */
            intsLength() {
              let offset = this.bb.__offset(this.bb_pos, 22);
              return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
            }
            strings(index, optionalEncoding) {
              let offset = this.bb.__offset(this.bb_pos, 24);
              return offset ? this.bb.__string(this.bb.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
            }
            /**
             * @returns number
             */
            stringsLength() {
              let offset = this.bb.__offset(this.bb_pos, 24);
              return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
            }
            /**
             * @param number index
             * @param onnxruntime.experimental.fbs.Tensor= obj
             * @returns onnxruntime.experimental.fbs.Tensor
             */
            tensors(index, obj) {
              let offset = this.bb.__offset(this.bb_pos, 26);
              return offset ? (obj || new onnxruntime2.experimental.fbs.Tensor()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
            }
            /**
             * @returns number
             */
            tensorsLength() {
              let offset = this.bb.__offset(this.bb_pos, 26);
              return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
            }
            /**
             * @param number index
             * @param onnxruntime.experimental.fbs.Graph= obj
             * @returns onnxruntime.experimental.fbs.Graph
             */
            graphs(index, obj) {
              let offset = this.bb.__offset(this.bb_pos, 28);
              return offset ? (obj || new onnxruntime2.experimental.fbs.Graph()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
            }
            /**
             * @returns number
             */
            graphsLength() {
              let offset = this.bb.__offset(this.bb_pos, 28);
              return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
            }
            /**
             * @param flatbuffers.Builder builder
             */
            static startAttribute(builder) {
              builder.startObject(13);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset nameOffset
             */
            static addName(builder, nameOffset) {
              builder.addFieldOffset(0, nameOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset docStringOffset
             */
            static addDocString(builder, docStringOffset) {
              builder.addFieldOffset(1, docStringOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param onnxruntime.experimental.fbs.AttributeType type
             */
            static addType(builder, type) {
              builder.addFieldInt32(2, type, 0 /* UNDEFINED */);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param number f
             */
            static addF(builder, f) {
              builder.addFieldFloat32(3, f, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Long i
             */
            static addI(builder, i) {
              builder.addFieldInt64(4, i, builder.createLong(0, 0));
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset sOffset
             */
            static addS(builder, sOffset) {
              builder.addFieldOffset(5, sOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset tOffset
             */
            static addT(builder, tOffset) {
              builder.addFieldOffset(6, tOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset gOffset
             */
            static addG(builder, gOffset) {
              builder.addFieldOffset(7, gOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset floatsOffset
             */
            static addFloats(builder, floatsOffset) {
              builder.addFieldOffset(8, floatsOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param Array.<number> data
             * @returns flatbuffers.Offset
             */
            static createFloatsVector(builder, data) {
              builder.startVector(4, data.length, 4);
              for (let i = data.length - 1; i >= 0; i--) {
                builder.addFloat32(data[i]);
              }
              return builder.endVector();
            }
            /**
             * @param flatbuffers.Builder builder
             * @param number numElems
             */
            static startFloatsVector(builder, numElems) {
              builder.startVector(4, numElems, 4);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset intsOffset
             */
            static addInts(builder, intsOffset) {
              builder.addFieldOffset(9, intsOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param Array.<flatbuffers.Long> data
             * @returns flatbuffers.Offset
             */
            static createIntsVector(builder, data) {
              builder.startVector(8, data.length, 8);
              for (let i = data.length - 1; i >= 0; i--) {
                builder.addInt64(data[i]);
              }
              return builder.endVector();
            }
            /**
             * @param flatbuffers.Builder builder
             * @param number numElems
             */
            static startIntsVector(builder, numElems) {
              builder.startVector(8, numElems, 8);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset stringsOffset
             */
            static addStrings(builder, stringsOffset) {
              builder.addFieldOffset(10, stringsOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param Array.<flatbuffers.Offset> data
             * @returns flatbuffers.Offset
             */
            static createStringsVector(builder, data) {
              builder.startVector(4, data.length, 4);
              for (let i = data.length - 1; i >= 0; i--) {
                builder.addOffset(data[i]);
              }
              return builder.endVector();
            }
            /**
             * @param flatbuffers.Builder builder
             * @param number numElems
             */
            static startStringsVector(builder, numElems) {
              builder.startVector(4, numElems, 4);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset tensorsOffset
             */
            static addTensors(builder, tensorsOffset) {
              builder.addFieldOffset(11, tensorsOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param Array.<flatbuffers.Offset> data
             * @returns flatbuffers.Offset
             */
            static createTensorsVector(builder, data) {
              builder.startVector(4, data.length, 4);
              for (let i = data.length - 1; i >= 0; i--) {
                builder.addOffset(data[i]);
              }
              return builder.endVector();
            }
            /**
             * @param flatbuffers.Builder builder
             * @param number numElems
             */
            static startTensorsVector(builder, numElems) {
              builder.startVector(4, numElems, 4);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset graphsOffset
             */
            static addGraphs(builder, graphsOffset) {
              builder.addFieldOffset(12, graphsOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param Array.<flatbuffers.Offset> data
             * @returns flatbuffers.Offset
             */
            static createGraphsVector(builder, data) {
              builder.startVector(4, data.length, 4);
              for (let i = data.length - 1; i >= 0; i--) {
                builder.addOffset(data[i]);
              }
              return builder.endVector();
            }
            /**
             * @param flatbuffers.Builder builder
             * @param number numElems
             */
            static startGraphsVector(builder, numElems) {
              builder.startVector(4, numElems, 4);
            }
            /**
             * @param flatbuffers.Builder builder
             * @returns flatbuffers.Offset
             */
            static endAttribute(builder) {
              let offset = builder.endObject();
              return offset;
            }
            static createAttribute(builder, nameOffset, docStringOffset, type, f, i, sOffset, tOffset, gOffset, floatsOffset, intsOffset, stringsOffset, tensorsOffset, graphsOffset) {
              Attribute2.startAttribute(builder);
              Attribute2.addName(builder, nameOffset);
              Attribute2.addDocString(builder, docStringOffset);
              Attribute2.addType(builder, type);
              Attribute2.addF(builder, f);
              Attribute2.addI(builder, i);
              Attribute2.addS(builder, sOffset);
              Attribute2.addT(builder, tOffset);
              Attribute2.addG(builder, gOffset);
              Attribute2.addFloats(builder, floatsOffset);
              Attribute2.addInts(builder, intsOffset);
              Attribute2.addStrings(builder, stringsOffset);
              Attribute2.addTensors(builder, tensorsOffset);
              Attribute2.addGraphs(builder, graphsOffset);
              return Attribute2.endAttribute(builder);
            }
          }
          fbs2.Attribute = Attribute2;
        })(fbs = experimental2.fbs || (experimental2.fbs = {}));
      })(experimental = onnxruntime2.experimental || (onnxruntime2.experimental = {}));
    })(onnxruntime || (onnxruntime = {}));
    ((onnxruntime2) => {
      let experimental;
      ((experimental2) => {
        let fbs;
        ((fbs2) => {
          class Graph2 {
            constructor() {
              this.bb = null;
              this.bb_pos = 0;
            }
            /**
             * @param number i
             * @param flatbuffers.ByteBuffer bb
             * @returns Graph
             */
            __init(i, bb) {
              this.bb_pos = i;
              this.bb = bb;
              return this;
            }
            /**
             * @param flatbuffers.ByteBuffer bb
             * @param Graph= obj
             * @returns Graph
             */
            static getRootAsGraph(bb, obj) {
              return (obj || new Graph2()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
            }
            /**
             * @param flatbuffers.ByteBuffer bb
             * @param Graph= obj
             * @returns Graph
             */
            static getSizePrefixedRootAsGraph(bb, obj) {
              bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
              return (obj || new Graph2()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
            }
            /**
             * @param number index
             * @param onnxruntime.experimental.fbs.Tensor= obj
             * @returns onnxruntime.experimental.fbs.Tensor
             */
            initializers(index, obj) {
              let offset = this.bb.__offset(this.bb_pos, 4);
              return offset ? (obj || new onnxruntime2.experimental.fbs.Tensor()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
            }
            /**
             * @returns number
             */
            initializersLength() {
              let offset = this.bb.__offset(this.bb_pos, 4);
              return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
            }
            /**
             * @param number index
             * @param onnxruntime.experimental.fbs.ValueInfo= obj
             * @returns onnxruntime.experimental.fbs.ValueInfo
             */
            nodeArgs(index, obj) {
              let offset = this.bb.__offset(this.bb_pos, 6);
              return offset ? (obj || new onnxruntime2.experimental.fbs.ValueInfo()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
            }
            /**
             * @returns number
             */
            nodeArgsLength() {
              let offset = this.bb.__offset(this.bb_pos, 6);
              return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
            }
            /**
             * @param number index
             * @param onnxruntime.experimental.fbs.Node= obj
             * @returns onnxruntime.experimental.fbs.Node
             */
            nodes(index, obj) {
              let offset = this.bb.__offset(this.bb_pos, 8);
              return offset ? (obj || new onnxruntime2.experimental.fbs.Node()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
            }
            /**
             * @returns number
             */
            nodesLength() {
              let offset = this.bb.__offset(this.bb_pos, 8);
              return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
            }
            /**
             * @returns number
             */
            maxNodeIndex() {
              let offset = this.bb.__offset(this.bb_pos, 10);
              return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
            }
            /**
             * @param number index
             * @param onnxruntime.experimental.fbs.NodeEdge= obj
             * @returns onnxruntime.experimental.fbs.NodeEdge
             */
            nodeEdges(index, obj) {
              let offset = this.bb.__offset(this.bb_pos, 12);
              return offset ? (obj || new onnxruntime2.experimental.fbs.NodeEdge()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
            }
            /**
             * @returns number
             */
            nodeEdgesLength() {
              let offset = this.bb.__offset(this.bb_pos, 12);
              return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
            }
            inputs(index, optionalEncoding) {
              let offset = this.bb.__offset(this.bb_pos, 14);
              return offset ? this.bb.__string(this.bb.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
            }
            /**
             * @returns number
             */
            inputsLength() {
              let offset = this.bb.__offset(this.bb_pos, 14);
              return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
            }
            outputs(index, optionalEncoding) {
              let offset = this.bb.__offset(this.bb_pos, 16);
              return offset ? this.bb.__string(this.bb.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
            }
            /**
             * @returns number
             */
            outputsLength() {
              let offset = this.bb.__offset(this.bb_pos, 16);
              return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
            }
            /**
             * @param number index
             * @param onnxruntime.experimental.fbs.SparseTensor= obj
             * @returns onnxruntime.experimental.fbs.SparseTensor
             */
            sparseInitializers(index, obj) {
              let offset = this.bb.__offset(this.bb_pos, 18);
              return offset ? (obj || new onnxruntime2.experimental.fbs.SparseTensor()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
            }
            /**
             * @returns number
             */
            sparseInitializersLength() {
              let offset = this.bb.__offset(this.bb_pos, 18);
              return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
            }
            /**
             * @param flatbuffers.Builder builder
             */
            static startGraph(builder) {
              builder.startObject(8);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset initializersOffset
             */
            static addInitializers(builder, initializersOffset) {
              builder.addFieldOffset(0, initializersOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param Array.<flatbuffers.Offset> data
             * @returns flatbuffers.Offset
             */
            static createInitializersVector(builder, data) {
              builder.startVector(4, data.length, 4);
              for (let i = data.length - 1; i >= 0; i--) {
                builder.addOffset(data[i]);
              }
              return builder.endVector();
            }
            /**
             * @param flatbuffers.Builder builder
             * @param number numElems
             */
            static startInitializersVector(builder, numElems) {
              builder.startVector(4, numElems, 4);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset nodeArgsOffset
             */
            static addNodeArgs(builder, nodeArgsOffset) {
              builder.addFieldOffset(1, nodeArgsOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param Array.<flatbuffers.Offset> data
             * @returns flatbuffers.Offset
             */
            static createNodeArgsVector(builder, data) {
              builder.startVector(4, data.length, 4);
              for (let i = data.length - 1; i >= 0; i--) {
                builder.addOffset(data[i]);
              }
              return builder.endVector();
            }
            /**
             * @param flatbuffers.Builder builder
             * @param number numElems
             */
            static startNodeArgsVector(builder, numElems) {
              builder.startVector(4, numElems, 4);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset nodesOffset
             */
            static addNodes(builder, nodesOffset) {
              builder.addFieldOffset(2, nodesOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param Array.<flatbuffers.Offset> data
             * @returns flatbuffers.Offset
             */
            static createNodesVector(builder, data) {
              builder.startVector(4, data.length, 4);
              for (let i = data.length - 1; i >= 0; i--) {
                builder.addOffset(data[i]);
              }
              return builder.endVector();
            }
            /**
             * @param flatbuffers.Builder builder
             * @param number numElems
             */
            static startNodesVector(builder, numElems) {
              builder.startVector(4, numElems, 4);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param number maxNodeIndex
             */
            static addMaxNodeIndex(builder, maxNodeIndex) {
              builder.addFieldInt32(3, maxNodeIndex, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset nodeEdgesOffset
             */
            static addNodeEdges(builder, nodeEdgesOffset) {
              builder.addFieldOffset(4, nodeEdgesOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param Array.<flatbuffers.Offset> data
             * @returns flatbuffers.Offset
             */
            static createNodeEdgesVector(builder, data) {
              builder.startVector(4, data.length, 4);
              for (let i = data.length - 1; i >= 0; i--) {
                builder.addOffset(data[i]);
              }
              return builder.endVector();
            }
            /**
             * @param flatbuffers.Builder builder
             * @param number numElems
             */
            static startNodeEdgesVector(builder, numElems) {
              builder.startVector(4, numElems, 4);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset inputsOffset
             */
            static addInputs(builder, inputsOffset) {
              builder.addFieldOffset(5, inputsOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param Array.<flatbuffers.Offset> data
             * @returns flatbuffers.Offset
             */
            static createInputsVector(builder, data) {
              builder.startVector(4, data.length, 4);
              for (let i = data.length - 1; i >= 0; i--) {
                builder.addOffset(data[i]);
              }
              return builder.endVector();
            }
            /**
             * @param flatbuffers.Builder builder
             * @param number numElems
             */
            static startInputsVector(builder, numElems) {
              builder.startVector(4, numElems, 4);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset outputsOffset
             */
            static addOutputs(builder, outputsOffset) {
              builder.addFieldOffset(6, outputsOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param Array.<flatbuffers.Offset> data
             * @returns flatbuffers.Offset
             */
            static createOutputsVector(builder, data) {
              builder.startVector(4, data.length, 4);
              for (let i = data.length - 1; i >= 0; i--) {
                builder.addOffset(data[i]);
              }
              return builder.endVector();
            }
            /**
             * @param flatbuffers.Builder builder
             * @param number numElems
             */
            static startOutputsVector(builder, numElems) {
              builder.startVector(4, numElems, 4);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset sparseInitializersOffset
             */
            static addSparseInitializers(builder, sparseInitializersOffset) {
              builder.addFieldOffset(7, sparseInitializersOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param Array.<flatbuffers.Offset> data
             * @returns flatbuffers.Offset
             */
            static createSparseInitializersVector(builder, data) {
              builder.startVector(4, data.length, 4);
              for (let i = data.length - 1; i >= 0; i--) {
                builder.addOffset(data[i]);
              }
              return builder.endVector();
            }
            /**
             * @param flatbuffers.Builder builder
             * @param number numElems
             */
            static startSparseInitializersVector(builder, numElems) {
              builder.startVector(4, numElems, 4);
            }
            /**
             * @param flatbuffers.Builder builder
             * @returns flatbuffers.Offset
             */
            static endGraph(builder) {
              let offset = builder.endObject();
              return offset;
            }
            static createGraph(builder, initializersOffset, nodeArgsOffset, nodesOffset, maxNodeIndex, nodeEdgesOffset, inputsOffset, outputsOffset, sparseInitializersOffset) {
              Graph2.startGraph(builder);
              Graph2.addInitializers(builder, initializersOffset);
              Graph2.addNodeArgs(builder, nodeArgsOffset);
              Graph2.addNodes(builder, nodesOffset);
              Graph2.addMaxNodeIndex(builder, maxNodeIndex);
              Graph2.addNodeEdges(builder, nodeEdgesOffset);
              Graph2.addInputs(builder, inputsOffset);
              Graph2.addOutputs(builder, outputsOffset);
              Graph2.addSparseInitializers(builder, sparseInitializersOffset);
              return Graph2.endGraph(builder);
            }
          }
          fbs2.Graph = Graph2;
        })(fbs = experimental2.fbs || (experimental2.fbs = {}));
      })(experimental = onnxruntime2.experimental || (onnxruntime2.experimental = {}));
    })(onnxruntime || (onnxruntime = {}));
    ((onnxruntime2) => {
      let experimental;
      ((experimental2) => {
        let fbs;
        ((fbs2) => {
          class Model2 {
            constructor() {
              this.bb = null;
              this.bb_pos = 0;
            }
            /**
             * @param number i
             * @param flatbuffers.ByteBuffer bb
             * @returns Model
             */
            __init(i, bb) {
              this.bb_pos = i;
              this.bb = bb;
              return this;
            }
            /**
             * @param flatbuffers.ByteBuffer bb
             * @param Model= obj
             * @returns Model
             */
            static getRootAsModel(bb, obj) {
              return (obj || new Model2()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
            }
            /**
             * @param flatbuffers.ByteBuffer bb
             * @param Model= obj
             * @returns Model
             */
            static getSizePrefixedRootAsModel(bb, obj) {
              bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
              return (obj || new Model2()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
            }
            /**
             * @returns flatbuffers.Long
             */
            irVersion() {
              let offset = this.bb.__offset(this.bb_pos, 4);
              return offset ? this.bb.readInt64(this.bb_pos + offset) : this.bb.createLong(0, 0);
            }
            /**
             * @param number index
             * @param onnxruntime.experimental.fbs.OperatorSetId= obj
             * @returns onnxruntime.experimental.fbs.OperatorSetId
             */
            opsetImport(index, obj) {
              let offset = this.bb.__offset(this.bb_pos, 6);
              return offset ? (obj || new onnxruntime2.experimental.fbs.OperatorSetId()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
            }
            /**
             * @returns number
             */
            opsetImportLength() {
              let offset = this.bb.__offset(this.bb_pos, 6);
              return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
            }
            producerName(optionalEncoding) {
              let offset = this.bb.__offset(this.bb_pos, 8);
              return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
            }
            producerVersion(optionalEncoding) {
              let offset = this.bb.__offset(this.bb_pos, 10);
              return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
            }
            domain(optionalEncoding) {
              let offset = this.bb.__offset(this.bb_pos, 12);
              return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
            }
            /**
             * @returns flatbuffers.Long
             */
            modelVersion() {
              let offset = this.bb.__offset(this.bb_pos, 14);
              return offset ? this.bb.readInt64(this.bb_pos + offset) : this.bb.createLong(0, 0);
            }
            docString(optionalEncoding) {
              let offset = this.bb.__offset(this.bb_pos, 16);
              return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
            }
            /**
             * @param onnxruntime.experimental.fbs.Graph= obj
             * @returns onnxruntime.experimental.fbs.Graph|null
             */
            graph(obj) {
              let offset = this.bb.__offset(this.bb_pos, 18);
              return offset ? (obj || new onnxruntime2.experimental.fbs.Graph()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
            }
            graphDocString(optionalEncoding) {
              let offset = this.bb.__offset(this.bb_pos, 20);
              return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
            }
            /**
             * @param flatbuffers.Builder builder
             */
            static startModel(builder) {
              builder.startObject(9);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Long irVersion
             */
            static addIrVersion(builder, irVersion) {
              builder.addFieldInt64(0, irVersion, builder.createLong(0, 0));
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset opsetImportOffset
             */
            static addOpsetImport(builder, opsetImportOffset) {
              builder.addFieldOffset(1, opsetImportOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param Array.<flatbuffers.Offset> data
             * @returns flatbuffers.Offset
             */
            static createOpsetImportVector(builder, data) {
              builder.startVector(4, data.length, 4);
              for (let i = data.length - 1; i >= 0; i--) {
                builder.addOffset(data[i]);
              }
              return builder.endVector();
            }
            /**
             * @param flatbuffers.Builder builder
             * @param number numElems
             */
            static startOpsetImportVector(builder, numElems) {
              builder.startVector(4, numElems, 4);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset producerNameOffset
             */
            static addProducerName(builder, producerNameOffset) {
              builder.addFieldOffset(2, producerNameOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset producerVersionOffset
             */
            static addProducerVersion(builder, producerVersionOffset) {
              builder.addFieldOffset(3, producerVersionOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset domainOffset
             */
            static addDomain(builder, domainOffset) {
              builder.addFieldOffset(4, domainOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Long modelVersion
             */
            static addModelVersion(builder, modelVersion) {
              builder.addFieldInt64(5, modelVersion, builder.createLong(0, 0));
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset docStringOffset
             */
            static addDocString(builder, docStringOffset) {
              builder.addFieldOffset(6, docStringOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset graphOffset
             */
            static addGraph(builder, graphOffset) {
              builder.addFieldOffset(7, graphOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset graphDocStringOffset
             */
            static addGraphDocString(builder, graphDocStringOffset) {
              builder.addFieldOffset(8, graphDocStringOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @returns flatbuffers.Offset
             */
            static endModel(builder) {
              let offset = builder.endObject();
              return offset;
            }
            static createModel(builder, irVersion, opsetImportOffset, producerNameOffset, producerVersionOffset, domainOffset, modelVersion, docStringOffset, graphOffset, graphDocStringOffset) {
              Model2.startModel(builder);
              Model2.addIrVersion(builder, irVersion);
              Model2.addOpsetImport(builder, opsetImportOffset);
              Model2.addProducerName(builder, producerNameOffset);
              Model2.addProducerVersion(builder, producerVersionOffset);
              Model2.addDomain(builder, domainOffset);
              Model2.addModelVersion(builder, modelVersion);
              Model2.addDocString(builder, docStringOffset);
              Model2.addGraph(builder, graphOffset);
              Model2.addGraphDocString(builder, graphDocStringOffset);
              return Model2.endModel(builder);
            }
          }
          fbs2.Model = Model2;
        })(fbs = experimental2.fbs || (experimental2.fbs = {}));
      })(experimental = onnxruntime2.experimental || (onnxruntime2.experimental = {}));
    })(onnxruntime || (onnxruntime = {}));
    ((onnxruntime2) => {
      let experimental;
      ((experimental2) => {
        let fbs;
        ((fbs2) => {
          class KernelCreateInfos {
            constructor() {
              this.bb = null;
              this.bb_pos = 0;
            }
            /**
             * @param number i
             * @param flatbuffers.ByteBuffer bb
             * @returns KernelCreateInfos
             */
            __init(i, bb) {
              this.bb_pos = i;
              this.bb = bb;
              return this;
            }
            /**
             * @param flatbuffers.ByteBuffer bb
             * @param KernelCreateInfos= obj
             * @returns KernelCreateInfos
             */
            static getRootAsKernelCreateInfos(bb, obj) {
              return (obj || new KernelCreateInfos()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
            }
            /**
             * @param flatbuffers.ByteBuffer bb
             * @param KernelCreateInfos= obj
             * @returns KernelCreateInfos
             */
            static getSizePrefixedRootAsKernelCreateInfos(bb, obj) {
              bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
              return (obj || new KernelCreateInfos()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
            }
            /**
             * @param number index
             * @returns number
             */
            nodeIndices(index) {
              let offset = this.bb.__offset(this.bb_pos, 4);
              return offset ? this.bb.readUint32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
            }
            /**
             * @returns number
             */
            nodeIndicesLength() {
              let offset = this.bb.__offset(this.bb_pos, 4);
              return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
            }
            /**
             * @returns Uint32Array
             */
            nodeIndicesArray() {
              let offset = this.bb.__offset(this.bb_pos, 4);
              return offset ? new Uint32Array(
                this.bb.bytes().buffer,
                this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset),
                this.bb.__vector_len(this.bb_pos + offset)
              ) : null;
            }
            /**
             * @param number index
             * @returns flatbuffers.Long
             */
            kernelDefHashes(index) {
              let offset = this.bb.__offset(this.bb_pos, 6);
              return offset ? this.bb.readUint64(this.bb.__vector(this.bb_pos + offset) + index * 8) : this.bb.createLong(0, 0);
            }
            /**
             * @returns number
             */
            kernelDefHashesLength() {
              let offset = this.bb.__offset(this.bb_pos, 6);
              return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
            }
            /**
             * @param flatbuffers.Builder builder
             */
            static startKernelCreateInfos(builder) {
              builder.startObject(2);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset nodeIndicesOffset
             */
            static addNodeIndices(builder, nodeIndicesOffset) {
              builder.addFieldOffset(0, nodeIndicesOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param Array.<number> data
             * @returns flatbuffers.Offset
             */
            static createNodeIndicesVector(builder, data) {
              builder.startVector(4, data.length, 4);
              for (let i = data.length - 1; i >= 0; i--) {
                builder.addInt32(data[i]);
              }
              return builder.endVector();
            }
            /**
             * @param flatbuffers.Builder builder
             * @param number numElems
             */
            static startNodeIndicesVector(builder, numElems) {
              builder.startVector(4, numElems, 4);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset kernelDefHashesOffset
             */
            static addKernelDefHashes(builder, kernelDefHashesOffset) {
              builder.addFieldOffset(1, kernelDefHashesOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param Array.<flatbuffers.Long> data
             * @returns flatbuffers.Offset
             */
            static createKernelDefHashesVector(builder, data) {
              builder.startVector(8, data.length, 8);
              for (let i = data.length - 1; i >= 0; i--) {
                builder.addInt64(data[i]);
              }
              return builder.endVector();
            }
            /**
             * @param flatbuffers.Builder builder
             * @param number numElems
             */
            static startKernelDefHashesVector(builder, numElems) {
              builder.startVector(8, numElems, 8);
            }
            /**
             * @param flatbuffers.Builder builder
             * @returns flatbuffers.Offset
             */
            static endKernelCreateInfos(builder) {
              let offset = builder.endObject();
              return offset;
            }
            static createKernelCreateInfos(builder, nodeIndicesOffset, kernelDefHashesOffset) {
              KernelCreateInfos.startKernelCreateInfos(builder);
              KernelCreateInfos.addNodeIndices(builder, nodeIndicesOffset);
              KernelCreateInfos.addKernelDefHashes(builder, kernelDefHashesOffset);
              return KernelCreateInfos.endKernelCreateInfos(builder);
            }
          }
          fbs2.KernelCreateInfos = KernelCreateInfos;
        })(fbs = experimental2.fbs || (experimental2.fbs = {}));
      })(experimental = onnxruntime2.experimental || (onnxruntime2.experimental = {}));
    })(onnxruntime || (onnxruntime = {}));
    ((onnxruntime2) => {
      let experimental;
      ((experimental2) => {
        let fbs;
        ((fbs2) => {
          class SubGraphSessionState {
            constructor() {
              this.bb = null;
              this.bb_pos = 0;
            }
            /**
             * @param number i
             * @param flatbuffers.ByteBuffer bb
             * @returns SubGraphSessionState
             */
            __init(i, bb) {
              this.bb_pos = i;
              this.bb = bb;
              return this;
            }
            /**
             * @param flatbuffers.ByteBuffer bb
             * @param SubGraphSessionState= obj
             * @returns SubGraphSessionState
             */
            static getRootAsSubGraphSessionState(bb, obj) {
              return (obj || new SubGraphSessionState()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
            }
            /**
             * @param flatbuffers.ByteBuffer bb
             * @param SubGraphSessionState= obj
             * @returns SubGraphSessionState
             */
            static getSizePrefixedRootAsSubGraphSessionState(bb, obj) {
              bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
              return (obj || new SubGraphSessionState()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
            }
            graphId(optionalEncoding) {
              let offset = this.bb.__offset(this.bb_pos, 4);
              return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
            }
            /**
             * @param onnxruntime.experimental.fbs.SessionState= obj
             * @returns onnxruntime.experimental.fbs.SessionState|null
             */
            sessionState(obj) {
              let offset = this.bb.__offset(this.bb_pos, 6);
              return offset ? (obj || new onnxruntime2.experimental.fbs.SessionState()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
            }
            /**
             * @param flatbuffers.Builder builder
             */
            static startSubGraphSessionState(builder) {
              builder.startObject(2);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset graphIdOffset
             */
            static addGraphId(builder, graphIdOffset) {
              builder.addFieldOffset(0, graphIdOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset sessionStateOffset
             */
            static addSessionState(builder, sessionStateOffset) {
              builder.addFieldOffset(1, sessionStateOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @returns flatbuffers.Offset
             */
            static endSubGraphSessionState(builder) {
              let offset = builder.endObject();
              builder.requiredField(offset, 4);
              return offset;
            }
            static createSubGraphSessionState(builder, graphIdOffset, sessionStateOffset) {
              SubGraphSessionState.startSubGraphSessionState(builder);
              SubGraphSessionState.addGraphId(builder, graphIdOffset);
              SubGraphSessionState.addSessionState(builder, sessionStateOffset);
              return SubGraphSessionState.endSubGraphSessionState(builder);
            }
          }
          fbs2.SubGraphSessionState = SubGraphSessionState;
        })(fbs = experimental2.fbs || (experimental2.fbs = {}));
      })(experimental = onnxruntime2.experimental || (onnxruntime2.experimental = {}));
    })(onnxruntime || (onnxruntime = {}));
    ((onnxruntime2) => {
      let experimental;
      ((experimental2) => {
        let fbs;
        ((fbs2) => {
          class SessionState {
            constructor() {
              this.bb = null;
              this.bb_pos = 0;
            }
            /**
             * @param number i
             * @param flatbuffers.ByteBuffer bb
             * @returns SessionState
             */
            __init(i, bb) {
              this.bb_pos = i;
              this.bb = bb;
              return this;
            }
            /**
             * @param flatbuffers.ByteBuffer bb
             * @param SessionState= obj
             * @returns SessionState
             */
            static getRootAsSessionState(bb, obj) {
              return (obj || new SessionState()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
            }
            /**
             * @param flatbuffers.ByteBuffer bb
             * @param SessionState= obj
             * @returns SessionState
             */
            static getSizePrefixedRootAsSessionState(bb, obj) {
              bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
              return (obj || new SessionState()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
            }
            /**
             * @param onnxruntime.experimental.fbs.KernelCreateInfos= obj
             * @returns onnxruntime.experimental.fbs.KernelCreateInfos|null
             */
            kernels(obj) {
              let offset = this.bb.__offset(this.bb_pos, 4);
              return offset ? (obj || new onnxruntime2.experimental.fbs.KernelCreateInfos()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
            }
            /**
             * @param number index
             * @param onnxruntime.experimental.fbs.SubGraphSessionState= obj
             * @returns onnxruntime.experimental.fbs.SubGraphSessionState
             */
            subGraphSessionStates(index, obj) {
              let offset = this.bb.__offset(this.bb_pos, 6);
              return offset ? (obj || new onnxruntime2.experimental.fbs.SubGraphSessionState()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
            }
            /**
             * @returns number
             */
            subGraphSessionStatesLength() {
              let offset = this.bb.__offset(this.bb_pos, 6);
              return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
            }
            /**
             * @param flatbuffers.Builder builder
             */
            static startSessionState(builder) {
              builder.startObject(2);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset kernelsOffset
             */
            static addKernels(builder, kernelsOffset) {
              builder.addFieldOffset(0, kernelsOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset subGraphSessionStatesOffset
             */
            static addSubGraphSessionStates(builder, subGraphSessionStatesOffset) {
              builder.addFieldOffset(1, subGraphSessionStatesOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param Array.<flatbuffers.Offset> data
             * @returns flatbuffers.Offset
             */
            static createSubGraphSessionStatesVector(builder, data) {
              builder.startVector(4, data.length, 4);
              for (let i = data.length - 1; i >= 0; i--) {
                builder.addOffset(data[i]);
              }
              return builder.endVector();
            }
            /**
             * @param flatbuffers.Builder builder
             * @param number numElems
             */
            static startSubGraphSessionStatesVector(builder, numElems) {
              builder.startVector(4, numElems, 4);
            }
            /**
             * @param flatbuffers.Builder builder
             * @returns flatbuffers.Offset
             */
            static endSessionState(builder) {
              let offset = builder.endObject();
              return offset;
            }
            static createSessionState(builder, kernelsOffset, subGraphSessionStatesOffset) {
              SessionState.startSessionState(builder);
              SessionState.addKernels(builder, kernelsOffset);
              SessionState.addSubGraphSessionStates(builder, subGraphSessionStatesOffset);
              return SessionState.endSessionState(builder);
            }
          }
          fbs2.SessionState = SessionState;
        })(fbs = experimental2.fbs || (experimental2.fbs = {}));
      })(experimental = onnxruntime2.experimental || (onnxruntime2.experimental = {}));
    })(onnxruntime || (onnxruntime = {}));
    ((onnxruntime2) => {
      let experimental;
      ((experimental2) => {
        let fbs;
        ((fbs2) => {
          class InferenceSession4 {
            constructor() {
              this.bb = null;
              this.bb_pos = 0;
            }
            /**
             * @param number i
             * @param flatbuffers.ByteBuffer bb
             * @returns InferenceSession
             */
            __init(i, bb) {
              this.bb_pos = i;
              this.bb = bb;
              return this;
            }
            /**
             * @param flatbuffers.ByteBuffer bb
             * @param InferenceSession= obj
             * @returns InferenceSession
             */
            static getRootAsInferenceSession(bb, obj) {
              return (obj || new InferenceSession4()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
            }
            /**
             * @param flatbuffers.ByteBuffer bb
             * @param InferenceSession= obj
             * @returns InferenceSession
             */
            static getSizePrefixedRootAsInferenceSession(bb, obj) {
              bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
              return (obj || new InferenceSession4()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
            }
            /**
             * @param flatbuffers.ByteBuffer bb
             * @returns boolean
             */
            static bufferHasIdentifier(bb) {
              return bb.__has_identifier("ORTM");
            }
            ortVersion(optionalEncoding) {
              let offset = this.bb.__offset(this.bb_pos, 4);
              return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
            }
            /**
             * @param onnxruntime.experimental.fbs.Model= obj
             * @returns onnxruntime.experimental.fbs.Model|null
             */
            model(obj) {
              let offset = this.bb.__offset(this.bb_pos, 6);
              return offset ? (obj || new onnxruntime2.experimental.fbs.Model()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
            }
            /**
             * @param onnxruntime.experimental.fbs.SessionState= obj
             * @returns onnxruntime.experimental.fbs.SessionState|null
             */
            sessionState(obj) {
              let offset = this.bb.__offset(this.bb_pos, 8);
              return offset ? (obj || new onnxruntime2.experimental.fbs.SessionState()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
            }
            /**
             * @param flatbuffers.Builder builder
             */
            static startInferenceSession(builder) {
              builder.startObject(3);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset ortVersionOffset
             */
            static addOrtVersion(builder, ortVersionOffset) {
              builder.addFieldOffset(0, ortVersionOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset modelOffset
             */
            static addModel(builder, modelOffset) {
              builder.addFieldOffset(1, modelOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset sessionStateOffset
             */
            static addSessionState(builder, sessionStateOffset) {
              builder.addFieldOffset(2, sessionStateOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @returns flatbuffers.Offset
             */
            static endInferenceSession(builder) {
              let offset = builder.endObject();
              return offset;
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset offset
             */
            static finishInferenceSessionBuffer(builder, offset) {
              builder.finish(offset, "ORTM");
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset offset
             */
            static finishSizePrefixedInferenceSessionBuffer(builder, offset) {
              builder.finish(offset, "ORTM", true);
            }
            static createInferenceSession(builder, ortVersionOffset, modelOffset, sessionStateOffset) {
              InferenceSession4.startInferenceSession(builder);
              InferenceSession4.addOrtVersion(builder, ortVersionOffset);
              InferenceSession4.addModel(builder, modelOffset);
              InferenceSession4.addSessionState(builder, sessionStateOffset);
              return InferenceSession4.endInferenceSession(builder);
            }
          }
          fbs2.InferenceSession = InferenceSession4;
        })(fbs = experimental2.fbs || (experimental2.fbs = {}));
      })(experimental = onnxruntime2.experimental || (onnxruntime2.experimental = {}));
    })(onnxruntime || (onnxruntime = {}));
  }
});

// web/node_modules/@protobufjs/aspromise/index.js
var require_aspromise = __commonJS({
  "web/node_modules/@protobufjs/aspromise/index.js"(exports2, module2) {
    "use strict";
    module2.exports = asPromise;
    function asPromise(fn, ctx) {
      var params = new Array(arguments.length - 1), offset = 0, index = 2, pending = true;
      while (index < arguments.length)
        params[offset++] = arguments[index++];
      return new Promise(function executor(resolve, reject) {
        params[offset] = function callback(err) {
          if (pending) {
            pending = false;
            if (err)
              reject(err);
            else {
              var params2 = new Array(arguments.length - 1), offset2 = 0;
              while (offset2 < params2.length)
                params2[offset2++] = arguments[offset2];
              resolve.apply(null, params2);
            }
          }
        };
        try {
          fn.apply(ctx || null, params);
        } catch (err) {
          if (pending) {
            pending = false;
            reject(err);
          }
        }
      });
    }
  }
});

// web/node_modules/@protobufjs/base64/index.js
var require_base64 = __commonJS({
  "web/node_modules/@protobufjs/base64/index.js"(exports2) {
    "use strict";
    var base64 = exports2;
    base64.length = function length(string) {
      var p = string.length;
      if (!p)
        return 0;
      var n = 0;
      while (--p % 4 > 1 && string.charAt(p) === "=")
        ++n;
      return Math.ceil(string.length * 3) / 4 - n;
    };
    var b64 = new Array(64);
    var s64 = new Array(123);
    for (i = 0; i < 64; )
      s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;
    var i;
    base64.encode = function encode(buffer, start, end) {
      var parts = null, chunk = [];
      var i2 = 0, j = 0, t;
      while (start < end) {
        var b = buffer[start++];
        switch (j) {
          case 0:
            chunk[i2++] = b64[b >> 2];
            t = (b & 3) << 4;
            j = 1;
            break;
          case 1:
            chunk[i2++] = b64[t | b >> 4];
            t = (b & 15) << 2;
            j = 2;
            break;
          case 2:
            chunk[i2++] = b64[t | b >> 6];
            chunk[i2++] = b64[b & 63];
            j = 0;
            break;
        }
        if (i2 > 8191) {
          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
          i2 = 0;
        }
      }
      if (j) {
        chunk[i2++] = b64[t];
        chunk[i2++] = 61;
        if (j === 1)
          chunk[i2++] = 61;
      }
      if (parts) {
        if (i2)
          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i2)));
        return parts.join("");
      }
      return String.fromCharCode.apply(String, chunk.slice(0, i2));
    };
    var invalidEncoding = "invalid encoding";
    base64.decode = function decode(string, buffer, offset) {
      var start = offset;
      var j = 0, t;
      for (var i2 = 0; i2 < string.length; ) {
        var c = string.charCodeAt(i2++);
        if (c === 61 && j > 1)
          break;
        if ((c = s64[c]) === void 0)
          throw Error(invalidEncoding);
        switch (j) {
          case 0:
            t = c;
            j = 1;
            break;
          case 1:
            buffer[offset++] = t << 2 | (c & 48) >> 4;
            t = c;
            j = 2;
            break;
          case 2:
            buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;
            t = c;
            j = 3;
            break;
          case 3:
            buffer[offset++] = (t & 3) << 6 | c;
            j = 0;
            break;
        }
      }
      if (j === 1)
        throw Error(invalidEncoding);
      return offset - start;
    };
    base64.test = function test(string) {
      return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);
    };
  }
});

// web/node_modules/@protobufjs/eventemitter/index.js
var require_eventemitter = __commonJS({
  "web/node_modules/@protobufjs/eventemitter/index.js"(exports2, module2) {
    "use strict";
    module2.exports = EventEmitter;
    function EventEmitter() {
      this._listeners = {};
    }
    EventEmitter.prototype.on = function on(evt, fn, ctx) {
      (this._listeners[evt] || (this._listeners[evt] = [])).push({
        fn,
        ctx: ctx || this
      });
      return this;
    };
    EventEmitter.prototype.off = function off(evt, fn) {
      if (evt === void 0)
        this._listeners = {};
      else {
        if (fn === void 0)
          this._listeners[evt] = [];
        else {
          var listeners = this._listeners[evt];
          for (var i = 0; i < listeners.length; )
            if (listeners[i].fn === fn)
              listeners.splice(i, 1);
            else
              ++i;
        }
      }
      return this;
    };
    EventEmitter.prototype.emit = function emit(evt) {
      var listeners = this._listeners[evt];
      if (listeners) {
        var args = [], i = 1;
        for (; i < arguments.length; )
          args.push(arguments[i++]);
        for (i = 0; i < listeners.length; )
          listeners[i].fn.apply(listeners[i++].ctx, args);
      }
      return this;
    };
  }
});

// web/node_modules/@protobufjs/float/index.js
var require_float = __commonJS({
  "web/node_modules/@protobufjs/float/index.js"(exports2, module2) {
    "use strict";
    module2.exports = factory(factory);
    function factory(exports3) {
      if (typeof Float32Array !== "undefined")
        (function() {
          var f32 = new Float32Array([-0]), f8b = new Uint8Array(f32.buffer), le = f8b[3] === 128;
          function writeFloat_f32_cpy(val, buf, pos) {
            f32[0] = val;
            buf[pos] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
          }
          function writeFloat_f32_rev(val, buf, pos) {
            f32[0] = val;
            buf[pos] = f8b[3];
            buf[pos + 1] = f8b[2];
            buf[pos + 2] = f8b[1];
            buf[pos + 3] = f8b[0];
          }
          exports3.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
          exports3.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;
          function readFloat_f32_cpy(buf, pos) {
            f8b[0] = buf[pos];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            return f32[0];
          }
          function readFloat_f32_rev(buf, pos) {
            f8b[3] = buf[pos];
            f8b[2] = buf[pos + 1];
            f8b[1] = buf[pos + 2];
            f8b[0] = buf[pos + 3];
            return f32[0];
          }
          exports3.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
          exports3.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;
        })();
      else
        (function() {
          function writeFloat_ieee754(writeUint, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
              val = -val;
            if (val === 0)
              writeUint(1 / val > 0 ? (
                /* positive */
                0
              ) : (
                /* negative 0 */
                2147483648
              ), buf, pos);
            else if (isNaN(val))
              writeUint(2143289344, buf, pos);
            else if (val > 34028234663852886e22)
              writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);
            else if (val < 11754943508222875e-54)
              writeUint((sign << 31 | Math.round(val / 1401298464324817e-60)) >>> 0, buf, pos);
            else {
              var exponent = Math.floor(Math.log(val) / Math.LN2), mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
              writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);
            }
          }
          exports3.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
          exports3.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);
          function readFloat_ieee754(readUint, buf, pos) {
            var uint = readUint(buf, pos), sign = (uint >> 31) * 2 + 1, exponent = uint >>> 23 & 255, mantissa = uint & 8388607;
            return exponent === 255 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 1401298464324817e-60 * mantissa : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);
          }
          exports3.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
          exports3.readFloatBE = readFloat_ieee754.bind(null, readUintBE);
        })();
      if (typeof Float64Array !== "undefined")
        (function() {
          var f64 = new Float64Array([-0]), f8b = new Uint8Array(f64.buffer), le = f8b[7] === 128;
          function writeDouble_f64_cpy(val, buf, pos) {
            f64[0] = val;
            buf[pos] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
            buf[pos + 4] = f8b[4];
            buf[pos + 5] = f8b[5];
            buf[pos + 6] = f8b[6];
            buf[pos + 7] = f8b[7];
          }
          function writeDouble_f64_rev(val, buf, pos) {
            f64[0] = val;
            buf[pos] = f8b[7];
            buf[pos + 1] = f8b[6];
            buf[pos + 2] = f8b[5];
            buf[pos + 3] = f8b[4];
            buf[pos + 4] = f8b[3];
            buf[pos + 5] = f8b[2];
            buf[pos + 6] = f8b[1];
            buf[pos + 7] = f8b[0];
          }
          exports3.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
          exports3.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;
          function readDouble_f64_cpy(buf, pos) {
            f8b[0] = buf[pos];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            f8b[4] = buf[pos + 4];
            f8b[5] = buf[pos + 5];
            f8b[6] = buf[pos + 6];
            f8b[7] = buf[pos + 7];
            return f64[0];
          }
          function readDouble_f64_rev(buf, pos) {
            f8b[7] = buf[pos];
            f8b[6] = buf[pos + 1];
            f8b[5] = buf[pos + 2];
            f8b[4] = buf[pos + 3];
            f8b[3] = buf[pos + 4];
            f8b[2] = buf[pos + 5];
            f8b[1] = buf[pos + 6];
            f8b[0] = buf[pos + 7];
            return f64[0];
          }
          exports3.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
          exports3.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;
        })();
      else
        (function() {
          function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
              val = -val;
            if (val === 0) {
              writeUint(0, buf, pos + off0);
              writeUint(1 / val > 0 ? (
                /* positive */
                0
              ) : (
                /* negative 0 */
                2147483648
              ), buf, pos + off1);
            } else if (isNaN(val)) {
              writeUint(0, buf, pos + off0);
              writeUint(2146959360, buf, pos + off1);
            } else if (val > 17976931348623157e292) {
              writeUint(0, buf, pos + off0);
              writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);
            } else {
              var mantissa;
              if (val < 22250738585072014e-324) {
                mantissa = val / 5e-324;
                writeUint(mantissa >>> 0, buf, pos + off0);
                writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);
              } else {
                var exponent = Math.floor(Math.log(val) / Math.LN2);
                if (exponent === 1024)
                  exponent = 1023;
                mantissa = val * Math.pow(2, -exponent);
                writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);
                writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);
              }
            }
          }
          exports3.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
          exports3.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);
          function readDouble_ieee754(readUint, off0, off1, buf, pos) {
            var lo = readUint(buf, pos + off0), hi = readUint(buf, pos + off1);
            var sign = (hi >> 31) * 2 + 1, exponent = hi >>> 20 & 2047, mantissa = 4294967296 * (hi & 1048575) + lo;
            return exponent === 2047 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 5e-324 * mantissa : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
          }
          exports3.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
          exports3.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);
        })();
      return exports3;
    }
    function writeUintLE(val, buf, pos) {
      buf[pos] = val & 255;
      buf[pos + 1] = val >>> 8 & 255;
      buf[pos + 2] = val >>> 16 & 255;
      buf[pos + 3] = val >>> 24;
    }
    function writeUintBE(val, buf, pos) {
      buf[pos] = val >>> 24;
      buf[pos + 1] = val >>> 16 & 255;
      buf[pos + 2] = val >>> 8 & 255;
      buf[pos + 3] = val & 255;
    }
    function readUintLE(buf, pos) {
      return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16 | buf[pos + 3] << 24) >>> 0;
    }
    function readUintBE(buf, pos) {
      return (buf[pos] << 24 | buf[pos + 1] << 16 | buf[pos + 2] << 8 | buf[pos + 3]) >>> 0;
    }
  }
});

// web/node_modules/@protobufjs/inquire/index.js
var require_inquire = __commonJS({
  "web/node_modules/@protobufjs/inquire/index.js"(exports, module) {
    "use strict";
    module.exports = inquire;
    function inquire(moduleName) {
      try {
        var mod = eval("quire".replace(/^/, "re"))(moduleName);
        if (mod && (mod.length || Object.keys(mod).length))
          return mod;
      } catch (e) {
      }
      return null;
    }
  }
});

// web/node_modules/@protobufjs/utf8/index.js
var require_utf8 = __commonJS({
  "web/node_modules/@protobufjs/utf8/index.js"(exports2) {
    "use strict";
    var utf8 = exports2;
    utf8.length = function utf8_length(string) {
      var len = 0, c = 0;
      for (var i = 0; i < string.length; ++i) {
        c = string.charCodeAt(i);
        if (c < 128)
          len += 1;
        else if (c < 2048)
          len += 2;
        else if ((c & 64512) === 55296 && (string.charCodeAt(i + 1) & 64512) === 56320) {
          ++i;
          len += 4;
        } else
          len += 3;
      }
      return len;
    };
    utf8.read = function utf8_read(buffer, start, end) {
      var len = end - start;
      if (len < 1)
        return "";
      var parts = null, chunk = [], i = 0, t;
      while (start < end) {
        t = buffer[start++];
        if (t < 128)
          chunk[i++] = t;
        else if (t > 191 && t < 224)
          chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;
        else if (t > 239 && t < 365) {
          t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 65536;
          chunk[i++] = 55296 + (t >> 10);
          chunk[i++] = 56320 + (t & 1023);
        } else
          chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;
        if (i > 8191) {
          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
          i = 0;
        }
      }
      if (parts) {
        if (i)
          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
      }
      return String.fromCharCode.apply(String, chunk.slice(0, i));
    };
    utf8.write = function utf8_write(string, buffer, offset) {
      var start = offset, c1, c2;
      for (var i = 0; i < string.length; ++i) {
        c1 = string.charCodeAt(i);
        if (c1 < 128) {
          buffer[offset++] = c1;
        } else if (c1 < 2048) {
          buffer[offset++] = c1 >> 6 | 192;
          buffer[offset++] = c1 & 63 | 128;
        } else if ((c1 & 64512) === 55296 && ((c2 = string.charCodeAt(i + 1)) & 64512) === 56320) {
          c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);
          ++i;
          buffer[offset++] = c1 >> 18 | 240;
          buffer[offset++] = c1 >> 12 & 63 | 128;
          buffer[offset++] = c1 >> 6 & 63 | 128;
          buffer[offset++] = c1 & 63 | 128;
        } else {
          buffer[offset++] = c1 >> 12 | 224;
          buffer[offset++] = c1 >> 6 & 63 | 128;
          buffer[offset++] = c1 & 63 | 128;
        }
      }
      return offset - start;
    };
  }
});

// web/node_modules/@protobufjs/pool/index.js
var require_pool = __commonJS({
  "web/node_modules/@protobufjs/pool/index.js"(exports2, module2) {
    "use strict";
    module2.exports = pool;
    function pool(alloc, slice2, size) {
      var SIZE = size || 8192;
      var MAX = SIZE >>> 1;
      var slab = null;
      var offset = SIZE;
      return function pool_alloc(size2) {
        if (size2 < 1 || size2 > MAX)
          return alloc(size2);
        if (offset + size2 > SIZE) {
          slab = alloc(SIZE);
          offset = 0;
        }
        var buf = slice2.call(slab, offset, offset += size2);
        if (offset & 7)
          offset = (offset | 7) + 1;
        return buf;
      };
    }
  }
});

// web/node_modules/protobufjs/src/util/longbits.js
var require_longbits = __commonJS({
  "web/node_modules/protobufjs/src/util/longbits.js"(exports2, module2) {
    "use strict";
    module2.exports = LongBits;
    var util = require_minimal();
    function LongBits(lo, hi) {
      this.lo = lo >>> 0;
      this.hi = hi >>> 0;
    }
    var zero = LongBits.zero = new LongBits(0, 0);
    zero.toNumber = function() {
      return 0;
    };
    zero.zzEncode = zero.zzDecode = function() {
      return this;
    };
    zero.length = function() {
      return 1;
    };
    var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";
    LongBits.fromNumber = function fromNumber2(value) {
      if (value === 0)
        return zero;
      var sign = value < 0;
      if (sign)
        value = -value;
      var lo = value >>> 0, hi = (value - lo) / 4294967296 >>> 0;
      if (sign) {
        hi = ~hi >>> 0;
        lo = ~lo >>> 0;
        if (++lo > 4294967295) {
          lo = 0;
          if (++hi > 4294967295)
            hi = 0;
        }
      }
      return new LongBits(lo, hi);
    };
    LongBits.from = function from(value) {
      if (typeof value === "number")
        return LongBits.fromNumber(value);
      if (util.isString(value)) {
        if (util.Long)
          value = util.Long.fromString(value);
        else
          return LongBits.fromNumber(parseInt(value, 10));
      }
      return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
    };
    LongBits.prototype.toNumber = function toNumber2(unsigned) {
      if (!unsigned && this.hi >>> 31) {
        var lo = ~this.lo + 1 >>> 0, hi = ~this.hi >>> 0;
        if (!lo)
          hi = hi + 1 >>> 0;
        return -(lo + hi * 4294967296);
      }
      return this.lo + this.hi * 4294967296;
    };
    LongBits.prototype.toLong = function toLong(unsigned) {
      return util.Long ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned)) : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
    };
    var charCodeAt = String.prototype.charCodeAt;
    LongBits.fromHash = function fromHash(hash) {
      if (hash === zeroHash)
        return zero;
      return new LongBits(
        (charCodeAt.call(hash, 0) | charCodeAt.call(hash, 1) << 8 | charCodeAt.call(hash, 2) << 16 | charCodeAt.call(hash, 3) << 24) >>> 0,
        (charCodeAt.call(hash, 4) | charCodeAt.call(hash, 5) << 8 | charCodeAt.call(hash, 6) << 16 | charCodeAt.call(hash, 7) << 24) >>> 0
      );
    };
    LongBits.prototype.toHash = function toHash() {
      return String.fromCharCode(
        this.lo & 255,
        this.lo >>> 8 & 255,
        this.lo >>> 16 & 255,
        this.lo >>> 24,
        this.hi & 255,
        this.hi >>> 8 & 255,
        this.hi >>> 16 & 255,
        this.hi >>> 24
      );
    };
    LongBits.prototype.zzEncode = function zzEncode() {
      var mask = this.hi >> 31;
      this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
      this.lo = (this.lo << 1 ^ mask) >>> 0;
      return this;
    };
    LongBits.prototype.zzDecode = function zzDecode() {
      var mask = -(this.lo & 1);
      this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
      this.hi = (this.hi >>> 1 ^ mask) >>> 0;
      return this;
    };
    LongBits.prototype.length = function length() {
      var part0 = this.lo, part1 = (this.lo >>> 28 | this.hi << 4) >>> 0, part2 = this.hi >>> 24;
      return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;
    };
  }
});

// web/node_modules/protobufjs/src/util/minimal.js
var require_minimal = __commonJS({
  "web/node_modules/protobufjs/src/util/minimal.js"(exports2) {
    "use strict";
    var util = exports2;
    util.asPromise = require_aspromise();
    util.base64 = require_base64();
    util.EventEmitter = require_eventemitter();
    util.float = require_float();
    util.inquire = require_inquire();
    util.utf8 = require_utf8();
    util.pool = require_pool();
    util.LongBits = require_longbits();
    util.isNode = Boolean(typeof global !== "undefined" && global && global.process && global.process.versions && global.process.versions.node);
    util.global = util.isNode && global || typeof window !== "undefined" && window || typeof self !== "undefined" && self || exports2;
    util.emptyArray = Object.freeze ? Object.freeze([]) : (
      /* istanbul ignore next */
      []
    );
    util.emptyObject = Object.freeze ? Object.freeze({}) : (
      /* istanbul ignore next */
      {}
    );
    util.isInteger = Number.isInteger || /* istanbul ignore next */
    function isInteger(value) {
      return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
    };
    util.isString = function isString(value) {
      return typeof value === "string" || value instanceof String;
    };
    util.isObject = function isObject(value) {
      return value && typeof value === "object";
    };
    util.isset = /**
     * Checks if a property on a message is considered to be present.
     * @param {Object} obj Plain object or message instance
     * @param {string} prop Property name
     * @returns {boolean} `true` if considered to be present, otherwise `false`
     */
    util.isSet = function isSet(obj, prop) {
      var value = obj[prop];
      if (value != null && obj.hasOwnProperty(prop))
        return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
      return false;
    };
    util.Buffer = function() {
      try {
        var Buffer2 = util.inquire("buffer").Buffer;
        return Buffer2.prototype.utf8Write ? Buffer2 : (
          /* istanbul ignore next */
          null
        );
      } catch (e) {
        return null;
      }
    }();
    util._Buffer_from = null;
    util._Buffer_allocUnsafe = null;
    util.newBuffer = function newBuffer(sizeOrArray) {
      return typeof sizeOrArray === "number" ? util.Buffer ? util._Buffer_allocUnsafe(sizeOrArray) : new util.Array(sizeOrArray) : util.Buffer ? util._Buffer_from(sizeOrArray) : typeof Uint8Array === "undefined" ? sizeOrArray : new Uint8Array(sizeOrArray);
    };
    util.Array = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    util.Long = /* istanbul ignore next */
    util.global.dcodeIO && /* istanbul ignore next */
    util.global.dcodeIO.Long || /* istanbul ignore next */
    util.global.Long || util.inquire("long");
    util.key2Re = /^true|false|0|1$/;
    util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;
    util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;
    util.longToHash = function longToHash(value) {
      return value ? util.LongBits.from(value).toHash() : util.LongBits.zeroHash;
    };
    util.longFromHash = function longFromHash(hash, unsigned) {
      var bits = util.LongBits.fromHash(hash);
      if (util.Long)
        return util.Long.fromBits(bits.lo, bits.hi, unsigned);
      return bits.toNumber(Boolean(unsigned));
    };
    function merge(dst, src, ifNotSet) {
      for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)
        if (dst[keys[i]] === void 0 || !ifNotSet)
          dst[keys[i]] = src[keys[i]];
      return dst;
    }
    util.merge = merge;
    util.lcFirst = function lcFirst(str) {
      return str.charAt(0).toLowerCase() + str.substring(1);
    };
    function newError(name2) {
      function CustomError(message, properties) {
        if (!(this instanceof CustomError))
          return new CustomError(message, properties);
        Object.defineProperty(this, "message", { get: function() {
          return message;
        } });
        if (Error.captureStackTrace)
          Error.captureStackTrace(this, CustomError);
        else
          Object.defineProperty(this, "stack", { value: new Error().stack || "" });
        if (properties)
          merge(this, properties);
      }
      CustomError.prototype = Object.create(Error.prototype, {
        constructor: {
          value: CustomError,
          writable: true,
          enumerable: false,
          configurable: true
        },
        name: {
          get: function get() {
            return name2;
          },
          set: void 0,
          enumerable: false,
          // configurable: false would accurately preserve the behavior of
          // the original, but I'm guessing that was not intentional.
          // For an actual error subclass, this property would
          // be configurable.
          configurable: true
        },
        toString: {
          value: function value() {
            return this.name + ": " + this.message;
          },
          writable: true,
          enumerable: false,
          configurable: true
        }
      });
      return CustomError;
    }
    util.newError = newError;
    util.ProtocolError = newError("ProtocolError");
    util.oneOfGetter = function getOneOf(fieldNames) {
      var fieldMap = {};
      for (var i = 0; i < fieldNames.length; ++i)
        fieldMap[fieldNames[i]] = 1;
      return function() {
        for (var keys = Object.keys(this), i2 = keys.length - 1; i2 > -1; --i2)
          if (fieldMap[keys[i2]] === 1 && this[keys[i2]] !== void 0 && this[keys[i2]] !== null)
            return keys[i2];
      };
    };
    util.oneOfSetter = function setOneOf(fieldNames) {
      return function(name2) {
        for (var i = 0; i < fieldNames.length; ++i)
          if (fieldNames[i] !== name2)
            delete this[fieldNames[i]];
      };
    };
    util.toJSONOptions = {
      longs: String,
      enums: String,
      bytes: String,
      json: true
    };
    util._configure = function() {
      var Buffer2 = util.Buffer;
      if (!Buffer2) {
        util._Buffer_from = util._Buffer_allocUnsafe = null;
        return;
      }
      util._Buffer_from = Buffer2.from !== Uint8Array.from && Buffer2.from || /* istanbul ignore next */
      function Buffer_from(value, encoding) {
        return new Buffer2(value, encoding);
      };
      util._Buffer_allocUnsafe = Buffer2.allocUnsafe || /* istanbul ignore next */
      function Buffer_allocUnsafe(size) {
        return new Buffer2(size);
      };
    };
  }
});

// web/node_modules/protobufjs/src/writer.js
var require_writer = __commonJS({
  "web/node_modules/protobufjs/src/writer.js"(exports2, module2) {
    "use strict";
    module2.exports = Writer;
    var util = require_minimal();
    var BufferWriter;
    var LongBits = util.LongBits;
    var base64 = util.base64;
    var utf8 = util.utf8;
    function Op(fn, len, val) {
      this.fn = fn;
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    function noop() {
    }
    function State(writer) {
      this.head = writer.head;
      this.tail = writer.tail;
      this.len = writer.len;
      this.next = writer.states;
    }
    function Writer() {
      this.len = 0;
      this.head = new Op(noop, 0, 0);
      this.tail = this.head;
      this.states = null;
    }
    var create = function create2() {
      return util.Buffer ? function create_buffer_setup() {
        return (Writer.create = function create_buffer() {
          return new BufferWriter();
        })();
      } : function create_array() {
        return new Writer();
      };
    };
    Writer.create = create();
    Writer.alloc = function alloc(size) {
      return new util.Array(size);
    };
    if (util.Array !== Array)
      Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);
    Writer.prototype._push = function push(fn, len, val) {
      this.tail = this.tail.next = new Op(fn, len, val);
      this.len += len;
      return this;
    };
    function writeByte(val, buf, pos) {
      buf[pos] = val & 255;
    }
    function writeVarint32(val, buf, pos) {
      while (val > 127) {
        buf[pos++] = val & 127 | 128;
        val >>>= 7;
      }
      buf[pos] = val;
    }
    function VarintOp(len, val) {
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    VarintOp.prototype = Object.create(Op.prototype);
    VarintOp.prototype.fn = writeVarint32;
    Writer.prototype.uint32 = function write_uint32(value) {
      this.len += (this.tail = this.tail.next = new VarintOp(
        (value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5,
        value
      )).len;
      return this;
    };
    Writer.prototype.int32 = function write_int32(value) {
      return value < 0 ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) : this.uint32(value);
    };
    Writer.prototype.sint32 = function write_sint32(value) {
      return this.uint32((value << 1 ^ value >> 31) >>> 0);
    };
    function writeVarint64(val, buf, pos) {
      while (val.hi) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
        val.hi >>>= 7;
      }
      while (val.lo > 127) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = val.lo >>> 7;
      }
      buf[pos++] = val.lo;
    }
    Writer.prototype.uint64 = function write_uint64(value) {
      var bits = LongBits.from(value);
      return this._push(writeVarint64, bits.length(), bits);
    };
    Writer.prototype.int64 = Writer.prototype.uint64;
    Writer.prototype.sint64 = function write_sint64(value) {
      var bits = LongBits.from(value).zzEncode();
      return this._push(writeVarint64, bits.length(), bits);
    };
    Writer.prototype.bool = function write_bool(value) {
      return this._push(writeByte, 1, value ? 1 : 0);
    };
    function writeFixed32(val, buf, pos) {
      buf[pos] = val & 255;
      buf[pos + 1] = val >>> 8 & 255;
      buf[pos + 2] = val >>> 16 & 255;
      buf[pos + 3] = val >>> 24;
    }
    Writer.prototype.fixed32 = function write_fixed32(value) {
      return this._push(writeFixed32, 4, value >>> 0);
    };
    Writer.prototype.sfixed32 = Writer.prototype.fixed32;
    Writer.prototype.fixed64 = function write_fixed64(value) {
      var bits = LongBits.from(value);
      return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
    };
    Writer.prototype.sfixed64 = Writer.prototype.fixed64;
    Writer.prototype.float = function write_float(value) {
      return this._push(util.float.writeFloatLE, 4, value);
    };
    Writer.prototype.double = function write_double(value) {
      return this._push(util.float.writeDoubleLE, 8, value);
    };
    var writeBytes = util.Array.prototype.set ? function writeBytes_set(val, buf, pos) {
      buf.set(val, pos);
    } : function writeBytes_for(val, buf, pos) {
      for (var i = 0; i < val.length; ++i)
        buf[pos + i] = val[i];
    };
    Writer.prototype.bytes = function write_bytes(value) {
      var len = value.length >>> 0;
      if (!len)
        return this._push(writeByte, 1, 0);
      if (util.isString(value)) {
        var buf = Writer.alloc(len = base64.length(value));
        base64.decode(value, buf, 0);
        value = buf;
      }
      return this.uint32(len)._push(writeBytes, len, value);
    };
    Writer.prototype.string = function write_string(value) {
      var len = utf8.length(value);
      return len ? this.uint32(len)._push(utf8.write, len, value) : this._push(writeByte, 1, 0);
    };
    Writer.prototype.fork = function fork() {
      this.states = new State(this);
      this.head = this.tail = new Op(noop, 0, 0);
      this.len = 0;
      return this;
    };
    Writer.prototype.reset = function reset() {
      if (this.states) {
        this.head = this.states.head;
        this.tail = this.states.tail;
        this.len = this.states.len;
        this.states = this.states.next;
      } else {
        this.head = this.tail = new Op(noop, 0, 0);
        this.len = 0;
      }
      return this;
    };
    Writer.prototype.ldelim = function ldelim() {
      var head = this.head, tail = this.tail, len = this.len;
      this.reset().uint32(len);
      if (len) {
        this.tail.next = head.next;
        this.tail = tail;
        this.len += len;
      }
      return this;
    };
    Writer.prototype.finish = function finish() {
      var head = this.head.next, buf = this.constructor.alloc(this.len), pos = 0;
      while (head) {
        head.fn(head.val, buf, pos);
        pos += head.len;
        head = head.next;
      }
      return buf;
    };
    Writer._configure = function(BufferWriter_) {
      BufferWriter = BufferWriter_;
      Writer.create = create();
      BufferWriter._configure();
    };
  }
});

// web/node_modules/protobufjs/src/writer_buffer.js
var require_writer_buffer = __commonJS({
  "web/node_modules/protobufjs/src/writer_buffer.js"(exports2, module2) {
    "use strict";
    module2.exports = BufferWriter;
    var Writer = require_writer();
    (BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;
    var util = require_minimal();
    function BufferWriter() {
      Writer.call(this);
    }
    BufferWriter._configure = function() {
      BufferWriter.alloc = util._Buffer_allocUnsafe;
      BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === "set" ? function writeBytesBuffer_set(val, buf, pos) {
        buf.set(val, pos);
      } : function writeBytesBuffer_copy(val, buf, pos) {
        if (val.copy)
          val.copy(buf, pos, 0, val.length);
        else
          for (var i = 0; i < val.length; )
            buf[pos++] = val[i++];
      };
    };
    BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
      if (util.isString(value))
        value = util._Buffer_from(value, "base64");
      var len = value.length >>> 0;
      this.uint32(len);
      if (len)
        this._push(BufferWriter.writeBytesBuffer, len, value);
      return this;
    };
    function writeStringBuffer(val, buf, pos) {
      if (val.length < 40)
        util.utf8.write(val, buf, pos);
      else if (buf.utf8Write)
        buf.utf8Write(val, pos);
      else
        buf.write(val, pos);
    }
    BufferWriter.prototype.string = function write_string_buffer(value) {
      var len = util.Buffer.byteLength(value);
      this.uint32(len);
      if (len)
        this._push(writeStringBuffer, len, value);
      return this;
    };
    BufferWriter._configure();
  }
});

// web/node_modules/protobufjs/src/reader.js
var require_reader = __commonJS({
  "web/node_modules/protobufjs/src/reader.js"(exports2, module2) {
    "use strict";
    module2.exports = Reader;
    var util = require_minimal();
    var BufferReader;
    var LongBits = util.LongBits;
    var utf8 = util.utf8;
    function indexOutOfRange(reader, writeLength) {
      return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
    }
    function Reader(buffer) {
      this.buf = buffer;
      this.pos = 0;
      this.len = buffer.length;
    }
    var create_array = typeof Uint8Array !== "undefined" ? function create_typed_array(buffer) {
      if (buffer instanceof Uint8Array || Array.isArray(buffer))
        return new Reader(buffer);
      throw Error("illegal buffer");
    } : function create_array2(buffer) {
      if (Array.isArray(buffer))
        return new Reader(buffer);
      throw Error("illegal buffer");
    };
    var create = function create2() {
      return util.Buffer ? function create_buffer_setup(buffer) {
        return (Reader.create = function create_buffer(buffer2) {
          return util.Buffer.isBuffer(buffer2) ? new BufferReader(buffer2) : create_array(buffer2);
        })(buffer);
      } : create_array;
    };
    Reader.create = create();
    Reader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */
    util.Array.prototype.slice;
    Reader.prototype.uint32 = function read_uint32_setup() {
      var value = 4294967295;
      return function read_uint32() {
        value = (this.buf[this.pos] & 127) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 127) << 7) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 15) << 28) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        if ((this.pos += 5) > this.len) {
          this.pos = this.len;
          throw indexOutOfRange(this, 10);
        }
        return value;
      };
    }();
    Reader.prototype.int32 = function read_int32() {
      return this.uint32() | 0;
    };
    Reader.prototype.sint32 = function read_sint32() {
      var value = this.uint32();
      return value >>> 1 ^ -(value & 1) | 0;
    };
    function readLongVarint() {
      var bits = new LongBits(0, 0);
      var i = 0;
      if (this.len - this.pos > 4) {
        for (; i < 4; ++i) {
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;
        if (this.buf[this.pos++] < 128)
          return bits;
        i = 0;
      } else {
        for (; i < 3; ++i) {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
        return bits;
      }
      if (this.len - this.pos > 4) {
        for (; i < 5; ++i) {
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
      } else {
        for (; i < 5; ++i) {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
      }
      throw Error("invalid varint encoding");
    }
    Reader.prototype.bool = function read_bool() {
      return this.uint32() !== 0;
    };
    function readFixed32_end(buf, end) {
      return (buf[end - 4] | buf[end - 3] << 8 | buf[end - 2] << 16 | buf[end - 1] << 24) >>> 0;
    }
    Reader.prototype.fixed32 = function read_fixed32() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4);
    };
    Reader.prototype.sfixed32 = function read_sfixed32() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4) | 0;
    };
    function readFixed64() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 8);
      return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
    }
    Reader.prototype.float = function read_float() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      var value = util.float.readFloatLE(this.buf, this.pos);
      this.pos += 4;
      return value;
    };
    Reader.prototype.double = function read_double() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 4);
      var value = util.float.readDoubleLE(this.buf, this.pos);
      this.pos += 8;
      return value;
    };
    Reader.prototype.bytes = function read_bytes() {
      var length = this.uint32(), start = this.pos, end = this.pos + length;
      if (end > this.len)
        throw indexOutOfRange(this, length);
      this.pos += length;
      if (Array.isArray(this.buf))
        return this.buf.slice(start, end);
      return start === end ? new this.buf.constructor(0) : this._slice.call(this.buf, start, end);
    };
    Reader.prototype.string = function read_string() {
      var bytes = this.bytes();
      return utf8.read(bytes, 0, bytes.length);
    };
    Reader.prototype.skip = function skip(length) {
      if (typeof length === "number") {
        if (this.pos + length > this.len)
          throw indexOutOfRange(this, length);
        this.pos += length;
      } else {
        do {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
        } while (this.buf[this.pos++] & 128);
      }
      return this;
    };
    Reader.prototype.skipType = function(wireType) {
      switch (wireType) {
        case 0:
          this.skip();
          break;
        case 1:
          this.skip(8);
          break;
        case 2:
          this.skip(this.uint32());
          break;
        case 3:
          while ((wireType = this.uint32() & 7) !== 4) {
            this.skipType(wireType);
          }
          break;
        case 5:
          this.skip(4);
          break;
        default:
          throw Error("invalid wire type " + wireType + " at offset " + this.pos);
      }
      return this;
    };
    Reader._configure = function(BufferReader_) {
      BufferReader = BufferReader_;
      Reader.create = create();
      BufferReader._configure();
      var fn = util.Long ? "toLong" : (
        /* istanbul ignore next */
        "toNumber"
      );
      util.merge(Reader.prototype, {
        int64: function read_int64() {
          return readLongVarint.call(this)[fn](false);
        },
        uint64: function read_uint64() {
          return readLongVarint.call(this)[fn](true);
        },
        sint64: function read_sint64() {
          return readLongVarint.call(this).zzDecode()[fn](false);
        },
        fixed64: function read_fixed64() {
          return readFixed64.call(this)[fn](true);
        },
        sfixed64: function read_sfixed64() {
          return readFixed64.call(this)[fn](false);
        }
      });
    };
  }
});

// web/node_modules/protobufjs/src/reader_buffer.js
var require_reader_buffer = __commonJS({
  "web/node_modules/protobufjs/src/reader_buffer.js"(exports2, module2) {
    "use strict";
    module2.exports = BufferReader;
    var Reader = require_reader();
    (BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;
    var util = require_minimal();
    function BufferReader(buffer) {
      Reader.call(this, buffer);
    }
    BufferReader._configure = function() {
      if (util.Buffer)
        BufferReader.prototype._slice = util.Buffer.prototype.slice;
    };
    BufferReader.prototype.string = function read_string_buffer() {
      var len = this.uint32();
      return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
    };
    BufferReader._configure();
  }
});

// web/node_modules/protobufjs/src/rpc/service.js
var require_service = __commonJS({
  "web/node_modules/protobufjs/src/rpc/service.js"(exports2, module2) {
    "use strict";
    module2.exports = Service;
    var util = require_minimal();
    (Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;
    function Service(rpcImpl, requestDelimited, responseDelimited) {
      if (typeof rpcImpl !== "function")
        throw TypeError("rpcImpl must be a function");
      util.EventEmitter.call(this);
      this.rpcImpl = rpcImpl;
      this.requestDelimited = Boolean(requestDelimited);
      this.responseDelimited = Boolean(responseDelimited);
    }
    Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {
      if (!request)
        throw TypeError("request must be specified");
      var self2 = this;
      if (!callback)
        return util.asPromise(rpcCall, self2, method, requestCtor, responseCtor, request);
      if (!self2.rpcImpl) {
        setTimeout(function() {
          callback(Error("already ended"));
        }, 0);
        return void 0;
      }
      try {
        return self2.rpcImpl(
          method,
          requestCtor[self2.requestDelimited ? "encodeDelimited" : "encode"](request).finish(),
          function rpcCallback(err, response) {
            if (err) {
              self2.emit("error", err, method);
              return callback(err);
            }
            if (response === null) {
              self2.end(
                /* endedByRPC */
                true
              );
              return void 0;
            }
            if (!(response instanceof responseCtor)) {
              try {
                response = responseCtor[self2.responseDelimited ? "decodeDelimited" : "decode"](response);
              } catch (err2) {
                self2.emit("error", err2, method);
                return callback(err2);
              }
            }
            self2.emit("data", response, method);
            return callback(null, response);
          }
        );
      } catch (err) {
        self2.emit("error", err, method);
        setTimeout(function() {
          callback(err);
        }, 0);
        return void 0;
      }
    };
    Service.prototype.end = function end(endedByRPC) {
      if (this.rpcImpl) {
        if (!endedByRPC)
          this.rpcImpl(null, null, null);
        this.rpcImpl = null;
        this.emit("end").off();
      }
      return this;
    };
  }
});

// web/node_modules/protobufjs/src/rpc.js
var require_rpc = __commonJS({
  "web/node_modules/protobufjs/src/rpc.js"(exports2) {
    "use strict";
    var rpc = exports2;
    rpc.Service = require_service();
  }
});

// web/node_modules/protobufjs/src/roots.js
var require_roots = __commonJS({
  "web/node_modules/protobufjs/src/roots.js"(exports2, module2) {
    "use strict";
    module2.exports = {};
  }
});

// web/node_modules/protobufjs/src/index-minimal.js
var require_index_minimal = __commonJS({
  "web/node_modules/protobufjs/src/index-minimal.js"(exports2) {
    "use strict";
    var protobuf = exports2;
    protobuf.build = "minimal";
    protobuf.Writer = require_writer();
    protobuf.BufferWriter = require_writer_buffer();
    protobuf.Reader = require_reader();
    protobuf.BufferReader = require_reader_buffer();
    protobuf.util = require_minimal();
    protobuf.rpc = require_rpc();
    protobuf.roots = require_roots();
    protobuf.configure = configure;
    function configure() {
      protobuf.util._configure();
      protobuf.Writer._configure(protobuf.BufferWriter);
      protobuf.Reader._configure(protobuf.BufferReader);
    }
    configure();
  }
});

// web/node_modules/protobufjs/minimal.js
var require_minimal2 = __commonJS({
  "web/node_modules/protobufjs/minimal.js"(exports2, module2) {
    "use strict";
    module2.exports = require_index_minimal();
  }
});

// web/lib/onnxjs/ort-schema/protobuf/onnx.js
var require_onnx = __commonJS({
  "web/lib/onnxjs/ort-schema/protobuf/onnx.js"(exports2, module2) {
    "use strict";
    var $protobuf = require_minimal2();
    var $Reader = $protobuf.Reader;
    var $Writer = $protobuf.Writer;
    var $util = $protobuf.util;
    var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});
    $root.onnx = function() {
      var onnx6 = {};
      onnx6.Version = function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "_START_VERSION"] = 0;
        values[valuesById[1] = "IR_VERSION_2017_10_10"] = 1;
        values[valuesById[2] = "IR_VERSION_2017_10_30"] = 2;
        values[valuesById[3] = "IR_VERSION_2017_11_3"] = 3;
        values[valuesById[4] = "IR_VERSION_2019_1_22"] = 4;
        values[valuesById[5] = "IR_VERSION_2019_3_18"] = 5;
        values[valuesById[6] = "IR_VERSION_2019_9_19"] = 6;
        values[valuesById[7] = "IR_VERSION_2020_5_8"] = 7;
        values[valuesById[8] = "IR_VERSION_2021_7_30"] = 8;
        values[valuesById[9] = "IR_VERSION"] = 9;
        return values;
      }();
      onnx6.AttributeProto = function() {
        function AttributeProto(properties) {
          this.floats = [];
          this.ints = [];
          this.strings = [];
          this.tensors = [];
          this.graphs = [];
          this.sparseTensors = [];
          this.typeProtos = [];
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        AttributeProto.prototype.name = "";
        AttributeProto.prototype.refAttrName = "";
        AttributeProto.prototype.docString = "";
        AttributeProto.prototype.type = 0;
        AttributeProto.prototype.f = 0;
        AttributeProto.prototype.i = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        AttributeProto.prototype.s = $util.newBuffer([]);
        AttributeProto.prototype.t = null;
        AttributeProto.prototype.g = null;
        AttributeProto.prototype.sparseTensor = null;
        AttributeProto.prototype.tp = null;
        AttributeProto.prototype.floats = $util.emptyArray;
        AttributeProto.prototype.ints = $util.emptyArray;
        AttributeProto.prototype.strings = $util.emptyArray;
        AttributeProto.prototype.tensors = $util.emptyArray;
        AttributeProto.prototype.graphs = $util.emptyArray;
        AttributeProto.prototype.sparseTensors = $util.emptyArray;
        AttributeProto.prototype.typeProtos = $util.emptyArray;
        AttributeProto.create = function create(properties) {
          return new AttributeProto(properties);
        };
        AttributeProto.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.name != null && Object.hasOwnProperty.call(message, "name"))
            writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).string(message.name);
          if (message.f != null && Object.hasOwnProperty.call(message, "f"))
            writer.uint32(
              /* id 2, wireType 5 =*/
              21
            ).float(message.f);
          if (message.i != null && Object.hasOwnProperty.call(message, "i"))
            writer.uint32(
              /* id 3, wireType 0 =*/
              24
            ).int64(message.i);
          if (message.s != null && Object.hasOwnProperty.call(message, "s"))
            writer.uint32(
              /* id 4, wireType 2 =*/
              34
            ).bytes(message.s);
          if (message.t != null && Object.hasOwnProperty.call(message, "t"))
            $root.onnx.TensorProto.encode(message.t, writer.uint32(
              /* id 5, wireType 2 =*/
              42
            ).fork()).ldelim();
          if (message.g != null && Object.hasOwnProperty.call(message, "g"))
            $root.onnx.GraphProto.encode(message.g, writer.uint32(
              /* id 6, wireType 2 =*/
              50
            ).fork()).ldelim();
          if (message.floats != null && message.floats.length) {
            writer.uint32(
              /* id 7, wireType 2 =*/
              58
            ).fork();
            for (var i = 0; i < message.floats.length; ++i)
              writer.float(message.floats[i]);
            writer.ldelim();
          }
          if (message.ints != null && message.ints.length) {
            writer.uint32(
              /* id 8, wireType 2 =*/
              66
            ).fork();
            for (var i = 0; i < message.ints.length; ++i)
              writer.int64(message.ints[i]);
            writer.ldelim();
          }
          if (message.strings != null && message.strings.length)
            for (var i = 0; i < message.strings.length; ++i)
              writer.uint32(
                /* id 9, wireType 2 =*/
                74
              ).bytes(message.strings[i]);
          if (message.tensors != null && message.tensors.length)
            for (var i = 0; i < message.tensors.length; ++i)
              $root.onnx.TensorProto.encode(message.tensors[i], writer.uint32(
                /* id 10, wireType 2 =*/
                82
              ).fork()).ldelim();
          if (message.graphs != null && message.graphs.length)
            for (var i = 0; i < message.graphs.length; ++i)
              $root.onnx.GraphProto.encode(message.graphs[i], writer.uint32(
                /* id 11, wireType 2 =*/
                90
              ).fork()).ldelim();
          if (message.docString != null && Object.hasOwnProperty.call(message, "docString"))
            writer.uint32(
              /* id 13, wireType 2 =*/
              106
            ).string(message.docString);
          if (message.tp != null && Object.hasOwnProperty.call(message, "tp"))
            $root.onnx.TypeProto.encode(message.tp, writer.uint32(
              /* id 14, wireType 2 =*/
              114
            ).fork()).ldelim();
          if (message.typeProtos != null && message.typeProtos.length)
            for (var i = 0; i < message.typeProtos.length; ++i)
              $root.onnx.TypeProto.encode(message.typeProtos[i], writer.uint32(
                /* id 15, wireType 2 =*/
                122
              ).fork()).ldelim();
          if (message.type != null && Object.hasOwnProperty.call(message, "type"))
            writer.uint32(
              /* id 20, wireType 0 =*/
              160
            ).int32(message.type);
          if (message.refAttrName != null && Object.hasOwnProperty.call(message, "refAttrName"))
            writer.uint32(
              /* id 21, wireType 2 =*/
              170
            ).string(message.refAttrName);
          if (message.sparseTensor != null && Object.hasOwnProperty.call(message, "sparseTensor"))
            $root.onnx.SparseTensorProto.encode(message.sparseTensor, writer.uint32(
              /* id 22, wireType 2 =*/
              178
            ).fork()).ldelim();
          if (message.sparseTensors != null && message.sparseTensors.length)
            for (var i = 0; i < message.sparseTensors.length; ++i)
              $root.onnx.SparseTensorProto.encode(message.sparseTensors[i], writer.uint32(
                /* id 23, wireType 2 =*/
                186
              ).fork()).ldelim();
          return writer;
        };
        AttributeProto.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        AttributeProto.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.onnx.AttributeProto();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                message.name = reader.string();
                break;
              }
              case 21: {
                message.refAttrName = reader.string();
                break;
              }
              case 13: {
                message.docString = reader.string();
                break;
              }
              case 20: {
                message.type = reader.int32();
                break;
              }
              case 2: {
                message.f = reader.float();
                break;
              }
              case 3: {
                message.i = reader.int64();
                break;
              }
              case 4: {
                message.s = reader.bytes();
                break;
              }
              case 5: {
                message.t = $root.onnx.TensorProto.decode(reader, reader.uint32());
                break;
              }
              case 6: {
                message.g = $root.onnx.GraphProto.decode(reader, reader.uint32());
                break;
              }
              case 22: {
                message.sparseTensor = $root.onnx.SparseTensorProto.decode(reader, reader.uint32());
                break;
              }
              case 14: {
                message.tp = $root.onnx.TypeProto.decode(reader, reader.uint32());
                break;
              }
              case 7: {
                if (!(message.floats && message.floats.length))
                  message.floats = [];
                if ((tag & 7) === 2) {
                  var end2 = reader.uint32() + reader.pos;
                  while (reader.pos < end2)
                    message.floats.push(reader.float());
                } else
                  message.floats.push(reader.float());
                break;
              }
              case 8: {
                if (!(message.ints && message.ints.length))
                  message.ints = [];
                if ((tag & 7) === 2) {
                  var end2 = reader.uint32() + reader.pos;
                  while (reader.pos < end2)
                    message.ints.push(reader.int64());
                } else
                  message.ints.push(reader.int64());
                break;
              }
              case 9: {
                if (!(message.strings && message.strings.length))
                  message.strings = [];
                message.strings.push(reader.bytes());
                break;
              }
              case 10: {
                if (!(message.tensors && message.tensors.length))
                  message.tensors = [];
                message.tensors.push($root.onnx.TensorProto.decode(reader, reader.uint32()));
                break;
              }
              case 11: {
                if (!(message.graphs && message.graphs.length))
                  message.graphs = [];
                message.graphs.push($root.onnx.GraphProto.decode(reader, reader.uint32()));
                break;
              }
              case 23: {
                if (!(message.sparseTensors && message.sparseTensors.length))
                  message.sparseTensors = [];
                message.sparseTensors.push($root.onnx.SparseTensorProto.decode(reader, reader.uint32()));
                break;
              }
              case 15: {
                if (!(message.typeProtos && message.typeProtos.length))
                  message.typeProtos = [];
                message.typeProtos.push($root.onnx.TypeProto.decode(reader, reader.uint32()));
                break;
              }
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        AttributeProto.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        AttributeProto.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.name != null && message.hasOwnProperty("name")) {
            if (!$util.isString(message.name))
              return "name: string expected";
          }
          if (message.refAttrName != null && message.hasOwnProperty("refAttrName")) {
            if (!$util.isString(message.refAttrName))
              return "refAttrName: string expected";
          }
          if (message.docString != null && message.hasOwnProperty("docString")) {
            if (!$util.isString(message.docString))
              return "docString: string expected";
          }
          if (message.type != null && message.hasOwnProperty("type"))
            switch (message.type) {
              default:
                return "type: enum value expected";
              case 0:
              case 1:
              case 2:
              case 3:
              case 4:
              case 5:
              case 11:
              case 13:
              case 6:
              case 7:
              case 8:
              case 9:
              case 10:
              case 12:
              case 14:
                break;
            }
          if (message.f != null && message.hasOwnProperty("f")) {
            if (typeof message.f !== "number")
              return "f: number expected";
          }
          if (message.i != null && message.hasOwnProperty("i")) {
            if (!$util.isInteger(message.i) && !(message.i && $util.isInteger(message.i.low) && $util.isInteger(message.i.high)))
              return "i: integer|Long expected";
          }
          if (message.s != null && message.hasOwnProperty("s")) {
            if (!(message.s && typeof message.s.length === "number" || $util.isString(message.s)))
              return "s: buffer expected";
          }
          if (message.t != null && message.hasOwnProperty("t")) {
            var error = $root.onnx.TensorProto.verify(message.t);
            if (error)
              return "t." + error;
          }
          if (message.g != null && message.hasOwnProperty("g")) {
            var error = $root.onnx.GraphProto.verify(message.g);
            if (error)
              return "g." + error;
          }
          if (message.sparseTensor != null && message.hasOwnProperty("sparseTensor")) {
            var error = $root.onnx.SparseTensorProto.verify(message.sparseTensor);
            if (error)
              return "sparseTensor." + error;
          }
          if (message.tp != null && message.hasOwnProperty("tp")) {
            var error = $root.onnx.TypeProto.verify(message.tp);
            if (error)
              return "tp." + error;
          }
          if (message.floats != null && message.hasOwnProperty("floats")) {
            if (!Array.isArray(message.floats))
              return "floats: array expected";
            for (var i = 0; i < message.floats.length; ++i)
              if (typeof message.floats[i] !== "number")
                return "floats: number[] expected";
          }
          if (message.ints != null && message.hasOwnProperty("ints")) {
            if (!Array.isArray(message.ints))
              return "ints: array expected";
            for (var i = 0; i < message.ints.length; ++i)
              if (!$util.isInteger(message.ints[i]) && !(message.ints[i] && $util.isInteger(message.ints[i].low) && $util.isInteger(message.ints[i].high)))
                return "ints: integer|Long[] expected";
          }
          if (message.strings != null && message.hasOwnProperty("strings")) {
            if (!Array.isArray(message.strings))
              return "strings: array expected";
            for (var i = 0; i < message.strings.length; ++i)
              if (!(message.strings[i] && typeof message.strings[i].length === "number" || $util.isString(message.strings[i])))
                return "strings: buffer[] expected";
          }
          if (message.tensors != null && message.hasOwnProperty("tensors")) {
            if (!Array.isArray(message.tensors))
              return "tensors: array expected";
            for (var i = 0; i < message.tensors.length; ++i) {
              var error = $root.onnx.TensorProto.verify(message.tensors[i]);
              if (error)
                return "tensors." + error;
            }
          }
          if (message.graphs != null && message.hasOwnProperty("graphs")) {
            if (!Array.isArray(message.graphs))
              return "graphs: array expected";
            for (var i = 0; i < message.graphs.length; ++i) {
              var error = $root.onnx.GraphProto.verify(message.graphs[i]);
              if (error)
                return "graphs." + error;
            }
          }
          if (message.sparseTensors != null && message.hasOwnProperty("sparseTensors")) {
            if (!Array.isArray(message.sparseTensors))
              return "sparseTensors: array expected";
            for (var i = 0; i < message.sparseTensors.length; ++i) {
              var error = $root.onnx.SparseTensorProto.verify(message.sparseTensors[i]);
              if (error)
                return "sparseTensors." + error;
            }
          }
          if (message.typeProtos != null && message.hasOwnProperty("typeProtos")) {
            if (!Array.isArray(message.typeProtos))
              return "typeProtos: array expected";
            for (var i = 0; i < message.typeProtos.length; ++i) {
              var error = $root.onnx.TypeProto.verify(message.typeProtos[i]);
              if (error)
                return "typeProtos." + error;
            }
          }
          return null;
        };
        AttributeProto.fromObject = function fromObject(object) {
          if (object instanceof $root.onnx.AttributeProto)
            return object;
          var message = new $root.onnx.AttributeProto();
          if (object.name != null)
            message.name = String(object.name);
          if (object.refAttrName != null)
            message.refAttrName = String(object.refAttrName);
          if (object.docString != null)
            message.docString = String(object.docString);
          switch (object.type) {
            default:
              if (typeof object.type === "number") {
                message.type = object.type;
                break;
              }
              break;
            case "UNDEFINED":
            case 0:
              message.type = 0;
              break;
            case "FLOAT":
            case 1:
              message.type = 1;
              break;
            case "INT":
            case 2:
              message.type = 2;
              break;
            case "STRING":
            case 3:
              message.type = 3;
              break;
            case "TENSOR":
            case 4:
              message.type = 4;
              break;
            case "GRAPH":
            case 5:
              message.type = 5;
              break;
            case "SPARSE_TENSOR":
            case 11:
              message.type = 11;
              break;
            case "TYPE_PROTO":
            case 13:
              message.type = 13;
              break;
            case "FLOATS":
            case 6:
              message.type = 6;
              break;
            case "INTS":
            case 7:
              message.type = 7;
              break;
            case "STRINGS":
            case 8:
              message.type = 8;
              break;
            case "TENSORS":
            case 9:
              message.type = 9;
              break;
            case "GRAPHS":
            case 10:
              message.type = 10;
              break;
            case "SPARSE_TENSORS":
            case 12:
              message.type = 12;
              break;
            case "TYPE_PROTOS":
            case 14:
              message.type = 14;
              break;
          }
          if (object.f != null)
            message.f = Number(object.f);
          if (object.i != null) {
            if ($util.Long)
              (message.i = $util.Long.fromValue(object.i)).unsigned = false;
            else if (typeof object.i === "string")
              message.i = parseInt(object.i, 10);
            else if (typeof object.i === "number")
              message.i = object.i;
            else if (typeof object.i === "object")
              message.i = new $util.LongBits(object.i.low >>> 0, object.i.high >>> 0).toNumber();
          }
          if (object.s != null) {
            if (typeof object.s === "string")
              $util.base64.decode(object.s, message.s = $util.newBuffer($util.base64.length(object.s)), 0);
            else if (object.s.length >= 0)
              message.s = object.s;
          }
          if (object.t != null) {
            if (typeof object.t !== "object")
              throw TypeError(".onnx.AttributeProto.t: object expected");
            message.t = $root.onnx.TensorProto.fromObject(object.t);
          }
          if (object.g != null) {
            if (typeof object.g !== "object")
              throw TypeError(".onnx.AttributeProto.g: object expected");
            message.g = $root.onnx.GraphProto.fromObject(object.g);
          }
          if (object.sparseTensor != null) {
            if (typeof object.sparseTensor !== "object")
              throw TypeError(".onnx.AttributeProto.sparseTensor: object expected");
            message.sparseTensor = $root.onnx.SparseTensorProto.fromObject(object.sparseTensor);
          }
          if (object.tp != null) {
            if (typeof object.tp !== "object")
              throw TypeError(".onnx.AttributeProto.tp: object expected");
            message.tp = $root.onnx.TypeProto.fromObject(object.tp);
          }
          if (object.floats) {
            if (!Array.isArray(object.floats))
              throw TypeError(".onnx.AttributeProto.floats: array expected");
            message.floats = [];
            for (var i = 0; i < object.floats.length; ++i)
              message.floats[i] = Number(object.floats[i]);
          }
          if (object.ints) {
            if (!Array.isArray(object.ints))
              throw TypeError(".onnx.AttributeProto.ints: array expected");
            message.ints = [];
            for (var i = 0; i < object.ints.length; ++i)
              if ($util.Long)
                (message.ints[i] = $util.Long.fromValue(object.ints[i])).unsigned = false;
              else if (typeof object.ints[i] === "string")
                message.ints[i] = parseInt(object.ints[i], 10);
              else if (typeof object.ints[i] === "number")
                message.ints[i] = object.ints[i];
              else if (typeof object.ints[i] === "object")
                message.ints[i] = new $util.LongBits(object.ints[i].low >>> 0, object.ints[i].high >>> 0).toNumber();
          }
          if (object.strings) {
            if (!Array.isArray(object.strings))
              throw TypeError(".onnx.AttributeProto.strings: array expected");
            message.strings = [];
            for (var i = 0; i < object.strings.length; ++i)
              if (typeof object.strings[i] === "string")
                $util.base64.decode(object.strings[i], message.strings[i] = $util.newBuffer($util.base64.length(object.strings[i])), 0);
              else if (object.strings[i].length >= 0)
                message.strings[i] = object.strings[i];
          }
          if (object.tensors) {
            if (!Array.isArray(object.tensors))
              throw TypeError(".onnx.AttributeProto.tensors: array expected");
            message.tensors = [];
            for (var i = 0; i < object.tensors.length; ++i) {
              if (typeof object.tensors[i] !== "object")
                throw TypeError(".onnx.AttributeProto.tensors: object expected");
              message.tensors[i] = $root.onnx.TensorProto.fromObject(object.tensors[i]);
            }
          }
          if (object.graphs) {
            if (!Array.isArray(object.graphs))
              throw TypeError(".onnx.AttributeProto.graphs: array expected");
            message.graphs = [];
            for (var i = 0; i < object.graphs.length; ++i) {
              if (typeof object.graphs[i] !== "object")
                throw TypeError(".onnx.AttributeProto.graphs: object expected");
              message.graphs[i] = $root.onnx.GraphProto.fromObject(object.graphs[i]);
            }
          }
          if (object.sparseTensors) {
            if (!Array.isArray(object.sparseTensors))
              throw TypeError(".onnx.AttributeProto.sparseTensors: array expected");
            message.sparseTensors = [];
            for (var i = 0; i < object.sparseTensors.length; ++i) {
              if (typeof object.sparseTensors[i] !== "object")
                throw TypeError(".onnx.AttributeProto.sparseTensors: object expected");
              message.sparseTensors[i] = $root.onnx.SparseTensorProto.fromObject(object.sparseTensors[i]);
            }
          }
          if (object.typeProtos) {
            if (!Array.isArray(object.typeProtos))
              throw TypeError(".onnx.AttributeProto.typeProtos: array expected");
            message.typeProtos = [];
            for (var i = 0; i < object.typeProtos.length; ++i) {
              if (typeof object.typeProtos[i] !== "object")
                throw TypeError(".onnx.AttributeProto.typeProtos: object expected");
              message.typeProtos[i] = $root.onnx.TypeProto.fromObject(object.typeProtos[i]);
            }
          }
          return message;
        };
        AttributeProto.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.arrays || options.defaults) {
            object.floats = [];
            object.ints = [];
            object.strings = [];
            object.tensors = [];
            object.graphs = [];
            object.typeProtos = [];
            object.sparseTensors = [];
          }
          if (options.defaults) {
            object.name = "";
            object.f = 0;
            if ($util.Long) {
              var long = new $util.Long(0, 0, false);
              object.i = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
              object.i = options.longs === String ? "0" : 0;
            if (options.bytes === String)
              object.s = "";
            else {
              object.s = [];
              if (options.bytes !== Array)
                object.s = $util.newBuffer(object.s);
            }
            object.t = null;
            object.g = null;
            object.docString = "";
            object.tp = null;
            object.type = options.enums === String ? "UNDEFINED" : 0;
            object.refAttrName = "";
            object.sparseTensor = null;
          }
          if (message.name != null && message.hasOwnProperty("name"))
            object.name = message.name;
          if (message.f != null && message.hasOwnProperty("f"))
            object.f = options.json && !isFinite(message.f) ? String(message.f) : message.f;
          if (message.i != null && message.hasOwnProperty("i"))
            if (typeof message.i === "number")
              object.i = options.longs === String ? String(message.i) : message.i;
            else
              object.i = options.longs === String ? $util.Long.prototype.toString.call(message.i) : options.longs === Number ? new $util.LongBits(message.i.low >>> 0, message.i.high >>> 0).toNumber() : message.i;
          if (message.s != null && message.hasOwnProperty("s"))
            object.s = options.bytes === String ? $util.base64.encode(message.s, 0, message.s.length) : options.bytes === Array ? Array.prototype.slice.call(message.s) : message.s;
          if (message.t != null && message.hasOwnProperty("t"))
            object.t = $root.onnx.TensorProto.toObject(message.t, options);
          if (message.g != null && message.hasOwnProperty("g"))
            object.g = $root.onnx.GraphProto.toObject(message.g, options);
          if (message.floats && message.floats.length) {
            object.floats = [];
            for (var j = 0; j < message.floats.length; ++j)
              object.floats[j] = options.json && !isFinite(message.floats[j]) ? String(message.floats[j]) : message.floats[j];
          }
          if (message.ints && message.ints.length) {
            object.ints = [];
            for (var j = 0; j < message.ints.length; ++j)
              if (typeof message.ints[j] === "number")
                object.ints[j] = options.longs === String ? String(message.ints[j]) : message.ints[j];
              else
                object.ints[j] = options.longs === String ? $util.Long.prototype.toString.call(message.ints[j]) : options.longs === Number ? new $util.LongBits(message.ints[j].low >>> 0, message.ints[j].high >>> 0).toNumber() : message.ints[j];
          }
          if (message.strings && message.strings.length) {
            object.strings = [];
            for (var j = 0; j < message.strings.length; ++j)
              object.strings[j] = options.bytes === String ? $util.base64.encode(message.strings[j], 0, message.strings[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.strings[j]) : message.strings[j];
          }
          if (message.tensors && message.tensors.length) {
            object.tensors = [];
            for (var j = 0; j < message.tensors.length; ++j)
              object.tensors[j] = $root.onnx.TensorProto.toObject(message.tensors[j], options);
          }
          if (message.graphs && message.graphs.length) {
            object.graphs = [];
            for (var j = 0; j < message.graphs.length; ++j)
              object.graphs[j] = $root.onnx.GraphProto.toObject(message.graphs[j], options);
          }
          if (message.docString != null && message.hasOwnProperty("docString"))
            object.docString = message.docString;
          if (message.tp != null && message.hasOwnProperty("tp"))
            object.tp = $root.onnx.TypeProto.toObject(message.tp, options);
          if (message.typeProtos && message.typeProtos.length) {
            object.typeProtos = [];
            for (var j = 0; j < message.typeProtos.length; ++j)
              object.typeProtos[j] = $root.onnx.TypeProto.toObject(message.typeProtos[j], options);
          }
          if (message.type != null && message.hasOwnProperty("type"))
            object.type = options.enums === String ? $root.onnx.AttributeProto.AttributeType[message.type] === void 0 ? message.type : $root.onnx.AttributeProto.AttributeType[message.type] : message.type;
          if (message.refAttrName != null && message.hasOwnProperty("refAttrName"))
            object.refAttrName = message.refAttrName;
          if (message.sparseTensor != null && message.hasOwnProperty("sparseTensor"))
            object.sparseTensor = $root.onnx.SparseTensorProto.toObject(message.sparseTensor, options);
          if (message.sparseTensors && message.sparseTensors.length) {
            object.sparseTensors = [];
            for (var j = 0; j < message.sparseTensors.length; ++j)
              object.sparseTensors[j] = $root.onnx.SparseTensorProto.toObject(message.sparseTensors[j], options);
          }
          return object;
        };
        AttributeProto.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        AttributeProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/onnx.AttributeProto";
        };
        AttributeProto.AttributeType = function() {
          var valuesById = {}, values = Object.create(valuesById);
          values[valuesById[0] = "UNDEFINED"] = 0;
          values[valuesById[1] = "FLOAT"] = 1;
          values[valuesById[2] = "INT"] = 2;
          values[valuesById[3] = "STRING"] = 3;
          values[valuesById[4] = "TENSOR"] = 4;
          values[valuesById[5] = "GRAPH"] = 5;
          values[valuesById[11] = "SPARSE_TENSOR"] = 11;
          values[valuesById[13] = "TYPE_PROTO"] = 13;
          values[valuesById[6] = "FLOATS"] = 6;
          values[valuesById[7] = "INTS"] = 7;
          values[valuesById[8] = "STRINGS"] = 8;
          values[valuesById[9] = "TENSORS"] = 9;
          values[valuesById[10] = "GRAPHS"] = 10;
          values[valuesById[12] = "SPARSE_TENSORS"] = 12;
          values[valuesById[14] = "TYPE_PROTOS"] = 14;
          return values;
        }();
        return AttributeProto;
      }();
      onnx6.ValueInfoProto = function() {
        function ValueInfoProto(properties) {
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        ValueInfoProto.prototype.name = "";
        ValueInfoProto.prototype.type = null;
        ValueInfoProto.prototype.docString = "";
        ValueInfoProto.create = function create(properties) {
          return new ValueInfoProto(properties);
        };
        ValueInfoProto.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.name != null && Object.hasOwnProperty.call(message, "name"))
            writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).string(message.name);
          if (message.type != null && Object.hasOwnProperty.call(message, "type"))
            $root.onnx.TypeProto.encode(message.type, writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).fork()).ldelim();
          if (message.docString != null && Object.hasOwnProperty.call(message, "docString"))
            writer.uint32(
              /* id 3, wireType 2 =*/
              26
            ).string(message.docString);
          return writer;
        };
        ValueInfoProto.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        ValueInfoProto.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.onnx.ValueInfoProto();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                message.name = reader.string();
                break;
              }
              case 2: {
                message.type = $root.onnx.TypeProto.decode(reader, reader.uint32());
                break;
              }
              case 3: {
                message.docString = reader.string();
                break;
              }
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        ValueInfoProto.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        ValueInfoProto.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.name != null && message.hasOwnProperty("name")) {
            if (!$util.isString(message.name))
              return "name: string expected";
          }
          if (message.type != null && message.hasOwnProperty("type")) {
            var error = $root.onnx.TypeProto.verify(message.type);
            if (error)
              return "type." + error;
          }
          if (message.docString != null && message.hasOwnProperty("docString")) {
            if (!$util.isString(message.docString))
              return "docString: string expected";
          }
          return null;
        };
        ValueInfoProto.fromObject = function fromObject(object) {
          if (object instanceof $root.onnx.ValueInfoProto)
            return object;
          var message = new $root.onnx.ValueInfoProto();
          if (object.name != null)
            message.name = String(object.name);
          if (object.type != null) {
            if (typeof object.type !== "object")
              throw TypeError(".onnx.ValueInfoProto.type: object expected");
            message.type = $root.onnx.TypeProto.fromObject(object.type);
          }
          if (object.docString != null)
            message.docString = String(object.docString);
          return message;
        };
        ValueInfoProto.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.defaults) {
            object.name = "";
            object.type = null;
            object.docString = "";
          }
          if (message.name != null && message.hasOwnProperty("name"))
            object.name = message.name;
          if (message.type != null && message.hasOwnProperty("type"))
            object.type = $root.onnx.TypeProto.toObject(message.type, options);
          if (message.docString != null && message.hasOwnProperty("docString"))
            object.docString = message.docString;
          return object;
        };
        ValueInfoProto.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        ValueInfoProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/onnx.ValueInfoProto";
        };
        return ValueInfoProto;
      }();
      onnx6.NodeProto = function() {
        function NodeProto(properties) {
          this.input = [];
          this.output = [];
          this.attribute = [];
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        NodeProto.prototype.input = $util.emptyArray;
        NodeProto.prototype.output = $util.emptyArray;
        NodeProto.prototype.name = "";
        NodeProto.prototype.opType = "";
        NodeProto.prototype.domain = "";
        NodeProto.prototype.attribute = $util.emptyArray;
        NodeProto.prototype.docString = "";
        NodeProto.create = function create(properties) {
          return new NodeProto(properties);
        };
        NodeProto.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.input != null && message.input.length)
            for (var i = 0; i < message.input.length; ++i)
              writer.uint32(
                /* id 1, wireType 2 =*/
                10
              ).string(message.input[i]);
          if (message.output != null && message.output.length)
            for (var i = 0; i < message.output.length; ++i)
              writer.uint32(
                /* id 2, wireType 2 =*/
                18
              ).string(message.output[i]);
          if (message.name != null && Object.hasOwnProperty.call(message, "name"))
            writer.uint32(
              /* id 3, wireType 2 =*/
              26
            ).string(message.name);
          if (message.opType != null && Object.hasOwnProperty.call(message, "opType"))
            writer.uint32(
              /* id 4, wireType 2 =*/
              34
            ).string(message.opType);
          if (message.attribute != null && message.attribute.length)
            for (var i = 0; i < message.attribute.length; ++i)
              $root.onnx.AttributeProto.encode(message.attribute[i], writer.uint32(
                /* id 5, wireType 2 =*/
                42
              ).fork()).ldelim();
          if (message.docString != null && Object.hasOwnProperty.call(message, "docString"))
            writer.uint32(
              /* id 6, wireType 2 =*/
              50
            ).string(message.docString);
          if (message.domain != null && Object.hasOwnProperty.call(message, "domain"))
            writer.uint32(
              /* id 7, wireType 2 =*/
              58
            ).string(message.domain);
          return writer;
        };
        NodeProto.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        NodeProto.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.onnx.NodeProto();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                if (!(message.input && message.input.length))
                  message.input = [];
                message.input.push(reader.string());
                break;
              }
              case 2: {
                if (!(message.output && message.output.length))
                  message.output = [];
                message.output.push(reader.string());
                break;
              }
              case 3: {
                message.name = reader.string();
                break;
              }
              case 4: {
                message.opType = reader.string();
                break;
              }
              case 7: {
                message.domain = reader.string();
                break;
              }
              case 5: {
                if (!(message.attribute && message.attribute.length))
                  message.attribute = [];
                message.attribute.push($root.onnx.AttributeProto.decode(reader, reader.uint32()));
                break;
              }
              case 6: {
                message.docString = reader.string();
                break;
              }
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        NodeProto.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        NodeProto.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.input != null && message.hasOwnProperty("input")) {
            if (!Array.isArray(message.input))
              return "input: array expected";
            for (var i = 0; i < message.input.length; ++i)
              if (!$util.isString(message.input[i]))
                return "input: string[] expected";
          }
          if (message.output != null && message.hasOwnProperty("output")) {
            if (!Array.isArray(message.output))
              return "output: array expected";
            for (var i = 0; i < message.output.length; ++i)
              if (!$util.isString(message.output[i]))
                return "output: string[] expected";
          }
          if (message.name != null && message.hasOwnProperty("name")) {
            if (!$util.isString(message.name))
              return "name: string expected";
          }
          if (message.opType != null && message.hasOwnProperty("opType")) {
            if (!$util.isString(message.opType))
              return "opType: string expected";
          }
          if (message.domain != null && message.hasOwnProperty("domain")) {
            if (!$util.isString(message.domain))
              return "domain: string expected";
          }
          if (message.attribute != null && message.hasOwnProperty("attribute")) {
            if (!Array.isArray(message.attribute))
              return "attribute: array expected";
            for (var i = 0; i < message.attribute.length; ++i) {
              var error = $root.onnx.AttributeProto.verify(message.attribute[i]);
              if (error)
                return "attribute." + error;
            }
          }
          if (message.docString != null && message.hasOwnProperty("docString")) {
            if (!$util.isString(message.docString))
              return "docString: string expected";
          }
          return null;
        };
        NodeProto.fromObject = function fromObject(object) {
          if (object instanceof $root.onnx.NodeProto)
            return object;
          var message = new $root.onnx.NodeProto();
          if (object.input) {
            if (!Array.isArray(object.input))
              throw TypeError(".onnx.NodeProto.input: array expected");
            message.input = [];
            for (var i = 0; i < object.input.length; ++i)
              message.input[i] = String(object.input[i]);
          }
          if (object.output) {
            if (!Array.isArray(object.output))
              throw TypeError(".onnx.NodeProto.output: array expected");
            message.output = [];
            for (var i = 0; i < object.output.length; ++i)
              message.output[i] = String(object.output[i]);
          }
          if (object.name != null)
            message.name = String(object.name);
          if (object.opType != null)
            message.opType = String(object.opType);
          if (object.domain != null)
            message.domain = String(object.domain);
          if (object.attribute) {
            if (!Array.isArray(object.attribute))
              throw TypeError(".onnx.NodeProto.attribute: array expected");
            message.attribute = [];
            for (var i = 0; i < object.attribute.length; ++i) {
              if (typeof object.attribute[i] !== "object")
                throw TypeError(".onnx.NodeProto.attribute: object expected");
              message.attribute[i] = $root.onnx.AttributeProto.fromObject(object.attribute[i]);
            }
          }
          if (object.docString != null)
            message.docString = String(object.docString);
          return message;
        };
        NodeProto.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.arrays || options.defaults) {
            object.input = [];
            object.output = [];
            object.attribute = [];
          }
          if (options.defaults) {
            object.name = "";
            object.opType = "";
            object.docString = "";
            object.domain = "";
          }
          if (message.input && message.input.length) {
            object.input = [];
            for (var j = 0; j < message.input.length; ++j)
              object.input[j] = message.input[j];
          }
          if (message.output && message.output.length) {
            object.output = [];
            for (var j = 0; j < message.output.length; ++j)
              object.output[j] = message.output[j];
          }
          if (message.name != null && message.hasOwnProperty("name"))
            object.name = message.name;
          if (message.opType != null && message.hasOwnProperty("opType"))
            object.opType = message.opType;
          if (message.attribute && message.attribute.length) {
            object.attribute = [];
            for (var j = 0; j < message.attribute.length; ++j)
              object.attribute[j] = $root.onnx.AttributeProto.toObject(message.attribute[j], options);
          }
          if (message.docString != null && message.hasOwnProperty("docString"))
            object.docString = message.docString;
          if (message.domain != null && message.hasOwnProperty("domain"))
            object.domain = message.domain;
          return object;
        };
        NodeProto.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        NodeProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/onnx.NodeProto";
        };
        return NodeProto;
      }();
      onnx6.TrainingInfoProto = function() {
        function TrainingInfoProto(properties) {
          this.initializationBinding = [];
          this.updateBinding = [];
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        TrainingInfoProto.prototype.initialization = null;
        TrainingInfoProto.prototype.algorithm = null;
        TrainingInfoProto.prototype.initializationBinding = $util.emptyArray;
        TrainingInfoProto.prototype.updateBinding = $util.emptyArray;
        TrainingInfoProto.create = function create(properties) {
          return new TrainingInfoProto(properties);
        };
        TrainingInfoProto.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.initialization != null && Object.hasOwnProperty.call(message, "initialization"))
            $root.onnx.GraphProto.encode(message.initialization, writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).fork()).ldelim();
          if (message.algorithm != null && Object.hasOwnProperty.call(message, "algorithm"))
            $root.onnx.GraphProto.encode(message.algorithm, writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).fork()).ldelim();
          if (message.initializationBinding != null && message.initializationBinding.length)
            for (var i = 0; i < message.initializationBinding.length; ++i)
              $root.onnx.StringStringEntryProto.encode(message.initializationBinding[i], writer.uint32(
                /* id 3, wireType 2 =*/
                26
              ).fork()).ldelim();
          if (message.updateBinding != null && message.updateBinding.length)
            for (var i = 0; i < message.updateBinding.length; ++i)
              $root.onnx.StringStringEntryProto.encode(message.updateBinding[i], writer.uint32(
                /* id 4, wireType 2 =*/
                34
              ).fork()).ldelim();
          return writer;
        };
        TrainingInfoProto.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        TrainingInfoProto.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.onnx.TrainingInfoProto();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                message.initialization = $root.onnx.GraphProto.decode(reader, reader.uint32());
                break;
              }
              case 2: {
                message.algorithm = $root.onnx.GraphProto.decode(reader, reader.uint32());
                break;
              }
              case 3: {
                if (!(message.initializationBinding && message.initializationBinding.length))
                  message.initializationBinding = [];
                message.initializationBinding.push($root.onnx.StringStringEntryProto.decode(reader, reader.uint32()));
                break;
              }
              case 4: {
                if (!(message.updateBinding && message.updateBinding.length))
                  message.updateBinding = [];
                message.updateBinding.push($root.onnx.StringStringEntryProto.decode(reader, reader.uint32()));
                break;
              }
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        TrainingInfoProto.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        TrainingInfoProto.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.initialization != null && message.hasOwnProperty("initialization")) {
            var error = $root.onnx.GraphProto.verify(message.initialization);
            if (error)
              return "initialization." + error;
          }
          if (message.algorithm != null && message.hasOwnProperty("algorithm")) {
            var error = $root.onnx.GraphProto.verify(message.algorithm);
            if (error)
              return "algorithm." + error;
          }
          if (message.initializationBinding != null && message.hasOwnProperty("initializationBinding")) {
            if (!Array.isArray(message.initializationBinding))
              return "initializationBinding: array expected";
            for (var i = 0; i < message.initializationBinding.length; ++i) {
              var error = $root.onnx.StringStringEntryProto.verify(message.initializationBinding[i]);
              if (error)
                return "initializationBinding." + error;
            }
          }
          if (message.updateBinding != null && message.hasOwnProperty("updateBinding")) {
            if (!Array.isArray(message.updateBinding))
              return "updateBinding: array expected";
            for (var i = 0; i < message.updateBinding.length; ++i) {
              var error = $root.onnx.StringStringEntryProto.verify(message.updateBinding[i]);
              if (error)
                return "updateBinding." + error;
            }
          }
          return null;
        };
        TrainingInfoProto.fromObject = function fromObject(object) {
          if (object instanceof $root.onnx.TrainingInfoProto)
            return object;
          var message = new $root.onnx.TrainingInfoProto();
          if (object.initialization != null) {
            if (typeof object.initialization !== "object")
              throw TypeError(".onnx.TrainingInfoProto.initialization: object expected");
            message.initialization = $root.onnx.GraphProto.fromObject(object.initialization);
          }
          if (object.algorithm != null) {
            if (typeof object.algorithm !== "object")
              throw TypeError(".onnx.TrainingInfoProto.algorithm: object expected");
            message.algorithm = $root.onnx.GraphProto.fromObject(object.algorithm);
          }
          if (object.initializationBinding) {
            if (!Array.isArray(object.initializationBinding))
              throw TypeError(".onnx.TrainingInfoProto.initializationBinding: array expected");
            message.initializationBinding = [];
            for (var i = 0; i < object.initializationBinding.length; ++i) {
              if (typeof object.initializationBinding[i] !== "object")
                throw TypeError(".onnx.TrainingInfoProto.initializationBinding: object expected");
              message.initializationBinding[i] = $root.onnx.StringStringEntryProto.fromObject(object.initializationBinding[i]);
            }
          }
          if (object.updateBinding) {
            if (!Array.isArray(object.updateBinding))
              throw TypeError(".onnx.TrainingInfoProto.updateBinding: array expected");
            message.updateBinding = [];
            for (var i = 0; i < object.updateBinding.length; ++i) {
              if (typeof object.updateBinding[i] !== "object")
                throw TypeError(".onnx.TrainingInfoProto.updateBinding: object expected");
              message.updateBinding[i] = $root.onnx.StringStringEntryProto.fromObject(object.updateBinding[i]);
            }
          }
          return message;
        };
        TrainingInfoProto.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.arrays || options.defaults) {
            object.initializationBinding = [];
            object.updateBinding = [];
          }
          if (options.defaults) {
            object.initialization = null;
            object.algorithm = null;
          }
          if (message.initialization != null && message.hasOwnProperty("initialization"))
            object.initialization = $root.onnx.GraphProto.toObject(message.initialization, options);
          if (message.algorithm != null && message.hasOwnProperty("algorithm"))
            object.algorithm = $root.onnx.GraphProto.toObject(message.algorithm, options);
          if (message.initializationBinding && message.initializationBinding.length) {
            object.initializationBinding = [];
            for (var j = 0; j < message.initializationBinding.length; ++j)
              object.initializationBinding[j] = $root.onnx.StringStringEntryProto.toObject(message.initializationBinding[j], options);
          }
          if (message.updateBinding && message.updateBinding.length) {
            object.updateBinding = [];
            for (var j = 0; j < message.updateBinding.length; ++j)
              object.updateBinding[j] = $root.onnx.StringStringEntryProto.toObject(message.updateBinding[j], options);
          }
          return object;
        };
        TrainingInfoProto.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        TrainingInfoProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/onnx.TrainingInfoProto";
        };
        return TrainingInfoProto;
      }();
      onnx6.ModelProto = function() {
        function ModelProto(properties) {
          this.opsetImport = [];
          this.metadataProps = [];
          this.trainingInfo = [];
          this.functions = [];
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        ModelProto.prototype.irVersion = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        ModelProto.prototype.opsetImport = $util.emptyArray;
        ModelProto.prototype.producerName = "";
        ModelProto.prototype.producerVersion = "";
        ModelProto.prototype.domain = "";
        ModelProto.prototype.modelVersion = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        ModelProto.prototype.docString = "";
        ModelProto.prototype.graph = null;
        ModelProto.prototype.metadataProps = $util.emptyArray;
        ModelProto.prototype.trainingInfo = $util.emptyArray;
        ModelProto.prototype.functions = $util.emptyArray;
        ModelProto.create = function create(properties) {
          return new ModelProto(properties);
        };
        ModelProto.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.irVersion != null && Object.hasOwnProperty.call(message, "irVersion"))
            writer.uint32(
              /* id 1, wireType 0 =*/
              8
            ).int64(message.irVersion);
          if (message.producerName != null && Object.hasOwnProperty.call(message, "producerName"))
            writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).string(message.producerName);
          if (message.producerVersion != null && Object.hasOwnProperty.call(message, "producerVersion"))
            writer.uint32(
              /* id 3, wireType 2 =*/
              26
            ).string(message.producerVersion);
          if (message.domain != null && Object.hasOwnProperty.call(message, "domain"))
            writer.uint32(
              /* id 4, wireType 2 =*/
              34
            ).string(message.domain);
          if (message.modelVersion != null && Object.hasOwnProperty.call(message, "modelVersion"))
            writer.uint32(
              /* id 5, wireType 0 =*/
              40
            ).int64(message.modelVersion);
          if (message.docString != null && Object.hasOwnProperty.call(message, "docString"))
            writer.uint32(
              /* id 6, wireType 2 =*/
              50
            ).string(message.docString);
          if (message.graph != null && Object.hasOwnProperty.call(message, "graph"))
            $root.onnx.GraphProto.encode(message.graph, writer.uint32(
              /* id 7, wireType 2 =*/
              58
            ).fork()).ldelim();
          if (message.opsetImport != null && message.opsetImport.length)
            for (var i = 0; i < message.opsetImport.length; ++i)
              $root.onnx.OperatorSetIdProto.encode(message.opsetImport[i], writer.uint32(
                /* id 8, wireType 2 =*/
                66
              ).fork()).ldelim();
          if (message.metadataProps != null && message.metadataProps.length)
            for (var i = 0; i < message.metadataProps.length; ++i)
              $root.onnx.StringStringEntryProto.encode(message.metadataProps[i], writer.uint32(
                /* id 14, wireType 2 =*/
                114
              ).fork()).ldelim();
          if (message.trainingInfo != null && message.trainingInfo.length)
            for (var i = 0; i < message.trainingInfo.length; ++i)
              $root.onnx.TrainingInfoProto.encode(message.trainingInfo[i], writer.uint32(
                /* id 20, wireType 2 =*/
                162
              ).fork()).ldelim();
          if (message.functions != null && message.functions.length)
            for (var i = 0; i < message.functions.length; ++i)
              $root.onnx.FunctionProto.encode(message.functions[i], writer.uint32(
                /* id 25, wireType 2 =*/
                202
              ).fork()).ldelim();
          return writer;
        };
        ModelProto.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        ModelProto.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.onnx.ModelProto();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                message.irVersion = reader.int64();
                break;
              }
              case 8: {
                if (!(message.opsetImport && message.opsetImport.length))
                  message.opsetImport = [];
                message.opsetImport.push($root.onnx.OperatorSetIdProto.decode(reader, reader.uint32()));
                break;
              }
              case 2: {
                message.producerName = reader.string();
                break;
              }
              case 3: {
                message.producerVersion = reader.string();
                break;
              }
              case 4: {
                message.domain = reader.string();
                break;
              }
              case 5: {
                message.modelVersion = reader.int64();
                break;
              }
              case 6: {
                message.docString = reader.string();
                break;
              }
              case 7: {
                message.graph = $root.onnx.GraphProto.decode(reader, reader.uint32());
                break;
              }
              case 14: {
                if (!(message.metadataProps && message.metadataProps.length))
                  message.metadataProps = [];
                message.metadataProps.push($root.onnx.StringStringEntryProto.decode(reader, reader.uint32()));
                break;
              }
              case 20: {
                if (!(message.trainingInfo && message.trainingInfo.length))
                  message.trainingInfo = [];
                message.trainingInfo.push($root.onnx.TrainingInfoProto.decode(reader, reader.uint32()));
                break;
              }
              case 25: {
                if (!(message.functions && message.functions.length))
                  message.functions = [];
                message.functions.push($root.onnx.FunctionProto.decode(reader, reader.uint32()));
                break;
              }
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        ModelProto.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        ModelProto.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.irVersion != null && message.hasOwnProperty("irVersion")) {
            if (!$util.isInteger(message.irVersion) && !(message.irVersion && $util.isInteger(message.irVersion.low) && $util.isInteger(message.irVersion.high)))
              return "irVersion: integer|Long expected";
          }
          if (message.opsetImport != null && message.hasOwnProperty("opsetImport")) {
            if (!Array.isArray(message.opsetImport))
              return "opsetImport: array expected";
            for (var i = 0; i < message.opsetImport.length; ++i) {
              var error = $root.onnx.OperatorSetIdProto.verify(message.opsetImport[i]);
              if (error)
                return "opsetImport." + error;
            }
          }
          if (message.producerName != null && message.hasOwnProperty("producerName")) {
            if (!$util.isString(message.producerName))
              return "producerName: string expected";
          }
          if (message.producerVersion != null && message.hasOwnProperty("producerVersion")) {
            if (!$util.isString(message.producerVersion))
              return "producerVersion: string expected";
          }
          if (message.domain != null && message.hasOwnProperty("domain")) {
            if (!$util.isString(message.domain))
              return "domain: string expected";
          }
          if (message.modelVersion != null && message.hasOwnProperty("modelVersion")) {
            if (!$util.isInteger(message.modelVersion) && !(message.modelVersion && $util.isInteger(message.modelVersion.low) && $util.isInteger(message.modelVersion.high)))
              return "modelVersion: integer|Long expected";
          }
          if (message.docString != null && message.hasOwnProperty("docString")) {
            if (!$util.isString(message.docString))
              return "docString: string expected";
          }
          if (message.graph != null && message.hasOwnProperty("graph")) {
            var error = $root.onnx.GraphProto.verify(message.graph);
            if (error)
              return "graph." + error;
          }
          if (message.metadataProps != null && message.hasOwnProperty("metadataProps")) {
            if (!Array.isArray(message.metadataProps))
              return "metadataProps: array expected";
            for (var i = 0; i < message.metadataProps.length; ++i) {
              var error = $root.onnx.StringStringEntryProto.verify(message.metadataProps[i]);
              if (error)
                return "metadataProps." + error;
            }
          }
          if (message.trainingInfo != null && message.hasOwnProperty("trainingInfo")) {
            if (!Array.isArray(message.trainingInfo))
              return "trainingInfo: array expected";
            for (var i = 0; i < message.trainingInfo.length; ++i) {
              var error = $root.onnx.TrainingInfoProto.verify(message.trainingInfo[i]);
              if (error)
                return "trainingInfo." + error;
            }
          }
          if (message.functions != null && message.hasOwnProperty("functions")) {
            if (!Array.isArray(message.functions))
              return "functions: array expected";
            for (var i = 0; i < message.functions.length; ++i) {
              var error = $root.onnx.FunctionProto.verify(message.functions[i]);
              if (error)
                return "functions." + error;
            }
          }
          return null;
        };
        ModelProto.fromObject = function fromObject(object) {
          if (object instanceof $root.onnx.ModelProto)
            return object;
          var message = new $root.onnx.ModelProto();
          if (object.irVersion != null) {
            if ($util.Long)
              (message.irVersion = $util.Long.fromValue(object.irVersion)).unsigned = false;
            else if (typeof object.irVersion === "string")
              message.irVersion = parseInt(object.irVersion, 10);
            else if (typeof object.irVersion === "number")
              message.irVersion = object.irVersion;
            else if (typeof object.irVersion === "object")
              message.irVersion = new $util.LongBits(object.irVersion.low >>> 0, object.irVersion.high >>> 0).toNumber();
          }
          if (object.opsetImport) {
            if (!Array.isArray(object.opsetImport))
              throw TypeError(".onnx.ModelProto.opsetImport: array expected");
            message.opsetImport = [];
            for (var i = 0; i < object.opsetImport.length; ++i) {
              if (typeof object.opsetImport[i] !== "object")
                throw TypeError(".onnx.ModelProto.opsetImport: object expected");
              message.opsetImport[i] = $root.onnx.OperatorSetIdProto.fromObject(object.opsetImport[i]);
            }
          }
          if (object.producerName != null)
            message.producerName = String(object.producerName);
          if (object.producerVersion != null)
            message.producerVersion = String(object.producerVersion);
          if (object.domain != null)
            message.domain = String(object.domain);
          if (object.modelVersion != null) {
            if ($util.Long)
              (message.modelVersion = $util.Long.fromValue(object.modelVersion)).unsigned = false;
            else if (typeof object.modelVersion === "string")
              message.modelVersion = parseInt(object.modelVersion, 10);
            else if (typeof object.modelVersion === "number")
              message.modelVersion = object.modelVersion;
            else if (typeof object.modelVersion === "object")
              message.modelVersion = new $util.LongBits(object.modelVersion.low >>> 0, object.modelVersion.high >>> 0).toNumber();
          }
          if (object.docString != null)
            message.docString = String(object.docString);
          if (object.graph != null) {
            if (typeof object.graph !== "object")
              throw TypeError(".onnx.ModelProto.graph: object expected");
            message.graph = $root.onnx.GraphProto.fromObject(object.graph);
          }
          if (object.metadataProps) {
            if (!Array.isArray(object.metadataProps))
              throw TypeError(".onnx.ModelProto.metadataProps: array expected");
            message.metadataProps = [];
            for (var i = 0; i < object.metadataProps.length; ++i) {
              if (typeof object.metadataProps[i] !== "object")
                throw TypeError(".onnx.ModelProto.metadataProps: object expected");
              message.metadataProps[i] = $root.onnx.StringStringEntryProto.fromObject(object.metadataProps[i]);
            }
          }
          if (object.trainingInfo) {
            if (!Array.isArray(object.trainingInfo))
              throw TypeError(".onnx.ModelProto.trainingInfo: array expected");
            message.trainingInfo = [];
            for (var i = 0; i < object.trainingInfo.length; ++i) {
              if (typeof object.trainingInfo[i] !== "object")
                throw TypeError(".onnx.ModelProto.trainingInfo: object expected");
              message.trainingInfo[i] = $root.onnx.TrainingInfoProto.fromObject(object.trainingInfo[i]);
            }
          }
          if (object.functions) {
            if (!Array.isArray(object.functions))
              throw TypeError(".onnx.ModelProto.functions: array expected");
            message.functions = [];
            for (var i = 0; i < object.functions.length; ++i) {
              if (typeof object.functions[i] !== "object")
                throw TypeError(".onnx.ModelProto.functions: object expected");
              message.functions[i] = $root.onnx.FunctionProto.fromObject(object.functions[i]);
            }
          }
          return message;
        };
        ModelProto.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.arrays || options.defaults) {
            object.opsetImport = [];
            object.metadataProps = [];
            object.trainingInfo = [];
            object.functions = [];
          }
          if (options.defaults) {
            if ($util.Long) {
              var long = new $util.Long(0, 0, false);
              object.irVersion = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
              object.irVersion = options.longs === String ? "0" : 0;
            object.producerName = "";
            object.producerVersion = "";
            object.domain = "";
            if ($util.Long) {
              var long = new $util.Long(0, 0, false);
              object.modelVersion = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
              object.modelVersion = options.longs === String ? "0" : 0;
            object.docString = "";
            object.graph = null;
          }
          if (message.irVersion != null && message.hasOwnProperty("irVersion"))
            if (typeof message.irVersion === "number")
              object.irVersion = options.longs === String ? String(message.irVersion) : message.irVersion;
            else
              object.irVersion = options.longs === String ? $util.Long.prototype.toString.call(message.irVersion) : options.longs === Number ? new $util.LongBits(message.irVersion.low >>> 0, message.irVersion.high >>> 0).toNumber() : message.irVersion;
          if (message.producerName != null && message.hasOwnProperty("producerName"))
            object.producerName = message.producerName;
          if (message.producerVersion != null && message.hasOwnProperty("producerVersion"))
            object.producerVersion = message.producerVersion;
          if (message.domain != null && message.hasOwnProperty("domain"))
            object.domain = message.domain;
          if (message.modelVersion != null && message.hasOwnProperty("modelVersion"))
            if (typeof message.modelVersion === "number")
              object.modelVersion = options.longs === String ? String(message.modelVersion) : message.modelVersion;
            else
              object.modelVersion = options.longs === String ? $util.Long.prototype.toString.call(message.modelVersion) : options.longs === Number ? new $util.LongBits(message.modelVersion.low >>> 0, message.modelVersion.high >>> 0).toNumber() : message.modelVersion;
          if (message.docString != null && message.hasOwnProperty("docString"))
            object.docString = message.docString;
          if (message.graph != null && message.hasOwnProperty("graph"))
            object.graph = $root.onnx.GraphProto.toObject(message.graph, options);
          if (message.opsetImport && message.opsetImport.length) {
            object.opsetImport = [];
            for (var j = 0; j < message.opsetImport.length; ++j)
              object.opsetImport[j] = $root.onnx.OperatorSetIdProto.toObject(message.opsetImport[j], options);
          }
          if (message.metadataProps && message.metadataProps.length) {
            object.metadataProps = [];
            for (var j = 0; j < message.metadataProps.length; ++j)
              object.metadataProps[j] = $root.onnx.StringStringEntryProto.toObject(message.metadataProps[j], options);
          }
          if (message.trainingInfo && message.trainingInfo.length) {
            object.trainingInfo = [];
            for (var j = 0; j < message.trainingInfo.length; ++j)
              object.trainingInfo[j] = $root.onnx.TrainingInfoProto.toObject(message.trainingInfo[j], options);
          }
          if (message.functions && message.functions.length) {
            object.functions = [];
            for (var j = 0; j < message.functions.length; ++j)
              object.functions[j] = $root.onnx.FunctionProto.toObject(message.functions[j], options);
          }
          return object;
        };
        ModelProto.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        ModelProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/onnx.ModelProto";
        };
        return ModelProto;
      }();
      onnx6.StringStringEntryProto = function() {
        function StringStringEntryProto(properties) {
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        StringStringEntryProto.prototype.key = "";
        StringStringEntryProto.prototype.value = "";
        StringStringEntryProto.create = function create(properties) {
          return new StringStringEntryProto(properties);
        };
        StringStringEntryProto.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.key != null && Object.hasOwnProperty.call(message, "key"))
            writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).string(message.key);
          if (message.value != null && Object.hasOwnProperty.call(message, "value"))
            writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).string(message.value);
          return writer;
        };
        StringStringEntryProto.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        StringStringEntryProto.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.onnx.StringStringEntryProto();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                message.key = reader.string();
                break;
              }
              case 2: {
                message.value = reader.string();
                break;
              }
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        StringStringEntryProto.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        StringStringEntryProto.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.key != null && message.hasOwnProperty("key")) {
            if (!$util.isString(message.key))
              return "key: string expected";
          }
          if (message.value != null && message.hasOwnProperty("value")) {
            if (!$util.isString(message.value))
              return "value: string expected";
          }
          return null;
        };
        StringStringEntryProto.fromObject = function fromObject(object) {
          if (object instanceof $root.onnx.StringStringEntryProto)
            return object;
          var message = new $root.onnx.StringStringEntryProto();
          if (object.key != null)
            message.key = String(object.key);
          if (object.value != null)
            message.value = String(object.value);
          return message;
        };
        StringStringEntryProto.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.defaults) {
            object.key = "";
            object.value = "";
          }
          if (message.key != null && message.hasOwnProperty("key"))
            object.key = message.key;
          if (message.value != null && message.hasOwnProperty("value"))
            object.value = message.value;
          return object;
        };
        StringStringEntryProto.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        StringStringEntryProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/onnx.StringStringEntryProto";
        };
        return StringStringEntryProto;
      }();
      onnx6.TensorAnnotation = function() {
        function TensorAnnotation(properties) {
          this.quantParameterTensorNames = [];
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        TensorAnnotation.prototype.tensorName = "";
        TensorAnnotation.prototype.quantParameterTensorNames = $util.emptyArray;
        TensorAnnotation.create = function create(properties) {
          return new TensorAnnotation(properties);
        };
        TensorAnnotation.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.tensorName != null && Object.hasOwnProperty.call(message, "tensorName"))
            writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).string(message.tensorName);
          if (message.quantParameterTensorNames != null && message.quantParameterTensorNames.length)
            for (var i = 0; i < message.quantParameterTensorNames.length; ++i)
              $root.onnx.StringStringEntryProto.encode(message.quantParameterTensorNames[i], writer.uint32(
                /* id 2, wireType 2 =*/
                18
              ).fork()).ldelim();
          return writer;
        };
        TensorAnnotation.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        TensorAnnotation.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.onnx.TensorAnnotation();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                message.tensorName = reader.string();
                break;
              }
              case 2: {
                if (!(message.quantParameterTensorNames && message.quantParameterTensorNames.length))
                  message.quantParameterTensorNames = [];
                message.quantParameterTensorNames.push($root.onnx.StringStringEntryProto.decode(reader, reader.uint32()));
                break;
              }
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        TensorAnnotation.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        TensorAnnotation.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.tensorName != null && message.hasOwnProperty("tensorName")) {
            if (!$util.isString(message.tensorName))
              return "tensorName: string expected";
          }
          if (message.quantParameterTensorNames != null && message.hasOwnProperty("quantParameterTensorNames")) {
            if (!Array.isArray(message.quantParameterTensorNames))
              return "quantParameterTensorNames: array expected";
            for (var i = 0; i < message.quantParameterTensorNames.length; ++i) {
              var error = $root.onnx.StringStringEntryProto.verify(message.quantParameterTensorNames[i]);
              if (error)
                return "quantParameterTensorNames." + error;
            }
          }
          return null;
        };
        TensorAnnotation.fromObject = function fromObject(object) {
          if (object instanceof $root.onnx.TensorAnnotation)
            return object;
          var message = new $root.onnx.TensorAnnotation();
          if (object.tensorName != null)
            message.tensorName = String(object.tensorName);
          if (object.quantParameterTensorNames) {
            if (!Array.isArray(object.quantParameterTensorNames))
              throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: array expected");
            message.quantParameterTensorNames = [];
            for (var i = 0; i < object.quantParameterTensorNames.length; ++i) {
              if (typeof object.quantParameterTensorNames[i] !== "object")
                throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: object expected");
              message.quantParameterTensorNames[i] = $root.onnx.StringStringEntryProto.fromObject(object.quantParameterTensorNames[i]);
            }
          }
          return message;
        };
        TensorAnnotation.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.arrays || options.defaults)
            object.quantParameterTensorNames = [];
          if (options.defaults)
            object.tensorName = "";
          if (message.tensorName != null && message.hasOwnProperty("tensorName"))
            object.tensorName = message.tensorName;
          if (message.quantParameterTensorNames && message.quantParameterTensorNames.length) {
            object.quantParameterTensorNames = [];
            for (var j = 0; j < message.quantParameterTensorNames.length; ++j)
              object.quantParameterTensorNames[j] = $root.onnx.StringStringEntryProto.toObject(message.quantParameterTensorNames[j], options);
          }
          return object;
        };
        TensorAnnotation.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        TensorAnnotation.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/onnx.TensorAnnotation";
        };
        return TensorAnnotation;
      }();
      onnx6.GraphProto = function() {
        function GraphProto(properties) {
          this.node = [];
          this.initializer = [];
          this.sparseInitializer = [];
          this.input = [];
          this.output = [];
          this.valueInfo = [];
          this.quantizationAnnotation = [];
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        GraphProto.prototype.node = $util.emptyArray;
        GraphProto.prototype.name = "";
        GraphProto.prototype.initializer = $util.emptyArray;
        GraphProto.prototype.sparseInitializer = $util.emptyArray;
        GraphProto.prototype.docString = "";
        GraphProto.prototype.input = $util.emptyArray;
        GraphProto.prototype.output = $util.emptyArray;
        GraphProto.prototype.valueInfo = $util.emptyArray;
        GraphProto.prototype.quantizationAnnotation = $util.emptyArray;
        GraphProto.create = function create(properties) {
          return new GraphProto(properties);
        };
        GraphProto.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.node != null && message.node.length)
            for (var i = 0; i < message.node.length; ++i)
              $root.onnx.NodeProto.encode(message.node[i], writer.uint32(
                /* id 1, wireType 2 =*/
                10
              ).fork()).ldelim();
          if (message.name != null && Object.hasOwnProperty.call(message, "name"))
            writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).string(message.name);
          if (message.initializer != null && message.initializer.length)
            for (var i = 0; i < message.initializer.length; ++i)
              $root.onnx.TensorProto.encode(message.initializer[i], writer.uint32(
                /* id 5, wireType 2 =*/
                42
              ).fork()).ldelim();
          if (message.docString != null && Object.hasOwnProperty.call(message, "docString"))
            writer.uint32(
              /* id 10, wireType 2 =*/
              82
            ).string(message.docString);
          if (message.input != null && message.input.length)
            for (var i = 0; i < message.input.length; ++i)
              $root.onnx.ValueInfoProto.encode(message.input[i], writer.uint32(
                /* id 11, wireType 2 =*/
                90
              ).fork()).ldelim();
          if (message.output != null && message.output.length)
            for (var i = 0; i < message.output.length; ++i)
              $root.onnx.ValueInfoProto.encode(message.output[i], writer.uint32(
                /* id 12, wireType 2 =*/
                98
              ).fork()).ldelim();
          if (message.valueInfo != null && message.valueInfo.length)
            for (var i = 0; i < message.valueInfo.length; ++i)
              $root.onnx.ValueInfoProto.encode(message.valueInfo[i], writer.uint32(
                /* id 13, wireType 2 =*/
                106
              ).fork()).ldelim();
          if (message.quantizationAnnotation != null && message.quantizationAnnotation.length)
            for (var i = 0; i < message.quantizationAnnotation.length; ++i)
              $root.onnx.TensorAnnotation.encode(message.quantizationAnnotation[i], writer.uint32(
                /* id 14, wireType 2 =*/
                114
              ).fork()).ldelim();
          if (message.sparseInitializer != null && message.sparseInitializer.length)
            for (var i = 0; i < message.sparseInitializer.length; ++i)
              $root.onnx.SparseTensorProto.encode(message.sparseInitializer[i], writer.uint32(
                /* id 15, wireType 2 =*/
                122
              ).fork()).ldelim();
          return writer;
        };
        GraphProto.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        GraphProto.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.onnx.GraphProto();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                if (!(message.node && message.node.length))
                  message.node = [];
                message.node.push($root.onnx.NodeProto.decode(reader, reader.uint32()));
                break;
              }
              case 2: {
                message.name = reader.string();
                break;
              }
              case 5: {
                if (!(message.initializer && message.initializer.length))
                  message.initializer = [];
                message.initializer.push($root.onnx.TensorProto.decode(reader, reader.uint32()));
                break;
              }
              case 15: {
                if (!(message.sparseInitializer && message.sparseInitializer.length))
                  message.sparseInitializer = [];
                message.sparseInitializer.push($root.onnx.SparseTensorProto.decode(reader, reader.uint32()));
                break;
              }
              case 10: {
                message.docString = reader.string();
                break;
              }
              case 11: {
                if (!(message.input && message.input.length))
                  message.input = [];
                message.input.push($root.onnx.ValueInfoProto.decode(reader, reader.uint32()));
                break;
              }
              case 12: {
                if (!(message.output && message.output.length))
                  message.output = [];
                message.output.push($root.onnx.ValueInfoProto.decode(reader, reader.uint32()));
                break;
              }
              case 13: {
                if (!(message.valueInfo && message.valueInfo.length))
                  message.valueInfo = [];
                message.valueInfo.push($root.onnx.ValueInfoProto.decode(reader, reader.uint32()));
                break;
              }
              case 14: {
                if (!(message.quantizationAnnotation && message.quantizationAnnotation.length))
                  message.quantizationAnnotation = [];
                message.quantizationAnnotation.push($root.onnx.TensorAnnotation.decode(reader, reader.uint32()));
                break;
              }
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        GraphProto.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        GraphProto.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.node != null && message.hasOwnProperty("node")) {
            if (!Array.isArray(message.node))
              return "node: array expected";
            for (var i = 0; i < message.node.length; ++i) {
              var error = $root.onnx.NodeProto.verify(message.node[i]);
              if (error)
                return "node." + error;
            }
          }
          if (message.name != null && message.hasOwnProperty("name")) {
            if (!$util.isString(message.name))
              return "name: string expected";
          }
          if (message.initializer != null && message.hasOwnProperty("initializer")) {
            if (!Array.isArray(message.initializer))
              return "initializer: array expected";
            for (var i = 0; i < message.initializer.length; ++i) {
              var error = $root.onnx.TensorProto.verify(message.initializer[i]);
              if (error)
                return "initializer." + error;
            }
          }
          if (message.sparseInitializer != null && message.hasOwnProperty("sparseInitializer")) {
            if (!Array.isArray(message.sparseInitializer))
              return "sparseInitializer: array expected";
            for (var i = 0; i < message.sparseInitializer.length; ++i) {
              var error = $root.onnx.SparseTensorProto.verify(message.sparseInitializer[i]);
              if (error)
                return "sparseInitializer." + error;
            }
          }
          if (message.docString != null && message.hasOwnProperty("docString")) {
            if (!$util.isString(message.docString))
              return "docString: string expected";
          }
          if (message.input != null && message.hasOwnProperty("input")) {
            if (!Array.isArray(message.input))
              return "input: array expected";
            for (var i = 0; i < message.input.length; ++i) {
              var error = $root.onnx.ValueInfoProto.verify(message.input[i]);
              if (error)
                return "input." + error;
            }
          }
          if (message.output != null && message.hasOwnProperty("output")) {
            if (!Array.isArray(message.output))
              return "output: array expected";
            for (var i = 0; i < message.output.length; ++i) {
              var error = $root.onnx.ValueInfoProto.verify(message.output[i]);
              if (error)
                return "output." + error;
            }
          }
          if (message.valueInfo != null && message.hasOwnProperty("valueInfo")) {
            if (!Array.isArray(message.valueInfo))
              return "valueInfo: array expected";
            for (var i = 0; i < message.valueInfo.length; ++i) {
              var error = $root.onnx.ValueInfoProto.verify(message.valueInfo[i]);
              if (error)
                return "valueInfo." + error;
            }
          }
          if (message.quantizationAnnotation != null && message.hasOwnProperty("quantizationAnnotation")) {
            if (!Array.isArray(message.quantizationAnnotation))
              return "quantizationAnnotation: array expected";
            for (var i = 0; i < message.quantizationAnnotation.length; ++i) {
              var error = $root.onnx.TensorAnnotation.verify(message.quantizationAnnotation[i]);
              if (error)
                return "quantizationAnnotation." + error;
            }
          }
          return null;
        };
        GraphProto.fromObject = function fromObject(object) {
          if (object instanceof $root.onnx.GraphProto)
            return object;
          var message = new $root.onnx.GraphProto();
          if (object.node) {
            if (!Array.isArray(object.node))
              throw TypeError(".onnx.GraphProto.node: array expected");
            message.node = [];
            for (var i = 0; i < object.node.length; ++i) {
              if (typeof object.node[i] !== "object")
                throw TypeError(".onnx.GraphProto.node: object expected");
              message.node[i] = $root.onnx.NodeProto.fromObject(object.node[i]);
            }
          }
          if (object.name != null)
            message.name = String(object.name);
          if (object.initializer) {
            if (!Array.isArray(object.initializer))
              throw TypeError(".onnx.GraphProto.initializer: array expected");
            message.initializer = [];
            for (var i = 0; i < object.initializer.length; ++i) {
              if (typeof object.initializer[i] !== "object")
                throw TypeError(".onnx.GraphProto.initializer: object expected");
              message.initializer[i] = $root.onnx.TensorProto.fromObject(object.initializer[i]);
            }
          }
          if (object.sparseInitializer) {
            if (!Array.isArray(object.sparseInitializer))
              throw TypeError(".onnx.GraphProto.sparseInitializer: array expected");
            message.sparseInitializer = [];
            for (var i = 0; i < object.sparseInitializer.length; ++i) {
              if (typeof object.sparseInitializer[i] !== "object")
                throw TypeError(".onnx.GraphProto.sparseInitializer: object expected");
              message.sparseInitializer[i] = $root.onnx.SparseTensorProto.fromObject(object.sparseInitializer[i]);
            }
          }
          if (object.docString != null)
            message.docString = String(object.docString);
          if (object.input) {
            if (!Array.isArray(object.input))
              throw TypeError(".onnx.GraphProto.input: array expected");
            message.input = [];
            for (var i = 0; i < object.input.length; ++i) {
              if (typeof object.input[i] !== "object")
                throw TypeError(".onnx.GraphProto.input: object expected");
              message.input[i] = $root.onnx.ValueInfoProto.fromObject(object.input[i]);
            }
          }
          if (object.output) {
            if (!Array.isArray(object.output))
              throw TypeError(".onnx.GraphProto.output: array expected");
            message.output = [];
            for (var i = 0; i < object.output.length; ++i) {
              if (typeof object.output[i] !== "object")
                throw TypeError(".onnx.GraphProto.output: object expected");
              message.output[i] = $root.onnx.ValueInfoProto.fromObject(object.output[i]);
            }
          }
          if (object.valueInfo) {
            if (!Array.isArray(object.valueInfo))
              throw TypeError(".onnx.GraphProto.valueInfo: array expected");
            message.valueInfo = [];
            for (var i = 0; i < object.valueInfo.length; ++i) {
              if (typeof object.valueInfo[i] !== "object")
                throw TypeError(".onnx.GraphProto.valueInfo: object expected");
              message.valueInfo[i] = $root.onnx.ValueInfoProto.fromObject(object.valueInfo[i]);
            }
          }
          if (object.quantizationAnnotation) {
            if (!Array.isArray(object.quantizationAnnotation))
              throw TypeError(".onnx.GraphProto.quantizationAnnotation: array expected");
            message.quantizationAnnotation = [];
            for (var i = 0; i < object.quantizationAnnotation.length; ++i) {
              if (typeof object.quantizationAnnotation[i] !== "object")
                throw TypeError(".onnx.GraphProto.quantizationAnnotation: object expected");
              message.quantizationAnnotation[i] = $root.onnx.TensorAnnotation.fromObject(object.quantizationAnnotation[i]);
            }
          }
          return message;
        };
        GraphProto.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.arrays || options.defaults) {
            object.node = [];
            object.initializer = [];
            object.input = [];
            object.output = [];
            object.valueInfo = [];
            object.quantizationAnnotation = [];
            object.sparseInitializer = [];
          }
          if (options.defaults) {
            object.name = "";
            object.docString = "";
          }
          if (message.node && message.node.length) {
            object.node = [];
            for (var j = 0; j < message.node.length; ++j)
              object.node[j] = $root.onnx.NodeProto.toObject(message.node[j], options);
          }
          if (message.name != null && message.hasOwnProperty("name"))
            object.name = message.name;
          if (message.initializer && message.initializer.length) {
            object.initializer = [];
            for (var j = 0; j < message.initializer.length; ++j)
              object.initializer[j] = $root.onnx.TensorProto.toObject(message.initializer[j], options);
          }
          if (message.docString != null && message.hasOwnProperty("docString"))
            object.docString = message.docString;
          if (message.input && message.input.length) {
            object.input = [];
            for (var j = 0; j < message.input.length; ++j)
              object.input[j] = $root.onnx.ValueInfoProto.toObject(message.input[j], options);
          }
          if (message.output && message.output.length) {
            object.output = [];
            for (var j = 0; j < message.output.length; ++j)
              object.output[j] = $root.onnx.ValueInfoProto.toObject(message.output[j], options);
          }
          if (message.valueInfo && message.valueInfo.length) {
            object.valueInfo = [];
            for (var j = 0; j < message.valueInfo.length; ++j)
              object.valueInfo[j] = $root.onnx.ValueInfoProto.toObject(message.valueInfo[j], options);
          }
          if (message.quantizationAnnotation && message.quantizationAnnotation.length) {
            object.quantizationAnnotation = [];
            for (var j = 0; j < message.quantizationAnnotation.length; ++j)
              object.quantizationAnnotation[j] = $root.onnx.TensorAnnotation.toObject(message.quantizationAnnotation[j], options);
          }
          if (message.sparseInitializer && message.sparseInitializer.length) {
            object.sparseInitializer = [];
            for (var j = 0; j < message.sparseInitializer.length; ++j)
              object.sparseInitializer[j] = $root.onnx.SparseTensorProto.toObject(message.sparseInitializer[j], options);
          }
          return object;
        };
        GraphProto.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        GraphProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/onnx.GraphProto";
        };
        return GraphProto;
      }();
      onnx6.TensorProto = function() {
        function TensorProto(properties) {
          this.dims = [];
          this.floatData = [];
          this.int32Data = [];
          this.stringData = [];
          this.int64Data = [];
          this.externalData = [];
          this.doubleData = [];
          this.uint64Data = [];
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        TensorProto.prototype.dims = $util.emptyArray;
        TensorProto.prototype.dataType = 0;
        TensorProto.prototype.segment = null;
        TensorProto.prototype.floatData = $util.emptyArray;
        TensorProto.prototype.int32Data = $util.emptyArray;
        TensorProto.prototype.stringData = $util.emptyArray;
        TensorProto.prototype.int64Data = $util.emptyArray;
        TensorProto.prototype.name = "";
        TensorProto.prototype.docString = "";
        TensorProto.prototype.rawData = $util.newBuffer([]);
        TensorProto.prototype.externalData = $util.emptyArray;
        TensorProto.prototype.dataLocation = 0;
        TensorProto.prototype.doubleData = $util.emptyArray;
        TensorProto.prototype.uint64Data = $util.emptyArray;
        TensorProto.create = function create(properties) {
          return new TensorProto(properties);
        };
        TensorProto.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.dims != null && message.dims.length) {
            writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).fork();
            for (var i = 0; i < message.dims.length; ++i)
              writer.int64(message.dims[i]);
            writer.ldelim();
          }
          if (message.dataType != null && Object.hasOwnProperty.call(message, "dataType"))
            writer.uint32(
              /* id 2, wireType 0 =*/
              16
            ).int32(message.dataType);
          if (message.segment != null && Object.hasOwnProperty.call(message, "segment"))
            $root.onnx.TensorProto.Segment.encode(message.segment, writer.uint32(
              /* id 3, wireType 2 =*/
              26
            ).fork()).ldelim();
          if (message.floatData != null && message.floatData.length) {
            writer.uint32(
              /* id 4, wireType 2 =*/
              34
            ).fork();
            for (var i = 0; i < message.floatData.length; ++i)
              writer.float(message.floatData[i]);
            writer.ldelim();
          }
          if (message.int32Data != null && message.int32Data.length) {
            writer.uint32(
              /* id 5, wireType 2 =*/
              42
            ).fork();
            for (var i = 0; i < message.int32Data.length; ++i)
              writer.int32(message.int32Data[i]);
            writer.ldelim();
          }
          if (message.stringData != null && message.stringData.length)
            for (var i = 0; i < message.stringData.length; ++i)
              writer.uint32(
                /* id 6, wireType 2 =*/
                50
              ).bytes(message.stringData[i]);
          if (message.int64Data != null && message.int64Data.length) {
            writer.uint32(
              /* id 7, wireType 2 =*/
              58
            ).fork();
            for (var i = 0; i < message.int64Data.length; ++i)
              writer.int64(message.int64Data[i]);
            writer.ldelim();
          }
          if (message.name != null && Object.hasOwnProperty.call(message, "name"))
            writer.uint32(
              /* id 8, wireType 2 =*/
              66
            ).string(message.name);
          if (message.rawData != null && Object.hasOwnProperty.call(message, "rawData"))
            writer.uint32(
              /* id 9, wireType 2 =*/
              74
            ).bytes(message.rawData);
          if (message.doubleData != null && message.doubleData.length) {
            writer.uint32(
              /* id 10, wireType 2 =*/
              82
            ).fork();
            for (var i = 0; i < message.doubleData.length; ++i)
              writer.double(message.doubleData[i]);
            writer.ldelim();
          }
          if (message.uint64Data != null && message.uint64Data.length) {
            writer.uint32(
              /* id 11, wireType 2 =*/
              90
            ).fork();
            for (var i = 0; i < message.uint64Data.length; ++i)
              writer.uint64(message.uint64Data[i]);
            writer.ldelim();
          }
          if (message.docString != null && Object.hasOwnProperty.call(message, "docString"))
            writer.uint32(
              /* id 12, wireType 2 =*/
              98
            ).string(message.docString);
          if (message.externalData != null && message.externalData.length)
            for (var i = 0; i < message.externalData.length; ++i)
              $root.onnx.StringStringEntryProto.encode(message.externalData[i], writer.uint32(
                /* id 13, wireType 2 =*/
                106
              ).fork()).ldelim();
          if (message.dataLocation != null && Object.hasOwnProperty.call(message, "dataLocation"))
            writer.uint32(
              /* id 14, wireType 0 =*/
              112
            ).int32(message.dataLocation);
          return writer;
        };
        TensorProto.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        TensorProto.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.onnx.TensorProto();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                if (!(message.dims && message.dims.length))
                  message.dims = [];
                if ((tag & 7) === 2) {
                  var end2 = reader.uint32() + reader.pos;
                  while (reader.pos < end2)
                    message.dims.push(reader.int64());
                } else
                  message.dims.push(reader.int64());
                break;
              }
              case 2: {
                message.dataType = reader.int32();
                break;
              }
              case 3: {
                message.segment = $root.onnx.TensorProto.Segment.decode(reader, reader.uint32());
                break;
              }
              case 4: {
                if (!(message.floatData && message.floatData.length))
                  message.floatData = [];
                if ((tag & 7) === 2) {
                  var end2 = reader.uint32() + reader.pos;
                  while (reader.pos < end2)
                    message.floatData.push(reader.float());
                } else
                  message.floatData.push(reader.float());
                break;
              }
              case 5: {
                if (!(message.int32Data && message.int32Data.length))
                  message.int32Data = [];
                if ((tag & 7) === 2) {
                  var end2 = reader.uint32() + reader.pos;
                  while (reader.pos < end2)
                    message.int32Data.push(reader.int32());
                } else
                  message.int32Data.push(reader.int32());
                break;
              }
              case 6: {
                if (!(message.stringData && message.stringData.length))
                  message.stringData = [];
                message.stringData.push(reader.bytes());
                break;
              }
              case 7: {
                if (!(message.int64Data && message.int64Data.length))
                  message.int64Data = [];
                if ((tag & 7) === 2) {
                  var end2 = reader.uint32() + reader.pos;
                  while (reader.pos < end2)
                    message.int64Data.push(reader.int64());
                } else
                  message.int64Data.push(reader.int64());
                break;
              }
              case 8: {
                message.name = reader.string();
                break;
              }
              case 12: {
                message.docString = reader.string();
                break;
              }
              case 9: {
                message.rawData = reader.bytes();
                break;
              }
              case 13: {
                if (!(message.externalData && message.externalData.length))
                  message.externalData = [];
                message.externalData.push($root.onnx.StringStringEntryProto.decode(reader, reader.uint32()));
                break;
              }
              case 14: {
                message.dataLocation = reader.int32();
                break;
              }
              case 10: {
                if (!(message.doubleData && message.doubleData.length))
                  message.doubleData = [];
                if ((tag & 7) === 2) {
                  var end2 = reader.uint32() + reader.pos;
                  while (reader.pos < end2)
                    message.doubleData.push(reader.double());
                } else
                  message.doubleData.push(reader.double());
                break;
              }
              case 11: {
                if (!(message.uint64Data && message.uint64Data.length))
                  message.uint64Data = [];
                if ((tag & 7) === 2) {
                  var end2 = reader.uint32() + reader.pos;
                  while (reader.pos < end2)
                    message.uint64Data.push(reader.uint64());
                } else
                  message.uint64Data.push(reader.uint64());
                break;
              }
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        TensorProto.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        TensorProto.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.dims != null && message.hasOwnProperty("dims")) {
            if (!Array.isArray(message.dims))
              return "dims: array expected";
            for (var i = 0; i < message.dims.length; ++i)
              if (!$util.isInteger(message.dims[i]) && !(message.dims[i] && $util.isInteger(message.dims[i].low) && $util.isInteger(message.dims[i].high)))
                return "dims: integer|Long[] expected";
          }
          if (message.dataType != null && message.hasOwnProperty("dataType")) {
            if (!$util.isInteger(message.dataType))
              return "dataType: integer expected";
          }
          if (message.segment != null && message.hasOwnProperty("segment")) {
            var error = $root.onnx.TensorProto.Segment.verify(message.segment);
            if (error)
              return "segment." + error;
          }
          if (message.floatData != null && message.hasOwnProperty("floatData")) {
            if (!Array.isArray(message.floatData))
              return "floatData: array expected";
            for (var i = 0; i < message.floatData.length; ++i)
              if (typeof message.floatData[i] !== "number")
                return "floatData: number[] expected";
          }
          if (message.int32Data != null && message.hasOwnProperty("int32Data")) {
            if (!Array.isArray(message.int32Data))
              return "int32Data: array expected";
            for (var i = 0; i < message.int32Data.length; ++i)
              if (!$util.isInteger(message.int32Data[i]))
                return "int32Data: integer[] expected";
          }
          if (message.stringData != null && message.hasOwnProperty("stringData")) {
            if (!Array.isArray(message.stringData))
              return "stringData: array expected";
            for (var i = 0; i < message.stringData.length; ++i)
              if (!(message.stringData[i] && typeof message.stringData[i].length === "number" || $util.isString(message.stringData[i])))
                return "stringData: buffer[] expected";
          }
          if (message.int64Data != null && message.hasOwnProperty("int64Data")) {
            if (!Array.isArray(message.int64Data))
              return "int64Data: array expected";
            for (var i = 0; i < message.int64Data.length; ++i)
              if (!$util.isInteger(message.int64Data[i]) && !(message.int64Data[i] && $util.isInteger(message.int64Data[i].low) && $util.isInteger(message.int64Data[i].high)))
                return "int64Data: integer|Long[] expected";
          }
          if (message.name != null && message.hasOwnProperty("name")) {
            if (!$util.isString(message.name))
              return "name: string expected";
          }
          if (message.docString != null && message.hasOwnProperty("docString")) {
            if (!$util.isString(message.docString))
              return "docString: string expected";
          }
          if (message.rawData != null && message.hasOwnProperty("rawData")) {
            if (!(message.rawData && typeof message.rawData.length === "number" || $util.isString(message.rawData)))
              return "rawData: buffer expected";
          }
          if (message.externalData != null && message.hasOwnProperty("externalData")) {
            if (!Array.isArray(message.externalData))
              return "externalData: array expected";
            for (var i = 0; i < message.externalData.length; ++i) {
              var error = $root.onnx.StringStringEntryProto.verify(message.externalData[i]);
              if (error)
                return "externalData." + error;
            }
          }
          if (message.dataLocation != null && message.hasOwnProperty("dataLocation"))
            switch (message.dataLocation) {
              default:
                return "dataLocation: enum value expected";
              case 0:
              case 1:
                break;
            }
          if (message.doubleData != null && message.hasOwnProperty("doubleData")) {
            if (!Array.isArray(message.doubleData))
              return "doubleData: array expected";
            for (var i = 0; i < message.doubleData.length; ++i)
              if (typeof message.doubleData[i] !== "number")
                return "doubleData: number[] expected";
          }
          if (message.uint64Data != null && message.hasOwnProperty("uint64Data")) {
            if (!Array.isArray(message.uint64Data))
              return "uint64Data: array expected";
            for (var i = 0; i < message.uint64Data.length; ++i)
              if (!$util.isInteger(message.uint64Data[i]) && !(message.uint64Data[i] && $util.isInteger(message.uint64Data[i].low) && $util.isInteger(message.uint64Data[i].high)))
                return "uint64Data: integer|Long[] expected";
          }
          return null;
        };
        TensorProto.fromObject = function fromObject(object) {
          if (object instanceof $root.onnx.TensorProto)
            return object;
          var message = new $root.onnx.TensorProto();
          if (object.dims) {
            if (!Array.isArray(object.dims))
              throw TypeError(".onnx.TensorProto.dims: array expected");
            message.dims = [];
            for (var i = 0; i < object.dims.length; ++i)
              if ($util.Long)
                (message.dims[i] = $util.Long.fromValue(object.dims[i])).unsigned = false;
              else if (typeof object.dims[i] === "string")
                message.dims[i] = parseInt(object.dims[i], 10);
              else if (typeof object.dims[i] === "number")
                message.dims[i] = object.dims[i];
              else if (typeof object.dims[i] === "object")
                message.dims[i] = new $util.LongBits(object.dims[i].low >>> 0, object.dims[i].high >>> 0).toNumber();
          }
          if (object.dataType != null)
            message.dataType = object.dataType | 0;
          if (object.segment != null) {
            if (typeof object.segment !== "object")
              throw TypeError(".onnx.TensorProto.segment: object expected");
            message.segment = $root.onnx.TensorProto.Segment.fromObject(object.segment);
          }
          if (object.floatData) {
            if (!Array.isArray(object.floatData))
              throw TypeError(".onnx.TensorProto.floatData: array expected");
            message.floatData = [];
            for (var i = 0; i < object.floatData.length; ++i)
              message.floatData[i] = Number(object.floatData[i]);
          }
          if (object.int32Data) {
            if (!Array.isArray(object.int32Data))
              throw TypeError(".onnx.TensorProto.int32Data: array expected");
            message.int32Data = [];
            for (var i = 0; i < object.int32Data.length; ++i)
              message.int32Data[i] = object.int32Data[i] | 0;
          }
          if (object.stringData) {
            if (!Array.isArray(object.stringData))
              throw TypeError(".onnx.TensorProto.stringData: array expected");
            message.stringData = [];
            for (var i = 0; i < object.stringData.length; ++i)
              if (typeof object.stringData[i] === "string")
                $util.base64.decode(object.stringData[i], message.stringData[i] = $util.newBuffer($util.base64.length(object.stringData[i])), 0);
              else if (object.stringData[i].length >= 0)
                message.stringData[i] = object.stringData[i];
          }
          if (object.int64Data) {
            if (!Array.isArray(object.int64Data))
              throw TypeError(".onnx.TensorProto.int64Data: array expected");
            message.int64Data = [];
            for (var i = 0; i < object.int64Data.length; ++i)
              if ($util.Long)
                (message.int64Data[i] = $util.Long.fromValue(object.int64Data[i])).unsigned = false;
              else if (typeof object.int64Data[i] === "string")
                message.int64Data[i] = parseInt(object.int64Data[i], 10);
              else if (typeof object.int64Data[i] === "number")
                message.int64Data[i] = object.int64Data[i];
              else if (typeof object.int64Data[i] === "object")
                message.int64Data[i] = new $util.LongBits(object.int64Data[i].low >>> 0, object.int64Data[i].high >>> 0).toNumber();
          }
          if (object.name != null)
            message.name = String(object.name);
          if (object.docString != null)
            message.docString = String(object.docString);
          if (object.rawData != null) {
            if (typeof object.rawData === "string")
              $util.base64.decode(object.rawData, message.rawData = $util.newBuffer($util.base64.length(object.rawData)), 0);
            else if (object.rawData.length >= 0)
              message.rawData = object.rawData;
          }
          if (object.externalData) {
            if (!Array.isArray(object.externalData))
              throw TypeError(".onnx.TensorProto.externalData: array expected");
            message.externalData = [];
            for (var i = 0; i < object.externalData.length; ++i) {
              if (typeof object.externalData[i] !== "object")
                throw TypeError(".onnx.TensorProto.externalData: object expected");
              message.externalData[i] = $root.onnx.StringStringEntryProto.fromObject(object.externalData[i]);
            }
          }
          switch (object.dataLocation) {
            default:
              if (typeof object.dataLocation === "number") {
                message.dataLocation = object.dataLocation;
                break;
              }
              break;
            case "DEFAULT":
            case 0:
              message.dataLocation = 0;
              break;
            case "EXTERNAL":
            case 1:
              message.dataLocation = 1;
              break;
          }
          if (object.doubleData) {
            if (!Array.isArray(object.doubleData))
              throw TypeError(".onnx.TensorProto.doubleData: array expected");
            message.doubleData = [];
            for (var i = 0; i < object.doubleData.length; ++i)
              message.doubleData[i] = Number(object.doubleData[i]);
          }
          if (object.uint64Data) {
            if (!Array.isArray(object.uint64Data))
              throw TypeError(".onnx.TensorProto.uint64Data: array expected");
            message.uint64Data = [];
            for (var i = 0; i < object.uint64Data.length; ++i)
              if ($util.Long)
                (message.uint64Data[i] = $util.Long.fromValue(object.uint64Data[i])).unsigned = true;
              else if (typeof object.uint64Data[i] === "string")
                message.uint64Data[i] = parseInt(object.uint64Data[i], 10);
              else if (typeof object.uint64Data[i] === "number")
                message.uint64Data[i] = object.uint64Data[i];
              else if (typeof object.uint64Data[i] === "object")
                message.uint64Data[i] = new $util.LongBits(object.uint64Data[i].low >>> 0, object.uint64Data[i].high >>> 0).toNumber(true);
          }
          return message;
        };
        TensorProto.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.arrays || options.defaults) {
            object.dims = [];
            object.floatData = [];
            object.int32Data = [];
            object.stringData = [];
            object.int64Data = [];
            object.doubleData = [];
            object.uint64Data = [];
            object.externalData = [];
          }
          if (options.defaults) {
            object.dataType = 0;
            object.segment = null;
            object.name = "";
            if (options.bytes === String)
              object.rawData = "";
            else {
              object.rawData = [];
              if (options.bytes !== Array)
                object.rawData = $util.newBuffer(object.rawData);
            }
            object.docString = "";
            object.dataLocation = options.enums === String ? "DEFAULT" : 0;
          }
          if (message.dims && message.dims.length) {
            object.dims = [];
            for (var j = 0; j < message.dims.length; ++j)
              if (typeof message.dims[j] === "number")
                object.dims[j] = options.longs === String ? String(message.dims[j]) : message.dims[j];
              else
                object.dims[j] = options.longs === String ? $util.Long.prototype.toString.call(message.dims[j]) : options.longs === Number ? new $util.LongBits(message.dims[j].low >>> 0, message.dims[j].high >>> 0).toNumber() : message.dims[j];
          }
          if (message.dataType != null && message.hasOwnProperty("dataType"))
            object.dataType = message.dataType;
          if (message.segment != null && message.hasOwnProperty("segment"))
            object.segment = $root.onnx.TensorProto.Segment.toObject(message.segment, options);
          if (message.floatData && message.floatData.length) {
            object.floatData = [];
            for (var j = 0; j < message.floatData.length; ++j)
              object.floatData[j] = options.json && !isFinite(message.floatData[j]) ? String(message.floatData[j]) : message.floatData[j];
          }
          if (message.int32Data && message.int32Data.length) {
            object.int32Data = [];
            for (var j = 0; j < message.int32Data.length; ++j)
              object.int32Data[j] = message.int32Data[j];
          }
          if (message.stringData && message.stringData.length) {
            object.stringData = [];
            for (var j = 0; j < message.stringData.length; ++j)
              object.stringData[j] = options.bytes === String ? $util.base64.encode(message.stringData[j], 0, message.stringData[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.stringData[j]) : message.stringData[j];
          }
          if (message.int64Data && message.int64Data.length) {
            object.int64Data = [];
            for (var j = 0; j < message.int64Data.length; ++j)
              if (typeof message.int64Data[j] === "number")
                object.int64Data[j] = options.longs === String ? String(message.int64Data[j]) : message.int64Data[j];
              else
                object.int64Data[j] = options.longs === String ? $util.Long.prototype.toString.call(message.int64Data[j]) : options.longs === Number ? new $util.LongBits(message.int64Data[j].low >>> 0, message.int64Data[j].high >>> 0).toNumber() : message.int64Data[j];
          }
          if (message.name != null && message.hasOwnProperty("name"))
            object.name = message.name;
          if (message.rawData != null && message.hasOwnProperty("rawData"))
            object.rawData = options.bytes === String ? $util.base64.encode(message.rawData, 0, message.rawData.length) : options.bytes === Array ? Array.prototype.slice.call(message.rawData) : message.rawData;
          if (message.doubleData && message.doubleData.length) {
            object.doubleData = [];
            for (var j = 0; j < message.doubleData.length; ++j)
              object.doubleData[j] = options.json && !isFinite(message.doubleData[j]) ? String(message.doubleData[j]) : message.doubleData[j];
          }
          if (message.uint64Data && message.uint64Data.length) {
            object.uint64Data = [];
            for (var j = 0; j < message.uint64Data.length; ++j)
              if (typeof message.uint64Data[j] === "number")
                object.uint64Data[j] = options.longs === String ? String(message.uint64Data[j]) : message.uint64Data[j];
              else
                object.uint64Data[j] = options.longs === String ? $util.Long.prototype.toString.call(message.uint64Data[j]) : options.longs === Number ? new $util.LongBits(message.uint64Data[j].low >>> 0, message.uint64Data[j].high >>> 0).toNumber(true) : message.uint64Data[j];
          }
          if (message.docString != null && message.hasOwnProperty("docString"))
            object.docString = message.docString;
          if (message.externalData && message.externalData.length) {
            object.externalData = [];
            for (var j = 0; j < message.externalData.length; ++j)
              object.externalData[j] = $root.onnx.StringStringEntryProto.toObject(message.externalData[j], options);
          }
          if (message.dataLocation != null && message.hasOwnProperty("dataLocation"))
            object.dataLocation = options.enums === String ? $root.onnx.TensorProto.DataLocation[message.dataLocation] === void 0 ? message.dataLocation : $root.onnx.TensorProto.DataLocation[message.dataLocation] : message.dataLocation;
          return object;
        };
        TensorProto.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        TensorProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/onnx.TensorProto";
        };
        TensorProto.DataType = function() {
          var valuesById = {}, values = Object.create(valuesById);
          values[valuesById[0] = "UNDEFINED"] = 0;
          values[valuesById[1] = "FLOAT"] = 1;
          values[valuesById[2] = "UINT8"] = 2;
          values[valuesById[3] = "INT8"] = 3;
          values[valuesById[4] = "UINT16"] = 4;
          values[valuesById[5] = "INT16"] = 5;
          values[valuesById[6] = "INT32"] = 6;
          values[valuesById[7] = "INT64"] = 7;
          values[valuesById[8] = "STRING"] = 8;
          values[valuesById[9] = "BOOL"] = 9;
          values[valuesById[10] = "FLOAT16"] = 10;
          values[valuesById[11] = "DOUBLE"] = 11;
          values[valuesById[12] = "UINT32"] = 12;
          values[valuesById[13] = "UINT64"] = 13;
          values[valuesById[14] = "COMPLEX64"] = 14;
          values[valuesById[15] = "COMPLEX128"] = 15;
          values[valuesById[16] = "BFLOAT16"] = 16;
          values[valuesById[17] = "FLOAT8E4M3FN"] = 17;
          values[valuesById[18] = "FLOAT8E4M3FNUZ"] = 18;
          values[valuesById[19] = "FLOAT8E5M2"] = 19;
          values[valuesById[20] = "FLOAT8E5M2FNUZ"] = 20;
          return values;
        }();
        TensorProto.Segment = function() {
          function Segment(properties) {
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          Segment.prototype.begin = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
          Segment.prototype.end = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
          Segment.create = function create(properties) {
            return new Segment(properties);
          };
          Segment.encode = function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.begin != null && Object.hasOwnProperty.call(message, "begin"))
              writer.uint32(
                /* id 1, wireType 0 =*/
                8
              ).int64(message.begin);
            if (message.end != null && Object.hasOwnProperty.call(message, "end"))
              writer.uint32(
                /* id 2, wireType 0 =*/
                16
              ).int64(message.end);
            return writer;
          };
          Segment.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };
          Segment.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.onnx.TensorProto.Segment();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1: {
                  message.begin = reader.int64();
                  break;
                }
                case 2: {
                  message.end = reader.int64();
                  break;
                }
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };
          Segment.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };
          Segment.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.begin != null && message.hasOwnProperty("begin")) {
              if (!$util.isInteger(message.begin) && !(message.begin && $util.isInteger(message.begin.low) && $util.isInteger(message.begin.high)))
                return "begin: integer|Long expected";
            }
            if (message.end != null && message.hasOwnProperty("end")) {
              if (!$util.isInteger(message.end) && !(message.end && $util.isInteger(message.end.low) && $util.isInteger(message.end.high)))
                return "end: integer|Long expected";
            }
            return null;
          };
          Segment.fromObject = function fromObject(object) {
            if (object instanceof $root.onnx.TensorProto.Segment)
              return object;
            var message = new $root.onnx.TensorProto.Segment();
            if (object.begin != null) {
              if ($util.Long)
                (message.begin = $util.Long.fromValue(object.begin)).unsigned = false;
              else if (typeof object.begin === "string")
                message.begin = parseInt(object.begin, 10);
              else if (typeof object.begin === "number")
                message.begin = object.begin;
              else if (typeof object.begin === "object")
                message.begin = new $util.LongBits(object.begin.low >>> 0, object.begin.high >>> 0).toNumber();
            }
            if (object.end != null) {
              if ($util.Long)
                (message.end = $util.Long.fromValue(object.end)).unsigned = false;
              else if (typeof object.end === "string")
                message.end = parseInt(object.end, 10);
              else if (typeof object.end === "number")
                message.end = object.end;
              else if (typeof object.end === "object")
                message.end = new $util.LongBits(object.end.low >>> 0, object.end.high >>> 0).toNumber();
            }
            return message;
          };
          Segment.toObject = function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.defaults) {
              if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.begin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
              } else
                object.begin = options.longs === String ? "0" : 0;
              if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.end = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
              } else
                object.end = options.longs === String ? "0" : 0;
            }
            if (message.begin != null && message.hasOwnProperty("begin"))
              if (typeof message.begin === "number")
                object.begin = options.longs === String ? String(message.begin) : message.begin;
              else
                object.begin = options.longs === String ? $util.Long.prototype.toString.call(message.begin) : options.longs === Number ? new $util.LongBits(message.begin.low >>> 0, message.begin.high >>> 0).toNumber() : message.begin;
            if (message.end != null && message.hasOwnProperty("end"))
              if (typeof message.end === "number")
                object.end = options.longs === String ? String(message.end) : message.end;
              else
                object.end = options.longs === String ? $util.Long.prototype.toString.call(message.end) : options.longs === Number ? new $util.LongBits(message.end.low >>> 0, message.end.high >>> 0).toNumber() : message.end;
            return object;
          };
          Segment.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          Segment.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === void 0) {
              typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/onnx.TensorProto.Segment";
          };
          return Segment;
        }();
        TensorProto.DataLocation = function() {
          var valuesById = {}, values = Object.create(valuesById);
          values[valuesById[0] = "DEFAULT"] = 0;
          values[valuesById[1] = "EXTERNAL"] = 1;
          return values;
        }();
        return TensorProto;
      }();
      onnx6.SparseTensorProto = function() {
        function SparseTensorProto(properties) {
          this.dims = [];
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        SparseTensorProto.prototype.values = null;
        SparseTensorProto.prototype.indices = null;
        SparseTensorProto.prototype.dims = $util.emptyArray;
        SparseTensorProto.create = function create(properties) {
          return new SparseTensorProto(properties);
        };
        SparseTensorProto.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.values != null && Object.hasOwnProperty.call(message, "values"))
            $root.onnx.TensorProto.encode(message.values, writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).fork()).ldelim();
          if (message.indices != null && Object.hasOwnProperty.call(message, "indices"))
            $root.onnx.TensorProto.encode(message.indices, writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).fork()).ldelim();
          if (message.dims != null && message.dims.length) {
            writer.uint32(
              /* id 3, wireType 2 =*/
              26
            ).fork();
            for (var i = 0; i < message.dims.length; ++i)
              writer.int64(message.dims[i]);
            writer.ldelim();
          }
          return writer;
        };
        SparseTensorProto.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        SparseTensorProto.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.onnx.SparseTensorProto();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                message.values = $root.onnx.TensorProto.decode(reader, reader.uint32());
                break;
              }
              case 2: {
                message.indices = $root.onnx.TensorProto.decode(reader, reader.uint32());
                break;
              }
              case 3: {
                if (!(message.dims && message.dims.length))
                  message.dims = [];
                if ((tag & 7) === 2) {
                  var end2 = reader.uint32() + reader.pos;
                  while (reader.pos < end2)
                    message.dims.push(reader.int64());
                } else
                  message.dims.push(reader.int64());
                break;
              }
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        SparseTensorProto.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        SparseTensorProto.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.values != null && message.hasOwnProperty("values")) {
            var error = $root.onnx.TensorProto.verify(message.values);
            if (error)
              return "values." + error;
          }
          if (message.indices != null && message.hasOwnProperty("indices")) {
            var error = $root.onnx.TensorProto.verify(message.indices);
            if (error)
              return "indices." + error;
          }
          if (message.dims != null && message.hasOwnProperty("dims")) {
            if (!Array.isArray(message.dims))
              return "dims: array expected";
            for (var i = 0; i < message.dims.length; ++i)
              if (!$util.isInteger(message.dims[i]) && !(message.dims[i] && $util.isInteger(message.dims[i].low) && $util.isInteger(message.dims[i].high)))
                return "dims: integer|Long[] expected";
          }
          return null;
        };
        SparseTensorProto.fromObject = function fromObject(object) {
          if (object instanceof $root.onnx.SparseTensorProto)
            return object;
          var message = new $root.onnx.SparseTensorProto();
          if (object.values != null) {
            if (typeof object.values !== "object")
              throw TypeError(".onnx.SparseTensorProto.values: object expected");
            message.values = $root.onnx.TensorProto.fromObject(object.values);
          }
          if (object.indices != null) {
            if (typeof object.indices !== "object")
              throw TypeError(".onnx.SparseTensorProto.indices: object expected");
            message.indices = $root.onnx.TensorProto.fromObject(object.indices);
          }
          if (object.dims) {
            if (!Array.isArray(object.dims))
              throw TypeError(".onnx.SparseTensorProto.dims: array expected");
            message.dims = [];
            for (var i = 0; i < object.dims.length; ++i)
              if ($util.Long)
                (message.dims[i] = $util.Long.fromValue(object.dims[i])).unsigned = false;
              else if (typeof object.dims[i] === "string")
                message.dims[i] = parseInt(object.dims[i], 10);
              else if (typeof object.dims[i] === "number")
                message.dims[i] = object.dims[i];
              else if (typeof object.dims[i] === "object")
                message.dims[i] = new $util.LongBits(object.dims[i].low >>> 0, object.dims[i].high >>> 0).toNumber();
          }
          return message;
        };
        SparseTensorProto.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.arrays || options.defaults)
            object.dims = [];
          if (options.defaults) {
            object.values = null;
            object.indices = null;
          }
          if (message.values != null && message.hasOwnProperty("values"))
            object.values = $root.onnx.TensorProto.toObject(message.values, options);
          if (message.indices != null && message.hasOwnProperty("indices"))
            object.indices = $root.onnx.TensorProto.toObject(message.indices, options);
          if (message.dims && message.dims.length) {
            object.dims = [];
            for (var j = 0; j < message.dims.length; ++j)
              if (typeof message.dims[j] === "number")
                object.dims[j] = options.longs === String ? String(message.dims[j]) : message.dims[j];
              else
                object.dims[j] = options.longs === String ? $util.Long.prototype.toString.call(message.dims[j]) : options.longs === Number ? new $util.LongBits(message.dims[j].low >>> 0, message.dims[j].high >>> 0).toNumber() : message.dims[j];
          }
          return object;
        };
        SparseTensorProto.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        SparseTensorProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/onnx.SparseTensorProto";
        };
        return SparseTensorProto;
      }();
      onnx6.TensorShapeProto = function() {
        function TensorShapeProto(properties) {
          this.dim = [];
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        TensorShapeProto.prototype.dim = $util.emptyArray;
        TensorShapeProto.create = function create(properties) {
          return new TensorShapeProto(properties);
        };
        TensorShapeProto.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.dim != null && message.dim.length)
            for (var i = 0; i < message.dim.length; ++i)
              $root.onnx.TensorShapeProto.Dimension.encode(message.dim[i], writer.uint32(
                /* id 1, wireType 2 =*/
                10
              ).fork()).ldelim();
          return writer;
        };
        TensorShapeProto.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        TensorShapeProto.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.onnx.TensorShapeProto();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                if (!(message.dim && message.dim.length))
                  message.dim = [];
                message.dim.push($root.onnx.TensorShapeProto.Dimension.decode(reader, reader.uint32()));
                break;
              }
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        TensorShapeProto.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        TensorShapeProto.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.dim != null && message.hasOwnProperty("dim")) {
            if (!Array.isArray(message.dim))
              return "dim: array expected";
            for (var i = 0; i < message.dim.length; ++i) {
              var error = $root.onnx.TensorShapeProto.Dimension.verify(message.dim[i]);
              if (error)
                return "dim." + error;
            }
          }
          return null;
        };
        TensorShapeProto.fromObject = function fromObject(object) {
          if (object instanceof $root.onnx.TensorShapeProto)
            return object;
          var message = new $root.onnx.TensorShapeProto();
          if (object.dim) {
            if (!Array.isArray(object.dim))
              throw TypeError(".onnx.TensorShapeProto.dim: array expected");
            message.dim = [];
            for (var i = 0; i < object.dim.length; ++i) {
              if (typeof object.dim[i] !== "object")
                throw TypeError(".onnx.TensorShapeProto.dim: object expected");
              message.dim[i] = $root.onnx.TensorShapeProto.Dimension.fromObject(object.dim[i]);
            }
          }
          return message;
        };
        TensorShapeProto.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.arrays || options.defaults)
            object.dim = [];
          if (message.dim && message.dim.length) {
            object.dim = [];
            for (var j = 0; j < message.dim.length; ++j)
              object.dim[j] = $root.onnx.TensorShapeProto.Dimension.toObject(message.dim[j], options);
          }
          return object;
        };
        TensorShapeProto.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        TensorShapeProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/onnx.TensorShapeProto";
        };
        TensorShapeProto.Dimension = function() {
          function Dimension(properties) {
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          Dimension.prototype.dimValue = null;
          Dimension.prototype.dimParam = null;
          Dimension.prototype.denotation = "";
          var $oneOfFields;
          Object.defineProperty(Dimension.prototype, "value", {
            get: $util.oneOfGetter($oneOfFields = ["dimValue", "dimParam"]),
            set: $util.oneOfSetter($oneOfFields)
          });
          Dimension.create = function create(properties) {
            return new Dimension(properties);
          };
          Dimension.encode = function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.dimValue != null && Object.hasOwnProperty.call(message, "dimValue"))
              writer.uint32(
                /* id 1, wireType 0 =*/
                8
              ).int64(message.dimValue);
            if (message.dimParam != null && Object.hasOwnProperty.call(message, "dimParam"))
              writer.uint32(
                /* id 2, wireType 2 =*/
                18
              ).string(message.dimParam);
            if (message.denotation != null && Object.hasOwnProperty.call(message, "denotation"))
              writer.uint32(
                /* id 3, wireType 2 =*/
                26
              ).string(message.denotation);
            return writer;
          };
          Dimension.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };
          Dimension.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.onnx.TensorShapeProto.Dimension();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1: {
                  message.dimValue = reader.int64();
                  break;
                }
                case 2: {
                  message.dimParam = reader.string();
                  break;
                }
                case 3: {
                  message.denotation = reader.string();
                  break;
                }
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };
          Dimension.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };
          Dimension.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            var properties = {};
            if (message.dimValue != null && message.hasOwnProperty("dimValue")) {
              properties.value = 1;
              if (!$util.isInteger(message.dimValue) && !(message.dimValue && $util.isInteger(message.dimValue.low) && $util.isInteger(message.dimValue.high)))
                return "dimValue: integer|Long expected";
            }
            if (message.dimParam != null && message.hasOwnProperty("dimParam")) {
              if (properties.value === 1)
                return "value: multiple values";
              properties.value = 1;
              if (!$util.isString(message.dimParam))
                return "dimParam: string expected";
            }
            if (message.denotation != null && message.hasOwnProperty("denotation")) {
              if (!$util.isString(message.denotation))
                return "denotation: string expected";
            }
            return null;
          };
          Dimension.fromObject = function fromObject(object) {
            if (object instanceof $root.onnx.TensorShapeProto.Dimension)
              return object;
            var message = new $root.onnx.TensorShapeProto.Dimension();
            if (object.dimValue != null) {
              if ($util.Long)
                (message.dimValue = $util.Long.fromValue(object.dimValue)).unsigned = false;
              else if (typeof object.dimValue === "string")
                message.dimValue = parseInt(object.dimValue, 10);
              else if (typeof object.dimValue === "number")
                message.dimValue = object.dimValue;
              else if (typeof object.dimValue === "object")
                message.dimValue = new $util.LongBits(object.dimValue.low >>> 0, object.dimValue.high >>> 0).toNumber();
            }
            if (object.dimParam != null)
              message.dimParam = String(object.dimParam);
            if (object.denotation != null)
              message.denotation = String(object.denotation);
            return message;
          };
          Dimension.toObject = function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.defaults)
              object.denotation = "";
            if (message.dimValue != null && message.hasOwnProperty("dimValue")) {
              if (typeof message.dimValue === "number")
                object.dimValue = options.longs === String ? String(message.dimValue) : message.dimValue;
              else
                object.dimValue = options.longs === String ? $util.Long.prototype.toString.call(message.dimValue) : options.longs === Number ? new $util.LongBits(message.dimValue.low >>> 0, message.dimValue.high >>> 0).toNumber() : message.dimValue;
              if (options.oneofs)
                object.value = "dimValue";
            }
            if (message.dimParam != null && message.hasOwnProperty("dimParam")) {
              object.dimParam = message.dimParam;
              if (options.oneofs)
                object.value = "dimParam";
            }
            if (message.denotation != null && message.hasOwnProperty("denotation"))
              object.denotation = message.denotation;
            return object;
          };
          Dimension.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          Dimension.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === void 0) {
              typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/onnx.TensorShapeProto.Dimension";
          };
          return Dimension;
        }();
        return TensorShapeProto;
      }();
      onnx6.TypeProto = function() {
        function TypeProto(properties) {
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        TypeProto.prototype.tensorType = null;
        TypeProto.prototype.sequenceType = null;
        TypeProto.prototype.mapType = null;
        TypeProto.prototype.optionalType = null;
        TypeProto.prototype.sparseTensorType = null;
        TypeProto.prototype.denotation = "";
        var $oneOfFields;
        Object.defineProperty(TypeProto.prototype, "value", {
          get: $util.oneOfGetter($oneOfFields = ["tensorType", "sequenceType", "mapType", "optionalType", "sparseTensorType"]),
          set: $util.oneOfSetter($oneOfFields)
        });
        TypeProto.create = function create(properties) {
          return new TypeProto(properties);
        };
        TypeProto.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.tensorType != null && Object.hasOwnProperty.call(message, "tensorType"))
            $root.onnx.TypeProto.Tensor.encode(message.tensorType, writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).fork()).ldelim();
          if (message.sequenceType != null && Object.hasOwnProperty.call(message, "sequenceType"))
            $root.onnx.TypeProto.Sequence.encode(message.sequenceType, writer.uint32(
              /* id 4, wireType 2 =*/
              34
            ).fork()).ldelim();
          if (message.mapType != null && Object.hasOwnProperty.call(message, "mapType"))
            $root.onnx.TypeProto.Map.encode(message.mapType, writer.uint32(
              /* id 5, wireType 2 =*/
              42
            ).fork()).ldelim();
          if (message.denotation != null && Object.hasOwnProperty.call(message, "denotation"))
            writer.uint32(
              /* id 6, wireType 2 =*/
              50
            ).string(message.denotation);
          if (message.sparseTensorType != null && Object.hasOwnProperty.call(message, "sparseTensorType"))
            $root.onnx.TypeProto.SparseTensor.encode(message.sparseTensorType, writer.uint32(
              /* id 8, wireType 2 =*/
              66
            ).fork()).ldelim();
          if (message.optionalType != null && Object.hasOwnProperty.call(message, "optionalType"))
            $root.onnx.TypeProto.Optional.encode(message.optionalType, writer.uint32(
              /* id 9, wireType 2 =*/
              74
            ).fork()).ldelim();
          return writer;
        };
        TypeProto.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        TypeProto.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.onnx.TypeProto();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                message.tensorType = $root.onnx.TypeProto.Tensor.decode(reader, reader.uint32());
                break;
              }
              case 4: {
                message.sequenceType = $root.onnx.TypeProto.Sequence.decode(reader, reader.uint32());
                break;
              }
              case 5: {
                message.mapType = $root.onnx.TypeProto.Map.decode(reader, reader.uint32());
                break;
              }
              case 9: {
                message.optionalType = $root.onnx.TypeProto.Optional.decode(reader, reader.uint32());
                break;
              }
              case 8: {
                message.sparseTensorType = $root.onnx.TypeProto.SparseTensor.decode(reader, reader.uint32());
                break;
              }
              case 6: {
                message.denotation = reader.string();
                break;
              }
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        TypeProto.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        TypeProto.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          var properties = {};
          if (message.tensorType != null && message.hasOwnProperty("tensorType")) {
            properties.value = 1;
            {
              var error = $root.onnx.TypeProto.Tensor.verify(message.tensorType);
              if (error)
                return "tensorType." + error;
            }
          }
          if (message.sequenceType != null && message.hasOwnProperty("sequenceType")) {
            if (properties.value === 1)
              return "value: multiple values";
            properties.value = 1;
            {
              var error = $root.onnx.TypeProto.Sequence.verify(message.sequenceType);
              if (error)
                return "sequenceType." + error;
            }
          }
          if (message.mapType != null && message.hasOwnProperty("mapType")) {
            if (properties.value === 1)
              return "value: multiple values";
            properties.value = 1;
            {
              var error = $root.onnx.TypeProto.Map.verify(message.mapType);
              if (error)
                return "mapType." + error;
            }
          }
          if (message.optionalType != null && message.hasOwnProperty("optionalType")) {
            if (properties.value === 1)
              return "value: multiple values";
            properties.value = 1;
            {
              var error = $root.onnx.TypeProto.Optional.verify(message.optionalType);
              if (error)
                return "optionalType." + error;
            }
          }
          if (message.sparseTensorType != null && message.hasOwnProperty("sparseTensorType")) {
            if (properties.value === 1)
              return "value: multiple values";
            properties.value = 1;
            {
              var error = $root.onnx.TypeProto.SparseTensor.verify(message.sparseTensorType);
              if (error)
                return "sparseTensorType." + error;
            }
          }
          if (message.denotation != null && message.hasOwnProperty("denotation")) {
            if (!$util.isString(message.denotation))
              return "denotation: string expected";
          }
          return null;
        };
        TypeProto.fromObject = function fromObject(object) {
          if (object instanceof $root.onnx.TypeProto)
            return object;
          var message = new $root.onnx.TypeProto();
          if (object.tensorType != null) {
            if (typeof object.tensorType !== "object")
              throw TypeError(".onnx.TypeProto.tensorType: object expected");
            message.tensorType = $root.onnx.TypeProto.Tensor.fromObject(object.tensorType);
          }
          if (object.sequenceType != null) {
            if (typeof object.sequenceType !== "object")
              throw TypeError(".onnx.TypeProto.sequenceType: object expected");
            message.sequenceType = $root.onnx.TypeProto.Sequence.fromObject(object.sequenceType);
          }
          if (object.mapType != null) {
            if (typeof object.mapType !== "object")
              throw TypeError(".onnx.TypeProto.mapType: object expected");
            message.mapType = $root.onnx.TypeProto.Map.fromObject(object.mapType);
          }
          if (object.optionalType != null) {
            if (typeof object.optionalType !== "object")
              throw TypeError(".onnx.TypeProto.optionalType: object expected");
            message.optionalType = $root.onnx.TypeProto.Optional.fromObject(object.optionalType);
          }
          if (object.sparseTensorType != null) {
            if (typeof object.sparseTensorType !== "object")
              throw TypeError(".onnx.TypeProto.sparseTensorType: object expected");
            message.sparseTensorType = $root.onnx.TypeProto.SparseTensor.fromObject(object.sparseTensorType);
          }
          if (object.denotation != null)
            message.denotation = String(object.denotation);
          return message;
        };
        TypeProto.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.defaults)
            object.denotation = "";
          if (message.tensorType != null && message.hasOwnProperty("tensorType")) {
            object.tensorType = $root.onnx.TypeProto.Tensor.toObject(message.tensorType, options);
            if (options.oneofs)
              object.value = "tensorType";
          }
          if (message.sequenceType != null && message.hasOwnProperty("sequenceType")) {
            object.sequenceType = $root.onnx.TypeProto.Sequence.toObject(message.sequenceType, options);
            if (options.oneofs)
              object.value = "sequenceType";
          }
          if (message.mapType != null && message.hasOwnProperty("mapType")) {
            object.mapType = $root.onnx.TypeProto.Map.toObject(message.mapType, options);
            if (options.oneofs)
              object.value = "mapType";
          }
          if (message.denotation != null && message.hasOwnProperty("denotation"))
            object.denotation = message.denotation;
          if (message.sparseTensorType != null && message.hasOwnProperty("sparseTensorType")) {
            object.sparseTensorType = $root.onnx.TypeProto.SparseTensor.toObject(message.sparseTensorType, options);
            if (options.oneofs)
              object.value = "sparseTensorType";
          }
          if (message.optionalType != null && message.hasOwnProperty("optionalType")) {
            object.optionalType = $root.onnx.TypeProto.Optional.toObject(message.optionalType, options);
            if (options.oneofs)
              object.value = "optionalType";
          }
          return object;
        };
        TypeProto.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        TypeProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/onnx.TypeProto";
        };
        TypeProto.Tensor = function() {
          function Tensor4(properties) {
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          Tensor4.prototype.elemType = 0;
          Tensor4.prototype.shape = null;
          Tensor4.create = function create(properties) {
            return new Tensor4(properties);
          };
          Tensor4.encode = function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.elemType != null && Object.hasOwnProperty.call(message, "elemType"))
              writer.uint32(
                /* id 1, wireType 0 =*/
                8
              ).int32(message.elemType);
            if (message.shape != null && Object.hasOwnProperty.call(message, "shape"))
              $root.onnx.TensorShapeProto.encode(message.shape, writer.uint32(
                /* id 2, wireType 2 =*/
                18
              ).fork()).ldelim();
            return writer;
          };
          Tensor4.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };
          Tensor4.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.onnx.TypeProto.Tensor();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1: {
                  message.elemType = reader.int32();
                  break;
                }
                case 2: {
                  message.shape = $root.onnx.TensorShapeProto.decode(reader, reader.uint32());
                  break;
                }
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };
          Tensor4.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };
          Tensor4.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.elemType != null && message.hasOwnProperty("elemType")) {
              if (!$util.isInteger(message.elemType))
                return "elemType: integer expected";
            }
            if (message.shape != null && message.hasOwnProperty("shape")) {
              var error = $root.onnx.TensorShapeProto.verify(message.shape);
              if (error)
                return "shape." + error;
            }
            return null;
          };
          Tensor4.fromObject = function fromObject(object) {
            if (object instanceof $root.onnx.TypeProto.Tensor)
              return object;
            var message = new $root.onnx.TypeProto.Tensor();
            if (object.elemType != null)
              message.elemType = object.elemType | 0;
            if (object.shape != null) {
              if (typeof object.shape !== "object")
                throw TypeError(".onnx.TypeProto.Tensor.shape: object expected");
              message.shape = $root.onnx.TensorShapeProto.fromObject(object.shape);
            }
            return message;
          };
          Tensor4.toObject = function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.defaults) {
              object.elemType = 0;
              object.shape = null;
            }
            if (message.elemType != null && message.hasOwnProperty("elemType"))
              object.elemType = message.elemType;
            if (message.shape != null && message.hasOwnProperty("shape"))
              object.shape = $root.onnx.TensorShapeProto.toObject(message.shape, options);
            return object;
          };
          Tensor4.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          Tensor4.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === void 0) {
              typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/onnx.TypeProto.Tensor";
          };
          return Tensor4;
        }();
        TypeProto.Sequence = function() {
          function Sequence(properties) {
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          Sequence.prototype.elemType = null;
          Sequence.create = function create(properties) {
            return new Sequence(properties);
          };
          Sequence.encode = function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.elemType != null && Object.hasOwnProperty.call(message, "elemType"))
              $root.onnx.TypeProto.encode(message.elemType, writer.uint32(
                /* id 1, wireType 2 =*/
                10
              ).fork()).ldelim();
            return writer;
          };
          Sequence.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };
          Sequence.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.onnx.TypeProto.Sequence();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1: {
                  message.elemType = $root.onnx.TypeProto.decode(reader, reader.uint32());
                  break;
                }
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };
          Sequence.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };
          Sequence.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.elemType != null && message.hasOwnProperty("elemType")) {
              var error = $root.onnx.TypeProto.verify(message.elemType);
              if (error)
                return "elemType." + error;
            }
            return null;
          };
          Sequence.fromObject = function fromObject(object) {
            if (object instanceof $root.onnx.TypeProto.Sequence)
              return object;
            var message = new $root.onnx.TypeProto.Sequence();
            if (object.elemType != null) {
              if (typeof object.elemType !== "object")
                throw TypeError(".onnx.TypeProto.Sequence.elemType: object expected");
              message.elemType = $root.onnx.TypeProto.fromObject(object.elemType);
            }
            return message;
          };
          Sequence.toObject = function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.defaults)
              object.elemType = null;
            if (message.elemType != null && message.hasOwnProperty("elemType"))
              object.elemType = $root.onnx.TypeProto.toObject(message.elemType, options);
            return object;
          };
          Sequence.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          Sequence.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === void 0) {
              typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/onnx.TypeProto.Sequence";
          };
          return Sequence;
        }();
        TypeProto.Map = function() {
          function Map2(properties) {
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          Map2.prototype.keyType = 0;
          Map2.prototype.valueType = null;
          Map2.create = function create(properties) {
            return new Map2(properties);
          };
          Map2.encode = function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.keyType != null && Object.hasOwnProperty.call(message, "keyType"))
              writer.uint32(
                /* id 1, wireType 0 =*/
                8
              ).int32(message.keyType);
            if (message.valueType != null && Object.hasOwnProperty.call(message, "valueType"))
              $root.onnx.TypeProto.encode(message.valueType, writer.uint32(
                /* id 2, wireType 2 =*/
                18
              ).fork()).ldelim();
            return writer;
          };
          Map2.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };
          Map2.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.onnx.TypeProto.Map();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1: {
                  message.keyType = reader.int32();
                  break;
                }
                case 2: {
                  message.valueType = $root.onnx.TypeProto.decode(reader, reader.uint32());
                  break;
                }
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };
          Map2.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };
          Map2.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.keyType != null && message.hasOwnProperty("keyType")) {
              if (!$util.isInteger(message.keyType))
                return "keyType: integer expected";
            }
            if (message.valueType != null && message.hasOwnProperty("valueType")) {
              var error = $root.onnx.TypeProto.verify(message.valueType);
              if (error)
                return "valueType." + error;
            }
            return null;
          };
          Map2.fromObject = function fromObject(object) {
            if (object instanceof $root.onnx.TypeProto.Map)
              return object;
            var message = new $root.onnx.TypeProto.Map();
            if (object.keyType != null)
              message.keyType = object.keyType | 0;
            if (object.valueType != null) {
              if (typeof object.valueType !== "object")
                throw TypeError(".onnx.TypeProto.Map.valueType: object expected");
              message.valueType = $root.onnx.TypeProto.fromObject(object.valueType);
            }
            return message;
          };
          Map2.toObject = function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.defaults) {
              object.keyType = 0;
              object.valueType = null;
            }
            if (message.keyType != null && message.hasOwnProperty("keyType"))
              object.keyType = message.keyType;
            if (message.valueType != null && message.hasOwnProperty("valueType"))
              object.valueType = $root.onnx.TypeProto.toObject(message.valueType, options);
            return object;
          };
          Map2.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          Map2.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === void 0) {
              typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/onnx.TypeProto.Map";
          };
          return Map2;
        }();
        TypeProto.Optional = function() {
          function Optional(properties) {
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          Optional.prototype.elemType = null;
          Optional.create = function create(properties) {
            return new Optional(properties);
          };
          Optional.encode = function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.elemType != null && Object.hasOwnProperty.call(message, "elemType"))
              $root.onnx.TypeProto.encode(message.elemType, writer.uint32(
                /* id 1, wireType 2 =*/
                10
              ).fork()).ldelim();
            return writer;
          };
          Optional.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };
          Optional.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.onnx.TypeProto.Optional();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1: {
                  message.elemType = $root.onnx.TypeProto.decode(reader, reader.uint32());
                  break;
                }
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };
          Optional.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };
          Optional.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.elemType != null && message.hasOwnProperty("elemType")) {
              var error = $root.onnx.TypeProto.verify(message.elemType);
              if (error)
                return "elemType." + error;
            }
            return null;
          };
          Optional.fromObject = function fromObject(object) {
            if (object instanceof $root.onnx.TypeProto.Optional)
              return object;
            var message = new $root.onnx.TypeProto.Optional();
            if (object.elemType != null) {
              if (typeof object.elemType !== "object")
                throw TypeError(".onnx.TypeProto.Optional.elemType: object expected");
              message.elemType = $root.onnx.TypeProto.fromObject(object.elemType);
            }
            return message;
          };
          Optional.toObject = function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.defaults)
              object.elemType = null;
            if (message.elemType != null && message.hasOwnProperty("elemType"))
              object.elemType = $root.onnx.TypeProto.toObject(message.elemType, options);
            return object;
          };
          Optional.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          Optional.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === void 0) {
              typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/onnx.TypeProto.Optional";
          };
          return Optional;
        }();
        TypeProto.SparseTensor = function() {
          function SparseTensor(properties) {
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          SparseTensor.prototype.elemType = 0;
          SparseTensor.prototype.shape = null;
          SparseTensor.create = function create(properties) {
            return new SparseTensor(properties);
          };
          SparseTensor.encode = function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.elemType != null && Object.hasOwnProperty.call(message, "elemType"))
              writer.uint32(
                /* id 1, wireType 0 =*/
                8
              ).int32(message.elemType);
            if (message.shape != null && Object.hasOwnProperty.call(message, "shape"))
              $root.onnx.TensorShapeProto.encode(message.shape, writer.uint32(
                /* id 2, wireType 2 =*/
                18
              ).fork()).ldelim();
            return writer;
          };
          SparseTensor.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };
          SparseTensor.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.onnx.TypeProto.SparseTensor();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1: {
                  message.elemType = reader.int32();
                  break;
                }
                case 2: {
                  message.shape = $root.onnx.TensorShapeProto.decode(reader, reader.uint32());
                  break;
                }
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };
          SparseTensor.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };
          SparseTensor.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.elemType != null && message.hasOwnProperty("elemType")) {
              if (!$util.isInteger(message.elemType))
                return "elemType: integer expected";
            }
            if (message.shape != null && message.hasOwnProperty("shape")) {
              var error = $root.onnx.TensorShapeProto.verify(message.shape);
              if (error)
                return "shape." + error;
            }
            return null;
          };
          SparseTensor.fromObject = function fromObject(object) {
            if (object instanceof $root.onnx.TypeProto.SparseTensor)
              return object;
            var message = new $root.onnx.TypeProto.SparseTensor();
            if (object.elemType != null)
              message.elemType = object.elemType | 0;
            if (object.shape != null) {
              if (typeof object.shape !== "object")
                throw TypeError(".onnx.TypeProto.SparseTensor.shape: object expected");
              message.shape = $root.onnx.TensorShapeProto.fromObject(object.shape);
            }
            return message;
          };
          SparseTensor.toObject = function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.defaults) {
              object.elemType = 0;
              object.shape = null;
            }
            if (message.elemType != null && message.hasOwnProperty("elemType"))
              object.elemType = message.elemType;
            if (message.shape != null && message.hasOwnProperty("shape"))
              object.shape = $root.onnx.TensorShapeProto.toObject(message.shape, options);
            return object;
          };
          SparseTensor.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          SparseTensor.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === void 0) {
              typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/onnx.TypeProto.SparseTensor";
          };
          return SparseTensor;
        }();
        return TypeProto;
      }();
      onnx6.OperatorSetIdProto = function() {
        function OperatorSetIdProto(properties) {
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        OperatorSetIdProto.prototype.domain = "";
        OperatorSetIdProto.prototype.version = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        OperatorSetIdProto.create = function create(properties) {
          return new OperatorSetIdProto(properties);
        };
        OperatorSetIdProto.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.domain != null && Object.hasOwnProperty.call(message, "domain"))
            writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).string(message.domain);
          if (message.version != null && Object.hasOwnProperty.call(message, "version"))
            writer.uint32(
              /* id 2, wireType 0 =*/
              16
            ).int64(message.version);
          return writer;
        };
        OperatorSetIdProto.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        OperatorSetIdProto.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.onnx.OperatorSetIdProto();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                message.domain = reader.string();
                break;
              }
              case 2: {
                message.version = reader.int64();
                break;
              }
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        OperatorSetIdProto.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        OperatorSetIdProto.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.domain != null && message.hasOwnProperty("domain")) {
            if (!$util.isString(message.domain))
              return "domain: string expected";
          }
          if (message.version != null && message.hasOwnProperty("version")) {
            if (!$util.isInteger(message.version) && !(message.version && $util.isInteger(message.version.low) && $util.isInteger(message.version.high)))
              return "version: integer|Long expected";
          }
          return null;
        };
        OperatorSetIdProto.fromObject = function fromObject(object) {
          if (object instanceof $root.onnx.OperatorSetIdProto)
            return object;
          var message = new $root.onnx.OperatorSetIdProto();
          if (object.domain != null)
            message.domain = String(object.domain);
          if (object.version != null) {
            if ($util.Long)
              (message.version = $util.Long.fromValue(object.version)).unsigned = false;
            else if (typeof object.version === "string")
              message.version = parseInt(object.version, 10);
            else if (typeof object.version === "number")
              message.version = object.version;
            else if (typeof object.version === "object")
              message.version = new $util.LongBits(object.version.low >>> 0, object.version.high >>> 0).toNumber();
          }
          return message;
        };
        OperatorSetIdProto.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.defaults) {
            object.domain = "";
            if ($util.Long) {
              var long = new $util.Long(0, 0, false);
              object.version = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
              object.version = options.longs === String ? "0" : 0;
          }
          if (message.domain != null && message.hasOwnProperty("domain"))
            object.domain = message.domain;
          if (message.version != null && message.hasOwnProperty("version"))
            if (typeof message.version === "number")
              object.version = options.longs === String ? String(message.version) : message.version;
            else
              object.version = options.longs === String ? $util.Long.prototype.toString.call(message.version) : options.longs === Number ? new $util.LongBits(message.version.low >>> 0, message.version.high >>> 0).toNumber() : message.version;
          return object;
        };
        OperatorSetIdProto.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        OperatorSetIdProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/onnx.OperatorSetIdProto";
        };
        return OperatorSetIdProto;
      }();
      onnx6.OperatorStatus = function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "EXPERIMENTAL"] = 0;
        values[valuesById[1] = "STABLE"] = 1;
        return values;
      }();
      onnx6.FunctionProto = function() {
        function FunctionProto(properties) {
          this.input = [];
          this.output = [];
          this.attribute = [];
          this.attributeProto = [];
          this.node = [];
          this.opsetImport = [];
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        FunctionProto.prototype.name = "";
        FunctionProto.prototype.input = $util.emptyArray;
        FunctionProto.prototype.output = $util.emptyArray;
        FunctionProto.prototype.attribute = $util.emptyArray;
        FunctionProto.prototype.attributeProto = $util.emptyArray;
        FunctionProto.prototype.node = $util.emptyArray;
        FunctionProto.prototype.docString = "";
        FunctionProto.prototype.opsetImport = $util.emptyArray;
        FunctionProto.prototype.domain = "";
        FunctionProto.create = function create(properties) {
          return new FunctionProto(properties);
        };
        FunctionProto.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.name != null && Object.hasOwnProperty.call(message, "name"))
            writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).string(message.name);
          if (message.input != null && message.input.length)
            for (var i = 0; i < message.input.length; ++i)
              writer.uint32(
                /* id 4, wireType 2 =*/
                34
              ).string(message.input[i]);
          if (message.output != null && message.output.length)
            for (var i = 0; i < message.output.length; ++i)
              writer.uint32(
                /* id 5, wireType 2 =*/
                42
              ).string(message.output[i]);
          if (message.attribute != null && message.attribute.length)
            for (var i = 0; i < message.attribute.length; ++i)
              writer.uint32(
                /* id 6, wireType 2 =*/
                50
              ).string(message.attribute[i]);
          if (message.node != null && message.node.length)
            for (var i = 0; i < message.node.length; ++i)
              $root.onnx.NodeProto.encode(message.node[i], writer.uint32(
                /* id 7, wireType 2 =*/
                58
              ).fork()).ldelim();
          if (message.docString != null && Object.hasOwnProperty.call(message, "docString"))
            writer.uint32(
              /* id 8, wireType 2 =*/
              66
            ).string(message.docString);
          if (message.opsetImport != null && message.opsetImport.length)
            for (var i = 0; i < message.opsetImport.length; ++i)
              $root.onnx.OperatorSetIdProto.encode(message.opsetImport[i], writer.uint32(
                /* id 9, wireType 2 =*/
                74
              ).fork()).ldelim();
          if (message.domain != null && Object.hasOwnProperty.call(message, "domain"))
            writer.uint32(
              /* id 10, wireType 2 =*/
              82
            ).string(message.domain);
          if (message.attributeProto != null && message.attributeProto.length)
            for (var i = 0; i < message.attributeProto.length; ++i)
              $root.onnx.AttributeProto.encode(message.attributeProto[i], writer.uint32(
                /* id 11, wireType 2 =*/
                90
              ).fork()).ldelim();
          return writer;
        };
        FunctionProto.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        FunctionProto.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.onnx.FunctionProto();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                message.name = reader.string();
                break;
              }
              case 4: {
                if (!(message.input && message.input.length))
                  message.input = [];
                message.input.push(reader.string());
                break;
              }
              case 5: {
                if (!(message.output && message.output.length))
                  message.output = [];
                message.output.push(reader.string());
                break;
              }
              case 6: {
                if (!(message.attribute && message.attribute.length))
                  message.attribute = [];
                message.attribute.push(reader.string());
                break;
              }
              case 11: {
                if (!(message.attributeProto && message.attributeProto.length))
                  message.attributeProto = [];
                message.attributeProto.push($root.onnx.AttributeProto.decode(reader, reader.uint32()));
                break;
              }
              case 7: {
                if (!(message.node && message.node.length))
                  message.node = [];
                message.node.push($root.onnx.NodeProto.decode(reader, reader.uint32()));
                break;
              }
              case 8: {
                message.docString = reader.string();
                break;
              }
              case 9: {
                if (!(message.opsetImport && message.opsetImport.length))
                  message.opsetImport = [];
                message.opsetImport.push($root.onnx.OperatorSetIdProto.decode(reader, reader.uint32()));
                break;
              }
              case 10: {
                message.domain = reader.string();
                break;
              }
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        FunctionProto.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        FunctionProto.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.name != null && message.hasOwnProperty("name")) {
            if (!$util.isString(message.name))
              return "name: string expected";
          }
          if (message.input != null && message.hasOwnProperty("input")) {
            if (!Array.isArray(message.input))
              return "input: array expected";
            for (var i = 0; i < message.input.length; ++i)
              if (!$util.isString(message.input[i]))
                return "input: string[] expected";
          }
          if (message.output != null && message.hasOwnProperty("output")) {
            if (!Array.isArray(message.output))
              return "output: array expected";
            for (var i = 0; i < message.output.length; ++i)
              if (!$util.isString(message.output[i]))
                return "output: string[] expected";
          }
          if (message.attribute != null && message.hasOwnProperty("attribute")) {
            if (!Array.isArray(message.attribute))
              return "attribute: array expected";
            for (var i = 0; i < message.attribute.length; ++i)
              if (!$util.isString(message.attribute[i]))
                return "attribute: string[] expected";
          }
          if (message.attributeProto != null && message.hasOwnProperty("attributeProto")) {
            if (!Array.isArray(message.attributeProto))
              return "attributeProto: array expected";
            for (var i = 0; i < message.attributeProto.length; ++i) {
              var error = $root.onnx.AttributeProto.verify(message.attributeProto[i]);
              if (error)
                return "attributeProto." + error;
            }
          }
          if (message.node != null && message.hasOwnProperty("node")) {
            if (!Array.isArray(message.node))
              return "node: array expected";
            for (var i = 0; i < message.node.length; ++i) {
              var error = $root.onnx.NodeProto.verify(message.node[i]);
              if (error)
                return "node." + error;
            }
          }
          if (message.docString != null && message.hasOwnProperty("docString")) {
            if (!$util.isString(message.docString))
              return "docString: string expected";
          }
          if (message.opsetImport != null && message.hasOwnProperty("opsetImport")) {
            if (!Array.isArray(message.opsetImport))
              return "opsetImport: array expected";
            for (var i = 0; i < message.opsetImport.length; ++i) {
              var error = $root.onnx.OperatorSetIdProto.verify(message.opsetImport[i]);
              if (error)
                return "opsetImport." + error;
            }
          }
          if (message.domain != null && message.hasOwnProperty("domain")) {
            if (!$util.isString(message.domain))
              return "domain: string expected";
          }
          return null;
        };
        FunctionProto.fromObject = function fromObject(object) {
          if (object instanceof $root.onnx.FunctionProto)
            return object;
          var message = new $root.onnx.FunctionProto();
          if (object.name != null)
            message.name = String(object.name);
          if (object.input) {
            if (!Array.isArray(object.input))
              throw TypeError(".onnx.FunctionProto.input: array expected");
            message.input = [];
            for (var i = 0; i < object.input.length; ++i)
              message.input[i] = String(object.input[i]);
          }
          if (object.output) {
            if (!Array.isArray(object.output))
              throw TypeError(".onnx.FunctionProto.output: array expected");
            message.output = [];
            for (var i = 0; i < object.output.length; ++i)
              message.output[i] = String(object.output[i]);
          }
          if (object.attribute) {
            if (!Array.isArray(object.attribute))
              throw TypeError(".onnx.FunctionProto.attribute: array expected");
            message.attribute = [];
            for (var i = 0; i < object.attribute.length; ++i)
              message.attribute[i] = String(object.attribute[i]);
          }
          if (object.attributeProto) {
            if (!Array.isArray(object.attributeProto))
              throw TypeError(".onnx.FunctionProto.attributeProto: array expected");
            message.attributeProto = [];
            for (var i = 0; i < object.attributeProto.length; ++i) {
              if (typeof object.attributeProto[i] !== "object")
                throw TypeError(".onnx.FunctionProto.attributeProto: object expected");
              message.attributeProto[i] = $root.onnx.AttributeProto.fromObject(object.attributeProto[i]);
            }
          }
          if (object.node) {
            if (!Array.isArray(object.node))
              throw TypeError(".onnx.FunctionProto.node: array expected");
            message.node = [];
            for (var i = 0; i < object.node.length; ++i) {
              if (typeof object.node[i] !== "object")
                throw TypeError(".onnx.FunctionProto.node: object expected");
              message.node[i] = $root.onnx.NodeProto.fromObject(object.node[i]);
            }
          }
          if (object.docString != null)
            message.docString = String(object.docString);
          if (object.opsetImport) {
            if (!Array.isArray(object.opsetImport))
              throw TypeError(".onnx.FunctionProto.opsetImport: array expected");
            message.opsetImport = [];
            for (var i = 0; i < object.opsetImport.length; ++i) {
              if (typeof object.opsetImport[i] !== "object")
                throw TypeError(".onnx.FunctionProto.opsetImport: object expected");
              message.opsetImport[i] = $root.onnx.OperatorSetIdProto.fromObject(object.opsetImport[i]);
            }
          }
          if (object.domain != null)
            message.domain = String(object.domain);
          return message;
        };
        FunctionProto.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.arrays || options.defaults) {
            object.input = [];
            object.output = [];
            object.attribute = [];
            object.node = [];
            object.opsetImport = [];
            object.attributeProto = [];
          }
          if (options.defaults) {
            object.name = "";
            object.docString = "";
            object.domain = "";
          }
          if (message.name != null && message.hasOwnProperty("name"))
            object.name = message.name;
          if (message.input && message.input.length) {
            object.input = [];
            for (var j = 0; j < message.input.length; ++j)
              object.input[j] = message.input[j];
          }
          if (message.output && message.output.length) {
            object.output = [];
            for (var j = 0; j < message.output.length; ++j)
              object.output[j] = message.output[j];
          }
          if (message.attribute && message.attribute.length) {
            object.attribute = [];
            for (var j = 0; j < message.attribute.length; ++j)
              object.attribute[j] = message.attribute[j];
          }
          if (message.node && message.node.length) {
            object.node = [];
            for (var j = 0; j < message.node.length; ++j)
              object.node[j] = $root.onnx.NodeProto.toObject(message.node[j], options);
          }
          if (message.docString != null && message.hasOwnProperty("docString"))
            object.docString = message.docString;
          if (message.opsetImport && message.opsetImport.length) {
            object.opsetImport = [];
            for (var j = 0; j < message.opsetImport.length; ++j)
              object.opsetImport[j] = $root.onnx.OperatorSetIdProto.toObject(message.opsetImport[j], options);
          }
          if (message.domain != null && message.hasOwnProperty("domain"))
            object.domain = message.domain;
          if (message.attributeProto && message.attributeProto.length) {
            object.attributeProto = [];
            for (var j = 0; j < message.attributeProto.length; ++j)
              object.attributeProto[j] = $root.onnx.AttributeProto.toObject(message.attributeProto[j], options);
          }
          return object;
        };
        FunctionProto.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        FunctionProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/onnx.FunctionProto";
        };
        return FunctionProto;
      }();
      return onnx6;
    }();
    module2.exports = $root;
  }
});

// web/lib/onnxjs/util.ts
function assert(expr, msg) {
  if (!expr) {
    throw new Error(typeof msg === "string" ? msg : msg());
  }
}
function decodeUtf8String(buffer) {
  return new TextDecoder().decode(buffer);
}
var import_onnx, ArrayUtil, MatMulUtil, BroadcastUtil, GemmUtil, ProtoUtil, LongUtil, ShapeUtil, SplitUtil, PoolConvUtil, MIN_CLIP, MAX_CLIP;
var init_util = __esm({
  "web/lib/onnxjs/util.ts"() {
    "use strict";
    init_flatbuffers();
    init_long();
    import_onnx = __toESM(require_onnx());
    init_tensor2();
    ArrayUtil = class {
      /**
       * Verifies if 2 input arrays contain the same elements.
       * @param n1 Array 1
       * @param n2 Array 2
       * @returns Whether these 2 are equal
       */
      static arraysEqual(n1, n2) {
        if (n1.length !== n2.length) {
          return false;
        }
        for (let i = 0; i < n1.length; i++) {
          if (n1[i] !== n2[i]) {
            return false;
          }
        }
        return true;
      }
    };
    MatMulUtil = class {
      /**
       * Fix the input shapes for MatMul operation if they need fixing
       * @param dimsA The shape of tensor A. Should be an array of positive integers
       * @param dimsB The shape of tensor B. Should be an array of positive integers
       * @returns A tuple containing the preprocessed input shapes as required by ONNX specifications
       */
      static preprocessInputShapes(dimsA, dimsB) {
        const a = dimsA.length === 1 ? [1, dimsA[0]] : dimsA;
        const b = dimsB.length === 1 ? [dimsB[0], 1] : dimsB;
        return [a, b];
      }
      /**
       * Fix the output shape computed for MatMul operation if it needs fixing
       * @param outputShape The computed outputShape. Should be an array (atleast of length 2) of positive integers.
       * This will be mutated.
       * @param aRank The rank of tensor A.
       * @param bRank The rank of tensor B.
       */
      static postprocessOutputShape(outputShape, aRank, bRank) {
        if (aRank === 1) {
          outputShape.splice(outputShape.length - 2, 1);
        }
        if (bRank === 1) {
          outputShape.pop();
        }
      }
      /**
       * Calculate the expected shape when matrix multiplication
       * @param a The shape of tensor A. Should be a tuple of 2 positive integers
       * @param b The shape of tensor B. Should be a tuple of 2 positive integers
       * @returns The expected shape of the result, or undefined if N/A
       */
      static calcMatMulShape(a, b) {
        return a[1] !== b[0] ? void 0 : [a[0], b[1]];
      }
    };
    BroadcastUtil = class _BroadcastUtil {
      /**
       * Calculate the expected shape when broadcasting 2 tensors
       * @param a The shape of tensor A. Should be an array of positive integers
       * @param b The shape of tensor B. Should be an array of positive integers
       * @param isMatMul Whether the operation is MatMul
       * @returns The expected shape of the result, or undefined if N/A
       */
      static calcShape(adims, bdims, isMatMul = false) {
        const arank = adims.length;
        const brank = bdims.length;
        if (arank === 0) {
          return bdims;
        }
        if (brank === 0) {
          return adims;
        }
        const crank = Math.max(adims.length, bdims.length);
        const cdims = new Array(crank);
        if (isMatMul) {
          if (arank < 2 || brank < 2) {
            return void 0;
          }
          const cShapeMatMul = MatMulUtil.calcMatMulShape([adims[arank - 2], adims[arank - 1]], [bdims[brank - 2], bdims[brank - 1]]);
          if (cShapeMatMul === void 0) {
            return void 0;
          }
          [cdims[crank - 2], cdims[crank - 1]] = cShapeMatMul;
        }
        for (let i = isMatMul ? 3 : 1; i <= crank; i++) {
          const aLen = arank - i < 0 ? 1 : adims[arank - i];
          const bLen = brank - i < 0 ? 1 : bdims[brank - i];
          if (aLen !== bLen && aLen > 1 && bLen > 1) {
            return void 0;
          }
          cdims[crank - i] = Math.max(aLen, bLen);
        }
        return cdims;
      }
      /**
       * Given the indices of a broadcasted tensor, calculate the original indices
       * @param broadcastedIndices The given indices of the broadcasted tensor.
       * @param originalShape The original shape of the tensor before broadcas
       * @returns The calculated indices that maps to the original tensor.
       */
      static index(broadcastedIndices, originalShape) {
        const originalIndices = new Array(originalShape.length);
        _BroadcastUtil.fillIndex(broadcastedIndices, originalShape, originalIndices);
        return originalIndices;
      }
      /**
       * Given the indices of a broadcasted tensor, calculate the original indices
       * @param broadcastedIndices The given indices of the broadcasted tensor.
       * @param originalShape The original shape of the tensor before broadcast
       * @param originalIndices The mapping of broadcastedIndices to the originalIndices (output parameter - will be
       *     mutated).
       */
      static fillIndex(broadcastedIndices, originalShape, originalIndices) {
        const dimOffset = broadcastedIndices.length - originalShape.length;
        for (let i = 0; i < originalShape.length; i++) {
          originalIndices[i] = broadcastedIndices[dimOffset + i] % originalShape[i];
        }
      }
      /**
       * Perform the broadcasting operation on the specific operator
       * @param a The input tensor A
       * @param b The input tensor B
       * @param op The operator lambda function
       * @param inplace Whether to write the result back to A.
       * @returns The result tensor, or undefined if input not broadcastable.
       */
      static calc(a, b, op, inplace, resultType) {
        const outputShape = _BroadcastUtil.calcShape(a.dims, b.dims);
        if (outputShape) {
          if (inplace && !ShapeUtil.areEqual(outputShape, a.dims)) {
            return void 0;
          }
          const size = ShapeUtil.size(outputShape);
          const c = inplace ? a : new Tensor3(outputShape, resultType || a.type);
          if (outputShape.length === 0) {
            c.set([], op(a.get([]), b.get([])));
          } else {
            const outputIndices = new Array(outputShape.length);
            const originalIndicesA = new Array(a.dims.length);
            const originalIndicesB = new Array(b.dims.length);
            let valA = 0;
            let valB = 0;
            let isAScalar = false;
            let isBScalar = false;
            if (a.dims.length === 0) {
              valA = a.get([]);
              isAScalar = true;
            }
            if (b.dims.length === 0) {
              valB = b.get([]);
              isBScalar = true;
            }
            let rest;
            for (let i = 0; i < size; i++) {
              rest = i;
              for (let j = outputShape.length - 1; j >= 0; j--) {
                outputIndices[j] = rest % outputShape[j];
                rest = Math.floor(rest / outputShape[j]);
              }
              if (!isAScalar) {
                _BroadcastUtil.fillIndex(outputIndices, a.dims, originalIndicesA);
                valA = a.get(originalIndicesA);
              }
              if (!isBScalar) {
                _BroadcastUtil.fillIndex(outputIndices, b.dims, originalIndicesB);
                valB = b.get(originalIndicesB);
              }
              c.set(outputIndices, op(valA, valB));
            }
          }
          return c;
        }
        return void 0;
      }
      /**
       * Determine if a shape is unidirectional broadcastable to another shape
       * @param shape The input shape
       * @param finalShape The desired shape after broadcasting
       */
      static isValidBroadcast(shape2, finalShape) {
        const inputRank = shape2.length;
        const finalRank = finalShape.length;
        if (inputRank > finalRank) {
          return false;
        }
        for (let i = 1; i <= inputRank; i++) {
          if (shape2[inputRank - i] !== 1 && shape2[inputRank - i] !== finalShape[finalRank - i]) {
            return false;
          }
        }
        return true;
      }
      /**
       * Determine the broadcasted dims in input shape based on the given output shape.
       * Note that this function only returns the broadcasted dims.
       * @param inputShape The input shape
       * @param outputShape The output shape
       * @returns The broadcasted dims in input shape.
       */
      static getBroadcastDims(inputShape, outputShape) {
        const inRank = inputShape.length;
        const dims = [];
        for (let i = 0; i < inRank; i++) {
          const dim = inRank - 1 - i;
          const a = inputShape[dim] || 1;
          const b = outputShape[outputShape.length - 1 - i] || 1;
          if (b > 1 && a === 1) {
            dims.unshift(dim);
          }
        }
        return dims;
      }
    };
    GemmUtil = class {
      // will make sure input shapes are compatible for this op
      // and return back the shape of the output in the form of a tuple
      // will throw exception if the input shapes are not compatible
      static getShapeOfGemmResult(leftShape, transLeft, rightShape, transRight, biasShape) {
        if (leftShape.length !== 2 || rightShape.length !== 2) {
          throw new Error("shape need to be of size 2");
        }
        let M;
        let K;
        let N;
        if (transLeft) {
          M = leftShape[1];
          K = leftShape[0];
        } else {
          M = leftShape[0];
          K = leftShape[1];
        }
        let kDim = -1;
        if (transRight) {
          N = rightShape[0];
          kDim = 1;
        } else {
          N = rightShape[1];
          kDim = 0;
        }
        if (rightShape[kDim] !== K) {
          throw new Error("dimension mismatch");
        }
        if (M <= 0 || N <= 0 || K <= 0) {
          throw new Error("invalid shape specified");
        }
        if (biasShape && !BroadcastUtil.isValidBroadcast(biasShape, [M, N])) {
          throw new Error("gemm: invalid bias shape for broadcast");
        }
        return [M, N, K];
      }
    };
    ProtoUtil = class _ProtoUtil {
      static tensorDataTypeFromProto(typeProto) {
        switch (typeProto) {
          case import_onnx.onnx.TensorProto.DataType.INT8:
            return "int8";
          case import_onnx.onnx.TensorProto.DataType.UINT8:
            return "uint8";
          case import_onnx.onnx.TensorProto.DataType.BOOL:
            return "bool";
          case import_onnx.onnx.TensorProto.DataType.INT16:
            return "int16";
          case import_onnx.onnx.TensorProto.DataType.UINT16:
            return "uint16";
          case import_onnx.onnx.TensorProto.DataType.INT32:
            return "int32";
          case import_onnx.onnx.TensorProto.DataType.UINT32:
            return "uint32";
          case import_onnx.onnx.TensorProto.DataType.FLOAT:
            return "float32";
          case import_onnx.onnx.TensorProto.DataType.DOUBLE:
            return "float64";
          case import_onnx.onnx.TensorProto.DataType.STRING:
            return "string";
          case import_onnx.onnx.TensorProto.DataType.INT64:
            return "int32";
          case import_onnx.onnx.TensorProto.DataType.UINT64:
            return "uint32";
          default:
            throw new Error(`unsupported data type: ${import_onnx.onnx.TensorProto.DataType[typeProto]}`);
        }
      }
      static tensorDataTypeStringToEnum(type) {
        switch (type) {
          case "int8":
            return import_onnx.onnx.TensorProto.DataType.INT8;
          case "uint8":
            return import_onnx.onnx.TensorProto.DataType.UINT8;
          case "bool":
            return import_onnx.onnx.TensorProto.DataType.BOOL;
          case "int16":
            return import_onnx.onnx.TensorProto.DataType.INT16;
          case "uint16":
            return import_onnx.onnx.TensorProto.DataType.UINT16;
          case "int32":
            return import_onnx.onnx.TensorProto.DataType.INT32;
          case "uint32":
            return import_onnx.onnx.TensorProto.DataType.UINT32;
          case "float32":
            return import_onnx.onnx.TensorProto.DataType.FLOAT;
          case "float64":
            return import_onnx.onnx.TensorProto.DataType.DOUBLE;
          case "string":
            return import_onnx.onnx.TensorProto.DataType.STRING;
          case "int64":
            return import_onnx.onnx.TensorProto.DataType.INT64;
          case "uint64":
            return import_onnx.onnx.TensorProto.DataType.UINT64;
          default:
            throw new Error(`unsupported data type: ${type}`);
        }
      }
      static tensorDimsFromProto(dims) {
        return dims.map((d) => long_default.isLong(d) ? d.toNumber() : d);
      }
      static tensorValueTypeFromProto(valueType) {
        return {
          tensorType: _ProtoUtil.tensorDataTypeFromProto(valueType.elemType),
          shape: { dims: _ProtoUtil.tensorDimsFromProto(valueType.shape.dim.map((d) => d.dimValue)) }
        };
      }
      static tensorDimsFromORTFormat(tensor) {
        const dims = [];
        for (let i = 0; i < tensor.dimsLength(); i++) {
          dims.push(LongUtil.longToNumber(tensor.dims(i)));
        }
        return dims;
      }
      static tensorAttributesFromORTFormat(node) {
        const attributes = [];
        for (let i = 0; i < node.attributesLength(); i++) {
          attributes.push(node.attributes(i));
        }
        return attributes;
      }
    };
    LongUtil = class {
      // This function is called to get a number from long type of data for attribute, dim, and ir version,
      // which values are signed integers.
      // To make it more generic, add an optional paramter to convert to a unsigned number.
      static longToNumber(n, unsigned) {
        if (long_default.isLong(n)) {
          return n.toNumber();
        } else if (n instanceof flatbuffers.Long) {
          return long_default.fromValue({ low: n.low, high: n.high, unsigned: unsigned ?? false }).toNumber();
        }
        return n;
      }
      static isLong(n) {
        return long_default.isLong(n) || n instanceof flatbuffers.Long;
      }
    };
    ShapeUtil = class _ShapeUtil {
      static size(dims) {
        return _ShapeUtil.getSizeFromDimensionRange(dims, 0, dims.length);
      }
      // `axis` inclusive
      static sizeFromDimension(dims, axis) {
        if (axis < 0 || axis > dims.length) {
          throw new Error(`invalid dimension of ${axis} for sizeFromDimension as Tensor has ${dims.length} dimensions.`);
        }
        return _ShapeUtil.getSizeFromDimensionRange(dims, axis, dims.length);
      }
      // `axis` exclusive
      static sizeToDimension(dims, axis) {
        if (axis < 0 || axis > dims.length) {
          throw new Error(`invalid dimension of ${axis} for sizeToDimension as Tensor has ${dims.length} dimensions.`);
        }
        return _ShapeUtil.getSizeFromDimensionRange(dims, 0, axis);
      }
      static getSizeFromDimensionRange(dims, start, end) {
        let size = 1;
        for (let i = start; i < end; i++) {
          if (dims[i] <= 0) {
            throw new Error(
              // eslint-disable-next-line max-len
              "cannot get valid size from specified dimension range. Most likely the range contains 0 or negative values in them."
            );
          }
          size *= dims[i];
        }
        return size;
      }
      static computeStrides(dims) {
        const rank = dims.length;
        if (rank === 0) {
          return [];
        } else if (rank === 1) {
          return [1];
        }
        const strides = new Array(rank);
        strides[rank - 1] = 1;
        strides[rank - 2] = dims[rank - 1];
        for (let i = rank - 3; i >= 0; --i) {
          strides[i] = strides[i + 1] * dims[i + 1];
        }
        return strides;
      }
      static transpose(dims) {
        const copy = dims.slice();
        return copy.reverse();
      }
      static indicesToOffset(indices, strides, axis) {
        if (axis === void 0) {
          axis = indices.length;
        }
        let offset = 0;
        for (let i = 0; i < axis; ++i) {
          offset += strides[i] * indices[i];
        }
        return offset;
      }
      static offsetToIndices(offset, strides) {
        const rank = strides.length;
        if (rank === 0) {
          return [];
        } else if (rank === 1) {
          return [offset * strides[0]];
        }
        const indices = new Array(strides.length);
        for (let i = 0; i < indices.length - 1; ++i) {
          indices[i] = Math.floor(offset / strides[i]);
          offset -= indices[i] * strides[i];
        }
        indices[indices.length - 1] = offset;
        return indices;
      }
      /**
       * normailze axis of range [-r, r) into [0, r).
       */
      static normalizeAxis(axis, tensorRank) {
        if (axis < -tensorRank && axis >= tensorRank) {
          throw new Error("unsupported axis for this operation.");
        }
        return axis < 0 ? axis + tensorRank : axis;
      }
      static normalizeAxes(axes, tensorRank) {
        return axes.map((x) => this.normalizeAxis(x, tensorRank));
      }
      // Increment an index into a tensor (in lexicographic
      // ordering), wrapping around the specified upper_bound.
      /**
       * Increment an index into a tensor (in lexicographic ordering), wrapping around the specified upper_bound.
       * @param index Given index to increment (Will be mutated)
       * @param dims The dimensions of the tensor for which the given index corresponds to
       * @param axisToIncrementOn The 1-indexed axis to increment on. If undefined, axisToIncrementOn == rank
       */
      static incrementIndex(index, dims, axisToIncrementOn) {
        if (dims.length === 0 || index.length === 0) {
          throw new Error("Index incrementing unsupported for scalar Tensor");
        }
        if (axisToIncrementOn === void 0) {
          axisToIncrementOn = dims.length;
        } else {
          if (axisToIncrementOn <= 0 || axisToIncrementOn > dims.length) {
            throw new Error("Incorrect axis to increment on");
          }
        }
        for (let k = axisToIncrementOn - 1; k >= 0; --k) {
          index[k]++;
          if (index[k] < dims[k]) {
            break;
          }
          index[k] = 0;
        }
      }
      /**
       * Produces a new dimensions array based on the values in the 'originalDimensions' and 'shape' array
       * Used in Reshape
       * @param originalDims Original Shape array
       * @param shapeHints array containing values to compute the new dimensions
       * For example:
       * originalDims = [2,2] and shapeHints = [0,-1] will return [2,2]
       * originalDims = [2,2] and shapeHints = [4] will return [4]
       * originalDims = [2,2] and shapeHints = [5] will throw an exception
       * https://github.com/onnx/onnx/blob/main/docs/Operators.md#Reshape
       */
      static calculateReshapedDims(originalDims, shapeHints) {
        if (shapeHints.length === 0) {
          if (originalDims.length === 0 || _ShapeUtil.size(originalDims) === 1) {
            return [];
          } else {
            throw new Error("cannot reshape to a scalar Tensor");
          }
        }
        const nDims = shapeHints.length;
        const reshapedDims = new Array(nDims);
        let unknownDimension = -1;
        let newTensorSize = 1;
        for (let i = 0; i < nDims; i++) {
          if (shapeHints[i] < -1) {
            throw new Error("a dimension in shape hints cannot be less than -1");
          }
          if (shapeHints[i] === -1) {
            if (unknownDimension !== -1) {
              throw new Error("at most one dimension in shape hints can be -1");
            }
            unknownDimension = i;
          } else {
            if (shapeHints[i] === 0) {
              if (i >= originalDims.length) {
                throw new Error("the dimension with value zero exceeds the dimension size of the input tensor");
              }
              reshapedDims[i] = originalDims[i];
            } else {
              reshapedDims[i] = shapeHints[i];
            }
            newTensorSize *= reshapedDims[i];
          }
        }
        const oldTensorSize = _ShapeUtil.size(originalDims);
        if (unknownDimension !== -1) {
          if (oldTensorSize % newTensorSize !== 0) {
            throw new Error(`the input tensor cannot be reshaped to the requested shape. Input shape: [${originalDims}] Output shape: [${shapeHints}]`);
          }
          reshapedDims[unknownDimension] = oldTensorSize / newTensorSize;
        } else {
          if (newTensorSize !== oldTensorSize) {
            throw new Error("reshapedDims and originalDims don't have matching sizes");
          }
        }
        return reshapedDims;
      }
      /**
       * Sorts a given array based on the indices in the Perm array
       * Used in Transpose
       * @param a Array to be sorted such as dims or strides
       * @param perm Perm given; if null a will be reversed
       */
      static sortBasedOnPerm(a, perm) {
        if (perm) {
          return perm.map((v) => a[v]);
        } else {
          return a.slice().reverse();
        }
      }
      /**
       * Pads a given shape according to the padding values
       * @param dims shape of the Tensor to be padded
       * @param pad pad values
       */
      static padShape(dims, pad) {
        const rank = dims.length;
        return dims.map((v, i) => v + pad[i] + pad[i + rank]);
      }
      /**
       * Determines if the two shapes are identical
       * @param shape1
       * @param shape2
       */
      static areEqual(shape1, shape2) {
        if (shape1.length !== shape2.length) {
          return false;
        }
        return shape1.every((v, i) => v === shape2[i]);
      }
      /**
       * Validates if the given `dims` or `shape` is valid in ONNX.js context and returns data size
       * @param dims - input `dims` that needs to be checked
       */
      static validateDimsAndCalcSize(dims) {
        if (dims.length > 6) {
          throw new TypeError("Only rank 0 to 6 is supported for tensor shape.");
        }
        let size = 1;
        for (const n of dims) {
          if (!Number.isInteger(n)) {
            throw new TypeError(`Invalid shape: ${n} is not an integer`);
          }
          if (n < 0 || n > 2147483647) {
            throw new TypeError(`Invalid shape: length ${n} is not allowed`);
          }
          size *= n;
        }
        return size;
      }
      /**
       * Determines the shape of output tensor y = flatten(x, axis)
       * @param dims - shape of input tensor
       * @param axis - flatten axis, in the range [-r, r]
       */
      static flattenShape(dims, axis) {
        if (axis < 0) {
          axis += dims.length;
        }
        const total = dims.reduce((x, y) => x * y, 1);
        const right = dims.slice(axis).reduce((x, y) => x * y, 1);
        const outputDims = [total / right, right];
        return outputDims;
      }
      /**
       * Determines the shape of output tensor y = squeeze(x, axes)
       * @param dims - shape of input tensor
       * @param axes - squeeze axes
       */
      static squeezeShape(dims, axes) {
        const outputDims = new Array();
        axes = _ShapeUtil.normalizeAxes(axes, dims.length);
        for (let i = 0; i < dims.length; i++) {
          const inSqueezeList = axes.indexOf(i) >= 0;
          if (inSqueezeList && dims[i] !== 1) {
            throw new Error("squeeze an axis of size different than 1");
          }
          if (axes.length === 0 && dims[i] > 1 || axes.length > 0 && !inSqueezeList) {
            outputDims.push(dims[i]);
          }
        }
        return outputDims;
      }
      /**
       * Determines the shape of output tensor y = unsqueeze(x, axes)
       * @param dims - shape of input tensor
       * @param axes - unsqueeze axes
       */
      static unsqueezeShape(dims, axes) {
        const outputDims = new Array(dims.length + axes.length);
        outputDims.fill(0);
        for (let i = 0; i < axes.length; i++) {
          const axis = _ShapeUtil.normalizeAxis(axes[i], outputDims.length);
          if (axis >= outputDims.length) {
            throw new Error("'axes' has an out of range axis");
          }
          if (outputDims[axis] !== 0) {
            throw new Error("'axes' has a duplicate axis");
          }
          outputDims[axis] = 1;
        }
        let inputDimsIterator = 0;
        for (let i = 0; i < outputDims.length; i++) {
          if (outputDims[i] === 0) {
            outputDims[i] = dims[inputDimsIterator++];
          }
        }
        if (inputDimsIterator !== dims.length) {
          throw new Error("the unsqueezed dimension could not be established");
        }
        return outputDims;
      }
    };
    SplitUtil = class _SplitUtil {
      /**
       * Calculates new Shapes from existing one and the splits given along the axis provides
       * @param dims Shape of the Tensor to be splitted into two or more Shapes
       * @param axis The dimension along which the Tensor will be split
       * @param splits Offsets for the start of each split
       */
      static splitShape(dims, axis, split2, numOutputs) {
        if (split2.length === 0) {
          if (!numOutputs) {
            throw new Error("need to know number of outputs when the 'split' attribute is not specified");
          }
          _SplitUtil.determineSplit(dims[axis], numOutputs, split2);
        }
        const shapes = [];
        const offsets = [0];
        for (let i = 0; i < split2.length; ++i) {
          if (i !== 0) {
            offsets.push(offsets[i - 1] + split2[i - 1]);
          }
          const shape2 = dims.slice();
          shape2[axis] = split2[i];
          shapes.push(shape2);
        }
        return [shapes, offsets];
      }
      static determineSplit(numElementsAlongAxis, numOutputs, split2) {
        if (numElementsAlongAxis % numOutputs !== 0) {
          throw new Error("cannot split tensor to equal sized parts");
        }
        for (let i = 0; i < numOutputs; ++i) {
          split2.push(numElementsAlongAxis / numOutputs);
        }
      }
    };
    PoolConvUtil = class _PoolConvUtil {
      /**
       * Adjust the kernel, strides, pads to correct rank. Set to default value if not present
       * @param isGlobalOperator If true, perform global pooling.
       * @param inputDims The input tensor dimension.
       * @param kernelShape The size of the kernel along each axis.
       * @param strides Stride along each axis.
       * @param dilations Dilation along each axis.
       * @param pads Padding for the beginning and ending along each axis.
       */
      static adjustPoolAttributes(isGlobalOperator, inputDims, kernelShape, strides, dilations, pads) {
        if (!isGlobalOperator && kernelShape.length !== inputDims.length - 2) {
          throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");
        }
        if (isGlobalOperator) {
          for (let dim = 0; dim < inputDims.length - 2; dim++) {
            if (dim >= kernelShape.length) {
              kernelShape.push(inputDims[dim + 2]);
            } else {
              kernelShape[dim] = inputDims[dim + 2];
            }
          }
        }
        for (let dim = 0; dim < kernelShape.length; dim++) {
          if (dim < strides.length) {
            if (strides[dim] < 0) {
              throw new Error("strides should be greater than or equal to 1");
            }
          } else {
            strides.push(1);
          }
        }
        for (let dim = 0; dim < kernelShape.length; dim++) {
          if (dim < dilations.length) {
            if (dilations[dim] < 0) {
              throw new Error("dilations should be greater than or equal to 1");
            }
          } else {
            dilations.push(1);
          }
        }
        for (let dim = 0; dim < kernelShape.length * 2; dim++) {
          if (dim < pads.length) {
            if (pads[dim] < 0) {
              throw new Error("pad should be greater than or equal to 1");
            }
          } else {
            pads.push(0);
          }
        }
        for (let dim = 0; dim < kernelShape.length; dim++) {
          if (kernelShape[dim] <= 0) {
            throw new Error("kernel shapes need to be greater than 0");
          }
          if (pads[dim] >= kernelShape[dim] || pads[dim + kernelShape.length] >= kernelShape[dim]) {
            throw new Error("pads should be smaller than kernel");
          }
        }
      }
      // adjust pad values based on 'autoPad' attribute
      static adjustPadsBasedOnAutoPad(inputDims, strides, dilations, kernelShape, pads, autoPad) {
        if (!autoPad) {
          return;
        }
        if (pads.length !== 2 * (inputDims.length - 2)) {
          throw new Error("length of pads should be twice the length of data dimensions");
        }
        if (strides.length !== inputDims.length - 2) {
          throw new Error("length of strides should be the length of data dimensions");
        }
        if (kernelShape.length !== inputDims.length - 2) {
          throw new Error("length of kernel shapes should be the length of data dimensions");
        }
        for (let dim = 0; dim < inputDims.length - 2; dim++) {
          _PoolConvUtil.adjustPadAndReturnShape(
            inputDims[dim + 2],
            strides[dim],
            dilations[dim],
            kernelShape[dim],
            pads,
            dim,
            dim + inputDims.length - 2,
            autoPad
          );
        }
      }
      /**
       * Calculate the output shape for Pool ops based on input attributes. (Should be used only for Pool ops)
       * @param isGlobalOperator If true, perform global pooling.
       * @param inputDims The input tensor dimension. (inputs[0].dims)
       * @param strides Stride along each axis.
       * @param dilations Dilation along each axis.
       * @param kernelShape The size of the kernel along each axis.
       * @param pads Padding for the beginning and ending along each axis.
       * @param autoPad DEPRECATED attribute supported for legacy models. Specifies how to implicitly calculate pads in each
       *     dimension. Can take values NOTSET, SAME_UPPER, SAME_LOWER, or VALID.
       */
      static computePoolOutputShape(isGlobalOperator, inputDims, strides, dilations, kernelShape, pads, autoPad) {
        if (inputDims.length <= 0) {
          throw new Error("input shape must be of size greater than 0");
        }
        const outputDims = [inputDims[0], inputDims[1]];
        _PoolConvUtil.computeShapeHelper(
          isGlobalOperator,
          inputDims,
          outputDims,
          strides,
          dilations,
          kernelShape,
          pads,
          autoPad
        );
        return outputDims;
      }
      /**
       * Calculate the output shape for Conv op based on input attributes. (Should be used only for Conv op)
       * @param inputDims The input tensor dimension. (inputs[0].dims)
       * @param filterDims The filter tensor dimension. (inputs[1].dims)
       * @param strides Stride along each axis.
       * @param kernelShape The size of the kernel along each axis.
       * @param pads Padding for the beginning and ending along each axis.
       * @param autoPad DEPRECATED attribute supported for legacy models. Specifies how to implicitly calculate pads in each
       *     dimension. Can take values NOTSET, SAME_UPPER, SAME_LOWER, or VALID.
       */
      static computeConvOutputShape(inputDims, filterDims, strides, dilations, kernelShape, pads, autoPad) {
        if (inputDims.length <= 0 || filterDims.length <= 0) {
          throw new Error("invalid input tensor dims or invalid filter tensor dims");
        }
        const outputDims = [inputDims[0], filterDims[0]];
        _PoolConvUtil.computeShapeHelper(false, inputDims, outputDims, strides, dilations, kernelShape, pads, autoPad);
        return outputDims;
      }
      // will compute output shapes for data dimensions ONLY (i.e.) no batch size and channels
      // called by computePoolOutputShape() and computeConvOutputShape()
      // adjust pads based on 'autoPad' attribute prior to shape computation
      static computeShapeHelper(isGlobalOperator, inputDims, outputDims, strides, dilations, kernelShape, pads, autoPad) {
        if (isGlobalOperator) {
          for (let dim = 0; dim < inputDims.length - 2; dim++) {
            outputDims.push(1);
          }
        } else {
          for (let dim = 0; dim < inputDims.length - 2; dim++) {
            outputDims.push(_PoolConvUtil.adjustPadAndReturnShape(
              inputDims[dim + 2],
              strides[dim],
              dilations[dim],
              kernelShape[dim],
              pads,
              dim,
              dim + inputDims.length - 2,
              autoPad
            ));
          }
        }
      }
      // helper for computeShapeHelper() and adjustPadsBasedOnAutoPad()
      // adjusts pad value for given 'autoPad' string and computes output shape along a particular dimension
      static adjustPadAndReturnShape(inSize, stride, dilation, kernel, pads, padHeadIndex, padTailIndex, autoPad) {
        const dkernel = dilation * (kernel - 1) + 1;
        if (autoPad && autoPad !== "NOTSET") {
          switch (autoPad) {
            case "VALID":
              pads[padHeadIndex] = 0;
              pads[padTailIndex] = 0;
              return Math.floor((inSize - dkernel) / stride + 1);
            case "SAME_LOWER":
            case "SAME_UPPER":
              if (dilation !== 1) {
                throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");
              } else {
                const legacyTargetSize = (inSize + stride - 1) / stride;
                const padNeeded = (legacyTargetSize - 1) * stride + kernel - inSize;
                pads[padHeadIndex] = autoPad === "SAME_LOWER" ? Math.floor((padNeeded + 1) / 2) : Math.floor(padNeeded / 2);
                pads[padTailIndex] = padNeeded - pads[padHeadIndex];
                return Math.floor((inSize + padNeeded - kernel) / stride + 1);
              }
            default:
              throw new Error("Unsupported AutoPad type");
          }
        } else {
          return Math.floor((inSize + pads[padHeadIndex] + pads[padTailIndex] - dkernel) / stride + 1);
        }
      }
    };
    MIN_CLIP = -34028234663852886e22;
    MAX_CLIP = 34028234663852886e22;
  }
});

// web/lib/onnxjs/tensor.ts
function sizeof(type) {
  switch (type) {
    case "bool":
    case "int8":
    case "uint8":
      return 1;
    case "int16":
    case "uint16":
      return 2;
    case "int32":
    case "uint32":
    case "float32":
      return 4;
    case "float64":
      return 8;
    default:
      throw new Error(`cannot calculate sizeof() on type ${type}`);
  }
}
function sizeofProto(type) {
  switch (type) {
    case import_onnx2.onnx.TensorProto.DataType.UINT8:
    case import_onnx2.onnx.TensorProto.DataType.INT8:
    case import_onnx2.onnx.TensorProto.DataType.BOOL:
      return 1;
    case import_onnx2.onnx.TensorProto.DataType.UINT16:
    case import_onnx2.onnx.TensorProto.DataType.INT16:
      return 2;
    case import_onnx2.onnx.TensorProto.DataType.FLOAT:
    case import_onnx2.onnx.TensorProto.DataType.INT32:
    case import_onnx2.onnx.TensorProto.DataType.UINT32:
      return 4;
    case import_onnx2.onnx.TensorProto.DataType.INT64:
    case import_onnx2.onnx.TensorProto.DataType.DOUBLE:
    case import_onnx2.onnx.TensorProto.DataType.UINT64:
      return 8;
    default:
      throw new Error(`cannot calculate sizeof() on type ${import_onnx2.onnx.TensorProto.DataType[type]}`);
  }
}
function createView(dataBuffer, type) {
  return new (dataviewConstructor(type))(dataBuffer);
}
function dataviewConstructor(type) {
  switch (type) {
    case "bool":
    case "uint8":
      return Uint8Array;
    case "int8":
      return Int8Array;
    case "int16":
      return Int16Array;
    case "uint16":
      return Uint16Array;
    case "int32":
      return Int32Array;
    case "uint32":
      return Uint32Array;
    case "int64":
      return BigInt64Array;
    case "float32":
      return Float32Array;
    case "float64":
      return Float64Array;
    default:
      throw new Error("unspecified error");
  }
}
function longToNumber(i, type) {
  if (type === import_onnx2.onnx.TensorProto.DataType.INT64 || type === ortFbs.TensorDataType.INT64) {
    if (i.greaterThanOrEqual(2147483648) || i.lessThan(-2147483648)) {
      throw new TypeError("int64 is not supported");
    }
  } else if (type === import_onnx2.onnx.TensorProto.DataType.UINT32 || type === ortFbs.TensorDataType.UINT32 || type === import_onnx2.onnx.TensorProto.DataType.UINT64 || type === ortFbs.TensorDataType.UINT64) {
    if (i.greaterThanOrEqual(4294967296) || i.lessThan(0)) {
      throw new TypeError("uint64 is not supported");
    }
  } else {
    throw new TypeError(`not a LONG type: ${import_onnx2.onnx.TensorProto.DataType[type]}`);
  }
  return i.toNumber();
}
function readProto(view, type, byteOffset) {
  switch (type) {
    case import_onnx2.onnx.TensorProto.DataType.BOOL:
    case import_onnx2.onnx.TensorProto.DataType.UINT8:
      return view.getUint8(byteOffset);
    case import_onnx2.onnx.TensorProto.DataType.INT8:
      return view.getInt8(byteOffset);
    case import_onnx2.onnx.TensorProto.DataType.UINT16:
      return view.getUint16(byteOffset, true);
    case import_onnx2.onnx.TensorProto.DataType.INT16:
      return view.getInt16(byteOffset, true);
    case import_onnx2.onnx.TensorProto.DataType.FLOAT:
      return view.getFloat32(byteOffset, true);
    case import_onnx2.onnx.TensorProto.DataType.INT32:
      return view.getInt32(byteOffset, true);
    case import_onnx2.onnx.TensorProto.DataType.UINT32:
      return view.getUint32(byteOffset, true);
    case import_onnx2.onnx.TensorProto.DataType.INT64:
      return longToNumber(
        long_default.fromBits(view.getUint32(byteOffset, true), view.getUint32(byteOffset + 4, true), false),
        type
      );
    case import_onnx2.onnx.TensorProto.DataType.DOUBLE:
      return view.getFloat64(byteOffset, true);
    case import_onnx2.onnx.TensorProto.DataType.UINT64:
      return longToNumber(
        long_default.fromBits(view.getUint32(byteOffset, true), view.getUint32(byteOffset + 4, true), true),
        type
      );
    default:
      throw new Error(`cannot read from DataView for type ${import_onnx2.onnx.TensorProto.DataType[type]}`);
  }
}
var import_guid_typescript, import_onnx2, ortFbs, Tensor3;
var init_tensor2 = __esm({
  "web/lib/onnxjs/tensor.ts"() {
    "use strict";
    import_guid_typescript = __toESM(require_guid());
    init_long();
    init_ort_generated();
    import_onnx2 = __toESM(require_onnx());
    init_util();
    ortFbs = onnxruntime.experimental.fbs;
    Tensor3 = class _Tensor {
      constructor(dims, type, dataProvider, asyncDataProvider, cache2, dataId = import_guid_typescript.Guid.create()) {
        this.dims = dims;
        this.type = type;
        this.dataProvider = dataProvider;
        this.asyncDataProvider = asyncDataProvider;
        this.cache = cache2;
        this.dataId = dataId;
        this.size = ShapeUtil.validateDimsAndCalcSize(dims);
        const size = this.size;
        const empty = dataProvider === void 0 && asyncDataProvider === void 0 && cache2 === void 0;
        if (cache2 !== void 0) {
          if (cache2.length !== size) {
            throw new RangeError("Input dims doesn't match data length.");
          }
        }
        if (type === "string") {
          if (cache2 !== void 0 && (!Array.isArray(cache2) || !cache2.every((i) => typeof i === "string"))) {
            throw new TypeError("cache should be a string array");
          }
          if (empty) {
            this.cache = new Array(size);
          }
        } else {
          if (cache2 !== void 0) {
            const constructor = dataviewConstructor(type);
            if (!(cache2 instanceof constructor)) {
              throw new TypeError(`cache should be type ${constructor.name}`);
            }
          }
          if (empty) {
            const buf = new ArrayBuffer(size * sizeof(type));
            this.cache = createView(buf, type);
          }
        }
      }
      /**
       * get the underlying tensor data
       */
      get data() {
        if (this.cache === void 0) {
          const data = this.dataProvider(this.dataId);
          if (data.length !== this.size) {
            throw new Error("Length of data provided by the Data Provider is inconsistent with the dims of this Tensor.");
          }
          this.cache = data;
        }
        return this.cache;
      }
      /**
       * get the underlying string tensor data. Should only use when type is STRING
       */
      get stringData() {
        if (this.type !== "string") {
          throw new TypeError("data type is not string");
        }
        return this.data;
      }
      /**
       * get the underlying integer tensor data. Should only use when type is one of the following: (UINT8, INT8, UINT16,
       * INT16, INT32, UINT32, BOOL)
       */
      get integerData() {
        switch (this.type) {
          case "uint8":
          case "int8":
          case "uint16":
          case "int16":
          case "int32":
          case "uint32":
          case "bool":
            return this.data;
          default:
            throw new TypeError("data type is not integer (uint8, int8, uint16, int16, int32, uint32, bool)");
        }
      }
      /**
       * get the underlying float tensor data. Should only use when type is one of the following: (FLOAT, DOUBLE)
       */
      get floatData() {
        switch (this.type) {
          case "float32":
          case "float64":
            return this.data;
          default:
            throw new TypeError("data type is not float (float32, float64)");
        }
      }
      /**
       * get the underlying number tensor data. Should only use when type is one of the following: (UINT8, INT8, UINT16,
       * INT16, INT32, UINT32, BOOL, FLOAT, DOUBLE)
       */
      get numberData() {
        if (this.type !== "string") {
          return this.data;
        }
        throw new TypeError("type cannot be non-number (string)");
      }
      /**
       * get value of an element at the given indices
       */
      get(indices) {
        return this.data[ShapeUtil.indicesToOffset(indices, this.strides)];
      }
      /**
       * set value of an element at the given indices
       */
      set(indices, value) {
        this.data[ShapeUtil.indicesToOffset(indices, this.strides)] = value;
      }
      /**
       * get the underlying tensor data asynchronously
       */
      async getData() {
        if (this.cache === void 0) {
          this.cache = await this.asyncDataProvider(this.dataId);
        }
        return this.cache;
      }
      /**
       * get the strides for each dimension
       */
      get strides() {
        if (!this._strides) {
          this._strides = ShapeUtil.computeStrides(this.dims);
        }
        return this._strides;
      }
      /**
       * Construct new Tensor from a ONNX Tensor object
       * @param tensorProto the ONNX Tensor
       */
      static fromProto(tensorProto) {
        if (!tensorProto) {
          throw new Error("cannot construct Value from an empty tensor");
        }
        const type = ProtoUtil.tensorDataTypeFromProto(tensorProto.dataType);
        const dims = ProtoUtil.tensorDimsFromProto(tensorProto.dims);
        const value = new _Tensor(dims, type);
        if (type === "string") {
          tensorProto.stringData.forEach((str, i) => {
            value.data[i] = decodeUtf8String(str);
          });
        } else if (tensorProto.rawData && typeof tensorProto.rawData.byteLength === "number" && tensorProto.rawData.byteLength > 0) {
          const dataDest = value.data;
          const dataSource = new DataView(tensorProto.rawData.buffer, tensorProto.rawData.byteOffset, tensorProto.rawData.byteLength);
          const elementSize = sizeofProto(tensorProto.dataType);
          const length = tensorProto.rawData.byteLength / elementSize;
          if (tensorProto.rawData.byteLength % elementSize !== 0) {
            throw new Error("invalid buffer length");
          }
          if (dataDest.length !== length) {
            throw new Error("buffer length mismatch");
          }
          for (let i = 0; i < length; i++) {
            const n = readProto(dataSource, tensorProto.dataType, i * elementSize);
            dataDest[i] = n;
          }
        } else {
          let array;
          switch (tensorProto.dataType) {
            case import_onnx2.onnx.TensorProto.DataType.FLOAT:
              array = tensorProto.floatData;
              break;
            case import_onnx2.onnx.TensorProto.DataType.INT32:
            case import_onnx2.onnx.TensorProto.DataType.INT16:
            case import_onnx2.onnx.TensorProto.DataType.UINT16:
            case import_onnx2.onnx.TensorProto.DataType.INT8:
            case import_onnx2.onnx.TensorProto.DataType.UINT8:
            case import_onnx2.onnx.TensorProto.DataType.BOOL:
              array = tensorProto.int32Data;
              break;
            case import_onnx2.onnx.TensorProto.DataType.INT64:
              array = tensorProto.int64Data;
              break;
            case import_onnx2.onnx.TensorProto.DataType.DOUBLE:
              array = tensorProto.doubleData;
              break;
            case import_onnx2.onnx.TensorProto.DataType.UINT32:
            case import_onnx2.onnx.TensorProto.DataType.UINT64:
              array = tensorProto.uint64Data;
              break;
            default:
              throw new Error("unspecific error");
          }
          if (array === null || array === void 0) {
            throw new Error("failed to populate data from a tensorproto value");
          }
          const data = value.data;
          if (data.length !== array.length) {
            throw new Error("array length mismatch");
          }
          for (let i = 0; i < array.length; i++) {
            const element = array[i];
            if (long_default.isLong(element)) {
              data[i] = longToNumber(element, tensorProto.dataType);
            } else {
              data[i] = element;
            }
          }
        }
        return value;
      }
      /**
       * Construct new Tensor from raw data
       * @param data the raw data object. Should be a string array for 'string' tensor, and the corresponding typed array
       * for other types of tensor.
       * @param dims the dimensions of the tensor
       * @param type the type of the tensor
       */
      static fromData(data, dims, type) {
        return new _Tensor(dims, type, void 0, void 0, data);
      }
      static fromOrtTensor(ortTensor) {
        if (!ortTensor) {
          throw new Error("cannot construct Value from an empty tensor");
        }
        const dims = ProtoUtil.tensorDimsFromORTFormat(ortTensor);
        const type = ProtoUtil.tensorDataTypeFromProto(ortTensor.dataType());
        const value = new _Tensor(dims, type);
        if (type === "string") {
          for (let i = 0; i < ortTensor.stringDataLength(); i++) {
            value.data[i] = ortTensor.stringData(i);
          }
        } else if (ortTensor.rawDataArray() && typeof ortTensor.rawDataLength() === "number" && ortTensor.rawDataLength() > 0) {
          const dataDest = value.data;
          const dataSource = new DataView(
            ortTensor.rawDataArray().buffer,
            ortTensor.rawDataArray().byteOffset,
            ortTensor.rawDataLength()
          );
          const elementSize = sizeofProto(ortTensor.dataType());
          const length = ortTensor.rawDataLength() / elementSize;
          if (ortTensor.rawDataLength() % elementSize !== 0) {
            throw new Error("invalid buffer length");
          }
          if (dataDest.length !== length) {
            throw new Error("buffer length mismatch");
          }
          for (let i = 0; i < length; i++) {
            const n = readProto(dataSource, ortTensor.dataType(), i * elementSize);
            dataDest[i] = n;
          }
        }
        return value;
      }
    };
  }
});

// web/lib/onnxjs/backends/webgl/glsl-source.ts
function getGlsl(version3) {
  return version3 === 1 ? GLSL_ES_2_0 : GLSL_ES_3_0;
}
function getVertexShaderSource(version3) {
  const glsl = getGlsl(version3);
  return `${glsl.version}
      precision highp float;
      ${glsl.attribute} vec3 position;
      ${glsl.attribute} vec2 textureCoord;

      ${glsl.varyingVertex} vec2 TexCoords;

      void main()
      {
          gl_Position = vec4(position, 1.0);
          TexCoords = textureCoord;
      }`;
}
function getFragShaderPreamble(version3) {
  const glsl = getGlsl(version3);
  return `${glsl.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${glsl.varyingFrag} vec2 TexCoords;
    ${glsl.outputDeclaration}
    const vec2 halfCR = vec2(0.5, 0.5);

    // Custom vector types to handle higher dimenalities.
    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    `;
}
function getDefaultFragShaderMain(version3, outputShapeLength) {
  const glsl = getGlsl(version3);
  return `
  void main() {
    int indices[${outputShapeLength}];
    toVec(TexCoords, indices);
    vec4 result = vec4(process(indices));
    ${glsl.output} = result;
  }
  `;
}
var GLSL_ES_2_0, GLSL_ES_3_0;
var init_glsl_source = __esm({
  "web/lib/onnxjs/backends/webgl/glsl-source.ts"() {
    "use strict";
    GLSL_ES_2_0 = {
      version: "",
      attribute: "attribute",
      varyingVertex: "varying",
      varyingFrag: "varying",
      texture2D: "texture2D",
      output: "gl_FragColor",
      outputDeclaration: ""
    };
    GLSL_ES_3_0 = {
      version: "#version 300 es",
      attribute: "in",
      varyingVertex: "out",
      varyingFrag: "in",
      texture2D: "texture",
      output: "outputColor",
      outputDeclaration: "out vec4 outputColor;"
    };
  }
});

// web/lib/onnxjs/backends/webgl/types.ts
var init_types = __esm({
  "web/lib/onnxjs/backends/webgl/types.ts"() {
    "use strict";
  }
});

// web/lib/onnxjs/backends/webgl/utils.ts
async function repeatedTry(checkFn, delayFn = (_counter) => 0, maxCounter) {
  return new Promise((resolve, reject) => {
    let tryCount = 0;
    const tryFn = () => {
      if (checkFn()) {
        resolve();
        return;
      }
      tryCount++;
      const nextBackoff = delayFn(tryCount);
      if (maxCounter != null && tryCount >= maxCounter) {
        reject();
        return;
      }
      setTimeout(tryFn, nextBackoff);
    };
    tryFn();
  });
}
function generateShaderFuncNameFromInputSamplerName(samplerName) {
  assert(typeof samplerName !== "undefined" && samplerName.length !== 0, () => "empty string found for sampler name");
  return "get" + samplerName.charAt(0).toUpperCase() + samplerName.slice(1);
}
function generateShaderFuncNameFromInputSamplerNameAtOutCoords(samplerName) {
  assert(typeof samplerName !== "undefined" && samplerName.length !== 0, () => "empty string found for sampler name");
  return "get" + samplerName.charAt(0).toUpperCase() + samplerName.slice(1) + "AtOutCoords";
}
function squeezeInputShape(inputShape, squeezedShape) {
  let newInputShape = JSON.parse(JSON.stringify(inputShape));
  newInputShape = squeezedShape;
  return newInputShape;
}
function getSqueezedParams(params, keptDims) {
  return keptDims.map((d) => params[d]).join(", ");
}
function getCoordsDataType(rank) {
  if (rank <= 1) {
    return "int";
  } else if (rank === 2) {
    return "ivec2";
  } else if (rank === 3) {
    return "ivec3";
  } else if (rank === 4) {
    return "ivec4";
  } else if (rank === 5) {
    return "ivec5";
  } else if (rank === 6) {
    return "ivec6";
  } else {
    throw Error(`GPU for rank ${rank} is not yet supported`);
  }
}
function getGlChannels(rank = 6) {
  return ["x", "y", "z", "w", "u", "v"].slice(0, rank);
}
var init_utils = __esm({
  "web/lib/onnxjs/backends/webgl/utils.ts"() {
    "use strict";
    init_util();
  }
});

// web/lib/onnxjs/backends/webgl/ops/packing-utils.ts
function getVecChannels(name2, rank) {
  return getGlChannels(rank).map((d) => `${name2}.${d}`);
}
function getChannels(name2, rank) {
  if (rank === 1) {
    return [name2];
  }
  return getVecChannels(name2, rank);
}
function unpackFromChannel() {
  return `
    float getChannel(vec4 frag, int dim) {
      int modCoord = imod(dim, 2);
      return modCoord == 0 ? frag.r : frag.g;
    }

    float getChannel(vec4 frag, vec2 innerDims) {
      vec2 modCoord = mod(innerDims, 2.);
      return modCoord.x == 0. ?
        (modCoord.y == 0. ? frag.r : frag.g) :
        (modCoord.y == 0. ? frag.b : frag.a);
    }
  `;
}
var init_packing_utils = __esm({
  "web/lib/onnxjs/backends/webgl/ops/packing-utils.ts"() {
    "use strict";
    init_utils();
  }
});

// web/lib/onnxjs/backends/webgl/ops/pack.ts
function getOutOfBoundsCondition(rank, shape2, dims) {
  if (rank === 0) {
    return "false";
  }
  if (rank === 1) {
    return `rc > ${shape2[0]}`;
  }
  let cond = "";
  for (let i = rank - 2; i < rank; i++) {
    cond += `${dims[i]} >= ${shape2[i - rank + 2]}`;
    if (i < rank - 1) {
      cond += "||";
    }
  }
  return cond;
}
function getOutput(shape2, dims) {
  const rank = shape2.length;
  if (rank === 0) {
    return "getA(), 0, 0, 0";
  }
  if (rank === 1) {
    return `getA(rc),
            rc + 1 >= ${shape2[0]} ? 0. : getA(rc + 1),
            0, 0`;
  }
  const coord00 = "r, c";
  const coord01 = "r, cp1";
  const coord10 = "rp1, c";
  const coord11 = "rp1, cp1";
  let D = "";
  if (rank > 2) {
    for (let i = 0; i < rank - 2; ++i) {
      D = D + `${dims[i]},`;
    }
  }
  return `getA(${D}${coord00}),
          rEdge ? 0. : getA(${D}${coord10}),
          cEdge ? 0. : getA(${D}${coord01}),
          rEdge || cEdge ? 0. : getA(${D}${coord11})`;
}
function getSetup(rank, dims, rows, cols) {
  if (rank === 0 || rank === 1) {
    return "";
  } else {
    const setup = `
    int r = ${dims[rank - 2]};
    int c = ${dims[rank - 1]};
    int rp1 = ${dims[rank - 2]} + 1;
    int cp1 = ${dims[rank - 1]} + 1;
    bool rEdge = rp1 >= ${cols};
    bool cEdge = cp1 >= ${rows};
    `;
    return setup;
  }
}
var packProgramMetadata, createPackProgramInfo, createPackProgramInfoLoader;
var init_pack = __esm({
  "web/lib/onnxjs/backends/webgl/ops/pack.ts"() {
    "use strict";
    init_glsl_source();
    init_types();
    init_utils();
    init_packing_utils();
    packProgramMetadata = {
      name: "pack",
      inputNames: ["A"],
      inputTypes: [1 /* unpackedReversed */]
    };
    createPackProgramInfo = (handler, input) => {
      const glsl = getGlsl(handler.session.backend.glContext.version);
      const inputShape = input.dims;
      const inputRank = inputShape.length;
      const outputRank = input.dims.length;
      const coordsDataType = getCoordsDataType(outputRank);
      const channels = getChannels("rc", outputRank);
      const setup = getSetup(outputRank, channels, inputShape[inputShape.length - 2], inputShape[inputShape.length - 1]);
      let reversedInputWH;
      if (inputRank === 0) {
        reversedInputWH = [1, 1];
      } else if (inputRank === 1) {
        reversedInputWH = [inputShape[0], 1];
      } else {
        reversedInputWH = [inputShape[outputRank - 1], inputShape[outputRank - 2]];
      }
      const outOfBoundsCondition = getOutOfBoundsCondition(outputRank, reversedInputWH, channels);
      const output = getOutput(inputShape, channels);
      const shaderSource = `
        void main() {
          ${coordsDataType} rc = getOutputCoords();

          if(${outOfBoundsCondition}) {
            ${glsl.output} = vec4(0);
          } else {
            ${setup}

            ${glsl.output} = vec4(${output});
          }
        }
      `;
      return {
        ...packProgramMetadata,
        hasMain: true,
        output: { dims: input.dims, type: input.type, textureType: 2 /* packed */ },
        shaderSource
      };
    };
    createPackProgramInfoLoader = (handler, input) => ({ ...packProgramMetadata, get: () => createPackProgramInfo(handler, input) });
  }
});

// web/lib/onnxjs/backends/webgl/ops/reshape-packed.ts
function processDims3D(shape2) {
  if (shape2.length === 0) {
    return [1, 1, 1];
  }
  let batch = 1;
  for (let i = 0; i < shape2.length - 2; ++i) {
    batch *= shape2[i];
  }
  return [batch, shape2.length > 1 ? shape2[shape2.length - 2] : 1, shape2[shape2.length - 1]];
}
function isReshapeCheap(dims, reshapedDims) {
  let isCheapReshape = false;
  if (dims.length === 0 || reshapedDims.length === 0) {
    isCheapReshape = true;
  } else if (dims.length < 2 || reshapedDims.length < 2) {
    isCheapReshape = dims[dims.length - 1] === reshapedDims[reshapedDims.length - 1];
  } else {
    isCheapReshape = dims[dims.length - 1] === reshapedDims[reshapedDims.length - 1] && dims[dims.length - 2] === reshapedDims[reshapedDims.length - 2];
  }
  return isCheapReshape;
}
function getReshapedInputCoords(shape2) {
  const strides = ShapeUtil.computeStrides(shape2);
  const coords = ["b", "r", "c"];
  const index = "index";
  const coordsFromIndexSnippet = strides.map((stride, i) => {
    const line1 = `int ${coords[i]} = ${index} / ${stride}`;
    const line2 = i === strides.length - 1 ? `int ${coords[i + 1]} = ${index} - ${coords[i]} * ${stride}` : `index -= ${coords[i]} * ${stride}`;
    return `${line1}; ${line2};`;
  }).join("");
  return `
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${coordsFromIndexSnippet}
      return ivec3(b, r, c);
    }
  `;
}
function getFlattenedIndexFrom3D(shape2) {
  const strides = ShapeUtil.computeStrides(shape2);
  return `
  int getFlattenedIndex(ivec3 coords) {
    // reverse y, z order
    return coords.x * ${strides[0]} + coords.z * ${strides[1]} + coords.y;
  }
`;
}
var createPackedReshape3DProgramMetadata, createPackedReshape3DProgramInfo, createPackedReshape3DProgramInfoLoader;
var init_reshape_packed = __esm({
  "web/lib/onnxjs/backends/webgl/ops/reshape-packed.ts"() {
    "use strict";
    init_util();
    init_glsl_source();
    init_types();
    init_packing_utils();
    createPackedReshape3DProgramMetadata = (outputShape3D) => ({ name: "Reshape (packed)", inputTypes: [2 /* packed */], inputNames: ["A"], cacheHint: `${outputShape3D}` });
    createPackedReshape3DProgramInfo = (handler, input3D, metadata, outputShape3D) => {
      const inputShape3D = input3D.dims;
      const squeezedOutputShape = outputShape3D;
      let mainLoop = "";
      for (let i = 0; i < 4; i++) {
        let outputCoords = "";
        switch (i) {
          case 0:
            outputCoords = "outputCoords = rc;";
            break;
          case 1:
            outputCoords = "outputCoords = ivec3(rc.x, rc.y+1, rc.z);";
            break;
          case 2:
            outputCoords = "outputCoords = ivec3(rc.x, rc.y, rc.z+1);";
            break;
          case 3:
            outputCoords = "outputCoords = ivec3(rc.x, rc.y+1, rc.z+1);";
            break;
          default:
            throw new Error();
        }
        mainLoop += `
        ${outputCoords}
        ${i > 0 ? "if(outputCoords.y < rows && outputCoords.z < cols){" : ""}
          int flattenedIndex = getFlattenedIndex(outputCoords);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flattenedIndex);
          vec2 innerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${i}] = getChannel(getA(inputRC.x, inputRC.y, inputRC.z), innerDims);

        ${i > 0 ? "}" : ""}
      `;
      }
      const glsl = getGlsl(handler.session.backend.glContext.version);
      const shaderSource = `
      ${getReshapedInputCoords(inputShape3D)}
      ${getFlattenedIndexFrom3D(squeezedOutputShape)}
      ${unpackFromChannel()}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.0);

        ivec3 outputCoords;
        int rows = ${squeezedOutputShape[2]};
        int cols = ${squeezedOutputShape[1]};

        ${mainLoop}
        ${glsl.output} = result;
      }
    `;
      return {
        ...metadata,
        output: { dims: squeezedOutputShape, type: input3D.type, textureType: 2 /* packed */ },
        shaderSource,
        hasMain: true
      };
    };
    createPackedReshape3DProgramInfoLoader = (handler, input3D, outputShape3D) => {
      const metadata = createPackedReshape3DProgramMetadata(outputShape3D);
      return { ...metadata, get: () => createPackedReshape3DProgramInfo(handler, input3D, metadata, outputShape3D) };
    };
  }
});

// web/lib/onnxjs/backends/webgl/ops/uint8-encode.ts
var encodeAsUint8;
var init_uint8_encode = __esm({
  "web/lib/onnxjs/backends/webgl/ops/uint8-encode.ts"() {
    "use strict";
    init_glsl_source();
    init_types();
    encodeAsUint8 = (inferenceHandler, input) => {
      const outputShape = input.shape;
      const glsl = getGlsl(inferenceHandler.session.backend.glContext.version);
      const shaderSource = `
    const float FLOAT_MAX = 1.70141184e38;
    const float FLOAT_MIN = 1.17549435e-38;

    bool isNaN(float val) {
      return (val < 1.0 || 0.0 < val || val == 0.0) ? false : true;
    }

    highp vec4 encodeAsUint8(highp float v) {
      if (isNaN(v)) {
        return vec4(255, 255, 255, 255);
      }

      highp float av = abs(v);

      if(av < FLOAT_MIN) {
        return vec4(0.0, 0.0, 0.0, 0.0);
      } else if(v > FLOAT_MAX) {
        return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
      } else if(v < -FLOAT_MAX) {
        return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
      }

      highp vec4 c = vec4(0,0,0,0);

      highp float e = floor(log2(av));
      highp float m = exp2(fract(log2(av))) - 1.0;

      c[2] = floor(128.0 * m);
      m -= c[2] / 128.0;
      c[1] = floor(32768.0 * m);
      m -= c[1] / 32768.0;
      c[0] = floor(8388608.0 * m);

      highp float ebias = e + 127.0;
      c[3] = floor(ebias / 2.0);
      ebias -= c[3] * 2.0;
      c[2] += floor(ebias) * 128.0;

      c[3] += 128.0 * step(0.0, -v);

      return c / 255.0;
    }

    void main() {
      float value = ${glsl.texture2D}(X,TexCoords).r;
      ${glsl.output} = encodeAsUint8(value);
    }`;
      const programInfo = {
        name: "Uint8Encode",
        inputTypes: [0 /* unpacked */],
        inputNames: ["X"],
        output: { dims: outputShape, type: input.tensor.type, textureType: 3 /* downloadUint8AsFloat */ },
        shaderSource,
        hasMain: true
      };
      return inferenceHandler.executeProgram(programInfo, [input.tensor]);
    };
  }
});

// web/lib/onnxjs/backends/webgl/ops/unpack.ts
function getSourceCoords(rank, dims) {
  if (rank === 1) {
    return "rc";
  }
  let coords = "";
  for (let i = 0; i < rank; i++) {
    coords += dims[i];
    if (i < rank - 1) {
      coords += ",";
    }
  }
  return coords;
}
var unpackProgramMetadata, createUnpackProgramInfo, createUnpackProgramInfoLoader;
var init_unpack = __esm({
  "web/lib/onnxjs/backends/webgl/ops/unpack.ts"() {
    "use strict";
    init_glsl_source();
    init_types();
    init_utils();
    init_packing_utils();
    unpackProgramMetadata = {
      name: "unpack",
      inputNames: ["A"],
      inputTypes: [2 /* packed */]
    };
    createUnpackProgramInfo = (handler, input) => {
      const rank = input.dims.length;
      const channels = getChannels("rc", rank);
      const innerDims = channels.slice(-2);
      const coordsDataType = getCoordsDataType(rank);
      const unpackChannel = unpackFromChannel();
      const isScalar = input.dims.length === 0;
      const sourceCoords = isScalar ? "" : getSourceCoords(rank, channels);
      const coords = rank <= 1 ? "rc" : `vec2(${innerDims.join(",")})`;
      const glsl = getGlsl(handler.session.backend.glContext.version);
      const shaderSource = `
    ${unpackChannel}
    void main() {
      ${coordsDataType} rc = getOutputCoords();

       // Sample the texture with the coords to get the rgba channel value.
       vec4 packedInput = getA(${sourceCoords});

       ${glsl.output} = vec4(getChannel(packedInput, ${coords}), 0, 0, 0);
     }
   `;
      return {
        ...unpackProgramMetadata,
        hasMain: true,
        output: { dims: input.dims, type: input.type, textureType: 0 /* unpacked */ },
        shaderSource
      };
    };
    createUnpackProgramInfoLoader = (handler, input) => ({ ...unpackProgramMetadata, get: () => createUnpackProgramInfo(handler, input) });
  }
});

// web/lib/onnxjs/backends/webgl/texture-data-encoder.ts
var RedFloat32DataEncoder, RGBAFloatDataEncoder, Uint8DataEncoder;
var init_texture_data_encoder = __esm({
  "web/lib/onnxjs/backends/webgl/texture-data-encoder.ts"() {
    "use strict";
    init_instrument();
    RedFloat32DataEncoder = class {
      constructor(gl, channels = 1) {
        if (channels === 1) {
          this.internalFormat = gl.R32F;
          this.format = gl.RED;
          this.textureType = gl.FLOAT;
          this.channelSize = channels;
        } else if (channels === 4) {
          this.internalFormat = gl.RGBA32F;
          this.format = gl.RGBA;
          this.textureType = gl.FLOAT;
          this.channelSize = channels;
        } else {
          throw new Error(`Invalid number of channels: ${channels}`);
        }
      }
      encode(src, textureSize) {
        let result;
        let source;
        if (src.constructor !== Float32Array) {
          Logger.warning("Encoder", "data was not of type Float32; creating new Float32Array");
          source = new Float32Array(src);
        }
        if (textureSize * this.channelSize > src.length) {
          Logger.warning("Encoder", "Source data too small. Allocating larger array");
          source = src;
          result = this.allocate(textureSize * this.channelSize);
          source.forEach((v, i) => result[i] = v);
        } else {
          source = src;
          result = source;
        }
        return result;
      }
      allocate(size) {
        return new Float32Array(size * 4);
      }
      decode(buffer, dataSize) {
        if (this.channelSize === 1) {
          const filteredData = buffer.filter((_value, index) => index % 4 === 0).subarray(0, dataSize);
          return filteredData;
        }
        return buffer.subarray(0, dataSize);
      }
    };
    RGBAFloatDataEncoder = class {
      constructor(gl, channels = 1, textureType) {
        if (channels !== 1 && channels !== 4) {
          throw new Error(`Invalid number of channels: ${channels}`);
        }
        this.internalFormat = gl.RGBA;
        this.format = gl.RGBA;
        this.channelSize = channels;
        this.textureType = textureType || gl.FLOAT;
      }
      encode(src, textureSize) {
        let dest = src;
        if (this.channelSize === 1) {
          Logger.verbose("Encoder", "Exploding into a larger array");
          dest = this.allocate(textureSize);
          src.forEach((v, i) => dest[i * 4] = v);
        }
        return dest;
      }
      allocate(size) {
        return new Float32Array(size * 4);
      }
      decode(buffer, dataSize) {
        if (this.channelSize === 1) {
          const filteredData = buffer.filter((_value, index) => index % 4 === 0).subarray(0, dataSize);
          return filteredData;
        }
        return buffer.subarray(0, dataSize);
      }
    };
    Uint8DataEncoder = class {
      constructor(gl, channels = 1) {
        this.channelSize = 4;
        if (channels === 1) {
          this.internalFormat = gl.ALPHA;
          this.format = gl.ALPHA;
          this.textureType = gl.UNSIGNED_BYTE;
          this.channelSize = channels;
        } else if (channels === 4) {
          this.internalFormat = gl.RGBA;
          this.format = gl.RGBA;
          this.textureType = gl.UNSIGNED_BYTE;
          this.channelSize = channels;
        } else {
          throw new Error(`Invalid number of channels: ${channels}`);
        }
      }
      encode(src, _textureSize) {
        return new Uint8Array(src.buffer, src.byteOffset, src.byteLength);
      }
      allocate(size) {
        return new Uint8Array(size * this.channelSize);
      }
      decode(buffer, dataSize) {
        if (buffer instanceof Uint8Array) {
          return buffer.subarray(0, dataSize);
        }
        throw new Error(`Invalid array type: ${buffer.constructor}`);
      }
    };
  }
});

// web/lib/onnxjs/backends/webgl/texture-layout.ts
var createTextureLayoutFromTextureType, calculateTextureWidthAndHeight, createTextureLayoutFromShape;
var init_texture_layout = __esm({
  "web/lib/onnxjs/backends/webgl/texture-layout.ts"() {
    "use strict";
    init_util();
    init_types();
    createTextureLayoutFromTextureType = (textureLayoutStrategy, shape2, textureType) => {
      const channel = textureType === 0 /* unpacked */ || textureType === 1 /* unpackedReversed */ ? 1 : 4;
      const isPacked = textureType === 2 /* packed */;
      const reverseWH = textureType === 1 /* unpackedReversed */ || textureType === 2 /* packed */;
      const breakAxis = textureType === 4 /* packedLastDimension */ ? shape2.length - 1 : void 0;
      const unpackedShape = textureType === 4 /* packedLastDimension */ ? shape2.map((d, i) => i === shape2.length - 1 ? d * 4 : d) : void 0;
      return createTextureLayoutFromShape(
        textureLayoutStrategy,
        shape2,
        channel,
        unpackedShape,
        { isPacked, reverseWH, breakAxis }
      );
    };
    calculateTextureWidthAndHeight = (textureLayoutStrategy, shape2, textureType) => {
      const layout = createTextureLayoutFromTextureType(textureLayoutStrategy, shape2, textureType);
      return [layout.width, layout.height];
    };
    createTextureLayoutFromShape = (textureLayoutStrategy, shape2, channels = 1, unpackedShape, prefs) => {
      const isPacked = !!(prefs && prefs.isPacked);
      const [width, height] = textureLayoutStrategy.computeTextureWH(isPacked ? unpackedShape || shape2 : shape2, prefs);
      const rank = shape2.length;
      let inferredDims = shape2.slice(0);
      if (rank === 0) {
        inferredDims = [1];
      }
      if (channels === 1) {
        unpackedShape = shape2;
      } else if (isPacked) {
        if (channels !== 4) {
          throw new Error("a packed texture must be 4-channel");
        }
        unpackedShape = shape2;
        if (rank > 0) {
          inferredDims[rank - 1] = Math.ceil(inferredDims[rank - 1] / 2);
        }
        if (rank > 1) {
          inferredDims[rank - 2] = Math.ceil(inferredDims[rank - 2] / 2);
        }
      } else if (!unpackedShape) {
        throw new Error("Unpacked shape is needed when using channels > 1");
      }
      return {
        width,
        height,
        channels,
        isPacked,
        shape: inferredDims,
        strides: ShapeUtil.computeStrides(inferredDims),
        unpackedShape,
        reversedWH: prefs && prefs.reverseWH
      };
    };
  }
});

// web/lib/onnxjs/backends/webgl/inference-handler.ts
var getProgramInfoUniqueKey, WebGLInferenceHandler;
var init_inference_handler = __esm({
  "web/lib/onnxjs/backends/webgl/inference-handler.ts"() {
    "use strict";
    init_instrument();
    init_tensor2();
    init_util();
    init_pack();
    init_reshape_packed();
    init_uint8_encode();
    init_unpack();
    init_texture_data_encoder();
    init_texture_layout();
    init_types();
    getProgramInfoUniqueKey = (programInfo, inputTextureDatas) => {
      const inputs = inputTextureDatas.map((texture) => `${texture.unpackedShape.join(",")};${texture.width}x${texture.height}`).join("_");
      let key = programInfo.name;
      if (programInfo.cacheHint) {
        key += "[" + programInfo.cacheHint + "]";
      }
      key += ":" + inputs;
      return key;
    };
    WebGLInferenceHandler = class {
      constructor(session) {
        this.session = session;
        this.packedTextureDataCache = /* @__PURE__ */ new Map();
        this.unpackedTextureDataCache = /* @__PURE__ */ new Map();
      }
      /**
       * @returns [width, height]
       */
      calculateTextureWidthAndHeight(shape2, textureType) {
        return calculateTextureWidthAndHeight(this.session.layoutStrategy, shape2, textureType);
      }
      executeProgram(program, inputs) {
        if (inputs.length < program.inputNames.length) {
          throw new Error(`Input size mustn't be less than ${program.inputNames.length}.`);
        }
        if (program.inputNames.length !== program.inputTypes.length) {
          throw new Error("input names size does not match input types");
        }
        const inputTextureDatas = [];
        for (let i = 0; i < program.inputNames.length; ++i) {
          inputTextureDatas[i] = this.getOrCreateTextureData(inputs[i], program.inputTypes[i]);
        }
        const key = getProgramInfoUniqueKey(program, inputTextureDatas);
        let artifact = this.session.programManager.getArtifact(key);
        const programInfo = artifact ? artifact.programInfo : typeof program.get === "function" ? program.get() : program;
        const outputTextureLayout = createTextureLayoutFromTextureType(
          this.session.layoutStrategy,
          programInfo.output.dims,
          programInfo.output.textureType
        );
        const outputTextureData = this.createTextureData(outputTextureLayout, programInfo.output.type);
        if (!artifact) {
          artifact = this.session.programManager.build(programInfo, inputTextureDatas, outputTextureData);
          this.session.programManager.setArtifact(key, artifact);
        }
        this.runProgram(artifact, inputTextureDatas, outputTextureData);
        return outputTextureData;
      }
      run(program, inputs) {
        const outputTextureData = this.executeProgram(program, inputs);
        return outputTextureData.tensor;
      }
      runProgram(artifact, inputs, output) {
        for (let i = 0; i < inputs.length; ++i) {
          if (!!inputs[i].isPacked !== (artifact.programInfo.inputTypes[i] === 2 /* packed */)) {
            throw new Error(`input[${i}] property packed inconsistent`);
          }
        }
        if (!!output.isPacked !== (artifact.programInfo.output.textureType === 2 /* packed */)) {
          throw new Error("output property packed inconsistent");
        }
        this.session.programManager.run(artifact, inputs, output);
      }
      /**
       * Create a TextureData object from a tensor.
       * Usage = EncoderUsage.UploadOnly.
       * If a related texture data is found in cache, returns it;
       * Otherwise:
       *   Creates a new texture layout if not provided;
       *   Creates WebGLTexture with the layout;
       *   Upload tensor data to the texture;
       *   Creates a texture data object associated with the given tensor.
       * @param tensor the tensor with data to upload
       */
      getOrCreateTextureData(tensor, textureType) {
        let td = this.getTextureData(tensor.dataId, textureType === 2 /* packed */);
        if (!td) {
          td = this.getTextureData(tensor.dataId, textureType !== 2 /* packed */);
          if (td) {
            if (textureType === 2 /* packed */) {
              return this.pack(td);
            } else {
              return this.unpack(td);
            }
          }
        }
        if (!td) {
          const layout = createTextureLayoutFromTextureType(this.session.layoutStrategy, tensor.dims, textureType);
          if (textureType === 4 /* packedLastDimension */) {
            const group = 1;
            const channels = 4;
            const shape2 = tensor.dims;
            if (shape2.length === 4) {
              const adjustedKernelShape = [shape2[0], Math.ceil(shape2[1] * shape2[2] * shape2[3] / channels)];
              const adjustedLayout = createTextureLayoutFromTextureType(this.session.layoutStrategy, adjustedKernelShape, textureType);
              let buffer = tensor.numberData;
              if (shape2[1] * shape2[2] * shape2[3] % channels !== 0) {
                const numFeatureMaps = shape2[0];
                const oldRowSize = shape2[1] * shape2[2] * shape2[3];
                const newRowSize = Math.ceil(oldRowSize * group / channels) * channels;
                const newSize = numFeatureMaps * newRowSize;
                buffer = new Float32Array(newSize);
                for (let f = 0; f < numFeatureMaps; ++f) {
                  const oldOffset = f * oldRowSize;
                  const newOffset = f * newRowSize + f % group * oldRowSize;
                  buffer.set(tensor.numberData.subarray(oldOffset, oldOffset + oldRowSize), newOffset);
                }
              }
              return this.createTextureData(adjustedLayout, tensor.type, buffer, tensor, 1 /* UploadOnly */);
            }
          }
          if (textureType === 2 /* packed */) {
            const unpackedTextureLayout = createTextureLayoutFromShape(this.session.layoutStrategy, tensor.dims, 1, [], { reverseWH: true });
            const unpackedTextureData = this.createTextureData(
              unpackedTextureLayout,
              tensor.type,
              tensor.numberData,
              tensor,
              1 /* UploadOnly */
            );
            td = this.pack(unpackedTextureData);
          } else {
            td = this.createTextureData(layout, tensor.type, tensor.numberData, tensor, 1 /* UploadOnly */);
          }
        }
        return td;
      }
      /**
       * Create a TextureData object using the given data and bind to the given tensor.
       * Usage = EncoderUsage.UploadOnly.
       * NOTE: this function is a hack for Conv implementation. should remove this function, after rewriting Conv
       * implementation by Graph.Transformer
       * @param dataType the tensor data type
       * @param data the actual data to upload
       * @param tensor the tensor to bind. tensor's data is ignored.
       */
      createTextureDataFromLayoutBindTensor(layout, dataType, data, tensor) {
        return this.createTextureData(layout, dataType, data, tensor, 1 /* UploadOnly */);
      }
      createTextureData(layout, dataType, data, tensor, usage) {
        Logger.verbose("InferenceHandler", `Creating TextureData: layout:[${JSON.stringify(layout)}]`);
        const texture = this.session.textureManager.createTextureFromLayout(dataType, layout, data, usage);
        return this.createTextureDataFromTexture(layout, dataType, texture, tensor);
      }
      reshapeUnpacked(input, reshapedDims) {
        const inputTD = this.getOrCreateTextureData(input, 0 /* unpacked */);
        const newTextureLayout = {
          channels: inputTD.channels,
          height: inputTD.height,
          width: inputTD.width,
          // handle reshaping into scalar Tensors
          shape: reshapedDims.length !== 0 ? reshapedDims : [1],
          strides: ShapeUtil.computeStrides(reshapedDims),
          unpackedShape: reshapedDims
        };
        const newTextureData = this.createTextureDataFromTexture(newTextureLayout, input.type, inputTD.texture);
        return newTextureData.tensor;
      }
      reshapePacked(input, reshapedDims) {
        const inputTD = this.getOrCreateTextureData(input, 2 /* packed */);
        if (isReshapeCheap(input.dims, reshapedDims)) {
          const newTextureLayout = {
            channels: inputTD.channels,
            height: inputTD.height,
            width: inputTD.width,
            // handle reshaping into scalar Tensors
            shape: reshapedDims.length !== 0 ? reshapedDims : [1],
            strides: ShapeUtil.computeStrides(reshapedDims),
            unpackedShape: reshapedDims,
            isPacked: true
          };
          const newTextureData = this.createTextureDataFromTexture(newTextureLayout, input.type, inputTD.texture);
          return newTextureData.tensor;
        }
        const squeezedInputShape = processDims3D(input.dims);
        const squeezedOutputShape = processDims3D(reshapedDims);
        const squeezedInputTensor = this.reshapePacked(input, squeezedInputShape);
        const squeezedOutputTensor = this.run(
          createPackedReshape3DProgramInfoLoader(this, squeezedInputTensor, squeezedOutputShape),
          [squeezedInputTensor]
        );
        const outputTensor = this.reshapePacked(squeezedOutputTensor, reshapedDims);
        return outputTensor;
      }
      cast(input, type) {
        const inputTD = this.getOrCreateTextureData(input, 0 /* unpacked */);
        const newTextureData = this.createTextureDataFromTexture(inputTD, type, inputTD.texture);
        return newTextureData.tensor;
      }
      createTextureDataFromTexture(layout, dataType, texture, tensor, tensorId) {
        const textureData = {
          ...layout,
          tensor: tensor || new Tensor3(
            layout.unpackedShape,
            dataType,
            (_id) => this.readTexture(textureData),
            async (_id) => this.readTextureAsync(textureData),
            void 0,
            tensorId
          ),
          texture
        };
        this.setTextureData(textureData.tensor.dataId, textureData, layout.isPacked);
        return textureData;
      }
      getTextureData(tensorId, isPacked = false) {
        return this.session.isInitializer(tensorId) ? this.session.getTextureData(tensorId, isPacked) : isPacked ? this.packedTextureDataCache.get(tensorId) : this.unpackedTextureDataCache.get(tensorId);
      }
      setTextureData(tensorId, td, isPacked = false) {
        if (this.session.isInitializer(tensorId)) {
          this.session.setTextureData(tensorId, td, isPacked);
        } else {
          (isPacked ? this.packedTextureDataCache : this.unpackedTextureDataCache).set(tensorId, td);
        }
      }
      isTextureLayoutCached(tensor, isPacked = false) {
        return !!this.getTextureData(tensor.dataId, isPacked);
      }
      dispose() {
        this.session.textureManager.clearActiveTextures();
        this.packedTextureDataCache.forEach((td) => this.session.textureManager.releaseTexture(td));
        this.packedTextureDataCache = /* @__PURE__ */ new Map();
        this.unpackedTextureDataCache.forEach((td) => this.session.textureManager.releaseTexture(td));
        this.unpackedTextureDataCache = /* @__PURE__ */ new Map();
      }
      readTexture(textureData) {
        if (textureData.isPacked) {
          return this.readTexture(this.unpack(textureData));
        }
        if (!this.session.backend.glContext.isFloat32DownloadSupported) {
          return this.session.textureManager.readUint8TextureAsFloat(encodeAsUint8(this, textureData));
        }
        return this.session.textureManager.readTexture(textureData, textureData.tensor.type, textureData.channels);
      }
      async readTextureAsync(textureData) {
        if (textureData.isPacked) {
          return this.readTextureAsync(this.unpack(textureData));
        }
        if (!this.session.backend.glContext.isFloat32DownloadSupported) {
          return this.session.textureManager.readUint8TextureAsFloat(encodeAsUint8(this, textureData));
        }
        return this.session.textureManager.readTextureAsync(textureData, textureData.tensor.type, textureData.channels);
      }
      pack(input) {
        const outputTextureData = this.executeProgram(createPackProgramInfoLoader(this, input.tensor), [input.tensor]);
        return outputTextureData;
      }
      unpack(input) {
        const outputTextureData = this.executeProgram(createUnpackProgramInfoLoader(this, input.tensor), [input.tensor]);
        return outputTextureData;
      }
    };
  }
});

// web/lib/onnxjs/attribute-with-cache-key.ts
var AttributeWithCacheKeyImpl, createAttributeWithCacheKey;
var init_attribute_with_cache_key = __esm({
  "web/lib/onnxjs/attribute-with-cache-key.ts"() {
    "use strict";
    AttributeWithCacheKeyImpl = class {
      constructor(attribute) {
        Object.assign(this, attribute);
      }
      get cacheKey() {
        if (!this.key) {
          this.key = Object.getOwnPropertyNames(this).sort().map((name2) => `${this[name2]}`).join(";");
        }
        return this.key;
      }
    };
    createAttributeWithCacheKey = (attribute) => new AttributeWithCacheKeyImpl(attribute);
  }
});

// web/lib/onnxjs/backends/webgl/ops/batch-normalization.ts
var batchNormalizationProgramMetadata, batchNormalization, parseBatchNormalizationAttributes, createBatchNormalizationProgramInfo, validateInputs;
var init_batch_normalization = __esm({
  "web/lib/onnxjs/backends/webgl/ops/batch-normalization.ts"() {
    "use strict";
    init_attribute_with_cache_key();
    init_glsl_source();
    init_types();
    batchNormalizationProgramMetadata = {
      name: "BatchNormalization",
      inputNames: ["A", "Scale", "B", "Mean", "Variance"],
      inputTypes: [0 /* unpacked */, 0 /* unpacked */, 0 /* unpacked */, 0 /* unpacked */, 0 /* unpacked */]
    };
    batchNormalization = (inferenceHandler, inputs, attributes) => {
      validateInputs(inputs);
      const output = inferenceHandler.run(
        {
          ...batchNormalizationProgramMetadata,
          cacheHint: attributes.cacheKey,
          get: () => createBatchNormalizationProgramInfo(inferenceHandler, inputs, attributes)
        },
        inputs
      );
      return [output];
    };
    parseBatchNormalizationAttributes = (node) => {
      const epsilon = node.attributes.getFloat("epsilon", 1e-5);
      const momentum = node.attributes.getFloat("momentum", 0.9);
      const spatial = node.attributes.getInt("spatial", 1);
      return createAttributeWithCacheKey({ epsilon, momentum, spatial });
    };
    createBatchNormalizationProgramInfo = (inferenceHandler, inputs, attributes) => {
      const glsl = getGlsl(inferenceHandler.session.backend.glContext.version);
      const rank = inputs[0].dims.length;
      const [scaleWidth, scaleHeight] = inferenceHandler.calculateTextureWidthAndHeight(inputs[1].dims, 0 /* unpacked */);
      const shaderSource = `
  float process(int[${rank}] indices) {
    vec2 position = offsetToCoords(indices[1], ${scaleWidth}, ${scaleHeight});
    float scale = getColorAsFloat(${glsl.texture2D}(Scale, position));
    float mean = getColorAsFloat(${glsl.texture2D}(Mean, position));
    float variance = getColorAsFloat(${glsl.texture2D}(Variance, position));
    float b = getColorAsFloat(${glsl.texture2D}(B, position));

    return scale * ( (_A(indices) - mean) / sqrt(variance + float(${attributes.epsilon})) ) + b;
  }`;
      return {
        ...batchNormalizationProgramMetadata,
        output: { dims: inputs[0].dims, type: inputs[0].type, textureType: 0 /* unpacked */ },
        shaderSource
      };
    };
    validateInputs = (inputs) => {
      if (!inputs || inputs.length !== 5) {
        throw new Error("BatchNormalization requires 5 inputs.");
      }
      const X = inputs[0];
      const scale = inputs[1];
      const B = inputs[2];
      const mean = inputs[3];
      const var_ = inputs[4];
      if (X.dims.length < 3 || scale.dims.length !== 1 || B.dims.length !== 1 || mean.dims.length !== 1 || var_.dims.length !== 1) {
        throw new Error("invalid input shape.");
      }
      if (scale.dims[0] !== X.dims[1] || B.dims[0] !== X.dims[1] || mean.dims[0] !== X.dims[1] || var_.dims[0] !== X.dims[1]) {
        throw new Error("invalid input shape.");
      }
      if (X.type !== "float32" && X.type !== "float64" || scale.type !== "float32" && scale.type !== "float64" || B.type !== "float32" && B.type !== "float64" || mean.type !== "float32" && mean.type !== "float64" || var_.type !== "float32" && var_.type !== "float64") {
        throw new Error("invalid input tensor types.");
      }
    };
  }
});

// web/lib/onnxjs/backends/webgl/glsl-definitions.ts
var GlslContext, GlslLib, GlslLibRoutine, GlslLibRoutineNode, TopologicalSortGlslRoutines;
var init_glsl_definitions = __esm({
  "web/lib/onnxjs/backends/webgl/glsl-definitions.ts"() {
    "use strict";
    GlslContext = class {
      constructor(glContext, programInfo, inputTextureLayouts, outputTextureLayout) {
        this.glContext = glContext;
        this.programInfo = programInfo;
        this.inputTextureLayouts = inputTextureLayouts;
        this.outputTextureLayout = outputTextureLayout;
      }
    };
    GlslLib = class {
      constructor(context) {
        this.context = context;
      }
    };
    GlslLibRoutine = class {
      constructor(routineBody, dependencies) {
        this.routineBody = routineBody;
        this.dependencies = dependencies;
      }
    };
    GlslLibRoutineNode = class {
      constructor(name2, routineBody, dependencies) {
        this.name = name2;
        if (dependencies) {
          this.dependencies = dependencies;
        } else {
          this.dependencies = [];
        }
        if (routineBody) {
          this.routineBody = routineBody;
        }
      }
      addDependency(node) {
        if (node) {
          this.dependencies.push(node);
        }
      }
    };
    TopologicalSortGlslRoutines = class {
      static returnOrderedNodes(nodes) {
        if (!nodes || nodes.length === 0) {
          return [];
        }
        if (nodes.length === 1) {
          return nodes;
        }
        const cycleCheck = /* @__PURE__ */ new Set();
        const alreadyTraversed = /* @__PURE__ */ new Set();
        const result = new Array();
        this.createOrderedNodes(nodes, cycleCheck, alreadyTraversed, result);
        return result;
      }
      static createOrderedNodes(graphNodes, cycleCheck, alreadyTraversed, result) {
        for (let i = 0; i < graphNodes.length; ++i) {
          this.dfsTraverse(graphNodes[i], cycleCheck, alreadyTraversed, result);
        }
      }
      static dfsTraverse(root, cycleCheck, alreadyTraversed, result) {
        if (!root || alreadyTraversed.has(root.name)) {
          return;
        }
        if (cycleCheck.has(root.name)) {
          throw new Error("Cyclic dependency detected. Can't topologically sort routines needed for shader.");
        }
        cycleCheck.add(root.name);
        const dependencies = root.dependencies;
        if (dependencies && dependencies.length > 0) {
          for (let i = 0; i < dependencies.length; ++i) {
            this.dfsTraverse(dependencies[i], cycleCheck, alreadyTraversed, result);
          }
        }
        result.push(root);
        alreadyTraversed.add(root.name);
        cycleCheck.delete(root.name);
      }
    };
  }
});

// web/lib/onnxjs/backends/webgl/ops/binary-op.ts
function glslAdd() {
  const name2 = "add_";
  const body = `
  float ${name2}(float a, float b) {
    return a + b;
  }
  vec4 ${name2}(vec4 v1, vec4 v2) {
    return v1 + v2;
  }
  `;
  return { body, name: name2, type: 0 /* ValueBased */ };
}
function glslDiv() {
  const name2 = "div_";
  const body = `
  float ${name2}(float a, float b) {
    return a / b;
  }
  vec4 ${name2}(vec4 v1, vec4 v2) {
    return v1 / v2;
  }
  `;
  return { body, name: name2, type: 0 /* ValueBased */ };
}
function glslMul() {
  const name2 = "mul_";
  const body = `
  float ${name2}(float a, float b) {
    return a * b;
  }
  vec4 ${name2}(vec4 v1, vec4 v2) {
    return v1 * v2;
  }
  `;
  return { body, name: name2, type: 0 /* ValueBased */ };
}
function glslSub() {
  const name2 = "sub_";
  const body = `
  float ${name2}(float a, float b) {
    return a - b;
  }
  vec4 ${name2}(vec4 v1, vec4 v2) {
    return v1 - v2;
  }
  `;
  return { body, name: name2, type: 0 /* ValueBased */ };
}
function glslEqual() {
  const name2 = "equal_";
  const body = `
  float ${name2}(float a, float b) {
    return float(a == b);
  }
  vec4 ${name2}(vec4 v1, vec4 v2) {
    return vec4(equal(v1, v2));
  }
  `;
  return { body, name: name2, type: 0 /* ValueBased */ };
}
function glslGreater() {
  const name2 = "greater_";
  const body = `
  float ${name2}(float a, float b) {
    return float(a > b);
  }
  vec4 ${name2}(vec4 v1, vec4 v2) {
    return vec4( v1.r > v2.r ,
      v1.g > v2.g,
      v1.b > v2.b,
      v1.a > v2.a );
  }
  `;
  return { body, name: name2, type: 0 /* ValueBased */ };
}
function glslLess() {
  const name2 = "less_";
  const body = `
  float ${name2}(float a, float b) {
    return float(a < b);
  }
  vec4 ${name2}(vec4 v1, vec4 v2) {
    return vec4( v1.r < v2.r ,
                v1.g < v2.g,
                v1.b < v2.b,
                v1.a < v2.a );
  }
  `;
  return { body, name: name2, type: 0 /* ValueBased */ };
}
function glslAnd() {
  const name2 = "and_";
  const body = `
  float ${name2}(float a, float b) {
    return float( bool(a) && bool(b) );
  }
  vec4 ${name2}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r && b2.r ,
                b1.g && b2.g,
                b1.b && b2.b,
                b1.a && b2.a );
  }
  `;
  return { body, name: name2, type: 0 /* ValueBased */ };
}
function glslOr() {
  const name2 = "or_";
  const body = `
  float ${name2}(float a, float b) {
    return float( bool(a) || bool(b) );
  }
  vec4 ${name2}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r || b2.r ,
                b1.g || b2.g,
                b1.b || b2.b,
                b1.a || b2.a );
  }
  `;
  return { body, name: name2, type: 0 /* ValueBased */ };
}
function glslXor() {
  const name2 = "xor_";
  const body = `
  float ${name2}(float a, float b) {
    return float( bool(a) ^^ bool(b) );
  }
  vec4 ${name2}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r ^^ b2.r ,
                b1.g ^^ b2.g,
                b1.b ^^ b2.b,
                b1.a ^^ b2.a );
  }
  `;
  return { body, name: name2, type: 0 /* ValueBased */ };
}
function glslPow() {
  return glslBuiltinBinary("pow");
}
function glslPRelu() {
  const name2 = "prelu_";
  const body = `
  float ${name2}(float a, float b) {
    return a < 0.0 ? a * b: a;
  }
  vec4 ${name2}(vec4 v1, vec4 v2) {
    return vec4(
      v1.r < 0.0 ? v1.r * v2.r: v1.r,
      v1.g < 0.0 ? v1.g * v2.g: v1.g,
      v1.b < 0.0 ? v1.b * v2.b: v1.b,
      v1.a < 0.0 ? v1.a * v2.a: v1.a
      );
  }
  `;
  return { body, name: name2, type: 0 /* ValueBased */ };
}
function glslBuiltinBinary(fname) {
  const name2 = `${fname}_`;
  const body = `
  float ${name2}(float a, float b) {
    return ${fname}(a, b);
  }
  vec4 ${name2}(vec4 v1, vec4 v2) {
    return ${fname}(v1, v2);
  }
  `;
  return { body, name: name2, type: 0 /* ValueBased */ };
}
var createBinaryProgramInfoLoader, createBinaryProgramInfo, add2, and2, div, equal, greater, less, mul, or2, pow, pRelu, sub, xor2;
var init_binary_op = __esm({
  "web/lib/onnxjs/backends/webgl/ops/binary-op.ts"() {
    "use strict";
    init_util();
    init_glsl_definitions();
    init_glsl_source();
    init_types();
    createBinaryProgramInfoLoader = (handler, inputs, glslFunc, outputTensorType = inputs[0].type, cacheKey) => {
      const textureType = handler.session.pack ? 2 /* packed */ : 0 /* unpacked */;
      return {
        name: glslFunc.name,
        inputNames: ["A", "B"],
        inputTypes: [textureType, textureType],
        cacheHint: cacheKey,
        get: () => createBinaryProgramInfo(handler, inputs, glslFunc, outputTensorType)
      };
    };
    createBinaryProgramInfo = (handler, inputs, glslFunc, outputTensorType = inputs[0].type) => {
      const textureType = handler.session.pack ? 2 /* packed */ : 0 /* unpacked */;
      const isBroadcast = !ShapeUtil.areEqual(inputs[0].dims, inputs[1].dims);
      let outputShape = inputs[0].dims;
      const usePackedTexture = handler.session.pack;
      if (isBroadcast) {
        const calculatedShape = BroadcastUtil.calcShape(inputs[0].dims, inputs[1].dims, false);
        if (!calculatedShape) {
          throw new Error("Can't perform binary op on the given tensors");
        }
        outputShape = calculatedShape;
        const outputRank = outputShape.length;
        const aRank = inputs[0].dims.length !== 0 ? inputs[0].dims.length : 1;
        const bRank = inputs[1].dims.length !== 0 ? inputs[1].dims.length : 1;
        const aBcast = inputs[0].dims.length !== 0 ? "bcastIndices_A(indices, aindices);" : "aindices[0] = 0;";
        const bBcast = inputs[1].dims.length !== 0 ? "bcastIndices_B(indices, bindices);" : "bindices[0] = 0;";
        const glsl2 = getGlsl(handler.session.backend.glContext.version);
        const shaderSource2 = usePackedTexture ? `
      ${glslFunc.body}
      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();
        vec4 result = ${glslFunc.name}(a, b);
        ${glsl2.output} = result;
      }` : `
      ${glslFunc.body}
      float process(int indices[${outputRank}]) {
        int aindices[${aRank}];
        int bindices[${bRank}];
        ${aBcast}
        ${bBcast}
        return ${glslFunc.name}(_A(aindices), _B(bindices));
      }`;
        return {
          name: glslFunc.name,
          inputNames: ["A", "B"],
          inputTypes: [textureType, textureType],
          output: { dims: outputShape, type: outputTensorType, textureType },
          shaderSource: shaderSource2,
          hasMain: usePackedTexture
        };
      }
      const glsl = getGlsl(handler.session.backend.glContext.version);
      const shaderSource = `
    ${glslFunc.body}
    void main() {
      vec4 v1 = ${glsl.texture2D}(A, TexCoords);
      vec4 v2 = ${glsl.texture2D}(B, TexCoords);
      vec4 result = ${glslFunc.name}(v1, v2);
      ${glsl.output} = result;
    }
    `;
      return {
        name: glslFunc.name,
        inputNames: ["A", "B"],
        inputTypes: [textureType, textureType],
        output: { dims: inputs[0].dims, type: outputTensorType, textureType },
        shaderSource,
        hasMain: true
      };
    };
    add2 = (handler, inputs) => [handler.run(createBinaryProgramInfoLoader(handler, inputs, glslAdd()), inputs)];
    and2 = (handler, inputs) => [handler.run(createBinaryProgramInfoLoader(handler, inputs, glslAnd(), "bool"), inputs)];
    div = (handler, inputs) => [handler.run(createBinaryProgramInfoLoader(handler, inputs, glslDiv()), inputs)];
    equal = (handler, inputs) => [handler.run(createBinaryProgramInfoLoader(handler, inputs, glslEqual(), "bool"), inputs)];
    greater = (handler, inputs) => [handler.run(createBinaryProgramInfoLoader(handler, inputs, glslGreater(), "bool"), inputs)];
    less = (handler, inputs) => [handler.run(createBinaryProgramInfoLoader(handler, inputs, glslLess(), "bool"), inputs)];
    mul = (handler, inputs) => [handler.run(createBinaryProgramInfoLoader(handler, inputs, glslMul()), inputs)];
    or2 = (handler, inputs) => [handler.run(createBinaryProgramInfoLoader(handler, inputs, glslOr(), "bool"), inputs)];
    pow = (handler, inputs) => [handler.run(createBinaryProgramInfoLoader(handler, inputs, glslPow()), inputs)];
    pRelu = (handler, inputs) => [handler.run(createBinaryProgramInfoLoader(handler, inputs, glslPRelu()), inputs)];
    sub = (handler, inputs) => [handler.run(createBinaryProgramInfoLoader(handler, inputs, glslSub()), inputs)];
    xor2 = (handler, inputs) => [handler.run(createBinaryProgramInfoLoader(handler, inputs, glslXor(), "bool"), inputs)];
  }
});

// web/lib/onnxjs/backends/webgl/ops/cast.ts
var cast, parseCastAttributes, validateInputs2;
var init_cast = __esm({
  "web/lib/onnxjs/backends/webgl/ops/cast.ts"() {
    "use strict";
    init_util();
    cast = (handler, inputs, to) => {
      validateInputs2(inputs);
      return [handler.cast(inputs[0], to)];
    };
    parseCastAttributes = (node) => ProtoUtil.tensorDataTypeFromProto(node.attributes.getInt("to"));
    validateInputs2 = (inputs) => {
      if (!inputs || inputs.length !== 1) {
        throw new Error("Cast requires 1 input.");
      }
      if (inputs[0].type === "string") {
        throw new Error("Invalid input type.");
      }
    };
  }
});

// web/lib/onnxjs/backends/webgl/ops/concat-packed.ts
var createPackedConcatProgramMetadata, createPackedConcatProgramInfo, createPackedConcatProgramInfoLoader, getShiftedChannelsSnippet;
var init_concat_packed = __esm({
  "web/lib/onnxjs/backends/webgl/ops/concat-packed.ts"() {
    "use strict";
    init_glsl_source();
    init_types();
    init_utils();
    init_packing_utils();
    createPackedConcatProgramMetadata = (inputCount, cacheHint) => ({
      name: "Concat (packed)",
      inputNames: Array.from({ length: inputCount }, (_v, i) => `X${i}`),
      inputTypes: Array(inputCount).fill(2 /* packed */),
      cacheHint
    });
    createPackedConcatProgramInfo = (handler, metadata, inputs, axis) => {
      const inputShape = inputs[0].dims.slice();
      if (axis >= inputShape.length || axis < -1 * inputShape.length) {
        throw new Error("axis specified for concat doesn't match input dimensionality");
      }
      if (axis < 0) {
        axis = inputShape.length + axis;
      }
      const outputShape = inputShape.slice(0);
      for (let i = 1; i < inputs.length; i++) {
        const dataNShape = inputs[i].dims.slice();
        for (let axisIndex = 0; axisIndex < inputShape.length; axisIndex++) {
          if (axisIndex === axis) {
            outputShape[axis] += dataNShape[axisIndex];
          } else if (inputShape[axisIndex] !== dataNShape[axisIndex]) {
            throw new Error("non concat dimensions must match");
          }
        }
      }
      const rank = outputShape.length;
      const coords = getChannels("coords", rank);
      const dtype = getCoordsDataType(rank);
      const unpackChannel = unpackFromChannel();
      const shapes = inputs.map((i) => i.dims);
      const channels = getGlChannels(rank);
      const offsets = new Array(shapes.length - 1);
      offsets[0] = shapes[0][axis];
      for (let i = 1; i < offsets.length; i++) {
        offsets[i] = offsets[i - 1] + shapes[i][axis];
      }
      const channel = channels[axis];
      const lastChannels = channels.slice(-2);
      const allChannels = channels.join();
      let getValueSnippet = `if (${channel} < ${offsets[0]}) {
        return getChannel(
            getX0(${allChannels}), vec2(${lastChannels.join()}));
        }`;
      for (let i = 1; i < offsets.length; i++) {
        const shift2 = offsets[i - 1];
        getValueSnippet += `
            if (${channel} < ${offsets[i]}  && ${channel} >= ${offsets[i - 1]}) {
              return getChannel(
                getX${i}(${getShiftedChannelsSnippet(channels, channel, shift2)}),
                vec2(${getShiftedChannelsSnippet(lastChannels, channel, shift2)}));
            }`;
      }
      const lastIndex = offsets.length;
      const shift = offsets[offsets.length - 1];
      getValueSnippet += `
            return getChannel(
              getX${lastIndex}(${getShiftedChannelsSnippet(channels, channel, shift)}),
              vec2(${getShiftedChannelsSnippet(lastChannels, channel, shift)}));`;
      const glsl = getGlsl(handler.session.backend.glContext.version);
      const shaderSource = `
          ${unpackChannel}
          float getValue(${channels.map((x) => "int " + x)}) {
            ${getValueSnippet}
          }

          void main() {
            ${dtype} coords = getOutputCoords();
            int lastDim = coords.${channels[rank - 1]};
            coords.${channels[rank - 1]} = coords.${channels[rank - 2]};
            coords.${channels[rank - 2]} = lastDim;

            vec4 result = vec4(getValue(${coords}), 0., 0., 0.);

            ${coords[rank - 1]} = ${coords[rank - 1]} + 1;
            if (${coords[rank - 1]} < ${outputShape[rank - 1]}) {
              result.g = getValue(${coords});
            }

            ${coords[rank - 2]} = ${coords[rank - 2]} + 1;
            if (${coords[rank - 2]} < ${outputShape[rank - 2]}) {
              result.a = getValue(${coords});
            }

            ${coords[rank - 1]} = ${coords[rank - 1]} - 1;
            if (${coords[rank - 2]} < ${outputShape[rank - 2]} &&
                ${coords[rank - 1]} < ${outputShape[rank - 1]}) {
              result.b = getValue(${coords});
            }
            ${glsl.output} = result;
          }
        `;
      return {
        ...metadata,
        output: { dims: outputShape, type: inputs[0].type, textureType: 2 /* packed */ },
        shaderSource,
        hasMain: true
      };
    };
    createPackedConcatProgramInfoLoader = (handler, inputs, attributes) => {
      const metadata = createPackedConcatProgramMetadata(inputs.length, attributes.cacheKey);
      return { ...metadata, get: () => createPackedConcatProgramInfo(handler, metadata, inputs, attributes.axis) };
    };
    getShiftedChannelsSnippet = (channels, channel, shift) => {
      const channelIdx = channels.indexOf(channel);
      const res = channels.map((c, idx) => {
        if (idx === channelIdx) {
          return `${c} - ${shift}`;
        } else {
          return c;
        }
      });
      return res.join();
    };
  }
});

// web/lib/onnxjs/backends/webgl/ops/concat.ts
var concat, createUnpackedConcatProgramMetadata, createUnpackedConcatProgramInfo, createUnpackedConcatProgramInfoLoader, getTextureIndexWhereDataResidesLinearSearch, getTextureIndexWhereDataResidesBinarySearch, getFetchDataFromCorrectTextureMethod, getGetSizeInConcatAxisValueFromIndexMethod, parseConcatAttributes, validateInputs3;
var init_concat = __esm({
  "web/lib/onnxjs/backends/webgl/ops/concat.ts"() {
    "use strict";
    init_attribute_with_cache_key();
    init_types();
    init_concat_packed();
    concat = (inferenceHandler, inputs, attributes) => {
      validateInputs3(inputs);
      if (inferenceHandler.session.pack && inputs[0].dims.length > 1) {
        const output = inferenceHandler.run(createPackedConcatProgramInfoLoader(inferenceHandler, inputs, attributes), inputs);
        return [output];
      } else {
        const output = inferenceHandler.run(createUnpackedConcatProgramInfoLoader(inferenceHandler, inputs, attributes), inputs);
        return [output];
      }
    };
    createUnpackedConcatProgramMetadata = (inputCount, cacheHint) => ({
      name: "Concat",
      inputNames: Array.from({ length: inputCount }, (_v, i) => `X${i}`),
      inputTypes: Array(inputCount).fill(0 /* unpacked */),
      cacheHint
    });
    createUnpackedConcatProgramInfo = (_handler, metadata, inputs, axis) => {
      const inputShape = inputs[0].dims.slice();
      if (axis >= inputShape.length || axis < -1 * inputShape.length) {
        throw new Error("axis specified for concat doesn't match input dimensionality");
      }
      if (axis < 0) {
        axis = inputShape.length + axis;
      }
      const outputShape = inputShape.slice(0);
      for (let i = 1; i < inputs.length; i++) {
        const dataNShape = inputs[i].dims.slice();
        for (let axisIndex = 0; axisIndex < inputShape.length; axisIndex++) {
          if (axisIndex === axis) {
            outputShape[axis] += dataNShape[axisIndex];
          } else if (inputShape[axisIndex] !== dataNShape[axisIndex]) {
            throw new Error("non concat dimensions must match");
          }
        }
      }
      const rank = outputShape.length;
      const sizeInConcatAxis = new Array(inputs.length);
      let previousSum = 0;
      for (let i = 0; i < sizeInConcatAxis.length; ++i) {
        previousSum += inputs[i].dims[axis];
        sizeInConcatAxis[i] = previousSum;
      }
      let getTextureIndexWhereDataResidesMethod = "";
      if (inputs.length < 5) {
        getTextureIndexWhereDataResidesMethod = getTextureIndexWhereDataResidesLinearSearch(sizeInConcatAxis);
      } else {
        getTextureIndexWhereDataResidesMethod = getTextureIndexWhereDataResidesBinarySearch(sizeInConcatAxis);
      }
      const fetchDataFromCorrectTextureMethod = getFetchDataFromCorrectTextureMethod(inputs.length, rank);
      const getSizeInConcatAxisValueFromIndexMethod = getGetSizeInConcatAxisValueFromIndexMethod(sizeInConcatAxis);
      const shaderSource = `
        ${fetchDataFromCorrectTextureMethod}
        ${getSizeInConcatAxisValueFromIndexMethod}
        ${getTextureIndexWhereDataResidesMethod}
        float process(int indices[${rank}]) {
          int textureIndex = getTextureWhereDataResides (indices[${axis}]);

          if(textureIndex != 0) {
            indices[${axis}] = indices[${axis}] - int(getSizeInConcatAxisValueFromIndex(textureIndex-int(1)));
          }

          return fetchDataFromCorrectTexture(textureIndex, indices);
        }`;
      return {
        ...metadata,
        output: { dims: outputShape, type: inputs[0].type, textureType: 0 /* unpacked */ },
        shaderSource
      };
    };
    createUnpackedConcatProgramInfoLoader = (handler, inputs, attributes) => {
      const metadata = createUnpackedConcatProgramMetadata(inputs.length, attributes.cacheKey);
      return { ...metadata, get: () => createUnpackedConcatProgramInfo(handler, metadata, inputs, attributes.axis) };
    };
    getTextureIndexWhereDataResidesLinearSearch = (sizeInConcatAxis) => {
      const searchAxis = sizeInConcatAxis.map((size, i) => `if(index<${size}) {return ${i};}
`);
      return `int getTextureWhereDataResides(int index) {
      ${searchAxis.join("")}
    }`;
    };
    getTextureIndexWhereDataResidesBinarySearch = (sizeInConcatAxis) => getTextureIndexWhereDataResidesLinearSearch(sizeInConcatAxis);
    getFetchDataFromCorrectTextureMethod = (numberOfTensors, tensorRank) => {
      const codeLines = [`float fetchDataFromCorrectTexture(int textureIndex, int indices[${tensorRank}]) {`];
      for (let i = 0; i < numberOfTensors; ++i) {
        if (i === 0) {
          codeLines.push(
            `	if (textureIndex == ${i}) { return _X${i}(indices); }`
          );
        } else if (i === numberOfTensors - 1) {
          codeLines.push(
            `	else { return _X${i}(indices); }`
          );
        } else {
          codeLines.push(
            `	else if (textureIndex == ${i}) { return _X${i}(indices); }`
          );
        }
      }
      codeLines.push(
        "	}"
      );
      return codeLines.join("\n");
    };
    getGetSizeInConcatAxisValueFromIndexMethod = (sizeInConcatAxis) => {
      const codeLines = ["int getSizeInConcatAxisValueFromIndex(int index) {"];
      for (let i = 0; i < sizeInConcatAxis.length; ++i) {
        if (i === 0) {
          codeLines.push(
            `	if (index == ${i}) { return ${sizeInConcatAxis[i]}; }`
          );
        } else if (i === sizeInConcatAxis.length - 1) {
          codeLines.push(
            `	else { return ${sizeInConcatAxis[i]}; }`
          );
        } else {
          codeLines.push(
            `	else if (index == ${i}) { return ${sizeInConcatAxis[i]}; }`
          );
        }
      }
      codeLines.push(
        "	}"
      );
      return codeLines.join("\n");
    };
    parseConcatAttributes = (node) => createAttributeWithCacheKey({ axis: node.attributes.getInt("axis") });
    validateInputs3 = (inputs) => {
      if (!inputs || inputs.length < 1) {
        throw new Error("too few inputs");
      }
      const inputType = inputs[0].type;
      const inputDimensionality = inputs[0].dims.length;
      if (inputType === "string") {
        throw new Error("string tensor is not supported yet");
      }
      for (const input of inputs) {
        if (input.type !== inputType) {
          throw new Error("input tensors should be one type");
        }
        if (input.dims.length !== inputDimensionality) {
          throw new Error("input tensors should have the same shape");
        }
      }
    };
  }
});

// web/lib/onnxjs/backends/webgl/ops/unary-op.ts
function glslAbs() {
  return glslBuiltinUnary("abs");
}
function glslAcos() {
  return glslBuiltinUnary("acos");
}
function glslAsin() {
  return glslBuiltinUnary("asin");
}
function glslAtan() {
  return glslBuiltinUnary("atan");
}
function glslCeil() {
  return glslBuiltinUnary("ceil");
}
function glslCos() {
  return glslBuiltinUnary("cos");
}
function glslElu(alpha) {
  const name2 = "elu";
  const body = `
  const float alpha = float(${alpha});

  float ${name2}_(float a) {
    return a >= 0.0 ? a: (exp(a) - 1.0) * alpha;
  }
  vec4 ${name2}_(vec4 v) {
    return vec4(${name2}_(v.x), ${name2}_(v.y), ${name2}_(v.z), ${name2}_(v.w));
  }
  `;
  return { body, name: name2, type: 0 /* ValueBased */ };
}
function glslExp() {
  return glslBuiltinUnary("exp");
}
function glslFloor() {
  return glslBuiltinUnary("floor");
}
function glslClip(min, max) {
  const name2 = "clip";
  const body = `
  const float min = float(${min});
  const float max = float(${max});

  float ${name2}_(float a) {
    return clamp(a, min, max);
  }
  vec4 ${name2}_(vec4 v) {
    return clamp(v, min, max);
  }
  `;
  return { body, name: name2, type: 0 /* ValueBased */ };
}
function glslIdentity() {
  const name2 = "indentity";
  const body = `
  float ${name2}_(float a) {
    return a;
  }
  vec4 ${name2}_(vec4 v) {
    return v;
  }
  `;
  return { body, name: name2, type: 0 /* ValueBased */ };
}
function glslLeakyRelu(alpha) {
  const name2 = "leakyRelu";
  const body = `
  const float alpha = float(${alpha});

  float ${name2}_(float a) {
    return a < 0.0 ? a * alpha : a;
  }
  vec4 ${name2}_(vec4 v) {
    return vec4(${name2}_(v.x), ${name2}_(v.y), ${name2}_(v.z), ${name2}_(v.w));
  }
  `;
  return { body, name: name2, type: 0 /* ValueBased */ };
}
function glslLog() {
  return glslBuiltinUnary("log");
}
function glslNeg() {
  const name2 = "neg";
  const body = `
  float ${name2}_(float a) {
    return -a;
  }
  vec4 ${name2}_(vec4 v) {
    return -v;
  }
  `;
  return { body, name: name2, type: 0 /* ValueBased */ };
}
function glslNot() {
  const name2 = "not";
  const body = `
  float ${name2}_(float a) {
    return float( ! bool(a) );
  }
  bool ${name2}_(bool a) {
    return !a;
  }
  vec4 ${name2}_(vec4 v) {
    return vec4(!bool(v.x), !bool(v.y), !bool(v.z), !bool(v.w));
  }
  bvec4 ${name2}_(bvec4 v) {
    return bvec4(!v.x, !v.y, !v.z, !v.w);
  }
  `;
  return { body, name: name2, type: 0 /* ValueBased */ };
}
function glslSin() {
  return glslBuiltinUnary("sin");
}
function glslRelu() {
  const name2 = "relu";
  const body = `
  float ${name2}_(float a) {
    return max( a, 0.0 );
  }
  vec4 ${name2}_(vec4 v) {
    return max( v, 0.0 );
  }
  `;
  return { body, name: name2, type: 0 /* ValueBased */ };
}
function glslSigmoid() {
  const name2 = "sigmoid";
  const body = `
  float ${name2}_(float a) {
    return 1.0 / (1.0 + exp(-a));
  }
  vec4 ${name2}_(vec4 v) {
    return 1.0 / (1.0 + exp(-v));
  }
  `;
  return { body, name: name2, type: 0 /* ValueBased */ };
}
function glslSqrt() {
  return glslBuiltinUnary("sqrt");
}
function glslTan() {
  return glslBuiltinUnary("tan");
}
function glslTanh() {
  const name2 = "tanh";
  const body = `
  float ${name2}_(float a) {
    a = clamp(a, -10., 10.);
    a = exp(2.*a);
    return (a - 1.) / (a + 1.);
  }
  vec4 ${name2}_(vec4 v) {
    v = clamp(v, -10., 10.);
    v = exp(2.*v);
    return (v - 1.) / (v + 1.);
  }
  `;
  return { body, name: name2, type: 0 /* ValueBased */ };
}
function glslBuiltinUnary(name2) {
  const body = `
  float ${name2}_(float a) {
    return ${name2}(a);
  }
  vec4 ${name2}_(vec4 v) {
    return ${name2}(v);
  }
  `;
  return { body, name: name2, type: 0 /* ValueBased */ };
}
var createElementwiseProgramInfo, createElementwiseProgramInfoLoader, abs, acos, asin, atan, clip, parseClipAttributes, clipV11, generateClipAttributesFromInputs, ceil, cos, elu, parseEluAttributes, exp, floor, identity, leakyRelu, parseLeakyReluAttributes, log2, neg, not2, relu, sigmoid, sin, sqrt, tan, tanh;
var init_unary_op = __esm({
  "web/lib/onnxjs/backends/webgl/ops/unary-op.ts"() {
    "use strict";
    init_attribute_with_cache_key();
    init_util();
    init_glsl_definitions();
    init_glsl_source();
    init_types();
    createElementwiseProgramInfo = (handler, metadata, input, glslFunc) => {
      const textureType = handler.session.pack ? 2 /* packed */ : 0 /* unpacked */;
      const glsl = getGlsl(handler.session.backend.glContext.version);
      return {
        ...metadata,
        output: { dims: input.dims, type: input.type, textureType },
        shaderSource: `
     ${glslFunc.body}
     void main() {
       vec4 v = ${glsl.texture2D}(A, TexCoords);
       v = ${glslFunc.name}_(v);
       ${glsl.output} = v;
     }
     `,
        hasMain: true
      };
    };
    createElementwiseProgramInfoLoader = (handler, input, glslFunc, cacheKey) => {
      const textureType = handler.session.pack ? 2 /* packed */ : 0 /* unpacked */;
      const metadata = { name: glslFunc.name, inputTypes: [textureType], inputNames: ["A"], cacheHint: cacheKey };
      return { ...metadata, get: () => createElementwiseProgramInfo(handler, metadata, input, glslFunc) };
    };
    abs = (handler, inputs) => [handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslAbs()), inputs)];
    acos = (handler, inputs) => [handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslAcos()), inputs)];
    asin = (handler, inputs) => [handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslAsin()), inputs)];
    atan = (handler, inputs) => [handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslAtan()), inputs)];
    clip = (handler, inputs, attributes) => [handler.run(
      createElementwiseProgramInfoLoader(
        handler,
        inputs[0],
        glslClip(attributes.min, attributes.max),
        attributes.cacheKey
      ),
      inputs
    )];
    parseClipAttributes = (node) => createAttributeWithCacheKey(
      { min: node.attributes.getFloat("min", MIN_CLIP), max: node.attributes.getFloat("max", MAX_CLIP) }
    );
    clipV11 = (handler, inputs) => {
      const attributes = generateClipAttributesFromInputs(handler, inputs);
      return clip(handler, [inputs[0]], attributes);
    };
    generateClipAttributesFromInputs = (handler, inputs) => {
      if (inputs.length >= 3 && (!handler.session.isInitializer(inputs[1].dataId) || !handler.session.isInitializer(inputs[2].dataId))) {
        throw new Error("dynamic clip attributes are not allowed");
      }
      const min = inputs.length >= 3 ? inputs[1].numberData[0] : MIN_CLIP;
      const max = inputs.length >= 3 ? inputs[2].numberData[0] : MAX_CLIP;
      return createAttributeWithCacheKey({ min, max });
    };
    ceil = (handler, inputs) => [handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslCeil()), inputs)];
    cos = (handler, inputs) => [handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslCos()), inputs)];
    elu = (handler, inputs, attributes) => [handler.run(
      createElementwiseProgramInfoLoader(handler, inputs[0], glslElu(attributes.alpha), attributes.cacheKey),
      inputs
    )];
    parseEluAttributes = (node) => createAttributeWithCacheKey({ alpha: node.attributes.getFloat("alpha", 1) });
    exp = (handler, inputs) => [handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslExp()), inputs)];
    floor = (handler, inputs) => [handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslFloor()), inputs)];
    identity = (handler, inputs) => [handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslIdentity()), inputs)];
    leakyRelu = (handler, inputs, attributes) => [handler.run(
      createElementwiseProgramInfoLoader(handler, inputs[0], glslLeakyRelu(attributes.alpha), attributes.cacheKey),
      inputs
    )];
    parseLeakyReluAttributes = (node) => createAttributeWithCacheKey({ alpha: node.attributes.getFloat("alpha", 0.01) });
    log2 = (handler, inputs) => [handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslLog()), inputs)];
    neg = (handler, inputs) => [handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslNeg()), inputs)];
    not2 = (handler, inputs) => [handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslNot()), inputs)];
    relu = (handler, inputs) => [handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslRelu()), inputs)];
    sigmoid = (handler, inputs) => [handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslSigmoid()), inputs)];
    sin = (handler, inputs) => [handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslSin()), inputs)];
    sqrt = (handler, inputs) => [handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslSqrt()), inputs)];
    tan = (handler, inputs) => [handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslTan()), inputs)];
    tanh = (handler, inputs) => [handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslTanh()), inputs)];
  }
});

// web/lib/onnxjs/backends/webgl/ops/fuse-utils.ts
function getActivationSnippet(attributes) {
  let func;
  switch (attributes.activation) {
    case "Relu":
      func = glslRelu();
      break;
    case "Sigmoid":
      func = glslSigmoid();
      break;
    case "Clip":
      func = glslClip(attributes.clipMin, attributes.clipMax);
      break;
    default:
      return { activationFunction: "", applyActivation: "" };
  }
  const activationName = func.name;
  const activationFunction = func.body;
  const applyActivation = `value = ${activationName}_(value);`;
  return { activationFunction, applyActivation };
}
var parseInternalActivationAttributes;
var init_fuse_utils = __esm({
  "web/lib/onnxjs/backends/webgl/ops/fuse-utils.ts"() {
    "use strict";
    init_util();
    init_unary_op();
    parseInternalActivationAttributes = (attributes) => {
      const activation = attributes.getString("activation", "");
      if (activation === "Clip") {
        const [clipMin, clipMax] = attributes.getFloats("activation_params", [MIN_CLIP, MAX_CLIP]);
        return { activation, clipMax, clipMin, activationCacheKey: `${activation}:${clipMin},${clipMax}` };
      }
      return { activation, activationCacheKey: activation };
    };
  }
});

// web/lib/onnxjs/backends/webgl/ops/conv-grouped.ts
var createUnpackedGroupedConvProgramMetadata, createUnpackedGroupedConvProgramInfo, createUnpackedGroupedConvProgramInfoLoader;
var init_conv_grouped = __esm({
  "web/lib/onnxjs/backends/webgl/ops/conv-grouped.ts"() {
    "use strict";
    init_instrument();
    init_glsl_source();
    init_types();
    init_conv();
    init_fuse_utils();
    createUnpackedGroupedConvProgramMetadata = (hasBias, cacheHint) => ({
      name: "GroupedConv",
      inputNames: hasBias ? ["X", "W", "Bias"] : ["X", "W"],
      inputTypes: hasBias ? [0 /* unpacked */, 0 /* unpacked */, 0 /* unpacked */] : [0 /* unpacked */, 0 /* unpacked */],
      cacheHint
    });
    createUnpackedGroupedConvProgramInfo = (inferenceHandler, inputs, metadata, attributes) => {
      const hasBias = inputs.length > 2;
      const processBias = hasBias ? "value += getBias(output_channel);" : "";
      const xShape = inputs[0].dims.slice();
      const wShape = inputs[1].dims.slice();
      const outputChannelsPerGroup = wShape[0] / attributes.group;
      Logger.verbose(
        "GroupedConv",
        `autpPad:${attributes.autoPad}, dilations:${attributes.dilations}, group:${attributes.group}, kernelShape:${attributes.kernelShape}, pads:${attributes.pads}, strides:${attributes.strides}`
      );
      const outputShape = calculateOutputShape(xShape, wShape, attributes.dilations, attributes.pads, attributes.strides);
      const glsl = getGlsl(inferenceHandler.session.backend.glContext.version);
      const { activationFunction, applyActivation } = getActivationSnippet(attributes);
      const shaderSource = `
  const ivec2 strides = ivec2(${attributes.strides[0]}, ${attributes.strides[1]});
  const ivec2 pads = ivec2(${attributes.pads[0]}, ${attributes.pads[1]});
  ${activationFunction}
  void main() {
    ivec4 coords = getOutputCoords();
    int batch = coords.x;
    int output_channel = coords.y;
    ivec2 xRCCorner = coords.zw * strides - pads;
    int group_id = output_channel / ${outputChannelsPerGroup};

    float value = 0.0;
    for (int wInChannel = 0; wInChannel < ${wShape[1]}; wInChannel++) {
      int input_channel = group_id * ${wShape[1]} + wInChannel;
      for (int wHeight = 0; wHeight < ${wShape[2]}; wHeight++) {
        int xHeight = xRCCorner.x + wHeight * ${attributes.dilations[0]};

        if (xHeight < 0 || xHeight >= ${xShape[2]}) {
          continue;
        }

        for (int wWidth = 0; wWidth < ${wShape[3]}; wWidth++) {
          int xWidth = xRCCorner.y + wWidth * ${attributes.dilations[1]};
          if (xWidth < 0 || xWidth >= ${xShape[3]}) {
            continue;
          }

          float xVal = getX(batch, input_channel, xWidth, xHeight);
          float wVal = getW(output_channel, wInChannel, wWidth, wHeight);
          value += xVal*wVal;
        }
      }
    }
    ${processBias}
    ${applyActivation}
    ${glsl.output} = vec4(value, .0, .0, .0);
  }
`;
      return {
        ...metadata,
        output: { dims: outputShape, type: inputs[0].type, textureType: 0 /* unpacked */ },
        shaderSource,
        hasMain: true
      };
    };
    createUnpackedGroupedConvProgramInfoLoader = (inferenceHandler, inputs, attributes) => {
      const metadata = createUnpackedGroupedConvProgramMetadata(inputs.length > 2, attributes.cacheKey);
      return {
        ...metadata,
        get: () => createUnpackedGroupedConvProgramInfo(inferenceHandler, inputs, metadata, attributes)
      };
    };
  }
});

// web/lib/onnxjs/backends/webgl/ops/im2col-pack.ts
var createPackedIm2ColProgramMetadata, createPackedIm2ColProgramInfo, createPackedIm2ColProgramInfoLoader;
var init_im2col_pack = __esm({
  "web/lib/onnxjs/backends/webgl/ops/im2col-pack.ts"() {
    "use strict";
    init_glsl_source();
    init_types();
    init_packing_utils();
    createPackedIm2ColProgramMetadata = (cacheHint) => ({
      name: "Im2Col (packed)",
      inputNames: ["A"],
      inputTypes: [2 /* packed */],
      cacheHint
    });
    createPackedIm2ColProgramInfo = (inferenceHandler, metadata, x, w, outputShape, attributes) => {
      const xshape = x.dims;
      const wshape = w.dims;
      const rowDim = 2;
      const colDim = 3;
      const rank = outputShape.length;
      const im2colShape = [wshape[1] * wshape[2] * wshape[3], outputShape[2] * outputShape[3]];
      const kernelSize = wshape[2] * wshape[3];
      const unpackChannel = unpackFromChannel();
      const glsl = getGlsl(inferenceHandler.session.backend.glContext.version);
      let unrolled = "";
      for (let row = 0; row <= 1; row++) {
        for (let col = 0; col <= 1; col++) {
          unrolled += `
            blockIndex = rc.x + ${col};
            pos = rc.y + ${row};

            if(blockIndex < ${im2colShape[1]} && pos < ${im2colShape[0]}) {
              offsetY = int(blockIndex / (${outputShape[rank - 1]})) * ${attributes.strides[0]} -
                ${attributes.pads[0]};
              d0 = offsetY + ${attributes.dilations[0]} * (imod(pos, ${kernelSize}) / ${wshape[2]});

              if(d0 < ${xshape[rowDim]} && d0 >= 0) {
                offsetX = imod(blockIndex, ${outputShape[rank - 1]}) * ${attributes.strides[1]} -
                  ${attributes.pads[1]};
                d1 = offsetX + ${attributes.dilations[1]} * imod(imod(pos, ${kernelSize}), ${wshape[2]});

                if(d1 < ${xshape[colDim]} && d1 >= 0) {

                  ch = int(float(pos)/ ${kernelSize}.);
                    innerDims = vec2(d0, d1);
                    result[${row * 2 + col}] = getChannel(
                      getA(0, ch, int(innerDims.x),
                      int(innerDims.y)), innerDims);
                }
              }
            }

          `;
        }
      }
      const shaderSource = `
      ${unpackChannel}

      void main() {
        ivec2 rc = getOutputCoords();
          vec4 result = vec4(0.0);
          int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
          vec2 innerDims;
          ${unrolled}
          ${glsl.output} = result;
      }
            `;
      return {
        ...metadata,
        output: { dims: im2colShape, type: x.type, textureType: 2 /* packed */ },
        shaderSource,
        hasMain: true
      };
    };
    createPackedIm2ColProgramInfoLoader = (inferenceHandler, x, w, outputShape, attributes) => {
      const metadata = createPackedIm2ColProgramMetadata(attributes.cacheKey);
      return {
        ...metadata,
        get: () => createPackedIm2ColProgramInfo(inferenceHandler, metadata, x, w, outputShape, attributes)
      };
    };
  }
});

// web/lib/onnxjs/backends/webgl/ops/matmul.ts
function createMatmulProgramInfo(metadata, inputs, activationAttributes) {
  const aShape = inputs[0].dims;
  const bShape = inputs[1].dims;
  const outputShape = BroadcastUtil.calcShape(aShape, bShape, true);
  if (!outputShape) {
    throw new Error("Can't use matmul on the given tensors");
  }
  const coordsDataType = getCoordsDataType(outputShape.length);
  const allGlChannels = getGlChannels();
  const { activationFunction, applyActivation } = getActivationSnippet(activationAttributes);
  const hasBias = inputs.length > 2;
  const processBias = hasBias ? "value += getBiasForMatmul();" : "";
  const getBiasForMatmulSnippet = hasBias ? `${getBiasForMatmul(coordsDataType, allGlChannels, inputs[2].dims, outputShape, false)}` : "";
  const rank = outputShape.length;
  const arank = aShape.length;
  const brank = bShape.length;
  const sharedDim = aShape[aShape.length - 1];
  const shaderSource = `
    ${activationFunction}
    ${getBiasForMatmulSnippet}
    float process(int indices[${rank}]) {
        int a[${arank}];
        int b[${brank}];
        bcastMatmulIndices_A(indices, a);
        bcastMatmulIndices_B(indices, b);

        float value;
        for (int k=0; k<${sharedDim}; ++k) {
            a[${arank - 1}] = k;
            b[${brank - 2}] = k;
            value += _A(a) * _B(b);
        }
        ${processBias}
        ${applyActivation}
        return value;
    }`;
  return {
    ...metadata,
    output: { dims: outputShape, type: inputs[0].type, textureType: 0 /* unpacked */ },
    shaderSource
  };
}
function createMatmulProgramInfoLoader(inputs, activationAttributes) {
  const metadata = createMatmulProgramMetadata(inputs.length > 2, activationAttributes.activationCacheKey);
  return { ...metadata, get: () => createMatmulProgramInfo(metadata, inputs, activationAttributes) };
}
function getBiasForMatmul(coordsDataType, allGlChannels, inShape, outShape, isPacked) {
  let unpackedCoordsSnippet = "";
  const inRank = inShape.length;
  const outRank = outShape.length;
  const rankDiff = outRank - inRank;
  if (outRank < 2 && inRank > 0) {
    unpackedCoordsSnippet = "coords";
  } else {
    unpackedCoordsSnippet = inShape.map((_s, i) => `coords.${allGlChannels[i + rankDiff]}`).join(", ");
  }
  const broadcastDims = BroadcastUtil.getBroadcastDims(inShape, outShape);
  const coordsSnippet = broadcastDims.map((d) => `coords.${allGlChannels[d + rankDiff]} = 0;`).join("\n");
  const inSize = ShapeUtil.size(inShape);
  const isInputScalar = inSize === 1;
  let output = "vec4(outputValue.xx, outputValue.yy)";
  if (isInputScalar) {
    output = "vec4(outputValue.x)";
  }
  const getBiasForMatmulSource = isPacked ? `
vec4 getBiasForMatmul() {
  ${coordsDataType} coords = getOutputCoords();
  ${coordsSnippet}
  vec4 outputValue = getBias(${unpackedCoordsSnippet});
  return ${output};
}` : `
float getBiasForMatmul() {
  ${coordsDataType} coords = getOutputCoords();
  ${coordsSnippet}
  return getBias(coords.x);
}`;
  return getBiasForMatmulSource;
}
var matMul, parseMatMulAttributes, createMatmulProgramMetadata, validateInputs4;
var init_matmul = __esm({
  "web/lib/onnxjs/backends/webgl/ops/matmul.ts"() {
    "use strict";
    init_util();
    init_types();
    init_utils();
    init_fuse_utils();
    init_matmul_pack();
    matMul = (inferenceHandler, inputs, attributes) => {
      validateInputs4(inputs);
      if (inferenceHandler.session.pack) {
        return [inferenceHandler.run(
          createPackedMatmulProgramInfoLoader(inferenceHandler, inputs, attributes),
          inputs
        )];
      } else {
        return [inferenceHandler.run(createMatmulProgramInfoLoader(inputs, attributes), inputs)];
      }
    };
    parseMatMulAttributes = (node) => parseInternalActivationAttributes(node.attributes);
    createMatmulProgramMetadata = (hasBias, cacheHint) => ({
      name: "MatMul",
      inputNames: hasBias ? ["A", "B", "Bias"] : ["A", "B"],
      inputTypes: hasBias ? [0 /* unpacked */, 0 /* unpacked */, 0 /* unpacked */] : [0 /* unpacked */, 0 /* unpacked */],
      cacheHint
    });
    validateInputs4 = (inputs) => {
      if (!inputs || inputs.length !== 2) {
        throw new Error("MatMul requires 2 inputs.");
      }
      if (inputs[0].dims[inputs[0].dims.length - 1] !== inputs[1].dims[inputs[1].dims.length - 2]) {
        throw new Error("shared dimension does not match.");
      }
      if (inputs[0].type !== "float32" && inputs[0].type !== "float64" || inputs[1].type !== "float32" && inputs[1].type !== "float64") {
        throw new Error("inputs should be float type");
      }
      if (inputs[0].type !== inputs[1].type) {
        throw new Error("inputs types should match");
      }
    };
  }
});

// web/lib/onnxjs/backends/webgl/ops/matmul-pack.ts
function getBcastSamplerForMatmul(coordsDataType, allGlChannels, inputs, outShape) {
  let unpackedACoordsSnippet = [];
  let unpackedBCoordsSnippet = [];
  const inAShape = inputs[0].dims;
  const inBShape = inputs[1].dims;
  const inARank = inAShape.length;
  const inBRank = inBShape.length;
  const outRank = outShape.length;
  const rankADiff = outRank - inARank;
  const rankBDiff = outRank - inBRank;
  unpackedACoordsSnippet = inAShape.map((_s, i) => `coords.${allGlChannels[i + rankADiff]}`);
  unpackedACoordsSnippet[inARank - 1] = "i*2";
  unpackedACoordsSnippet.join(", ");
  unpackedBCoordsSnippet = inBShape.map((_s, i) => `coords.${allGlChannels[i + rankBDiff]}`);
  unpackedBCoordsSnippet[inBRank - 2] = "i*2";
  unpackedBCoordsSnippet.join(", ");
  const broadcastADims = BroadcastUtil.getBroadcastDims(inAShape, outShape);
  const broadcastBDims = BroadcastUtil.getBroadcastDims(inBShape, outShape);
  const coordsASnippet = broadcastADims.map((d) => `coords.${allGlChannels[d + rankADiff]} = 0;`).join("\n");
  const coordsBSnippet = broadcastBDims.map((d) => `coords.${allGlChannels[d + rankBDiff]} = 0;`).join("\n");
  const swapDimSnippet = `int lastDim = coords.${allGlChannels[outRank - 1]};
  coords.${allGlChannels[outRank - 1]} = coords.${allGlChannels[outRank - 2]};
  coords.${allGlChannels[outRank - 2]} = lastDim;`;
  const getBcastSamplerMatmulSource = `
vec4 getAAtOutCoordsMatmul(int i) {
  ${coordsDataType} coords = getOutputCoords();
  ${swapDimSnippet}
  ${coordsASnippet}
  vec4 outputValue = getA(${unpackedACoordsSnippet});
  return outputValue;
}

vec4 getBAtOutCoordsMatmul(int i) {
  ${coordsDataType} coords = getOutputCoords();
  ${swapDimSnippet}
  ${coordsBSnippet}
  vec4 outputValue = getB(${unpackedBCoordsSnippet});
  return outputValue;
}`;
  return getBcastSamplerMatmulSource;
}
function getA(allGlChannels, rank) {
  let res = "";
  for (let i = 0; i < rank - 2; i++) {
    res += `rc.${allGlChannels[i]}, `;
  }
  res += `rc.${allGlChannels[rank - 2]}, i*2`;
  return res;
}
function getB(allGlChannels, rank) {
  let res = "";
  for (let i = 0; i < rank - 2; i++) {
    res += `rc.${allGlChannels[i]}, `;
  }
  res += `i*2, rc.${allGlChannels[rank - 1]}`;
  return res;
}
var createPackedMatmulProgramMetadata, createPackedMatmulProgramInfo, createPackedMatmulProgramInfoLoader;
var init_matmul_pack = __esm({
  "web/lib/onnxjs/backends/webgl/ops/matmul-pack.ts"() {
    "use strict";
    init_util();
    init_glsl_source();
    init_types();
    init_utils();
    init_fuse_utils();
    init_matmul();
    createPackedMatmulProgramMetadata = (hasBias, cacheHint) => ({
      name: "MatMul (packed)",
      inputNames: hasBias ? ["A", "B", "Bias"] : ["A", "B"],
      inputTypes: hasBias ? [2 /* packed */, 2 /* packed */, 2 /* packed */] : [2 /* packed */, 2 /* packed */],
      cacheHint
    });
    createPackedMatmulProgramInfo = (inferenceHandler, metadata, inputs, activationAttributes) => {
      const hasBias = inputs.length > 2;
      const processBias = hasBias ? "value += getBiasForMatmul();" : "";
      const aShape = inputs[0].dims;
      const bShape = inputs[1].dims;
      const outputShape = BroadcastUtil.calcShape(aShape, bShape, true);
      const isBroadcast = !ShapeUtil.areEqual(inputs[0].dims, inputs[1].dims);
      if (!outputShape) {
        throw new Error("Can't use matmul on the given tensors");
      }
      const sharedDim = aShape[aShape.length - 1];
      const sharedDimIndex = Math.ceil(sharedDim / 2);
      const aRank = aShape.length;
      const bRank = bShape.length;
      const glsl = getGlsl(inferenceHandler.session.backend.glContext.version);
      const coordsDataType = getCoordsDataType(outputShape.length);
      const outRank = outputShape.length;
      const allGlChannels = getGlChannels();
      const { activationFunction, applyActivation } = getActivationSnippet(activationAttributes);
      const getBiasForMatmulSnippet = hasBias ? `${getBiasForMatmul(coordsDataType, allGlChannels, inputs[2].dims, outputShape, true)}` : "";
      const getBcastedSamplerForMatmulSnippet = isBroadcast ? `${getBcastSamplerForMatmul(coordsDataType, allGlChannels, inputs, outputShape)}` : "";
      const getSamplerAInLoopSnippet = isBroadcast ? "getAAtOutCoordsMatmul(i)" : `getA(${getA(allGlChannels, aRank)})`;
      const getSamplerBInLoopSnippet = isBroadcast ? "getBAtOutCoordsMatmul(i)" : `getB(${getB(allGlChannels, bRank)})`;
      const getOutputCoordsSnippet = isBroadcast ? "" : `${coordsDataType} rc =
          getOutputCoords(); int lastDim = rc.${allGlChannels[outRank - 1]}; rc.${allGlChannels[outRank - 1]} =
          rc.${allGlChannels[outRank - 2]}; rc.${allGlChannels[outRank - 2]} = lastDim;
      `;
      const shaderSource = `
            ${getBcastedSamplerForMatmulSnippet}
            ${getBiasForMatmulSnippet}
            ${activationFunction}
            void main() {
              ${getOutputCoordsSnippet}

              vec4 value = vec4(0);
              for (int i = 0; i < ${sharedDimIndex}; i++) {
                vec4 a = ${getSamplerAInLoopSnippet};
                vec4 b = ${getSamplerBInLoopSnippet};

                value += (a.rrbb * b.rgrg);
                value += (a.ggaa * b.baba);
              }
              ${processBias}
              ${applyActivation}
              ${glsl.output} = value;
            }`;
      return {
        ...metadata,
        output: { dims: outputShape, type: inputs[0].type, textureType: 2 /* packed */ },
        shaderSource,
        hasMain: true
      };
    };
    createPackedMatmulProgramInfoLoader = (inferenceHandler, inputs, activationAttributes) => {
      const metadata = createPackedMatmulProgramMetadata(inputs.length > 2, activationAttributes.activationCacheKey);
      return {
        ...metadata,
        get: () => createPackedMatmulProgramInfo(inferenceHandler, metadata, inputs, activationAttributes)
      };
    };
  }
});

// web/lib/onnxjs/backends/webgl/ops/conv-pack.ts
var conv2DPacked;
var init_conv_pack = __esm({
  "web/lib/onnxjs/backends/webgl/ops/conv-pack.ts"() {
    "use strict";
    init_conv();
    init_im2col_pack();
    init_matmul_pack();
    conv2DPacked = (inferenceHandler, inputs, attributes) => {
      const xshape = inputs[0].dims;
      const kshape = inputs[1].dims;
      const outputShape = calculateOutputShape(xshape, kshape, attributes.dilations, attributes.pads, attributes.strides);
      const im2colOutput = inferenceHandler.run(
        createPackedIm2ColProgramInfoLoader(inferenceHandler, inputs[0], inputs[1], outputShape, attributes),
        [inputs[0]]
      );
      const kernelReshaped = inferenceHandler.reshapePacked(inputs[1], [kshape[0], kshape[1] * kshape[2] * kshape[3]]);
      const matmulInputs = inputs.length === 3 ? [kernelReshaped, im2colOutput, inputs[2]] : [kernelReshaped, im2colOutput];
      const matmulOutput = inferenceHandler.run(
        createPackedMatmulProgramInfoLoader(inferenceHandler, matmulInputs, attributes),
        matmulInputs
      );
      const outputReshaped = inferenceHandler.reshapePacked(matmulOutput, outputShape);
      return outputReshaped;
    };
  }
});

// web/lib/onnxjs/backends/webgl/ops/im2col.ts
var createIm2ColProgramMetadata, createIm2ColProgramInfo, createIm2ColProgramInfoLoader, calculateIm2ColDims;
var init_im2col = __esm({
  "web/lib/onnxjs/backends/webgl/ops/im2col.ts"() {
    "use strict";
    init_types();
    createIm2ColProgramMetadata = (cacheHint) => ({
      name: "Im2Col",
      inputNames: ["X"],
      inputTypes: [0 /* unpacked */],
      cacheHint
    });
    createIm2ColProgramInfo = (_inferenceHandler, metadata, x, w, outputShape, attributes) => {
      const xshape = x.dims;
      const wshape = w.dims;
      const rank = outputShape.length;
      const im2colDims = calculateIm2ColDims(xshape, wshape, outputShape, 4);
      const shaderSource = `
        const int XC = ${xshape[1]};
        const int XH = ${xshape[2]};
        const int XW = ${xshape[3]};
        const int KH = ${attributes.kernelShape[0]};
        const int KW = ${attributes.kernelShape[1]};
        const int dilationH = ${attributes.dilations[0]};
        const int dilationW = ${attributes.dilations[1]};
        const int strideH = ${attributes.strides[0]};
        const int strideW = ${attributes.strides[1]};
        const int padH = ${attributes.pads[0]};
        const int padW = ${attributes.pads[1]};
        const int KHKW = KH*KW;
        const int XCKHKW = XC * KHKW;
        const int outputChannels = 4;
        vec4 process(int indices[${rank}]) {
          int b  = indices[0]; // batch size
          int oh = indices[1] * strideH - padH; //output height
          int ow = indices[2] * strideW - padW; //output width
          int p = indices[3] * outputChannels; //patch
          vec4 value = vec4(0.0);
          for(int i=0; i < outputChannels; ++i) {
            if(p < XCKHKW) {
              int patchC = p / KHKW;
              int patchH = (p - patchC*KHKW) / KW;
              int patchW = (p - patchC*KHKW) - patchH * KW;
              int xh2 = oh + patchH * dilationH;
              int xw2 = ow + patchW * dilationW;
              int x[${xshape.length}];
              x[0] = b;
              x[1] = patchC;
              x[2] = xh2;
              x[3] = xw2;
              if(xh2 >= 0 &&
                  xh2 < XH &&
                  xw2 >= 0 &&
                  xw2 < XW) {
                value[i] = _X(x);
              }
            }
            ++p;
          }
          return value;
        }
        `;
      return {
        ...metadata,
        output: { dims: im2colDims, type: x.type, textureType: 4 /* packedLastDimension */ },
        shaderSource
      };
    };
    createIm2ColProgramInfoLoader = (inferenceHandler, x, w, outputShape, attributes) => {
      const metadata = createIm2ColProgramMetadata(attributes.cacheKey);
      return {
        ...metadata,
        get: () => createIm2ColProgramInfo(inferenceHandler, metadata, x, w, outputShape, attributes)
      };
    };
    calculateIm2ColDims = (inputShape, kernelShape, outputShape, channels = 4) => [
      outputShape[0],
      outputShape[2],
      outputShape[3],
      Math.ceil(inputShape[1] * kernelShape[2] * kernelShape[3] / channels)
    ];
  }
});

// web/lib/onnxjs/backends/webgl/ops/dot-product.ts
var createDotProductProgramMetadata, createDotProductProgramInfo, createDotProductProgramInfoLoader;
var init_dot_product = __esm({
  "web/lib/onnxjs/backends/webgl/ops/dot-product.ts"() {
    "use strict";
    init_util();
    init_glsl_source();
    init_types();
    init_fuse_utils();
    init_im2col();
    createDotProductProgramMetadata = (hasBias, attributes) => ({
      name: "ConvDotProduct",
      inputNames: hasBias ? ["Im2Col", "K", "B"] : ["Im2Col", "K"],
      inputTypes: hasBias ? [0 /* unpacked */, 4 /* packedLastDimension */, 0 /* unpacked */] : [0 /* unpacked */, 4 /* packedLastDimension */],
      cacheKey: attributes.activationCacheKey
    });
    createDotProductProgramInfo = (inferenceHandler, metadata, inputs, outputShape, attributes) => {
      const xshape = inputs[0].dims;
      const kshape = inputs[1].dims;
      const adjustedKernelShape = [kshape[0], Math.ceil(xshape[1] * kshape[2] * kshape[3] / 4)];
      const im2colShape = calculateIm2ColDims(xshape, kshape, outputShape);
      const [kWidth, kHeight] = inferenceHandler.calculateTextureWidthAndHeight(adjustedKernelShape, 4 /* packedLastDimension */);
      const im2colStrides = ShapeUtil.computeStrides(im2colShape);
      const [im2colWidth, im2colHeight] = inferenceHandler.calculateTextureWidthAndHeight(im2colShape, 4 /* packedLastDimension */);
      const rank = outputShape.length;
      const initValue = inputs.length < 3 ? "0.0" : "_B(b)";
      const sharedDim = Math.ceil(xshape[1] * kshape[2] * kshape[3] / 4);
      const { activationFunction, applyActivation } = getActivationSnippet(attributes);
      const glsl = getGlsl(inferenceHandler.session.backend.glContext.version);
      const shaderSource = `
${activationFunction}
float process(int indices[${rank}]) {
  int b[1];
  b[0] = indices[1];
  int im2col[4];
  im2col[0] = indices[0];
  im2col[1] = indices[2];
  im2col[2] = indices[3];
  int im2colOffset = im2col[0] * ${im2colStrides[0]} + im2col[1] * ${im2colStrides[1]} + im2col[2] * ${im2colStrides[2]};
  int kernelOffset = indices[1] * ${adjustedKernelShape[1]};
  float value = ${initValue};
  for (int i = 0; i < ${sharedDim}; ++i) {
    vec2 im2colCoords = offsetToCoords(im2colOffset, ${im2colWidth}, ${im2colHeight});
    vec2 kernelCoords = offsetToCoords(kernelOffset, ${kWidth}, ${kHeight});
    value += dot(${glsl.texture2D}(Im2Col, im2colCoords), ${glsl.texture2D}(K, kernelCoords));
    ++im2colOffset;
    ++kernelOffset;
  }
  ${applyActivation}
  return value;
}`;
      return {
        ...metadata,
        output: { dims: outputShape, type: inputs[0].type, textureType: 0 /* unpacked */ },
        shaderSource
      };
    };
    createDotProductProgramInfoLoader = (inferenceHandler, inputs, outputShape, attributes) => {
      const metadata = createDotProductProgramMetadata(inputs.length > 2, attributes);
      return {
        ...metadata,
        get: () => createDotProductProgramInfo(inferenceHandler, metadata, inputs, outputShape, attributes)
      };
    };
  }
});

// web/lib/onnxjs/backends/webgl/ops/conv.ts
var calculateOutputShape, conv, conv2d, conv2DUnpackedPointwise, conv2DUnpacked, getAdjustedConvAttributes, parseConvAttributes, validateInputs5;
var init_conv = __esm({
  "web/lib/onnxjs/backends/webgl/ops/conv.ts"() {
    "use strict";
    init_attribute_with_cache_key();
    init_util();
    init_conv_grouped();
    init_conv_pack();
    init_dot_product();
    init_fuse_utils();
    init_im2col();
    init_matmul();
    calculateOutputShape = (inputShape, kernelShape, dilations, adjustPads, strides) => {
      const batchSize = inputShape[0];
      const inputSpatialShape = inputShape.slice(2);
      const spatialRank = inputSpatialShape.length;
      const outChannels = kernelShape[0];
      const kernelSpatialShape = kernelShape.slice(2);
      const dilatedKernelShape = kernelSpatialShape.map((v, i) => v + (v - 1) * (dilations[i] - 1));
      const inputSpatialShapeWithPad = inputSpatialShape.map((v, i) => v + adjustPads[i] + adjustPads[i + spatialRank]);
      const outputSpatialShape = inputSpatialShapeWithPad.map((v, i) => Math.floor((v - dilatedKernelShape[i] + strides[i]) / strides[i]));
      const outputShape = [batchSize, outChannels].concat(...outputSpatialShape);
      return outputShape;
    };
    conv = (inferenceHandler, inputs, attributes) => {
      validateInputs5(inputs, attributes);
      return conv2d(inferenceHandler, inputs, attributes);
    };
    conv2d = (inferenceHandler, inputs, attributes) => {
      const adjustedAttributes = getAdjustedConvAttributes(attributes, inputs);
      const packMode = inferenceHandler.session.pack;
      const isPointwise = adjustedAttributes.kernelShape[0] === 1 && adjustedAttributes.kernelShape[1] === 1;
      if (adjustedAttributes.group > 1) {
        const result = inferenceHandler.run(
          createUnpackedGroupedConvProgramInfoLoader(inferenceHandler, inputs, adjustedAttributes),
          inputs
        );
        return [result];
      } else if (isPointwise && packMode) {
        return [conv2DUnpackedPointwise(inferenceHandler, inputs, adjustedAttributes)];
      } else if (packMode && inputs[0].dims.length === 4 && inputs[0].dims[0] === 1 && !isPointwise) {
        return [conv2DPacked(inferenceHandler, inputs, adjustedAttributes)];
      } else {
        return [conv2DUnpacked(inferenceHandler, inputs, adjustedAttributes)];
      }
    };
    conv2DUnpackedPointwise = (inferenceHandler, inputs, attributes) => {
      const xshape = inputs[0].dims;
      const kshape = inputs[1].dims;
      const outputShape = calculateOutputShape(xshape, kshape, attributes.dilations, attributes.pads, attributes.strides);
      const reshapedX = inferenceHandler.reshapeUnpacked(inputs[0], [xshape[1], xshape[2] * xshape[3]]);
      const reshapedK = inferenceHandler.reshapeUnpacked(inputs[1], [kshape[0], kshape[1]]);
      const matmulInputs = inputs.length > 2 ? [reshapedK, reshapedX, inputs[2]] : [reshapedK, reshapedX];
      const matmulOutput = inferenceHandler.run(createMatmulProgramInfoLoader(matmulInputs, attributes), matmulInputs);
      return inferenceHandler.reshapeUnpacked(matmulOutput, outputShape);
    };
    conv2DUnpacked = (inferenceHandler, inputs, attributes) => {
      const xshape = inputs[0].dims;
      const kshape = inputs[1].dims;
      const outputShape = calculateOutputShape(xshape, kshape, attributes.dilations, attributes.pads, attributes.strides);
      const xIm2Col = inferenceHandler.run(
        createIm2ColProgramInfoLoader(inferenceHandler, inputs[0], inputs[1], outputShape, attributes),
        [inputs[0]]
      );
      const dotProductInputs = inputs.length === 3 ? [xIm2Col, inputs[1], inputs[2]] : [xIm2Col, inputs[1]];
      const output = inferenceHandler.run(
        createDotProductProgramInfoLoader(inferenceHandler, inputs, outputShape, attributes),
        dotProductInputs
      );
      return output;
    };
    getAdjustedConvAttributes = (attributes, inputs) => {
      const kernelShape = attributes.kernelShape.slice();
      if (attributes.kernelShape.length === 0) {
        for (let i = 2; i < inputs[1].dims.length; ++i) {
          kernelShape.push(inputs[1].dims[i]);
        }
      }
      const pads = attributes.pads.slice();
      PoolConvUtil.adjustPadsBasedOnAutoPad(
        inputs[0].dims,
        attributes.strides,
        attributes.dilations,
        kernelShape,
        pads,
        attributes.autoPad
      );
      const newAttributes = Object.assign({}, attributes);
      Object.assign(newAttributes, { kernelShape, pads, cacheKey: attributes.cacheKey });
      return newAttributes;
    };
    parseConvAttributes = (node) => {
      const attributes = node.attributes;
      const activationAttributes = parseInternalActivationAttributes(attributes);
      const autoPad = attributes.getString("auto_pad", "NOTSET");
      const dilations = attributes.getInts("dilations", [1, 1]);
      const group = attributes.getInt("group", 1);
      const kernelShape = attributes.getInts("kernel_shape", []);
      const pads = attributes.getInts("pads", [0, 0, 0, 0]);
      const strides = attributes.getInts("strides", [1, 1]);
      return createAttributeWithCacheKey({ autoPad, dilations, group, kernelShape, pads, strides, ...activationAttributes });
    };
    validateInputs5 = (inputs, attributes) => {
      if (!inputs || inputs.length !== 2 && inputs.length !== 3) {
        throw new Error("Conv requires 2 or 3 inputs");
      }
      if (inputs[0].dims.length !== 4 || inputs[1].dims.length !== 4) {
        throw new Error("currently only support 2-dimensional conv");
      }
      const dataChannel = inputs[0].dims[1];
      const filterInChannel = inputs[1].dims[1] * attributes.group;
      if (dataChannel !== filterInChannel) {
        throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");
      }
      if (inputs.length === 3 && (inputs[2].dims.length !== 1 || inputs[1].dims[0] !== inputs[2].dims[0])) {
        throw new Error("invalid bias");
      }
      const spatialRank = inputs[0].dims.length - 2;
      if (attributes.dilations.length !== spatialRank) {
        throw new Error(`dilations should be ${spatialRank}D`);
      }
      if (attributes.strides.length !== spatialRank) {
        throw new Error(`strides should be ${spatialRank}D`);
      }
      if (attributes.pads.length !== spatialRank * 2) {
        throw new Error(`pads should be ${spatialRank * 2}D`);
      }
      if (attributes.kernelShape.length !== 0 && attributes.kernelShape.length !== inputs[1].dims.length - 2) {
        throw new Error("invalid kernel shape");
      }
      if (inputs[0].type !== "float32" || inputs[1].type !== "float32") {
        throw new Error("Conv input(X,W) should be float tensor");
      }
      if (inputs.length === 3 && inputs[2].type !== "float32") {
        throw new Error("Conv input(bias) should be float tensor");
      }
    };
  }
});

// web/lib/onnxjs/backends/webgl/ops/conv-transpose.ts
var computeTotalPad, distributePadding, calculateOutputShapeAndPads, convTranspose, convTranspose2d, createConvTransposeProgramMetadata, createUnpackedConvTransposeProgramInfo, createUnpackedConvTransposeProgramInfoLoader, convTranspose2DUnpacked, getAdjustedConvTransposeAttributes, parseConvTransposeAttributes, validateInputs6;
var init_conv_transpose = __esm({
  "web/lib/onnxjs/backends/webgl/ops/conv-transpose.ts"() {
    "use strict";
    init_attribute_with_cache_key();
    init_glsl_source();
    init_types();
    init_fuse_utils();
    computeTotalPad = (inDim, stride, adj, kernel, dilation, outSize) => (inDim - 1) * stride + adj + (kernel - 1) * dilation + 1 - outSize;
    distributePadding = (totalPad, autoPad, pads, head, tail) => {
      const smallPad = Math.floor(totalPad / 2);
      if (autoPad === "SAME_UPPER") {
        pads[head] = smallPad;
        pads[tail] = totalPad - smallPad;
      } else if (autoPad === "SAME_LOWER") {
        pads[head] = totalPad - smallPad;
        pads[tail] = smallPad;
      }
    };
    calculateOutputShapeAndPads = (inputShape, kernelShape, dilations, autoPad, pads, strides, outputPadding, outputShape) => {
      const spatialRank = inputShape.length - 2;
      const updateShape = outputShape.length === 0;
      for (let i = 0; i < spatialRank; ++i) {
        const outSize = updateShape ? inputShape[i + 2] * strides[i] : outputShape[i];
        const totalPad = computeTotalPad(inputShape[i + 2], strides[i], pads[i], kernelShape[i], dilations[i], outSize);
        distributePadding(totalPad, autoPad, pads, i, i + spatialRank);
        if (updateShape) {
          outputShape.push(
            strides[i] * (inputShape[i + 2] - 1) + outputPadding[i] + (kernelShape[i] - 1) * dilations[i] + 1 - pads[i] - pads[i + spatialRank]
          );
        }
      }
    };
    convTranspose = (inferenceHandler, inputs, attributes) => {
      validateInputs6(inputs, attributes);
      return convTranspose2d(inferenceHandler, inputs, attributes);
    };
    convTranspose2d = (inferenceHandler, inputs, attributes) => {
      const adjustedAttributes = getAdjustedConvTransposeAttributes(attributes, inputs);
      return [convTranspose2DUnpacked(inferenceHandler, inputs, adjustedAttributes)];
    };
    createConvTransposeProgramMetadata = (hasBias, cacheHint) => ({
      name: "ConvTranspose",
      inputNames: hasBias ? ["X", "W", "B"] : ["X", "W"],
      inputTypes: hasBias ? [0 /* unpacked */, 0 /* unpacked */, 0 /* unpacked */] : [0 /* unpacked */, 0 /* unpacked */],
      cacheHint
    });
    createUnpackedConvTransposeProgramInfo = (inferenceHandler, inputs, metadata, attributes) => {
      const hasBias = inputs.length > 2;
      const valueInit = hasBias ? "getB(output_channel)" : "0.0";
      const xShape = inputs[0].dims;
      const wShape = inputs[1].dims;
      const outputChannelsPerGroup = wShape[1];
      const inputChannelsPerGroup = wShape[0] / attributes.group;
      const outputShape = [inputs[0].dims[0], inputs[1].dims[1] * attributes.group, ...attributes.outputShape];
      const glsl = getGlsl(inferenceHandler.session.backend.glContext.version);
      const { activationFunction, applyActivation } = getActivationSnippet(attributes);
      const shaderSource = `
  const ivec2 strides = ivec2(${attributes.strides[0]}, ${attributes.strides[1]});
  const ivec2 pads = ivec2(${attributes.pads[0]}, ${attributes.pads[1]});
  ${activationFunction}
  void main() {
    ivec4 coords = getOutputCoords();
    int batch = coords.x;
    int output_channel = coords.y;

    ivec2 loc = coords.zw + pads;

    int group_id = output_channel / ${outputChannelsPerGroup};
    int wOutChannel = output_channel - group_id * ${outputChannelsPerGroup};

    float value = ${valueInit};
    for (int inChannelOffset = 0; inChannelOffset < ${inputChannelsPerGroup}; inChannelOffset++) {
      int input_channel = group_id * ${inputChannelsPerGroup} + inChannelOffset;
      for (int wWOff = 0; wWOff < ${wShape[2]}; wWOff++) {
        for (int wHOff = 0; wHOff < ${wShape[3]}; wHOff++) {
          ivec2 wOff = ivec2(wWOff * ${attributes.dilations[0]}, wHOff * ${attributes.dilations[1]});
          ivec2 wLoc = loc - wOff;
          ivec2 wLocIn = wLoc / strides;
          if (
            wLocIn * strides == wLoc &&
            wLocIn.x >= 0 && wLocIn.x < ${xShape[2]} &&
            wLocIn.y >= 0 && wLocIn.y < ${xShape[3]}
          ) {
            float xVal = getX(batch, input_channel, wLocIn.y, wLocIn.x);
            float wVal = getW(input_channel, wOutChannel, wHOff, wWOff);
            value += xVal * wVal;
          }
        }
      }
    }
    ${applyActivation}
    ${glsl.output} = vec4(value, .0, .0, .0);
  }
`;
      return {
        ...metadata,
        output: { dims: outputShape, type: inputs[0].type, textureType: 0 /* unpacked */ },
        shaderSource,
        hasMain: true
      };
    };
    createUnpackedConvTransposeProgramInfoLoader = (inferenceHandler, inputs, attributes) => {
      const metadata = createConvTransposeProgramMetadata(inputs.length > 2, attributes.cacheKey);
      return {
        ...metadata,
        get: () => createUnpackedConvTransposeProgramInfo(inferenceHandler, inputs, metadata, attributes)
      };
    };
    convTranspose2DUnpacked = (inferenceHandler, inputs, attributes) => {
      const result = inferenceHandler.run(
        createUnpackedConvTransposeProgramInfoLoader(inferenceHandler, inputs, attributes),
        inputs
      );
      return result;
    };
    getAdjustedConvTransposeAttributes = (attributes, inputs) => {
      const kernelShape = attributes.kernelShape.slice();
      if (attributes.kernelShape.length === 0) {
        for (let i = 2; i < inputs[1].dims.length; ++i) {
          kernelShape.push(inputs[1].dims[i]);
        }
      }
      const pads = attributes.pads.slice();
      const outputShape = attributes.outputShape.slice();
      const inputShape = inputs[0].dims;
      calculateOutputShapeAndPads(
        inputShape,
        kernelShape,
        attributes.dilations,
        attributes.autoPad,
        pads,
        attributes.strides,
        attributes.outputPadding,
        outputShape
      );
      const newAttributes = Object.assign({}, attributes);
      Object.assign(newAttributes, { kernelShape, pads, outputShape, cacheKey: attributes.cacheKey });
      return newAttributes;
    };
    parseConvTransposeAttributes = (node) => {
      const attributes = node.attributes;
      const activationAttributes = parseInternalActivationAttributes(attributes);
      const autoPad = attributes.getString("auto_pad", "NOTSET");
      const dilations = attributes.getInts("dilations", [1, 1]);
      const group = attributes.getInt("group", 1);
      const kernelShape = attributes.getInts("kernel_shape", []);
      const outputPadding = attributes.getInts("output_padding", [0, 0]);
      const outputShape = attributes.getInts("output_shape", []);
      const pads = attributes.getInts("pads", [0, 0, 0, 0]);
      const strides = attributes.getInts("strides", [1, 1]);
      return createAttributeWithCacheKey(
        { autoPad, dilations, group, kernelShape, outputPadding, outputShape, pads, strides, ...activationAttributes }
      );
    };
    validateInputs6 = (inputs, attributes) => {
      if (!inputs || inputs.length !== 2 && inputs.length !== 3) {
        throw new Error("Conv requires 2 or 3 inputs");
      }
      if (inputs[0].dims.length !== 4 || inputs[1].dims.length !== 4) {
        throw new Error("currently only support 2-dimensional conv");
      }
      const dataChannel = inputs[0].dims[1];
      const filterInChannel = inputs[1].dims[0];
      if (dataChannel !== filterInChannel) {
        throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");
      }
      const featureMaps = inputs[1].dims[1] * attributes.group;
      if (inputs.length === 3 && (inputs[2].dims.length !== 1 || inputs[2].dims[0] !== featureMaps)) {
        throw new Error("invalid bias");
      }
      const spatialRank = inputs[0].dims.length - 2;
      if (attributes.dilations.length !== spatialRank) {
        throw new Error(`dilations should be ${spatialRank}D`);
      }
      if (attributes.strides.length !== spatialRank) {
        throw new Error(`strides should be ${spatialRank}D`);
      }
      if (attributes.pads.length !== spatialRank * 2) {
        throw new Error(`pads should be ${spatialRank * 2}D`);
      }
      if (attributes.outputPadding.length !== spatialRank) {
        throw new Error(`output_padding should be ${spatialRank}D`);
      }
      if (attributes.kernelShape.length !== 0 && attributes.kernelShape.length !== inputs[1].dims.length - 2) {
        throw new Error("invalid kernel shape");
      }
      if (attributes.outputShape.length !== 0 && attributes.outputShape.length !== inputs[0].dims.length - 2) {
        throw new Error("invalid output shape");
      }
      if (inputs[0].type !== "float32" || inputs[1].type !== "float32") {
        throw new Error("ConvTranspose input(X,W) should be float tensor");
      }
      if (inputs.length === 3 && inputs[2].type !== "float32") {
        throw new Error("ConvTranspose input(bias) should be float tensor");
      }
    };
  }
});

// web/lib/onnxjs/backends/webgl/ops/transpose.ts
var transposeProgramMetadata, transpose, parseTransposeAttributes, createTransposeProgramInfo, getAdjustedPerm, getOutputShape, getPermFunctionBody, validateInputs7;
var init_transpose = __esm({
  "web/lib/onnxjs/backends/webgl/ops/transpose.ts"() {
    "use strict";
    init_attribute_with_cache_key();
    init_util();
    init_types();
    transposeProgramMetadata = {
      name: "Transpose",
      inputNames: ["A"],
      inputTypes: [0 /* unpacked */]
    };
    transpose = (inferenceHandler, inputs, attributes) => {
      validateInputs7(inputs);
      const output = inferenceHandler.run(
        {
          ...transposeProgramMetadata,
          cacheHint: attributes.cacheKey,
          get: () => createTransposeProgramInfo(inferenceHandler, inputs[0], attributes.perm)
        },
        inputs
      );
      return [output];
    };
    parseTransposeAttributes = (node) => createAttributeWithCacheKey({ perm: node.attributes.getInts("perm", []) });
    createTransposeProgramInfo = (_inferenceHandler, input, perm) => {
      const inputShape = input.dims;
      perm = getAdjustedPerm(inputShape, perm);
      const unpackedOutputShape = getOutputShape(inputShape, perm);
      const rank = inputShape.length;
      const shaderSource = `
      ${getPermFunctionBody("perm", perm, rank)}
      float process(int indices[${rank}]) {
        int a[${rank}];
        perm(a, indices);
        return _A(a);
      }`;
      return {
        ...transposeProgramMetadata,
        output: { dims: unpackedOutputShape, type: input.type, textureType: 0 /* unpacked */ },
        shaderSource
      };
    };
    getAdjustedPerm = (inputShape, perm) => {
      if (perm && perm.length !== inputShape.length) {
        perm = [...inputShape.keys()].reverse();
      }
      return perm;
    };
    getOutputShape = (inputShape, perm) => {
      perm = getAdjustedPerm(inputShape, perm);
      return ShapeUtil.sortBasedOnPerm(inputShape, perm);
    };
    getPermFunctionBody = (name2, perm, rank) => {
      const reverseFunc = [];
      reverseFunc.push(`void ${name2}(out int a[${rank}], int src[${rank}]) {`);
      for (let i = 0; i < rank; ++i) {
        reverseFunc.push(`	a[${perm[i]}]=src[${i}];`);
      }
      reverseFunc.push("	}");
      return reverseFunc.join("\n");
    };
    validateInputs7 = (inputs) => {
      if (!inputs || inputs.length !== 1) {
        throw new Error("Transpose requires 1 input.");
      }
      if (inputs[0].type !== "float32" && inputs[0].type !== "float64") {
        throw new Error("input should be float tensor");
      }
    };
  }
});

// web/lib/onnxjs/backends/webgl/ops/depth-to-space.ts
var depthToSpace, parseDepthToSpaceAttributes, validateInputs8;
var init_depth_to_space = __esm({
  "web/lib/onnxjs/backends/webgl/ops/depth-to-space.ts"() {
    "use strict";
    init_transpose();
    depthToSpace = (inferenceHandler, inputs, attributes) => {
      validateInputs8(inputs);
      const blocksize = attributes.blocksize;
      const blocksizeSqr = blocksize * blocksize;
      const transposePerm = attributes.mode === "DCR" ? [0, 3, 4, 1, 5, 2] : [0, 1, 4, 2, 5, 3];
      const firstReshapeShape = attributes.mode === "DCR" ? [
        inputs[0].dims[0],
        blocksize,
        blocksize,
        inputs[0].dims[1] / blocksizeSqr,
        inputs[0].dims[2],
        inputs[0].dims[3]
      ] : [
        inputs[0].dims[0],
        inputs[0].dims[1] / blocksizeSqr,
        blocksize,
        blocksize,
        inputs[0].dims[2],
        inputs[0].dims[3]
      ];
      const firstReshapedTensor = inferenceHandler.reshapeUnpacked(inputs[0], firstReshapeShape);
      const transposeAttributes = { perm: transposePerm, cacheKey: `${transposePerm}` };
      const [transposeOutput] = transpose(inferenceHandler, [firstReshapedTensor], transposeAttributes);
      const secondReshapeShape = [
        inputs[0].dims[0],
        inputs[0].dims[1] / blocksizeSqr,
        inputs[0].dims[2] * blocksize,
        inputs[0].dims[3] * blocksize
      ];
      const result = inferenceHandler.reshapeUnpacked(transposeOutput, secondReshapeShape);
      return [result];
    };
    parseDepthToSpaceAttributes = (node) => {
      const blocksize = node.attributes.getInt("blocksize");
      if (blocksize < 1) {
        throw new Error(`blocksize must be >= 1, but got : ${blocksize} for DepthToSpace`);
      }
      const mode = node.attributes.getString("mode", "DCR");
      if (mode !== "DCR" && mode !== "CRD") {
        throw new Error(`unrecognized mode: ${mode} for DepthToSpace`);
      }
      return { mode, blocksize };
    };
    validateInputs8 = (inputs) => {
      if (inputs.length !== 1) {
        throw new Error(`DepthToSpace expect 1 inputs, but got ${inputs.length}`);
      }
      if (inputs[0].type === "string" || inputs[0].dims.length !== 4) {
        throw new TypeError("DepthToSpace input should be a 4-D numeric tensor");
      }
    };
  }
});

// web/lib/onnxjs/backends/webgl/ops/flatten.ts
var flatten, parseFlattenAttributes, validateInputs9;
var init_flatten = __esm({
  "web/lib/onnxjs/backends/webgl/ops/flatten.ts"() {
    "use strict";
    init_util();
    flatten = (inferenceHandler, inputs, axis) => {
      validateInputs9(inputs, axis);
      const outputDims = ShapeUtil.flattenShape(inputs[0].dims, axis);
      return [inferenceHandler.reshapeUnpacked(inputs[0], outputDims)];
    };
    parseFlattenAttributes = (node) => node.attributes.getInt("axis", 1);
    validateInputs9 = (inputs, axis) => {
      if (!inputs || inputs.length !== 1) {
        throw new Error("Flatten requires 1 input.");
      }
      const r = inputs[0].dims.length;
      if (r === 0) {
        throw new Error("scalar tensor is not supported.");
      }
      if (axis < -r || axis > r) {
        throw new Error("Invalid axis");
      }
      if (inputs[0].type === "string") {
        throw new Error("string tensor is not supported.");
      }
    };
  }
});

// web/lib/onnxjs/operators.ts
var NUMBER_TYPES;
var init_operators = __esm({
  "web/lib/onnxjs/operators.ts"() {
    "use strict";
    NUMBER_TYPES = ["float32", "float64", "int32", "int16", "int8", "uint16", "uint32", "uint8"];
  }
});

// web/lib/onnxjs/backends/webgl/ops/gather.ts
var gather, parseGatherAttributes, gatherProgramMetadata, createGatherProgramInfo, createGatherProgramInfoLoader, validateInputs10;
var init_gather = __esm({
  "web/lib/onnxjs/backends/webgl/ops/gather.ts"() {
    "use strict";
    init_attribute_with_cache_key();
    init_operators();
    init_util();
    init_types();
    gather = (inferenceHandler, inputs, attributes) => {
      validateInputs10(inputs, attributes.axis);
      const output = inferenceHandler.run(createGatherProgramInfoLoader(inferenceHandler, inputs, attributes), inputs);
      return [output];
    };
    parseGatherAttributes = (node) => createAttributeWithCacheKey({ axis: node.attributes.getInt("axis", 0) });
    gatherProgramMetadata = {
      name: "Gather",
      inputNames: ["A", "B"],
      inputTypes: [0 /* unpacked */, 0 /* unpacked */]
    };
    createGatherProgramInfo = (_handler, metadata, inputs, axis) => {
      const inputShape = inputs[0].dims.slice();
      const indexDataShape = inputs[1].dims.slice();
      const outputShape = new Array(inputShape.length + indexDataShape.length - 1);
      axis = ShapeUtil.normalizeAxis(axis, inputShape.length);
      const indexCopyOps = [];
      for (let i = 0; i < outputShape.length; i++) {
        if (i < axis) {
          outputShape[i] = inputShape[i];
          indexCopyOps.push(`inputIdx[${i}] = outputIdx[${i}];`);
        } else {
          if (i < axis + indexDataShape.length) {
            outputShape[i] = indexDataShape[i - axis];
            indexCopyOps.push(`indexDataIdx[${i - axis}] = outputIdx[${i}];`);
          } else {
            outputShape[i] = inputShape[i - indexDataShape.length + 1];
            indexCopyOps.push(`inputIdx[${i - indexDataShape.length + 1}] = outputIdx[${i}];`);
          }
        }
      }
      const orank = outputShape.length || 1;
      const irank = inputShape.length;
      const iDrank = indexDataShape.length || 1;
      const shaderSource = `
      float process(int outputIdx[${orank}]) {
        int inputIdx[${irank}];
        int indexDataIdx[${iDrank}];
        indexDataIdx[0] = 0;
        ${indexCopyOps.join("\n        ")}
        int idx = int(_B(indexDataIdx));
        inputIdx[${axis}] = idx < 0 ? idx + ${inputShape[axis]} : idx;
        return _A(inputIdx);
      }`;
      return {
        ...metadata,
        output: { dims: outputShape, type: inputs[0].type, textureType: 0 /* unpacked */ },
        shaderSource
      };
    };
    createGatherProgramInfoLoader = (handler, inputs, attributes) => {
      const metadata = { ...gatherProgramMetadata, cacheHint: attributes.cacheKey };
      return { ...metadata, get: () => createGatherProgramInfo(handler, metadata, inputs, attributes.axis) };
    };
    validateInputs10 = (inputs, axis) => {
      if (!inputs || inputs.length !== 2) {
        throw new Error("Gather requires 2 inputs.");
      }
      const tensorRank = inputs[0].dims.length;
      if (tensorRank < 1) {
        throw new Error("Invalid input shape.");
      }
      if (axis < -tensorRank || axis > tensorRank - 1) {
        throw new Error("Invalid axis.");
      }
      if (NUMBER_TYPES.indexOf(inputs[0].type) === -1) {
        throw new Error("Invaid input type.");
      }
      if (inputs[1].type !== "int32" && inputs[1].type !== "int16") {
        throw new Error("Invaid input type.");
      }
    };
  }
});

// web/lib/onnxjs/backends/webgl/ops/gemm.ts
var gemm, parseGemmAttributes, parseGemmAttributesV7, parseGemmAttributesV11, createGemmProgramInfoLoader, createGemmProgramInfo, validateInputs11;
var init_gemm = __esm({
  "web/lib/onnxjs/backends/webgl/ops/gemm.ts"() {
    "use strict";
    init_attribute_with_cache_key();
    init_util();
    init_types();
    gemm = (inferenceHandler, inputs, attributes) => {
      validateInputs11(inputs, attributes);
      const output = inferenceHandler.run(createGemmProgramInfoLoader(inputs, attributes), inputs);
      return [output];
    };
    parseGemmAttributes = (node, isOptionalC) => {
      const transA = node.attributes.getInt("transA", 0) !== 0;
      const transB = node.attributes.getInt("transB", 0) !== 0;
      const alpha = node.attributes.getFloat("alpha", 1);
      const beta = node.attributes.getFloat("beta", 1);
      return createAttributeWithCacheKey({ transA, transB, alpha, beta, isOptionalC });
    };
    parseGemmAttributesV7 = (node) => parseGemmAttributes(node, false);
    parseGemmAttributesV11 = (node) => parseGemmAttributes(node, true);
    createGemmProgramInfoLoader = (inputs, attributes) => {
      const metadata = {
        name: "Gemm",
        inputNames: inputs.length === 3 ? ["A", "B", "C"] : ["A", "B"],
        inputTypes: inputs.length === 3 ? [0 /* unpacked */, 0 /* unpacked */, 0 /* unpacked */] : [0 /* unpacked */, 0 /* unpacked */],
        key: attributes.cacheKey
      };
      return { ...metadata, get: () => createGemmProgramInfo(metadata, inputs, attributes) };
    };
    createGemmProgramInfo = (metadata, inputs, attributes) => {
      const aShape = inputs[0].dims.slice();
      const bShape = inputs[1].dims.slice();
      const [M, N] = GemmUtil.getShapeOfGemmResult(
        aShape,
        attributes.transA,
        bShape,
        attributes.transB,
        inputs.length === 3 ? inputs[2].dims : void 0
      );
      const outputShape = [M, N];
      if (!outputShape) {
        throw new Error("Can't use gemm on the given tensors");
      }
      let sharedDim = aShape[aShape.length - 1];
      let line = "";
      if (attributes.transA) {
        sharedDim = aShape[0];
      }
      if (attributes.transA && attributes.transB) {
        line = "value += _A_T(a) * _B_T(b);";
      } else if (attributes.transA && !attributes.transB) {
        line = "value += _A_T(a) * _B(b);";
      } else if (!attributes.transA && attributes.transB) {
        line = "value += _A(a) * _B_T(b);";
      } else if (!attributes.transA && !attributes.transB) {
        line = "value += _A(a) * _B(b);";
      }
      const rank = outputShape.length;
      const declareC = inputs.length === 3 ? `int c[${inputs[2].dims.length}];` : "";
      const broadcastC = inputs.length === 3 ? "bcastIndices_C(indices, c);" : "";
      const calculateC = inputs.length === 3 ? "value += beta * _C(c);" : "";
      const shaderSource = `
      float process(int indices[${rank}]) {
          int a[${rank}];
          int b[${rank}];
          ${declareC}

          copyVec(indices, a);
          copyVec(indices, b);
          ${broadcastC}

          float value = 0.0;
          for (int k=0; k<${sharedDim}; ++k) {
              a[${rank - 1}] = k;
              b[${rank - 2}] = k;
              ${line}
          }

          value = value * alpha;
          ${calculateC}
          return value;
      }`;
      return {
        ...metadata,
        output: { dims: outputShape, type: inputs[0].type, textureType: 0 /* unpacked */ },
        variables: [
          { name: "alpha", type: "float", data: attributes.alpha },
          { name: "beta", type: "float", data: attributes.beta }
        ],
        shaderSource
      };
    };
    validateInputs11 = (inputs, attributes) => {
      if (!inputs) {
        throw new Error("Input is missing");
      }
      if (attributes.isOptionalC && (inputs.length < 2 || inputs.length > 3)) {
        throw new Error("Invaid input shape.");
      }
      if (!attributes.isOptionalC && inputs.length !== 3) {
        throw new Error("Gemm requires 3 inputs");
      }
      if (inputs.length === 3 && inputs[2].dims.length !== 1 && inputs[2].dims.length !== 2) {
        throw new Error("Invalid input shape of C");
      }
      if (inputs[0].type !== "float32" && inputs[0].type !== "float64" || inputs[1].type !== "float32" && inputs[1].type !== "float64" || inputs.length === 3 && inputs[2].type !== "float32" && inputs[2].type !== "float64") {
        throw new Error("Invalid input type.");
      }
      if (inputs[0].type !== inputs[1].type || inputs.length === 3 && inputs[0].type !== inputs[2].type) {
        throw new Error("Input types are mismatched");
      }
    };
  }
});

// web/lib/onnxjs/backends/webgl/ops/image-scaler.ts
var imageScaler, parseImageScalerAttributes, imageScalerProgramMetadata, createImageScalerProgramInfo, createImageScalerProgramInfoLoader, createGetBiasMethod, validateInputs12;
var init_image_scaler = __esm({
  "web/lib/onnxjs/backends/webgl/ops/image-scaler.ts"() {
    "use strict";
    init_attribute_with_cache_key();
    init_types();
    imageScaler = (inferenceHandler, inputs, attributes) => {
      validateInputs12(inputs);
      const output = inferenceHandler.run(createImageScalerProgramInfoLoader(inferenceHandler, inputs, attributes), inputs);
      return [output];
    };
    parseImageScalerAttributes = (node) => {
      const scale = node.attributes.getFloat("scale");
      const bias = node.attributes.getFloats("bias");
      return createAttributeWithCacheKey({ scale, bias });
    };
    imageScalerProgramMetadata = {
      name: "ImageScaler",
      inputNames: ["X"],
      inputTypes: [0 /* unpacked */]
    };
    createImageScalerProgramInfo = (_handler, metadata, inputs, attributes) => {
      const outputShape = inputs[0].dims.slice();
      const rank = outputShape.length;
      const getBiasMethod = createGetBiasMethod(attributes.bias.length);
      const shaderSource = `
      ${getBiasMethod}
      float process(int indices[${rank}]) {
        return _X(indices) * scale + getBias(bias, indices[1]);
      }`;
      return {
        ...metadata,
        output: { dims: outputShape, type: inputs[0].type, textureType: 0 /* unpacked */ },
        variables: [
          { name: "bias", type: "float", arrayLength: attributes.bias.length, data: attributes.bias },
          { name: "scale", type: "float", data: attributes.scale }
        ],
        shaderSource
      };
    };
    createImageScalerProgramInfoLoader = (handler, inputs, attributes) => {
      const metadata = { ...imageScalerProgramMetadata, cacheHint: attributes.cacheKey };
      return { ...metadata, get: () => createImageScalerProgramInfo(handler, metadata, inputs, attributes) };
    };
    createGetBiasMethod = (numChannels) => {
      const codeLines = [`float getBias(float bias[${numChannels}], int channel) {`];
      for (let i = 0; i < numChannels; ++i) {
        if (i === 0) {
          codeLines.push(
            `	if (channel == ${i}) { return bias[${i}]; }`
          );
        } else if (i === numChannels - 1) {
          codeLines.push(
            `	else { return bias[${i}]; }`
          );
        } else {
          codeLines.push(
            `	else if (channel == ${i}) { return bias[${i}]; }`
          );
        }
      }
      codeLines.push(
        "	}"
      );
      return codeLines.join("\n");
    };
    validateInputs12 = (inputs) => {
      if (!inputs || inputs.length !== 1) {
        throw new Error("ImageScaler requires 1 input.");
      }
      if (inputs[0].dims.length !== 4) {
        throw new Error("Invalid input shape.");
      }
      if (inputs[0].type !== "float32" && inputs[0].type !== "float64") {
        throw new Error("Invalid input type.");
      }
    };
  }
});

// web/lib/onnxjs/backends/webgl/ops/instance-normalization.ts
var instanceNormalization, parseInstanceNormalizationAttributes, meanAndVarianceProgramMetadata, createMeanAndVarianceProgramInfo, createMeanAndVarianceProgramInfoLoader, computeOutputProgramMetadata, createComputeOutputProgramInfo, createComputeOutputProgramInfoLoader, validateInputs13;
var init_instance_normalization = __esm({
  "web/lib/onnxjs/backends/webgl/ops/instance-normalization.ts"() {
    "use strict";
    init_glsl_source();
    init_types();
    instanceNormalization = (inferenceHandler, inputs, epsilon) => {
      validateInputs13(inputs);
      const meanAndVariance = inferenceHandler.run(createMeanAndVarianceProgramInfoLoader(inputs[0]), inputs);
      const output = inferenceHandler.run(
        createComputeOutputProgramInfoLoader(inferenceHandler, inputs[0], epsilon, meanAndVariance.dims),
        [inputs[0], meanAndVariance, inputs[1], inputs[2]]
      );
      return [output];
    };
    parseInstanceNormalizationAttributes = (node) => node.attributes.getFloat("epsilon", 1e-5);
    meanAndVarianceProgramMetadata = {
      name: "InstanceNormalization_MeanAndVariance",
      inputNames: ["X"],
      inputTypes: [0 /* unpacked */]
    };
    createMeanAndVarianceProgramInfo = (metadata, input) => {
      const xDims = input.dims.slice();
      const channel = xDims[1];
      const channelSize = xDims[2] * xDims[3];
      const outputShape = [xDims[0], channel];
      const shaderSource = `
      vec4 process(int[2] indices) {
        vec4 v = vec4(0.0);
        int a[4];
        a[0] = indices[0];
        a[1] = indices[1];
        float temp = 0.0;
        for(int a2=0; a2<${xDims[2]}; a2++) {
          a[2] = a2;
          for(int a3=0; a3<${xDims[3]}; a3++) {
            a[3] = a3;
            float x = _X(a);
            temp += x;
          }
        }
        float mean = temp / float(${channelSize});
        temp = 0.0;
        for(int a2=0; a2<${xDims[2]}; a2++) {
          a[2] = a2;
          for(int a3=0; a3<${xDims[3]}; a3++) {
            a[3] = a3;
            float x = _X(a);
            temp += (x - mean) * (x - mean);
          }
        }
        v.r = mean;
        v.g = temp / float(${channelSize});

        return v;
      }`;
      return {
        ...metadata,
        output: { dims: outputShape, type: input.type, textureType: 4 /* packedLastDimension */ },
        shaderSource
      };
    };
    createMeanAndVarianceProgramInfoLoader = (input) => ({
      ...meanAndVarianceProgramMetadata,
      get: () => createMeanAndVarianceProgramInfo(meanAndVarianceProgramMetadata, input)
    });
    computeOutputProgramMetadata = {
      name: "InstanceNormalization_ComputeOutput",
      inputNames: ["X", "MeanAndVariance", "Scale", "B"],
      inputTypes: [0 /* unpacked */, 4 /* packedLastDimension */, 0 /* unpacked */, 0 /* unpacked */]
    };
    createComputeOutputProgramInfo = (inferenceHandler, metadata, input, epsilon, meanAndVarianceShape) => {
      const glsl = getGlsl(inferenceHandler.session.backend.glContext.version);
      const [textureWidth, textureHeight] = inferenceHandler.calculateTextureWidthAndHeight(meanAndVarianceShape, 4 /* packedLastDimension */);
      const [meanAndVarianceWidth, meanAndVarianceHeight] = [textureWidth / 4, textureHeight];
      const shaderSource = `
      vec4 get_MeanAndVariance(int[2] mv) {
        int offset = indicesToOffset_MeanAndVariance(mv);
        vec2 coords = offsetToCoords(offset, ${meanAndVarianceWidth}, ${meanAndVarianceHeight});
        return ${glsl.texture2D}(MeanAndVariance, coords);
      }

      float process(int[4] indices) {
        int mv[2];
        mv[0] = indices[0];
        mv[1] = indices[1];
        vec4 mean_and_variance = get_MeanAndVariance(mv);
        float mean = mean_and_variance.r;
        float variance = mean_and_variance.g;

        int sb[1];
        sb[0] = indices[1];
        float scale = _Scale(sb);
        float b = _B(sb);

        return scale * (_X(indices) - mean) / sqrt(variance + epsilon) + b;
      }`;
      return {
        ...metadata,
        output: { dims: input.dims, type: input.type, textureType: 0 /* unpacked */ },
        variables: [{ name: "epsilon", type: "float", data: epsilon }],
        shaderSource
      };
    };
    createComputeOutputProgramInfoLoader = (inferenceHandler, input, epsilon, meanAndVarianceShape) => {
      const metadata = { ...computeOutputProgramMetadata, cacheHint: `${epsilon}` };
      return {
        ...metadata,
        get: () => createComputeOutputProgramInfo(inferenceHandler, metadata, input, epsilon, meanAndVarianceShape)
      };
    };
    validateInputs13 = (inputs) => {
      if (!inputs || inputs.length !== 3) {
        throw new Error("InstanceNormalization requires 3 inputs.");
      }
      const X = inputs[0];
      const scale = inputs[1];
      const B = inputs[2];
      if (X.dims.length < 3 || scale.dims.length !== 1 || B.dims.length !== 1) {
        throw new Error("Invalid input shape.");
      }
      if (scale.dims[0] !== X.dims[1] || B.dims[0] !== X.dims[1]) {
        throw new Error("Input shapes are mismatched.");
      }
      if (X.type !== "float32" && X.type !== "float64" || scale.type !== "float32" && scale.type !== "float64" || B.type !== "float32" && B.type !== "float64") {
        throw new Error("Invalid input type.");
      }
      if (inputs[0].dims.length !== 4) {
        throw new Error("Only support 4-D input shape.");
      }
    };
  }
});

// web/lib/onnxjs/backends/webgl/ops/lrn.ts
function createLrnProgramInfo(inputs, attributes) {
  const C = inputs[0].dims[1];
  const rank = inputs[0].dims.length;
  const from = -Math.floor((attributes.size - 1) / 2);
  const to = Math.ceil((attributes.size - 1) / 2);
  const alpha = `float(${attributes.alpha}) / float(${attributes.size})`;
  const bias = `float(${attributes.bias})`;
  const beta = `float(${attributes.beta})`;
  const shaderSource = `
    float process(int indices[${rank}]) {
        int c = indices[1];
        float x = _X(indices);
        float square_sum = 0.0;

        for (int i = ${from}; i <= ${to}; i++) {
          int idx = c + i;
          if (c >= 0 && c < ${C}) {
            indices[1] = idx;
            float j = _X(indices);
            square_sum += j * j;
          }
        }
        return x / pow(${bias} + ${alpha} * square_sum, ${beta});
    }`;
  return {
    ...lrnProgramMetadata,
    cacheHint: attributes.cacheKey,
    output: { dims: inputs[0].dims, type: inputs[0].type, textureType: 0 /* unpacked */ },
    shaderSource
  };
}
function createLrnProgramInfoLoader(inputs, attributes) {
  return { ...lrnProgramMetadata, cacheHint: attributes.cacheKey, get: () => createLrnProgramInfo(inputs, attributes) };
}
var lrn, parseLrnAttributes, lrnProgramMetadata, validateInputs14;
var init_lrn = __esm({
  "web/lib/onnxjs/backends/webgl/ops/lrn.ts"() {
    "use strict";
    init_attribute_with_cache_key();
    init_types();
    lrn = (inferenceHandler, inputs, attributes) => {
      validateInputs14(inputs);
      return [inferenceHandler.run(createLrnProgramInfoLoader(inputs, attributes), inputs)];
    };
    parseLrnAttributes = (node) => {
      const alpha = node.attributes.getFloat("alpha", 1e-4);
      const beta = node.attributes.getFloat("beta", 0.75);
      const bias = node.attributes.getFloat("bias", 1);
      const size = node.attributes.getInt("size");
      return createAttributeWithCacheKey({ alpha, beta, bias, size });
    };
    lrnProgramMetadata = {
      name: "LRN",
      inputNames: ["X"],
      inputTypes: [0 /* unpacked */]
    };
    validateInputs14 = (inputs) => {
      if (!inputs || inputs.length !== 1) {
        throw new Error("LRN requires 1 input.");
      }
      if (inputs[0].dims.length !== 4) {
        throw new Error('currently only support LRN for input with "NCHW" format');
      }
      if (inputs[0].type !== "float32") {
        throw new Error("input should be float type");
      }
    };
  }
});

// web/lib/onnxjs/backends/webgl/ops/pad.ts
var padProgramMetadata, padV2, parsePadAttributesV2, padV11, parsePadAttributesV11, generatePadAttributesFromInputs, createPadProgramInfo, validateInputsV2, validateInputsV11, getPadFunction, getPadConstant, getPadReflect, getPadEdge;
var init_pad = __esm({
  "web/lib/onnxjs/backends/webgl/ops/pad.ts"() {
    "use strict";
    init_attribute_with_cache_key();
    init_util();
    init_glsl_source();
    init_types();
    padProgramMetadata = {
      name: "Pad",
      inputNames: ["A"],
      inputTypes: [0 /* unpacked */]
    };
    padV2 = (inferenceHandler, inputs, attributes) => {
      validateInputsV2(inputs);
      const output = inferenceHandler.run(
        {
          ...padProgramMetadata,
          cacheHint: attributes.cacheKey,
          get: () => createPadProgramInfo(inferenceHandler, inputs[0], attributes)
        },
        inputs
      );
      return [output];
    };
    parsePadAttributesV2 = (node) => {
      const mode = node.attributes.getString("mode", "constant");
      const value = node.attributes.getFloat("value", 0);
      const pads = node.attributes.getInts("pads");
      return createAttributeWithCacheKey({ mode, value, pads });
    };
    padV11 = (inferenceHandler, inputs, mode) => {
      validateInputsV11(inputs);
      const attrubutes = generatePadAttributesFromInputs(inferenceHandler, inputs, mode);
      return padV2(inferenceHandler, [inputs[0]], attrubutes);
    };
    parsePadAttributesV11 = (node) => node.attributes.getString("mode", "constant");
    generatePadAttributesFromInputs = (inferenceHandler, inputs, mode) => {
      if (!inferenceHandler.session.isInitializer(inputs[1].dataId) || inputs.length >= 3 && !inferenceHandler.session.isInitializer(inputs[2].dataId)) {
        throw new Error("dynamic pad attributes are not allowed");
      }
      const pads = Array.from(inputs[1].integerData);
      const value = inputs.length >= 3 ? inputs[2].floatData[0] : 0;
      return createAttributeWithCacheKey({ mode, pads, value });
    };
    createPadProgramInfo = (inferenceHandler, input, attributes) => {
      const outputShape = ShapeUtil.padShape(input.dims.slice(), attributes.pads);
      const rank = outputShape.length;
      const padFunction = getPadFunction(inferenceHandler, input, attributes);
      const shaderSource = `
      ${padFunction}
      float process(int[${rank}] indices) {
          return padA(indices);
      }`;
      return {
        name: "Pad",
        inputNames: ["A"],
        inputTypes: [0 /* unpacked */],
        output: { dims: outputShape, type: input.type, textureType: 0 /* unpacked */ },
        shaderSource
      };
    };
    validateInputsV2 = (inputs) => {
      if (!inputs || inputs.length !== 1) {
        throw new Error("Pad requires 1 input");
      }
      if (inputs[0].type !== "float32" && inputs[0].type !== "float64") {
        throw new Error("Invalid input type.");
      }
    };
    validateInputsV11 = (inputs) => {
      if (!inputs || inputs.length !== 2 && inputs.length !== 3) {
        throw new Error("Pad requires 2 or 3 inputs");
      }
      if (inputs[1].type !== "int32") {
        throw new Error("Invalid input type.");
      }
      if (inputs.length >= 3 && inputs[2].type === "string") {
        throw new Error("Invalid input type.");
      }
    };
    getPadFunction = (inferenceHandler, input, attributes) => {
      const glsl = getGlsl(inferenceHandler.session.backend.glContext.version);
      const [width, height] = inferenceHandler.calculateTextureWidthAndHeight(input.dims, 0 /* unpacked */);
      const strides = ShapeUtil.computeStrides(input.dims);
      switch (attributes.mode) {
        case "constant":
          return getPadConstant(glsl, input.dims, strides, width, height, attributes.pads, attributes.value);
        case "reflect":
          return getPadReflect(glsl, input.dims, strides, width, height, attributes.pads);
        case "edge":
          return getPadEdge(glsl, input.dims, strides, width, height, attributes.pads);
        default:
          throw new Error("Invalid mode");
      }
    };
    getPadConstant = (glsl, shape2, strides, width, height, pads, value) => {
      const rank = shape2.length;
      let block = "";
      for (let i = rank - 1; i >= 0; --i) {
        block += `
        k = m[${i}] - ${pads[i]};
        if (k < 0)  return constant;
        if (k >= ${shape2[i]}) return constant;
        offset += k * ${strides[i]};
        `;
      }
      return `
      float padA(int m[${rank}]) {
        const float constant = float(${value});
        int offset = 0;
        int k = 0;
        ${block}
        vec2 coords = offsetToCoords(offset, ${width}, ${height});
        float value = getColorAsFloat(${glsl.texture2D}(A, coords));
        return value;
      }
      `;
    };
    getPadReflect = (glsl, shape2, strides, width, height, pads) => {
      const rank = shape2.length;
      let block = "";
      for (let i = rank - 1; i >= 0; --i) {
        block += `
        k = m[${i}] - ${pads[i]};
        if (k < 0) { k = -k; }
        {
          const int _2n_1 = ${2 * (shape2[i] - 1)};
          k = int( mod( float(k), float(_2n_1) ) ) ;
          if(k >= ${shape2[i]}) { k = _2n_1 - k; }
        }
        offset += k * ${strides[i]};
        `;
      }
      return `
      float padA(int m[${rank}]) {
        int offset = 0;
        int k = 0;
        ${block}
        vec2 coords = offsetToCoords(offset, ${width}, ${height});
        float value = getColorAsFloat(${glsl.texture2D}(A, coords));
        return value;
      }
      `;
    };
    getPadEdge = (glsl, shape2, strides, width, height, pads) => {
      const rank = shape2.length;
      let block = "";
      for (let i = rank - 1; i >= 0; --i) {
        block += `
        k = m[${i}] - ${pads[i]};
        if (k < 0)  k = 0;
        if (k >= ${shape2[i]}) k = ${shape2[i] - 1};
        offset += k * ${strides[i]};
      `;
      }
      return `
      float padA(int m[${rank}]) {
        int offset = 0;
        int k = 0;
        ${block}
        vec2 coords = offsetToCoords(offset, ${width}, ${height});
        float value = getColorAsFloat(${glsl.texture2D}(A, coords));
        return value;
      }
      `;
    };
  }
});

// web/lib/onnxjs/backends/webgl/ops/pool.ts
var averagePool, parseAveragePoolAttributes, createAveragePoolProgramInfo, globalAveragePool, parseGlobalAveragePoolAttributes, maxPool, parseMaxPoolAttributes, createMaxPoolProgramInfo, getAdjustedPoolAttributesAndOutputShape, globalMaxPoolAttributes, globalMaxPoolMetadata, globalMaxPool, validateInputs15, generatePoolingCode, copyArray, offsetToIndices;
var init_pool = __esm({
  "web/lib/onnxjs/backends/webgl/ops/pool.ts"() {
    "use strict";
    init_attribute_with_cache_key();
    init_util();
    init_types();
    averagePool = (inferenceHandler, inputs, attributes) => {
      validateInputs15(inputs);
      const metadata = { name: "AveragePool", inputNames: ["X"], inputTypes: [0 /* unpacked */], cacheHint: attributes.cacheKey };
      const output = inferenceHandler.run(
        { ...metadata, get: () => createAveragePoolProgramInfo(inputs, metadata, false, attributes) },
        inputs
      );
      return [output];
    };
    parseAveragePoolAttributes = (node) => {
      const autoPad = node.attributes.getString("auto_pad", "NOTSET");
      const ceilMode = node.attributes.getInt("ceil_mode", 0);
      const countIncludePad = node.attributes.getInt("count_include_pad", 0) === 0 ? false : true;
      const kernelShape = node.attributes.getInts("kernel_shape");
      const strides = node.attributes.getInts("strides", []);
      const pads = node.attributes.getInts("pads", []);
      if (ceilMode !== 0) {
        throw new Error("using ceil() in shape computation is not yet supported for AveragePool");
      }
      return createAttributeWithCacheKey({ autoPad, ceilMode, countIncludePad, kernelShape, strides, pads });
    };
    createAveragePoolProgramInfo = (inputs, metadata, isGlobalOperator, attributes) => {
      const [adjustedAttributes, outputShape] = getAdjustedPoolAttributesAndOutputShape(inputs, attributes, isGlobalOperator);
      const kernelSize = ShapeUtil.size(adjustedAttributes.kernelShape);
      const op1 = "value += _X(x);";
      let op2 = "";
      if (adjustedAttributes.countIncludePad) {
        op2 += `value /= float(${kernelSize});`;
      } else {
        op2 += `value /= float(${kernelSize} - pad);`;
      }
      const poolingCode = generatePoolingCode(inputs[0].dims, adjustedAttributes, op1, op2, "0.0");
      const shaderSource = `
        ${poolingCode}
      `;
      return {
        ...metadata,
        output: { dims: outputShape, type: inputs[0].type, textureType: 0 /* unpacked */ },
        shaderSource
      };
    };
    globalAveragePool = (inferenceHandler, inputs, attributes) => {
      validateInputs15(inputs);
      const metadata = {
        name: "GlobalAveragePool",
        inputNames: ["X"],
        inputTypes: [0 /* unpacked */],
        cacheHint: `${attributes.countIncludePad}`
      };
      const output = inferenceHandler.run(
        { ...metadata, get: () => createAveragePoolProgramInfo(inputs, metadata, true, attributes) },
        inputs
      );
      return [output];
    };
    parseGlobalAveragePoolAttributes = (node) => {
      const countIncludePad = node.attributes.getInt("count_include_pad", 0) === 0 ? false : true;
      return createAttributeWithCacheKey(
        { autoPad: "", ceilMode: 0, countIncludePad, kernelShape: [], strides: [], pads: [] }
      );
    };
    maxPool = (inferenceHandler, inputs, attributes) => {
      validateInputs15(inputs);
      const metadata = { name: "MaxPool", inputNames: ["X"], inputTypes: [0 /* unpacked */], cacheHint: attributes.cacheKey };
      const output = inferenceHandler.run(
        { ...metadata, get: () => createMaxPoolProgramInfo(inputs, metadata, false, attributes) },
        inputs
      );
      return [output];
    };
    parseMaxPoolAttributes = (node) => {
      const autoPad = node.attributes.getString("auto_pad", "NOTSET");
      const ceilMode = node.attributes.getInt("ceil_mode", 0);
      const kernelShape = node.attributes.getInts("kernel_shape");
      const strides = node.attributes.getInts("strides", []);
      const pads = node.attributes.getInts("pads", []);
      const storageOrder = node.attributes.getInt("storage_order", 0);
      const dilations = node.attributes.getInts("dilations", []);
      if (storageOrder !== 0) {
        throw new Error("column major storage order is not yet supported for MaxPool");
      }
      if (ceilMode !== 0) {
        throw new Error("using ceil() in shape computation is not yet supported for MaxPool");
      }
      return createAttributeWithCacheKey(
        { autoPad, ceilMode, countIncludePad: false, kernelShape, strides, pads, storageOrder, dilations }
      );
    };
    createMaxPoolProgramInfo = (inputs, metadata, isGlobalOperator, attributes) => {
      const [adjustedAttributes, outputShape] = getAdjustedPoolAttributesAndOutputShape(inputs, attributes, isGlobalOperator);
      const op1 = `
      value = max(_X(x), value);
    `;
      const op2 = "";
      const poolingCode = generatePoolingCode(inputs[0].dims, adjustedAttributes, op1, op2, "-1e5");
      const shaderSource = `
      ${poolingCode}
    `;
      return {
        ...metadata,
        output: { dims: outputShape, type: inputs[0].type, textureType: 0 /* unpacked */ },
        shaderSource
      };
    };
    getAdjustedPoolAttributesAndOutputShape = (inputs, attributes, isGlobalOperator) => {
      const inputShape = inputs[0].dims.slice();
      const hasDilations = Object.hasOwnProperty.call(attributes, "dilations");
      const kernelShape = attributes.kernelShape.slice();
      const strides = attributes.strides.slice();
      const dilations = hasDilations ? attributes.dilations.slice() : [];
      const pads = attributes.pads.slice();
      PoolConvUtil.adjustPoolAttributes(isGlobalOperator, inputShape, kernelShape, strides, dilations, pads);
      const outputShape = PoolConvUtil.computePoolOutputShape(
        isGlobalOperator,
        inputShape,
        strides,
        dilations,
        kernelShape,
        pads,
        attributes.autoPad
      );
      const newAttributes = Object.assign({}, attributes);
      if (hasDilations) {
        Object.assign(newAttributes, { kernelShape, strides, pads, dilations, cacheKey: attributes.cacheKey });
      } else {
        Object.assign(newAttributes, { kernelShape, strides, pads, cacheKey: attributes.cacheKey });
      }
      return [newAttributes, outputShape];
    };
    globalMaxPoolAttributes = {
      autoPad: "",
      ceilMode: 0,
      countIncludePad: false,
      kernelShape: [],
      strides: [],
      pads: [],
      storageOrder: 0,
      dilations: [],
      cacheKey: ""
    };
    globalMaxPoolMetadata = {
      name: "GlobalMaxPool",
      inputNames: ["X"],
      inputTypes: [0 /* unpacked */]
    };
    globalMaxPool = (inferenceHandler, inputs) => {
      validateInputs15(inputs);
      const output = inferenceHandler.run(
        {
          ...globalMaxPoolMetadata,
          get: () => createMaxPoolProgramInfo(inputs, globalMaxPoolMetadata, true, globalMaxPoolAttributes)
        },
        inputs
      );
      return [output];
    };
    validateInputs15 = (inputs) => {
      if (!inputs || inputs.length !== 1) {
        throw new Error("Pool ops requires 1 input.");
      }
      if (inputs[0].type !== "float32" && inputs[0].type !== "float64") {
        throw new Error("Invalid input type.");
      }
    };
    generatePoolingCode = (inputDims, attributes, op1, op2, start) => {
      const rank = inputDims.length;
      if (attributes.kernelShape.length <= 2) {
        const kw = attributes.kernelShape[attributes.kernelShape.length - 1];
        const sw = attributes.strides[attributes.strides.length - 1];
        const pwStart = attributes.pads[attributes.pads.length / 2 - 1];
        const pwEnd = attributes.pads[attributes.pads.length - 1];
        const dimW = inputDims[rank - 1];
        let codeW = "";
        let codeH = "";
        let codeHEnd = "";
        if (pwStart + pwEnd !== 0) {
          codeW = `
          for (int i = 0; i < ${kw}; i++) {
            x[${rank} - 1] = indices[${rank} - 1] * ${sw} - ${pwStart} + i;
            if (x[${rank} - 1] < 0 || x[${rank} - 1] >= ${dimW}) {
              pad++;
              continue;
            }
            ${op1}
          }`;
        } else {
          codeW = `
          for (int i = 0; i < ${kw}; i++) {
            x[${rank} - 1] = indices[${rank} - 1] * ${sw} - ${pwStart} + i;
            ${op1}
          }`;
        }
        if (attributes.kernelShape.length === 2) {
          const kh = attributes.kernelShape[attributes.kernelShape.length - 2];
          const sh = attributes.strides[attributes.strides.length - 2];
          const phStart = attributes.pads[attributes.pads.length / 2 - 2];
          const phEnd = attributes.pads[attributes.pads.length - 2];
          const dimH = inputDims[rank - 2];
          if (phStart + phEnd !== 0) {
            codeH = `
            for (int j = 0; j < ${kh}; j++) {
              x[${rank} - 2] = indices[${rank} - 2] * ${sh} - ${phStart} + j;
              if (x[${rank} - 2] < 0 || x[${rank} - 2] >= ${dimH}) {
                pad+= ${kw};
                continue;
              }
          `;
          } else {
            codeH = `
            for (int j = 0; j < ${kh}; j++) {
              x[${rank} - 2] = indices[${rank} - 2] * ${sh} - ${phStart} + j;
            `;
          }
          codeHEnd = `
          }
        `;
        }
        const poolingCode = `
        float process(int indices[${rank}]) {
          int x[${rank}];
          copyVec(indices, x);

          float value = ${start};
          int pad = 0;
          ${codeH}
          ${codeW}
          ${codeHEnd}
          ${op2}
          return value;
        }
      `;
        return poolingCode;
      } else {
        const kernelSize = ShapeUtil.size(attributes.kernelShape);
        const kernelStrides = ShapeUtil.computeStrides(attributes.kernelShape);
        const stridesRank = kernelStrides.length;
        const padsRank = attributes.pads.length;
        const offsetToIndicesFunction = offsetToIndices(stridesRank);
        const copyInputDims = copyArray(inputDims, "inputDims");
        const copyPads = copyArray(attributes.pads, "pads");
        const copyKernelStrides = copyArray(kernelStrides, "kernelStrides");
        const copyStrides = copyArray(attributes.strides, "strides");
        const hasPads = attributes.pads.reduce((sum2, cur) => sum2 + cur);
        let padCode = "";
        if (hasPads) {
          padCode = `
            if (x[j] >= inputDims[j] || x[j] < 0) {
              pad++;
              isPad = true;
              break;
            }
          }
          if (!isPad) {
            ${op1}
          }`;
        } else {
          padCode = `
          }
          ${op1}
        `;
        }
        const poolingCode = `
        ${offsetToIndicesFunction}
        float process(int indices[${rank}]) {
          int x[${rank}];
          copyVec(indices, x);
          int offset[${stridesRank}];
          int pads[${padsRank}];
          int inputDims[${rank}];
          int kernelStrides[${stridesRank}];
          int strides[${stridesRank}];
          ${copyPads}
          ${copyInputDims}
          ${copyStrides}
          ${copyKernelStrides}

          float value = ${start};
          int pad = 0;
          bool isPad = false;
          for (int i = 0; i < ${kernelSize}; i++) {
            offsetToIndices(i, kernelStrides, offset);
            isPad = false;
            for (int j = ${rank} - ${stridesRank}; j < ${rank}; j++) {
              x[j] = indices[j] * strides[j - ${rank} + ${stridesRank}]
                + offset[j - ${rank} + ${stridesRank}] - pads[j - 2];
              ${padCode}
          }
          ${op2}

          return value;
        }
      `;
        return poolingCode;
      }
    };
    copyArray = (array, arrayName) => {
      let block = "";
      for (let i = 0; i < array.length; i++) {
        block += `
      ${arrayName}[${i}] = ${array[i]};
    `;
      }
      return block;
    };
    offsetToIndices = (rank) => `
  void offsetToIndices(int offset, int[${rank}] strides, out int[${rank}] indices) {
    if (${rank} == 0) {
      return;
    }
    for (int i = 0; i < ${rank} - 1; ++i) {
      indices[i] = offset / strides[i];
      offset -= indices[i] * strides[i];
    }
    indices[${rank} - 1] = offset;
  }`;
  }
});

// web/lib/onnxjs/backends/webgl/ops/reduce.ts
var reduce, parseReduceAttributes, createReduceProgramInfo, validateInputs16, reduceSum, reduceMean, reduceMax, reduceMin, reduceProd, reduceLogSum, reduceLogSumSquare;
var init_reduce = __esm({
  "web/lib/onnxjs/backends/webgl/ops/reduce.ts"() {
    "use strict";
    init_attribute_with_cache_key();
    init_operators();
    init_util();
    init_types();
    reduce = (inferenceHandler, inputs, attributes, name2, reduceOp) => {
      validateInputs16(inputs);
      const reduceProgramMetadata = {
        name: name2,
        inputNames: ["A"],
        inputTypes: [0 /* unpacked */]
      };
      const output = inferenceHandler.run(
        {
          ...reduceProgramMetadata,
          cacheHint: attributes.cacheKey,
          get: () => createReduceProgramInfo(inferenceHandler, inputs, attributes, name2, reduceOp, reduceProgramMetadata)
        },
        inputs
      );
      return [output];
    };
    parseReduceAttributes = (node) => {
      const axes = node.attributes.getInts("axes", []);
      const keepDims = node.attributes.getInt("keepdims", 1) === 1;
      return createAttributeWithCacheKey({ axes, keepDims });
    };
    createReduceProgramInfo = (_handler, inputs, attributes, _name, reduceOp, reduceProgramMetadata) => {
      const outputShape = [];
      const iRank = inputs[0].dims.length || 1;
      const idxCopy = [];
      const axes = ShapeUtil.normalizeAxes(attributes.axes, inputs[0].dims.length);
      const ops = reduceOp(inputs, axes);
      let reduceOps = ops[1];
      for (let k = 0; k < inputs[0].dims.length; k++) {
        if (axes.indexOf(k) >= 0 || axes.length === 0) {
          if (attributes.keepDims) {
            outputShape.push(1);
          }
          reduceOps = `
          for(int j${k} = 0; j${k} < ${inputs[0].dims[k]}; j${k}++) {
            inputIdx[${k}] = j${k};
            ${reduceOps}
          }`;
        } else {
          idxCopy.push(`inputIdx[${k}] = outputIdx[${outputShape.length}];`);
          outputShape.push(inputs[0].dims[k]);
        }
      }
      const oRank = outputShape.length || 1;
      const shaderSource = `
      float process(int outputIdx[${oRank}]) {
        float value;                 // final result
        int inputIdx[${iRank}];      // addressing input data
        ${idxCopy.join("\n")}
        ${ops[0]}       // init ops for reduce max/min
        ${reduceOps}
        ${ops[2]}       // final computation for reduce mean
        return value;
      }`;
      return {
        ...reduceProgramMetadata,
        output: { dims: outputShape, type: inputs[0].type, textureType: 0 /* unpacked */ },
        shaderSource
      };
    };
    validateInputs16 = (inputs) => {
      if (!inputs || inputs.length !== 1) {
        throw new Error("Reduce op requires 1 input.");
      }
      if (NUMBER_TYPES.indexOf(inputs[0].type) === -1) {
        throw new Error("Invalid input type.");
      }
    };
    reduceSum = (inferenceHandler, inputs, attributes) => {
      const reduceOp = () => ["value = 0.0;", "value += _A(inputIdx);", ""];
      return reduce(inferenceHandler, inputs, attributes, "ReduceSum", reduceOp);
    };
    reduceMean = (inferenceHandler, inputs, attributes) => {
      const reduceOp = (inputs2, axes) => {
        let size = 1;
        for (let k = 0; k < inputs2[0].dims.length; k++) {
          if (axes.indexOf(k) >= 0 || axes.length === 0) {
            size *= inputs2[0].dims[k];
          }
        }
        return ["value = 0.0;", "value += _A(inputIdx);", `value /= ${size}.;`];
      };
      return reduce(inferenceHandler, inputs, attributes, "ReduceMean", reduceOp);
    };
    reduceMax = (inferenceHandler, inputs, attributes) => {
      const reduceOp = (inputs2, axes) => {
        const idxZero = [];
        for (let k = 0; k < inputs2[0].dims.length; k++) {
          if (axes.indexOf(k) >= 0 || axes.length === 0) {
            idxZero.push(`inputIdx[${k}] = 0;`);
          }
        }
        return [`${idxZero.join("\n")}
value = _A(inputIdx);`, "value = max(value, _A(inputIdx));", ""];
      };
      return reduce(inferenceHandler, inputs, attributes, "ReduceMax", reduceOp);
    };
    reduceMin = (inferenceHandler, inputs, attributes) => {
      const reduceOp = (inputs2, axes) => {
        const idxZero = [];
        for (let k = 0; k < inputs2[0].dims.length; k++) {
          if (axes.indexOf(k) >= 0 || axes.length === 0) {
            idxZero.push(`inputIdx[${k}] = 0;`);
          }
        }
        return [`${idxZero.join("\n")}
value = _A(inputIdx);`, "value = min(value, _A(inputIdx));", ""];
      };
      return reduce(inferenceHandler, inputs, attributes, "ReduceMin", reduceOp);
    };
    reduceProd = (inferenceHandler, inputs, attributes) => {
      const reduceOp = () => ["value = 1.0;", "value *= _A(inputIdx);", ""];
      return reduce(inferenceHandler, inputs, attributes, "ReduceProd", reduceOp);
    };
    reduceLogSum = (inferenceHandler, inputs, attributes) => {
      const reduceOp = () => ["value = 0.0;", "value += _A(inputIdx);", "value = log(value);"];
      return reduce(inferenceHandler, inputs, attributes, "ReduceLogSum", reduceOp);
    };
    reduceLogSumSquare = (inferenceHandler, inputs, attributes) => {
      const reduceOp = () => ["float t; value = 0.0;", "t = _A(inputIdx); value += t * t;", ""];
      return reduce(inferenceHandler, inputs, attributes, "ReduceLogSumSquare", reduceOp);
    };
  }
});

// web/lib/onnxjs/backends/webgl/ops/reshape.ts
var reshape;
var init_reshape = __esm({
  "web/lib/onnxjs/backends/webgl/ops/reshape.ts"() {
    "use strict";
    init_util();
    reshape = (handler, inputs) => {
      const reshapedDims = ShapeUtil.calculateReshapedDims(inputs[0].dims, inputs[1].integerData);
      if (handler.session.pack) {
        return [handler.reshapePacked(inputs[0], reshapedDims)];
      } else {
        return [handler.reshapeUnpacked(inputs[0], reshapedDims)];
      }
    };
  }
});

// web/lib/onnxjs/backends/webgl/ops/upsample.ts
var upsampleProgramMetadata, upsample, parseUpsampleAttributesV7, parseUpsampleAttributesV9, parseUpsampleAttributes, createUpsampleProgramInfo, validateInputs17, scalesValidation;
var init_upsample = __esm({
  "web/lib/onnxjs/backends/webgl/ops/upsample.ts"() {
    "use strict";
    init_attribute_with_cache_key();
    init_glsl_source();
    init_types();
    upsampleProgramMetadata = {
      name: "Upsample",
      inputNames: ["X"],
      inputTypes: [0 /* unpacked */]
    };
    upsample = (inferenceHandler, inputs, attributes) => {
      validateInputs17(inputs, attributes);
      const output = inferenceHandler.run(
        {
          ...upsampleProgramMetadata,
          cacheHint: attributes.cacheKey,
          get: () => createUpsampleProgramInfo(inferenceHandler, inputs, attributes)
        },
        inputs
      );
      return [output];
    };
    parseUpsampleAttributesV7 = (node) => parseUpsampleAttributes(node, 7);
    parseUpsampleAttributesV9 = (node) => parseUpsampleAttributes(node, 9);
    parseUpsampleAttributes = (node, opset) => {
      const isResize = opset >= 10;
      const mode = node.attributes.getString("mode", "nearest");
      if (mode !== "nearest" && mode !== "linear" && (opset < 11 || mode !== "cubic")) {
        throw new Error(`unrecognized mode: ${mode}`);
      }
      let scales = [];
      if (opset < 9) {
        scales = node.attributes.getFloats("scales");
        scalesValidation(scales, mode, isResize);
      }
      const extrapolationValue = node.attributes.getFloat("extrapolation_value", 0);
      const coordinateTransformMode = opset > 10 ? node.attributes.getString("coordinate_transformation_mode", "half_pixel") : "asymmetric";
      if ([
        "asymmetric",
        "pytorch_half_pixel",
        "tf_half_pixel_for_nn",
        "align_corners",
        "tf_crop_and_resize",
        "half_pixel"
      ].indexOf(coordinateTransformMode) === -1) {
        throw new Error(`coordinate_transform_mode '${coordinateTransformMode}' is not supported`);
      }
      const needRoiInput = coordinateTransformMode === "tf_crop_and_resize";
      const useExtrapolation = needRoiInput;
      const nearestMode = mode === "nearest" && opset >= 11 ? node.attributes.getString("nearest_mode", "round_prefer_floor") : "";
      if (["round_prefer_floor", "round_prefer_ceil", "floor", "ceil", ""].indexOf(nearestMode) === -1) {
        throw new Error(`nearest_mode '${nearestMode}' is not supported`);
      }
      const cubicCoefficientA = node.attributes.getFloat("cubic_coeff_a", -0.75);
      const excludeOutside = node.attributes.getInt("exclude_outside", 0) !== 0;
      if (excludeOutside && mode !== "cubic") {
        throw new Error("exclude_outside can be set to 1 only when mode is CUBIC.");
      }
      const useNearest2xOptimization = opset < 11 ? true : mode === "nearest" && coordinateTransformMode === "asymmetric" && nearestMode === "floor";
      let roiInputIdx = 0;
      let scalesInputIdx = 0;
      let sizesInputIdx = 0;
      if (opset > 10) {
        if (node.inputs.length > 2) {
          roiInputIdx = 1;
          scalesInputIdx = 2;
          sizesInputIdx = 3;
        } else {
          scalesInputIdx = 1;
          sizesInputIdx = 2;
        }
      } else if (opset === 9) {
        scalesInputIdx = 1;
      }
      return createAttributeWithCacheKey({
        opset,
        isResize,
        mode,
        scales,
        extrapolationValue,
        coordinateTransformMode,
        useExtrapolation,
        needRoiInput,
        nearestMode,
        cubicCoefficientA,
        excludeOutside,
        useNearest2xOptimization,
        roiInputIdx,
        scalesInputIdx,
        sizesInputIdx
      });
    };
    createUpsampleProgramInfo = (inferenceHandler, inputs, attributes) => {
      const glsl = getGlsl(inferenceHandler.session.backend.glContext.version);
      const [inputWidth, inputHeight] = inferenceHandler.calculateTextureWidthAndHeight(inputs[0].dims, 0 /* unpacked */);
      const outputShape = inputs[0].dims.map((dim2, i) => Math.floor(dim2 * attributes.scales[i]));
      const [outputWidth, outputHeight] = inferenceHandler.calculateTextureWidthAndHeight(outputShape, 0 /* unpacked */);
      const dim = outputShape.length;
      const outputPitches = new Array(dim);
      const inputPitches = new Array(dim);
      let precalculatedPitches = `
      int output_pitches[${dim}];
      int input_pitches[${dim}];
      `;
      for (let d = dim - 1; d >= 0; d--) {
        outputPitches[d] = d === dim - 1 ? 1 : outputPitches[d + 1] * outputShape[d + 1];
        inputPitches[d] = d === dim - 1 ? 1 : inputPitches[d + 1] * inputs[0].dims[d + 1];
        precalculatedPitches += `
        output_pitches[${d}] = ${outputPitches[d]};
        input_pitches[${d}] = ${inputPitches[d]};
        `;
      }
      const getInputFloatFunction = `
      float getInputFloat(int index) {
        vec2 coords = offsetToCoords(index, ${inputWidth}, ${inputHeight});
        float value = getColorAsFloat(${glsl.texture2D}(X, coords));
        return value;
      }
      `;
      const shaderSource = attributes.mode === "nearest" ? (
        // nearest
        `
    ${getInputFloatFunction}
    float process(int indices[${dim}]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${outputWidth}, ${outputHeight});

      ${precalculatedPitches}

      int d, m;
      for (int dim = 0; dim < ${dim}; ++dim) {
        d = output_index / output_pitches[dim];
        m = output_index - d * output_pitches[dim];
        output_index = m;

        if (scales[dim] != 1 && d > 0) {
          int d2 = d / scales[dim];
          m = d - d2 * scales[dim];
          d = d2;
        }
        input_index += input_pitches[dim] * d;
      }

      return getInputFloat(input_index);
    }`
      ) : dim === 4 ? (
        // bilinear 4D
        `
    ${getInputFloatFunction}
    float process(int indices[4]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${outputWidth}, ${outputHeight});

      ${precalculatedPitches}

      int m;
      int index_of_dim0, index_of_dim1, index_of_dim2, index_of_dim3;
      index_of_dim0 = output_index / output_pitches[0];
      m = output_index - index_of_dim0 * output_pitches[0];
      index_of_dim1 = m / output_pitches[1];
      m = m - index_of_dim1 * output_pitches[1];
      index_of_dim2 = m / output_pitches[2];
      m = m - index_of_dim2 * output_pitches[2];
      index_of_dim3 = m;

      int index_of_input_dim2, index_of_input_dim3, x_offset, y_offset;
      index_of_input_dim2 = index_of_dim2 / scales[2];
      y_offset = index_of_dim2 - index_of_input_dim2 * scales[2];
      index_of_input_dim3 = index_of_dim3 / scales[3];
      x_offset = index_of_dim3 - index_of_input_dim3 * scales[3];

      input_index = index_of_dim0 * input_pitches[0] +
            index_of_dim1 * input_pitches[1] +
            index_of_input_dim2 * input_pitches[2] +
            index_of_input_dim3;

      float x00 = getInputFloat(input_index);
      float x10, x01, x11;

      bool end_of_dim2 = false;
      if (index_of_input_dim2 == (${inputs[0].dims[2]} - 1)) {
        // It's the end in dimension 2
        x01 = x00;
        end_of_dim2 = true;
      } else {
        x01 = getInputFloat(input_index + input_pitches[2]);
      }

      if (index_of_input_dim3 == (input_pitches[2] - 1)) {
        // It's the end in dimension 3
        x10 = x00;
        x11 = x01;
      }
      else {
        x10 = getInputFloat(input_index + 1);
        x11 = end_of_dim2 ? x10 : getInputFloat(input_index + input_pitches[2] + 1);
      }

      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[2]);
      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[2]);
      return y0 + float(x_offset) * (y1 - y0) / float(scales[3]);
    }`
      ) : (
        // bilinear 2D
        `
    ${getInputFloatFunction}
    float process(int indices[2]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${outputWidth}, ${outputHeight});

      ${precalculatedPitches}

      int m;
      int index_of_dim0, index_of_dim1;
      index_of_dim0 = output_index / output_pitches[0];
      m = output_index - index_of_dim0 * output_pitches[0];
      index_of_dim1 = m;

      int index_of_input_dim0, index_of_input_dim1, x_offset, y_offset;
      index_of_input_dim0 = index_of_dim0 / scales[0];
      y_offset = index_of_dim0 - index_of_input_dim0 * scales[0];
      index_of_input_dim1 = index_of_dim1 / scales[1];
      x_offset = index_of_dim1 - index_of_input_dim1 * scales[1];

      input_index = index_of_input_dim0 * input_pitches[0] + index_of_input_dim1;

      float x00 = getInputFloat(input_index);
      float x10, x01, x11;

      bool end_of_dim0 = false;
      if (index_of_input_dim0 == (${inputs[0].dims[0]} - 1)) {
        // It's the end in dimension 0
        x01 = x00;
        end_of_dim0 = true;
      } else {
        x01 = getInputFloat(input_index + input_pitches[0]);
      }

      if (index_of_input_dim1 == (input_pitches[0] - 1)) {
        // It's the end in dimension 1
        x10 = x00;
        x11 = x01;
      }
      else {
        x10 = getInputFloat(input_index + 1);
        x11 = end_of_dim0 ? x10 : getInputFloat(input_index + input_pitches[0] + 1);
      }

      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[0]);
      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[0]);
      return y0 + float(x_offset) * (y1 - y0) / float(scales[1]);
    }`
      );
      return {
        ...upsampleProgramMetadata,
        output: { dims: outputShape, type: inputs[0].type, textureType: 0 /* unpacked */ },
        shaderSource,
        variables: [{
          name: "scales",
          type: "int",
          arrayLength: attributes.scales.length,
          data: attributes.scales.map((x) => Math.ceil(x))
        }]
      };
    };
    validateInputs17 = (inputs, attribute) => {
      if (!inputs || attribute.opset < 9 && inputs.length !== 1 || attribute.opset >= 9 && attribute.opset < 11 && inputs.length !== 2 || attribute.opset >= 11 && inputs.length < 2) {
        throw new Error("invalid inputs.");
      }
      if (attribute.scales.length > 0 && inputs[0].dims.length !== attribute.scales.length) {
        throw new Error("Invalid input shape.");
      }
      if (inputs[0].type === "string") {
        throw new Error("Invalid input tensor types.");
      }
    };
    scalesValidation = (scales, mode, isResize) => {
      if (!isResize) {
        for (const scale of scales) {
          if (scale < 1) {
            throw new Error("Scale value should be greater than or equal to 1.");
          }
        }
      } else {
        for (const scale of scales) {
          if (scale <= 0) {
            throw new Error("Scale value should be greater than 0.");
          }
        }
      }
      if (mode === "linear" || mode === "cubic") {
        if (scales.length !== 2 && (scales.length !== 4 || scales[0] !== 1 || scales[1] !== 1)) {
          throw new Error(`'Linear' mode and 'Cubic' mode only support 2-D inputs ('Bilinear', 'Bicubic')         or 4-D inputs with the corresponding outermost 2 scale values being 1         in the ${isResize ? "Resize" : "Upsample"} opeartor.`);
        }
      }
    };
  }
});

// web/lib/onnxjs/backends/webgl/ops/resize-packed.ts
var resizeProgramMetadata, resize, parseResizeAttributesV10, parseResizeAttributesV11, createPackedResizeProgramInfo, prepareInputs, parseScalesData, parseScalesDataFromOutputSize;
var init_resize_packed = __esm({
  "web/lib/onnxjs/backends/webgl/ops/resize-packed.ts"() {
    "use strict";
    init_glsl_source();
    init_types();
    init_utils();
    init_packing_utils();
    init_upsample();
    resizeProgramMetadata = {
      name: "Resize",
      inputNames: ["A"],
      inputTypes: [2 /* packed */]
    };
    resize = (inferenceHandler, inputs, attributes) => {
      validateInputs17(inputs, attributes);
      const output = inferenceHandler.run(
        {
          ...resizeProgramMetadata,
          cacheHint: attributes.cacheKey,
          get: () => createPackedResizeProgramInfo(inferenceHandler, inputs, attributes)
        },
        inputs
      );
      return [output];
    };
    parseResizeAttributesV10 = (node) => parseUpsampleAttributes(node, 10);
    parseResizeAttributesV11 = (node) => parseUpsampleAttributes(node, 11);
    createPackedResizeProgramInfo = (inferenceHandler, inputs, attributes) => {
      const glsl = getGlsl(inferenceHandler.session.backend.glContext.version);
      const [scales, outputShape] = prepareInputs(inputs, attributes);
      const isSame = scales.every((s) => s === 1) && attributes.coordinateTransformMode !== "tf_crop_and_resize";
      if (isSame) {
        return {
          ...resizeProgramMetadata,
          output: { dims: outputShape, type: inputs[0].type, textureType: 2 /* packed */ },
          hasMain: true,
          shaderSource: `void main() {
                    vec4 v = ${glsl.texture2D}(X, TexCoords);
                    ${glsl.output} = v;
                }`
        };
      }
      const dim = outputShape.length;
      if (dim < 2) {
        throw new Error(`output dimension should be at least 2, but got ${dim}`);
      }
      const outputHeight = outputShape[dim - 2];
      const outputWidth = outputShape[dim - 1];
      const inputShape = inputs[0].dims;
      if (dim !== inputShape.length) {
        throw new Error(`output dimension should match input ${inputShape.length}, but got ${dim}`);
      }
      const inputHeight = inputShape[dim - 2];
      const inputWidth = inputShape[dim - 1];
      const scalesHeight = scales[dim - 2];
      const scalesWidth = scales[dim - 1];
      let getSourceFracIndex = "";
      if (attributes.mode !== "linear") {
        throw new Error(`resize (packed) does not support mode: '${attributes.mode}'`);
      }
      switch (attributes.coordinateTransformMode) {
        case "asymmetric":
          getSourceFracIndex = `
                    vec4 getSourceFracIndex(ivec4 coords) {
                        return vec4(coords) / scaleWHWH;
                    }
                `;
          break;
        case "half_pixel":
          getSourceFracIndex = `
                    vec4 getSourceFracIndex(ivec4 coords) {
                        return (vec4(coords) + 0.5) / scaleWHWH - 0.5;
                    }
                `;
          break;
        case "pytorch_half_pixel":
          getSourceFracIndex = `
                    vec4 getSourceFracIndex(ivec4 coords) {
                        vec4 fcoords = vec4(coords);
                        return vec4(
                            ${outputWidth}.0 > 1.0 ? (fcoords.x + 0.5) / scaleWHWH.x - 0.5 : 0.0,
                            ${outputHeight}.0 > 1.0 ? (fcoords.y + 0.5) / scaleWHWH.y - 0.5 : 0.0,
                            ${outputWidth}.0 > 1.0 ? (fcoords.z + 0.5) / scaleWHWH.z - 0.5 : 0.0,
                            ${outputHeight}.0 > 1.0 ? (fcoords.w + 0.5) / scaleWHWH.w - 0.5 : 0.0
                          );
                    }
                `;
          break;
        case "align_corners":
          getSourceFracIndex = `
                    vec4 getSourceFracIndex(ivec4 coords) {
                        vec4 resized = vec4(${outputWidth}.0 - 1.0, ${outputHeight}.0 - 1.0, ${outputWidth}.0 - 1.0,
                            ${outputHeight}.0 - 1.0);
                        vec4 original = vec4(${inputWidth}.0 - 1.0, ${inputHeight}.0 - 1.0, ${inputWidth}.0 - 1.0,
                            ${inputHeight}.0 - 1.0);
                        vec4 new_scale = original / resized;
                        return vec4(coords) * new_scale;
                    }
                `;
          break;
        default:
          throw new Error(`resize (packed) does not support coordinateTransformMode:                                 '${attributes.coordinateTransformMode}'`);
      }
      const coordsDataType = getCoordsDataType(dim);
      const unpackChannel = unpackFromChannel();
      const shaderSource = `
            const vec2 inputWH = vec2(${inputHeight}.0, ${inputWidth}.0);
            const vec4 scaleWHWH = vec4(float(${scalesHeight}), float(${scalesWidth}), float(${scalesHeight}), float(${scalesWidth}));
            ${unpackChannel}
            ${getSourceFracIndex}
            float getAValue(int x10, int r, int c, int d) {
                return getChannel(getA(x10, r, c, d), vec2(c, d));
            }
            void main() {
                ${coordsDataType} rc = getOutputCoords();

                int batch = rc[0];
                int depth = rc[1];

                // retrieve the 4 coordinates that is used in the 4 packed output values.
                ivec4 coords = ivec4(rc.wz, rc.w + 1, rc.z + 1);

                // calculate the source index in fraction
                vec4 sourceFrac = getSourceFracIndex(coords);

                // get the lower and upper bound of the 4 values that will be packed into one texel.
                ivec4 x00 = ivec4(max(sourceFrac.xy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xy)));
                ivec4 x01 = ivec4(max(sourceFrac.xw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xw)));
                ivec4 x10 = ivec4(max(sourceFrac.zy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zy)));
                ivec4 x11 = ivec4(max(sourceFrac.zw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zw)));

                bool hasNextRow = rc.w < ${outputHeight - 1};
                bool hasNextCol = rc.z < ${outputWidth - 1};

                // pack x00, x01, x10, x11's top-left corner into one vec4 structure
                vec4 topLeft = vec4(
                    getAValue(batch, depth, x00.x, x00.y),
                    hasNextCol ? getAValue(batch, depth, x01.x, x01.y) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.x, x10.y) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.y) : 0.0);

                // pack x00, x01, x10, x11's top-right corner into one vec4 structure
                vec4 topRight = vec4(
                    getAValue(batch, depth, x00.x, x00.w),
                    hasNextCol ? getAValue(batch, depth, x01.x, x01.w) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.x, x10.w) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.w) : 0.0);

                // pack x00, x01, x10, x11's bottom-left corner into one vec4 structure
                vec4 bottomLeft = vec4(
                    getAValue(batch, depth, x00.z, x00.y),
                    hasNextCol ? getAValue(batch, depth, x01.z, x01.y) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.z, x10.y) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.y) : 0.0);

                // pack x00, x01, x10, x11's bottom-right corner into one vec4 structure
                vec4 bottomRight = vec4(
                    getAValue(batch, depth, x00.z, x00.w),
                    hasNextCol ? getAValue(batch, depth, x01.z, x01.w) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.z, x10.w) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.w) : 0.0);

                // calculate the interpolation fraction on u and v direction
                vec4 frac = vec4(sourceFrac) - floor(sourceFrac);
                vec4 clampFrac = clamp(frac, vec4(0.0), vec4(1.0));

                vec4 top = mix(topLeft, topRight, clampFrac.ywyw);
                vec4 bottom = mix(bottomLeft, bottomRight, clampFrac.ywyw);
                vec4 newValue = mix(top, bottom, clampFrac.xxzz);

                ${glsl.output} = vec4(newValue);
            }
        `;
      return {
        ...resizeProgramMetadata,
        output: { dims: outputShape, type: inputs[0].type, textureType: 2 /* packed */ },
        hasMain: true,
        shaderSource
      };
    };
    prepareInputs = (inputs, attributes) => {
      const x = inputs[0];
      const xDims = x.dims;
      let scales = attributes.scales;
      let outputSizes;
      if (scales.length === 0) {
        const scalesTensor = inputs[attributes.scalesInputIdx];
        if (scalesTensor && scalesTensor.size !== 0) {
          if (inputs[attributes.sizesInputIdx]) {
            throw new Error("Only one of scales or sizes must be provided as input.");
          }
          scales = parseScalesData(scalesTensor, attributes.mode, attributes.isResize);
        } else {
          const sizesTensor = inputs[attributes.sizesInputIdx];
          if (!sizesTensor || sizesTensor.size === 0) {
            throw new Error("Either scales or sizes MUST be provided as input.");
          }
          outputSizes = Array.from(sizesTensor.integerData);
          scales = parseScalesDataFromOutputSize(outputSizes, xDims, attributes.mode, attributes.isResize);
        }
      } else {
        if (inputs[attributes.sizesInputIdx]) {
          throw new Error("Only one of scales or sizes must be provided as input.");
        }
      }
      const yDims = outputSizes || xDims.map((dim, i) => Math.floor(dim * scales[i]));
      return [scales, yDims];
    };
    parseScalesData = (scale, mode, isResize) => {
      const scales = Array.from(scale.floatData);
      scalesValidation(scales, mode, isResize);
      return scales;
    };
    parseScalesDataFromOutputSize = (yDims, xDims, mode, isResize) => {
      const length = xDims.length;
      const scales = new Array(length);
      for (let i = 0, end = length; i < end; i++) {
        if (xDims[i] === 0) {
          if (yDims[i] !== 0) {
            throw new Error("Input dim is zero but required output dim is non-zero.");
          }
          scales[i] = 1;
        } else {
          scales[i] = yDims[i] / xDims[i];
        }
      }
      scalesValidation(scales, mode, isResize);
      return scales;
    };
  }
});

// web/lib/onnxjs/backends/webgl/ops/shape.ts
var shape, validateInputs18;
var init_shape = __esm({
  "web/lib/onnxjs/backends/webgl/ops/shape.ts"() {
    "use strict";
    init_tensor2();
    shape = (_inferenceHandler, inputs) => {
      validateInputs18(inputs);
      return [new Tensor3([inputs[0].dims.length], "int32", void 0, void 0, new Int32Array(inputs[0].dims))];
    };
    validateInputs18 = (inputs) => {
      if (!inputs || inputs.length !== 1) {
        throw new Error("Shape requires 1 input.");
      }
    };
  }
});

// web/lib/onnxjs/backends/webgl/ops/slice.ts
var sliceProgramMetadata, slice, parseSliceAttributes, createSliceProgramInfo, validateInputs19, sliceV10, generateSliceAttributesFromInputs, validateInputsV10;
var init_slice = __esm({
  "web/lib/onnxjs/backends/webgl/ops/slice.ts"() {
    "use strict";
    init_attribute_with_cache_key();
    init_operators();
    init_util();
    init_types();
    sliceProgramMetadata = {
      name: "Slice",
      inputNames: ["A"],
      inputTypes: [0 /* unpacked */]
    };
    slice = (inferenceHandler, inputs, attributes) => {
      validateInputs19(inputs);
      const output = inferenceHandler.run(
        {
          ...sliceProgramMetadata,
          cacheHint: attributes.cacheKey,
          get: () => createSliceProgramInfo(inferenceHandler, inputs[0], attributes)
        },
        inputs
      );
      return [output];
    };
    parseSliceAttributes = (node) => {
      const starts = node.attributes.getInts("starts");
      const ends = node.attributes.getInts("ends");
      const axes = node.attributes.getInts("axes", []);
      return createAttributeWithCacheKey({ starts, ends, axes });
    };
    createSliceProgramInfo = (_inferenceHandler, input, attributes) => {
      const axes = attributes.axes.length === 0 ? input.dims.slice(0).map((_val, i) => i) : attributes.axes;
      const normalizedAxes = ShapeUtil.normalizeAxes(axes, input.dims.length);
      const starts = attributes.starts.map((start, i) => {
        if (start > input.dims[normalizedAxes[i]] - 1) {
          return input.dims[normalizedAxes[i]];
        }
        return ShapeUtil.normalizeAxis(start, input.dims[normalizedAxes[i]]);
      });
      const ends = attributes.ends.map((end, i) => {
        if (end > input.dims[normalizedAxes[i]] - 1) {
          return input.dims[normalizedAxes[i]];
        }
        return ShapeUtil.normalizeAxis(end, input.dims[normalizedAxes[i]]);
      });
      const outputShape = input.dims.slice();
      const sliceOps = [];
      for (let i = 0; i < normalizedAxes.length; i++) {
        outputShape[normalizedAxes[i]] = ends[i] - starts[i];
        if (starts[i] > 0) {
          sliceOps.push(`outputIdx[${normalizedAxes[i]}] += ${starts[i]};`);
        }
      }
      const rank = outputShape.length;
      const shaderSource = `
      float process(int outputIdx[${rank}]) {
        ${sliceOps.join("\n      ")}
        return _A(outputIdx);
      }`;
      return {
        ...sliceProgramMetadata,
        output: { dims: outputShape, type: input.type, textureType: 0 /* unpacked */ },
        shaderSource
      };
    };
    validateInputs19 = (inputs) => {
      if (!inputs || inputs.length !== 1) {
        throw new Error("Slice requires 1 input.");
      }
      if (NUMBER_TYPES.indexOf(inputs[0].type) === -1) {
        throw new Error("Invalid input type.");
      }
    };
    sliceV10 = (inferenceHandler, inputs) => {
      validateInputsV10(inputs);
      const attributes = generateSliceAttributesFromInputs(inferenceHandler, inputs);
      const output = inferenceHandler.run(
        {
          ...sliceProgramMetadata,
          cacheHint: attributes.cacheKey,
          get: () => createSliceProgramInfo(inferenceHandler, inputs[0], attributes)
        },
        [inputs[0]]
      );
      return [output];
    };
    generateSliceAttributesFromInputs = (inferenceHandler, inputs) => {
      if (!inferenceHandler.session.isInitializer(inputs[1].dataId) || !inferenceHandler.session.isInitializer(inputs[2].dataId) || inputs.length >= 4 && !inferenceHandler.session.isInitializer(inputs[3].dataId) || inputs.length >= 5 && !inferenceHandler.session.isInitializer(inputs[4].dataId)) {
        throw new Error("dynamic slice attributes are not allowed");
      }
      if (inputs.length >= 5 && inputs[4].integerData.some((i) => i !== 1)) {
        throw new Error("currently non-1 steps is not supported for Slice");
      }
      const starts = Array.from(inputs[1].integerData);
      const ends = Array.from(inputs[2].integerData);
      const axes = inputs.length >= 4 ? Array.from(inputs[3].integerData) : [];
      const cacheKey = `${axes};${starts};${ends}`;
      return { starts, ends, axes, cacheKey };
    };
    validateInputsV10 = (inputs) => {
      if (!inputs || inputs.length < 3 || inputs.length > 5) {
        throw new Error("Invalid input number.");
      }
      if (inputs[1].type !== "int32" || inputs[1].dims.length !== 1) {
        throw new Error("Invalid input type.");
      }
      if (inputs[2].type !== "int32" || inputs[2].dims.length !== 1) {
        throw new Error("Invalid input type.");
      }
      if (inputs.length >= 4 && (inputs[3].type !== "int32" || inputs[3].dims.length !== 1)) {
        throw new Error("Invalid input type.");
      }
      if (inputs.length >= 5 && (inputs[4].type !== "int32" || inputs[4].dims.length !== 1)) {
        throw new Error("Invalid input type.");
      }
    };
  }
});

// web/lib/onnxjs/backends/webgl/ops/softmax.ts
var softmaxComputeMaxProgramMetadata, softmaxComputeScaleProgramMetadata, softmaxProgramMetadata, softmax, parseSoftmaxAttributes, parseSoftmaxAttributesV13, softmaxV13, computeSoftmax, createComputeMaxProgramInfo, createComputScaleProgramInfo, createSoftMaxProgramInfo, validateInputs20;
var init_softmax = __esm({
  "web/lib/onnxjs/backends/webgl/ops/softmax.ts"() {
    "use strict";
    init_attribute_with_cache_key();
    init_util();
    init_glsl_source();
    init_types();
    init_transpose();
    softmaxComputeMaxProgramMetadata = {
      name: "SoftmaxComputeMax",
      inputNames: ["A"],
      inputTypes: [0 /* unpacked */]
    };
    softmaxComputeScaleProgramMetadata = {
      name: "SoftmaxComputeScale",
      inputNames: ["A", "Max"],
      inputTypes: [0 /* unpacked */, 0 /* unpacked */]
    };
    softmaxProgramMetadata = {
      name: "SoftMax",
      inputNames: ["A", "Max", "Norm"],
      inputTypes: [0 /* unpacked */, 0 /* unpacked */, 0 /* unpacked */]
    };
    softmax = (inferenceHandler, inputs, attributes) => {
      validateInputs20(inputs);
      const inputShape = inputs[0].dims.slice();
      const axis = ShapeUtil.normalizeAxis(attributes.axis, inputShape.length);
      const logicalRowCount = ShapeUtil.sizeToDimension(inputShape, axis);
      const featureCount = ShapeUtil.sizeFromDimension(inputShape, axis);
      const output = computeSoftmax(inferenceHandler, inputs, attributes, logicalRowCount, featureCount);
      return output;
    };
    parseSoftmaxAttributes = (node) => createAttributeWithCacheKey({ axis: node.attributes.getInt("axis", 1) });
    parseSoftmaxAttributesV13 = (node) => createAttributeWithCacheKey({ axis: node.attributes.getInt("axis", -1) });
    softmaxV13 = (inferenceHandler, inputs, attributes) => {
      validateInputs20(inputs);
      const inputShape = inputs[0].dims.slice();
      const axis = ShapeUtil.normalizeAxis(attributes.axis, inputShape.length);
      const rank = inputShape.length;
      const isTransposeRequired = axis !== rank - 1 ? true : false;
      const transposedInputShape = [];
      let perm = [];
      let transposedInputs = [];
      let transposeAttribute;
      if (isTransposeRequired) {
        perm = Array.from({ length: rank }).map((_, i) => i);
        perm[axis] = rank - 1;
        perm[rank - 1] = axis;
        perm.map((p) => transposedInputShape.push(inputShape[p]));
        transposeAttribute = createAttributeWithCacheKey({ perm });
        transposedInputs = transpose(inferenceHandler, inputs, transposeAttribute);
      }
      const logicalRowCount = isTransposeRequired ? ShapeUtil.sizeToDimension(transposedInputShape, rank - 1) : ShapeUtil.sizeToDimension(inputShape, rank - 1);
      const featureCount = isTransposeRequired ? ShapeUtil.sizeFromDimension(transposedInputShape, rank - 1) : ShapeUtil.sizeFromDimension(inputShape, rank - 1);
      const output = computeSoftmax(
        inferenceHandler,
        isTransposeRequired ? transposedInputs : inputs,
        attributes,
        logicalRowCount,
        featureCount
      );
      if (isTransposeRequired) {
        const reversedOutput = transpose(inferenceHandler, output, transposeAttribute);
        return reversedOutput;
      } else {
        return output;
      }
    };
    computeSoftmax = (inferenceHandler, inputs, attributes, logicalRowCount, featureCount) => {
      const computeMaxProgramInfo = createComputeMaxProgramInfo(inferenceHandler, inputs[0], logicalRowCount, featureCount, [logicalRowCount]);
      const max = inferenceHandler.run(
        { ...softmaxComputeMaxProgramMetadata, cacheHint: attributes.cacheKey, get: () => computeMaxProgramInfo },
        inputs
      );
      const computeScaleProgramInfo = createComputScaleProgramInfo(
        inferenceHandler,
        inputs[0],
        logicalRowCount,
        featureCount,
        computeMaxProgramInfo.output.dims,
        [logicalRowCount]
      );
      const scale = inferenceHandler.run(
        { ...softmaxComputeScaleProgramMetadata, cacheHint: attributes.cacheKey, get: () => computeScaleProgramInfo },
        [inputs[0], max]
      );
      const softMaxProgramInfo = createSoftMaxProgramInfo(
        inferenceHandler,
        inputs[0],
        logicalRowCount,
        featureCount,
        computeMaxProgramInfo.output.dims,
        computeScaleProgramInfo.output.dims
      );
      const output = inferenceHandler.run(
        { ...softmaxProgramMetadata, cacheHint: attributes.cacheKey, get: () => softMaxProgramInfo },
        [inputs[0], max, scale]
      );
      return [output];
    };
    createComputeMaxProgramInfo = (inferenceHandler, input, logicalRowCount, featureCount, outputShape) => {
      const [textureWidth, textureHeight] = inferenceHandler.calculateTextureWidthAndHeight(input.dims, 0 /* unpacked */);
      const rank = outputShape.length;
      if (logicalRowCount < 1 || featureCount < 1) {
        throw new Error("Logical row count N and feature count D must be greater than or equal to 1");
      }
      if (outputShape.length !== 1) {
        throw new Error("Dimensionality of the output should be 1");
      }
      if (outputShape[0] !== logicalRowCount) {
        throw new Error("Shape of the output should be equal to logical row count");
      }
      const glsl = getGlsl(inferenceHandler.session.backend.glContext.version);
      const shaderSource = `
      float process(int[${rank}] indices) {
        int logical_row_start_offset = indices[0] * ${featureCount};

        float max = getColorAsFloat(${glsl.texture2D}(A, offsetToCoords(logical_row_start_offset, ${textureWidth},
        ${textureHeight} )));
        for(int i=1; i<${featureCount}; ++i)
        {
          float current = getColorAsFloat(${glsl.texture2D}(A, offsetToCoords(logical_row_start_offset + i,
            ${textureWidth}, ${textureHeight})));
          if(current > max)
          max = current;
        }

        return max;
      }`;
      return {
        ...softmaxComputeMaxProgramMetadata,
        output: { dims: outputShape, type: input.type, textureType: 0 /* unpacked */ },
        shaderSource
      };
    };
    createComputScaleProgramInfo = (inferenceHandler, input, logicalRowCount, featureCount, maxElementPerLogicalRow, outputShape) => {
      const [textureWidth, textureHeight] = inferenceHandler.calculateTextureWidthAndHeight(input.dims, 0 /* unpacked */);
      const rank = outputShape.length;
      if (logicalRowCount < 1 || featureCount < 1) {
        throw new Error("Logical row count N and feature count D must be greater than or equal to 1");
      }
      if (outputShape.length !== 1) {
        throw new Error("Dimensionality of the output should be 1");
      }
      if (outputShape[0] !== logicalRowCount) {
        throw new Error("Shape of the output should be equal to logical row count");
      }
      if (maxElementPerLogicalRow.length !== 1) {
        throw new Error("Dimensionality of the intermediate results should be 1");
      }
      if (maxElementPerLogicalRow[0] !== logicalRowCount) {
        throw new Error("Shape of the intermediate results should be equal to logical row count");
      }
      const glsl = getGlsl(inferenceHandler.session.backend.glContext.version);
      const shaderSource = `
      float process(int[${rank}] indices) {
        int logical_row_start_offset = indices[0] * ${featureCount};

        float norm_factor = 0.0;
        float max = _Max(indices);
        for(int i=0; i<${featureCount}; ++i)
        {
          norm_factor += exp(getColorAsFloat(${glsl.texture2D}(A, offsetToCoords(logical_row_start_offset + i,
            ${textureWidth}, ${textureHeight}))) - max);
        }

        return norm_factor;
      }`;
      return {
        ...softmaxComputeScaleProgramMetadata,
        output: { dims: outputShape, type: input.type, textureType: 0 /* unpacked */ },
        shaderSource
      };
    };
    createSoftMaxProgramInfo = (inferenceHandler, input, logicalRowCount, featureCount, maxElementPerLogicalRow, normalizationPerLogicalRow) => {
      const [textureWidth, textureHeight] = inferenceHandler.calculateTextureWidthAndHeight(input.dims, 0 /* unpacked */);
      const rank = input.dims.length;
      if (logicalRowCount < 1 || featureCount < 1) {
        throw new Error("Logical row count N and feature count D must be greater than or equal to 1");
      }
      if (maxElementPerLogicalRow.length !== 1 || normalizationPerLogicalRow.length !== 1) {
        throw new Error("Dimensionality of the intermediate results should be 1");
      }
      if (maxElementPerLogicalRow[0] !== logicalRowCount || normalizationPerLogicalRow[0] !== logicalRowCount) {
        throw new Error("Shape of the intermediate results should be equal to logical row count");
      }
      const shaderSource = `
      float process(int[${rank}] indices) {

      // get offset of current logical tensor index from the 2-D texture coordinates (TexCoords)
      int offset = coordsToOffset(TexCoords, ${textureWidth}, ${textureHeight});

      //determine the logical row for this index
      int logical_row_index[1];
      logical_row_index[0] = offset / ${featureCount};

      float norm_factor = _Norm(logical_row_index);

      // avoid possible division by 0
      // if norm_facor is 0, all elements are zero
      // if so, return 0
      if(norm_factor == 0.0)
        return 0.0;

      return exp(_A(indices) - _Max(logical_row_index)) / norm_factor;
    }`;
      return {
        ...softmaxProgramMetadata,
        output: { dims: input.dims, type: input.type, textureType: 0 /* unpacked */ },
        shaderSource
      };
    };
    validateInputs20 = (inputs) => {
      if (!inputs || inputs.length !== 1) {
        throw new Error("Softmax requires 1 input.");
      }
      if (inputs[0].type !== "float32" && inputs[0].type !== "float64") {
        throw new Error("Invalid input type");
      }
    };
  }
});

// web/lib/onnxjs/backends/webgl/ops/split.ts
var splitProgramMetadata, split, parseSplitAttributes, getProgramCount, createSplitProgramInfo, validateInputs21;
var init_split = __esm({
  "web/lib/onnxjs/backends/webgl/ops/split.ts"() {
    "use strict";
    init_attribute_with_cache_key();
    init_util();
    init_types();
    splitProgramMetadata = {
      name: "Split",
      inputNames: ["A"],
      inputTypes: [0 /* unpacked */]
    };
    split = (inferenceHandler, inputs, attributes) => {
      validateInputs21(inputs);
      const axis = ShapeUtil.normalizeAxis(attributes.axis, inputs[0].dims.length);
      const count = getProgramCount(inferenceHandler, inputs, axis, attributes);
      const output = [];
      for (let i = 0; i < count; ++i) {
        output.push(inferenceHandler.run(
          {
            ...splitProgramMetadata,
            cacheHint: `${attributes.cacheKey};${i}`,
            get: () => createSplitProgramInfo(inferenceHandler, inputs[0], attributes, axis, i)
          },
          inputs
        ));
      }
      return output;
    };
    parseSplitAttributes = (node) => {
      const axis = node.attributes.getInt("axis", 0);
      const split2 = node.attributes.getInts("split", []);
      const numOutputs = node.outputs.length;
      return createAttributeWithCacheKey({ axis, split: split2, numOutputs });
    };
    getProgramCount = (_inferenceHandler, inputs, axis, attributes) => {
      const [, offsets] = SplitUtil.splitShape(inputs[0].dims, axis, attributes.split, attributes.numOutputs);
      return offsets.length;
    };
    createSplitProgramInfo = (_inferenceHandler, input, attributes, axis, index) => {
      const [shapes, offsets] = SplitUtil.splitShape(input.dims, axis, attributes.split, attributes.numOutputs);
      const offset = offsets[index];
      const outputShape = shapes[index];
      const rank = outputShape.length;
      const shaderSource = `
      float process(int indices[${rank}]) {
        indices[${axis}] += ${offset};
        return _A(indices);
      }
    `;
      return {
        ...splitProgramMetadata,
        cacheHint: `${attributes.cacheKey}:${index}`,
        output: { dims: outputShape, type: input.type, textureType: 0 /* unpacked */ },
        shaderSource
      };
    };
    validateInputs21 = (inputs) => {
      if (!inputs || inputs.length !== 1) {
        throw new Error("Split requires one input.");
      }
      if (inputs[0].type !== "int8" && inputs[0].type !== "uint8" && inputs[0].type !== "int16" && inputs[0].type !== "uint16" && inputs[0].type !== "int32" && inputs[0].type !== "uint32" && inputs[0].type !== "float32" && inputs[0].type !== "float64" && inputs[0].type !== "bool") {
        throw new Error("Invalid input type.");
      }
    };
  }
});

// web/lib/onnxjs/backends/webgl/ops/squeeze.ts
var squeeze, squeezeV13, parseSqueezeAttributes, validateInputs22, validateInputsV13;
var init_squeeze = __esm({
  "web/lib/onnxjs/backends/webgl/ops/squeeze.ts"() {
    "use strict";
    init_util();
    squeeze = (inferenceHandler, inputs, axes) => {
      validateInputs22(inputs);
      const outputShape = ShapeUtil.squeezeShape(inputs[0].dims, axes);
      const output = inferenceHandler.reshapeUnpacked(inputs[0], outputShape);
      return [output];
    };
    squeezeV13 = (inferenceHandler, inputs) => {
      validateInputsV13(inputs);
      return squeeze(inferenceHandler, [inputs[0]], Array.from(inputs[1].integerData));
    };
    parseSqueezeAttributes = (node) => node.attributes.getInts("axes");
    validateInputs22 = (inputs) => {
      if (!inputs || inputs.length !== 1) {
        throw new Error("Squeeze requires 1 input.");
      }
      if (inputs[0].type === "string") {
        throw new Error("invalid input tensor types.");
      }
    };
    validateInputsV13 = (inputs) => {
      if (!inputs || inputs.length !== 2) {
        throw new Error("Squeeze requires 2 inputs.");
      }
      if (inputs[1].type !== "int32") {
        throw new Error("Invalid input type.");
      }
    };
  }
});

// web/lib/onnxjs/backends/webgl/ops/sum.ts
var sum, createSumProgramInfo, validateInputs23;
var init_sum = __esm({
  "web/lib/onnxjs/backends/webgl/ops/sum.ts"() {
    "use strict";
    init_glsl_source();
    init_types();
    sum = (inferenceHandler, inputs) => {
      validateInputs23(inputs);
      const sumProgramMetadata = {
        name: "Sum",
        inputNames: inputs.map((_v, i) => `X${i}`),
        inputTypes: new Array(inputs.length).fill(0 /* unpacked */)
      };
      const output = inferenceHandler.run(
        { ...sumProgramMetadata, get: () => createSumProgramInfo(inferenceHandler, inputs, sumProgramMetadata) },
        inputs
      );
      return [output];
    };
    createSumProgramInfo = (inferenceHandler, inputs, sumProgramMetadata) => {
      const glsl = getGlsl(inferenceHandler.session.backend.glContext.version);
      const outputShape = inputs[0].dims.slice();
      const sumLine = inputs.map((_v, i) => `${glsl.texture2D}(X${i},TexCoords)`).join(" + ");
      const shaderSource = `
      void main() {
        vec4 result = ${sumLine};
        ${glsl.output} = result;
      }
    `;
      return {
        ...sumProgramMetadata,
        output: { dims: outputShape, type: inputs[0].type, textureType: 0 /* unpacked */ },
        hasMain: true,
        shaderSource
      };
    };
    validateInputs23 = (inputs) => {
      if (!inputs || inputs.length === 0) {
        throw new Error("Sum requires inputs.");
      }
      const length = inputs[0].dims.length;
      for (let i = 1; i < inputs.length; i++) {
        if (length !== inputs[i].dims.length) {
          throw new Error("Input shapes are mismatched.");
        }
        for (let j = 0; j < length; j++) {
          if (inputs[0].dims[j] !== inputs[i].dims[j]) {
            throw new Error("Input shapes are not matched.");
          }
        }
      }
      if (inputs[0].type !== "float32" && inputs[0].type !== "float64") {
        throw new Error("Invalid input type.");
      }
      for (let i = 1; i < inputs.length; i++) {
        if (inputs[0].type !== inputs[i].type) {
          throw new Error("Input types are not matched.");
        }
      }
    };
  }
});

// web/lib/onnxjs/backends/webgl/ops/tile.ts
var tile, createTileProgramInfo, validateInputs24;
var init_tile = __esm({
  "web/lib/onnxjs/backends/webgl/ops/tile.ts"() {
    "use strict";
    init_operators();
    init_types();
    tile = (inferenceHandler, inputs) => {
      validateInputs24(inputs);
      const tileProgramMetadata = {
        name: "Tile",
        inputNames: ["A"],
        inputTypes: [0 /* unpacked */]
      };
      const output = inferenceHandler.run(
        { ...tileProgramMetadata, get: () => createTileProgramInfo(inferenceHandler, inputs, tileProgramMetadata) },
        inputs
      );
      return [output];
    };
    createTileProgramInfo = (_handler, inputs, tileProgramMetadata) => {
      const inputShape = inputs[0].dims.slice();
      const outputShape = new Array(inputShape.length);
      const tileOps = [];
      for (let i = 0; i < inputShape.length; i++) {
        outputShape[i] = inputShape[i] * inputs[1].numberData[i];
        tileOps.push(`inputIdx[${i}] = int(mod(float(outputIdx[${i}]), ${inputShape[i]}.));`);
      }
      const rank = outputShape.length;
      const shaderSource = `
      float process(int outputIdx[${rank}]) {
        int inputIdx[${rank}];
        ${tileOps.join("\n")}
        return _A(inputIdx);
      }
    `;
      return {
        ...tileProgramMetadata,
        output: { dims: outputShape, type: inputs[0].type, textureType: 0 /* unpacked */ },
        shaderSource
      };
    };
    validateInputs24 = (inputs) => {
      if (!inputs || inputs.length !== 2) {
        throw new Error("Tile requires 2 input.");
      }
      if (inputs[1].dims.length !== 1) {
        throw new Error("The second input shape must 1 dimension.");
      }
      if (inputs[1].dims[0] !== inputs[0].dims.length) {
        throw new Error("Invalid input shape.");
      }
      if (NUMBER_TYPES.indexOf(inputs[0].type) === -1) {
        throw new Error("Invalid input type.");
      }
      if (inputs[1].type !== "int32" && inputs[1].type !== "int16") {
        throw new Error("Invalid repeat type.");
      }
    };
  }
});

// web/lib/onnxjs/backends/webgl/ops/unsqueeze.ts
var unsqueeze, unsqueezeV13, parseUnsqueezeAttributes, validateInputs25, validateInputsV132;
var init_unsqueeze = __esm({
  "web/lib/onnxjs/backends/webgl/ops/unsqueeze.ts"() {
    "use strict";
    init_util();
    unsqueeze = (inferenceHandler, inputs, axes) => {
      validateInputs25(inputs);
      const outputShape = ShapeUtil.unsqueezeShape(inputs[0].dims, axes);
      const output = inferenceHandler.reshapeUnpacked(inputs[0], outputShape);
      return [output];
    };
    unsqueezeV13 = (inferenceHandler, inputs) => {
      validateInputsV132(inputs);
      return unsqueeze(inferenceHandler, [inputs[0]], Array.from(inputs[1].integerData));
    };
    parseUnsqueezeAttributes = (node) => node.attributes.getInts("axes");
    validateInputs25 = (inputs) => {
      if (!inputs || inputs.length !== 1) {
        throw new Error("Unsqueeze requires 1 input.");
      }
      if (inputs[0].type === "string") {
        throw new Error("invalid input tensor types.");
      }
    };
    validateInputsV132 = (inputs) => {
      if (!inputs || inputs.length !== 2) {
        throw new Error("Unsqueeze requires 2 inputs.");
      }
      if (inputs[1].type !== "int32") {
        throw new Error("Invalid input type.");
      }
    };
  }
});

// web/lib/onnxjs/backends/webgl/op-resolve-rules.ts
var WEBGL_OP_RESOLVE_RULES;
var init_op_resolve_rules = __esm({
  "web/lib/onnxjs/backends/webgl/op-resolve-rules.ts"() {
    "use strict";
    init_batch_normalization();
    init_binary_op();
    init_cast();
    init_concat();
    init_conv();
    init_conv_transpose();
    init_depth_to_space();
    init_flatten();
    init_gather();
    init_gemm();
    init_image_scaler();
    init_instance_normalization();
    init_lrn();
    init_matmul();
    init_pad();
    init_pool();
    init_reduce();
    init_reshape();
    init_resize_packed();
    init_shape();
    init_slice();
    init_softmax();
    init_split();
    init_squeeze();
    init_sum();
    init_tile();
    init_transpose();
    init_unary_op();
    init_unsqueeze();
    init_upsample();
    WEBGL_OP_RESOLVE_RULES = [
      ["Abs", "", "6+", abs],
      ["Acos", "", "7+", acos],
      ["Add", "", "7+", add2],
      ["And", "", "7+", and2],
      ["Asin", "", "7+", asin],
      ["Atan", "", "7+", atan],
      // TODO: support new attributes for AveragePool-10
      ["AveragePool", "", "7+", averagePool, parseAveragePoolAttributes],
      ["BatchNormalization", "", "7+", batchNormalization, parseBatchNormalizationAttributes],
      ["Cast", "", "6+", cast, parseCastAttributes],
      ["Ceil", "", "6+", ceil],
      ["Clip", "", "6-10", clip, parseClipAttributes],
      ["Clip", "", "11+", clipV11],
      ["Concat", "", "4+", concat, parseConcatAttributes],
      ["Conv", "", "1+", conv, parseConvAttributes],
      ["ConvTranspose", "", "1+", convTranspose, parseConvTransposeAttributes],
      ["Cos", "", "7+", cos],
      ["Div", "", "7+", div],
      ["Dropout", "", "7+", identity],
      ["DepthToSpace", "", "1+", depthToSpace, parseDepthToSpaceAttributes],
      ["Equal", "", "7+", equal],
      ["Elu", "", "6+", elu, parseEluAttributes],
      ["Exp", "", "6+", exp],
      ["Flatten", "", "1+", flatten, parseFlattenAttributes],
      ["Floor", "", "6+", floor],
      ["FusedConv", "com.microsoft", "1+", conv, parseConvAttributes],
      ["Gather", "", "1+", gather, parseGatherAttributes],
      ["Gemm", "", "7-10", gemm, parseGemmAttributesV7],
      ["Gemm", "", "11+", gemm, parseGemmAttributesV11],
      ["GlobalAveragePool", "", "1+", globalAveragePool, parseGlobalAveragePoolAttributes],
      ["GlobalMaxPool", "", "1+", globalMaxPool],
      ["Greater", "", "7+", greater],
      ["Identity", "", "1+", identity],
      ["ImageScaler", "", "1+", imageScaler, parseImageScalerAttributes],
      ["InstanceNormalization", "", "6+", instanceNormalization, parseInstanceNormalizationAttributes],
      ["LeakyRelu", "", "6+", leakyRelu, parseLeakyReluAttributes],
      ["Less", "", "7+", less],
      ["LRN", "", "1+", lrn, parseLrnAttributes],
      ["Log", "", "6+", log2],
      ["MatMul", "", "1+", matMul, parseMatMulAttributes],
      // TODO: support new attributes for MaxPool-8 and MaxPool-10
      ["MaxPool", "", "1+", maxPool, parseMaxPoolAttributes],
      ["Mul", "", "7+", mul],
      ["Neg", "", "6+", neg],
      ["Not", "", "1+", not2],
      ["Or", "", "7+", or2],
      ["Pad", "", "2-10", padV2, parsePadAttributesV2],
      ["Pad", "", "11+", padV11, parsePadAttributesV11],
      ["Pow", "", "7+", pow],
      ["PRelu", "", "7+", pRelu],
      ["ReduceLogSum", "", "1+", reduceLogSum, parseReduceAttributes],
      ["ReduceMax", "", "1+", reduceMax, parseReduceAttributes],
      ["ReduceMean", "", "1+", reduceMean, parseReduceAttributes],
      ["ReduceMin", "", "1+", reduceMin, parseReduceAttributes],
      ["ReduceProd", "", "1+", reduceProd, parseReduceAttributes],
      ["ReduceSum", "", "1-12", reduceSum, parseReduceAttributes],
      ["ReduceSumSquare", "", "1+", reduceLogSumSquare, parseReduceAttributes],
      ["Relu", "", "6+", relu],
      ["Reshape", "", "5+", reshape],
      ["Resize", "", "10", resize, parseResizeAttributesV10],
      ["Resize", "", "11+", resize, parseResizeAttributesV11],
      ["Shape", "", "1+", shape],
      ["Sigmoid", "", "6+", sigmoid],
      ["Sin", "", "7+", sin],
      ["Slice", "", "10+", sliceV10],
      // TODO: support 'steps' for Slice-10
      ["Slice", "", "1-9", slice, parseSliceAttributes],
      // The "semantic" meaning of axis has changed in opset-13.
      ["Softmax", "", "1-12", softmax, parseSoftmaxAttributes],
      ["Softmax", "", "13+", softmaxV13, parseSoftmaxAttributesV13],
      // 'Split' operator has an optional attribute 'split'
      // this attribute determines how the specified axis of input data is split.
      // When the attribute is missing, we need the count of number of outputs
      // so that we can determine the 'split' attribute from the runtime input to the Operator
      ["Split", "", "2-12", split, parseSplitAttributes],
      ["Sqrt", "", "6+", sqrt],
      ["Squeeze", "", "1-12", squeeze, parseSqueezeAttributes],
      ["Squeeze", "", "13+", squeezeV13],
      ["Sub", "", "7+", sub],
      ["Sum", "", "6+", sum],
      ["Tan", "", "7+", tan],
      ["Tanh", "", "6+", tanh],
      ["Tile", "", "6+", tile],
      ["Transpose", "", "1+", transpose, parseTransposeAttributes],
      ["Upsample", "", "7-8", upsample, parseUpsampleAttributesV7],
      ["Upsample", "", "9", upsample, parseUpsampleAttributesV9],
      ["Unsqueeze", "", "1-12", unsqueeze, parseUnsqueezeAttributes],
      ["Unsqueeze", "", "13+", unsqueezeV13],
      ["Xor", "", "7+", xor2]
    ];
  }
});

// web/lib/onnxjs/backends/webgl/glsl-function-inliner.ts
function replaceInlines(script) {
  const inlineDefs = {};
  let match;
  while ((match = INLINE_FUNC_DEF_REGEX.exec(script)) !== null) {
    const params = match[3].split(",").map((s) => {
      const tokens = s.trim().split(" ");
      if (tokens && tokens.length === 2) {
        return { type: tokens[0], name: tokens[1] };
      }
      return null;
    }).filter((v) => v !== null);
    inlineDefs[match[2]] = { params, body: match[4] };
  }
  for (const name2 in inlineDefs) {
    const regexString = FUNC_CALL_REGEX.replace("__FUNC__", name2);
    const regex = new RegExp(regexString, "gm");
    while ((match = regex.exec(script)) !== null) {
      const type = match[1];
      const variable = match[2];
      const params = match[3].split(",");
      const declLine = type ? `${type} ${variable};` : "";
      let newBody = inlineDefs[name2].body;
      let paramRedecLine = "";
      inlineDefs[name2].params.forEach((v, i) => {
        if (v) {
          paramRedecLine += `${v.type} ${v.name} = ${params[i]};
`;
        }
      });
      newBody = `${paramRedecLine}
 ${newBody}`;
      newBody = newBody.replace("return", `${variable} = `);
      const replacement = `
      ${declLine}
      {
        ${newBody}
      }
      `;
      script = script.replace(match[0], replacement);
    }
  }
  script = script.replace(INLINE_FUNC_DEF_REGEX, "");
  return script;
}
var INLINE_FUNC_DEF_REGEX, FUNC_CALL_REGEX;
var init_glsl_function_inliner = __esm({
  "web/lib/onnxjs/backends/webgl/glsl-function-inliner.ts"() {
    "use strict";
    INLINE_FUNC_DEF_REGEX = /@inline[\s\n\r]+(\w+)[\s\n\r]+([0-9a-zA-Z_]+)\s*\(([^)]*)\)\s*{(([^}]|[\n\r])*)}/gm;
    FUNC_CALL_REGEX = "(\\w+)?\\s+([_0-9a-zA-Z]+)\\s+=\\s+__FUNC__\\((.*)\\)\\s*;";
  }
});

// web/lib/onnxjs/backends/webgl/texture-layout-strategy.ts
function squeezeShape(shape2, axis) {
  const newShape = [];
  const keptDims = [];
  const isEmptyArray = axis != null && Array.isArray(axis) && axis.length === 0;
  const axes = axis == null || isEmptyArray ? null : parseAxisParam(axis, shape2).sort();
  let j = 0;
  for (let i = 0; i < shape2.length; ++i) {
    if (axes != null) {
      if (axes[j] === i && shape2[i] !== 1) {
        throw new Error(`Can't squeeze axis ${i} since its dim '${shape2[i]}' is not 1`);
      }
      if ((axes[j] == null || axes[j] > i) && shape2[i] === 1) {
        newShape.push(shape2[i]);
        keptDims.push(i);
      }
      if (axes[j] <= i) {
        j++;
      }
    }
    if (shape2[i] !== 1) {
      newShape.push(shape2[i]);
      keptDims.push(i);
    }
  }
  return { newShape, keptDims };
}
function parseAxisParam(axis, shape2) {
  const rank = shape2.length;
  axis = axis == null ? shape2.map((_s, i) => i) : [].concat(axis);
  assert(
    axis.every((ax) => ax >= -rank && ax < rank),
    () => `All values in axis param must be in range [-${rank}, ${rank}) but got axis ${axis}`
  );
  assert(
    axis.every(isInt),
    () => `All values in axis param must be integers but got axis ${axis}`
  );
  return axis.map((a) => a < 0 ? rank + a : a);
}
function isInt(a) {
  return a % 1 === 0;
}
function sizeFromShape(shape2) {
  if (shape2.length === 0) {
    return 1;
  }
  let size = shape2[0];
  for (let i = 1; i < shape2.length; i++) {
    size *= shape2[i];
  }
  return size;
}
function sizeToSquarishShape(size) {
  const width = Math.ceil(Math.sqrt(size));
  return [width, Math.ceil(size / width)];
}
var PreferLogicalStrategy;
var init_texture_layout_strategy = __esm({
  "web/lib/onnxjs/backends/webgl/texture-layout-strategy.ts"() {
    "use strict";
    init_instrument();
    init_util();
    PreferLogicalStrategy = class {
      constructor(maxTextureSize) {
        this.maxTextureSize = maxTextureSize;
      }
      computeTextureWH(shape2, prefs) {
        const wh = this.computeTexture(shape2, prefs);
        if (prefs && prefs.isPacked) {
          wh[0] /= 2;
          wh[1] /= 2;
        }
        if (prefs && prefs.reverseWH) {
          return [wh[1], wh[0]];
        }
        return wh;
      }
      computeTexture(shape2, prefs) {
        const isPacked = prefs && prefs.isPacked;
        if (shape2.length === 0) {
          return isPacked ? [2, 2] : [1, 1];
        }
        let maxTextureSize = this.maxTextureSize;
        if (prefs && prefs.breakAxis !== void 0) {
          const wsize = prefs.breakAxis >= shape2.length ? 1 : shape2.slice(prefs.breakAxis).reduce((a, b) => a * b);
          const hsize = prefs.breakAxis <= 0 ? 1 : shape2.slice(0, prefs.breakAxis).reduce((a, b) => a * b);
          if (wsize > maxTextureSize || hsize > maxTextureSize) {
            Logger.verbose(
              "TextureLayout",
              `Given width/height preferences were unattainable: shape:${shape2}, breakAxis:${prefs.breakAxis}`
            );
          } else {
            return [wsize, hsize];
          }
        }
        let logShape = shape2.slice(0);
        if (isPacked) {
          maxTextureSize = maxTextureSize * 2;
          logShape = logShape.map(
            (_d, i) => i >= logShape.length - 2 ? logShape[i] % 2 === 0 ? logShape[i] : logShape[i] + 1 : logShape[i]
          );
          if (logShape.length === 1) {
            logShape = [2, logShape[0]];
          }
        }
        if (logShape.length !== 2) {
          const squeezeResult = squeezeShape(logShape);
          logShape = squeezeResult.newShape;
        }
        const size = sizeFromShape(logShape);
        if (logShape.length <= 1 && size <= maxTextureSize) {
          return [1, size];
        } else if (logShape.length === 2 && logShape[0] <= maxTextureSize && logShape[1] <= maxTextureSize) {
          return logShape;
        } else if (logShape.length === 3 && logShape[0] * logShape[1] <= maxTextureSize && logShape[2] <= maxTextureSize) {
          return [logShape[0] * logShape[1], logShape[2]];
        } else if (logShape.length === 3 && logShape[0] <= maxTextureSize && logShape[1] * logShape[2] <= maxTextureSize) {
          return [logShape[0], logShape[1] * logShape[2]];
        } else if (logShape.length === 4 && logShape[0] * logShape[1] * logShape[2] <= maxTextureSize && logShape[3] <= maxTextureSize) {
          return [logShape[0] * logShape[1] * logShape[2], logShape[3]];
        } else if (logShape.length === 4 && logShape[0] <= maxTextureSize && logShape[1] * logShape[2] * logShape[3] <= maxTextureSize) {
          return [logShape[0], logShape[1] * logShape[2] * logShape[3]];
        } else {
          if (isPacked) {
            return sizeToSquarishShape(size / 4).map((d) => d * 2);
          }
          return sizeToSquarishShape(size);
        }
      }
    };
  }
});

// web/lib/onnxjs/backends/webgl/glsl-coordinate-lib.ts
var CoordsGlslLib;
var init_glsl_coordinate_lib = __esm({
  "web/lib/onnxjs/backends/webgl/glsl-coordinate-lib.ts"() {
    "use strict";
    init_util();
    init_glsl_definitions();
    init_glsl_source();
    init_texture_layout_strategy();
    init_utils();
    CoordsGlslLib = class extends GlslLib {
      constructor(context) {
        super(context);
      }
      getFunctions() {
        return {
          ...this.offsetToCoords(),
          ...this.coordsToOffset(),
          ...this.toVec(),
          ...this.valueFrom(),
          // TODO return these only when packing is enabled.
          ...this.getCommonUtilFuncs(),
          ...this.getInputsSamplingSnippets(),
          ...this.getOutputSamplingSnippet()
        };
      }
      getCustomTypes() {
        return {};
      }
      /**
       * Produces a function that can map from
       * 2D normalzied coordinates (s,t) to a flat offset
       */
      offsetToCoords() {
        const funcName = "offsetToCoords";
        return {
          offsetToCoords: new GlslLibRoutine(`
      vec2 ${funcName}(int offset, int width, int height) {
        int t = offset / width;
        int s = offset - t*width;
        vec2 coords = (vec2(s,t) + vec2(0.5,0.5)) / vec2(width, height);
        return coords;
      }
      `)
        };
      }
      /**
       * Produces a function that can map from
       * 2D normalzied coordinates (s,t) to a flat offset
       */
      coordsToOffset() {
        const funcName = "coordsToOffset";
        return {
          coordsToOffset: new GlslLibRoutine(`
      int ${funcName}(vec2 coords, int width, int height) {
        float s = coords.s * float(width);
        float t = coords.t * float(height);
        int offset = int(t) * width + int(s);
        return offset;
      }
      `)
        };
      }
      /**
       * Generates code for output sampler.
       */
      getOutputSamplingSnippet() {
        const outputLayout = this.context.outputTextureLayout;
        if (outputLayout.isPacked) {
          return this.getPackedOutputSamplingSnippet(outputLayout);
        } else {
          return this.getUnpackedOutputSamplingSnippet(outputLayout);
        }
      }
      /**
       * Generates code for packed output sampler.
       */
      getPackedOutputSamplingSnippet(outputLayout) {
        const outShape = outputLayout.unpackedShape;
        const outTexShape = [outputLayout.width, outputLayout.height];
        const result = {};
        const funcName = "getOutputCoords";
        switch (outShape.length) {
          case 0:
            result[funcName] = this.getOutputScalarCoords();
            break;
          case 1:
            result[funcName] = this.getOutputPacked1DCoords(outShape, outTexShape);
            break;
          case 2:
            result[funcName] = this.getOutputPacked2DCoords(outShape, outTexShape);
            break;
          case 3:
            result[funcName] = this.getOutputPacked3DCoords(outShape, outTexShape);
            break;
          default:
            result[funcName] = this.getOutputPackedNDCoords(outShape, outTexShape);
        }
        const glsl = getGlsl(this.context.glContext.version);
        const floatTextureSetRGBASource = `
      void setOutput(vec4 val) {
        ${glsl.output} = val;
      }
    `;
        const floatTextureSetRGBAFuncName = "floatTextureSetRGBA";
        result[floatTextureSetRGBAFuncName] = new GlslLibRoutine(floatTextureSetRGBASource);
        return result;
      }
      /**
       * Generates code for unpacked output sampler.
       */
      getUnpackedOutputSamplingSnippet(outputLayout) {
        const outShape = outputLayout.unpackedShape;
        const outTexShape = [outputLayout.width, outputLayout.height];
        const result = {};
        const funcName = "getOutputCoords";
        switch (outShape.length) {
          case 0:
            result[funcName] = this.getOutputScalarCoords();
            break;
          case 1:
            result[funcName] = this.getOutputUnpacked1DCoords(outShape, outTexShape);
            break;
          case 2:
            result[funcName] = this.getOutputUnpacked2DCoords(outShape, outTexShape);
            break;
          case 3:
            result[funcName] = this.getOutputUnpacked3DCoords(outShape, outTexShape);
            break;
          case 4:
            result[funcName] = this.getOutputUnpacked4DCoords(
              outShape,
              outTexShape
            );
            break;
          case 5:
            result[funcName] = this.getOutputUnpacked5DCoords(
              outShape,
              outTexShape
            );
            break;
          case 6:
            result[funcName] = this.getOutputUnpacked6DCoords(
              outShape,
              outTexShape
            );
            break;
          default:
            throw new Error(`Unsupported output dimensionality: ${outShape.length}`);
        }
        const glsl = getGlsl(this.context.glContext.version);
        const floatTextureSetRSource = `
        void setOutput(float val) {
          ${glsl.output} = vec4(val, 0, 0, 0);
        }
    `;
        const floatTextureSetRFuncName = "floatTextureSetR";
        result[floatTextureSetRFuncName] = new GlslLibRoutine(floatTextureSetRSource);
        return result;
      }
      /**
       * Scalar output coordinates.
       */
      getOutputScalarCoords() {
        return new GlslLibRoutine(`
      int getOutputCoords() {
        return 0;
      }
    `);
      }
      /**
       * 1D packed output coordinates.
       */
      getOutputPacked1DCoords(_shape, texShape) {
        const packedTexShape = texShape;
        let source = "";
        if (packedTexShape[0] === 1) {
          source = `
          int getOutputCoords() {
            return 2 * int(TexCoords.y * ${packedTexShape[1]}.0);
          }
        `;
          return new GlslLibRoutine(source);
        }
        if (packedTexShape[1] === 1) {
          source = `
          int getOutputCoords() {
            return 2 * int(TexCoords.x * ${packedTexShape[0]}.0);
          }
        `;
          return new GlslLibRoutine(source);
        }
        source = `
        int getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                 vec2(${packedTexShape[0]}, ${packedTexShape[1]}));
          return 2 * (resTexRC.y * ${packedTexShape[0]} + resTexRC.x);
        }
      `;
        return new GlslLibRoutine(source);
      }
      /**
       * 2D packed output coordinates.
       */
      getOutputPacked2DCoords(shape2, texShape) {
        let source = "";
        if (ArrayUtil.arraysEqual(shape2, texShape)) {
          source = `
        ivec2 getOutputCoords() {
          return 2 * ivec2(TexCoords.xy * vec2(${texShape[0]}, ${texShape[1]}));
        }
      `;
          return new GlslLibRoutine(source);
        }
        const packedTexShape = texShape;
        const texelsInLogicalRow = Math.ceil(shape2[1] / 2);
        source = `
        ivec2 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${packedTexShape[0]}, ${packedTexShape[1]}));

          int index = resTexRC.y * ${packedTexShape[0]} + resTexRC.x;

          // reverse r and c order for packed texture
          int r = imod(index, ${texelsInLogicalRow}) * 2;
          int c = 2 * (index / ${texelsInLogicalRow});

          return ivec2(r, c);
        }
      `;
        return new GlslLibRoutine(source);
      }
      /**
       * 3D packed output coordinates.
       */
      getOutputPacked3DCoords(shape2, texShape) {
        const packedTexShape = [texShape[0], texShape[1]];
        const texelsInLogicalRow = Math.ceil(shape2[2] / 2);
        const texelsInBatch = texelsInLogicalRow * Math.ceil(shape2[1] / 2);
        const source = `
        ivec3 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${packedTexShape[0]}, ${packedTexShape[1]}));
          int index = resTexRC.y * ${packedTexShape[0]} + resTexRC.x;

          int b = index / ${texelsInBatch};
          index -= b * ${texelsInBatch};

          // reverse r and c order for packed texture
          int r = imod(index, ${texelsInLogicalRow}) * 2;
          int c = 2 * (index / ${texelsInLogicalRow});

          return ivec3(b, r, c);
        }
      `;
        return new GlslLibRoutine(source);
      }
      /**
       * ND packed output coordinates.
       */
      getOutputPackedNDCoords(shape2, texShape) {
        const packedTexShape = [texShape[0], texShape[1]];
        const texelsInLogicalRow = Math.ceil(shape2[shape2.length - 1] / 2);
        const texelsInBatch = texelsInLogicalRow * Math.ceil(shape2[shape2.length - 2] / 2);
        let texelsInBatchN = texelsInBatch;
        let batches = "";
        let coords = "b, r, c";
        for (let b = 2; b < shape2.length - 1; b++) {
          texelsInBatchN *= shape2[shape2.length - b - 1];
          batches = `
      int b${b} = index / ${texelsInBatchN};
      index -= b${b} * ${texelsInBatchN};
    ` + batches;
          coords = `b${b}, ` + coords;
        }
        const source = `
      ivec${shape2.length} getOutputCoords() {
        ivec2 resTexRC = ivec2(TexCoords.xy *
                              vec2(${packedTexShape[0]}, ${packedTexShape[1]}));
        int index = resTexRC.y * ${packedTexShape[0]} + resTexRC.x;

        ${batches}

        int b = index / ${texelsInBatch};
        index -= b * ${texelsInBatch};

        // reverse r and c order for packed texture
        int r = imod(index, ${texelsInLogicalRow}) * 2;
        int c = 2 * (index / ${texelsInLogicalRow});

        return ivec${shape2.length}(${coords});
      }
    `;
        return new GlslLibRoutine(source);
      }
      /**
       * Unpacked 1D output coordinates.
       */
      getOutputUnpacked1DCoords(_shape, texShape) {
        const source = `
        int getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${texShape[0]}, ${texShape[1]}));
          return resTexRC.y * ${texShape[0]} + resTexRC.x;
        }
      `;
        return new GlslLibRoutine(source);
      }
      /**
       * Unpacked 2D output coordinates.
       */
      getOutputUnpacked2DCoords(shape2, texShape) {
        const source = `
        ivec2 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${texShape[0]}, ${texShape[1]}));
          int index = resTexRC.y * ${texShape[0]} + resTexRC.x;
          int r = index / ${shape2[1]};
          int c = index - r * ${shape2[1]};
          return ivec2(r, c);
        }
      `;
        return new GlslLibRoutine(source);
      }
      /**
       * Unpacked 3D output coordinates.
       */
      getOutputUnpacked3DCoords(shape2, texShape) {
        let source = "";
        const rank = shape2.length;
        let strides = null;
        if (rank < 2) {
          strides = [];
        }
        strides = new Array(rank - 1);
        strides[rank - 2] = shape2[rank - 1];
        for (let i = rank - 3; i >= 0; --i) {
          strides[i] = strides[i + 1] * shape2[i + 1];
        }
        const coordsToCompute = ["r", "c", "d"];
        const coordsFromIndexSnippet = strides.map((stride, i) => {
          const line1 = `int ${coordsToCompute[i]} = index / ${stride}`;
          const line2 = i === strides.length - 1 ? `int ${coordsToCompute[i + 1]} = index - ${coordsToCompute[i]} * ${stride}` : `index -= ${coordsToCompute[i]} * ${stride}`;
          return `${line1}; ${line2};`;
        }).join("");
        source = `
        ivec3 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${texShape[0]}, ${texShape[1]}));
          int index = resTexRC.y * ${texShape[0]} + resTexRC.x;
          ${coordsFromIndexSnippet}
          return ivec3(r, c, d);
        }
      `;
        return new GlslLibRoutine(source);
      }
      /**
       * Unpacked 4D output coordinates.
       */
      getOutputUnpacked4DCoords(shape2, texShape) {
        let source = "";
        const rank = shape2.length;
        let strides = null;
        if (rank < 2) {
          strides = [];
        }
        strides = new Array(rank - 1);
        strides[rank - 2] = shape2[rank - 1];
        for (let i = rank - 3; i >= 0; --i) {
          strides[i] = strides[i + 1] * shape2[i + 1];
        }
        const coordsToCompute = ["r", "c", "d", "d2"];
        const coordsFromIndexSnippet = strides.map((stride, i) => {
          const line1 = `int ${coordsToCompute[i]} = index / ${stride}`;
          const line2 = i === strides.length - 1 ? `int ${coordsToCompute[i + 1]} = index - ${coordsToCompute[i]} * ${stride}` : `index -= ${coordsToCompute[i]} * ${stride}`;
          return `${line1}; ${line2};`;
        }).join("");
        source = `
      ivec4 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${texShape[0]}, ${texShape[1]}));
          int index = resTexRC.y * ${texShape[0]} + resTexRC.x;
          ${coordsFromIndexSnippet}
          return ivec4(r, c, d, d2);
        }
      `;
        return new GlslLibRoutine(source);
      }
      /**
       * Unpacked 5D output coordinates.
       */
      getOutputUnpacked5DCoords(shape2, texShape) {
        let source = "";
        const rank = shape2.length;
        let strides = null;
        if (rank < 2) {
          strides = [];
        }
        strides = new Array(rank - 1);
        strides[rank - 2] = shape2[rank - 1];
        for (let i = rank - 3; i >= 0; --i) {
          strides[i] = strides[i + 1] * shape2[i + 1];
        }
        const coordsToCompute = ["r", "c", "d", "d2", "d3"];
        const coordsFromIndexSnippet = strides.map((stride, i) => {
          const line1 = `int ${coordsToCompute[i]} = index / ${stride}`;
          const line2 = i === strides.length - 1 ? `int ${coordsToCompute[i + 1]} = index - ${coordsToCompute[i]} * ${stride}` : `index -= ${coordsToCompute[i]} * ${stride}`;
          return `${line1}; ${line2};`;
        }).join("");
        source = `
      ivec5 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${texShape[0]}, ${texShape[1]}));
          int index = resTexRC.y * ${texShape[0]} + resTexRC.x;
          ${coordsFromIndexSnippet}
          return ivec5(r, c, d, d2, d3);
        }
      `;
        return new GlslLibRoutine(source);
      }
      /**
       * Unpacked 6D output coordinates.
       */
      getOutputUnpacked6DCoords(shape2, texShape) {
        let source = "";
        const rank = shape2.length;
        let strides = null;
        if (rank < 2) {
          strides = [];
        }
        strides = new Array(rank - 1);
        strides[rank - 2] = shape2[rank - 1];
        for (let i = rank - 3; i >= 0; --i) {
          strides[i] = strides[i + 1] * shape2[i + 1];
        }
        const coordsToCompute = ["r", "c", "d", "d2", "d3", "d4"];
        const coordsFromIndexSnippet = strides.map((stride, i) => {
          const line1 = `int ${coordsToCompute[i]} = index / ${stride}`;
          const line2 = i === strides.length - 1 ? `int ${coordsToCompute[i + 1]} = index - ${coordsToCompute[i]} * ${stride}` : `index -= ${coordsToCompute[i]} * ${stride}`;
          return `${line1}; ${line2};`;
        }).join("");
        source = `
     ivec6 getOutputCoords() {
         ivec2 resTexRC = ivec2(TexCoords.xy *
                               vec2(${texShape[0]}, ${texShape[1]}));
         int index = resTexRC.y * ${texShape[0]} + resTexRC.x;
         ${coordsFromIndexSnippet}
         return ivec6(r, c, d, d2, d3, d4);
       }
     `;
        return new GlslLibRoutine(source);
      }
      /**
       * Generates code for common UV coords computation utility functions.
       */
      getCommonUtilFuncs() {
        const result = {};
        let funcName = "uvFromFlat";
        result[funcName] = new GlslLibRoutine(`
    vec2 uvFromFlat(int texNumR, int texNumC, int index) {
      int texC = index / texNumR;
      int texR = index - texC * texNumR;
      // TODO: swap texR, texC order in following function so row is corresponding to u and column is corresponding to
      //       v.
      return (vec2(texR, texC) + halfCR) / vec2(texNumR, texNumC);
    }
    `);
        funcName = "packedUVfrom1D";
        result[funcName] = new GlslLibRoutine(`
      vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
        int texelIndex = index / 2;
        int texR = texelIndex / texNumC;
        int texC = texelIndex - texR * texNumC;
        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
      }
      `);
        funcName = "packedUVfrom2D";
        result[funcName] = new GlslLibRoutine(`
      vec2 packedUVfrom2D(int texNumR, int texNumC, int texelsInLogicalRow, int row, int col) {
        int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
        int texR = texelIndex / texNumC;
        int texC = texelIndex - texR * texNumC;
        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
      }
      `);
        funcName = "packedUVfrom3D";
        result[funcName] = new GlslLibRoutine(`
      vec2 packedUVfrom3D(int texNumR, int texNumC,
          int texelsInBatch, int texelsInLogicalRow, int b,
          int row, int col) {
        int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
        int texR = index / texNumC;
        int texC = index - texR * texNumC;
        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
      }
      `);
        funcName = "sampleTexture";
        const glsl = getGlsl(this.context.glContext.version);
        result[funcName] = new GlslLibRoutine(`
        float sampleTexture(sampler2D textureSampler, vec2 uv) {
            return ${glsl.texture2D}(textureSampler, uv).r;
        }`);
        return result;
      }
      /**
       * Constructing snippets for inputs
       */
      getInputsSamplingSnippets() {
        const result = {};
        const outputLayout = this.context.outputTextureLayout;
        this.context.programInfo.inputNames.forEach((samplerName, i) => {
          const inputLayout = this.context.inputTextureLayouts[i];
          const funcName = generateShaderFuncNameFromInputSamplerName(samplerName);
          if (inputLayout.isPacked) {
            result[funcName] = this.getPackedSamplerFromInput(funcName, samplerName, inputLayout);
          } else {
            result[funcName] = this.getUnpackedSamplerFromInput(funcName, samplerName, inputLayout);
          }
          const outCoordFuncName = generateShaderFuncNameFromInputSamplerNameAtOutCoords(samplerName);
          if (inputLayout.unpackedShape.length <= outputLayout.unpackedShape.length) {
            if (inputLayout.isPacked) {
              result[outCoordFuncName] = this.getPackedSamplerAtOutputCoords(outCoordFuncName, inputLayout, outputLayout, samplerName);
            } else {
              result[outCoordFuncName] = this.getUnpackedSamplerAtOutputCoords(outCoordFuncName, inputLayout, outputLayout, samplerName);
            }
          }
        });
        return result;
      }
      /**
       * Constructing snippets for output coordinates of samplers
       */
      getPackedSamplerAtOutputCoords(funcName, inputLayout, outputLayout, name2) {
        const inShape = inputLayout.unpackedShape;
        const outShape = outputLayout.unpackedShape;
        const texName = name2;
        const texFuncSnippet = generateShaderFuncNameFromInputSamplerName(texName);
        const inRank = inShape.length;
        const outRank = outShape.length;
        const broadcastDims = BroadcastUtil.getBroadcastDims(inShape, outShape);
        const type = getCoordsDataType(outRank);
        const rankDiff = outRank - inRank;
        let coordsSnippet;
        const fields = getGlChannels();
        if (inRank === 0) {
          coordsSnippet = "";
        } else if (outRank < 2 && broadcastDims.length >= 1) {
          coordsSnippet = "coords = 0;";
        } else {
          coordsSnippet = broadcastDims.map((d) => `coords.${fields[d + rankDiff]} = 0;`).join("\n");
        }
        let unpackedCoordsSnippet = "";
        if (outRank < 2 && inRank > 0) {
          unpackedCoordsSnippet = "coords";
        } else {
          unpackedCoordsSnippet = inShape.map((_s, i) => `coords.${fields[i + rankDiff]}`).join(", ");
        }
        let output = "return outputValue;";
        const inSize = ShapeUtil.size(inShape);
        const isInputScalar = inSize === 1;
        const outSize = ShapeUtil.size(outShape);
        const isOutputScalar = outSize === 1;
        if (inRank === 1 && !isInputScalar && !isOutputScalar) {
          output = `
        return vec4(outputValue.xy, outputValue.xy);
      `;
        } else if (isInputScalar && !isOutputScalar) {
          if (outRank === 1) {
            output = `
          return vec4(outputValue.x, outputValue.x, 0., 0.);
        `;
          } else {
            output = `
          return vec4(outputValue.x);
        `;
          }
        } else if (broadcastDims.length) {
          const rows = inRank - 2;
          const cols = inRank - 1;
          if (broadcastDims.indexOf(rows) > -1 && broadcastDims.indexOf(cols) > -1) {
            output = "return vec4(outputValue.x);";
          } else if (broadcastDims.indexOf(rows) > -1) {
            output = "return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);";
          } else if (broadcastDims.indexOf(cols) > -1) {
            output = "return vec4(outputValue.xx, outputValue.zz);";
          }
        }
        const swapLastDimsSnippet = `
        int lastDim = coords.${fields[outRank - 1]};
        coords.${fields[outRank - 1]} = coords.${fields[outRank - 2]};
        coords.${fields[outRank - 2]} = lastDim;
      `;
        const source = `
      vec4 ${funcName}() {
        ${type} coords = getOutputCoords();
        ${swapLastDimsSnippet}
        ${coordsSnippet}
        vec4 outputValue = ${texFuncSnippet}(${unpackedCoordsSnippet});
        ${output}
      }
    `;
        return new GlslLibRoutine(source, ["coordinates.getOutputCoords"]);
      }
      /**
       * Constructing snippets for unpacked output coordinates of samplers
       */
      getUnpackedSamplerAtOutputCoords(funcName, inputLayout, outputLayout, name2) {
        const outTexShape = [outputLayout.width, outputLayout.height];
        const inTexShape = [inputLayout.width, inputLayout.height];
        const inRank = inputLayout.unpackedShape.length;
        const outRank = outputLayout.unpackedShape.length;
        const inShape = inputLayout.unpackedShape;
        const outShape = outputLayout.unpackedShape;
        const texFuncSnippet = generateShaderFuncNameFromInputSamplerName(name2);
        if (inRank === outRank && ArrayUtil.arraysEqual(inTexShape, outTexShape)) {
          const source2 = `
          float ${funcName}() {
            return sampleTexture(${name2}, TexCoords);
          }
        `;
          return new GlslLibRoutine(source2, ["coordinates.sampleTexture"]);
        }
        const type = getCoordsDataType(outRank);
        const broadcastDims = BroadcastUtil.getBroadcastDims(inShape, outShape);
        const rankDiff = outRank - inRank;
        let coordsSnippet;
        const fields = getGlChannels();
        if (inRank === 0) {
          coordsSnippet = "";
        } else if (outRank < 2 && broadcastDims.length >= 1) {
          coordsSnippet = "coords = 0;";
        } else {
          coordsSnippet = broadcastDims.map((d) => `coords.${fields[d + rankDiff]} = 0;`).join("\n");
        }
        let unpackedCoordsSnippet = "";
        if (outRank < 2 && inRank > 0) {
          unpackedCoordsSnippet = "coords";
        } else {
          unpackedCoordsSnippet = inputLayout.unpackedShape.map((_s, i) => `coords.${fields[i + rankDiff]}`).join(", ");
        }
        const source = `
        float ${funcName}() {
          ${type} coords = getOutputCoords();
          ${coordsSnippet}
          return ${texFuncSnippet}(${unpackedCoordsSnippet});
        }
      `;
        return new GlslLibRoutine(source, ["coordinates.getOutputCoords"]);
      }
      /**
       * Constructing snippets for packed operations.
       */
      getPackedSamplerFromInput(funcName, name2, inputLayout) {
        switch (inputLayout.unpackedShape.length) {
          case 0:
            return this.getPackedSamplerScalar(funcName, name2);
          case 1:
            return this.getPackedSampler1D(funcName, name2, inputLayout);
          case 2:
            return this.getPackedSampler2D(funcName, name2, inputLayout);
          case 3:
            return this.getPackedSampler3D(funcName, name2, inputLayout);
          default:
            return this.getPackedSamplerND(funcName, name2, inputLayout);
        }
      }
      /**
       * Constructing snippets for unpacked operations.
       */
      getUnpackedSamplerFromInput(funcName, name2, inputLayout) {
        const shape2 = inputLayout.unpackedShape;
        switch (shape2.length) {
          case 0:
            return this.getUnpackedSamplerScalar(funcName, name2, inputLayout);
          case 1:
            return this.getUnpackedSampler1D(funcName, name2, inputLayout);
          case 2:
            return this.getUnpackedSampler2D(funcName, name2, inputLayout);
          case 3:
            return this.getUnpackedSampler3D(funcName, name2, inputLayout);
          case 4:
            return this.getUnpackedSampler4D(funcName, name2, inputLayout);
          case 5:
            return this.getUnpackedSampler5D(funcName, name2, inputLayout);
          case 6:
            return this.getUnpackedSampler6D(funcName, name2, inputLayout);
          default:
            throw new Error(`Unsupported dimension ${shape2.length}-D`);
        }
      }
      /**
       * Packed scalar snippet.
       */
      getPackedSamplerScalar(funcName, name2) {
        const glsl = getGlsl(this.context.glContext.version);
        const source = `
          vec4 ${funcName}() {
            return ${glsl.texture2D}(${name2}, halfCR);
          }
        `;
        return new GlslLibRoutine(source);
      }
      /**
       * Packed 1D snippet.
       */
      getPackedSampler1D(funcName, name2, inputLayout) {
        const texShape = [inputLayout.width, inputLayout.height];
        const packedTexShape = [texShape[1], texShape[0]];
        const glsl = getGlsl(this.context.glContext.version);
        const packedSampler = `vec4 ${funcName}(int index) {
      vec2 uv = packedUVfrom1D(
      ${packedTexShape[0]}, ${packedTexShape[1]}, index);
      return ${glsl.texture2D}(${name2}, uv);
    }`;
        const source = packedSampler;
        return new GlslLibRoutine(source, ["coordinates.packedUVfrom1D"]);
      }
      /**
       * Packed 2D snippet.
       */
      getPackedSampler2D(funcName, name2, inputLayout) {
        const shape2 = inputLayout.unpackedShape;
        const texShape = [inputLayout.width, inputLayout.height];
        const glsl = getGlsl(this.context.glContext.version);
        const texNumR = texShape[0];
        const texNumC = texShape[1];
        if (texShape != null && ArrayUtil.arraysEqual(shape2, texShape)) {
          const packedSampler2 = `vec4 ${funcName}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${texNumC}.0, ${texNumR}.0);
        return ${glsl.texture2D}(${name2}, uv);
      }`;
          return new GlslLibRoutine(packedSampler2);
        }
        const packedTexShape = texShape;
        const valuesPerRow = Math.ceil(shape2[1] / 2);
        const packedSampler = `vec4 ${funcName}(int row, int col) {
      vec2 uv = packedUVfrom2D(${packedTexShape[1]}, ${packedTexShape[0]}, ${valuesPerRow}, row, col);
      return ${glsl.texture2D}(${name2}, uv);
    }`;
        const source = packedSampler;
        return new GlslLibRoutine(source, ["coordinates.packedUVfrom2D"]);
      }
      /**
       * Packed 3D snippet.
       */
      getPackedSampler3D(funcName, name2, inputLayout) {
        const shape2 = inputLayout.unpackedShape;
        const texShape = [inputLayout.width, inputLayout.height];
        const packedTexShape = [texShape[0], texShape[1]];
        const glsl = getGlsl(this.context.glContext.version);
        if (shape2[0] === 1) {
          const squeezedShape = shape2.slice(1);
          const keptDims = [1, 2];
          const newInputShape = squeezeInputShape(shape2, squeezedShape);
          const params = ["b", "row", "col"];
          const newInputLayout = JSON.parse(JSON.stringify(inputLayout));
          newInputLayout.unpackedShape = newInputShape;
          const samplerRoutine = this.getPackedSamplerFromInput(funcName, name2, newInputLayout);
          const packedSampler2 = `${samplerRoutine.routineBody}
      vec4 ${funcName}(int b, int row, int col) {
        return ${funcName}(${getSqueezedParams(params, keptDims)});
      } `;
          const source2 = packedSampler2;
          return new GlslLibRoutine(source2, samplerRoutine.dependencies);
        }
        const texNumR = packedTexShape[0];
        const texNumC = packedTexShape[1];
        const valuesPerRow = Math.ceil(shape2[2] / 2);
        const texelsInBatch = valuesPerRow * Math.ceil(shape2[1] / 2);
        const packedSampler = `vec4 ${funcName}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${texNumC}, ${texNumR}, ${texelsInBatch}, ${valuesPerRow}, b, row, col);
      return ${glsl.texture2D}(${name2}, uv);}`;
        const source = packedSampler;
        return new GlslLibRoutine(source, ["coordinates.packedUVfrom3D"]);
      }
      /*
       * Packed ND snippet.
       */
      getPackedSamplerND(funcName, name2, inputLayout) {
        const shape2 = inputLayout.unpackedShape;
        const rank = shape2.length;
        const texShape = [inputLayout.width, inputLayout.height];
        const glsl = getGlsl(this.context.glContext.version);
        const packedTexShape = [texShape[0], texShape[1]];
        const texNumR = packedTexShape[1];
        const texNumC = packedTexShape[0];
        const valuesPerRow = Math.ceil(shape2[rank - 1] / 2);
        let texelsInBatch = valuesPerRow * Math.ceil(shape2[rank - 2] / 2);
        let params = "int b, int row, int col";
        let index = `b * ${texelsInBatch} + (row / 2) * ${valuesPerRow} + (col / 2)`;
        for (let b = 2; b < rank - 1; b++) {
          params = `int b${b}, ` + params;
          texelsInBatch *= shape2[rank - b - 1];
          index = `b${b} * ${texelsInBatch} + ` + index;
        }
        const packedSampler = `vec4 ${funcName}(${params}) {
      int index = ${index};
      int texR = index / ${texNumC};
      int texC = index - texR * ${texNumC};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${texNumC}, ${texNumR});
      return ${glsl.texture2D}(${name2}, uv);
    }`;
        const source = packedSampler;
        return new GlslLibRoutine(source);
      }
      /**
       * Unpacked scalar snippet.
       */
      getUnpackedSamplerScalar(funcName, name2, inputLayout) {
        const [texNumR, texNumC] = [inputLayout.width, inputLayout.height];
        if (texNumR === 1 && texNumC === 1) {
          const source2 = `
          float ${funcName}() {
            return sampleTexture(${name2}, halfCR);
          }
        `;
          return new GlslLibRoutine(source2, ["coordinates.sampleTexture"]);
        }
        const source = `
        float ${funcName}() {
          int offset_${name2} = coordsToOffset(TexCoords, ${texNumR}, ${texNumC});
          vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, offset_${name2});
          return sampleTexture(${name2}, uv);
        }
      `;
        return new GlslLibRoutine(
          source,
          ["coordinates.uvFromFlat", "coordinates.sampleTexture", "coordinates.coordsToOffset"]
        );
      }
      /**
       * Unpacked 1D snippet.
       */
      getUnpackedSampler1D(funcName, name2, inputLayout) {
        const tNumR = inputLayout.width;
        const tNumC = inputLayout.height;
        if (tNumC === 1 && tNumR === 1) {
          const source2 = `
        float ${funcName}(int index) {
          return sampleTexture(${name2}, halfCR);
        }
      `;
          return new GlslLibRoutine(source2, ["coordinates.sampleTexture"]);
        }
        if (tNumC === 1) {
          const source2 = `
          float ${funcName}(int index) {
            vec2 uv = vec2((float(index) + 0.5) / ${tNumR}.0, 0.5);
            return sampleTexture(${name2}, uv);
          }
        `;
          return new GlslLibRoutine(source2, ["coordinates.sampleTexture"]);
        }
        if (tNumR === 1) {
          const source2 = `
          float ${funcName}(int index) {
            vec2 uv = vec2(0.5, (float(index) + 0.5) / ${tNumC}.0);
            return sampleTexture(${name2}, uv);
          }
        `;
          return new GlslLibRoutine(source2, ["coordinates.sampleTexture"]);
        }
        const source = `
        float ${funcName}(int index) {
          vec2 uv = uvFromFlat(${tNumR}, ${tNumC}, index);
          return sampleTexture(${name2}, uv);
        }
      `;
        return new GlslLibRoutine(source, ["coordinates.uvFromFlat", "coordinates.sampleTexture"]);
      }
      /**
       * Unpacked 2D snippet.
       */
      getUnpackedSampler2D(funcName, name2, inputLayout) {
        const shape2 = inputLayout.unpackedShape;
        const texShape = [inputLayout.height, inputLayout.width];
        if (texShape != null && ArrayUtil.arraysEqual(shape2, texShape)) {
          const texNumR2 = texShape[1];
          const texNumC2 = texShape[0];
          const source2 = `
          float ${funcName}(int row, int col) {
            vec2 uv = (vec2(row, col) + halfCR) / vec2(${texNumR2}.0, ${texNumC2}.0);
            return sampleTexture(${name2}, uv);
          }
        `;
          return new GlslLibRoutine(source2, ["coordinates.sampleTexture"]);
        }
        const { newShape, keptDims } = squeezeShape(shape2);
        const squeezedShape = newShape;
        if (squeezedShape.length < shape2.length) {
          const newInputShape = squeezeInputShape(shape2, squeezedShape);
          const newInputLayout = JSON.parse(JSON.stringify(inputLayout));
          newInputLayout.unpackedShape = newInputShape;
          const params = ["col", "row"];
          const source2 = `
          ${this.getUnpackedSamplerFromInput(funcName, name2, newInputLayout).routineBody}
          float ${funcName}(int row, int col) {
            return ${funcName}(${getSqueezedParams(params, keptDims)});
          }
        `;
          return new GlslLibRoutine(source2, ["coordinates.sampleTexture"]);
        }
        const texNumR = texShape[1];
        const texNumC = texShape[0];
        if (texNumC === 1) {
          const source2 = `
          float ${funcName}(int row, int col) {
            int offset_${name2} = coordsToOffset(TexCoords, ${texNumR}, ${texNumC});
            float index = dot(vec3(row, col, offset_${name2}), vec3(${shape2[1]}, 1, 1));
            vec2 uv = vec2(0.5, (index + 0.5) / ${texNumR}.0);
            return sampleTexture(${name2}, uv);
          }
        `;
          return new GlslLibRoutine(source2, ["coordinates.sampleTexture", "coordinates.coordsToOffset"]);
        }
        if (texNumR === 1) {
          const source2 = `
          float ${funcName}(int row, int col) {
            int offset_${name2} = coordsToOffset(TexCoords, ${texNumR}, ${texNumC});
            float index = dot(vec3(row, col, offset_${name2}), vec3(${shape2[1]}, 1, 1));
            vec2 uv = vec2((index + 0.5) / ${texNumC}.0, 0.5);
            return sampleTexture(${name2}, uv);
          }
        `;
          return new GlslLibRoutine(source2, ["coordinates.sampleTexture", "coordinates.coordsToOffset"]);
        }
        const source = `
        float ${funcName}(int row, int col) {
          int index = col * ${shape2[1]} + row;
          vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index);
          return sampleTexture(${name2}, uv);
        }
      `;
        return new GlslLibRoutine(
          source,
          ["coordinates.uvFromFlat", "coordinates.sampleTexture", "coordinates.coordsToOffset"]
        );
      }
      /**
       * Unpacked 3D snippet.
       */
      getUnpackedSampler3D(funcName, name2, inputLayout) {
        const shape2 = inputLayout.unpackedShape;
        const stride0 = shape2[1] * shape2[2];
        const stride1 = shape2[2];
        const { newShape, keptDims } = squeezeShape(shape2);
        const squeezedShape = newShape;
        if (squeezedShape.length < shape2.length) {
          const newInputShape = squeezeInputShape(shape2, squeezedShape);
          const params = ["batch", "col", "row"];
          const newInputLayout = JSON.parse(JSON.stringify(inputLayout));
          newInputLayout.unpackedShape = newInputShape;
          const routine = this.getUnpackedSamplerFromInput(funcName, name2, newInputLayout);
          const revDims = keptDims.reverse();
          const source2 = `
          ${routine.routineBody}
          float ${funcName}(int batch, int row, int col) {
            return ${funcName}(${getSqueezedParams(params, revDims)});
          }
        `;
          return new GlslLibRoutine(source2, routine.dependencies);
        }
        const texNumR = inputLayout.width;
        const texNumC = inputLayout.height;
        const source = `
          float ${funcName}(int depth, int row, int col) {
            // Explicitly use integer operations as dot() only works on floats.
            int index = depth * ${stride0} + col * ${stride1} + row;
            vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index);
            return sampleTexture(${name2}, uv);
          }
      `;
        return new GlslLibRoutine(
          source,
          ["coordinates.uvFromFlat", "coordinates.sampleTexture", "coordinates.coordsToOffset"]
        );
      }
      /**
       * Unpacked 4D snippet.
       */
      getUnpackedSampler4D(funcName, name2, inputLayout) {
        const shape2 = inputLayout.unpackedShape;
        const stride2 = shape2[3];
        const stride1 = shape2[2] * stride2;
        const stride0 = shape2[1] * stride1;
        const texNumR = inputLayout.width;
        const texNumC = inputLayout.height;
        const source = `
        float ${funcName}(int row, int col, int depth, int depth2) {
          int index = row * ${stride0} + col * ${stride1} +
              depth2 * ${stride2} + depth;
          vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index);
          return sampleTexture(${name2}, uv);
        }
      `;
        return new GlslLibRoutine(source, ["coordinates.uvFromFlat", "coordinates.sampleTexture"]);
      }
      /**
       * Unpacked 5D snippet.
       */
      getUnpackedSampler5D(funcName, name2, inputLayout) {
        const shape2 = inputLayout.unpackedShape;
        const stride3 = shape2[4];
        const stride2 = shape2[3] * stride3;
        const stride1 = shape2[2] * stride2;
        const stride0 = shape2[1] * stride1;
        const { newShape, keptDims } = squeezeShape(shape2);
        if (newShape.length < shape2.length) {
          const newInputShape = squeezeInputShape(shape2, newShape);
          const params = ["row", "col", "depth", "depth2", "depth3"];
          const newInputLayout = JSON.parse(JSON.stringify(inputLayout));
          newInputLayout.unpackedShape = newInputShape;
          const source2 = `
          ${this.getUnpackedSamplerFromInput(funcName, name2, newInputLayout).routineBody}
          float ${funcName}(int row, int col, int depth, int depth2, int depth3) {
            return ${funcName}(${getSqueezedParams(params, keptDims)});
          }
        `;
          return new GlslLibRoutine(source2, ["coordinates.sampleTexture", "coordinates.uvFromFlat"]);
        }
        const texNumR = inputLayout.width;
        const texNumC = inputLayout.height;
        const source = `
        float ${funcName}(int row, int col, int depth, int depth2, int depth3) {
          int index = row * ${stride0} + col * ${stride1} + depth * ${stride2} +
          depth3 * ${stride3} + depth2;
          vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index);
          return sampleTexture(${name2}, uv);
        }
      `;
        return new GlslLibRoutine(source, ["coordinates.sampleTexture", "coordinates.uvFromFlat"]);
      }
      /**
       * Unpacked 6D snippet.
       */
      getUnpackedSampler6D(funcName, name2, inputLayout) {
        const shape2 = inputLayout.unpackedShape;
        const stride4 = shape2[5];
        const stride3 = shape2[4] * stride4;
        const stride2 = shape2[3] * stride3;
        const stride1 = shape2[2] * stride2;
        const stride0 = shape2[1] * stride1;
        const { newShape, keptDims } = squeezeShape(shape2);
        if (newShape.length < shape2.length) {
          const newInputShape = squeezeInputShape(shape2, newShape);
          const params = ["row", "col", "depth", "depth2", "depth3", "depth4"];
          const newInputLayout = JSON.parse(JSON.stringify(inputLayout));
          newInputLayout.unpackedShape = newInputShape;
          const source2 = `
            ${this.getUnpackedSamplerFromInput(funcName, name2, newInputLayout).routineBody}
            float ${funcName}(int row, int col, int depth,
              int depth2, int depth3, int depth4) {
              return ${funcName}(${getSqueezedParams(params, keptDims)});
            }
          `;
          return new GlslLibRoutine(source2, ["coordinates.sampleTexture", "coordinates.uvFromFlat"]);
        }
        const texNumR = inputLayout.width;
        const texNumC = inputLayout.height;
        const source = `
          float ${funcName}(int row, int col, int depth,
            int depth2, int depth3, int depth4) {
            int index = row * ${stride0} + col * ${stride1} + depth * ${stride2} +
            depth2 * ${stride3} + depth3 * ${stride4} + depth4;
            vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index);
            return sampleTexture(${name2}, uv);
          }
        `;
        return new GlslLibRoutine(
          source,
          ["coordinates.uvFromFlat", "coordinates.sampleTexture", "coordinates.coordsToOffset"]
        );
      }
      /**
       * This is the main function to map from the given texture coordiantes (s,t)
       * to logical indices for the output
       * There will only be one single variation of this
       * Also see coordsToOffset and offsetToIndices for input-specific versions
       */
      toVec() {
        const output = this.context.outputTextureLayout;
        const rank = output.shape.length;
        const strides = output.strides;
        const xScale = output.width;
        const yScale = output.height;
        const stridesBlock = [];
        for (let i = 0; i < rank - 1; ++i) {
          stridesBlock.push(`
        c[${i}] = offset / ${strides[i]};`);
          stridesBlock.push(`
        offset -= c[${i}] * ${strides[i]};`);
        }
        stridesBlock.push(`
        c[${rank - 1}] = offset;`);
        const body = `
      void toVec(vec2 texCoords, out int c[${rank}]) {
        int offset = coordsToOffset(texCoords, ${xScale}, ${yScale});
        ${stridesBlock.join("")}
      }
      void toVec(int offset, out int c[${rank}]) {
        ${stridesBlock.join("")}
      }
    `;
        return { toVec: new GlslLibRoutine(body, ["coordinates.coordsToOffset"]) };
      }
      /**
       * These are value getter functions generated for each input
       * Each function is hardwired to the name and dimensions of the input
       * An '_T' variation is also produced which accesses values as if the
       * input was transposed
       */
      valueFrom() {
        const result = {};
        this.context.programInfo.inputNames.forEach((name2, i) => {
          const layout = this.context.inputTextureLayouts[i];
          const shape2 = layout.unpackedShape.length > 0 ? layout.unpackedShape : layout.shape;
          const rank = shape2.length;
          let funcName = `_${name2}`;
          result[funcName] = new GlslLibRoutine(
            this.getValueFromSingle(name2, rank, layout.width, layout.height, false),
            [`shapeUtils.indicesToOffset${funcName}`, "coordinates.offsetToCoords", "fragcolor.getColorAsFloat"]
          );
          funcName = funcName + "_T";
          result[funcName] = new GlslLibRoutine(
            this.getValueFromSingle(name2, rank, layout.width, layout.height, true),
            [`shapeUtils.indicesToOffset${funcName}`, "coordinates.offsetToCoords", "fragcolor.getColorAsFloat"]
          );
        });
        return result;
      }
      /**
       * Produces one value getter function for the name and rank given
       * If a transpose is set proper offsetToCoords mapping will be used
       * @param name name of the function
       * @param rank rank of the input
       * @param transpose whether or not should generate a transpose variation
       */
      getValueFromSingle(varName, rank, width, height, transpose2) {
        let name2 = `_${varName}`;
        if (transpose2) {
          name2 = name2 + "_T";
        }
        const glsl = getGlsl(this.context.glContext.version);
        return `
        float ${name2}(int m[${rank}]) {
          int offset = indicesToOffset${name2}(m);
          vec2 coords = offsetToCoords(offset, ${width}, ${height});
          float value = getColorAsFloat(${glsl.texture2D}(${varName}, coords));
          return value;
        }
        `;
      }
      /**
       * Produces a packed value getter function for the name and rank given
       * If a transpose is set proper offsetToCoords mapping will be used
       * @param name name of the function
       * @param rank rank of the input
       * @param transpose whether or not should generate a transpose variation
       */
      getPackedValueFrom(varName, rank, width, height, transpose2) {
        let name2 = `_${varName}_Pack`;
        if (transpose2) {
          name2 = name2 + "_T";
        }
        const glsl = getGlsl(this.context.glContext.version);
        return `
        vec4 ${name2}(int m[${rank}]) {
          int offset = indicesToOffset_${varName}(m);
          vec2 coords = offsetToCoords(offset, ${width}, ${height});
          return ${glsl.texture2D}(${varName}, coords);
        }
        `;
      }
    };
  }
});

// web/lib/onnxjs/backends/webgl/glsl-encoding-lib.ts
var EncodingGlslLib;
var init_glsl_encoding_lib = __esm({
  "web/lib/onnxjs/backends/webgl/glsl-encoding-lib.ts"() {
    "use strict";
    init_glsl_definitions();
    EncodingGlslLib = class _EncodingGlslLib extends GlslLib {
      constructor(context) {
        super(context);
      }
      getFunctions() {
        return { ...this.encodeFloat32(), ...this.decodeFloat32() };
      }
      getCustomTypes() {
        return {};
      }
      encodeFloat32() {
        return {
          encode: new GlslLibRoutine(`highp vec4 encode(highp float f) {
        return vec4(f, 0.0, 0.0, 0.0);
      }
        `)
        };
      }
      decodeFloat32() {
        return {
          decode: new GlslLibRoutine(`highp float decode(highp vec4 rgba) {
        return rgba.r;
      }
        `)
        };
      }
      /**
       * returns the routine to encode encode a 32bit float to a vec4 (of unsigned bytes)
       * @credit: https://stackoverflow.com/questions/7059962/how-do-i-convert-a-vec4-rgba-value-to-a-float
       */
      encodeUint8() {
        const endianness = _EncodingGlslLib.isLittleEndian() ? "rgba.rgba=rgba.abgr;" : "";
        return {
          encode: new GlslLibRoutine(`
      highp vec4 encode(highp float f) {
        highp float F = abs(f);
        highp float Sign = step(0.0,-f);
        highp float Exponent = floor(log2(F));
        highp float Mantissa = (exp2(- Exponent) * F);
        Exponent = floor(log2(F) + 127.0) + floor(log2(Mantissa));
        highp vec4 rgba;
        rgba[0] = 128.0 * Sign  + floor(Exponent*exp2(-1.0));
        rgba[1] = 128.0 * mod(Exponent,2.0) + mod(floor(Mantissa*128.0),128.0);
        rgba[2] = floor(mod(floor(Mantissa*exp2(23.0 -8.0)),exp2(8.0)));
        rgba[3] = floor(exp2(23.0)*mod(Mantissa,exp2(-15.0)));
        ${endianness}
        rgba = rgba / 255.0; // values need to be normalized to [0,1]
        return rgba;
    }
        `)
        };
      }
      /**
       * returns the routine to encode a vec4 of unsigned bytes to float32
       * @credit: https://stackoverflow.com/questions/7059962/how-do-i-convert-a-vec4-rgba-value-to-a-float
       */
      decodeUint8() {
        const endianness = _EncodingGlslLib.isLittleEndian() ? "rgba.rgba=rgba.abgr;" : "";
        return {
          decode: new GlslLibRoutine(`
        highp float decode(highp vec4 rgba) {
          rgba = rgba * 255.0; // values need to be de-normalized from [0,1] to [0,255]
          ${endianness}
          highp float Sign = 1.0 - step(128.0,rgba[0])*2.0;
          highp float Exponent = 2.0 * mod(rgba[0],128.0) + step(128.0,rgba[1]) - 127.0;
          highp float Mantissa = mod(rgba[1],128.0)*65536.0 + rgba[2]*256.0 +rgba[3] + float(0x800000);
          highp float Result =  Sign * exp2(Exponent) * (Mantissa * exp2(-23.0 ));
          return Result;
      }
        `)
        };
      }
      /**
       * Determines if the machine is little endian or not
       * @credit: https://gist.github.com/TooTallNate/4750953
       */
      static isLittleEndian() {
        const b = new ArrayBuffer(4);
        const a = new Uint32Array(b);
        const c = new Uint8Array(b);
        a[0] = 3735928559;
        if (c[0] === 239) {
          return true;
        }
        if (c[0] === 222) {
          return false;
        }
        throw new Error("unknown endianness");
      }
    };
  }
});

// web/lib/onnxjs/backends/webgl/glsl-fragcolor-lib.ts
var FragColorGlslLib;
var init_glsl_fragcolor_lib = __esm({
  "web/lib/onnxjs/backends/webgl/glsl-fragcolor-lib.ts"() {
    "use strict";
    init_glsl_definitions();
    init_glsl_source();
    FragColorGlslLib = class extends GlslLib {
      constructor(context) {
        super(context);
      }
      getFunctions() {
        return { ...this.setFragColor(), ...this.getColorAsFloat() };
      }
      getCustomTypes() {
        return {};
      }
      setFragColor() {
        const glsl = getGlsl(this.context.glContext.version);
        return {
          setFragColor: new GlslLibRoutine(
            `
        void setFragColor(float value) {
            ${glsl.output} = encode(value);
        }
        `,
            ["encoding.encode"]
          )
        };
      }
      getColorAsFloat() {
        return {
          getColorAsFloat: new GlslLibRoutine(
            `
        float getColorAsFloat(vec4 color) {
            return decode(color);
        }
        `,
            ["encoding.decode"]
          )
        };
      }
    };
  }
});

// web/lib/onnxjs/backends/webgl/glsl-shape-utils-lib.ts
var ShapeUtilsGlslLib;
var init_glsl_shape_utils_lib = __esm({
  "web/lib/onnxjs/backends/webgl/glsl-shape-utils-lib.ts"() {
    "use strict";
    init_glsl_definitions();
    ShapeUtilsGlslLib = class _ShapeUtilsGlslLib extends GlslLib {
      constructor(context) {
        super(context);
      }
      getFunctions() {
        return {
          ...this.bcastIndex(),
          ...this.bcastMatmulIndex(),
          ...this.offsetToIndices(),
          ...this.indicesToOffset(),
          ...this.incrementIndices()
        };
      }
      getCustomTypes() {
        return {};
      }
      bcastIndex() {
        const outputRank = this.context.outputTextureLayout.shape.length;
        const result = {};
        this.context.programInfo.inputNames.forEach((name2, i) => {
          const shape2 = this.context.inputTextureLayouts[i].unpackedShape;
          if (shape2.length <= outputRank) {
            const rank = shape2.length;
            const dimOffset = outputRank - rank;
            const funcName = `bcastIndices_${name2}`;
            let block = "";
            for (let i2 = 0; i2 < rank; ++i2) {
              block += `
          realIndices[${i2}] = int( mod(float(bcastedIndices[${dimOffset + i2}]), ${shape2[i2]}.0) );
          `;
            }
            const body = `
        void ${funcName} (int bcastedIndices[${outputRank}], out int realIndices[${rank}]) {
          ${block}
        }
        `;
            result[funcName] = new GlslLibRoutine(body);
          }
        });
        return result;
      }
      bcastMatmulIndex() {
        const outputRank = this.context.outputTextureLayout.shape.length;
        const result = {};
        this.context.programInfo.inputNames.forEach((name2, i) => {
          const shape2 = this.context.inputTextureLayouts[i].shape;
          if (!(shape2.length < 2 || shape2.length > outputRank)) {
            const rank = shape2.length;
            const dimOffset = outputRank - rank;
            const funcName = `bcastMatmulIndices_${name2}`;
            let block = "";
            for (let i2 = 0; i2 < rank - 2; ++i2) {
              block += `
          realIndices[${i2}] = int( mod(float(bcastedIndices[${dimOffset + i2}]), ${shape2[i2]}.0) );
          `;
            }
            const body = `
        void ${funcName}(int bcastedIndices[${outputRank}], out int realIndices[${rank}]) {
          ${block}
          realIndices[${rank - 1}] = bcastedIndices[${outputRank - 1}];
          realIndices[${rank - 2}] = bcastedIndices[${outputRank - 2}];
        }
        `;
            result[funcName] = new GlslLibRoutine(body);
          }
        });
        return result;
      }
      indicesToOffset() {
        const result = {};
        this.context.programInfo.inputNames.forEach((name2, i) => {
          const shape2 = this.context.inputTextureLayouts[i].shape;
          const strides = this.context.inputTextureLayouts[i].strides;
          const rank = shape2.length;
          let funcName = `indicesToOffset_${name2}`;
          result[funcName] = new GlslLibRoutine(_ShapeUtilsGlslLib.indexToOffsetSingle(funcName, rank, strides));
          funcName = `indicesToOffset_${name2}_T`;
          result[funcName] = new GlslLibRoutine(_ShapeUtilsGlslLib.indexToOffsetSingle(funcName, rank, strides.slice().reverse()));
        });
        return result;
      }
      static indexToOffsetSingle(name2, rank, strides) {
        let block = "";
        for (let i = rank - 1; i >= 0; --i) {
          block += `
        offset += indices[${i}] * ${strides[i]};
        `;
        }
        return `
      int ${name2}(int indices[${rank}]) {
        int offset = 0;
        ${block}
        return offset;
      }
      `;
      }
      offsetToIndices() {
        const result = {};
        this.context.programInfo.inputNames.forEach((name2, i) => {
          const shape2 = this.context.inputTextureLayouts[i].shape;
          const strides = this.context.inputTextureLayouts[i].strides;
          const rank = shape2.length;
          let funcName = `offsetToIndices_${name2}`;
          result[funcName] = new GlslLibRoutine(_ShapeUtilsGlslLib.offsetToIndicesSingle(funcName, rank, strides));
          funcName = `offsetToIndices_${name2}_T`;
          result[funcName] = new GlslLibRoutine(_ShapeUtilsGlslLib.offsetToIndicesSingle(funcName, rank, strides.slice().reverse()));
        });
        return result;
      }
      static offsetToIndicesSingle(name2, rank, strides) {
        const stridesBlock = [];
        for (let i = 0; i < rank - 1; ++i) {
          stridesBlock.push(`
      indices[${i}] = offset / ${strides[i]};`);
          stridesBlock.push(`
        offset -= indices[${i}] * ${strides[i]};`);
        }
        stridesBlock.push(`
      indices[${rank - 1}] = offset;`);
        return `
      void ${name2}(int offset, out int indices[${rank}]) {
        ${stridesBlock.join("")}
      }
      `;
      }
      incrementIndices() {
        const result = {};
        this.context.programInfo.inputNames.forEach((name2, i) => {
          const shape2 = this.context.inputTextureLayouts[i].shape;
          const rank = shape2.length;
          const funcName = `incrementIndices_${name2}`;
          let shapeInit = "";
          for (let i2 = 0; i2 < rank; ++i2) {
            shapeInit += `
        shape[${i2}] = ${shape2[i2]};`;
          }
          const body = `
        void ${funcName}(int axis, out int indices[${rank}]) {
          int shape[${rank}];
          ${shapeInit};
          for(int i = ${rank} -1 ; i >= 0; --i) {
            if(i > axis) continue;
            indices[i] += 1;
            if(indices[i] < shape[i]) {
              break;
            }
            indices[i] = 0;
          }
        }
        `;
          result[funcName] = new GlslLibRoutine(body);
        });
        return result;
      }
    };
  }
});

// web/lib/onnxjs/backends/webgl/glsl-vec-lib.ts
var VecGlslLib;
var init_glsl_vec_lib = __esm({
  "web/lib/onnxjs/backends/webgl/glsl-vec-lib.ts"() {
    "use strict";
    init_glsl_definitions();
    VecGlslLib = class extends GlslLib {
      constructor(context) {
        super(context);
      }
      getCustomTypes() {
        return {};
      }
      getFunctions() {
        return { ...this.binaryVecFunctions(), ...this.copyVec(), ...this.setVecItem(), ...this.getVecItem() };
      }
      binaryVecFunctions() {
        const outputLayout = this.context.outputTextureLayout;
        const rank = outputLayout.shape.length;
        const nameOp = { add: "+=", sub: "-=", mul: "*=", div: "/=" };
        const result = {};
        for (const name2 in nameOp) {
          const fname = `${name2}Vec`;
          let assignmentBlock = "";
          for (let i = 0; i < rank; ++i) {
            assignmentBlock += `
          dest[${i}] ${nameOp[name2]} src[${i}];
          `;
          }
          const body = `
        void ${fname}(int src[${rank}], out int dest[${rank}]) {
          ${assignmentBlock}
        }
        `;
          result[fname] = new GlslLibRoutine(body);
        }
        return result;
      }
      copyVec() {
        const outputLayout = this.context.outputTextureLayout;
        const rank = outputLayout.shape.length;
        let assignmentBlock = "";
        for (let i = 0; i < rank; ++i) {
          assignmentBlock += `
        dest[${i}] = src[${i}];
        `;
        }
        const body = `
      void copyVec(int src[${rank}], out int dest[${rank}]) {
        ${assignmentBlock}
      }
      `;
        return { copyVec: new GlslLibRoutine(body) };
      }
      setVecItem() {
        const outputLayout = this.context.outputTextureLayout;
        const rank = outputLayout.shape.length;
        let block = `
        if(index < 0)
            index =${rank} + index;
        if (index == 0)
            m[0] = value;
        `;
        for (let i = 1; i < rank - 1; ++i) {
          block += `
        else if (index == ${i})
            m[${i}] = value;
            `;
        }
        block += `
        else
            m[${rank - 1}] = value;
        `;
        const body = `
      void setVecItem(out int m[${rank}], int index, int value) {
        ${block}
      }
        `;
        return { setVecItem: new GlslLibRoutine(body) };
      }
      getVecItem() {
        const outputLayout = this.context.outputTextureLayout;
        const rank = outputLayout.shape.length;
        let block = `
        if(index < 0)
            index = ${rank} + index;
        if (index == 0)
            return m[0];
      `;
        for (let i = 1; i < rank - 1; ++i) {
          block += `
        else if (index == ${i})
            return m[${i}];
      `;
        }
        block += `
        else
            return m[${rank - 1}];
        `;
        const body = `
      int getVecItem(int m[${rank}], int index) {
        ${block}
      }
    `;
        return { getVecItem: new GlslLibRoutine(body) };
      }
    };
  }
});

// web/lib/onnxjs/backends/webgl/glsl-registered-libs.ts
var glslRegistry;
var init_glsl_registered_libs = __esm({
  "web/lib/onnxjs/backends/webgl/glsl-registered-libs.ts"() {
    "use strict";
    init_glsl_coordinate_lib();
    init_glsl_encoding_lib();
    init_glsl_fragcolor_lib();
    init_glsl_shape_utils_lib();
    init_glsl_vec_lib();
    glslRegistry = {
      "encoding": EncodingGlslLib,
      "fragcolor": FragColorGlslLib,
      "vec": VecGlslLib,
      "shapeUtils": ShapeUtilsGlslLib,
      "coordinates": CoordsGlslLib
      //  'arrays': ArrayGlslSLib
    };
  }
});

// web/lib/onnxjs/backends/webgl/glsl-preprocessor.ts
var GlslPreprocessor;
var init_glsl_preprocessor = __esm({
  "web/lib/onnxjs/backends/webgl/glsl-preprocessor.ts"() {
    "use strict";
    init_glsl_definitions();
    init_glsl_function_inliner();
    init_glsl_registered_libs();
    init_glsl_source();
    GlslPreprocessor = class {
      constructor(glContext, programInfo, inputTextureLayouts, outputTextureLayout) {
        this.libs = {};
        this.glslLibRoutineDependencyGraph = {};
        this.context = new GlslContext(glContext, programInfo, inputTextureLayouts, outputTextureLayout);
        Object.keys(glslRegistry).forEach((name2) => {
          const lib = new glslRegistry[name2](this.context);
          this.libs[name2] = lib;
        });
        const map = this.glslLibRoutineDependencyGraph;
        for (const libName in this.libs) {
          const lib = this.libs[libName];
          const routinesInLib = lib.getFunctions();
          for (const routine in routinesInLib) {
            const key = libName + "." + routine;
            let currentNode;
            if (map[key]) {
              currentNode = map[key];
              currentNode.routineBody = routinesInLib[routine].routineBody;
            } else {
              currentNode = new GlslLibRoutineNode(key, routinesInLib[routine].routineBody);
              map[key] = currentNode;
            }
            const dependencies = routinesInLib[routine].dependencies;
            if (dependencies) {
              for (let i = 0; i < dependencies.length; ++i) {
                if (!map[dependencies[i]]) {
                  const node = new GlslLibRoutineNode(dependencies[i]);
                  map[dependencies[i]] = node;
                  currentNode.addDependency(node);
                } else {
                  currentNode.addDependency(map[dependencies[i]]);
                }
              }
            }
          }
        }
      }
      preprocess() {
        const programInfo = this.context.programInfo;
        let source = programInfo.shaderSource;
        if (!this.context.programInfo.hasMain) {
          source = `${source}
      ${getDefaultFragShaderMain(this.context.glContext.version, this.context.outputTextureLayout.shape.length)}`;
        }
        source = replaceInlines(source);
        return `${getFragShaderPreamble(this.context.glContext.version)}
    ${this.getUniforms(programInfo.inputNames, programInfo.variables)}
    ${this.getImports(source)}
    ${source}`;
      }
      getImports(script) {
        const routinesIncluded = this.selectGlslLibRoutinesToBeIncluded(script);
        if (routinesIncluded.length === 0) {
          return "";
        }
        let routines = "";
        for (let i = 0; i < routinesIncluded.length; ++i) {
          if (routinesIncluded[i].routineBody) {
            routines += routinesIncluded[i].routineBody + "\n";
          } else {
            throw new Error(`Missing body for the Glsl Library routine: ${routinesIncluded[i].name}`);
          }
        }
        return routines;
      }
      selectGlslLibRoutinesToBeIncluded(script) {
        const nodes = [];
        Object.keys(this.glslLibRoutineDependencyGraph).forEach((classAndRoutine) => {
          const routine = classAndRoutine.split(".")[1];
          if (script.indexOf(routine) !== -1) {
            nodes.push(this.glslLibRoutineDependencyGraph[classAndRoutine]);
          }
        });
        return TopologicalSortGlslRoutines.returnOrderedNodes(nodes);
      }
      getUniforms(samplers, variables) {
        const uniformLines = [];
        if (samplers) {
          for (const sampler of samplers) {
            uniformLines.push(`uniform sampler2D ${sampler};`);
          }
        }
        if (variables) {
          for (const variable of variables) {
            uniformLines.push(
              `uniform ${variable.type} ${variable.name}${variable.arrayLength ? `[${variable.arrayLength}]` : ""};`
            );
          }
        }
        return uniformLines.join("\n");
      }
    };
  }
});

// web/lib/onnxjs/backends/webgl/program-manager.ts
var ProgramManager;
var init_program_manager = __esm({
  "web/lib/onnxjs/backends/webgl/program-manager.ts"() {
    "use strict";
    init_esm();
    init_instrument();
    init_glsl_preprocessor();
    init_glsl_source();
    ProgramManager = class {
      constructor(profiler, glContext, textureLayoutStrategy) {
        this.profiler = profiler;
        this.glContext = glContext;
        this.textureLayoutStrategy = textureLayoutStrategy;
        this.repo = /* @__PURE__ */ new Map();
        this.attributesBound = false;
      }
      getArtifact(key) {
        return this.repo.get(key);
      }
      setArtifact(key, artifact) {
        this.repo.set(key, artifact);
      }
      run(buildArtifact, inputs, output) {
        this.profiler.event("op", `ProgramManager.run ${buildArtifact.programInfo.name ?? "unknown kernel"}`, () => {
          const gl = this.glContext.gl;
          const program = buildArtifact.program;
          gl.useProgram(program);
          try {
            this.bindOutput(output);
            if (!this.attributesBound) {
              this.bindAttributes(buildArtifact.attribLocations);
            }
            this.bindUniforms(buildArtifact.uniformLocations, buildArtifact.programInfo.variables ?? [], inputs);
          } catch (err) {
            Logger.error("ProgramManager", buildArtifact.programInfo.shaderSource);
            throw err;
          }
          this.profiler.event("backend", "GlContext.draw()", () => {
            this.glContext.draw();
          });
        }, this.glContext);
      }
      dispose() {
        if (this.vertexShader) {
          this.glContext.deleteShader(this.vertexShader);
        }
        this.repo.forEach((a) => this.glContext.deleteProgram(a.program));
      }
      build(programInfo, inputTextureLayouts, outputTextureLayout) {
        return this.profiler.event("backend", "ProgramManager.build", () => {
          const preprocessor = new GlslPreprocessor(this.glContext, programInfo, inputTextureLayouts, outputTextureLayout);
          const fragScript = preprocessor.preprocess();
          const program = this.compile(fragScript);
          const artifact = {
            programInfo,
            program,
            uniformLocations: this.getUniformLocations(
              program,
              preprocessor.context.programInfo.inputNames,
              preprocessor.context.programInfo.variables
            ),
            attribLocations: this.getAttribLocations(program)
          };
          return artifact;
        });
      }
      compile(fragShaderScript) {
        if (!this.vertexShader) {
          Logger.verbose("ProrgramManager", "Compiling and caching Vertex shader for the first time");
          const vertexShaderScript = getVertexShaderSource(this.glContext.version);
          this.vertexShader = this.glContext.compileShader(vertexShaderScript, this.glContext.gl.VERTEX_SHADER);
        }
        if (env2.debug) {
          Logger.verbose("ProrgramManager", `FragShader:
${fragShaderScript}
`);
        }
        const fragShader = this.glContext.compileShader(fragShaderScript, this.glContext.gl.FRAGMENT_SHADER);
        const program = this.glContext.createProgram(this.vertexShader, fragShader);
        this.glContext.deleteShader(fragShader);
        return program;
      }
      bindOutput(td) {
        const width = td.width;
        const height = td.height;
        Logger.verbose(
          "ProrgramManager",
          `Binding output texture to Framebuffer: w/h=${width}/${height}, shape=${td.shape}, type=${td.tensor.type}`
        );
        this.glContext.attachFramebuffer(td.texture, width, height);
      }
      bindAttributes(attribLocations) {
        const positionHandle = attribLocations.position;
        const textureCoordHandle = attribLocations.textureCoord;
        this.glContext.setVertexAttributes(positionHandle, textureCoordHandle);
        this.attributesBound = true;
      }
      bindUniforms(uniformLocations, variables, textures) {
        const gl = this.glContext.gl;
        let texturePosition = 0;
        for (const { name: name2, type, location, arrayLength } of uniformLocations) {
          const value = variables.find((v) => v.name === name2)?.data;
          if (type !== "sampler2D" && !value) {
            throw new Error(`variable '${name2}' does not have data defined in program info`);
          }
          switch (type) {
            case "sampler2D":
              this.bindTexture(textures[texturePosition], location, texturePosition);
              texturePosition++;
              break;
            case "float":
              if (arrayLength) {
                gl.uniform1fv(location, value);
              } else {
                gl.uniform1f(location, value);
              }
              break;
            case "int":
              if (arrayLength) {
                gl.uniform1iv(location, value);
              } else {
                gl.uniform1i(location, value);
              }
              break;
            default:
              throw new Error(`Uniform not implemented: ${type}`);
          }
        }
      }
      bindTexture(td, uniformHandle, position) {
        this.glContext.bindTextureToUniform(td.texture, position, uniformHandle);
      }
      getAttribLocations(program) {
        return {
          position: this.getAttribLocation(program, "position"),
          textureCoord: this.getAttribLocation(program, "textureCoord")
        };
      }
      getUniformLocations(program, samplers, variables) {
        const uniformLocations = [];
        if (samplers) {
          for (const sampler of samplers) {
            uniformLocations.push({ name: sampler, type: "sampler2D", location: this.getUniformLocation(program, sampler) });
          }
        }
        if (variables) {
          for (const variable of variables) {
            uniformLocations.push({ ...variable, location: this.getUniformLocation(program, variable.name) });
          }
        }
        return uniformLocations;
      }
      getUniformLocation(program, name2) {
        const gl = this.glContext.gl;
        const reference = gl.getUniformLocation(program, name2);
        if (reference === null) {
          throw new Error(`Uniform ${name2} not found.`);
        }
        return reference;
      }
      getAttribLocation(program, name2) {
        const gl = this.glContext.gl;
        const attributeLocation = gl.getAttribLocation(program, name2);
        return attributeLocation;
      }
    };
  }
});

// web/lib/onnxjs/backends/webgl/texture-manager.ts
var TextureManager;
var init_texture_manager = __esm({
  "web/lib/onnxjs/backends/webgl/texture-manager.ts"() {
    "use strict";
    init_instrument();
    init_texture_data_encoder();
    TextureManager = class {
      constructor(glContext, layoutStrategy, profiler, config) {
        this.glContext = glContext;
        this.layoutStrategy = layoutStrategy;
        this.profiler = profiler;
        this.config = config;
        this.pendingRead = /* @__PURE__ */ new Map();
        if (config.reuseTextures) {
          this.inUseTextures = /* @__PURE__ */ new Map();
          this.idleTextures = /* @__PURE__ */ new Map();
          this.textureLookup = /* @__PURE__ */ new Map();
        }
      }
      createTextureFromLayout(dataType, layout, data, usage) {
        const textureDataType = this.toEncoderType(dataType);
        const encoder = this.glContext.getEncoder(textureDataType, layout.channels || 1, usage);
        if (layout.isPacked && usage === 1 /* UploadOnly */) {
          throw new Error("not implemented");
        }
        const width = layout.width;
        const height = layout.height;
        let key;
        let inUseTextures;
        if (this.config.reuseTextures) {
          key = `${width}x${height}_${encoder.format}_${encoder.internalFormat}_${encoder.textureType}`;
          inUseTextures = this.inUseTextures.get(key);
          if (!inUseTextures) {
            inUseTextures = [];
            this.inUseTextures.set(key, inUseTextures);
          }
          const idleTextures = this.idleTextures.get(key);
          if (idleTextures && idleTextures.length > 0) {
            const texture2 = idleTextures.pop();
            inUseTextures.push(texture2);
            if (usage === 1 /* UploadOnly */) {
              this.glContext.updateTexture(texture2, width, height, encoder, this.toTextureData(dataType, data));
            }
            return texture2;
          }
        }
        Logger.verbose("TextureManager", `Creating new texture of size ${layout.width}x${layout.height}`);
        const texture = this.glContext.allocateTexture(width, height, encoder, this.toTextureData(dataType, data));
        if (this.config.reuseTextures) {
          inUseTextures.push(texture);
          this.textureLookup.set(texture, key);
        }
        return texture;
      }
      readTexture(td, dataType, channels) {
        if (!channels) {
          channels = 1;
        }
        return this.profiler.event("backend", "TextureManager.readTexture", () => {
          const dataSize = td.shape.reduce((a, b) => a * b) * channels;
          const data = this.glContext.readTexture(
            td.texture,
            td.width,
            td.height,
            dataSize,
            this.toEncoderType(dataType),
            channels
          );
          return this.toTensorData(dataType, data);
        });
      }
      async readTextureAsync(td, dataType, channels) {
        const dataId = td.tensor.dataId;
        if (!channels) {
          channels = 1;
        }
        if (this.pendingRead.has(dataId)) {
          const subscribers = this.pendingRead.get(dataId);
          return new Promise((resolve) => subscribers?.push(resolve));
        }
        return this.profiler.event("backend", "TextureManager.readTextureAsync", async () => {
          this.pendingRead.set(dataId, []);
          const dataSize = td.shape.reduce((a, b) => a * b) * channels;
          await this.glContext.createAndWaitForFence();
          const data = this.glContext.readTexture(
            td.texture,
            td.width,
            td.height,
            dataSize,
            this.toEncoderType(dataType),
            channels
          );
          const tensorData = this.toTensorData(dataType, data);
          const subscribers = this.pendingRead.get(dataId);
          this.pendingRead.delete(dataId);
          subscribers?.forEach((resolve) => resolve(tensorData));
          return tensorData;
        });
      }
      readUint8TextureAsFloat(td) {
        return this.profiler.event("backend", "TextureManager.readUint8TextureAsFloat", () => {
          const dataSize = td.shape.reduce((a, b) => a * b);
          const data = this.glContext.readTexture(td.texture, td.width, td.height, dataSize * 4, "byte", 4);
          return new Float32Array(data.buffer, data.byteOffset, dataSize);
        });
      }
      releaseTexture(textureData, deleteTexture) {
        let key;
        if (this.config.reuseTextures) {
          key = this.textureLookup.get(textureData.texture);
          if (key) {
            if (deleteTexture) {
              this.textureLookup.delete(key);
            }
            const inUseTextures = this.inUseTextures.get(key);
            if (inUseTextures) {
              const index = inUseTextures.indexOf(textureData.texture);
              if (index !== -1) {
                inUseTextures.splice(index, 1);
                let idleTextures = this.idleTextures.get(key);
                if (!idleTextures) {
                  idleTextures = [];
                  this.idleTextures.set(key, idleTextures);
                }
                idleTextures.push(textureData.texture);
              }
            }
          }
        }
        if (!key || deleteTexture) {
          Logger.verbose("TextureManager", `Deleting texture of size ${textureData.width}x${textureData.height}`);
          this.glContext.deleteTexture(textureData.texture);
        }
      }
      toTensorData(dataType, data) {
        switch (dataType) {
          case "int16":
            return data instanceof Int16Array ? data : Int16Array.from(data);
          case "int32":
            return data instanceof Int32Array ? data : Int32Array.from(data);
          case "int8":
            return data instanceof Int8Array ? data : Int8Array.from(data);
          case "uint16":
            return data instanceof Uint16Array ? data : Uint16Array.from(data);
          case "uint32":
            return data instanceof Uint32Array ? data : Uint32Array.from(data);
          case "uint8":
          case "bool":
            return data instanceof Uint8Array ? data : Uint8Array.from(data);
          case "float32":
            return data instanceof Float32Array ? data : Float32Array.from(data);
          case "float64":
            return data instanceof Float64Array ? data : Float64Array.from(data);
          default:
            throw new Error(`TensorData type ${dataType} is not supported`);
        }
      }
      toTextureData(_dataType, data) {
        if (!data) {
          return void 0;
        }
        return data instanceof Float32Array ? data : new Float32Array(data);
      }
      toEncoderType(_dataType) {
        return "float";
      }
      clearActiveTextures() {
        this.glContext.clearActiveTextures();
      }
    };
  }
});

// web/lib/onnxjs/backends/webgl/session-handler.ts
var WebGLSessionHandler;
var init_session_handler = __esm({
  "web/lib/onnxjs/backends/webgl/session-handler.ts"() {
    "use strict";
    init_instrument();
    init_opset();
    init_inference_handler();
    init_op_resolve_rules();
    init_program_manager();
    init_texture_layout_strategy();
    init_texture_manager();
    WebGLSessionHandler = class {
      constructor(backend2, context) {
        this.backend = backend2;
        this.context = context;
        this.layoutStrategy = new PreferLogicalStrategy(backend2.glContext.maxTextureSize);
        this.programManager = new ProgramManager(this.context.profiler, backend2.glContext, this.layoutStrategy);
        this.textureManager = new TextureManager(
          backend2.glContext,
          this.layoutStrategy,
          this.context.profiler,
          { reuseTextures: backend2.textureCacheMode === "full" }
        );
        this.packedTextureDataCache = /* @__PURE__ */ new Map();
        this.unpackedTextureDataCache = /* @__PURE__ */ new Map();
        this.pack = backend2.pack;
        this.pack2unpackMap = /* @__PURE__ */ new Map();
        this.unpack2packMap = /* @__PURE__ */ new Map();
      }
      createInferenceHandler() {
        return new WebGLInferenceHandler(this);
      }
      onGraphInitialized(graph) {
        const initializers = graph.getValues().filter((v) => v.from === -1 && v.tensor).map((v) => v.tensor.dataId);
        this.initializers = new Set(initializers);
      }
      isInitializer(tensorId) {
        return this.initializers ? this.initializers.has(tensorId) : false;
      }
      addInitializer(tensorId) {
        this.initializers.add(tensorId);
      }
      getTextureData(tensorId, isPacked) {
        if (isPacked) {
          return this.packedTextureDataCache.get(tensorId);
        } else {
          return this.unpackedTextureDataCache.get(tensorId);
        }
      }
      setTextureData(tensorId, textureData, isPacked = false) {
        Logger.verbose("WebGLSessionHandler", "Storing Texture data in cache");
        if (isPacked) {
          this.packedTextureDataCache.set(tensorId, textureData);
        } else {
          this.unpackedTextureDataCache.set(tensorId, textureData);
        }
      }
      dispose() {
        this.programManager.dispose();
        this.textureManager.clearActiveTextures();
        this.packedTextureDataCache.forEach((td) => this.textureManager.releaseTexture(td, true));
        this.packedTextureDataCache = /* @__PURE__ */ new Map();
        this.unpackedTextureDataCache.forEach((td) => this.textureManager.releaseTexture(td, true));
        this.unpackedTextureDataCache = /* @__PURE__ */ new Map();
      }
      resolve(node, opsets, graph) {
        const op = resolveOperator(node, opsets, WEBGL_OP_RESOLVE_RULES);
        return { impl: op.opImpl, context: op.opInit ? op.opInit(node, graph) : node };
      }
    };
  }
});

// web/lib/onnxjs/backends/webgl/webgl-context.ts
function linearSearchLastTrue(arr) {
  let i = 0;
  for (; i < arr.length; ++i) {
    const isDone = arr[i]();
    if (!isDone) {
      break;
    }
  }
  return i - 1;
}
var WebGLContext;
var init_webgl_context = __esm({
  "web/lib/onnxjs/backends/webgl/webgl-context.ts"() {
    "use strict";
    init_esm();
    init_texture_data_encoder();
    init_texture_data_encoder();
    init_utils();
    WebGLContext = class {
      constructor(gl, version3) {
        this.frameBufferBound = false;
        this.itemsToPoll = [];
        this.gl = gl;
        this.version = version3;
        this.getExtensions();
        this.vertexbuffer = this.createVertexbuffer();
        this.framebuffer = this.createFramebuffer();
        this.queryVitalParameters();
      }
      allocateTexture(width, height, encoder, data) {
        const gl = this.gl;
        const texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        const buffer = data ? encoder.encode(data, width * height) : null;
        gl.texImage2D(
          gl.TEXTURE_2D,
          0,
          // Level of detail.
          encoder.internalFormat,
          width,
          height,
          0,
          // Always 0 in OpenGL ES.
          encoder.format,
          encoder.textureType,
          buffer
        );
        this.checkError();
        return texture;
      }
      updateTexture(texture, width, height, encoder, data) {
        const gl = this.gl;
        gl.bindTexture(gl.TEXTURE_2D, texture);
        const buffer = encoder.encode(data, width * height);
        gl.texSubImage2D(
          gl.TEXTURE_2D,
          0,
          // level
          0,
          // xoffset
          0,
          // yoffset
          width,
          height,
          encoder.format,
          encoder.textureType,
          buffer
        );
        this.checkError();
      }
      attachFramebuffer(texture, width, height) {
        const gl = this.gl;
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
        gl.framebufferTexture2D(
          gl.FRAMEBUFFER,
          gl.COLOR_ATTACHMENT0,
          gl.TEXTURE_2D,
          texture,
          0
        );
        this.checkError();
        gl.viewport(0, 0, width, height);
        gl.scissor(0, 0, width, height);
      }
      readTexture(texture, width, height, dataSize, dataType, channels) {
        const gl = this.gl;
        if (!channels) {
          channels = 1;
        }
        if (!this.frameBufferBound) {
          this.attachFramebuffer(texture, width, height);
        }
        const encoder = this.getEncoder(dataType, channels);
        const buffer = encoder.allocate(width * height);
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.framebufferTexture2D(
          gl.FRAMEBUFFER,
          gl.COLOR_ATTACHMENT0,
          gl.TEXTURE_2D,
          texture,
          0
        );
        gl.readPixels(0, 0, width, height, gl.RGBA, encoder.textureType, buffer);
        this.checkError();
        return encoder.decode(buffer, dataSize);
      }
      isFramebufferReady() {
        return true;
      }
      getActiveTexture() {
        const gl = this.gl;
        const n = gl.getParameter(this.gl.ACTIVE_TEXTURE);
        return `TEXTURE${n - gl.TEXTURE0}`;
      }
      getTextureBinding() {
        return this.gl.getParameter(this.gl.TEXTURE_BINDING_2D);
      }
      getFramebufferBinding() {
        return this.gl.getParameter(this.gl.FRAMEBUFFER_BINDING);
      }
      setVertexAttributes(positionHandle, textureCoordHandle) {
        const gl = this.gl;
        gl.vertexAttribPointer(positionHandle, 3, gl.FLOAT, false, 20, 0);
        gl.enableVertexAttribArray(positionHandle);
        if (textureCoordHandle !== -1) {
          gl.vertexAttribPointer(textureCoordHandle, 2, gl.FLOAT, false, 20, 12);
          gl.enableVertexAttribArray(textureCoordHandle);
        }
        this.checkError();
      }
      createProgram(vertexShader, fragShader) {
        const gl = this.gl;
        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragShader);
        gl.linkProgram(program);
        return program;
      }
      compileShader(shaderSource, shaderType) {
        const gl = this.gl;
        const shader = gl.createShader(shaderType);
        if (!shader) {
          throw new Error(`createShader() returned null with type ${shaderType}`);
        }
        gl.shaderSource(shader, shaderSource);
        gl.compileShader(shader);
        if (gl.getShaderParameter(shader, gl.COMPILE_STATUS) === false) {
          throw new Error(`Failed to compile shader: ${gl.getShaderInfoLog(shader)}
Shader source:
${shaderSource}`);
        }
        return shader;
      }
      deleteShader(shader) {
        this.gl.deleteShader(shader);
      }
      bindTextureToUniform(texture, position, uniformHandle) {
        const gl = this.gl;
        gl.activeTexture(gl.TEXTURE0 + position);
        this.checkError();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        this.checkError();
        gl.uniform1i(uniformHandle, position);
        this.checkError();
      }
      draw() {
        this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);
        this.checkError();
      }
      checkError() {
        if (env2.debug) {
          const gl = this.gl;
          const error = gl.getError();
          let label = "";
          switch (error) {
            case gl.NO_ERROR:
              return;
            case gl.INVALID_ENUM:
              label = "INVALID_ENUM";
              break;
            case gl.INVALID_VALUE:
              label = "INVALID_VALUE";
              break;
            case gl.INVALID_OPERATION:
              label = "INVALID_OPERATION";
              break;
            case gl.INVALID_FRAMEBUFFER_OPERATION:
              label = "INVALID_FRAMEBUFFER_OPERATION";
              break;
            case gl.OUT_OF_MEMORY:
              label = "OUT_OF_MEMORY";
              break;
            case gl.CONTEXT_LOST_WEBGL:
              label = "CONTEXT_LOST_WEBGL";
              break;
            default:
              label = `Unknown WebGL Error: ${error.toString(16)}`;
          }
          throw new Error(label);
        }
      }
      deleteTexture(texture) {
        this.gl.deleteTexture(texture);
      }
      deleteProgram(program) {
        this.gl.deleteProgram(program);
      }
      getEncoder(dataType, channels, usage = 0 /* Default */) {
        if (this.version === 2) {
          return new RedFloat32DataEncoder(this.gl, channels);
        }
        switch (dataType) {
          case "float":
            if (usage === 1 /* UploadOnly */ || this.isRenderFloat32Supported) {
              return new RGBAFloatDataEncoder(this.gl, channels);
            } else {
              return new RGBAFloatDataEncoder(
                this.gl,
                channels,
                this.textureHalfFloatExtension.HALF_FLOAT_OES
              );
            }
          case "int":
            throw new Error("not implemented");
          case "byte":
            return new Uint8DataEncoder(this.gl, channels);
          default:
            throw new Error(`Invalid dataType: ${dataType}`);
        }
      }
      clearActiveTextures() {
        const gl = this.gl;
        for (let unit = 0; unit < this.maxTextureImageUnits; ++unit) {
          gl.activeTexture(gl.TEXTURE0 + unit);
          gl.bindTexture(gl.TEXTURE_2D, null);
        }
      }
      dispose() {
        if (this.disposed) {
          return;
        }
        const gl = this.gl;
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        gl.deleteFramebuffer(this.framebuffer);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
        gl.deleteBuffer(this.vertexbuffer);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
        gl.finish();
        this.disposed = true;
      }
      createDefaultGeometry() {
        return new Float32Array([
          -1,
          1,
          0,
          0,
          1,
          // upper left
          -1,
          -1,
          0,
          0,
          0,
          // lower left
          1,
          1,
          0,
          1,
          1,
          // upper right
          1,
          -1,
          0,
          1,
          0
          // lower right
        ]);
      }
      createVertexbuffer() {
        const gl = this.gl;
        const buffer = gl.createBuffer();
        if (!buffer) {
          throw new Error("createBuffer() returned null");
        }
        const geometry = this.createDefaultGeometry();
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, geometry, gl.STATIC_DRAW);
        this.checkError();
        return buffer;
      }
      createFramebuffer() {
        const fb = this.gl.createFramebuffer();
        if (!fb) {
          throw new Error("createFramebuffer returned null");
        }
        return fb;
      }
      queryVitalParameters() {
        const gl = this.gl;
        this.isFloatTextureAttachableToFrameBuffer = this.checkFloatTextureAttachableToFrameBuffer();
        this.isRenderFloat32Supported = this.checkRenderFloat32();
        this.isFloat32DownloadSupported = this.checkFloat32Download();
        if (this.version === 1 && !this.textureHalfFloatExtension && !this.isRenderFloat32Supported) {
          throw new Error("both float32 and float16 TextureType are not supported");
        }
        this.isBlendSupported = !this.isRenderFloat32Supported || this.checkFloat32Blend();
        this.maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
        this.maxTextureImageUnits = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
        if (this.version === 2) {
        }
      }
      getExtensions() {
        if (this.version === 2) {
          this.colorBufferFloatExtension = this.gl.getExtension("EXT_color_buffer_float");
          this.disjointTimerQueryWebgl2Extension = this.gl.getExtension("EXT_disjoint_timer_query_webgl2");
        } else {
          this.textureFloatExtension = this.gl.getExtension("OES_texture_float");
          this.textureHalfFloatExtension = this.gl.getExtension("OES_texture_half_float");
        }
      }
      checkFloatTextureAttachableToFrameBuffer() {
        const gl = this.gl;
        const texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        const internalFormat = this.version === 2 ? gl.RGBA32F : gl.RGBA;
        gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, 1, 1, 0, gl.RGBA, gl.FLOAT, null);
        const frameBuffer = gl.createFramebuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
        const isComplete = gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE;
        gl.bindTexture(gl.TEXTURE_2D, null);
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        gl.deleteTexture(texture);
        gl.deleteFramebuffer(frameBuffer);
        return isComplete;
      }
      checkRenderFloat32() {
        if (this.version === 2) {
          if (!this.colorBufferFloatExtension) {
            return false;
          }
        } else {
          if (!this.textureFloatExtension) {
            return false;
          }
        }
        return this.isFloatTextureAttachableToFrameBuffer;
      }
      checkFloat32Download() {
        if (this.version === 2) {
          if (!this.colorBufferFloatExtension) {
            return false;
          }
        } else {
          if (!this.textureFloatExtension) {
            return false;
          }
          if (!this.gl.getExtension("WEBGL_color_buffer_float")) {
            return false;
          }
        }
        return this.isFloatTextureAttachableToFrameBuffer;
      }
      /**
       * Check whether GL_BLEND is supported
       */
      checkFloat32Blend() {
        const gl = this.gl;
        let texture;
        let frameBuffer;
        let vertexShader;
        let fragmentShader;
        let program;
        try {
          texture = gl.createTexture();
          frameBuffer = gl.createFramebuffer();
          gl.bindTexture(gl.TEXTURE_2D, texture);
          const internalFormat = this.version === 2 ? gl.RGBA32F : gl.RGBA;
          gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, 1, 1, 0, gl.RGBA, gl.FLOAT, null);
          gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);
          gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
          gl.enable(gl.BLEND);
          vertexShader = gl.createShader(gl.VERTEX_SHADER);
          if (!vertexShader) {
            return false;
          }
          gl.shaderSource(vertexShader, "void main(){}");
          gl.compileShader(vertexShader);
          fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
          if (!fragmentShader) {
            return false;
          }
          gl.shaderSource(fragmentShader, "precision highp float;void main(){gl_FragColor=vec4(0.5);}");
          gl.compileShader(fragmentShader);
          program = gl.createProgram();
          if (!program) {
            return false;
          }
          gl.attachShader(program, vertexShader);
          gl.attachShader(program, fragmentShader);
          gl.linkProgram(program);
          gl.useProgram(program);
          gl.drawArrays(gl.POINTS, 0, 1);
          return gl.getError() === gl.NO_ERROR;
        } finally {
          gl.disable(gl.BLEND);
          if (program) {
            gl.deleteProgram(program);
          }
          if (vertexShader) {
            gl.deleteShader(vertexShader);
          }
          if (fragmentShader) {
            gl.deleteShader(fragmentShader);
          }
          if (frameBuffer) {
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            gl.deleteFramebuffer(frameBuffer);
          }
          if (texture) {
            gl.bindTexture(gl.TEXTURE_2D, null);
            gl.deleteTexture(texture);
          }
        }
      }
      beginTimer() {
        if (this.version === 2 && this.disjointTimerQueryWebgl2Extension) {
          const gl2 = this.gl;
          const ext = this.disjointTimerQueryWebgl2Extension;
          const query = gl2.createQuery();
          gl2.beginQuery(ext.TIME_ELAPSED_EXT, query);
          return query;
        } else {
          throw new Error("WebGL1 profiling currently not supported.");
        }
      }
      endTimer() {
        if (this.version === 2 && this.disjointTimerQueryWebgl2Extension) {
          const gl2 = this.gl;
          const ext = this.disjointTimerQueryWebgl2Extension;
          gl2.endQuery(ext.TIME_ELAPSED_EXT);
          return;
        } else {
          throw new Error("WebGL1 profiling currently not supported");
        }
      }
      isTimerResultAvailable(query) {
        let available = false, disjoint = false;
        if (this.version === 2 && this.disjointTimerQueryWebgl2Extension) {
          const gl2 = this.gl;
          const ext = this.disjointTimerQueryWebgl2Extension;
          available = gl2.getQueryParameter(query, gl2.QUERY_RESULT_AVAILABLE);
          disjoint = gl2.getParameter(ext.GPU_DISJOINT_EXT);
        } else {
          throw new Error("WebGL1 profiling currently not supported");
        }
        return available && !disjoint;
      }
      getTimerResult(query) {
        let timeElapsed = 0;
        if (this.version === 2) {
          const gl2 = this.gl;
          timeElapsed = gl2.getQueryParameter(query, gl2.QUERY_RESULT);
          gl2.deleteQuery(query);
        } else {
          throw new Error("WebGL1 profiling currently not supported");
        }
        return timeElapsed / 1e6;
      }
      async waitForQueryAndGetTime(query) {
        await repeatedTry(() => this.isTimerResultAvailable(query));
        return this.getTimerResult(query);
      }
      async createAndWaitForFence() {
        const fenceContext = this.createFence(this.gl);
        return this.pollFence(fenceContext);
      }
      createFence(gl) {
        let isFencePassed;
        const gl2 = gl;
        const query = gl2.fenceSync(gl2.SYNC_GPU_COMMANDS_COMPLETE, 0);
        gl.flush();
        if (query === null) {
          isFencePassed = () => true;
        } else {
          isFencePassed = () => {
            const status = gl2.clientWaitSync(query, 0, 0);
            return status === gl2.ALREADY_SIGNALED || status === gl2.CONDITION_SATISFIED;
          };
        }
        return { query, isFencePassed };
      }
      async pollFence(fenceContext) {
        return new Promise((resolve) => {
          void this.addItemToPoll(() => fenceContext.isFencePassed(), () => resolve());
        });
      }
      pollItems() {
        const index = linearSearchLastTrue(this.itemsToPoll.map((x) => x.isDoneFn));
        for (let i = 0; i <= index; ++i) {
          const { resolveFn } = this.itemsToPoll[i];
          resolveFn();
        }
        this.itemsToPoll = this.itemsToPoll.slice(index + 1);
      }
      async addItemToPoll(isDoneFn, resolveFn) {
        this.itemsToPoll.push({ isDoneFn, resolveFn });
        if (this.itemsToPoll.length > 1) {
          return;
        }
        await repeatedTry(() => {
          this.pollItems();
          return this.itemsToPoll.length === 0;
        });
      }
    };
  }
});

// web/lib/onnxjs/backends/webgl/webgl-context-factory.ts
function createWebGLContext(contextId) {
  let context;
  if ((!contextId || contextId === "webgl2") && "webgl2" in cache) {
    context = cache.webgl2;
  } else if ((!contextId || contextId === "webgl") && "webgl" in cache) {
    context = cache.webgl;
  }
  if (!context) {
    try {
      const offscreenCanvas = createOffscreenCanvas();
      context = createNewWebGLContext(offscreenCanvas, contextId);
    } catch (e) {
      const canvas = createCanvas();
      context = createNewWebGLContext(canvas, contextId);
    }
  }
  contextId = contextId || context.version === 1 ? "webgl" : "webgl2";
  const gl = context.gl;
  cache[contextId] = context;
  if (gl.isContextLost()) {
    delete cache[contextId];
    return createWebGLContext(contextId);
  }
  gl.disable(gl.DEPTH_TEST);
  gl.disable(gl.STENCIL_TEST);
  gl.disable(gl.BLEND);
  gl.disable(gl.DITHER);
  gl.disable(gl.POLYGON_OFFSET_FILL);
  gl.disable(gl.SAMPLE_COVERAGE);
  gl.enable(gl.SCISSOR_TEST);
  gl.enable(gl.CULL_FACE);
  gl.cullFace(gl.BACK);
  return context;
}
function createNewWebGLContext(canvas, contextId) {
  const contextAttributes = {
    alpha: false,
    depth: false,
    antialias: false,
    stencil: false,
    preserveDrawingBuffer: false,
    premultipliedAlpha: false,
    failIfMajorPerformanceCaveat: false
  };
  let gl;
  const ca = contextAttributes;
  if (!contextId || contextId === "webgl2") {
    gl = canvas.getContext("webgl2", ca);
    if (gl) {
      try {
        return new WebGLContext(gl, 2);
      } catch (err) {
        Logger.warning("GlContextFactory", `failed to create WebGLContext using contextId 'webgl2'. Error: ${err}`);
      }
    }
  }
  if (!contextId || contextId === "webgl") {
    gl = canvas.getContext("webgl", ca) || canvas.getContext("experimental-webgl", ca);
    if (gl) {
      try {
        return new WebGLContext(gl, 1);
      } catch (err) {
        Logger.warning(
          "GlContextFactory",
          `failed to create WebGLContext using contextId 'webgl' or 'experimental-webgl'. Error: ${err}`
        );
      }
    }
  }
  throw new Error("WebGL is not supported");
}
function createCanvas() {
  if (typeof document === "undefined") {
    throw new TypeError("failed to create canvas: document is not supported");
  }
  const canvas = document.createElement("canvas");
  canvas.width = 1;
  canvas.height = 1;
  return canvas;
}
function createOffscreenCanvas() {
  if (typeof OffscreenCanvas === "undefined") {
    throw new TypeError("failed to create offscreen canvas: OffscreenCanvas is not supported");
  }
  return new OffscreenCanvas(1, 1);
}
var cache;
var init_webgl_context_factory = __esm({
  "web/lib/onnxjs/backends/webgl/webgl-context-factory.ts"() {
    "use strict";
    init_instrument();
    init_webgl_context();
    cache = {};
  }
});

// web/lib/onnxjs/backends/backend-webgl.ts
var WebGLBackend;
var init_backend_webgl = __esm({
  "web/lib/onnxjs/backends/backend-webgl.ts"() {
    "use strict";
    init_esm();
    init_instrument();
    init_session_handler();
    init_webgl_context_factory();
    WebGLBackend = class {
      get contextId() {
        return env2.webgl.contextId;
      }
      set contextId(value) {
        env2.webgl.contextId = value;
      }
      get matmulMaxBatchSize() {
        return env2.webgl.matmulMaxBatchSize;
      }
      set matmulMaxBatchSize(value) {
        env2.webgl.matmulMaxBatchSize = value;
      }
      get textureCacheMode() {
        return env2.webgl.textureCacheMode;
      }
      set textureCacheMode(value) {
        env2.webgl.textureCacheMode = value;
      }
      get pack() {
        return env2.webgl.pack;
      }
      set pack(value) {
        env2.webgl.pack = value;
      }
      get async() {
        return env2.webgl.async;
      }
      set async(value) {
        env2.webgl.async = value;
      }
      initialize() {
        try {
          this.glContext = createWebGLContext(this.contextId);
          if (typeof this.matmulMaxBatchSize !== "number") {
            this.matmulMaxBatchSize = 16;
          }
          if (typeof this.textureCacheMode !== "string") {
            this.textureCacheMode = "full";
          }
          if (typeof this.pack !== "boolean") {
            this.pack = false;
          }
          if (typeof this.async !== "boolean") {
            this.async = false;
          }
          Logger.setWithEnv(env2);
          if (!env2.webgl.context) {
            Object.defineProperty(env2.webgl, "context", { value: this.glContext.gl });
          }
          Logger.verbose(
            "WebGLBackend",
            `Created WebGLContext: ${typeof this.glContext} with matmulMaxBatchSize: ${this.matmulMaxBatchSize}; textureCacheMode: ${this.textureCacheMode}; pack: ${this.pack}; async: ${this.async}.`
          );
          return true;
        } catch (e) {
          Logger.warning("WebGLBackend", `Unable to initialize WebGLBackend. ${e}`);
          return false;
        }
      }
      createSessionHandler(context) {
        return new WebGLSessionHandler(this, context);
      }
      dispose() {
        this.glContext.dispose();
      }
    };
  }
});

// web/lib/onnxjs/backend.ts
async function resolveBackend(hint) {
  if (!hint) {
    return resolveBackend(["webgl"]);
  } else {
    const hints = typeof hint === "string" ? [hint] : hint;
    for (const backendHint of hints) {
      const cache2 = backendsCache.get(backendHint);
      if (cache2) {
        return cache2;
      }
      const backend2 = await tryLoadBackend(backendHint);
      if (backend2) {
        return backend2;
      }
    }
  }
  throw new Error("no available backend to use");
}
async function tryLoadBackend(backendHint) {
  const backendObj = backend;
  if (typeof backendObj[backendHint] !== "undefined" && isBackend(backendObj[backendHint])) {
    const backend2 = backendObj[backendHint];
    let init = backend2.initialize();
    if (typeof init === "object" && "then" in init) {
      init = await init;
    }
    if (init) {
      backendsCache.set(backendHint, backend2);
      return backend2;
    }
  }
  return void 0;
}
function isBackend(obj) {
  const o = obj;
  if ("initialize" in o && typeof o.initialize === "function" && // initialize()
  "createSessionHandler" in o && typeof o.createSessionHandler === "function" && // createSessionHandler()
  "dispose" in o && typeof o.dispose === "function") {
    return true;
  }
  return false;
}
var backendsCache, backend;
var init_backend2 = __esm({
  "web/lib/onnxjs/backend.ts"() {
    "use strict";
    init_backend_webgl();
    backendsCache = /* @__PURE__ */ new Map();
    backend = {
      webgl: new WebGLBackend()
    };
  }
});

// web/lib/onnxjs/execution-plan.ts
var KernelOp, ExecutionPlan;
var init_execution_plan = __esm({
  "web/lib/onnxjs/execution-plan.ts"() {
    "use strict";
    init_instrument();
    KernelOp = class {
      constructor(op, node) {
        this.op = op;
        this.node = node;
      }
    };
    ExecutionPlan = class {
      constructor(graph, ops, profiler) {
        this.graph = graph;
        this.profiler = profiler;
        this.initialize(ops);
      }
      initialize(ops) {
        this.profiler.event("session", "ExecutionPlan.initialize", () => {
          const graphNodes = this.graph.getNodes();
          if (graphNodes.length !== ops.length) {
            throw new Error("The size of nodes and OPs do not match.");
          }
          this._ops = ops.map((op, i) => new KernelOp(op, graphNodes[i]));
          this.reset();
          this._starter = [];
          this._ops.forEach((op, i) => {
            let resolved = true;
            for (const input of op.node.inputs) {
              if (!this._values[input] && this.graph.getInputIndices().indexOf(input) === -1) {
                resolved = false;
                break;
              }
            }
            if (resolved) {
              this._starter.push(i);
            }
          });
        });
      }
      reset() {
        this._values = this.graph.getValues().map((i) => i.tensor);
      }
      async execute(sessionHandler, modelInputs) {
        return this.profiler.event("session", "ExecutionPlan.execute", async () => {
          this.reset();
          const inferenceHandler = sessionHandler.createInferenceHandler();
          const graphInputs = this.graph.getInputIndices();
          if (modelInputs.length !== graphInputs.length) {
            throw new Error(`number of input tensors don't match the number of inputs to the model: actual: ${modelInputs.length} expected: ${graphInputs.length}`);
          }
          modelInputs.forEach((input, i) => {
            const index = graphInputs[i];
            this._values[index] = input;
          });
          const sequence = this._starter.slice(0);
          const graphValues = this.graph.getValues();
          const graphNodes = this.graph.getNodes();
          let rear = 0;
          while (rear < sequence.length) {
            const thisOpIndex = sequence[rear++];
            const thisOp = this._ops[thisOpIndex];
            const inputList = thisOp.node.inputs.map((i) => this._values[i]);
            if (inputList.indexOf(void 0) !== -1) {
              throw new Error(`unresolved input detected: op: ${thisOp.node}`);
            }
            const inputTensors = inputList;
            Logger.verbose(
              "ExecPlan",
              `Runing op:${thisOp.node.name} (${inputTensors.map((t, i) => `'${thisOp.node.inputs[i]}': ${t.type}[${t.dims.join(",")}]`).join(", ")})`
            );
            const outputList = await this.profiler.event(
              "node",
              thisOp.node.name,
              async () => thisOp.op.impl(inferenceHandler, inputTensors, thisOp.op.context)
            );
            if (outputList.length !== thisOp.node.outputs.length) {
              throw new Error("the size of output does not match model definition.");
            }
            outputList.forEach((output2, i) => {
              const j = thisOp.node.outputs[i];
              if (this._values[j]) {
                throw new Error(`output [${j}] already has value: op:${thisOp.node.name}`);
              }
              this._values[j] = output2;
            });
            const downstreamNodes = /* @__PURE__ */ new Set();
            outputList.forEach((_output, i) => {
              const j = thisOp.node.outputs[i];
              for (const currentDownstreamNodeIndex of graphValues[j].to) {
                const currentDownstreamNode = graphNodes[currentDownstreamNodeIndex];
                let resolved = true;
                for (const k of currentDownstreamNode.inputs) {
                  if (!this._values[k]) {
                    resolved = false;
                    break;
                  }
                }
                if (resolved) {
                  downstreamNodes.add(currentDownstreamNodeIndex);
                }
              }
            });
            sequence.push(...downstreamNodes);
          }
          const output = [];
          for (let i = 0; i < this.graph.getOutputIndices().length; i++) {
            const outputIndex = this.graph.getOutputIndices()[i];
            const outputTensor = this._values[outputIndex];
            if (outputTensor === void 0) {
              throw new Error(`required output [${outputIndex}] does not have value`);
            }
            if (outputIndex === 0) {
              await outputTensor.getData();
            } else {
              outputTensor.data;
            }
            output.push(outputTensor);
          }
          Logger.verbose("ExecPlan", "disposing of inferenceHandler");
          inferenceHandler.dispose();
          return output;
        });
      }
    };
  }
});

// web/lib/onnxjs/attribute.ts
var import_onnx3, ortFbs2, Attribute;
var init_attribute = __esm({
  "web/lib/onnxjs/attribute.ts"() {
    "use strict";
    init_ort_generated();
    import_onnx3 = __toESM(require_onnx());
    init_tensor2();
    init_util();
    ortFbs2 = onnxruntime.experimental.fbs;
    Attribute = class _Attribute {
      constructor(attributes) {
        this._attributes = /* @__PURE__ */ new Map();
        if (attributes !== null && attributes !== void 0) {
          for (const attr of attributes) {
            if (attr instanceof import_onnx3.onnx.AttributeProto) {
              this._attributes.set(attr.name, [_Attribute.getValue(attr), _Attribute.getType(attr)]);
            } else if (attr instanceof ortFbs2.Attribute) {
              this._attributes.set(attr.name(), [_Attribute.getValue(attr), _Attribute.getType(attr)]);
            }
          }
          if (this._attributes.size < attributes.length) {
            throw new Error("duplicated attribute names");
          }
        }
      }
      set(key, type, value) {
        this._attributes.set(key, [value, type]);
      }
      delete(key) {
        this._attributes.delete(key);
      }
      getFloat(key, defaultValue) {
        return this.get(key, "float", defaultValue);
      }
      getInt(key, defaultValue) {
        return this.get(key, "int", defaultValue);
      }
      getString(key, defaultValue) {
        return this.get(key, "string", defaultValue);
      }
      getTensor(key, defaultValue) {
        return this.get(key, "tensor", defaultValue);
      }
      getFloats(key, defaultValue) {
        return this.get(key, "floats", defaultValue);
      }
      getInts(key, defaultValue) {
        return this.get(key, "ints", defaultValue);
      }
      getStrings(key, defaultValue) {
        return this.get(key, "strings", defaultValue);
      }
      getTensors(key, defaultValue) {
        return this.get(key, "tensors", defaultValue);
      }
      get(key, type, defaultValue) {
        const valueAndType = this._attributes.get(key);
        if (valueAndType === void 0) {
          if (defaultValue !== void 0) {
            return defaultValue;
          }
          throw new Error(`required attribute not found: ${key}`);
        }
        if (valueAndType[1] !== type) {
          throw new Error(`type mismatch: expected ${type} but got ${valueAndType[1]}`);
        }
        return valueAndType[0];
      }
      static getType(attr) {
        const type = attr instanceof import_onnx3.onnx.AttributeProto ? attr.type : attr.type();
        switch (type) {
          case import_onnx3.onnx.AttributeProto.AttributeType.FLOAT:
            return "float";
          case import_onnx3.onnx.AttributeProto.AttributeType.INT:
            return "int";
          case import_onnx3.onnx.AttributeProto.AttributeType.STRING:
            return "string";
          case import_onnx3.onnx.AttributeProto.AttributeType.TENSOR:
            return "tensor";
          case import_onnx3.onnx.AttributeProto.AttributeType.FLOATS:
            return "floats";
          case import_onnx3.onnx.AttributeProto.AttributeType.INTS:
            return "ints";
          case import_onnx3.onnx.AttributeProto.AttributeType.STRINGS:
            return "strings";
          case import_onnx3.onnx.AttributeProto.AttributeType.TENSORS:
            return "tensors";
          default:
            throw new Error(`attribute type is not supported yet: ${import_onnx3.onnx.AttributeProto.AttributeType[type]}`);
        }
      }
      static getValue(attr) {
        const attrType = attr instanceof import_onnx3.onnx.AttributeProto ? attr.type : attr.type();
        if (attrType === import_onnx3.onnx.AttributeProto.AttributeType.GRAPH || attrType === import_onnx3.onnx.AttributeProto.AttributeType.GRAPHS) {
          throw new Error("graph attribute is not supported yet");
        }
        const value = this.getValueNoCheck(attr);
        if (attrType === import_onnx3.onnx.AttributeProto.AttributeType.INT && LongUtil.isLong(value)) {
          return LongUtil.longToNumber(value);
        }
        if (attrType === import_onnx3.onnx.AttributeProto.AttributeType.INTS) {
          const arr = value;
          const numberValue = new Array(arr.length);
          for (let i = 0; i < arr.length; i++) {
            const maybeLong = arr[i];
            numberValue[i] = LongUtil.longToNumber(maybeLong);
          }
          return numberValue;
        }
        if (attrType === import_onnx3.onnx.AttributeProto.AttributeType.TENSOR) {
          return attr instanceof import_onnx3.onnx.AttributeProto ? Tensor3.fromProto(value) : Tensor3.fromOrtTensor(value);
        }
        if (attrType === import_onnx3.onnx.AttributeProto.AttributeType.TENSORS) {
          if (attr instanceof import_onnx3.onnx.AttributeProto) {
            const tensorProtos = value;
            return tensorProtos.map((value2) => Tensor3.fromProto(value2));
          } else if (attr instanceof ortFbs2.Attribute) {
            const tensorProtos = value;
            return tensorProtos.map((value2) => Tensor3.fromOrtTensor(value2));
          }
        }
        if (attrType === import_onnx3.onnx.AttributeProto.AttributeType.STRING) {
          if (attr instanceof import_onnx3.onnx.AttributeProto) {
            const utf8String = value;
            return decodeUtf8String(utf8String);
          }
        }
        if (attrType === import_onnx3.onnx.AttributeProto.AttributeType.STRINGS) {
          if (attr instanceof import_onnx3.onnx.AttributeProto) {
            const utf8Strings = value;
            return utf8Strings.map(decodeUtf8String);
          }
        }
        return value;
      }
      static getValueNoCheck(attr) {
        return attr instanceof import_onnx3.onnx.AttributeProto ? this.getValueNoCheckFromOnnxFormat(attr) : this.getValueNoCheckFromOrtFormat(attr);
      }
      static getValueNoCheckFromOnnxFormat(attr) {
        switch (attr.type) {
          case import_onnx3.onnx.AttributeProto.AttributeType.FLOAT:
            return attr.f;
          case import_onnx3.onnx.AttributeProto.AttributeType.INT:
            return attr.i;
          case import_onnx3.onnx.AttributeProto.AttributeType.STRING:
            return attr.s;
          case import_onnx3.onnx.AttributeProto.AttributeType.TENSOR:
            return attr.t;
          case import_onnx3.onnx.AttributeProto.AttributeType.GRAPH:
            return attr.g;
          case import_onnx3.onnx.AttributeProto.AttributeType.FLOATS:
            return attr.floats;
          case import_onnx3.onnx.AttributeProto.AttributeType.INTS:
            return attr.ints;
          case import_onnx3.onnx.AttributeProto.AttributeType.STRINGS:
            return attr.strings;
          case import_onnx3.onnx.AttributeProto.AttributeType.TENSORS:
            return attr.tensors;
          case import_onnx3.onnx.AttributeProto.AttributeType.GRAPHS:
            return attr.graphs;
          default:
            throw new Error(`unsupported attribute type: ${import_onnx3.onnx.AttributeProto.AttributeType[attr.type]}`);
        }
      }
      static getValueNoCheckFromOrtFormat(attr) {
        switch (attr.type()) {
          case ortFbs2.AttributeType.FLOAT:
            return attr.f();
          case ortFbs2.AttributeType.INT:
            return attr.i();
          case ortFbs2.AttributeType.STRING:
            return attr.s();
          case ortFbs2.AttributeType.TENSOR:
            return attr.t();
          case ortFbs2.AttributeType.GRAPH:
            return attr.g();
          case ortFbs2.AttributeType.FLOATS:
            return attr.floatsArray();
          case ortFbs2.AttributeType.INTS: {
            const ints = [];
            for (let i = 0; i < attr.intsLength(); i++) {
              ints.push(attr.ints(i));
            }
            return ints;
          }
          case ortFbs2.AttributeType.STRINGS: {
            const strings = [];
            for (let i = 0; i < attr.stringsLength(); i++) {
              strings.push(attr.strings(i));
            }
            return strings;
          }
          case ortFbs2.AttributeType.TENSORS: {
            const tensors = [];
            for (let i = 0; i < attr.tensorsLength(); i++) {
              tensors.push(attr.tensors(i));
            }
            return tensors;
          }
          default:
            throw new Error(`unsupported attribute type: ${ortFbs2.AttributeType[attr.type()]}`);
        }
      }
    };
  }
});

// web/lib/onnxjs/graph.ts
var import_onnx4, ortFbs3, Graph, Value, Node, GraphImpl;
var init_graph = __esm({
  "web/lib/onnxjs/graph.ts"() {
    "use strict";
    init_attribute();
    init_ort_generated();
    import_onnx4 = __toESM(require_onnx());
    init_tensor2();
    init_util();
    ortFbs3 = onnxruntime.experimental.fbs;
    Graph = {
      /**
       * construct a graph from a graph protobuf type
       */
      from: (graphProto, initializer) => new GraphImpl(graphProto, initializer)
    };
    Value = class {
      constructor(valueInfo) {
        this._from = void 0;
        this._to = [];
        this.tensor = void 0;
        this.type = void 0;
        if (valueInfo) {
          this.type = ProtoUtil.tensorValueTypeFromProto(valueInfo.type.tensorType);
        }
      }
      // -1 represent from initializer
      get from() {
        return this._from;
      }
      get to() {
        return this._to;
      }
    };
    Node = class {
      constructor(_nodeProto, name2) {
        if (_nodeProto instanceof import_onnx4.onnx.NodeProto) {
          this.name = _nodeProto.name;
          this.opType = _nodeProto.opType;
          this.attributes = new Attribute(_nodeProto.attribute);
        } else if (_nodeProto instanceof ortFbs3.Node) {
          this.name = name2 ?? _nodeProto.name();
          this.opType = _nodeProto.opType();
          this.attributes = new Attribute(ProtoUtil.tensorAttributesFromORTFormat(_nodeProto));
        }
        this.inputs = [];
        this.outputs = [];
        this.executeNode = true;
      }
    };
    GraphImpl = class {
      constructor(graph, graphInitializer) {
        if (!graph) {
          throw new TypeError("graph is empty");
        }
        this.buildGraph(graph);
        this.transformGraph(graphInitializer);
        this.checkIsAcyclic();
      }
      getInputIndices() {
        return this._allInputIndices;
      }
      getInputNames() {
        return this._allInputNames;
      }
      getOutputIndices() {
        return this._allOutputIndices;
      }
      getOutputNames() {
        return this._allOutputNames;
      }
      getValues() {
        return this._allData;
      }
      getNodes() {
        return this._nodes;
      }
      buildGraph(graph) {
        if (graph instanceof import_onnx4.onnx.GraphProto) {
          this.buildGraphFromOnnxFormat(graph);
        } else if (graph instanceof ortFbs3.Graph) {
          this.buildGraphFromOrtFormat(graph);
        } else {
          throw new TypeError("Graph type is not supported.");
        }
      }
      buildGraphFromOnnxFormat(graph) {
        const dataIndices = /* @__PURE__ */ new Map();
        this._allData = [];
        this._allInputIndices = [];
        this._allInputNames = [];
        this._allOutputIndices = [];
        this._allOutputNames = [];
        this._nodes = [];
        const nodesIndices = /* @__PURE__ */ new Map();
        if (!graph.input) {
          throw new Error("missing information in graph: input");
        }
        const inputValueNames = [];
        for (const i of graph.input) {
          if (dataIndices.has(i.name)) {
            throw new Error(`duplicated input name: ${i.name}`);
          }
          const currentIndex = this._allData.push(new Value(i)) - 1;
          dataIndices.set(i.name, currentIndex);
          inputValueNames.push(i.name);
        }
        if (!graph.initializer) {
          throw new Error("missing information in graph: initializer");
        }
        for (const i of graph.initializer) {
          let index = dataIndices.get(i.name);
          if (index === void 0) {
            const value = new Value();
            value.type = {
              shape: { dims: ProtoUtil.tensorDimsFromProto(i.dims) },
              tensorType: ProtoUtil.tensorDataTypeFromProto(i.dataType)
            };
            index = this._allData.push(value) - 1;
            dataIndices.set(i.name, index);
          }
          this._allData[index]._from = -1;
          this._allData[index].tensor = Tensor3.fromProto(i);
        }
        for (let i = 0; i < this._allData.length; i++) {
          if (!this._allData[i].tensor) {
            this._allInputIndices.push(i);
            this._allInputNames.push(inputValueNames[i]);
          }
        }
        if (!graph.output) {
          throw new Error("missing information in graph: output");
        }
        for (const i of graph.output) {
          if (dataIndices.has(i.name)) {
            throw new Error(`duplicated output name: ${i.name}`);
          }
          const currentIndex = this._allData.push(new Value(i)) - 1;
          dataIndices.set(i.name, currentIndex);
          this._allOutputIndices.push(currentIndex);
          this._allOutputNames.push(i.name);
        }
        if (!graph.node) {
          throw new Error("missing information in graph: node");
        }
        for (const nodeProto of graph.node) {
          if (!nodeProto.name) {
            for (let pick = 0; ; pick++) {
              const name2 = `unnamed_${nodeProto.opType}_${pick}`;
              if (!nodesIndices.has(name2)) {
                nodeProto.name = name2;
                break;
              }
            }
          }
          if (nodesIndices.has(nodeProto.name)) {
            throw new Error(`duplicated node name: ${nodeProto.name}`);
          }
          const currentIndex = this._nodes.push(new Node(nodeProto)) - 1;
          nodesIndices.set(nodeProto.name, currentIndex);
        }
        for (let i = 0; i < this._nodes.length; i++) {
          const node = this._nodes[i];
          const nodeProto = graph.node[i];
          if (!nodeProto.output) {
            throw new Error(`missing output for node: ${nodeProto.name}`);
          }
          for (const output of nodeProto.output) {
            let dataIndex = dataIndices.get(output);
            if (typeof dataIndex === "undefined") {
              dataIndex = this._allData.push(new Value()) - 1;
              dataIndices.set(output, dataIndex);
            }
            node.outputs.push(dataIndex);
            if (this._allData[dataIndex]._from !== void 0) {
              throw new Error(`multiple nodes output to one data value: ${dataIndex}`);
            }
            this._allData[dataIndex]._from = i;
            if (nodeProto.opType === "Constant") {
              if (!nodeProto.attribute || nodeProto.attribute.length !== 1 || !nodeProto.attribute[0].t) {
                throw new Error("missing attributes or missing tensor value in attributes for this Constant operator");
              }
              if (!nodeProto.output || nodeProto.output.length !== 1) {
                throw new Error("missing output or incorrect number of outputs for this Constant operator");
              }
              node.outputs.pop();
              node.executeNode = false;
              this._allData[dataIndex]._from = -1;
              this._allData[dataIndex].tensor = Tensor3.fromProto(nodeProto.attribute[0].t);
            }
          }
        }
        for (let i = 0; i < this._nodes.length; i++) {
          const node = this._nodes[i];
          const nodeProto = graph.node[i];
          if (!nodeProto.input) {
            throw new Error(`missing input for node: ${nodeProto.name}`);
          }
          for (const input of nodeProto.input) {
            const dataIndex = dataIndices.get(input);
            if (typeof dataIndex === "undefined") {
              if (input === "" && (nodeProto.input.length === 3 || nodeProto.input.length === 4) && nodeProto.opType === "Resize") {
                continue;
              }
              throw new Error(`unrecognized input '${input}' for node: ${nodeProto.name}`);
            }
            node.inputs.push(dataIndex);
            this._allData[dataIndex]._to.push(i);
          }
        }
        return true;
      }
      buildGraphFromOrtFormat(graph) {
        const dataIndices = /* @__PURE__ */ new Map();
        this._allData = [];
        this._allInputIndices = [];
        this._allInputNames = [];
        this._allOutputIndices = [];
        this._allOutputNames = [];
        this._nodes = [];
        const nodesIndices = /* @__PURE__ */ new Map();
        const inputValueNames = [];
        for (let i = 0; i < graph.inputsLength(); i++) {
          const inputName = graph.inputs(i);
          if (dataIndices.has(inputName)) {
            throw new Error(`duplicated input name: ${inputName}`);
          }
          for (let j = 0; j < graph.nodeArgsLength(); j++) {
            if (graph.nodeArgs(j)?.name() === inputName) {
              const value = new Value();
              const valueType = graph.nodeArgs(j)?.type()?.valueType();
              if (valueType !== ortFbs3.TypeInfoValue.tensor_type) {
                throw new Error("Unexpected value type for the nodeArg.");
              }
              const valueInfo = graph.nodeArgs(j).type().value(new ortFbs3.TensorTypeAndShape());
              const type = ProtoUtil.tensorDataTypeFromProto(valueInfo.elemType());
              const shape2 = valueInfo.shape();
              const dims = [];
              for (let k = 0; k < shape2.dimLength(); k++) {
                dims.push(LongUtil.longToNumber(shape2.dim(k).value().dimValue()));
              }
              value.type = { shape: { dims }, tensorType: type };
              const currentIndex = this._allData.push(value) - 1;
              dataIndices.set(inputName, currentIndex);
              inputValueNames.push(inputName);
            }
          }
        }
        for (let i = 0; i < graph.initializersLength(); i++) {
          const initializer = graph.initializers(i);
          let index = dataIndices.get(initializer.name());
          if (index === void 0) {
            const value = new Value();
            const dims = ProtoUtil.tensorDimsFromORTFormat(initializer);
            const type = ProtoUtil.tensorDataTypeFromProto(initializer.dataType());
            value.type = { shape: { dims }, tensorType: type };
            index = this._allData.push(value) - 1;
            dataIndices.set(initializer.name(), index);
          }
          this._allData[index]._from = -1;
          this._allData[index].tensor = Tensor3.fromOrtTensor(initializer);
        }
        for (let i = 0; i < this._allData.length; i++) {
          if (!this._allData[i].tensor) {
            this._allInputIndices.push(i);
            this._allInputNames.push(inputValueNames[i]);
          }
        }
        for (let i = 0; i < graph.outputsLength(); i++) {
          const outputName = graph.outputs(i);
          if (dataIndices.has(outputName)) {
            throw new Error(`duplicated output name: ${outputName}`);
          }
          const currentIndex = this._allData.push(new Value()) - 1;
          dataIndices.set(outputName, currentIndex);
          this._allOutputIndices.push(currentIndex);
          this._allOutputNames.push(outputName);
        }
        if (!graph.nodes) {
          throw new Error("missing information in graph: node");
        }
        for (let i = 0; i < graph.nodesLength(); i++) {
          const nodeProto = graph.nodes(i);
          let name2 = nodeProto.name();
          if (!name2) {
            for (let pick = 0; ; pick++) {
              name2 = `unnamed_${nodeProto.opType()}_${pick}`;
              if (!nodesIndices.has(name2)) {
                break;
              }
            }
          }
          if (nodesIndices.has(name2)) {
            throw new Error(`duplicated node name: ${name2}`);
          }
          const currentIndex = this._nodes.push(new Node(nodeProto, name2)) - 1;
          nodesIndices.set(name2, currentIndex);
        }
        for (let i = 0; i < this._nodes.length; i++) {
          const node = this._nodes[i];
          const nodeProto = graph.nodes(i);
          if (nodeProto == null) {
            throw new Error(`No node exists at index ${i}`);
          }
          if (nodeProto?.outputsLength() === 0) {
            throw new Error(`missing output for node: ${nodeProto.name}`);
          }
          for (let j = 0; j < nodeProto?.outputsLength(); j++) {
            const output = nodeProto?.outputs(j);
            let dataIndex = dataIndices.get(output);
            if (typeof dataIndex === "undefined") {
              dataIndex = this._allData.push(new Value()) - 1;
              dataIndices.set(output, dataIndex);
            }
            node.outputs.push(dataIndex);
            if (this._allData[dataIndex]._from !== void 0) {
              throw new Error(`multiple nodes output to one data value: ${dataIndex}`);
            }
            this._allData[dataIndex]._from = i;
            if (nodeProto.opType() === "Constant") {
              if (nodeProto.attributesLength() !== 1 || !nodeProto.attributes(0).t()) {
                throw new Error("missing attributes or missing tensor value in attributes for this Constant operator");
              }
              if (nodeProto.outputsLength() !== 1) {
                throw new Error("missing output or incorrect number of outputs for this Constant operator");
              }
              node.outputs.pop();
              node.executeNode = false;
              this._allData[dataIndex]._from = -1;
              this._allData[dataIndex].tensor = Tensor3.fromOrtTensor(nodeProto.attributes(0).t());
            }
          }
        }
        for (let i = 0; i < this._nodes.length; i++) {
          const node = this._nodes[i];
          const nodeProto = graph.nodes(i);
          if (nodeProto.inputsLength() === 0) {
            throw new Error(`missing input for node: ${nodeProto.name}`);
          }
          for (let j = 0; j < nodeProto.inputsLength(); j++) {
            const input = nodeProto.inputs(j);
            const dataIndex = dataIndices.get(input);
            if (typeof dataIndex === "undefined") {
              throw new Error(`unrecognized input '${input}' for node: ${nodeProto.name()}`);
            }
            node.inputs.push(dataIndex);
            this._allData[dataIndex]._to.push(i);
          }
        }
      }
      checkIsAcyclic() {
        const starters = /* @__PURE__ */ new Set();
        this._allInputIndices.forEach((i) => {
          const data = this._allData[i];
          data._to.forEach((j) => {
            starters.add(j);
          });
        });
        const nodesStack = Array.from(starters);
        const nodesState = new Array(this._nodes.length).fill("white");
        while (nodesStack.length > 0) {
          const nodeIndex = nodesStack.pop();
          if (nodesState[nodeIndex] === "gray") {
            nodesState[nodeIndex] = "black";
          } else {
            nodesStack.push(nodeIndex);
            nodesState[nodeIndex] = "gray";
            this._nodes[nodeIndex].outputs.forEach((outgoingEdgeIndex) => {
              const data = this._allData[outgoingEdgeIndex];
              if (typeof data.tensor !== "undefined") {
                throw new Error("node outputs should not be initialized");
              }
              if (data._from !== nodeIndex) {
                throw new Error("from property of the Value object doesn't match index of Node being processed");
              }
              data._to.forEach((downstreamNodeIndex) => {
                if (nodesState[downstreamNodeIndex] === "gray") {
                  throw new Error("model graph is cyclic");
                } else if (nodesState[downstreamNodeIndex] === "white") {
                  nodesStack.push(downstreamNodeIndex);
                }
              });
            });
          }
        }
      }
      transformGraph(graphInitializer) {
        this.removeAllIdentityNodes();
        this.removeAllDropoutNodes();
        this.fuseConvActivationNodes();
        if (graphInitializer) {
          graphInitializer.transformGraph(this);
        }
        this.finalizeGraph();
      }
      /**
       * finalize the graph.
       *
       * this function should be called after all the transformation completed.
       * this function removes all unnecessary nodes and values from the graph
       */
      finalizeGraph() {
        let offset = 0;
        const newIndices = new Array(this._nodes.length, 0);
        let nodePossition = 0;
        for (let i = 0; i < this._nodes.length; i++) {
          newIndices[i] = nodePossition;
          if (this._nodes[i].executeNode) {
            if (nodePossition !== i) {
              this._nodes[nodePossition] = this._nodes[i];
            }
            nodePossition++;
          } else {
            this._nodes[i].outputs.forEach((ind) => {
              this._allData[ind]._from = -2;
            });
          }
        }
        this._nodes.splice(nodePossition, this._nodes.length - nodePossition);
        for (let i = 0; i < this._allData.length; i++) {
          const currentData = this._allData[i];
          if (currentData._from !== void 0 && currentData._from !== -1 && currentData._from !== -2) {
            currentData._from = newIndices[currentData._from];
          }
          for (let j = 0; j < currentData._to.length; j++) {
            if (currentData._to[j] >= 0) {
              currentData._to[j] = newIndices[currentData._to[j]];
            } else {
              throw new Error("Trying to update a removed node");
            }
          }
        }
        offset = 0;
        for (let i = 0; i < this._allData.length; i++) {
          if (this._allData[i].from === -2 && this._allOutputIndices.indexOf(i + offset) === -1) {
            offset++;
            this._allData.splice(i, 1);
            i--;
            continue;
          }
          if (offset > 0) {
            let ind = -1;
            if (this._allData[i].from !== void 0 && this._allData[i].from !== -1) {
              ind = this._nodes[this._allData[i].from].outputs.indexOf(i + offset);
              if (ind !== -1) {
                this._nodes[this._allData[i].from].outputs[ind] = i;
              }
            } else {
              ind = this._allInputIndices.indexOf(i + offset);
              if (ind !== -1) {
                this._allInputIndices[ind] = i;
              }
            }
            this._allData[i].to.forEach((node) => {
              ind = this._nodes[node].inputs.indexOf(i + offset);
              if (ind !== -1) {
                this._nodes[node].inputs[ind] = i;
              }
            });
            if (this._allData[i].to.length === 0) {
              ind = this._allOutputIndices.indexOf(i + offset);
              if (ind !== -1) {
                this._allOutputIndices[ind] = i;
              }
            }
          }
        }
      }
      /**
       * Delete the specifed node. Assume the node has one incoming input and the first output connected to other nodes.
       * An input validation must be done before calling this function.
       * @param nodeIndex The index of node to be deleted
       */
      deleteNode(nodeIndex) {
        const node = this._nodes[nodeIndex];
        if (node.outputs.length > 1) {
          for (let i = 1; i < node.outputs.length; i++) {
            if (this._allData[node.outputs[i]].to.length > 0) {
              throw new Error("Node deletion with more than one output connected to other nodes is not supported. ");
            }
          }
        }
        node.executeNode = false;
        const inputValueIndex = node.inputs[0];
        const outputValueIndex = node.outputs[0];
        const nodesConsumingOutput = this._allData[outputValueIndex].to;
        for (let i = 0; i < node.inputs.length; i++) {
          const delIndex = this._allData[node.inputs[i]].to.indexOf(nodeIndex);
          if (delIndex === -1) {
            throw new Error("The Value object doesn't have the current Node in it's 'to' property ");
          }
          this._allData[node.inputs[i]].to.splice(delIndex, 1);
        }
        this._allData[outputValueIndex]._to = [];
        const index = this._allOutputIndices.indexOf(outputValueIndex);
        if (index !== -1) {
          this._allOutputIndices[index] = inputValueIndex;
        }
        if (nodesConsumingOutput && nodesConsumingOutput.length > 0) {
          for (const nodeIndex2 of nodesConsumingOutput) {
            const replaceIndex = this._nodes[nodeIndex2].inputs.indexOf(outputValueIndex);
            if (replaceIndex === -1) {
              throw new Error("The Node object doesn't have the output Value in it's 'inputs' property ");
            }
            this._nodes[nodeIndex2].inputs[replaceIndex] = inputValueIndex;
            this._allData[inputValueIndex].to.push(nodeIndex2);
          }
        }
      }
      removeAllDropoutNodes() {
        let nodeIndex = 0;
        for (const node of this._nodes) {
          if (node.opType === "Dropout") {
            if (node.inputs.length !== 1) {
              throw new Error("Dropout nodes should only contain one input. ");
            }
            if (node.outputs.length !== 1 && node.outputs.length !== 2) {
              throw new Error("Dropout nodes should contain either 1 or 2 output(s)");
            }
            if (node.outputs.length === 2 && this._allData[node.outputs[1]]._to.length !== 0) {
              throw new Error("Dropout nodes's second output should not be referenced by other nodes");
            }
            this.deleteNode(nodeIndex);
          }
          nodeIndex++;
        }
      }
      removeAllIdentityNodes() {
        let nodeIndex = 0;
        for (const node of this._nodes) {
          if (node.opType === "Identity") {
            this.deleteNode(nodeIndex);
          }
          nodeIndex++;
        }
      }
      isActivation(n) {
        switch (n.opType) {
          case "Relu":
          case "Sigmoid":
          case "Clip":
            return true;
          default:
            return false;
        }
      }
      fuseConvActivationNodes() {
        for (const node of this._nodes) {
          if (node.opType === "Conv") {
            const next = this._allData[node.outputs[0]]._to;
            if (next.length === 1 && this.isActivation(this._nodes[next[0]])) {
              const child = this._nodes[next[0]];
              if (child.opType === "Clip") {
                if (child.inputs.length === 1) {
                  try {
                    node.attributes.set(
                      "activation_params",
                      "floats",
                      [child.attributes.getFloat("min"), child.attributes.getFloat("max")]
                    );
                  } catch (e) {
                    node.attributes.set("activation_params", "floats", [MIN_CLIP, MAX_CLIP]);
                  }
                } else if (child.inputs.length >= 3 && this._allData[child.inputs[1]].tensor !== void 0 && this._allData[child.inputs[2]].tensor !== void 0) {
                  node.attributes.set("activation_params", "floats", [
                    this._allData[child.inputs[1]].tensor.floatData[0],
                    this._allData[child.inputs[2]].tensor.floatData[0]
                  ]);
                } else {
                  continue;
                }
              }
              node.attributes.set("activation", "string", child.opType);
              this.deleteNode(next[0]);
            }
          }
        }
      }
    };
  }
});

// web/lib/onnxjs/model.ts
var import_onnx5, ortFbs4, Model;
var init_model = __esm({
  "web/lib/onnxjs/model.ts"() {
    "use strict";
    init_flatbuffers();
    init_graph();
    init_ort_generated();
    import_onnx5 = __toESM(require_onnx());
    init_util();
    ortFbs4 = onnxruntime.experimental.fbs;
    Model = class {
      // empty model
      constructor() {
      }
      load(buf, graphInitializer, isOrtFormat) {
        let onnxError;
        if (!isOrtFormat) {
          try {
            this.loadFromOnnxFormat(buf, graphInitializer);
            return;
          } catch (e) {
            if (isOrtFormat !== void 0) {
              throw e;
            }
            onnxError = e;
          }
        }
        try {
          this.loadFromOrtFormat(buf, graphInitializer);
        } catch (e) {
          if (isOrtFormat !== void 0) {
            throw e;
          }
          throw new Error(`Failed to load model as ONNX format: ${onnxError}
as ORT format: ${e}`);
        }
      }
      loadFromOnnxFormat(buf, graphInitializer) {
        const modelProto = import_onnx5.onnx.ModelProto.decode(buf);
        const irVersion = LongUtil.longToNumber(modelProto.irVersion);
        if (irVersion < 3) {
          throw new Error("only support ONNX model with IR_VERSION>=3");
        }
        this._opsets = modelProto.opsetImport.map((i) => ({ domain: i.domain, version: LongUtil.longToNumber(i.version) }));
        this._graph = Graph.from(modelProto.graph, graphInitializer);
      }
      loadFromOrtFormat(buf, graphInitializer) {
        const fb = new flatbuffers.ByteBuffer(buf);
        const ortModel = ortFbs4.InferenceSession.getRootAsInferenceSession(fb).model();
        const irVersion = LongUtil.longToNumber(ortModel.irVersion());
        if (irVersion < 3) {
          throw new Error("only support ONNX model with IR_VERSION>=3");
        }
        this._opsets = [];
        for (let i = 0; i < ortModel.opsetImportLength(); i++) {
          const opsetId = ortModel.opsetImport(i);
          this._opsets.push({ domain: opsetId?.domain(), version: LongUtil.longToNumber(opsetId.version()) });
        }
        this._graph = Graph.from(ortModel.graph(), graphInitializer);
      }
      get graph() {
        return this._graph;
      }
      get opsets() {
        return this._opsets;
      }
    };
  }
});

// web/lib/onnxjs/session.ts
var Session;
var init_session = __esm({
  "web/lib/onnxjs/session.ts"() {
    "use strict";
    init_promises();
    init_backend2();
    init_execution_plan();
    init_instrument();
    init_model();
    Session = class {
      constructor(config = {}) {
        this._initialized = false;
        this.backendHint = config.backendHint;
        this.profiler = Profiler.create(config.profiler);
        this.context = { profiler: this.profiler, graphInputTypes: [], graphInputDims: [] };
      }
      get inputNames() {
        return this._model.graph.getInputNames();
      }
      get outputNames() {
        return this._model.graph.getOutputNames();
      }
      startProfiling() {
        this.profiler.start();
      }
      endProfiling() {
        this.profiler.stop();
      }
      async loadModel(arg, byteOffset, length) {
        await this.profiler.event("session", "Session.loadModel", async () => {
          const backend2 = await resolveBackend(this.backendHint);
          this.sessionHandler = backend2.createSessionHandler(this.context);
          this._model = new Model();
          if (typeof arg === "string") {
            const isOrtFormat = arg.endsWith(".ort");
            if (typeof process !== "undefined" && process.versions && process.versions.node) {
              const buf = await readFile(arg);
              this.initialize(buf, isOrtFormat);
            } else {
              const response = await fetch(arg);
              const buf = await response.arrayBuffer();
              this.initialize(new Uint8Array(buf), isOrtFormat);
            }
          } else if (!ArrayBuffer.isView(arg)) {
            const arr = new Uint8Array(arg, byteOffset || 0, length || arg.byteLength);
            this.initialize(arr);
          } else {
            this.initialize(arg);
          }
        });
      }
      initialize(modelProtoBlob, isOrtFormat) {
        if (this._initialized) {
          throw new Error("already initialized");
        }
        this.profiler.event("session", "Session.initialize", () => {
          const graphInitializer = this.sessionHandler.transformGraph ? this.sessionHandler : void 0;
          this._model.load(modelProtoBlob, graphInitializer, isOrtFormat);
          if (this.sessionHandler.onGraphInitialized) {
            this.sessionHandler.onGraphInitialized(this._model.graph);
          }
          this.initializeOps(this._model.graph);
          this._executionPlan = new ExecutionPlan(this._model.graph, this._ops, this.profiler);
        });
        this._initialized = true;
      }
      async run(inputs) {
        if (!this._initialized) {
          throw new Error("session not initialized yet");
        }
        return this.profiler.event("session", "Session.run", async () => {
          const inputTensors = this.normalizeAndValidateInputs(inputs);
          const outputTensors = await this._executionPlan.execute(this.sessionHandler, inputTensors);
          return this.createOutput(outputTensors);
        });
      }
      normalizeAndValidateInputs(inputs) {
        const modelInputNames = this._model.graph.getInputNames();
        if (Array.isArray(inputs)) {
          if (inputs.length !== modelInputNames.length) {
            throw new Error(`incorrect input array length: expected ${modelInputNames.length} but got ${inputs.length}`);
          }
        } else {
          if (inputs.size !== modelInputNames.length) {
            throw new Error(`incorrect input map size: expected ${modelInputNames.length} but got ${inputs.size}`);
          }
          const sortedInputs = new Array(inputs.size);
          let sortedInputsIndex = 0;
          for (let i = 0; i < modelInputNames.length; ++i) {
            const tensor = inputs.get(modelInputNames[i]);
            if (!tensor) {
              throw new Error(`missing input tensor for: '${name}'`);
            }
            sortedInputs[sortedInputsIndex++] = tensor;
          }
          inputs = sortedInputs;
        }
        if (!this.context.graphInputTypes || this.context.graphInputTypes.length === 0 || !this.context.graphInputDims || this.context.graphInputDims.length === 0) {
          const modelInputIndices = this._model.graph.getInputIndices();
          const modelValues = this._model.graph.getValues();
          const graphInputDims = new Array(modelInputIndices.length);
          for (let i = 0; i < modelInputIndices.length; ++i) {
            const graphInput = modelValues[modelInputIndices[i]];
            graphInputDims[i] = graphInput.type.shape.dims;
            this.context.graphInputTypes.push(graphInput.type.tensorType);
            this.context.graphInputDims.push(inputs[i].dims);
          }
          this.validateInputTensorDims(graphInputDims, inputs, true);
        } else {
          this.validateInputTensorDims(this.context.graphInputDims, inputs, false);
        }
        this.validateInputTensorTypes(this.context.graphInputTypes, inputs);
        return inputs;
      }
      validateInputTensorTypes(graphInputTypes, givenInputs) {
        for (let i = 0; i < givenInputs.length; i++) {
          const expectedType = graphInputTypes[i];
          const actualType = givenInputs[i].type;
          if (expectedType !== actualType) {
            throw new Error(`input tensor[${i}] check failed: expected type '${expectedType}' but got ${actualType}`);
          }
        }
      }
      validateInputTensorDims(graphInputDims, givenInputs, noneDimSupported) {
        for (let i = 0; i < givenInputs.length; i++) {
          const expectedDims = graphInputDims[i];
          const actualDims = givenInputs[i].dims;
          if (!this.compareTensorDims(expectedDims, actualDims, noneDimSupported)) {
            throw new Error(`input tensor[${i}] check failed: expected shape '[${expectedDims.join(",")}]' but got [${actualDims.join(",")}]`);
          }
        }
      }
      compareTensorDims(expectedDims, actualDims, noneDimSupported) {
        if (expectedDims.length !== actualDims.length) {
          return false;
        }
        for (let i = 0; i < expectedDims.length; ++i) {
          if (expectedDims[i] !== actualDims[i] && (!noneDimSupported || expectedDims[i] !== 0) && expectedDims[i] !== null) {
            return false;
          }
        }
        return true;
      }
      createOutput(outputTensors) {
        const modelOutputNames = this._model.graph.getOutputNames();
        if (outputTensors.length !== modelOutputNames.length) {
          throw new Error("expected number of outputs do not match number of generated outputs");
        }
        const output = /* @__PURE__ */ new Map();
        for (let i = 0; i < modelOutputNames.length; ++i) {
          output.set(modelOutputNames[i], outputTensors[i]);
        }
        return output;
      }
      initializeOps(graph) {
        const nodes = graph.getNodes();
        this._ops = new Array(nodes.length);
        for (let i = 0; i < nodes.length; i++) {
          this._ops[i] = this.sessionHandler.resolve(nodes[i], this._model.opsets, graph);
        }
      }
    };
  }
});

// web/lib/onnxjs/session-handler-inference.ts
var OnnxjsSessionHandler;
var init_session_handler_inference = __esm({
  "web/lib/onnxjs/session-handler-inference.ts"() {
    "use strict";
    init_esm();
    init_tensor2();
    OnnxjsSessionHandler = class {
      constructor(session) {
        this.session = session;
        this.inputNames = this.session.inputNames;
        this.outputNames = this.session.outputNames;
      }
      async dispose() {
      }
      async run(feeds, _fetches, _options) {
        const inputMap = /* @__PURE__ */ new Map();
        for (const name2 in feeds) {
          if (Object.hasOwnProperty.call(feeds, name2)) {
            const feed = feeds[name2];
            inputMap.set(
              name2,
              new Tensor3(
                feed.dims,
                feed.type,
                void 0,
                void 0,
                feed.data
              )
            );
          }
        }
        const outputMap = await this.session.run(inputMap);
        const output = {};
        outputMap.forEach((tensor, name2) => {
          output[name2] = new Tensor2(tensor.type, tensor.data, tensor.dims);
        });
        return output;
      }
      startProfiling() {
        this.session.startProfiling();
      }
      endProfiling() {
        this.session.endProfiling();
      }
    };
  }
});

// web/lib/backend-onnxjs.ts
var backend_onnxjs_exports = {};
__export(backend_onnxjs_exports, {
  onnxjsBackend: () => onnxjsBackend
});
var OnnxjsBackend, onnxjsBackend;
var init_backend_onnxjs = __esm({
  "web/lib/backend-onnxjs.ts"() {
    "use strict";
    init_session();
    init_session_handler_inference();
    OnnxjsBackend = class {
      // eslint-disable-next-line @typescript-eslint/no-empty-function
      async init() {
      }
      async createInferenceSessionHandler(pathOrBuffer, options) {
        const session = new Session(options);
        if (typeof pathOrBuffer === "string") {
          await session.loadModel(pathOrBuffer);
        } else {
          await session.loadModel(pathOrBuffer);
        }
        return new OnnxjsSessionHandler(session);
      }
    };
    onnxjsBackend = new OnnxjsBackend();
  }
});

// web/lib/index.ts
init_esm();
init_esm();
init_esm();

// web/lib/version.ts
var version2 = "1.18.0";

// web/lib/index.ts
var lib_default = esm_exports;
if (true) {
  const onnxjsBackend2 = (init_backend_onnxjs(), __toCommonJS(backend_onnxjs_exports)).onnxjsBackend;
  registerBackend("webgl", onnxjsBackend2, -10);
}
if (false) {
  const wasmBackend = true ? null.wasmBackend : null.wasmBackend;
  if (false) {
    registerBackend("webgpu", wasmBackend, 5);
    registerBackend("webnn", wasmBackend, 5);
  }
  registerBackend("cpu", wasmBackend, 10);
  registerBackend("wasm", wasmBackend, 10);
}
Object.defineProperty(env2.versions, "web", { value: version2, enumerable: true });
export {
  InferenceSession2 as InferenceSession,
  TRACE,
  TRACE_FUNC_BEGIN,
  TRACE_FUNC_END,
  Tensor2 as Tensor,
  TrainingSession2 as TrainingSession,
  lib_default as default,
  env2 as env,
  registerBackend
};
/*! Bundled license information:

long/index.js:
  (**
   * @license
   * Copyright 2009 The Closure Library Authors
   * Copyright 2020 Daniel Wirtz / The long.js Authors.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   *)
*/
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vLi4vLi4vY29tbW9uL2xpYi9iYWNrZW5kLWltcGwudHMiLCAiLi4vLi4vLi4vY29tbW9uL2xpYi9iYWNrZW5kLnRzIiwgIi4uLy4uLy4uL2NvbW1vbi9saWIvdmVyc2lvbi50cyIsICIuLi8uLi8uLi9jb21tb24vbGliL2Vudi1pbXBsLnRzIiwgIi4uLy4uLy4uL2NvbW1vbi9saWIvZW52LnRzIiwgIi4uLy4uLy4uL2NvbW1vbi9saWIvdGVuc29yLWNvbnZlcnNpb24taW1wbC50cyIsICIuLi8uLi8uLi9jb21tb24vbGliL3RlbnNvci1mYWN0b3J5LWltcGwudHMiLCAiLi4vLi4vLi4vY29tbW9uL2xpYi90ZW5zb3ItaW1wbC10eXBlLW1hcHBpbmcudHMiLCAiLi4vLi4vLi4vY29tbW9uL2xpYi90ZW5zb3ItdXRpbHMtaW1wbC50cyIsICIuLi8uLi8uLi9jb21tb24vbGliL3RlbnNvci1pbXBsLnRzIiwgIi4uLy4uLy4uL2NvbW1vbi9saWIvdGVuc29yLnRzIiwgIi4uLy4uLy4uL2NvbW1vbi9saWIvdHJhY2UudHMiLCAiLi4vLi4vLi4vY29tbW9uL2xpYi9pbmZlcmVuY2Utc2Vzc2lvbi1pbXBsLnRzIiwgIi4uLy4uLy4uL2NvbW1vbi9saWIvaW5mZXJlbmNlLXNlc3Npb24udHMiLCAiLi4vLi4vLi4vY29tbW9uL2xpYi90ZW5zb3ItY29udmVyc2lvbi50cyIsICIuLi8uLi8uLi9jb21tb24vbGliL3RlbnNvci1mYWN0b3J5LnRzIiwgIi4uLy4uLy4uL2NvbW1vbi9saWIvb25ueC1tb2RlbC50cyIsICIuLi8uLi8uLi9jb21tb24vbGliL29ubngtdmFsdWUudHMiLCAiLi4vLi4vLi4vY29tbW9uL2xpYi90cmFpbmluZy1zZXNzaW9uLWltcGwudHMiLCAiLi4vLi4vLi4vY29tbW9uL2xpYi90cmFpbmluZy1zZXNzaW9uLnRzIiwgIi4uLy4uLy4uL2NvbW1vbi9saWIvaW5kZXgudHMiLCAibm9kZWpzLWlnbm9yZTpub2RlOmZzL3Byb21pc2VzIiwgIi4uLy4uL2xpYi9vbm54anMvaW5zdHJ1bWVudC50cyIsICIuLi8uLi9saWIvb25ueGpzL29wc2V0LnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9ndWlkLXR5cGVzY3JpcHQvZGlzdC9ndWlkLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9sb25nL2luZGV4LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9mbGF0YnVmZmVycy9qcy9mbGF0YnVmZmVycy5tanMiLCAiLi4vLi4vbGliL29ubnhqcy9vcnQtc2NoZW1hL2ZsYXRidWZmZXJzL29ydC1nZW5lcmF0ZWQudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0Bwcm90b2J1ZmpzL2FzcHJvbWlzZS9pbmRleC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHByb3RvYnVmanMvYmFzZTY0L2luZGV4LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AcHJvdG9idWZqcy9ldmVudGVtaXR0ZXIvaW5kZXguanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0Bwcm90b2J1ZmpzL2Zsb2F0L2luZGV4LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AcHJvdG9idWZqcy9pbnF1aXJlL2luZGV4LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AcHJvdG9idWZqcy91dGY4L2luZGV4LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AcHJvdG9idWZqcy9wb29sL2luZGV4LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy91dGlsL2xvbmdiaXRzLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy91dGlsL21pbmltYWwuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3dyaXRlci5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvd3JpdGVyX2J1ZmZlci5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvcmVhZGVyLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9yZWFkZXJfYnVmZmVyLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9ycGMvc2VydmljZS5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvcnBjLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9yb290cy5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvaW5kZXgtbWluaW1hbC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9taW5pbWFsLmpzIiwgIi4uLy4uL2xpYi9vbm54anMvb3J0LXNjaGVtYS9wcm90b2J1Zi9vbm54LmpzIiwgIi4uLy4uL2xpYi9vbm54anMvdXRpbC50cyIsICIuLi8uLi9saWIvb25ueGpzL3RlbnNvci50cyIsICIuLi8uLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL2dsc2wtc291cmNlLnRzIiwgIi4uLy4uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvdHlwZXMudHMiLCAiLi4vLi4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC91dGlscy50cyIsICIuLi8uLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL29wcy9wYWNraW5nLXV0aWxzLnRzIiwgIi4uLy4uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvb3BzL3BhY2sudHMiLCAiLi4vLi4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC9vcHMvcmVzaGFwZS1wYWNrZWQudHMiLCAiLi4vLi4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC9vcHMvdWludDgtZW5jb2RlLnRzIiwgIi4uLy4uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvb3BzL3VucGFjay50cyIsICIuLi8uLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL3RleHR1cmUtZGF0YS1lbmNvZGVyLnRzIiwgIi4uLy4uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvdGV4dHVyZS1sYXlvdXQudHMiLCAiLi4vLi4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC9pbmZlcmVuY2UtaGFuZGxlci50cyIsICIuLi8uLi9saWIvb25ueGpzL2F0dHJpYnV0ZS13aXRoLWNhY2hlLWtleS50cyIsICIuLi8uLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL29wcy9iYXRjaC1ub3JtYWxpemF0aW9uLnRzIiwgIi4uLy4uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvZ2xzbC1kZWZpbml0aW9ucy50cyIsICIuLi8uLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL29wcy9iaW5hcnktb3AudHMiLCAiLi4vLi4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC9vcHMvY2FzdC50cyIsICIuLi8uLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL29wcy9jb25jYXQtcGFja2VkLnRzIiwgIi4uLy4uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvb3BzL2NvbmNhdC50cyIsICIuLi8uLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL29wcy91bmFyeS1vcC50cyIsICIuLi8uLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL29wcy9mdXNlLXV0aWxzLnRzIiwgIi4uLy4uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvb3BzL2NvbnYtZ3JvdXBlZC50cyIsICIuLi8uLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL29wcy9pbTJjb2wtcGFjay50cyIsICIuLi8uLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL29wcy9tYXRtdWwudHMiLCAiLi4vLi4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC9vcHMvbWF0bXVsLXBhY2sudHMiLCAiLi4vLi4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC9vcHMvY29udi1wYWNrLnRzIiwgIi4uLy4uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvb3BzL2ltMmNvbC50cyIsICIuLi8uLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL29wcy9kb3QtcHJvZHVjdC50cyIsICIuLi8uLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL29wcy9jb252LnRzIiwgIi4uLy4uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvb3BzL2NvbnYtdHJhbnNwb3NlLnRzIiwgIi4uLy4uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvb3BzL3RyYW5zcG9zZS50cyIsICIuLi8uLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL29wcy9kZXB0aC10by1zcGFjZS50cyIsICIuLi8uLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL29wcy9mbGF0dGVuLnRzIiwgIi4uLy4uL2xpYi9vbm54anMvb3BlcmF0b3JzLnRzIiwgIi4uLy4uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvb3BzL2dhdGhlci50cyIsICIuLi8uLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL29wcy9nZW1tLnRzIiwgIi4uLy4uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvb3BzL2ltYWdlLXNjYWxlci50cyIsICIuLi8uLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL29wcy9pbnN0YW5jZS1ub3JtYWxpemF0aW9uLnRzIiwgIi4uLy4uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvb3BzL2xybi50cyIsICIuLi8uLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL29wcy9wYWQudHMiLCAiLi4vLi4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC9vcHMvcG9vbC50cyIsICIuLi8uLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL29wcy9yZWR1Y2UudHMiLCAiLi4vLi4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC9vcHMvcmVzaGFwZS50cyIsICIuLi8uLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL29wcy91cHNhbXBsZS50cyIsICIuLi8uLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL29wcy9yZXNpemUtcGFja2VkLnRzIiwgIi4uLy4uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvb3BzL3NoYXBlLnRzIiwgIi4uLy4uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvb3BzL3NsaWNlLnRzIiwgIi4uLy4uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvb3BzL3NvZnRtYXgudHMiLCAiLi4vLi4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC9vcHMvc3BsaXQudHMiLCAiLi4vLi4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC9vcHMvc3F1ZWV6ZS50cyIsICIuLi8uLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL29wcy9zdW0udHMiLCAiLi4vLi4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC9vcHMvdGlsZS50cyIsICIuLi8uLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL29wcy91bnNxdWVlemUudHMiLCAiLi4vLi4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC9vcC1yZXNvbHZlLXJ1bGVzLnRzIiwgIi4uLy4uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvZ2xzbC1mdW5jdGlvbi1pbmxpbmVyLnRzIiwgIi4uLy4uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvdGV4dHVyZS1sYXlvdXQtc3RyYXRlZ3kudHMiLCAiLi4vLi4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC9nbHNsLWNvb3JkaW5hdGUtbGliLnRzIiwgIi4uLy4uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvZ2xzbC1lbmNvZGluZy1saWIudHMiLCAiLi4vLi4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC9nbHNsLWZyYWdjb2xvci1saWIudHMiLCAiLi4vLi4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC9nbHNsLXNoYXBlLXV0aWxzLWxpYi50cyIsICIuLi8uLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL2dsc2wtdmVjLWxpYi50cyIsICIuLi8uLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL2dsc2wtcmVnaXN0ZXJlZC1saWJzLnRzIiwgIi4uLy4uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvZ2xzbC1wcmVwcm9jZXNzb3IudHMiLCAiLi4vLi4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC9wcm9ncmFtLW1hbmFnZXIudHMiLCAiLi4vLi4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC90ZXh0dXJlLW1hbmFnZXIudHMiLCAiLi4vLi4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC9zZXNzaW9uLWhhbmRsZXIudHMiLCAiLi4vLi4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC93ZWJnbC1jb250ZXh0LnRzIiwgIi4uLy4uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvd2ViZ2wtY29udGV4dC1mYWN0b3J5LnRzIiwgIi4uLy4uL2xpYi9vbm54anMvYmFja2VuZHMvYmFja2VuZC13ZWJnbC50cyIsICIuLi8uLi9saWIvb25ueGpzL2JhY2tlbmQudHMiLCAiLi4vLi4vbGliL29ubnhqcy9leGVjdXRpb24tcGxhbi50cyIsICIuLi8uLi9saWIvb25ueGpzL2F0dHJpYnV0ZS50cyIsICIuLi8uLi9saWIvb25ueGpzL2dyYXBoLnRzIiwgIi4uLy4uL2xpYi9vbm54anMvbW9kZWwudHMiLCAiLi4vLi4vbGliL29ubnhqcy9zZXNzaW9uLnRzIiwgIi4uLy4uL2xpYi9vbm54anMvc2Vzc2lvbi1oYW5kbGVyLWluZmVyZW5jZS50cyIsICIuLi8uLi9saWIvYmFja2VuZC1vbm54anMudHMiLCAiLi4vLi4vbGliL2luZGV4LnRzIiwgIi4uLy4uL2xpYi92ZXJzaW9uLnRzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtCYWNrZW5kfSBmcm9tICcuL2JhY2tlbmQuanMnO1xuaW1wb3J0IHtJbmZlcmVuY2VTZXNzaW9ufSBmcm9tICcuL2luZmVyZW5jZS1zZXNzaW9uLmpzJztcblxuaW50ZXJmYWNlIEJhY2tlbmRJbmZvIHtcbiAgYmFja2VuZDogQmFja2VuZDtcbiAgcHJpb3JpdHk6IG51bWJlcjtcblxuICBpbml0UHJvbWlzZT86IFByb21pc2U8dm9pZD47XG4gIGluaXRpYWxpemVkPzogYm9vbGVhbjtcbiAgYWJvcnRlZD86IGJvb2xlYW47XG4gIGVycm9yPzogc3RyaW5nO1xufVxuXG5jb25zdCBiYWNrZW5kczogTWFwPHN0cmluZywgQmFja2VuZEluZm8+ID0gbmV3IE1hcCgpO1xuY29uc3QgYmFja2VuZHNTb3J0ZWRCeVByaW9yaXR5OiBzdHJpbmdbXSA9IFtdO1xuXG4vKipcbiAqIFJlZ2lzdGVyIGEgYmFja2VuZC5cbiAqXG4gKiBAcGFyYW0gbmFtZSAtIHRoZSBuYW1lIGFzIGEga2V5IHRvIGxvb2t1cCBhcyBhbiBleGVjdXRpb24gcHJvdmlkZXIuXG4gKiBAcGFyYW0gYmFja2VuZCAtIHRoZSBiYWNrZW5kIG9iamVjdC5cbiAqIEBwYXJhbSBwcmlvcml0eSAtIGFuIGludGVnZXIgaW5kaWNhdGluZyB0aGUgcHJpb3JpdHkgb2YgdGhlIGJhY2tlbmQuIEhpZ2hlciBudW1iZXIgbWVhbnMgaGlnaGVyIHByaW9yaXR5LiBpZiBwcmlvcml0eVxuICogPCAwLCBpdCB3aWxsIGJlIGNvbnNpZGVyZWQgYXMgYSAnYmV0YScgdmVyc2lvbiBhbmQgd2lsbCBub3QgYmUgdXNlZCBhcyBhIGZhbGxiYWNrIGJhY2tlbmQgYnkgZGVmYXVsdC5cbiAqXG4gKiBAaWdub3JlXG4gKi9cbmV4cG9ydCBjb25zdCByZWdpc3RlckJhY2tlbmQgPSAobmFtZTogc3RyaW5nLCBiYWNrZW5kOiBCYWNrZW5kLCBwcmlvcml0eTogbnVtYmVyKTogdm9pZCA9PiB7XG4gIGlmIChiYWNrZW5kICYmIHR5cGVvZiBiYWNrZW5kLmluaXQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGJhY2tlbmQuY3JlYXRlSW5mZXJlbmNlU2Vzc2lvbkhhbmRsZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjb25zdCBjdXJyZW50QmFja2VuZCA9IGJhY2tlbmRzLmdldChuYW1lKTtcbiAgICBpZiAoY3VycmVudEJhY2tlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgYmFja2VuZHMuc2V0KG5hbWUsIHtiYWNrZW5kLCBwcmlvcml0eX0pO1xuICAgIH0gZWxzZSBpZiAoY3VycmVudEJhY2tlbmQucHJpb3JpdHkgPiBwcmlvcml0eSkge1xuICAgICAgLy8gc2FtZSBuYW1lIGlzIGFscmVhZHkgcmVnaXN0ZXJlZCB3aXRoIGEgaGlnaGVyIHByaW9yaXR5LiBza2lwIHJlZ2lzdGVyYXRpb24uXG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmIChjdXJyZW50QmFja2VuZC5wcmlvcml0eSA9PT0gcHJpb3JpdHkpIHtcbiAgICAgIGlmIChjdXJyZW50QmFja2VuZC5iYWNrZW5kICE9PSBiYWNrZW5kKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgY2Fubm90IHJlZ2lzdGVyIGJhY2tlbmQgXCIke25hbWV9XCIgdXNpbmcgcHJpb3JpdHkgJHtwcmlvcml0eX1gKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocHJpb3JpdHkgPj0gMCkge1xuICAgICAgY29uc3QgaSA9IGJhY2tlbmRzU29ydGVkQnlQcmlvcml0eS5pbmRleE9mKG5hbWUpO1xuICAgICAgaWYgKGkgIT09IC0xKSB7XG4gICAgICAgIGJhY2tlbmRzU29ydGVkQnlQcmlvcml0eS5zcGxpY2UoaSwgMSk7XG4gICAgICB9XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmFja2VuZHNTb3J0ZWRCeVByaW9yaXR5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChiYWNrZW5kcy5nZXQoYmFja2VuZHNTb3J0ZWRCeVByaW9yaXR5W2ldKSEucHJpb3JpdHkgPD0gcHJpb3JpdHkpIHtcbiAgICAgICAgICBiYWNrZW5kc1NvcnRlZEJ5UHJpb3JpdHkuc3BsaWNlKGksIDAsIG5hbWUpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYmFja2VuZHNTb3J0ZWRCeVByaW9yaXR5LnB1c2gobmFtZSk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ25vdCBhIHZhbGlkIGJhY2tlbmQnKTtcbn07XG5cbi8qKlxuICogVHJ5IHRvIHJlc29sdmUgYW5kIGluaXRpYWxpemUgYSBiYWNrZW5kLlxuICpcbiAqIEBwYXJhbSBiYWNrZW5kTmFtZSAtIHRoZSBuYW1lIG9mIHRoZSBiYWNrZW5kLlxuICogQHJldHVybnMgdGhlIGJhY2tlbmQgaW5zdGFuY2UgaWYgcmVzb2x2ZWQgYW5kIGluaXRpYWxpemVkIHN1Y2Nlc3NmdWxseSwgb3IgYW4gZXJyb3IgbWVzc2FnZSBpZiBmYWlsZWQuXG4gKi9cbmNvbnN0IHRyeVJlc29sdmVBbmRJbml0aWFsaXplQmFja2VuZCA9IGFzeW5jKGJhY2tlbmROYW1lOiBzdHJpbmcpOiBQcm9taXNlPEJhY2tlbmR8c3RyaW5nPiA9PiB7XG4gIGNvbnN0IGJhY2tlbmRJbmZvID0gYmFja2VuZHMuZ2V0KGJhY2tlbmROYW1lKTtcbiAgaWYgKCFiYWNrZW5kSW5mbykge1xuICAgIHJldHVybiAnYmFja2VuZCBub3QgZm91bmQuJztcbiAgfVxuXG4gIGlmIChiYWNrZW5kSW5mby5pbml0aWFsaXplZCkge1xuICAgIHJldHVybiBiYWNrZW5kSW5mby5iYWNrZW5kO1xuICB9IGVsc2UgaWYgKGJhY2tlbmRJbmZvLmFib3J0ZWQpIHtcbiAgICByZXR1cm4gYmFja2VuZEluZm8uZXJyb3IhO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGlzSW5pdGlhbGl6aW5nID0gISFiYWNrZW5kSW5mby5pbml0UHJvbWlzZTtcbiAgICB0cnkge1xuICAgICAgaWYgKCFpc0luaXRpYWxpemluZykge1xuICAgICAgICBiYWNrZW5kSW5mby5pbml0UHJvbWlzZSA9IGJhY2tlbmRJbmZvLmJhY2tlbmQuaW5pdChiYWNrZW5kTmFtZSk7XG4gICAgICB9XG4gICAgICBhd2FpdCBiYWNrZW5kSW5mby5pbml0UHJvbWlzZTtcbiAgICAgIGJhY2tlbmRJbmZvLmluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgIHJldHVybiBiYWNrZW5kSW5mby5iYWNrZW5kO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmICghaXNJbml0aWFsaXppbmcpIHtcbiAgICAgICAgYmFja2VuZEluZm8uZXJyb3IgPSBgJHtlfWA7XG4gICAgICAgIGJhY2tlbmRJbmZvLmFib3J0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhY2tlbmRJbmZvLmVycm9yITtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgZGVsZXRlIGJhY2tlbmRJbmZvLmluaXRQcm9taXNlO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBSZXNvbHZlIGV4ZWN1dGlvbiBwcm92aWRlcnMgZnJvbSB0aGUgc3BlY2lmaWMgc2Vzc2lvbiBvcHRpb25zLlxuICpcbiAqIEBwYXJhbSBvcHRpb25zIC0gdGhlIHNlc3Npb24gb3B0aW9ucyBvYmplY3QuXG4gKiBAcmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIHR1cGxlIG9mIGFuIGluaXRpYWxpemVkIGJhY2tlbmQgaW5zdGFuY2UgYW5kIGEgc2Vzc2lvbiBvcHRpb25zIG9iamVjdCB3aXRoXG4gKiBmaWx0ZXJlZCBFUCBsaXN0LlxuICpcbiAqIEBpZ25vcmVcbiAqL1xuZXhwb3J0IGNvbnN0IHJlc29sdmVCYWNrZW5kQW5kRXhlY3V0aW9uUHJvdmlkZXJzID0gYXN5bmMob3B0aW9uczogSW5mZXJlbmNlU2Vzc2lvbi5TZXNzaW9uT3B0aW9ucyk6XG4gICAgUHJvbWlzZTxbYmFja2VuZDogQmFja2VuZCwgb3B0aW9uczogSW5mZXJlbmNlU2Vzc2lvbi5TZXNzaW9uT3B0aW9uc10+ID0+IHtcbiAgICAgIC8vIGV4dHJhY3QgYmFja2VuZCBoaW50cyBmcm9tIHNlc3Npb24gb3B0aW9uc1xuICAgICAgY29uc3QgZXBzID0gb3B0aW9ucy5leGVjdXRpb25Qcm92aWRlcnMgfHwgW107XG4gICAgICBjb25zdCBiYWNrZW5kSGludHMgPSBlcHMubWFwKGkgPT4gdHlwZW9mIGkgPT09ICdzdHJpbmcnID8gaSA6IGkubmFtZSk7XG4gICAgICBjb25zdCBiYWNrZW5kTmFtZXMgPSBiYWNrZW5kSGludHMubGVuZ3RoID09PSAwID8gYmFja2VuZHNTb3J0ZWRCeVByaW9yaXR5IDogYmFja2VuZEhpbnRzO1xuXG4gICAgICAvLyB0cnkgdG8gcmVzb2x2ZSBhbmQgaW5pdGlhbGl6ZSBhbGwgcmVxdWVzdGVkIGJhY2tlbmRzXG4gICAgICBsZXQgYmFja2VuZDogQmFja2VuZHx1bmRlZmluZWQ7XG4gICAgICBjb25zdCBlcnJvcnMgPSBbXTtcbiAgICAgIGNvbnN0IGF2YWlsYWJsZUJhY2tlbmROYW1lcyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICAgICAgZm9yIChjb25zdCBiYWNrZW5kTmFtZSBvZiBiYWNrZW5kTmFtZXMpIHtcbiAgICAgICAgY29uc3QgcmVzb2x2ZVJlc3VsdCA9IGF3YWl0IHRyeVJlc29sdmVBbmRJbml0aWFsaXplQmFja2VuZChiYWNrZW5kTmFtZSk7XG4gICAgICAgIGlmICh0eXBlb2YgcmVzb2x2ZVJlc3VsdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBlcnJvcnMucHVzaCh7bmFtZTogYmFja2VuZE5hbWUsIGVycjogcmVzb2x2ZVJlc3VsdH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICghYmFja2VuZCkge1xuICAgICAgICAgICAgYmFja2VuZCA9IHJlc29sdmVSZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChiYWNrZW5kID09PSByZXNvbHZlUmVzdWx0KSB7XG4gICAgICAgICAgICBhdmFpbGFibGVCYWNrZW5kTmFtZXMuYWRkKGJhY2tlbmROYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gaWYgbm8gYmFja2VuZCBpcyBhdmFpbGFibGUsIHRocm93IGVycm9yLlxuICAgICAgaWYgKCFiYWNrZW5kKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgbm8gYXZhaWxhYmxlIGJhY2tlbmQgZm91bmQuIEVSUjogJHtlcnJvcnMubWFwKGUgPT4gYFske2UubmFtZX1dICR7ZS5lcnJ9YCkuam9pbignLCAnKX1gKTtcbiAgICAgIH1cblxuICAgICAgLy8gZm9yIGVhY2ggZXhwbGljaXRseSByZXF1ZXN0ZWQgYmFja2VuZCwgaWYgaXQncyBub3QgYXZhaWxhYmxlLCBvdXRwdXQgd2FybmluZyBtZXNzYWdlLlxuICAgICAgZm9yIChjb25zdCB7bmFtZSwgZXJyfSBvZiBlcnJvcnMpIHtcbiAgICAgICAgaWYgKGJhY2tlbmRIaW50cy5pbmNsdWRlcyhuYW1lKSkge1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgY29uc29sZS53YXJuKGByZW1vdmluZyByZXF1ZXN0ZWQgZXhlY3V0aW9uIHByb3ZpZGVyIFwiJHtcbiAgICAgICAgICAgICAgbmFtZX1cIiBmcm9tIHNlc3Npb24gb3B0aW9ucyBiZWNhdXNlIGl0IGlzIG5vdCBhdmFpbGFibGU6ICR7ZXJyfWApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGZpbHRlcmVkRXBzID0gZXBzLmZpbHRlcihpID0+IGF2YWlsYWJsZUJhY2tlbmROYW1lcy5oYXModHlwZW9mIGkgPT09ICdzdHJpbmcnID8gaSA6IGkubmFtZSkpO1xuXG4gICAgICByZXR1cm4gW1xuICAgICAgICBiYWNrZW5kLCBuZXcgUHJveHkob3B0aW9ucywge1xuICAgICAgICAgIGdldDogKHRhcmdldCwgcHJvcCkgPT4ge1xuICAgICAgICAgICAgaWYgKHByb3AgPT09ICdleGVjdXRpb25Qcm92aWRlcnMnKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmaWx0ZXJlZEVwcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBSZWZsZWN0LmdldCh0YXJnZXQsIHByb3ApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIF07XG4gICAgfTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtJbmZlcmVuY2VTZXNzaW9ufSBmcm9tICcuL2luZmVyZW5jZS1zZXNzaW9uLmpzJztcbmltcG9ydCB7T25ueFZhbHVlfSBmcm9tICcuL29ubngtdmFsdWUuanMnO1xuaW1wb3J0IHtUcmFpbmluZ1Nlc3Npb259IGZyb20gJy4vdHJhaW5pbmctc2Vzc2lvbi5qcyc7XG5cbi8qKlxuICogQGlnbm9yZVxuICovXG5leHBvcnQgZGVjbGFyZSBuYW1lc3BhY2UgU2Vzc2lvbkhhbmRsZXIge1xuICB0eXBlIEZlZWRzVHlwZSA9IHtbbmFtZTogc3RyaW5nXTogT25ueFZhbHVlfTtcbiAgdHlwZSBGZXRjaGVzVHlwZSA9IHtbbmFtZTogc3RyaW5nXTogT25ueFZhbHVlIHwgbnVsbH07XG4gIHR5cGUgUmV0dXJuVHlwZSA9IHtbbmFtZTogc3RyaW5nXTogT25ueFZhbHVlfTtcbn1cblxuLyoqXG4gKiBSZXByZXNlbnRzIHNoYXJlZCBTZXNzaW9uSGFuZGxlciBmdW5jdGlvbmFsaXR5XG4gKlxuICogQGlnbm9yZVxuICovXG5pbnRlcmZhY2UgU2Vzc2lvbkhhbmRsZXIge1xuICBkaXNwb3NlKCk6IFByb21pc2U8dm9pZD47XG5cbiAgcmVhZG9ubHkgaW5wdXROYW1lczogcmVhZG9ubHkgc3RyaW5nW107XG4gIHJlYWRvbmx5IG91dHB1dE5hbWVzOiByZWFkb25seSBzdHJpbmdbXTtcbn1cblxuLyoqXG4gKiBSZXByZXNlbnQgYSBoYW5kbGVyIGluc3RhbmNlIG9mIGFuIGluZmVyZW5jZSBzZXNzaW9uLlxuICpcbiAqIEBpZ25vcmVcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBJbmZlcmVuY2VTZXNzaW9uSGFuZGxlciBleHRlbmRzIFNlc3Npb25IYW5kbGVyIHtcbiAgc3RhcnRQcm9maWxpbmcoKTogdm9pZDtcbiAgZW5kUHJvZmlsaW5nKCk6IHZvaWQ7XG5cbiAgcnVuKGZlZWRzOiBTZXNzaW9uSGFuZGxlci5GZWVkc1R5cGUsIGZldGNoZXM6IFNlc3Npb25IYW5kbGVyLkZldGNoZXNUeXBlLFxuICAgICAgb3B0aW9uczogSW5mZXJlbmNlU2Vzc2lvbi5SdW5PcHRpb25zKTogUHJvbWlzZTxTZXNzaW9uSGFuZGxlci5SZXR1cm5UeXBlPjtcbn1cblxuLyoqXG4gKiBSZXByZXNlbnQgYSBoYW5kbGVyIGluc3RhbmNlIG9mIGEgdHJhaW5pbmcgaW5mZXJlbmNlIHNlc3Npb24uXG4gKlxuICogQGlnbm9yZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIFRyYWluaW5nU2Vzc2lvbkhhbmRsZXIgZXh0ZW5kcyBTZXNzaW9uSGFuZGxlciB7XG4gIHJlYWRvbmx5IGV2YWxJbnB1dE5hbWVzOiByZWFkb25seSBzdHJpbmdbXTtcbiAgcmVhZG9ubHkgZXZhbE91dHB1dE5hbWVzOiByZWFkb25seSBzdHJpbmdbXTtcblxuICBsYXp5UmVzZXRHcmFkKCk6IFByb21pc2U8dm9pZD47XG4gIHJ1blRyYWluU3RlcChcbiAgICAgIGZlZWRzOiBTZXNzaW9uSGFuZGxlci5GZWVkc1R5cGUsIGZldGNoZXM6IFNlc3Npb25IYW5kbGVyLkZldGNoZXNUeXBlLFxuICAgICAgb3B0aW9uczogSW5mZXJlbmNlU2Vzc2lvbi5SdW5PcHRpb25zKTogUHJvbWlzZTxTZXNzaW9uSGFuZGxlci5SZXR1cm5UeXBlPjtcbiAgcnVuT3B0aW1pemVyU3RlcChvcHRpb25zOiBJbmZlcmVuY2VTZXNzaW9uLlJ1bk9wdGlvbnMpOiBQcm9taXNlPHZvaWQ+O1xuICBydW5FdmFsU3RlcChcbiAgICAgIGZlZWRzOiBTZXNzaW9uSGFuZGxlci5GZWVkc1R5cGUsIGZldGNoZXM6IFNlc3Npb25IYW5kbGVyLkZldGNoZXNUeXBlLFxuICAgICAgb3B0aW9uczogSW5mZXJlbmNlU2Vzc2lvbi5SdW5PcHRpb25zKTogUHJvbWlzZTxTZXNzaW9uSGFuZGxlci5SZXR1cm5UeXBlPjtcblxuICBnZXRQYXJhbWV0ZXJzU2l6ZSh0cmFpbmFibGVPbmx5OiBib29sZWFuKTogUHJvbWlzZTxudW1iZXI+O1xuICBsb2FkUGFyYW1ldGVyc0J1ZmZlcihidWZmZXI6IFVpbnQ4QXJyYXksIHRyYWluYWJsZU9ubHk6IGJvb2xlYW4pOiBQcm9taXNlPHZvaWQ+O1xuICBnZXRDb250aWd1b3VzUGFyYW1ldGVycyh0cmFpbmFibGVPbmx5OiBib29sZWFuKTogUHJvbWlzZTxPbm54VmFsdWU+O1xufVxuXG4vKipcbiAqIFJlcHJlc2VudCBhIGJhY2tlbmQgdGhhdCBwcm92aWRlcyBpbXBsZW1lbnRhdGlvbiBvZiBtb2RlbCBpbmZlcmVuY2luZy5cbiAqXG4gKiBAaWdub3JlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQmFja2VuZCB7XG4gIC8qKlxuICAgKiBJbml0aWFsaXplIHRoZSBiYWNrZW5kIGFzeW5jaHJvbm91c2x5LiBTaG91bGQgdGhyb3cgd2hlbiBmYWlsZWQuXG4gICAqL1xuICBpbml0KGJhY2tlbmROYW1lOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+O1xuXG4gIGNyZWF0ZUluZmVyZW5jZVNlc3Npb25IYW5kbGVyKHVyaU9yQnVmZmVyOiBzdHJpbmd8VWludDhBcnJheSwgb3B0aW9ucz86IEluZmVyZW5jZVNlc3Npb24uU2Vzc2lvbk9wdGlvbnMpOlxuICAgICAgUHJvbWlzZTxJbmZlcmVuY2VTZXNzaW9uSGFuZGxlcj47XG5cbiAgY3JlYXRlVHJhaW5pbmdTZXNzaW9uSGFuZGxlcj9cbiAgICAgIChjaGVja3BvaW50U3RhdGVVcmlPckJ1ZmZlcjogVHJhaW5pbmdTZXNzaW9uLlVyaU9yQnVmZmVyLCB0cmFpbk1vZGVsVXJpT3JCdWZmZXI6IFRyYWluaW5nU2Vzc2lvbi5VcmlPckJ1ZmZlcixcbiAgICAgICBldmFsTW9kZWxVcmlPckJ1ZmZlcjogVHJhaW5pbmdTZXNzaW9uLlVyaU9yQnVmZmVyLCBvcHRpbWl6ZXJNb2RlbFVyaU9yQnVmZmVyOiBUcmFpbmluZ1Nlc3Npb24uVXJpT3JCdWZmZXIsXG4gICAgICAgb3B0aW9uczogSW5mZXJlbmNlU2Vzc2lvbi5TZXNzaW9uT3B0aW9ucyk6IFByb21pc2U8VHJhaW5pbmdTZXNzaW9uSGFuZGxlcj47XG59XG5cbmV4cG9ydCB7cmVnaXN0ZXJCYWNrZW5kfSBmcm9tICcuL2JhY2tlbmQtaW1wbC5qcyc7XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbi8vIFRoaXMgZmlsZSBpcyBnZW5lcmF0ZWQgYnkgL2pzL3NjcmlwdHMvdXBkYXRlLXZlcnNpb24udHNcbi8vIERvIG5vdCBtb2RpZnkgZmlsZSBjb250ZW50IG1hbnVhbGx5LlxuXG5leHBvcnQgY29uc3QgdmVyc2lvbiA9ICcxLjE4LjAnO1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0Vudn0gZnJvbSAnLi9lbnYuanMnO1xuaW1wb3J0IHt2ZXJzaW9ufSBmcm9tICcuL3ZlcnNpb24uanMnO1xuXG50eXBlIExvZ0xldmVsVHlwZSA9IEVudlsnbG9nTGV2ZWwnXTtcblxubGV0IGxvZ0xldmVsVmFsdWU6IFJlcXVpcmVkPExvZ0xldmVsVHlwZT4gPSAnd2FybmluZyc7XG5cbmV4cG9ydCBjb25zdCBlbnY6IEVudiA9IHtcbiAgd2FzbToge30gYXMgRW52LldlYkFzc2VtYmx5RmxhZ3MsXG4gIHdlYmdsOiB7fSBhcyBFbnYuV2ViR0xGbGFncyxcbiAgd2ViZ3B1OiB7fSBhcyBFbnYuV2ViR3B1RmxhZ3MsXG4gIHZlcnNpb25zOiB7Y29tbW9uOiB2ZXJzaW9ufSxcblxuICBzZXQgbG9nTGV2ZWwodmFsdWU6IExvZ0xldmVsVHlwZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnIHx8IFsndmVyYm9zZScsICdpbmZvJywgJ3dhcm5pbmcnLCAnZXJyb3InLCAnZmF0YWwnXS5pbmRleE9mKHZhbHVlKSA9PT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgbG9nZ2luZyBsZXZlbDogJHt2YWx1ZX1gKTtcbiAgICB9XG4gICAgbG9nTGV2ZWxWYWx1ZSA9IHZhbHVlO1xuICB9LFxuICBnZXQgbG9nTGV2ZWwoKTogUmVxdWlyZWQ8TG9nTGV2ZWxUeXBlPiB7XG4gICAgcmV0dXJuIGxvZ0xldmVsVmFsdWU7XG4gIH0sXG59O1xuXG4vLyBzZXQgcHJvcGVydHkgJ2xvZ0xldmVsJyBzbyB0aGF0IHRoZXkgY2FuIGJlIGNvcnJlY3RseSB0cmFuc2ZlcnJlZCB0byB3b3JrZXIgYnkgYHBvc3RNZXNzYWdlKClgLlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGVudiwgJ2xvZ0xldmVsJywge2VudW1lcmFibGU6IHRydWV9KTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtlbnYgYXMgZW52SW1wbH0gZnJvbSAnLi9lbnYtaW1wbC5qcyc7XG5cbmV4cG9ydCBkZWNsYXJlIG5hbWVzcGFjZSBFbnYge1xuICBleHBvcnQgdHlwZSBXYXNtUHJlZml4T3JGaWxlUGF0aHMgPSBzdHJpbmd8e1xuICAgIC8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvbiAqL1xuICAgICdvcnQtd2FzbS53YXNtJz86IHN0cmluZztcbiAgICAnb3J0LXdhc20tdGhyZWFkZWQud2FzbSc/OiBzdHJpbmc7XG4gICAgJ29ydC13YXNtLXNpbWQud2FzbSc/OiBzdHJpbmc7XG4gICAgJ29ydC10cmFpbmluZy13YXNtLXNpbWQud2FzbSc/OiBzdHJpbmc7XG4gICAgJ29ydC13YXNtLXNpbWQtdGhyZWFkZWQud2FzbSc/OiBzdHJpbmc7XG4gICAgLyogZXNsaW50LWVuYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb24gKi9cbiAgfTtcbiAgZXhwb3J0IGludGVyZmFjZSBXZWJBc3NlbWJseUZsYWdzIHtcbiAgICAvKipcbiAgICAgKiBzZXQgb3IgZ2V0IG51bWJlciBvZiB0aHJlYWQocykuIElmIG9taXR0ZWQgb3Igc2V0IHRvIDAsIG51bWJlciBvZiB0aHJlYWQocykgd2lsbCBiZSBkZXRlcm1pbmVkIGJ5IHN5c3RlbS4gSWYgc2V0XG4gICAgICogdG8gMSwgbm8gd29ya2VyIHRocmVhZCB3aWxsIGJlIHNwYXduZWQuXG4gICAgICpcbiAgICAgKiBUaGlzIHNldHRpbmcgaXMgYXZhaWxhYmxlIG9ubHkgd2hlbiBXZWJBc3NlbWJseSBtdWx0aXRocmVhZCBmZWF0dXJlIGlzIGF2YWlsYWJsZSBpbiBjdXJyZW50IGNvbnRleHQuXG4gICAgICpcbiAgICAgKiBAZGVmYXVsdFZhbHVlIGAwYFxuICAgICAqL1xuICAgIG51bVRocmVhZHM/OiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBzZXQgb3IgZ2V0IGEgYm9vbGVhbiB2YWx1ZSBpbmRpY2F0aW5nIHdoZXRoZXIgdG8gZW5hYmxlIFNJTUQuIElmIHNldCB0byBmYWxzZSwgU0lNRCB3aWxsIGJlIGZvcmNlbHkgZGlzYWJsZWQuXG4gICAgICpcbiAgICAgKiBUaGlzIHNldHRpbmcgaXMgYXZhaWxhYmxlIG9ubHkgd2hlbiBXZWJBc3NlbWJseSBTSU1EIGZlYXR1cmUgaXMgYXZhaWxhYmxlIGluIGN1cnJlbnQgY29udGV4dC5cbiAgICAgKlxuICAgICAqIEBkZWZhdWx0VmFsdWUgYHRydWVgXG4gICAgICovXG4gICAgc2ltZD86IGJvb2xlYW47XG5cbiAgICAvKipcbiAgICAgKiBzZXQgb3IgZ2V0IGEgYm9vbGVhbiB2YWx1ZSBpbmRpY2F0aW5nIHdoZXRoZXIgdG8gZW5hYmxlIHRyYWNlLlxuICAgICAqXG4gICAgICogQGRlcHJlY2F0ZWQgVXNlIGBlbnYudHJhY2VgIGluc3RlYWQuIElmIGBlbnYudHJhY2VgIGlzIHNldCwgdGhpcyBwcm9wZXJ0eSB3aWxsIGJlIGlnbm9yZWQuXG4gICAgICogQGRlZmF1bHRWYWx1ZSBgZmFsc2VgXG4gICAgICovXG4gICAgdHJhY2U/OiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogU2V0IG9yIGdldCBhIG51bWJlciBzcGVjaWZ5aW5nIHRoZSB0aW1lb3V0IGZvciBpbml0aWFsaXphdGlvbiBvZiBXZWJBc3NlbWJseSBiYWNrZW5kLCBpbiBtaWxsaXNlY29uZHMuIEEgemVyb1xuICAgICAqIHZhbHVlIGluZGljYXRlcyBubyB0aW1lb3V0IGlzIHNldC5cbiAgICAgKlxuICAgICAqIEBkZWZhdWx0VmFsdWUgYDBgXG4gICAgICovXG4gICAgaW5pdFRpbWVvdXQ/OiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBTZXQgYSBjdXN0b20gVVJMIHByZWZpeCB0byB0aGUgLndhc20gZmlsZXMgb3IgYSBzZXQgb2Ygb3ZlcnJpZGVzIGZvciBlYWNoIC53YXNtIGZpbGUuIFRoZSBvdmVycmlkZSBwYXRoIHNob3VsZCBiZVxuICAgICAqIGFuIGFic29sdXRlIHBhdGguXG4gICAgICovXG4gICAgd2FzbVBhdGhzPzogV2FzbVByZWZpeE9yRmlsZVBhdGhzO1xuXG4gICAgLyoqXG4gICAgICogU2V0IG9yIGdldCBhIGJvb2xlYW4gdmFsdWUgaW5kaWNhdGluZyB3aGV0aGVyIHRvIHByb3h5IHRoZSBleGVjdXRpb24gb2YgbWFpbiB0aHJlYWQgdG8gYSB3b3JrZXIgdGhyZWFkLlxuICAgICAqXG4gICAgICogQGRlZmF1bHRWYWx1ZSBgZmFsc2VgXG4gICAgICovXG4gICAgcHJveHk/OiBib29sZWFuO1xuICB9XG5cbiAgZXhwb3J0IGludGVyZmFjZSBXZWJHTEZsYWdzIHtcbiAgICAvKipcbiAgICAgKiBTZXQgb3IgZ2V0IHRoZSBXZWJHTCBDb250ZXh0IElEICh3ZWJnbCBvciB3ZWJnbDIpLlxuICAgICAqXG4gICAgICogQGRlZmF1bHRWYWx1ZSBgJ3dlYmdsMidgXG4gICAgICovXG4gICAgY29udGV4dElkPzogJ3dlYmdsJ3wnd2ViZ2wyJztcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIFdlYkdMIHJlbmRlcmluZyBjb250ZXh0LlxuICAgICAqL1xuICAgIHJlYWRvbmx5IGNvbnRleHQ6IFdlYkdMUmVuZGVyaW5nQ29udGV4dDtcbiAgICAvKipcbiAgICAgKiBTZXQgb3IgZ2V0IHRoZSBtYXhpbXVtIGJhdGNoIHNpemUgZm9yIG1hdG11bC4gMCBtZWFucyB0byBkaXNhYmxlIGJhdGNoaW5nLlxuICAgICAqXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKi9cbiAgICBtYXRtdWxNYXhCYXRjaFNpemU/OiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogU2V0IG9yIGdldCB0aGUgdGV4dHVyZSBjYWNoZSBtb2RlLlxuICAgICAqXG4gICAgICogQGRlZmF1bHRWYWx1ZSBgJ2Z1bGwnYFxuICAgICAqL1xuICAgIHRleHR1cmVDYWNoZU1vZGU/OiAnaW5pdGlhbGl6ZXJPbmx5J3wnZnVsbCc7XG4gICAgLyoqXG4gICAgICogU2V0IG9yIGdldCB0aGUgcGFja2VkIHRleHR1cmUgbW9kZVxuICAgICAqXG4gICAgICogQGRlZmF1bHRWYWx1ZSBgZmFsc2VgXG4gICAgICovXG4gICAgcGFjaz86IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogU2V0IG9yIGdldCB3aGV0aGVyIGVuYWJsZSBhc3luYyBkb3dubG9hZC5cbiAgICAgKlxuICAgICAqIEBkZWZhdWx0VmFsdWUgYGZhbHNlYFxuICAgICAqL1xuICAgIGFzeW5jPzogYm9vbGVhbjtcbiAgfVxuXG4gIGV4cG9ydCBpbnRlcmZhY2UgV2ViR3B1UHJvZmlsaW5nRGF0YVYxVGVuc29yTWV0YWRhdGEge1xuICAgIGRpbXM6IHJlYWRvbmx5IG51bWJlcltdO1xuICAgIGRhdGFUeXBlOiBzdHJpbmc7XG4gIH1cbiAgZXhwb3J0IGludGVyZmFjZSBXZWJHcHVQcm9maWxpbmdEYXRhVjEge1xuICAgIHZlcnNpb246IDE7XG4gICAgaW5wdXRzTWV0YWRhdGE6IHJlYWRvbmx5IFdlYkdwdVByb2ZpbGluZ0RhdGFWMVRlbnNvck1ldGFkYXRhW107XG4gICAgb3V0cHV0c01ldGFkYXRhOiByZWFkb25seSBXZWJHcHVQcm9maWxpbmdEYXRhVjFUZW5zb3JNZXRhZGF0YVtdO1xuICAgIGtlcm5lbElkOiBudW1iZXI7XG4gICAga2VybmVsVHlwZTogc3RyaW5nO1xuICAgIGtlcm5lbE5hbWU6IHN0cmluZztcbiAgICBwcm9ncmFtTmFtZTogc3RyaW5nO1xuICAgIHN0YXJ0VGltZTogbnVtYmVyO1xuICAgIGVuZFRpbWU6IG51bWJlcjtcbiAgfVxuXG4gIGV4cG9ydCB0eXBlIFdlYkdwdVByb2ZpbGluZ0RhdGEgPSBXZWJHcHVQcm9maWxpbmdEYXRhVjE7XG5cbiAgZXhwb3J0IGludGVyZmFjZSBXZWJHcHVGbGFncyB7XG4gICAgLyoqXG4gICAgICogU2V0IG9yIGdldCB0aGUgcHJvZmlsaW5nIG1vZGUuXG4gICAgICpcbiAgICAgKiBAZGVwcmVjYXRlZCBVc2UgYGVudi53ZWJncHUucHJvZmlsaW5nLm1vZGVgIGluc3RlYWQuIElmIGBlbnYud2ViZ3B1LnByb2ZpbGluZy5tb2RlYCBpcyBzZXQsIHRoaXMgcHJvcGVydHkgd2lsbCBiZVxuICAgICAqIGlnbm9yZWQuXG4gICAgICovXG4gICAgcHJvZmlsaW5nTW9kZT86ICdvZmYnfCdkZWZhdWx0JztcbiAgICAvKipcbiAgICAgKiBTZXQgb3IgZ2V0IHRoZSBwcm9maWxpbmcgY29uZmlndXJhdGlvbi5cbiAgICAgKi9cbiAgICBwcm9maWxpbmc/OiB7XG4gICAgICAvKipcbiAgICAgICAqIFNldCBvciBnZXQgdGhlIHByb2ZpbGluZyBtb2RlLlxuICAgICAgICpcbiAgICAgICAqIEBkZWZhdWx0VmFsdWUgYCdvZmYnYFxuICAgICAgICovXG4gICAgICBtb2RlPzogJ29mZid8J2RlZmF1bHQnO1xuXG4gICAgICAvKipcbiAgICAgICAqIFNldCBvciBnZXQgYSBjYWxsYmFjayBmdW5jdGlvbiB3aGVuIGEgcHJvZmlsaW5nIGRhdGEgaXMgcmVjZWl2ZWQuIElmIG5vdCBzZXQsIHRoZSBwcm9maWxpbmcgZGF0YSB3aWxsIGJlXG4gICAgICAgKiBwcmludGVkIHRvIGNvbnNvbGUuXG4gICAgICAgKi9cbiAgICAgIG9uZGF0YT86IChkYXRhOiBXZWJHcHVQcm9maWxpbmdEYXRhKSA9PiB2b2lkO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0IG9yIGdldCB0aGUgcG93ZXIgcHJlZmVyZW5jZS5cbiAgICAgKlxuICAgICAqIFNldHRpbmcgdGhpcyBwcm9wZXJ0eSBvbmx5IGhhcyBlZmZlY3QgYmVmb3JlIHRoZSBmaXJzdCBXZWJHUFUgaW5mZXJlbmNlIHNlc3Npb24gaXMgY3JlYXRlZC4gVGhlIHZhbHVlIHdpbGwgYmVcbiAgICAgKiB1c2VkIGFzIG9wdGlvbnMgZm9yIGBuYXZpZ2F0b3IuZ3B1LnJlcXVlc3RBZGFwdGVyKClgLlxuICAgICAqXG4gICAgICogU2VlIHtAbGluayBodHRwczovL2dwdXdlYi5naXRodWIuaW8vZ3B1d2ViLyNkaWN0ZGVmLWdwdXJlcXVlc3RhZGFwdGVyb3B0aW9uc30gZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKlxuICAgICAqIEBkZWZhdWx0VmFsdWUgYHVuZGVmaW5lZGBcbiAgICAgKi9cbiAgICBwb3dlclByZWZlcmVuY2U/OiAnbG93LXBvd2VyJ3wnaGlnaC1wZXJmb3JtYW5jZSc7XG4gICAgLyoqXG4gICAgICogU2V0IG9yIGdldCB0aGUgZm9yY2UgZmFsbGJhY2sgYWRhcHRlciBmbGFnLlxuICAgICAqXG4gICAgICogU2V0dGluZyB0aGlzIHByb3BlcnR5IG9ubHkgaGFzIGVmZmVjdCBiZWZvcmUgdGhlIGZpcnN0IFdlYkdQVSBpbmZlcmVuY2Ugc2Vzc2lvbiBpcyBjcmVhdGVkLiBUaGUgdmFsdWUgd2lsbCBiZVxuICAgICAqIHVzZWQgYXMgb3B0aW9ucyBmb3IgYG5hdmlnYXRvci5ncHUucmVxdWVzdEFkYXB0ZXIoKWAuXG4gICAgICpcbiAgICAgKiBTZWUge0BsaW5rIGh0dHBzOi8vZ3B1d2ViLmdpdGh1Yi5pby9ncHV3ZWIvI2RpY3RkZWYtZ3B1cmVxdWVzdGFkYXB0ZXJvcHRpb25zfSBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqXG4gICAgICogQGRlZmF1bHRWYWx1ZSBgdW5kZWZpbmVkYFxuICAgICAqL1xuICAgIGZvcmNlRmFsbGJhY2tBZGFwdGVyPzogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBTZXQgb3IgZ2V0IHRoZSBhZGFwdGVyIGZvciBXZWJHUFUuXG4gICAgICpcbiAgICAgKiBTZXR0aW5nIHRoaXMgcHJvcGVydHkgb25seSBoYXMgZWZmZWN0IGJlZm9yZSB0aGUgZmlyc3QgV2ViR1BVIGluZmVyZW5jZSBzZXNzaW9uIGlzIGNyZWF0ZWQuIFRoZSB2YWx1ZSB3aWxsIGJlXG4gICAgICogdXNlZCBhcyB0aGUgR1BVIGFkYXB0ZXIgZm9yIHRoZSB1bmRlcmx5aW5nIFdlYkdQVSBiYWNrZW5kIHRvIGNyZWF0ZSBHUFUgZGV2aWNlLlxuICAgICAqXG4gICAgICogSWYgdGhpcyBwcm9wZXJ0eSBpcyBub3Qgc2V0LCBpdCB3aWxsIGJlIGF2YWlsYWJsZSB0byBnZXQgYWZ0ZXIgdGhlIGZpcnN0IFdlYkdQVSBpbmZlcmVuY2Ugc2Vzc2lvbiBpcyBjcmVhdGVkLiBUaGVcbiAgICAgKiB2YWx1ZSB3aWxsIGJlIHRoZSBHUFUgYWRhcHRlciB0aGF0IGNyZWF0ZWQgYnkgdGhlIHVuZGVybHlpbmcgV2ViR1BVIGJhY2tlbmQuXG4gICAgICpcbiAgICAgKiBXaGVuIHVzZSB3aXRoIFR5cGVTY3JpcHQsIHRoZSB0eXBlIG9mIHRoaXMgcHJvcGVydHkgaXMgYEdQVUFkYXB0ZXJgIGRlZmluZWQgaW4gXCJAd2ViZ3B1L3R5cGVzXCIuXG4gICAgICogVXNlIGBjb25zdCBhZGFwdGVyID0gZW52LndlYmdwdS5hZGFwdGVyIGFzIEdQVUFkYXB0ZXI7YCBpbiBUeXBlU2NyaXB0IHRvIGFjY2VzcyB0aGlzIHByb3BlcnR5IHdpdGggY29ycmVjdCB0eXBlLlxuICAgICAqXG4gICAgICogc2VlIGNvbW1lbnRzIG9uIHtAbGluayBUZW5zb3IuR3B1QnVmZmVyVHlwZX1cbiAgICAgKi9cbiAgICBhZGFwdGVyOiB1bmtub3duO1xuICAgIC8qKlxuICAgICAqIEdldCB0aGUgZGV2aWNlIGZvciBXZWJHUFUuXG4gICAgICpcbiAgICAgKiBUaGlzIHByb3BlcnR5IGlzIG9ubHkgYXZhaWxhYmxlIGFmdGVyIHRoZSBmaXJzdCBXZWJHUFUgaW5mZXJlbmNlIHNlc3Npb24gaXMgY3JlYXRlZC5cbiAgICAgKlxuICAgICAqIFdoZW4gdXNlIHdpdGggVHlwZVNjcmlwdCwgdGhlIHR5cGUgb2YgdGhpcyBwcm9wZXJ0eSBpcyBgR1BVRGV2aWNlYCBkZWZpbmVkIGluIFwiQHdlYmdwdS90eXBlc1wiLlxuICAgICAqIFVzZSBgY29uc3QgZGV2aWNlID0gZW52LndlYmdwdS5kZXZpY2UgYXMgR1BVRGV2aWNlO2AgaW4gVHlwZVNjcmlwdCB0byBhY2Nlc3MgdGhpcyBwcm9wZXJ0eSB3aXRoIGNvcnJlY3QgdHlwZS5cbiAgICAgKlxuICAgICAqIHNlZSBjb21tZW50cyBvbiB7QGxpbmsgVGVuc29yLkdwdUJ1ZmZlclR5cGV9IGZvciBtb3JlIGRldGFpbHMgYWJvdXQgd2h5IG5vdCB1c2UgdHlwZXMgZGVmaW5lZCBpbiBcIkB3ZWJncHUvdHlwZXNcIi5cbiAgICAgKi9cbiAgICByZWFkb25seSBkZXZpY2U6IHVua25vd247XG4gICAgLyoqXG4gICAgICogU2V0IG9yIGdldCB3aGV0aGVyIHZhbGlkYXRlIGlucHV0IGNvbnRlbnQuXG4gICAgICpcbiAgICAgKiBAZGVmYXVsdFZhbHVlIGBmYWxzZWBcbiAgICAgKi9cbiAgICB2YWxpZGF0ZUlucHV0Q29udGVudD86IGJvb2xlYW47XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBFbnYge1xuICAvKipcbiAgICogc2V0IHRoZSBzZXZlcml0eSBsZXZlbCBmb3IgbG9nZ2luZy5cbiAgICpcbiAgICogQGRlZmF1bHRWYWx1ZSBgJ3dhcm5pbmcnYFxuICAgKi9cbiAgbG9nTGV2ZWw/OiAndmVyYm9zZSd8J2luZm8nfCd3YXJuaW5nJ3wnZXJyb3InfCdmYXRhbCc7XG5cbiAgLyoqXG4gICAqIEluZGljYXRlIHdoZXRoZXIgcnVuIGluIGRlYnVnIG1vZGUuXG4gICAqXG4gICAqIEBkZWZhdWx0VmFsdWUgYGZhbHNlYFxuICAgKi9cbiAgZGVidWc/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBzZXQgb3IgZ2V0IGEgYm9vbGVhbiB2YWx1ZSBpbmRpY2F0aW5nIHdoZXRoZXIgdG8gZW5hYmxlIHRyYWNlLlxuICAgKlxuICAgKiBAZGVmYXVsdFZhbHVlIGBmYWxzZWBcbiAgICovXG4gIHRyYWNlPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogR2V0IHZlcnNpb24gb2YgdGhlIGN1cnJlbnQgcGFja2FnZS5cbiAgICovXG4gIHJlYWRvbmx5IHZlcnNpb25zOiB7XG4gICAgcmVhZG9ubHkgY29tbW9uOiBzdHJpbmc7XG4gICAgcmVhZG9ubHkgd2ViPzogc3RyaW5nO1xuICAgIHJlYWRvbmx5IG5vZGU/OiBzdHJpbmc7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuICAgIHJlYWRvbmx5ICdyZWFjdC1uYXRpdmUnPzogc3RyaW5nO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXByZXNlbnQgYSBzZXQgb2YgZmxhZ3MgZm9yIFdlYkFzc2VtYmx5XG4gICAqL1xuICByZWFkb25seSB3YXNtOiBFbnYuV2ViQXNzZW1ibHlGbGFncztcblxuICAvKipcbiAgICogUmVwcmVzZW50IGEgc2V0IG9mIGZsYWdzIGZvciBXZWJHTFxuICAgKi9cbiAgcmVhZG9ubHkgd2ViZ2w6IEVudi5XZWJHTEZsYWdzO1xuXG4gIC8qKlxuICAgKiBSZXByZXNlbnQgYSBzZXQgb2YgZmxhZ3MgZm9yIFdlYkdQVVxuICAgKi9cbiAgcmVhZG9ubHkgd2ViZ3B1OiBFbnYuV2ViR3B1RmxhZ3M7XG5cbiAgW25hbWU6IHN0cmluZ106IHVua25vd247XG59XG5cbi8qKlxuICogUmVwcmVzZW50IGEgc2V0IG9mIGZsYWdzIGFzIGEgZ2xvYmFsIHNpbmdsZXRvbi5cbiAqL1xuZXhwb3J0IGNvbnN0IGVudjogRW52ID0gZW52SW1wbDtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtUZW5zb3JUb0RhdGFVcmxPcHRpb25zLCBUZW5zb3JUb0ltYWdlRGF0YU9wdGlvbnN9IGZyb20gJy4vdGVuc29yLWNvbnZlcnNpb24uanMnO1xuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4vdGVuc29yLmpzJztcblxuLyoqXG4gKiBpbXBsZW1lbnRhdGlvbiBvZiBUZW5zb3IudG9EYXRhVVJMKClcbiAqL1xuZXhwb3J0IGNvbnN0IHRlbnNvclRvRGF0YVVSTCA9ICh0ZW5zb3I6IFRlbnNvciwgb3B0aW9ucz86IFRlbnNvclRvRGF0YVVybE9wdGlvbnMpOiBzdHJpbmcgPT4ge1xuICBjb25zdCBjYW52YXMgPSB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJykgOiAobmV3IE9mZnNjcmVlbkNhbnZhcygxLCAxKSk7XG4gIGNhbnZhcy53aWR0aCA9IHRlbnNvci5kaW1zWzNdO1xuICBjYW52YXMuaGVpZ2h0ID0gdGVuc29yLmRpbXNbMl07XG4gIGNvbnN0IHBpeGVsczJEQ29udGV4dCA9XG4gICAgICBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKSBhcyAoQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEIHwgT2Zmc2NyZWVuQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEIHwgbnVsbCk7XG5cbiAgaWYgKHBpeGVsczJEQ29udGV4dCAhPSBudWxsKSB7XG4gICAgLy8gRGVmYXVsdCB2YWx1ZXMgZm9yIGhlaWdodCBhbmQgd2lkdGggJiBmb3JtYXRcbiAgICBsZXQgd2lkdGg6IG51bWJlcjtcbiAgICBsZXQgaGVpZ2h0OiBudW1iZXI7XG4gICAgaWYgKG9wdGlvbnM/LnRlbnNvckxheW91dCAhPT0gdW5kZWZpbmVkICYmIG9wdGlvbnMudGVuc29yTGF5b3V0ID09PSAnTkhXQycpIHtcbiAgICAgIHdpZHRoID0gdGVuc29yLmRpbXNbMl07XG4gICAgICBoZWlnaHQgPSB0ZW5zb3IuZGltc1szXTtcbiAgICB9IGVsc2UgeyAgLy8gRGVmYXVsdCBsYXlvdXQgaXMgTkNXSFxuICAgICAgd2lkdGggPSB0ZW5zb3IuZGltc1szXTtcbiAgICAgIGhlaWdodCA9IHRlbnNvci5kaW1zWzJdO1xuICAgIH1cblxuICAgIGNvbnN0IGlucHV0Zm9ybWF0ID0gb3B0aW9ucz8uZm9ybWF0ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmZvcm1hdCA6ICdSR0InO1xuXG4gICAgY29uc3Qgbm9ybSA9IG9wdGlvbnM/Lm5vcm07XG4gICAgbGV0IG5vcm1NZWFuOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXTtcbiAgICBsZXQgbm9ybUJpYXM6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdO1xuICAgIGlmIChub3JtID09PSB1bmRlZmluZWQgfHwgbm9ybS5tZWFuID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG5vcm1NZWFuID0gWzI1NSwgMjU1LCAyNTUsIDI1NV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlb2YgKG5vcm0ubWVhbikgPT09ICdudW1iZXInKSB7XG4gICAgICAgIG5vcm1NZWFuID0gW25vcm0ubWVhbiwgbm9ybS5tZWFuLCBub3JtLm1lYW4sIG5vcm0ubWVhbl07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub3JtTWVhbiA9IFtub3JtLm1lYW5bMF0sIG5vcm0ubWVhblsxXSwgbm9ybS5tZWFuWzJdLCAwXTtcbiAgICAgICAgaWYgKG5vcm0ubWVhblszXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbm9ybU1lYW5bM10gPSBub3JtLm1lYW5bM107XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5vcm0gPT09IHVuZGVmaW5lZCB8fCBub3JtLmJpYXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgbm9ybUJpYXMgPSBbMCwgMCwgMCwgMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlb2YgKG5vcm0uYmlhcykgPT09ICdudW1iZXInKSB7XG4gICAgICAgIG5vcm1CaWFzID0gW25vcm0uYmlhcywgbm9ybS5iaWFzLCBub3JtLmJpYXMsIG5vcm0uYmlhc107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub3JtQmlhcyA9IFtub3JtLmJpYXNbMF0sIG5vcm0uYmlhc1sxXSwgbm9ybS5iaWFzWzJdLCAwXTtcbiAgICAgICAgaWYgKG5vcm0uYmlhc1szXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbm9ybUJpYXNbM10gPSBub3JtLmJpYXNbM107XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBzdHJpZGUgPSBoZWlnaHQgKiB3aWR0aDtcbiAgICAvLyBEZWZhdWx0IHBvaW50ZXIgYXNzaWdubWVudHNcbiAgICBsZXQgclRlbnNvclBvaW50ZXIgPSAwLCBnVGVuc29yUG9pbnRlciA9IHN0cmlkZSwgYlRlbnNvclBvaW50ZXIgPSBzdHJpZGUgKiAyLCBhVGVuc29yUG9pbnRlciA9IC0xO1xuXG4gICAgLy8gVXBkYXRpbmcgdGhlIHBvaW50ZXIgYXNzaWdubWVudHMgYmFzZWQgb24gdGhlIGlucHV0IGltYWdlIGZvcm1hdFxuICAgIGlmIChpbnB1dGZvcm1hdCA9PT0gJ1JHQkEnKSB7XG4gICAgICByVGVuc29yUG9pbnRlciA9IDA7XG4gICAgICBnVGVuc29yUG9pbnRlciA9IHN0cmlkZTtcbiAgICAgIGJUZW5zb3JQb2ludGVyID0gc3RyaWRlICogMjtcbiAgICAgIGFUZW5zb3JQb2ludGVyID0gc3RyaWRlICogMztcbiAgICB9IGVsc2UgaWYgKGlucHV0Zm9ybWF0ID09PSAnUkdCJykge1xuICAgICAgclRlbnNvclBvaW50ZXIgPSAwO1xuICAgICAgZ1RlbnNvclBvaW50ZXIgPSBzdHJpZGU7XG4gICAgICBiVGVuc29yUG9pbnRlciA9IHN0cmlkZSAqIDI7XG4gICAgfSBlbHNlIGlmIChpbnB1dGZvcm1hdCA9PT0gJ1JCRycpIHtcbiAgICAgIHJUZW5zb3JQb2ludGVyID0gMDtcbiAgICAgIGJUZW5zb3JQb2ludGVyID0gc3RyaWRlO1xuICAgICAgZ1RlbnNvclBvaW50ZXIgPSBzdHJpZGUgKiAyO1xuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaGVpZ2h0OyBpKyspIHtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgd2lkdGg7IGorKykge1xuICAgICAgICBjb25zdCBSID0gKCh0ZW5zb3IuZGF0YVtyVGVuc29yUG9pbnRlcisrXSBhcyBudW1iZXIpIC0gbm9ybUJpYXNbMF0pICogbm9ybU1lYW5bMF07ICAvLyBSIHZhbHVlXG4gICAgICAgIGNvbnN0IEcgPSAoKHRlbnNvci5kYXRhW2dUZW5zb3JQb2ludGVyKytdIGFzIG51bWJlcikgLSBub3JtQmlhc1sxXSkgKiBub3JtTWVhblsxXTsgIC8vIEcgdmFsdWVcbiAgICAgICAgY29uc3QgQiA9ICgodGVuc29yLmRhdGFbYlRlbnNvclBvaW50ZXIrK10gYXMgbnVtYmVyKSAtIG5vcm1CaWFzWzJdKSAqIG5vcm1NZWFuWzJdOyAgLy8gQiB2YWx1ZVxuICAgICAgICBjb25zdCBBID0gYVRlbnNvclBvaW50ZXIgPT09IC0xID9cbiAgICAgICAgICAgIDI1NSA6XG4gICAgICAgICAgICAoKHRlbnNvci5kYXRhW2FUZW5zb3JQb2ludGVyKytdIGFzIG51bWJlcikgLSBub3JtQmlhc1szXSkgKiBub3JtTWVhblszXTsgIC8vIEEgdmFsdWVcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9yZXN0cmljdC1wbHVzLW9wZXJhbmRzXG4gICAgICAgIHBpeGVsczJEQ29udGV4dC5maWxsU3R5bGUgPSAncmdiYSgnICsgUiArICcsJyArIEcgKyAnLCcgKyBCICsgJywnICsgQSArICcpJztcbiAgICAgICAgcGl4ZWxzMkRDb250ZXh0LmZpbGxSZWN0KGosIGksIDEsIDEpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoJ3RvRGF0YVVSTCcgaW4gY2FudmFzKSB7XG4gICAgICByZXR1cm4gY2FudmFzLnRvRGF0YVVSTCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RvRGF0YVVSTCBpcyBub3Qgc3VwcG9ydGVkJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignQ2FuIG5vdCBhY2Nlc3MgaW1hZ2UgZGF0YScpO1xuICB9XG59O1xuXG4vKipcbiAqIGltcGxlbWVudGF0aW9uIG9mIFRlbnNvci50b0ltYWdlRGF0YSgpXG4gKi9cbmV4cG9ydCBjb25zdCB0ZW5zb3JUb0ltYWdlRGF0YSA9ICh0ZW5zb3I6IFRlbnNvciwgb3B0aW9ucz86IFRlbnNvclRvSW1hZ2VEYXRhT3B0aW9ucyk6IEltYWdlRGF0YSA9PiB7XG4gIGNvbnN0IHBpeGVsczJEQ29udGV4dCA9IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgP1xuICAgICAgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJykuZ2V0Q29udGV4dCgnMmQnKSA6XG4gICAgICBuZXcgT2Zmc2NyZWVuQ2FudmFzKDEsIDEpLmdldENvbnRleHQoJzJkJykgYXMgT2Zmc2NyZWVuQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEO1xuICBsZXQgaW1hZ2U6IEltYWdlRGF0YTtcbiAgaWYgKHBpeGVsczJEQ29udGV4dCAhPSBudWxsKSB7XG4gICAgLy8gRGVmYXVsdCB2YWx1ZXMgZm9yIGhlaWdodCBhbmQgd2lkdGggJiBmb3JtYXRcbiAgICBsZXQgd2lkdGg6IG51bWJlcjtcbiAgICBsZXQgaGVpZ2h0OiBudW1iZXI7XG4gICAgbGV0IGNoYW5uZWxzOiBudW1iZXI7XG4gICAgaWYgKG9wdGlvbnM/LnRlbnNvckxheW91dCAhPT0gdW5kZWZpbmVkICYmIG9wdGlvbnMudGVuc29yTGF5b3V0ID09PSAnTkhXQycpIHtcbiAgICAgIHdpZHRoID0gdGVuc29yLmRpbXNbMl07XG4gICAgICBoZWlnaHQgPSB0ZW5zb3IuZGltc1sxXTtcbiAgICAgIGNoYW5uZWxzID0gdGVuc29yLmRpbXNbM107XG4gICAgfSBlbHNlIHsgIC8vIERlZmF1bHQgbGF5b3V0IGlzIE5DV0hcbiAgICAgIHdpZHRoID0gdGVuc29yLmRpbXNbM107XG4gICAgICBoZWlnaHQgPSB0ZW5zb3IuZGltc1syXTtcbiAgICAgIGNoYW5uZWxzID0gdGVuc29yLmRpbXNbMV07XG4gICAgfVxuICAgIGNvbnN0IGlucHV0Zm9ybWF0ID0gb3B0aW9ucyAhPT0gdW5kZWZpbmVkID8gKG9wdGlvbnMuZm9ybWF0ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmZvcm1hdCA6ICdSR0InKSA6ICdSR0InO1xuXG4gICAgY29uc3Qgbm9ybSA9IG9wdGlvbnM/Lm5vcm07XG4gICAgbGV0IG5vcm1NZWFuOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXTtcbiAgICBsZXQgbm9ybUJpYXM6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdO1xuICAgIGlmIChub3JtID09PSB1bmRlZmluZWQgfHwgbm9ybS5tZWFuID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG5vcm1NZWFuID0gWzI1NSwgMjU1LCAyNTUsIDI1NV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlb2YgKG5vcm0ubWVhbikgPT09ICdudW1iZXInKSB7XG4gICAgICAgIG5vcm1NZWFuID0gW25vcm0ubWVhbiwgbm9ybS5tZWFuLCBub3JtLm1lYW4sIG5vcm0ubWVhbl07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub3JtTWVhbiA9IFtub3JtLm1lYW5bMF0sIG5vcm0ubWVhblsxXSwgbm9ybS5tZWFuWzJdLCAyNTVdO1xuICAgICAgICBpZiAobm9ybS5tZWFuWzNdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBub3JtTWVhblszXSA9IG5vcm0ubWVhblszXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAobm9ybSA9PT0gdW5kZWZpbmVkIHx8IG5vcm0uYmlhcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBub3JtQmlhcyA9IFswLCAwLCAwLCAwXTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHR5cGVvZiAobm9ybS5iaWFzKSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgbm9ybUJpYXMgPSBbbm9ybS5iaWFzLCBub3JtLmJpYXMsIG5vcm0uYmlhcywgbm9ybS5iaWFzXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vcm1CaWFzID0gW25vcm0uYmlhc1swXSwgbm9ybS5iaWFzWzFdLCBub3JtLmJpYXNbMl0sIDBdO1xuICAgICAgICBpZiAobm9ybS5iaWFzWzNdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBub3JtQmlhc1szXSA9IG5vcm0uYmlhc1szXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHN0cmlkZSA9IGhlaWdodCAqIHdpZHRoO1xuICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChvcHRpb25zLmZvcm1hdCAhPT0gdW5kZWZpbmVkICYmIChjaGFubmVscyA9PT0gNCAmJiBvcHRpb25zLmZvcm1hdCAhPT0gJ1JHQkEnKSB8fFxuICAgICAgICAgIChjaGFubmVscyA9PT0gMyAmJiAob3B0aW9ucy5mb3JtYXQgIT09ICdSR0InICYmIG9wdGlvbnMuZm9ybWF0ICE9PSAnQkdSJykpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGVuc29yIGZvcm1hdCBkb2VzblxcJ3QgbWF0Y2ggaW5wdXQgdGVuc29yIGRpbXMnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBEZWZhdWx0IHBvaW50ZXIgYXNzaWdubWVudHNcbiAgICBjb25zdCBzdGVwID0gNDtcbiAgICBsZXQgckltYWdlUG9pbnRlciA9IDAsIGdJbWFnZVBvaW50ZXIgPSAxLCBiSW1hZ2VQb2ludGVyID0gMiwgYUltYWdlUG9pbnRlciA9IDM7XG4gICAgbGV0IHJUZW5zb3JQb2ludGVyID0gMCwgZ1RlbnNvclBvaW50ZXIgPSBzdHJpZGUsIGJUZW5zb3JQb2ludGVyID0gc3RyaWRlICogMiwgYVRlbnNvclBvaW50ZXIgPSAtMTtcblxuICAgIC8vIFVwZGF0aW5nIHRoZSBwb2ludGVyIGFzc2lnbm1lbnRzIGJhc2VkIG9uIHRoZSBpbnB1dCBpbWFnZSBmb3JtYXRcbiAgICBpZiAoaW5wdXRmb3JtYXQgPT09ICdSR0JBJykge1xuICAgICAgclRlbnNvclBvaW50ZXIgPSAwO1xuICAgICAgZ1RlbnNvclBvaW50ZXIgPSBzdHJpZGU7XG4gICAgICBiVGVuc29yUG9pbnRlciA9IHN0cmlkZSAqIDI7XG4gICAgICBhVGVuc29yUG9pbnRlciA9IHN0cmlkZSAqIDM7XG4gICAgfSBlbHNlIGlmIChpbnB1dGZvcm1hdCA9PT0gJ1JHQicpIHtcbiAgICAgIHJUZW5zb3JQb2ludGVyID0gMDtcbiAgICAgIGdUZW5zb3JQb2ludGVyID0gc3RyaWRlO1xuICAgICAgYlRlbnNvclBvaW50ZXIgPSBzdHJpZGUgKiAyO1xuICAgIH0gZWxzZSBpZiAoaW5wdXRmb3JtYXQgPT09ICdSQkcnKSB7XG4gICAgICByVGVuc29yUG9pbnRlciA9IDA7XG4gICAgICBiVGVuc29yUG9pbnRlciA9IHN0cmlkZTtcbiAgICAgIGdUZW5zb3JQb2ludGVyID0gc3RyaWRlICogMjtcbiAgICB9XG5cbiAgICBpbWFnZSA9IHBpeGVsczJEQ29udGV4dC5jcmVhdGVJbWFnZURhdGEod2lkdGgsIGhlaWdodCk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhlaWdodCAqIHdpZHRoO1xuICAgICAgICAgckltYWdlUG9pbnRlciArPSBzdGVwLCBnSW1hZ2VQb2ludGVyICs9IHN0ZXAsIGJJbWFnZVBvaW50ZXIgKz0gc3RlcCwgYUltYWdlUG9pbnRlciArPSBzdGVwLCBpKyspIHtcbiAgICAgIGltYWdlLmRhdGFbckltYWdlUG9pbnRlcl0gPSAoKHRlbnNvci5kYXRhW3JUZW5zb3JQb2ludGVyKytdIGFzIG51bWJlcikgLSBub3JtQmlhc1swXSkgKiBub3JtTWVhblswXTsgIC8vIFIgdmFsdWVcbiAgICAgIGltYWdlLmRhdGFbZ0ltYWdlUG9pbnRlcl0gPSAoKHRlbnNvci5kYXRhW2dUZW5zb3JQb2ludGVyKytdIGFzIG51bWJlcikgLSBub3JtQmlhc1sxXSkgKiBub3JtTWVhblsxXTsgIC8vIEcgdmFsdWVcbiAgICAgIGltYWdlLmRhdGFbYkltYWdlUG9pbnRlcl0gPSAoKHRlbnNvci5kYXRhW2JUZW5zb3JQb2ludGVyKytdIGFzIG51bWJlcikgLSBub3JtQmlhc1syXSkgKiBub3JtTWVhblsyXTsgIC8vIEIgdmFsdWVcbiAgICAgIGltYWdlLmRhdGFbYUltYWdlUG9pbnRlcl0gPSBhVGVuc29yUG9pbnRlciA9PT0gLTEgP1xuICAgICAgICAgIDI1NSA6XG4gICAgICAgICAgKCh0ZW5zb3IuZGF0YVthVGVuc29yUG9pbnRlcisrXSBhcyBudW1iZXIpIC0gbm9ybUJpYXNbM10pICogbm9ybU1lYW5bM107ICAvLyBBIHZhbHVlXG4gICAgfVxuXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW4gbm90IGFjY2VzcyBpbWFnZSBkYXRhJyk7XG4gIH1cbiAgcmV0dXJuIGltYWdlO1xufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtPcHRpb25zRGltZW5zaW9ucywgT3B0aW9uc0Zvcm1hdCwgT3B0aW9uc05vcm1hbGl6YXRpb25QYXJhbWV0ZXJzLCBPcHRpb25zVGVuc29yRm9ybWF0LCBPcHRpb25zVGVuc29yTGF5b3V0LCBUZW5zb3JGcm9tR3B1QnVmZmVyT3B0aW9ucywgVGVuc29yRnJvbUltYWdlQml0bWFwT3B0aW9ucywgVGVuc29yRnJvbUltYWdlRGF0YU9wdGlvbnMsIFRlbnNvckZyb21JbWFnZUVsZW1lbnRPcHRpb25zLCBUZW5zb3JGcm9tVGV4dHVyZU9wdGlvbnMsIFRlbnNvckZyb21VcmxPcHRpb25zfSBmcm9tICcuL3RlbnNvci1mYWN0b3J5LmpzJztcbmltcG9ydCB7VGVuc29yfSBmcm9tICcuL3RlbnNvci1pbXBsLmpzJztcbmltcG9ydCB7VGVuc29yIGFzIFRlbnNvckludGVyZmFjZX0gZnJvbSAnLi90ZW5zb3IuanMnO1xuXG5pbnRlcmZhY2UgQnVmZmVyVG9UZW5zb3JPcHRpb25zIGV4dGVuZHMgT3B0aW9uc0RpbWVuc2lvbnMsIE9wdGlvbnNUZW5zb3JMYXlvdXQsIE9wdGlvbnNOb3JtYWxpemF0aW9uUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPcHRpb25zRm9ybWF0LCBPcHRpb25zVGVuc29yRm9ybWF0IHt9XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IHRlbnNvciBvYmplY3QgZnJvbSBpbWFnZSBvYmplY3RcbiAqXG4gKiBAcGFyYW0gYnVmZmVyIC0gRXh0cmFjdGVkIGltYWdlIGJ1ZmZlciBkYXRhIC0gYXNzdW1pbmcgUkdCQSBmb3JtYXRcbiAqIEBwYXJhbSBpbWFnZUZvcm1hdCAtIGlucHV0IGltYWdlIGNvbmZpZ3VyYXRpb24gLSByZXF1aXJlZCBjb25maWd1cmF0aW9ucyBoZWlnaHQsIHdpZHRoLCBmb3JtYXRcbiAqIEBwYXJhbSB0ZW5zb3JGb3JtYXQgLSBvdXRwdXQgdGVuc29yIGNvbmZpZ3VyYXRpb24gLSBEZWZhdWx0IGlzIFJHQiBmb3JtYXRcbiAqL1xuZXhwb3J0IGNvbnN0IGJ1ZmZlclRvVGVuc29yID0gKGJ1ZmZlcjogVWludDhDbGFtcGVkQXJyYXl8dW5kZWZpbmVkLCBvcHRpb25zOiBCdWZmZXJUb1RlbnNvck9wdGlvbnMpOiBUZW5zb3IgPT4ge1xuICBpZiAoYnVmZmVyID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ltYWdlIGJ1ZmZlciBtdXN0IGJlIGRlZmluZWQnKTtcbiAgfVxuICBpZiAob3B0aW9ucy5oZWlnaHQgPT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLndpZHRoID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ltYWdlIGhlaWdodCBhbmQgd2lkdGggbXVzdCBiZSBkZWZpbmVkJyk7XG4gIH1cbiAgaWYgKG9wdGlvbnMudGVuc29yTGF5b3V0ID09PSAnTkhXQycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05IV0MgVGVuc29yIGxheW91dCBpcyBub3Qgc3VwcG9ydGVkIHlldCcpO1xuICB9XG5cbiAgY29uc3Qge2hlaWdodCwgd2lkdGh9ID0gb3B0aW9ucztcblxuICBjb25zdCBub3JtID0gb3B0aW9ucy5ub3JtID8/IHttZWFuOiAyNTUsIGJpYXM6IDB9O1xuICBsZXQgbm9ybU1lYW46IFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdO1xuICBsZXQgbm9ybUJpYXM6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdO1xuXG4gIGlmICh0eXBlb2YgKG5vcm0ubWVhbikgPT09ICdudW1iZXInKSB7XG4gICAgbm9ybU1lYW4gPSBbbm9ybS5tZWFuLCBub3JtLm1lYW4sIG5vcm0ubWVhbiwgbm9ybS5tZWFuXTtcbiAgfSBlbHNlIHtcbiAgICBub3JtTWVhbiA9IFtub3JtLm1lYW4hWzBdLCBub3JtLm1lYW4hWzFdLCBub3JtLm1lYW4hWzJdLCBub3JtLm1lYW4hWzNdID8/IDI1NV07XG4gIH1cblxuICBpZiAodHlwZW9mIChub3JtLmJpYXMpID09PSAnbnVtYmVyJykge1xuICAgIG5vcm1CaWFzID0gW25vcm0uYmlhcywgbm9ybS5iaWFzLCBub3JtLmJpYXMsIG5vcm0uYmlhc107XG4gIH0gZWxzZSB7XG4gICAgbm9ybUJpYXMgPSBbbm9ybS5iaWFzIVswXSwgbm9ybS5iaWFzIVsxXSwgbm9ybS5iaWFzIVsyXSwgbm9ybS5iaWFzIVszXSA/PyAwXTtcbiAgfVxuXG4gIGNvbnN0IGlucHV0Zm9ybWF0ID0gb3B0aW9ucy5mb3JtYXQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZm9ybWF0IDogJ1JHQkEnO1xuICAvLyBkZWZhdWx0IHZhbHVlIGlzIFJHQkEgc2luY2UgaW1hZ2VkYXRhIGFuZCBIVE1MSW1hZ2VFbGVtZW50IHVzZXMgaXRcblxuICBjb25zdCBvdXRwdXRmb3JtYXQgPVxuICAgICAgb3B0aW9ucy50ZW5zb3JGb3JtYXQgIT09IHVuZGVmaW5lZCA/IChvcHRpb25zLnRlbnNvckZvcm1hdCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy50ZW5zb3JGb3JtYXQgOiAnUkdCJykgOiAnUkdCJztcbiAgY29uc3Qgc3RyaWRlID0gaGVpZ2h0ICogd2lkdGg7XG4gIGNvbnN0IGZsb2F0MzJEYXRhID0gb3V0cHV0Zm9ybWF0ID09PSAnUkdCQScgPyBuZXcgRmxvYXQzMkFycmF5KHN0cmlkZSAqIDQpIDogbmV3IEZsb2F0MzJBcnJheShzdHJpZGUgKiAzKTtcblxuICAvLyBEZWZhdWx0IHBvaW50ZXIgYXNzaWdubWVudHNcbiAgbGV0IHN0ZXAgPSA0LCBySW1hZ2VQb2ludGVyID0gMCwgZ0ltYWdlUG9pbnRlciA9IDEsIGJJbWFnZVBvaW50ZXIgPSAyLCBhSW1hZ2VQb2ludGVyID0gMztcbiAgbGV0IHJUZW5zb3JQb2ludGVyID0gMCwgZ1RlbnNvclBvaW50ZXIgPSBzdHJpZGUsIGJUZW5zb3JQb2ludGVyID0gc3RyaWRlICogMiwgYVRlbnNvclBvaW50ZXIgPSAtMTtcblxuICAvLyBVcGRhdGluZyB0aGUgcG9pbnRlciBhc3NpZ25tZW50cyBiYXNlZCBvbiB0aGUgaW5wdXQgaW1hZ2UgZm9ybWF0XG4gIGlmIChpbnB1dGZvcm1hdCA9PT0gJ1JHQicpIHtcbiAgICBzdGVwID0gMztcbiAgICBySW1hZ2VQb2ludGVyID0gMDtcbiAgICBnSW1hZ2VQb2ludGVyID0gMTtcbiAgICBiSW1hZ2VQb2ludGVyID0gMjtcbiAgICBhSW1hZ2VQb2ludGVyID0gLTE7XG4gIH1cblxuICAvLyBVcGRhdGluZyB0aGUgcG9pbnRlciBhc3NpZ25tZW50cyBiYXNlZCBvbiB0aGUgb3V0cHV0IHRlbnNvciBmb3JtYXRcbiAgaWYgKG91dHB1dGZvcm1hdCA9PT0gJ1JHQkEnKSB7XG4gICAgYVRlbnNvclBvaW50ZXIgPSBzdHJpZGUgKiAzO1xuICB9IGVsc2UgaWYgKG91dHB1dGZvcm1hdCA9PT0gJ1JCRycpIHtcbiAgICByVGVuc29yUG9pbnRlciA9IDA7XG4gICAgYlRlbnNvclBvaW50ZXIgPSBzdHJpZGU7XG4gICAgZ1RlbnNvclBvaW50ZXIgPSBzdHJpZGUgKiAyO1xuICB9IGVsc2UgaWYgKG91dHB1dGZvcm1hdCA9PT0gJ0JHUicpIHtcbiAgICBiVGVuc29yUG9pbnRlciA9IDA7XG4gICAgZ1RlbnNvclBvaW50ZXIgPSBzdHJpZGU7XG4gICAgclRlbnNvclBvaW50ZXIgPSBzdHJpZGUgKiAyO1xuICB9XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHJpZGU7XG4gICAgICAgaSsrLCBySW1hZ2VQb2ludGVyICs9IHN0ZXAsIGJJbWFnZVBvaW50ZXIgKz0gc3RlcCwgZ0ltYWdlUG9pbnRlciArPSBzdGVwLCBhSW1hZ2VQb2ludGVyICs9IHN0ZXApIHtcbiAgICBmbG9hdDMyRGF0YVtyVGVuc29yUG9pbnRlcisrXSA9IChidWZmZXJbckltYWdlUG9pbnRlcl0gKyBub3JtQmlhc1swXSkgLyBub3JtTWVhblswXTtcbiAgICBmbG9hdDMyRGF0YVtnVGVuc29yUG9pbnRlcisrXSA9IChidWZmZXJbZ0ltYWdlUG9pbnRlcl0gKyBub3JtQmlhc1sxXSkgLyBub3JtTWVhblsxXTtcbiAgICBmbG9hdDMyRGF0YVtiVGVuc29yUG9pbnRlcisrXSA9IChidWZmZXJbYkltYWdlUG9pbnRlcl0gKyBub3JtQmlhc1syXSkgLyBub3JtTWVhblsyXTtcbiAgICBpZiAoYVRlbnNvclBvaW50ZXIgIT09IC0xICYmIGFJbWFnZVBvaW50ZXIgIT09IC0xKSB7XG4gICAgICBmbG9hdDMyRGF0YVthVGVuc29yUG9pbnRlcisrXSA9IChidWZmZXJbYUltYWdlUG9pbnRlcl0gKyBub3JtQmlhc1szXSkgLyBub3JtTWVhblszXTtcbiAgICB9XG4gIH1cblxuICAvLyBGbG9hdDMyQXJyYXkgLT4gb3J0LlRlbnNvclxuICBjb25zdCBvdXRwdXRUZW5zb3IgPSBvdXRwdXRmb3JtYXQgPT09ICdSR0JBJyA/IG5ldyBUZW5zb3IoJ2Zsb2F0MzInLCBmbG9hdDMyRGF0YSwgWzEsIDQsIGhlaWdodCwgd2lkdGhdKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IFRlbnNvcignZmxvYXQzMicsIGZsb2F0MzJEYXRhLCBbMSwgMywgaGVpZ2h0LCB3aWR0aF0pO1xuICByZXR1cm4gb3V0cHV0VGVuc29yO1xufTtcblxuLyoqXG4gKiBpbXBsZW1lbnRhdGlvbiBvZiBUZW5zb3IuZnJvbUltYWdlKCkuXG4gKi9cbmV4cG9ydCBjb25zdCB0ZW5zb3JGcm9tSW1hZ2UgPSBhc3luYyhcbiAgICBpbWFnZTogSW1hZ2VEYXRhfEhUTUxJbWFnZUVsZW1lbnR8SW1hZ2VCaXRtYXB8c3RyaW5nLFxuICAgIG9wdGlvbnM/OiBUZW5zb3JGcm9tSW1hZ2VEYXRhT3B0aW9uc3xUZW5zb3JGcm9tSW1hZ2VFbGVtZW50T3B0aW9uc3xUZW5zb3JGcm9tSW1hZ2VCaXRtYXBPcHRpb25zfFxuICAgIFRlbnNvckZyb21VcmxPcHRpb25zKTogUHJvbWlzZTxUZW5zb3I+ID0+IHtcbiAgLy8gY2hlY2tpbmcgdGhlIHR5cGUgb2YgaW1hZ2Ugb2JqZWN0XG4gIGNvbnN0IGlzSFRNTEltYWdlRWxlID0gdHlwZW9mIChIVE1MSW1hZ2VFbGVtZW50KSAhPT0gJ3VuZGVmaW5lZCcgJiYgaW1hZ2UgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50O1xuICBjb25zdCBpc0ltYWdlRGF0YUVsZSA9IHR5cGVvZiAoSW1hZ2VEYXRhKSAhPT0gJ3VuZGVmaW5lZCcgJiYgaW1hZ2UgaW5zdGFuY2VvZiBJbWFnZURhdGE7XG4gIGNvbnN0IGlzSW1hZ2VCaXRtYXAgPSB0eXBlb2YgKEltYWdlQml0bWFwKSAhPT0gJ3VuZGVmaW5lZCcgJiYgaW1hZ2UgaW5zdGFuY2VvZiBJbWFnZUJpdG1hcDtcbiAgY29uc3QgaXNTdHJpbmcgPSB0eXBlb2YgaW1hZ2UgPT09ICdzdHJpbmcnO1xuXG4gIGxldCBkYXRhOiBVaW50OENsYW1wZWRBcnJheXx1bmRlZmluZWQ7XG4gIGxldCBidWZmZXJUb1RlbnNvck9wdGlvbnM6IEJ1ZmZlclRvVGVuc29yT3B0aW9ucyA9IG9wdGlvbnMgPz8ge307XG5cbiAgY29uc3QgY3JlYXRlQ2FudmFzID0gKCkgPT4ge1xuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgT2Zmc2NyZWVuQ2FudmFzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIG5ldyBPZmZzY3JlZW5DYW52YXMoMSwgMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2FudmFzIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IGNyZWF0ZUNhbnZhc0NvbnRleHQgPSAoY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudHxPZmZzY3JlZW5DYW52YXMpID0+IHtcbiAgICBpZiAoY2FudmFzIGluc3RhbmNlb2YgSFRNTENhbnZhc0VsZW1lbnQpIHtcbiAgICAgIHJldHVybiBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICB9IGVsc2UgaWYgKGNhbnZhcyBpbnN0YW5jZW9mIE9mZnNjcmVlbkNhbnZhcykge1xuICAgICAgcmV0dXJuIGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpIGFzIE9mZnNjcmVlbkNhbnZhc1JlbmRlcmluZ0NvbnRleHQyRDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9O1xuICAvLyBmaWxsaW5nIGFuZCBjaGVja2luZyBpbWFnZSBjb25maWd1cmF0aW9uIG9wdGlvbnNcbiAgaWYgKGlzSFRNTEltYWdlRWxlKSB7XG4gICAgLy8gSFRNTEltYWdlRWxlbWVudCAtIGltYWdlIG9iamVjdCAtIGZvcm1hdCBpcyBSR0JBIGJ5IGRlZmF1bHRcbiAgICBjb25zdCBjYW52YXMgPSBjcmVhdGVDYW52YXMoKTtcbiAgICBjYW52YXMud2lkdGggPSBpbWFnZS53aWR0aDtcbiAgICBjYW52YXMuaGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0O1xuICAgIGNvbnN0IHBpeGVsczJEQ29udGV4dCA9IGNyZWF0ZUNhbnZhc0NvbnRleHQoY2FudmFzKTtcblxuICAgIGlmIChwaXhlbHMyRENvbnRleHQgIT0gbnVsbCkge1xuICAgICAgbGV0IGhlaWdodCA9IGltYWdlLmhlaWdodDtcbiAgICAgIGxldCB3aWR0aCA9IGltYWdlLndpZHRoO1xuICAgICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLnJlc2l6ZWRIZWlnaHQgIT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLnJlc2l6ZWRXaWR0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGhlaWdodCA9IG9wdGlvbnMucmVzaXplZEhlaWdodDtcbiAgICAgICAgd2lkdGggPSBvcHRpb25zLnJlc2l6ZWRXaWR0aDtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBidWZmZXJUb1RlbnNvck9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICBpZiAob3B0aW9ucy50ZW5zb3JGb3JtYXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW1hZ2UgaW5wdXQgY29uZmlnIGZvcm1hdCBtdXN0IGJlIFJHQkEgZm9yIEhUTUxJbWFnZUVsZW1lbnQnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBidWZmZXJUb1RlbnNvck9wdGlvbnMudGVuc29yRm9ybWF0ID0gJ1JHQkEnO1xuICAgICAgICB9XG4gICAgICAgIGJ1ZmZlclRvVGVuc29yT3B0aW9ucy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIGJ1ZmZlclRvVGVuc29yT3B0aW9ucy53aWR0aCA9IHdpZHRoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnVmZmVyVG9UZW5zb3JPcHRpb25zLnRlbnNvckZvcm1hdCA9ICdSR0JBJztcbiAgICAgICAgYnVmZmVyVG9UZW5zb3JPcHRpb25zLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgYnVmZmVyVG9UZW5zb3JPcHRpb25zLndpZHRoID0gd2lkdGg7XG4gICAgICB9XG5cbiAgICAgIHBpeGVsczJEQ29udGV4dC5kcmF3SW1hZ2UoaW1hZ2UsIDAsIDApO1xuICAgICAgZGF0YSA9IHBpeGVsczJEQ29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgd2lkdGgsIGhlaWdodCkuZGF0YTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW4gbm90IGFjY2VzcyBpbWFnZSBkYXRhJyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzSW1hZ2VEYXRhRWxlKSB7XG4gICAgbGV0IGhlaWdodDogbnVtYmVyO1xuICAgIGxldCB3aWR0aDogbnVtYmVyO1xuXG4gICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLnJlc2l6ZWRXaWR0aCAhPT0gdW5kZWZpbmVkICYmIG9wdGlvbnMucmVzaXplZEhlaWdodCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBoZWlnaHQgPSBvcHRpb25zLnJlc2l6ZWRIZWlnaHQ7XG4gICAgICB3aWR0aCA9IG9wdGlvbnMucmVzaXplZFdpZHRoO1xuICAgIH0gZWxzZSB7XG4gICAgICBoZWlnaHQgPSBpbWFnZS5oZWlnaHQ7XG4gICAgICB3aWR0aCA9IGltYWdlLndpZHRoO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGJ1ZmZlclRvVGVuc29yT3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgfVxuICAgIGJ1ZmZlclRvVGVuc29yT3B0aW9ucy5mb3JtYXQgPSAnUkdCQSc7XG4gICAgYnVmZmVyVG9UZW5zb3JPcHRpb25zLmhlaWdodCA9IGhlaWdodDtcbiAgICBidWZmZXJUb1RlbnNvck9wdGlvbnMud2lkdGggPSB3aWR0aDtcblxuICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IHRlbXBDYW52YXMgPSBjcmVhdGVDYW52YXMoKTtcblxuICAgICAgdGVtcENhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgICAgdGVtcENhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG5cbiAgICAgIGNvbnN0IHBpeGVsczJEQ29udGV4dCA9IGNyZWF0ZUNhbnZhc0NvbnRleHQodGVtcENhbnZhcyk7XG5cbiAgICAgIGlmIChwaXhlbHMyRENvbnRleHQgIT0gbnVsbCkge1xuICAgICAgICBwaXhlbHMyRENvbnRleHQucHV0SW1hZ2VEYXRhKGltYWdlLCAwLCAwKTtcbiAgICAgICAgZGF0YSA9IHBpeGVsczJEQ29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgd2lkdGgsIGhlaWdodCkuZGF0YTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuIG5vdCBhY2Nlc3MgaW1hZ2UgZGF0YScpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBkYXRhID0gaW1hZ2UuZGF0YTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNJbWFnZUJpdG1hcCkge1xuICAgIC8vIEltYWdlQml0bWFwIC0gaW1hZ2Ugb2JqZWN0IC0gZm9ybWF0IG11c3QgYmUgcHJvdmlkZWQgYnkgdXNlclxuICAgIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUGxlYXNlIHByb3ZpZGUgaW1hZ2UgY29uZmlnIHdpdGggZm9ybWF0IGZvciBJbWFnZWJpdG1hcCcpO1xuICAgIH1cblxuICAgIGNvbnN0IGNhbnZhcyA9IGNyZWF0ZUNhbnZhcygpO1xuICAgIGNhbnZhcy53aWR0aCA9IGltYWdlLndpZHRoO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBpbWFnZS5oZWlnaHQ7XG4gICAgY29uc3QgcGl4ZWxzMkRDb250ZXh0ID0gY3JlYXRlQ2FudmFzQ29udGV4dChjYW52YXMpO1xuXG4gICAgaWYgKHBpeGVsczJEQ29udGV4dCAhPSBudWxsKSB7XG4gICAgICBjb25zdCBoZWlnaHQgPSBpbWFnZS5oZWlnaHQ7XG4gICAgICBjb25zdCB3aWR0aCA9IGltYWdlLndpZHRoO1xuICAgICAgcGl4ZWxzMkRDb250ZXh0LmRyYXdJbWFnZShpbWFnZSwgMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICBkYXRhID0gcGl4ZWxzMkRDb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCB3aWR0aCwgaGVpZ2h0KS5kYXRhO1xuICAgICAgYnVmZmVyVG9UZW5zb3JPcHRpb25zLmhlaWdodCA9IGhlaWdodDtcbiAgICAgIGJ1ZmZlclRvVGVuc29yT3B0aW9ucy53aWR0aCA9IHdpZHRoO1xuICAgICAgcmV0dXJuIGJ1ZmZlclRvVGVuc29yKGRhdGEsIGJ1ZmZlclRvVGVuc29yT3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuIG5vdCBhY2Nlc3MgaW1hZ2UgZGF0YScpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc1N0cmluZykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCBjYW52YXMgPSBjcmVhdGVDYW52YXMoKTtcbiAgICAgIGNvbnN0IGNvbnRleHQgPSBjcmVhdGVDYW52YXNDb250ZXh0KGNhbnZhcyk7XG4gICAgICBpZiAoIWltYWdlIHx8ICFjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiByZWplY3QoKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG5ld0ltYWdlID0gbmV3IEltYWdlKCk7XG4gICAgICBuZXdJbWFnZS5jcm9zc09yaWdpbiA9ICdBbm9ueW1vdXMnO1xuICAgICAgbmV3SW1hZ2Uuc3JjID0gaW1hZ2U7XG4gICAgICBuZXdJbWFnZS5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgIGNhbnZhcy53aWR0aCA9IG5ld0ltYWdlLndpZHRoO1xuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gbmV3SW1hZ2UuaGVpZ2h0O1xuICAgICAgICBjb250ZXh0LmRyYXdJbWFnZShuZXdJbWFnZSwgMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgY29uc3QgaW1nID0gY29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcblxuICAgICAgICBidWZmZXJUb1RlbnNvck9wdGlvbnMuaGVpZ2h0ID0gY2FudmFzLmhlaWdodDtcbiAgICAgICAgYnVmZmVyVG9UZW5zb3JPcHRpb25zLndpZHRoID0gY2FudmFzLndpZHRoO1xuICAgICAgICByZXNvbHZlKGJ1ZmZlclRvVGVuc29yKGltZy5kYXRhLCBidWZmZXJUb1RlbnNvck9wdGlvbnMpKTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBkYXRhIHByb3ZpZGVkIGlzIG5vdCBzdXBwb3J0ZWQgLSBhYm9ydGVkIHRlbnNvciBjcmVhdGlvbicpO1xuICB9XG5cbiAgaWYgKGRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBidWZmZXJUb1RlbnNvcihkYXRhLCBidWZmZXJUb1RlbnNvck9wdGlvbnMpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgZGF0YSBwcm92aWRlZCBpcyBub3Qgc3VwcG9ydGVkIC0gYWJvcnRlZCB0ZW5zb3IgY3JlYXRpb24nKTtcbiAgfVxufTtcblxuLyoqXG4gKiBpbXBsZW1lbnRhdGlvbiBvZiBUZW5zb3IuZnJvbVRleHR1cmUoKS5cbiAqL1xuZXhwb3J0IGNvbnN0IHRlbnNvckZyb21UZXh0dXJlID0gPFQgZXh0ZW5kcyBUZW5zb3JJbnRlcmZhY2UuVGV4dHVyZURhdGFUeXBlcz4oXG4gICAgdGV4dHVyZTogVGVuc29ySW50ZXJmYWNlLlRleHR1cmVUeXBlLCBvcHRpb25zOiBUZW5zb3JGcm9tVGV4dHVyZU9wdGlvbnM8VD4pOiBUZW5zb3IgPT4ge1xuICBjb25zdCB7d2lkdGgsIGhlaWdodCwgZG93bmxvYWQsIGRpc3Bvc2V9ID0gb3B0aW9ucztcbiAgLy8gQWx3YXlzIGFzc3VtZSBSR0JBRjMyLiBUT0RPOiBzdXBwb3J0IGRpZmZlcmVudCB0ZXh0dXJlIGZvcm1hdFxuICBjb25zdCBkaW1zID0gWzEsIGhlaWdodCwgd2lkdGgsIDRdO1xuICByZXR1cm4gbmV3IFRlbnNvcih7bG9jYXRpb246ICd0ZXh0dXJlJywgdHlwZTogJ2Zsb2F0MzInLCB0ZXh0dXJlLCBkaW1zLCBkb3dubG9hZCwgZGlzcG9zZX0pO1xufTtcblxuLyoqXG4gKiBpbXBsZW1lbnRhdGlvbiBvZiBUZW5zb3IuZnJvbUdwdUJ1ZmZlcigpLlxuICovXG5leHBvcnQgY29uc3QgdGVuc29yRnJvbUdwdUJ1ZmZlciA9IDxUIGV4dGVuZHMgVGVuc29ySW50ZXJmYWNlLkdwdUJ1ZmZlckRhdGFUeXBlcz4oXG4gICAgZ3B1QnVmZmVyOiBUZW5zb3JJbnRlcmZhY2UuR3B1QnVmZmVyVHlwZSwgb3B0aW9uczogVGVuc29yRnJvbUdwdUJ1ZmZlck9wdGlvbnM8VD4pOiBUZW5zb3IgPT4ge1xuICBjb25zdCB7ZGF0YVR5cGUsIGRpbXMsIGRvd25sb2FkLCBkaXNwb3NlfSA9IG9wdGlvbnM7XG4gIHJldHVybiBuZXcgVGVuc29yKHtsb2NhdGlvbjogJ2dwdS1idWZmZXInLCB0eXBlOiBkYXRhVHlwZSA/PyAnZmxvYXQzMicsIGdwdUJ1ZmZlciwgZGltcywgZG93bmxvYWQsIGRpc3Bvc2V9KTtcbn07XG5cbi8qKlxuICogaW1wbGVtZW50YXRpb24gb2YgVGVuc29yLmZyb21QaW5uZWRCdWZmZXIoKS5cbiAqL1xuZXhwb3J0IGNvbnN0IHRlbnNvckZyb21QaW5uZWRCdWZmZXIgPSA8VCBleHRlbmRzIFRlbnNvckludGVyZmFjZS5DcHVQaW5uZWREYXRhVHlwZXM+KFxuICAgIHR5cGU6IFQsIGJ1ZmZlcjogVGVuc29ySW50ZXJmYWNlLkRhdGFUeXBlTWFwW1RdLCBkaW1zPzogcmVhZG9ubHkgbnVtYmVyW10pOiBUZW5zb3IgPT5cbiAgICBuZXcgVGVuc29yKHtsb2NhdGlvbjogJ2NwdS1waW5uZWQnLCB0eXBlLCBkYXRhOiBidWZmZXIsIGRpbXM6IGRpbXMgPz8gW2J1ZmZlci5sZW5ndGhdfSk7XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7VGVuc29yfSBmcm9tICcuL3RlbnNvci5qcyc7XG5cbmV4cG9ydCB0eXBlIFN1cHBvcnRlZFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnMgPSBGbG9hdDMyQXJyYXlDb25zdHJ1Y3RvcnxVaW50OEFycmF5Q29uc3RydWN0b3J8SW50OEFycmF5Q29uc3RydWN0b3J8XG4gICAgVWludDE2QXJyYXlDb25zdHJ1Y3RvcnxJbnQxNkFycmF5Q29uc3RydWN0b3J8SW50MzJBcnJheUNvbnN0cnVjdG9yfEJpZ0ludDY0QXJyYXlDb25zdHJ1Y3RvcnxVaW50OEFycmF5Q29uc3RydWN0b3J8XG4gICAgRmxvYXQ2NEFycmF5Q29uc3RydWN0b3J8VWludDMyQXJyYXlDb25zdHJ1Y3RvcnxCaWdVaW50NjRBcnJheUNvbnN0cnVjdG9yO1xuZXhwb3J0IHR5cGUgU3VwcG9ydGVkVHlwZWRBcnJheSA9IEluc3RhbmNlVHlwZTxTdXBwb3J0ZWRUeXBlZEFycmF5Q29uc3RydWN0b3JzPjtcblxuLy8gYSBydW50aW1lIG1hcCB0aGF0IG1hcHMgdHlwZSBzdHJpbmcgdG8gVHlwZWRBcnJheSBjb25zdHJ1Y3Rvci4gU2hvdWxkIG1hdGNoIFRlbnNvci5EYXRhVHlwZU1hcC5cbmV4cG9ydCBjb25zdCBOVU1FUklDX1RFTlNPUl9UWVBFX1RPX1RZUEVEQVJSQVlfTUFQID0gbmV3IE1hcDxzdHJpbmcsIFN1cHBvcnRlZFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnM+KFtcbiAgWydmbG9hdDMyJywgRmxvYXQzMkFycmF5XSxcbiAgWyd1aW50OCcsIFVpbnQ4QXJyYXldLFxuICBbJ2ludDgnLCBJbnQ4QXJyYXldLFxuICBbJ3VpbnQxNicsIFVpbnQxNkFycmF5XSxcbiAgWydpbnQxNicsIEludDE2QXJyYXldLFxuICBbJ2ludDMyJywgSW50MzJBcnJheV0sXG4gIFsnYm9vbCcsIFVpbnQ4QXJyYXldLFxuICBbJ2Zsb2F0NjQnLCBGbG9hdDY0QXJyYXldLFxuICBbJ3VpbnQzMicsIFVpbnQzMkFycmF5XSxcbl0pO1xuXG4vLyBhIHJ1bnRpbWUgbWFwIHRoYXQgbWFwcyB0eXBlIHN0cmluZyB0byBUeXBlZEFycmF5IGNvbnN0cnVjdG9yLiBTaG91bGQgbWF0Y2ggVGVuc29yLkRhdGFUeXBlTWFwLlxuZXhwb3J0IGNvbnN0IE5VTUVSSUNfVEVOU09SX1RZUEVEQVJSQVlfVE9fVFlQRV9NQVAgPSBuZXcgTWFwPFN1cHBvcnRlZFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnMsIFRlbnNvci5UeXBlPihbXG4gIFtGbG9hdDMyQXJyYXksICdmbG9hdDMyJ10sXG4gIFtVaW50OEFycmF5LCAndWludDgnXSxcbiAgW0ludDhBcnJheSwgJ2ludDgnXSxcbiAgW1VpbnQxNkFycmF5LCAndWludDE2J10sXG4gIFtJbnQxNkFycmF5LCAnaW50MTYnXSxcbiAgW0ludDMyQXJyYXksICdpbnQzMiddLFxuICBbRmxvYXQ2NEFycmF5LCAnZmxvYXQ2NCddLFxuICBbVWludDMyQXJyYXksICd1aW50MzInXSxcbl0pO1xuXG4vLyBhIGR1bW15IHR5cGUgZGVjbGFyYXRpb24gZm9yIEZsb2F0MTZBcnJheSBpbiBjYXNlIGFueSBwb2x5ZmlsbCBpcyBhdmFpbGFibGUuXG5kZWNsYXJlIGdsb2JhbCB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb24sIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgY29uc3QgRmxvYXQxNkFycmF5OiBhbnk7XG59XG5cbi8vIHRoZSBmb2xsb3dpbmcgY29kZSBhbGxvd3MgZGVsYXlpbmcgZXhlY3V0aW9uIG9mIEJpZ0ludC9GbG9hdDE2QXJyYXkgY2hlY2tpbmcuIFRoaXMgYWxsb3dzIGxhenkgaW5pdGlhbGl6YXRpb24gZm9yXG4vLyBOVU1FUklDX1RFTlNPUl9UWVBFX1RPX1RZUEVEQVJSQVlfTUFQIGFuZCBOVU1FUklDX1RFTlNPUl9UWVBFREFSUkFZX1RPX1RZUEVfTUFQLCB3aGljaCBhbGxvd3MgQmlnSW50L0Zsb2F0MTZBcnJheVxuLy8gcG9seWZpbGwgaWYgYXZhaWxhYmxlLlxubGV0IGlzVHlwZWRBcnJheUNoZWNrZWQgPSBmYWxzZTtcbmV4cG9ydCBjb25zdCBjaGVja1R5cGVkQXJyYXkgPSAoKSA9PiB7XG4gIGlmICghaXNUeXBlZEFycmF5Q2hlY2tlZCkge1xuICAgIGlzVHlwZWRBcnJheUNoZWNrZWQgPSB0cnVlO1xuICAgIGNvbnN0IGlzQmlnSW50NjRBcnJheUF2YWlsYWJsZSA9IHR5cGVvZiBCaWdJbnQ2NEFycmF5ICE9PSAndW5kZWZpbmVkJyAmJiBCaWdJbnQ2NEFycmF5LmZyb207XG4gICAgY29uc3QgaXNCaWdVaW50NjRBcnJheUF2YWlsYWJsZSA9IHR5cGVvZiBCaWdVaW50NjRBcnJheSAhPT0gJ3VuZGVmaW5lZCcgJiYgQmlnVWludDY0QXJyYXkuZnJvbTtcbiAgICBjb25zdCBpc0Zsb2F0MTZBcnJheUF2YWlsYWJsZSA9IHR5cGVvZiBGbG9hdDE2QXJyYXkgIT09ICd1bmRlZmluZWQnICYmIEZsb2F0MTZBcnJheS5mcm9tO1xuXG4gICAgaWYgKGlzQmlnSW50NjRBcnJheUF2YWlsYWJsZSkge1xuICAgICAgTlVNRVJJQ19URU5TT1JfVFlQRV9UT19UWVBFREFSUkFZX01BUC5zZXQoJ2ludDY0JywgQmlnSW50NjRBcnJheSk7XG4gICAgICBOVU1FUklDX1RFTlNPUl9UWVBFREFSUkFZX1RPX1RZUEVfTUFQLnNldChCaWdJbnQ2NEFycmF5LCAnaW50NjQnKTtcbiAgICB9XG4gICAgaWYgKGlzQmlnVWludDY0QXJyYXlBdmFpbGFibGUpIHtcbiAgICAgIE5VTUVSSUNfVEVOU09SX1RZUEVfVE9fVFlQRURBUlJBWV9NQVAuc2V0KCd1aW50NjQnLCBCaWdVaW50NjRBcnJheSk7XG4gICAgICBOVU1FUklDX1RFTlNPUl9UWVBFREFSUkFZX1RPX1RZUEVfTUFQLnNldChCaWdVaW50NjRBcnJheSwgJ3VpbnQ2NCcpO1xuICAgIH1cbiAgICBpZiAoaXNGbG9hdDE2QXJyYXlBdmFpbGFibGUpIHtcbiAgICAgIE5VTUVSSUNfVEVOU09SX1RZUEVfVE9fVFlQRURBUlJBWV9NQVAuc2V0KCdmbG9hdDE2JywgRmxvYXQxNkFycmF5KTtcbiAgICAgIE5VTUVSSUNfVEVOU09SX1RZUEVEQVJSQVlfVE9fVFlQRV9NQVAuc2V0KEZsb2F0MTZBcnJheSwgJ2Zsb2F0MTYnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaWYgRmxvYXQxNkFycmF5IGlzIG5vdCBhdmFpbGFibGUsIHVzZSAnVWludDE2QXJyYXknIHRvIHN0b3JlIHRoZSBkYXRhLlxuICAgICAgTlVNRVJJQ19URU5TT1JfVFlQRV9UT19UWVBFREFSUkFZX01BUC5zZXQoJ2Zsb2F0MTYnLCBVaW50MTZBcnJheSk7XG4gICAgfVxuICB9XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0NwdVBpbm5lZENvbnN0cnVjdG9yUGFyYW1ldGVycywgR3B1QnVmZmVyQ29uc3RydWN0b3JQYXJhbWV0ZXJzLCBUZXh0dXJlQ29uc3RydWN0b3JQYXJhbWV0ZXJzfSBmcm9tICcuL3RlbnNvci1mYWN0b3J5LmpzJztcbmltcG9ydCB7VGVuc29yfSBmcm9tICcuL3RlbnNvci1pbXBsLmpzJztcblxuLyoqXG4gKiBjYWxjdWxhdGUgc2l6ZSBmcm9tIGRpbXMuXG4gKlxuICogQHBhcmFtIGRpbXMgdGhlIGRpbXMgYXJyYXkuIE1heSBiZSBhbiBpbGxlZ2FsIGlucHV0LlxuICovXG5leHBvcnQgY29uc3QgY2FsY3VsYXRlU2l6ZSA9IChkaW1zOiByZWFkb25seSB1bmtub3duW10pOiBudW1iZXIgPT4ge1xuICBsZXQgc2l6ZSA9IDE7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZGltcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGRpbSA9IGRpbXNbaV07XG4gICAgaWYgKHR5cGVvZiBkaW0gIT09ICdudW1iZXInIHx8ICFOdW1iZXIuaXNTYWZlSW50ZWdlcihkaW0pKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBkaW1zWyR7aX1dIG11c3QgYmUgYW4gaW50ZWdlciwgZ290OiAke2RpbX1gKTtcbiAgICB9XG4gICAgaWYgKGRpbSA8IDApIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBkaW1zWyR7aX1dIG11c3QgYmUgYSBub24tbmVnYXRpdmUgaW50ZWdlciwgZ290OiAke2RpbX1gKTtcbiAgICB9XG4gICAgc2l6ZSAqPSBkaW07XG4gIH1cbiAgcmV0dXJuIHNpemU7XG59O1xuXG4vKipcbiAqIGltcGxlbWVudGF0aW9uIG9mIFRlbnNvci5yZXNoYXBlKClcbiAqL1xuZXhwb3J0IGNvbnN0IHRlbnNvclJlc2hhcGUgPSAodGVuc29yOiBUZW5zb3IsIGRpbXM6IHJlYWRvbmx5IG51bWJlcltdKTogVGVuc29yID0+IHtcbiAgc3dpdGNoICh0ZW5zb3IubG9jYXRpb24pIHtcbiAgICBjYXNlICdjcHUnOlxuICAgICAgcmV0dXJuIG5ldyBUZW5zb3IodGVuc29yLnR5cGUsIHRlbnNvci5kYXRhLCBkaW1zKTtcbiAgICBjYXNlICdjcHUtcGlubmVkJzpcbiAgICAgIHJldHVybiBuZXcgVGVuc29yKHtcbiAgICAgICAgbG9jYXRpb246ICdjcHUtcGlubmVkJyxcbiAgICAgICAgZGF0YTogdGVuc29yLmRhdGEgYXMgQ3B1UGlubmVkQ29uc3RydWN0b3JQYXJhbWV0ZXJzWydkYXRhJ10sXG4gICAgICAgIHR5cGU6IHRlbnNvci50eXBlIGFzIENwdVBpbm5lZENvbnN0cnVjdG9yUGFyYW1ldGVyc1sndHlwZSddLFxuICAgICAgICBkaW1zLFxuICAgICAgfSk7XG4gICAgY2FzZSAndGV4dHVyZSc6XG4gICAgICByZXR1cm4gbmV3IFRlbnNvcih7XG4gICAgICAgIGxvY2F0aW9uOiAndGV4dHVyZScsXG4gICAgICAgIHRleHR1cmU6IHRlbnNvci50ZXh0dXJlLFxuICAgICAgICB0eXBlOiB0ZW5zb3IudHlwZSBhcyBUZXh0dXJlQ29uc3RydWN0b3JQYXJhbWV0ZXJzWyd0eXBlJ10sXG4gICAgICAgIGRpbXMsXG4gICAgICB9KTtcbiAgICBjYXNlICdncHUtYnVmZmVyJzpcbiAgICAgIHJldHVybiBuZXcgVGVuc29yKHtcbiAgICAgICAgbG9jYXRpb246ICdncHUtYnVmZmVyJyxcbiAgICAgICAgZ3B1QnVmZmVyOiB0ZW5zb3IuZ3B1QnVmZmVyLFxuICAgICAgICB0eXBlOiB0ZW5zb3IudHlwZSBhcyBHcHVCdWZmZXJDb25zdHJ1Y3RvclBhcmFtZXRlcnNbJ3R5cGUnXSxcbiAgICAgICAgZGltcyxcbiAgICAgIH0pO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHRlbnNvclJlc2hhcGU6IHRlbnNvciBsb2NhdGlvbiAke3RlbnNvci5sb2NhdGlvbn0gaXMgbm90IHN1cHBvcnRlZGApO1xuICB9XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge3RlbnNvclRvRGF0YVVSTCwgdGVuc29yVG9JbWFnZURhdGF9IGZyb20gJy4vdGVuc29yLWNvbnZlcnNpb24taW1wbC5qcyc7XG5pbXBvcnQge1RlbnNvclRvRGF0YVVybE9wdGlvbnMsIFRlbnNvclRvSW1hZ2VEYXRhT3B0aW9uc30gZnJvbSAnLi90ZW5zb3ItY29udmVyc2lvbi5qcyc7XG5pbXBvcnQge3RlbnNvckZyb21HcHVCdWZmZXIsIHRlbnNvckZyb21JbWFnZSwgdGVuc29yRnJvbVBpbm5lZEJ1ZmZlciwgdGVuc29yRnJvbVRleHR1cmV9IGZyb20gJy4vdGVuc29yLWZhY3RvcnktaW1wbC5qcyc7XG5pbXBvcnQge0NwdVBpbm5lZENvbnN0cnVjdG9yUGFyYW1ldGVycywgR3B1QnVmZmVyQ29uc3RydWN0b3JQYXJhbWV0ZXJzLCBUZW5zb3JGcm9tR3B1QnVmZmVyT3B0aW9ucywgVGVuc29yRnJvbUltYWdlQml0bWFwT3B0aW9ucywgVGVuc29yRnJvbUltYWdlRGF0YU9wdGlvbnMsIFRlbnNvckZyb21JbWFnZUVsZW1lbnRPcHRpb25zLCBUZW5zb3JGcm9tVGV4dHVyZU9wdGlvbnMsIFRlbnNvckZyb21VcmxPcHRpb25zLCBUZXh0dXJlQ29uc3RydWN0b3JQYXJhbWV0ZXJzfSBmcm9tICcuL3RlbnNvci1mYWN0b3J5LmpzJztcbmltcG9ydCB7Y2hlY2tUeXBlZEFycmF5LCBOVU1FUklDX1RFTlNPUl9UWVBFX1RPX1RZUEVEQVJSQVlfTUFQLCBOVU1FUklDX1RFTlNPUl9UWVBFREFSUkFZX1RPX1RZUEVfTUFQLCBTdXBwb3J0ZWRUeXBlZEFycmF5LCBTdXBwb3J0ZWRUeXBlZEFycmF5Q29uc3RydWN0b3JzfSBmcm9tICcuL3RlbnNvci1pbXBsLXR5cGUtbWFwcGluZy5qcyc7XG5pbXBvcnQge2NhbGN1bGF0ZVNpemUsIHRlbnNvclJlc2hhcGV9IGZyb20gJy4vdGVuc29yLXV0aWxzLWltcGwuanMnO1xuaW1wb3J0IHtUZW5zb3IgYXMgVGVuc29ySW50ZXJmYWNlfSBmcm9tICcuL3RlbnNvci5qcyc7XG5cbi8vIHR5cGUgYWxpYXNlcyBmb3IgdGhvc2UgZXhwb3J0ZWQgZnJvbSBUZW5zb3IgaW50ZXJmYWNlXG5cbnR5cGUgVGVuc29yVHlwZSA9IFRlbnNvckludGVyZmFjZS5UeXBlO1xudHlwZSBUZW5zb3JEYXRhVHlwZSA9IFRlbnNvckludGVyZmFjZS5EYXRhVHlwZTtcbnR5cGUgVGVuc29yRGF0YUxvY2F0aW9uID0gVGVuc29ySW50ZXJmYWNlLkRhdGFMb2NhdGlvbjtcbnR5cGUgVGVuc29yVGV4dHVyZVR5cGUgPSBUZW5zb3JJbnRlcmZhY2UuVGV4dHVyZVR5cGU7XG50eXBlIFRlbnNvckdwdUJ1ZmZlclR5cGUgPSBUZW5zb3JJbnRlcmZhY2UuR3B1QnVmZmVyVHlwZTtcblxuLyoqXG4gKiB0aGUgaW1wbGVtZW50YXRpb24gb2YgVGVuc29yIGludGVyZmFjZS5cbiAqXG4gKiBAaWdub3JlXG4gKi9cbmV4cG9ydCBjbGFzcyBUZW5zb3IgaW1wbGVtZW50cyBUZW5zb3JJbnRlcmZhY2Uge1xuICAvLyAjcmVnaW9uIGNvbnN0cnVjdG9yc1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgQ1BVIHRlbnNvciBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gdHlwZSwgZGF0YSBhbmQgZGltcy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKFxuICAgICAgdHlwZTogVGVuc29yVHlwZSwgZGF0YTogVGVuc29yRGF0YVR5cGV8cmVhZG9ubHkgc3RyaW5nW118cmVhZG9ubHkgbnVtYmVyW118cmVhZG9ubHkgYm9vbGVhbltdLFxuICAgICAgZGltcz86IHJlYWRvbmx5IG51bWJlcltdKTtcbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhIG5ldyBDUFUgdGVuc29yIG9iamVjdCBmcm9tIHRoZSBnaXZlbiBkYXRhIGFuZCBkaW1zLiBUeXBlIGlzIGluZmVycmVkIGZyb20gZGF0YS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGRhdGE6IFRlbnNvckRhdGFUeXBlfHJlYWRvbmx5IHN0cmluZ1tdfHJlYWRvbmx5IGJvb2xlYW5bXSwgZGltcz86IHJlYWRvbmx5IG51bWJlcltdKTtcbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhIG5ldyB0ZW5zb3Igb2JqZWN0IGZyb20gdGhlIHBpbm5lZCBDUFUgZGF0YSB3aXRoIHRoZSBnaXZlbiB0eXBlIGFuZCBkaW1zLlxuICAgKlxuICAgKiBUZW5zb3IncyBsb2NhdGlvbiB3aWxsIGJlIHNldCB0byAnY3B1LXBpbm5lZCcuXG4gICAqXG4gICAqIEBwYXJhbSBwYXJhbXMgLSBTcGVjaWZ5IHRoZSBwYXJhbWV0ZXJzIHRvIGNvbnN0cnVjdCB0aGUgdGVuc29yLlxuICAgKi9cbiAgY29uc3RydWN0b3IocGFyYW1zOiBDcHVQaW5uZWRDb25zdHJ1Y3RvclBhcmFtZXRlcnMpO1xuICAvKipcbiAgICogQ29uc3RydWN0IGEgbmV3IHRlbnNvciBvYmplY3QgZnJvbSB0aGUgV2ViR0wgdGV4dHVyZSB3aXRoIHRoZSBnaXZlbiB0eXBlIGFuZCBkaW1zLlxuICAgKlxuICAgKiBUZW5zb3IncyBsb2NhdGlvbiB3aWxsIGJlIHNldCB0byAndGV4dHVyZScuXG4gICAqXG4gICAqIEBwYXJhbSBwYXJhbXMgLSBTcGVjaWZ5IHRoZSBwYXJhbWV0ZXJzIHRvIGNvbnN0cnVjdCB0aGUgdGVuc29yLlxuICAgKi9cbiAgY29uc3RydWN0b3IocGFyYW1zOiBUZXh0dXJlQ29uc3RydWN0b3JQYXJhbWV0ZXJzKTtcbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhIG5ldyB0ZW5zb3Igb2JqZWN0IGZyb20gdGhlIFdlYkdQVSBidWZmZXIgd2l0aCB0aGUgZ2l2ZW4gdHlwZSBhbmQgZGltcy5cbiAgICpcbiAgICogVGVuc29yJ3MgbG9jYXRpb24gd2lsbCBiZSBzZXQgdG8gJ2dwdS1idWZmZXInLlxuICAgKlxuICAgKiBAcGFyYW0gcGFyYW1zIC0gU3BlY2lmeSB0aGUgcGFyYW1ldGVycyB0byBjb25zdHJ1Y3QgdGhlIHRlbnNvci5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHBhcmFtczogR3B1QnVmZmVyQ29uc3RydWN0b3JQYXJhbWV0ZXJzKTtcblxuICAvKipcbiAgICogaW1wbGVtZW50YXRpb24uXG4gICAqL1xuICBjb25zdHJ1Y3RvcihcbiAgICAgIGFyZzA6IFRlbnNvclR5cGV8VGVuc29yRGF0YVR5cGV8cmVhZG9ubHkgc3RyaW5nW118cmVhZG9ubHkgYm9vbGVhbltdfENwdVBpbm5lZENvbnN0cnVjdG9yUGFyYW1ldGVyc3xcbiAgICAgIFRleHR1cmVDb25zdHJ1Y3RvclBhcmFtZXRlcnN8R3B1QnVmZmVyQ29uc3RydWN0b3JQYXJhbWV0ZXJzLFxuICAgICAgYXJnMT86IFRlbnNvckRhdGFUeXBlfHJlYWRvbmx5IG51bWJlcltdfHJlYWRvbmx5IHN0cmluZ1tdfHJlYWRvbmx5IGJvb2xlYW5bXSwgYXJnMj86IHJlYWRvbmx5IG51bWJlcltdKSB7XG4gICAgLy8gcGVyZm9ybSBvbmUtdGltZSBjaGVjayBmb3IgQmlnSW50L0Zsb2F0MTZBcnJheSBzdXBwb3J0XG4gICAgY2hlY2tUeXBlZEFycmF5KCk7XG5cbiAgICBsZXQgdHlwZTogVGVuc29yVHlwZTtcbiAgICBsZXQgZGltczogcmVhZG9ubHkgbnVtYmVyW107XG5cbiAgICBpZiAodHlwZW9mIGFyZzAgPT09ICdvYmplY3QnICYmICdsb2NhdGlvbicgaW4gYXJnMCkge1xuICAgICAgLy9cbiAgICAgIC8vIGNvbnN0cnVjdGluZyB0ZW5zb3IgZnJvbSBzcGVjaWZpYyBsb2NhdGlvblxuICAgICAgLy9cbiAgICAgIHRoaXMuZGF0YUxvY2F0aW9uID0gYXJnMC5sb2NhdGlvbjtcbiAgICAgIHR5cGUgPSBhcmcwLnR5cGU7XG4gICAgICBkaW1zID0gYXJnMC5kaW1zO1xuICAgICAgc3dpdGNoIChhcmcwLmxvY2F0aW9uKSB7XG4gICAgICAgIGNhc2UgJ2NwdS1waW5uZWQnOiB7XG4gICAgICAgICAgY29uc3QgZXhwZWN0ZWRUeXBlZEFycmF5Q29uc3RydWN0b3IgPSBOVU1FUklDX1RFTlNPUl9UWVBFX1RPX1RZUEVEQVJSQVlfTUFQLmdldCh0eXBlKTtcbiAgICAgICAgICBpZiAoIWV4cGVjdGVkVHlwZWRBcnJheUNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGB1bnN1cHBvcnRlZCB0eXBlIFwiJHt0eXBlfVwiIHRvIGNyZWF0ZSB0ZW5zb3IgZnJvbSBwaW5uZWQgYnVmZmVyYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghKGFyZzAuZGF0YSBpbnN0YW5jZW9mIGV4cGVjdGVkVHlwZWRBcnJheUNvbnN0cnVjdG9yKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgYnVmZmVyIHNob3VsZCBiZSBvZiB0eXBlICR7ZXhwZWN0ZWRUeXBlZEFycmF5Q29uc3RydWN0b3IubmFtZX1gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5jcHVEYXRhID0gYXJnMC5kYXRhO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ3RleHR1cmUnOiB7XG4gICAgICAgICAgaWYgKHR5cGUgIT09ICdmbG9hdDMyJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgdW5zdXBwb3J0ZWQgdHlwZSBcIiR7dHlwZX1cIiB0byBjcmVhdGUgdGVuc29yIGZyb20gdGV4dHVyZWApO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmdwdVRleHR1cmVEYXRhID0gYXJnMC50ZXh0dXJlO1xuICAgICAgICAgIHRoaXMuZG93bmxvYWRlciA9IGFyZzAuZG93bmxvYWQ7XG4gICAgICAgICAgdGhpcy5kaXNwb3NlciA9IGFyZzAuZGlzcG9zZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdncHUtYnVmZmVyJzoge1xuICAgICAgICAgIGlmICgodHlwZSAhPT0gJ2Zsb2F0MzInICYmIHR5cGUgIT09ICdmbG9hdDE2JyAmJiB0eXBlICE9PSAnaW50MzInICYmIHR5cGUgIT09ICdpbnQ2NCcgJiYgdHlwZSAhPT0gJ3VpbnQzMicgJiZcbiAgICAgICAgICAgICAgIHR5cGUgIT09ICd1aW50OCcgJiYgdHlwZSAhPT0gJ2Jvb2wnKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgdW5zdXBwb3J0ZWQgdHlwZSBcIiR7dHlwZX1cIiB0byBjcmVhdGUgdGVuc29yIGZyb20gZ3B1IGJ1ZmZlcmApO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmdwdUJ1ZmZlckRhdGEgPSBhcmcwLmdwdUJ1ZmZlcjtcbiAgICAgICAgICB0aGlzLmRvd25sb2FkZXIgPSBhcmcwLmRvd25sb2FkO1xuICAgICAgICAgIHRoaXMuZGlzcG9zZXIgPSBhcmcwLmRpc3Bvc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRlbnNvciBjb25zdHJ1Y3RvcjogdW5zdXBwb3J0ZWQgbG9jYXRpb24gJyR7dGhpcy5kYXRhTG9jYXRpb259J2ApO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvL1xuICAgICAgLy8gY29uc3RydWN0aW5nIHRlbnNvciBvZiBsb2NhdGlvbiAnY3B1J1xuICAgICAgLy9cbiAgICAgIGxldCBkYXRhOiBUZW5zb3JEYXRhVHlwZTtcbiAgICAgIGxldCBtYXliZURpbXM6IHR5cGVvZiBhcmcxfHR5cGVvZiBhcmcyO1xuICAgICAgLy8gY2hlY2sgd2hldGhlciBhcmcwIGlzIHR5cGUgb3IgZGF0YVxuICAgICAgaWYgKHR5cGVvZiBhcmcwID09PSAnc3RyaW5nJykge1xuICAgICAgICAvL1xuICAgICAgICAvLyBPdmVycmlkZTogY29uc3RydWN0b3IodHlwZSwgZGF0YSwgLi4uKVxuICAgICAgICAvL1xuICAgICAgICB0eXBlID0gYXJnMDtcbiAgICAgICAgbWF5YmVEaW1zID0gYXJnMjtcbiAgICAgICAgaWYgKGFyZzAgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgLy8gc3RyaW5nIHRlbnNvclxuICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShhcmcxKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQSBzdHJpbmcgdGVuc29yXFwncyBkYXRhIG11c3QgYmUgYSBzdHJpbmcgYXJyYXkuJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIHdlIGRvbid0IGNoZWNrIHdoZXRoZXIgZXZlcnkgZWxlbWVudCBpbiB0aGUgYXJyYXkgaXMgc3RyaW5nOyB0aGlzIGlzIHRvbyBzbG93LiB3ZSBhc3N1bWUgaXQncyBjb3JyZWN0IGFuZFxuICAgICAgICAgIC8vIGVycm9yIHdpbGwgYmUgcG9wdWxhdGVkIGF0IGluZmVyZW5jZVxuICAgICAgICAgIGRhdGEgPSBhcmcxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIG51bWVyaWMgdGVuc29yXG4gICAgICAgICAgY29uc3QgdHlwZWRBcnJheUNvbnN0cnVjdG9yID0gTlVNRVJJQ19URU5TT1JfVFlQRV9UT19UWVBFREFSUkFZX01BUC5nZXQoYXJnMCk7XG4gICAgICAgICAgaWYgKHR5cGVkQXJyYXlDb25zdHJ1Y3RvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBVbnN1cHBvcnRlZCB0ZW5zb3IgdHlwZTogJHthcmcwfS5gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJnMSkpIHtcbiAgICAgICAgICAgIGlmIChhcmcwID09PSAnZmxvYXQxNicgJiYgdHlwZWRBcnJheUNvbnN0cnVjdG9yID09PSBVaW50MTZBcnJheSkge1xuICAgICAgICAgICAgICAvLyBXaGVuIG5vIEZsb2F0MTZBcnJheSBwb2x5ZmlsbCBpcyB1c2VkLCB3ZSBjYW5ub3QgY3JlYXRlICdmbG9hdDE2JyB0ZW5zb3IgZnJvbSBudW1iZXIgYXJyYXkuXG4gICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgIC8vIFRocm93IGVycm9yIGhlcmUgYmVjYXVzZSB3aGVuIHVzZXIgdHJ5IHRvIHVzZSBudW1iZXIgYXJyYXkgYXMgZGF0YSxcbiAgICAgICAgICAgICAgLy8gZS5nLiBuZXcgVGVuc29yKCdmbG9hdDE2JywgWzEsIDIsIDMsIDRdLCBkaW1zKSksIGl0IHdpbGwgYWN0dWFsbHkgY2FsbFxuICAgICAgICAgICAgICAvLyBVaW50MTZBcnJheS5mcm9tKGFyZzEpIHdoaWNoIGdlbmVyYXRlcyB3cm9uZyBkYXRhLlxuICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgICAgICAgJ0NyZWF0aW5nIGEgZmxvYXQxNiB0ZW5zb3IgZnJvbSBudW1iZXIgYXJyYXkgaXMgbm90IHN1cHBvcnRlZC4gUGxlYXNlIHVzZSBVaW50MTZBcnJheSBhcyBkYXRhLicpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChhcmcwID09PSAndWludDY0JyB8fCBhcmcwID09PSAnaW50NjQnKSB7XG4gICAgICAgICAgICAgIC8vIHVzZSAnYXMgYW55JyBoZXJlIGJlY2F1c2U6XG4gICAgICAgICAgICAgIC8vIDEuIFR5cGVTY3JpcHQncyBjaGVjayBvbiB0eXBlIG9mICdBcnJheS5pc0FycmF5KCknIGRvZXMgbm90IHdvcmsgd2l0aCByZWFkb25seSBhcnJheXMuXG4gICAgICAgICAgICAgIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzE3MDAyXG4gICAgICAgICAgICAgIC8vIDIuIFR5cGVTY3JpcHQncyBjaGVjayBvbiB1bmlvbiB0eXBlIG9mICcoQmlnSW50NjRBcnJheUNvbnN0cnVjdG9yfEJpZ1VpbnQ2NEFycmF5Q29uc3RydWN0b3IpLmZyb20oKSdcbiAgICAgICAgICAgICAgLy8gZG9lcyBub3QgYWNjZXB0IHBhcmFtZXRlciBtYXBGbi5cbiAgICAgICAgICAgICAgLy8gMy4gcGFyYW1ldGVycyBvZiAnU3VwcG9ydGVkVHlwZWRBcnJheUNvbnN0cnVjdG9ycy5mcm9tKCknIGRvZXMgbm90IG1hdGNoIHRoZSByZXF1aXJlbWVudCBvZiB0aGUgdW5pb25cbiAgICAgICAgICAgICAgLy8gdHlwZS5cblxuICAgICAgICAgICAgICAvLyBhc3N1bWUgJ2FyZzEnIGlzIG9mIHR5cGUgXCJyZWFkb25seSBudW1iZXJbXXxyZWFkb25seSBiaWdpbnRbXVwiIGhlcmUuXG5cbiAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgZGF0YSA9ICh0eXBlZEFycmF5Q29uc3RydWN0b3IgYXMgYW55KS5mcm9tKGFyZzEsIEJpZ0ludCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBhc3N1bWUgJ2FyZzEnIGlzIG9mIHR5cGUgXCJyZWFkb25seSBudW1iZXJbXVwiIGhlcmUuXG4gICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgIGRhdGEgPSAodHlwZWRBcnJheUNvbnN0cnVjdG9yIGFzIGFueSkuZnJvbShhcmcxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGFyZzEgaW5zdGFuY2VvZiB0eXBlZEFycmF5Q29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgIGRhdGEgPSBhcmcxO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBBICR7dHlwZX0gdGVuc29yJ3MgZGF0YSBtdXN0IGJlIHR5cGUgb2YgJHt0eXBlZEFycmF5Q29uc3RydWN0b3J9YCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvL1xuICAgICAgICAvLyBPdmVycmlkZTogY29uc3RydWN0b3IoZGF0YSwgLi4uKVxuICAgICAgICAvL1xuICAgICAgICBtYXliZURpbXMgPSBhcmcxO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhcmcwKSkge1xuICAgICAgICAgIC8vIG9ubHkgYm9vbGVhbltdIGFuZCBzdHJpbmdbXSBpcyBzdXBwb3J0ZWRcbiAgICAgICAgICBpZiAoYXJnMC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RlbnNvciB0eXBlIGNhbm5vdCBiZSBpbmZlcnJlZCBmcm9tIGFuIGVtcHR5IGFycmF5LicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBmaXJzdEVsZW1lbnRUeXBlID0gdHlwZW9mIGFyZzBbMF07XG4gICAgICAgICAgaWYgKGZpcnN0RWxlbWVudFR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0eXBlID0gJ3N0cmluZyc7XG4gICAgICAgICAgICBkYXRhID0gYXJnMDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGZpcnN0RWxlbWVudFR5cGUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgdHlwZSA9ICdib29sJztcbiAgICAgICAgICAgIC8vICdhcmcwJyBpcyBvZiB0eXBlICdib29sZWFuW10nLiBVaW50OEFycmF5LmZyb20oYm9vbGVhbltdKSBhY3R1YWxseSB3b3JrcywgYnV0IHR5cGVzY3JpcHQgdGhpbmtzIHRoaXMgaXNcbiAgICAgICAgICAgIC8vIHdyb25nIHR5cGUuIFdlIHVzZSAnYXMgYW55JyB0byBtYWtlIGl0IGhhcHB5LlxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgIGRhdGEgPSBVaW50OEFycmF5LmZyb20oYXJnMCBhcyBhbnlbXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgZWxlbWVudCB0eXBlIG9mIGRhdGEgYXJyYXk6ICR7Zmlyc3RFbGVtZW50VHlwZX0uYCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGdldCB0ZW5zb3IgdHlwZSBmcm9tIFR5cGVkQXJyYXlcbiAgICAgICAgICBjb25zdCBtYXBwZWRUeXBlID1cbiAgICAgICAgICAgICAgTlVNRVJJQ19URU5TT1JfVFlQRURBUlJBWV9UT19UWVBFX01BUC5nZXQoYXJnMC5jb25zdHJ1Y3RvciBhcyBTdXBwb3J0ZWRUeXBlZEFycmF5Q29uc3RydWN0b3JzKTtcbiAgICAgICAgICBpZiAobWFwcGVkVHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBVbnN1cHBvcnRlZCB0eXBlIGZvciB0ZW5zb3IgZGF0YTogJHthcmcwLmNvbnN0cnVjdG9yfS5gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdHlwZSA9IG1hcHBlZFR5cGU7XG4gICAgICAgICAgZGF0YSA9IGFyZzAgYXMgU3VwcG9ydGVkVHlwZWRBcnJheTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyB0eXBlIGFuZCBkYXRhIGlzIHByb2Nlc3NlZCwgbm93IHByb2Nlc3NpbmcgZGltc1xuICAgICAgaWYgKG1heWJlRGltcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIGFzc3VtZSAxLUQgdGVuc29yIGlmIGRpbXMgb21pdHRlZFxuICAgICAgICBtYXliZURpbXMgPSBbZGF0YS5sZW5ndGhdO1xuICAgICAgfSBlbHNlIGlmICghQXJyYXkuaXNBcnJheShtYXliZURpbXMpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0EgdGVuc29yXFwncyBkaW1zIG11c3QgYmUgYSBudW1iZXIgYXJyYXknKTtcbiAgICAgIH1cbiAgICAgIGRpbXMgPSBtYXliZURpbXMgYXMgcmVhZG9ubHkgbnVtYmVyW107XG5cbiAgICAgIHRoaXMuY3B1RGF0YSA9IGRhdGE7XG4gICAgICB0aGlzLmRhdGFMb2NhdGlvbiA9ICdjcHUnO1xuICAgIH1cblxuICAgIC8vIHBlcmZvcm0gY2hlY2sgb24gZGltc1xuICAgIGNvbnN0IHNpemUgPSBjYWxjdWxhdGVTaXplKGRpbXMpO1xuICAgIC8vIGlmIGRhdGEgaXMgb24gQ1BVLCBjaGVjayB3aGV0aGVyIGRhdGEgbGVuZ3RoIG1hdGNoZXMgdGVuc29yIHNpemVcbiAgICBpZiAodGhpcy5jcHVEYXRhICYmIHNpemUgIT09IHRoaXMuY3B1RGF0YS5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGVuc29yJ3Mgc2l6ZSgke3NpemV9KSBkb2VzIG5vdCBtYXRjaCBkYXRhIGxlbmd0aCgke3RoaXMuY3B1RGF0YS5sZW5ndGh9KS5gKTtcbiAgICB9XG5cbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMuZGltcyA9IGRpbXM7XG4gICAgdGhpcy5zaXplID0gc2l6ZTtcbiAgfVxuICAvLyAjZW5kcmVnaW9uXG5cbiAgLy8gI3JlZ2lvbiBmYWN0b3J5XG4gIHN0YXRpYyBhc3luYyBmcm9tSW1hZ2UoXG4gICAgICBpbWFnZTogSW1hZ2VEYXRhfEhUTUxJbWFnZUVsZW1lbnR8SW1hZ2VCaXRtYXB8c3RyaW5nLFxuICAgICAgb3B0aW9ucz86IFRlbnNvckZyb21JbWFnZURhdGFPcHRpb25zfFRlbnNvckZyb21JbWFnZUVsZW1lbnRPcHRpb25zfFRlbnNvckZyb21JbWFnZUJpdG1hcE9wdGlvbnN8XG4gICAgICBUZW5zb3JGcm9tVXJsT3B0aW9ucyk6IFByb21pc2U8VGVuc29ySW50ZXJmYWNlPiB7XG4gICAgcmV0dXJuIHRlbnNvckZyb21JbWFnZShpbWFnZSwgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZnJvbVRleHR1cmU8VCBleHRlbmRzIFRlbnNvckludGVyZmFjZS5UZXh0dXJlRGF0YVR5cGVzPihcbiAgICAgIHRleHR1cmU6IFRlbnNvclRleHR1cmVUeXBlLCBvcHRpb25zOiBUZW5zb3JGcm9tVGV4dHVyZU9wdGlvbnM8VD4pOiBUZW5zb3JJbnRlcmZhY2Uge1xuICAgIHJldHVybiB0ZW5zb3JGcm9tVGV4dHVyZSh0ZXh0dXJlLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tR3B1QnVmZmVyPFQgZXh0ZW5kcyBUZW5zb3JJbnRlcmZhY2UuR3B1QnVmZmVyRGF0YVR5cGVzPihcbiAgICAgIGdwdUJ1ZmZlcjogVGVuc29yR3B1QnVmZmVyVHlwZSwgb3B0aW9uczogVGVuc29yRnJvbUdwdUJ1ZmZlck9wdGlvbnM8VD4pOiBUZW5zb3JJbnRlcmZhY2Uge1xuICAgIHJldHVybiB0ZW5zb3JGcm9tR3B1QnVmZmVyKGdwdUJ1ZmZlciwgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZnJvbVBpbm5lZEJ1ZmZlcjxUIGV4dGVuZHMgVGVuc29ySW50ZXJmYWNlLkNwdVBpbm5lZERhdGFUeXBlcz4oXG4gICAgICB0eXBlOiBULCBidWZmZXI6IFRlbnNvckludGVyZmFjZS5EYXRhVHlwZU1hcFtUXSwgZGltcz86IHJlYWRvbmx5IG51bWJlcltdKTogVGVuc29yIHtcbiAgICByZXR1cm4gdGVuc29yRnJvbVBpbm5lZEJ1ZmZlcih0eXBlLCBidWZmZXIsIGRpbXMpO1xuICB9XG5cbiAgLy8gI2VuZHJlZ2lvblxuXG4gIC8vICNyZWdpb24gY29udmVyc2lvbnNcbiAgdG9EYXRhVVJMKG9wdGlvbnM/OiBUZW5zb3JUb0RhdGFVcmxPcHRpb25zKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGVuc29yVG9EYXRhVVJMKHRoaXMsIG9wdGlvbnMpO1xuICB9XG5cbiAgdG9JbWFnZURhdGEob3B0aW9ucz86IFRlbnNvclRvSW1hZ2VEYXRhT3B0aW9ucyk6IEltYWdlRGF0YSB7XG4gICAgcmV0dXJuIHRlbnNvclRvSW1hZ2VEYXRhKHRoaXMsIG9wdGlvbnMpO1xuICB9XG4gIC8vICNlbmRyZWdpb25cblxuICAvLyAjcmVnaW9uIHB1YmxpYyBmaWVsZHNcbiAgcmVhZG9ubHkgZGltczogcmVhZG9ubHkgbnVtYmVyW107XG4gIHJlYWRvbmx5IHR5cGU6IFRlbnNvclR5cGU7XG4gIHJlYWRvbmx5IHNpemU6IG51bWJlcjtcbiAgLy8gI2VuZHJlZ2lvblxuXG4gIC8vICNyZWdpb24gcHJpdmF0ZSBmaWVsZHNcblxuICAvKipcbiAgICogc3RvcmVzIHRoZSBsb2NhdGlvbiBvZiB0aGUgZGF0YS5cbiAgICovXG4gIHByaXZhdGUgZGF0YUxvY2F0aW9uOiBUZW5zb3JEYXRhTG9jYXRpb247XG5cbiAgLyoqXG4gICAqIHN0b3JlcyB0aGUgZGF0YSBvbiBDUFUsIGlmIGxvY2F0aW9uIGlzICdjcHUnIG9yICdjcHUtcGlubmVkJy4gb3RoZXJ3aXNlIGVtcHR5LlxuICAgKi9cbiAgcHJpdmF0ZSBjcHVEYXRhPzogVGVuc29yRGF0YVR5cGU7XG5cbiAgLyoqXG4gICAqIHN0b3JlcyB0aGUgdW5kZXJseWluZyB0ZXh0dXJlIHdoZW4gbG9jYXRpb24gaXMgJ3RleHR1cmUnLiBvdGhlcndpc2UgZW1wdHkuXG4gICAqL1xuICBwcml2YXRlIGdwdVRleHR1cmVEYXRhPzogVGVuc29yVGV4dHVyZVR5cGU7XG5cbiAgLyoqXG4gICAqIHN0b3JlcyB0aGUgdW5kZXJseWluZyBHUFUgYnVmZmVyIHdoZW4gbG9jYXRpb24gaXMgJ2dwdS1idWZmZXInLiBvdGhlcndpc2UgZW1wdHkuXG4gICAqL1xuICBwcml2YXRlIGdwdUJ1ZmZlckRhdGE/OiBUZW5zb3JHcHVCdWZmZXJUeXBlO1xuXG4gIC8qKlxuICAgKiBzdG9yZXMgYW4gb3B0aW9uYWwgZG93bmxvYWRlciBmdW5jdGlvbiB0byBkb3dubG9hZCBkYXRhIGZyb20gR1BVIHRvIENQVS5cbiAgICovXG4gIHByaXZhdGUgZG93bmxvYWRlcj8oKTogUHJvbWlzZTxUZW5zb3JEYXRhVHlwZT47XG5cbiAgLyoqXG4gICAqIGEgZmxhZyBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGRhdGEgaXMgYmVpbmcgZG93bmxvYWRlZCBmcm9tIEdQVSB0byBDUFUuXG4gICAqL1xuICBwcml2YXRlIGlzRG93bmxvYWRpbmc/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBzdG9yZXMgYW4gb3B0aW9uYWwgZGlzcG9zZXIgZnVuY3Rpb24gdG8gZGlzcG9zZSB0aGUgdW5kZXJseWluZyBkYXRhLlxuICAgKi9cbiAgcHJpdmF0ZSBkaXNwb3Nlcj8oKTogdm9pZDtcbiAgLy8gI2VuZHJlZ2lvblxuXG4gIC8vICNyZWdpb24gcHJvcGVydGllc1xuICBnZXQgZGF0YSgpOiBUZW5zb3JEYXRhVHlwZSB7XG4gICAgdGhpcy5lbnN1cmVWYWxpZCgpO1xuICAgIGlmICghdGhpcy5jcHVEYXRhKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgJ1RoZSBkYXRhIGlzIG5vdCBvbiBDUFUuIFVzZSBgZ2V0RGF0YSgpYCB0byBkb3dubG9hZCBHUFUgZGF0YSB0byBDUFUsICcgK1xuICAgICAgICAgICdvciB1c2UgYHRleHR1cmVgIG9yIGBncHVCdWZmZXJgIHByb3BlcnR5IHRvIGFjY2VzcyB0aGUgR1BVIGRhdGEgZGlyZWN0bHkuJyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNwdURhdGE7XG4gIH1cblxuICBnZXQgbG9jYXRpb24oKTogVGVuc29yRGF0YUxvY2F0aW9uIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhTG9jYXRpb247XG4gIH1cblxuICBnZXQgdGV4dHVyZSgpOiBUZW5zb3JUZXh0dXJlVHlwZSB7XG4gICAgdGhpcy5lbnN1cmVWYWxpZCgpO1xuICAgIGlmICghdGhpcy5ncHVUZXh0dXJlRGF0YSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgZGF0YSBpcyBub3Qgc3RvcmVkIGFzIGEgV2ViR0wgdGV4dHVyZS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ3B1VGV4dHVyZURhdGE7XG4gIH1cblxuICBnZXQgZ3B1QnVmZmVyKCk6IFRlbnNvckdwdUJ1ZmZlclR5cGUge1xuICAgIHRoaXMuZW5zdXJlVmFsaWQoKTtcbiAgICBpZiAoIXRoaXMuZ3B1QnVmZmVyRGF0YSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgZGF0YSBpcyBub3Qgc3RvcmVkIGFzIGEgV2ViR1BVIGJ1ZmZlci4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ3B1QnVmZmVyRGF0YTtcbiAgfVxuICAvLyAjZW5kcmVnaW9uXG5cbiAgLy8gI3JlZ2lvbiBtZXRob2RzXG5cbiAgYXN5bmMgZ2V0RGF0YShyZWxlYXNlRGF0YT86IGJvb2xlYW4pOiBQcm9taXNlPFRlbnNvckRhdGFUeXBlPiB7XG4gICAgdGhpcy5lbnN1cmVWYWxpZCgpO1xuICAgIHN3aXRjaCAodGhpcy5kYXRhTG9jYXRpb24pIHtcbiAgICAgIGNhc2UgJ2NwdSc6XG4gICAgICBjYXNlICdjcHUtcGlubmVkJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YTtcbiAgICAgIGNhc2UgJ3RleHR1cmUnOlxuICAgICAgY2FzZSAnZ3B1LWJ1ZmZlcic6IHtcbiAgICAgICAgaWYgKCF0aGlzLmRvd25sb2FkZXIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBjdXJyZW50IHRlbnNvciBpcyBub3QgY3JlYXRlZCB3aXRoIGEgc3BlY2lmaWVkIGRhdGEgZG93bmxvYWRlci4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pc0Rvd25sb2FkaW5nKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgY3VycmVudCB0ZW5zb3IgaXMgYmVpbmcgZG93bmxvYWRlZC4nKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoaXMuaXNEb3dubG9hZGluZyA9IHRydWU7XG4gICAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMuZG93bmxvYWRlcigpO1xuICAgICAgICAgIHRoaXMuZG93bmxvYWRlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB0aGlzLmRhdGFMb2NhdGlvbiA9ICdjcHUnO1xuICAgICAgICAgIHRoaXMuY3B1RGF0YSA9IGRhdGE7XG5cbiAgICAgICAgICBpZiAocmVsZWFzZURhdGEgJiYgdGhpcy5kaXNwb3Nlcikge1xuICAgICAgICAgICAgdGhpcy5kaXNwb3NlcigpO1xuICAgICAgICAgICAgdGhpcy5kaXNwb3NlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gZGF0YTtcblxuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHRoaXMuaXNEb3dubG9hZGluZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCBnZXQgZGF0YSBmcm9tIGxvY2F0aW9uOiAke3RoaXMuZGF0YUxvY2F0aW9ufWApO1xuICAgIH1cbiAgfVxuXG4gIGRpc3Bvc2UoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuaXNEb3dubG9hZGluZykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgY3VycmVudCB0ZW5zb3IgaXMgYmVpbmcgZG93bmxvYWRlZC4nKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5kaXNwb3Nlcikge1xuICAgICAgdGhpcy5kaXNwb3NlcigpO1xuICAgICAgdGhpcy5kaXNwb3NlciA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgdGhpcy5jcHVEYXRhID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZ3B1VGV4dHVyZURhdGEgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5ncHVCdWZmZXJEYXRhID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZG93bmxvYWRlciA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmlzRG93bmxvYWRpbmcgPSB1bmRlZmluZWQ7XG5cbiAgICB0aGlzLmRhdGFMb2NhdGlvbiA9ICdub25lJztcbiAgfVxuXG4gIC8vICNlbmRyZWdpb25cblxuICAvLyAjcmVnaW9uIHRlbnNvciB1dGlsaXRpZXNcbiAgcHJpdmF0ZSBlbnN1cmVWYWxpZCgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5kYXRhTG9jYXRpb24gPT09ICdub25lJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgdGVuc29yIGlzIGRpc3Bvc2VkLicpO1xuICAgIH1cbiAgfVxuXG4gIHJlc2hhcGUoZGltczogcmVhZG9ubHkgbnVtYmVyW10pOiBUZW5zb3JJbnRlcmZhY2Uge1xuICAgIHRoaXMuZW5zdXJlVmFsaWQoKTtcbiAgICBpZiAodGhpcy5kb3dubG9hZGVyIHx8IHRoaXMuZGlzcG9zZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHJlc2hhcGUgYSB0ZW5zb3IgdGhhdCBvd25zIEdQVSByZXNvdXJjZS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRlbnNvclJlc2hhcGUodGhpcywgZGltcyk7XG4gIH1cbiAgLy8gI2VuZHJlZ2lvblxufVxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge1RlbnNvckZhY3Rvcnl9IGZyb20gJy4vdGVuc29yLWZhY3RvcnkuanMnO1xuaW1wb3J0IHtUZW5zb3IgYXMgVGVuc29ySW1wbH0gZnJvbSAnLi90ZW5zb3ItaW1wbC5qcyc7XG5pbXBvcnQge1R5cGVkVGVuc29yVXRpbHN9IGZyb20gJy4vdGVuc29yLXV0aWxzLmpzJztcblxuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXJlZGVjbGFyZSAqL1xuXG4vKipcbiAqIHJlcHJlc2VudCBhIGJhc2ljIHRlbnNvciB3aXRoIHNwZWNpZmllZCBkaW1lbnNpb25zIGFuZCBkYXRhIHR5cGUuXG4gKi9cbmludGVyZmFjZSBUeXBlZFRlbnNvckJhc2U8VCBleHRlbmRzIFRlbnNvci5UeXBlPiB7XG4gIC8qKlxuICAgKiBHZXQgdGhlIGRpbWVuc2lvbnMgb2YgdGhlIHRlbnNvci5cbiAgICovXG4gIHJlYWRvbmx5IGRpbXM6IHJlYWRvbmx5IG51bWJlcltdO1xuICAvKipcbiAgICogR2V0IHRoZSBkYXRhIHR5cGUgb2YgdGhlIHRlbnNvci5cbiAgICovXG4gIHJlYWRvbmx5IHR5cGU6IFQ7XG4gIC8qKlxuICAgKiBHZXQgdGhlIGJ1ZmZlciBkYXRhIG9mIHRoZSB0ZW5zb3IuXG4gICAqXG4gICAqIElmIHRoZSBkYXRhIGlzIG5vdCBvbiBDUFUgKGVnLiBpdCdzIGluIHRoZSBmb3JtIG9mIFdlYkdMIHRleHR1cmUgb3IgV2ViR1BVIGJ1ZmZlciksIHRocm93IGVycm9yLlxuICAgKi9cbiAgcmVhZG9ubHkgZGF0YTogVGVuc29yLkRhdGFUeXBlTWFwW1RdO1xuICAvKipcbiAgICogR2V0IHRoZSBsb2NhdGlvbiBvZiB0aGUgZGF0YS5cbiAgICovXG4gIHJlYWRvbmx5IGxvY2F0aW9uOiBUZW5zb3IuRGF0YUxvY2F0aW9uO1xuICAvKipcbiAgICogR2V0IHRoZSBXZWJHTCB0ZXh0dXJlIHRoYXQgaG9sZHMgdGhlIHRlbnNvciBkYXRhLlxuICAgKlxuICAgKiBJZiB0aGUgZGF0YSBpcyBub3Qgb24gR1BVIGFzIFdlYkdMIHRleHR1cmUsIHRocm93IGVycm9yLlxuICAgKi9cbiAgcmVhZG9ubHkgdGV4dHVyZTogVGVuc29yLlRleHR1cmVUeXBlO1xuICAvKipcbiAgICogR2V0IHRoZSBXZWJHUFUgYnVmZmVyIHRoYXQgaG9sZHMgdGhlIHRlbnNvciBkYXRhLlxuICAgKlxuICAgKiBJZiB0aGUgZGF0YSBpcyBub3Qgb24gR1BVIGFzIFdlYkdQVSBidWZmZXIsIHRocm93IGVycm9yLlxuICAgKi9cbiAgcmVhZG9ubHkgZ3B1QnVmZmVyOiBUZW5zb3IuR3B1QnVmZmVyVHlwZTtcblxuICAvKipcbiAgICogR2V0IHRoZSBidWZmZXIgZGF0YSBvZiB0aGUgdGVuc29yLlxuICAgKlxuICAgKiBJZiB0aGUgZGF0YSBpcyBvbiBDUFUsIHJldHVybnMgdGhlIGRhdGEgaW1tZWRpYXRlbHkuXG4gICAqIElmIHRoZSBkYXRhIGlzIG9uIEdQVSwgZG93bmxvYWRzIHRoZSBkYXRhIGFuZCByZXR1cm5zIHRoZSBwcm9taXNlLlxuICAgKlxuICAgKiBAcGFyYW0gcmVsZWFzZURhdGEgLSB3aGV0aGVyIHJlbGVhc2UgdGhlIGRhdGEgb24gR1BVLiBJZ25vcmUgaWYgZGF0YSBpcyBhbHJlYWR5IG9uIENQVS5cbiAgICovXG4gIGdldERhdGEocmVsZWFzZURhdGE/OiBib29sZWFuKTogUHJvbWlzZTxUZW5zb3IuRGF0YVR5cGVNYXBbVF0+O1xuXG4gIC8qKlxuICAgKiBEaXNwb3NlIHRoZSB0ZW5zb3IgZGF0YS5cbiAgICpcbiAgICogSWYgdGhlIGRhdGEgaXMgb24gQ1BVLCByZW1vdmUgaXRzIGludGVybmFsIHJlZmVyZW5jZSB0byB0aGUgdW5kZXJseWluZyBkYXRhLlxuICAgKiBJZiB0aGUgZGF0YSBpcyBvbiBHUFUsIHJlbGVhc2UgdGhlIGRhdGEgb24gR1BVLlxuICAgKlxuICAgKiBBZnRlciBjYWxsaW5nIHRoaXMgZnVuY3Rpb24sIHRoZSB0ZW5zb3IgaXMgY29uc2lkZXJlZCBubyBsb25nZXIgdmFsaWQuIEl0cyBsb2NhdGlvbiB3aWxsIGJlIHNldCB0byAnbm9uZScuXG4gICAqL1xuICBkaXNwb3NlKCk6IHZvaWQ7XG59XG5cbmV4cG9ydCBkZWNsYXJlIG5hbWVzcGFjZSBUZW5zb3Ige1xuICBpbnRlcmZhY2UgRGF0YVR5cGVNYXAge1xuICAgIGZsb2F0MzI6IEZsb2F0MzJBcnJheTtcbiAgICB1aW50ODogVWludDhBcnJheTtcbiAgICBpbnQ4OiBJbnQ4QXJyYXk7XG4gICAgdWludDE2OiBVaW50MTZBcnJheTtcbiAgICBpbnQxNjogSW50MTZBcnJheTtcbiAgICBpbnQzMjogSW50MzJBcnJheTtcbiAgICBpbnQ2NDogQmlnSW50NjRBcnJheTtcbiAgICBzdHJpbmc6IHN0cmluZ1tdO1xuICAgIGJvb2w6IFVpbnQ4QXJyYXk7XG4gICAgZmxvYXQxNjogVWludDE2QXJyYXk7ICAvLyBLZWVwIHVzaW5nIFVpbnQxNkFycmF5IHVudGlsIHdlIGhhdmUgYSBjb25jcmV0ZSBzb2x1dGlvbiBmb3IgZmxvYXQgMTYuXG4gICAgZmxvYXQ2NDogRmxvYXQ2NEFycmF5O1xuICAgIHVpbnQzMjogVWludDMyQXJyYXk7XG4gICAgdWludDY0OiBCaWdVaW50NjRBcnJheTtcbiAgICAvLyBjb21wbGV4NjQ6IG5ldmVyO1xuICAgIC8vIGNvbXBsZXgxMjg6IG5ldmVyO1xuICAgIC8vIGJmbG9hdDE2OiBuZXZlcjtcbiAgfVxuXG4gIGludGVyZmFjZSBFbGVtZW50VHlwZU1hcCB7XG4gICAgZmxvYXQzMjogbnVtYmVyO1xuICAgIHVpbnQ4OiBudW1iZXI7XG4gICAgaW50ODogbnVtYmVyO1xuICAgIHVpbnQxNjogbnVtYmVyO1xuICAgIGludDE2OiBudW1iZXI7XG4gICAgaW50MzI6IG51bWJlcjtcbiAgICBpbnQ2NDogYmlnaW50O1xuICAgIHN0cmluZzogc3RyaW5nO1xuICAgIGJvb2w6IGJvb2xlYW47XG4gICAgZmxvYXQxNjogbnVtYmVyOyAgLy8gS2VlcCB1c2luZyBVaW50MTZBcnJheSB1bnRpbCB3ZSBoYXZlIGEgY29uY3JldGUgc29sdXRpb24gZm9yIGZsb2F0IDE2LlxuICAgIGZsb2F0NjQ6IG51bWJlcjtcbiAgICB1aW50MzI6IG51bWJlcjtcbiAgICB1aW50NjQ6IGJpZ2ludDtcbiAgICAvLyBjb21wbGV4NjQ6IG5ldmVyO1xuICAgIC8vIGNvbXBsZXgxMjg6IG5ldmVyO1xuICAgIC8vIGJmbG9hdDE2OiBuZXZlcjtcbiAgfVxuXG4gIHR5cGUgRGF0YVR5cGUgPSBEYXRhVHlwZU1hcFtUeXBlXTtcbiAgdHlwZSBFbGVtZW50VHlwZSA9IEVsZW1lbnRUeXBlTWFwW1R5cGVdO1xuXG4gIC8qKlxuICAgKiBzdXBwb3J0ZWQgZGF0YSB0eXBlcyBmb3IgY29uc3RydWN0aW5nIGEgdGVuc29yIGZyb20gYSBwaW5uZWQgQ1BVIGJ1ZmZlclxuICAgKi9cbiAgZXhwb3J0IHR5cGUgQ3B1UGlubmVkRGF0YVR5cGVzID0gRXhjbHVkZTxUZW5zb3IuVHlwZSwgJ3N0cmluZyc+O1xuXG4gIC8qKlxuICAgKiB0eXBlIGFsaWFzIGZvciBXZWJHTCB0ZXh0dXJlXG4gICAqL1xuICBleHBvcnQgdHlwZSBUZXh0dXJlVHlwZSA9IFdlYkdMVGV4dHVyZTtcblxuICAvKipcbiAgICogc3VwcG9ydGVkIGRhdGEgdHlwZXMgZm9yIGNvbnN0cnVjdGluZyBhIHRlbnNvciBmcm9tIGEgV2ViR0wgdGV4dHVyZVxuICAgKi9cbiAgZXhwb3J0IHR5cGUgVGV4dHVyZURhdGFUeXBlcyA9ICdmbG9hdDMyJztcblxuICAvKipcbiAgICogdHlwZSBhbGlhcyBmb3IgV2ViR1BVIGJ1ZmZlclxuICAgKlxuICAgKiBUaGUgcmVhc29uIHdoeSB3ZSBkb24ndCB1c2UgdHlwZSBcIkdQVUJ1ZmZlclwiIGRlZmluZWQgaW4gd2ViZ3B1LmQudHMgZnJvbSBAd2ViZ3B1L3R5cGVzIGlzIGJlY2F1c2UgXCJAd2ViZ3B1L3R5cGVzXCJcbiAgICogcmVxdWlyZXMgXCJAdHlwZXMvZG9tLXdlYmNvZGVjc1wiIGFzIHBlZXIgZGVwZW5kZW5jeSB3aGVuIHVzaW5nIFR5cGVTY3JpcHQgPCB2NS4xIGFuZCBpdHMgdmVyc2lvbiBuZWVkIHRvIGJlIGNob3NlblxuICAgKiBjYXJlZnVsbHkgYWNjb3JkaW5nIHRvIHRoZSBUeXBlU2NyaXB0IHZlcnNpb24gYmVpbmcgdXNlZC4gVGhpcyBtZWFucyBzbyBmYXIgdGhlcmUgaXMgbm90IGEgd2F5IHRvIGtlZXAgZXZlcnlcbiAgICogVHlwZVNjcmlwdCB2ZXJzaW9uIGhhcHB5LiBJdCB0dXJucyBvdXQgdGhhdCB3ZSB3aWxsIGVhc2lseSBicm9rZSB1c2VycyBvbiBzb21lIFR5cGVTY3JpcHQgdmVyc2lvbi5cbiAgICpcbiAgICogZm9yIG1vcmUgaW5mbyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2dwdXdlYi90eXBlcy9pc3N1ZXMvMTI3XG4gICAqL1xuICBleHBvcnQgdHlwZSBHcHVCdWZmZXJUeXBlID0ge3NpemU6IG51bWJlcjsgbWFwU3RhdGU6ICd1bm1hcHBlZCcgfCAncGVuZGluZycgfCAnbWFwcGVkJ307XG5cbiAgLyoqXG4gICAqIHN1cHBvcnRlZCBkYXRhIHR5cGVzIGZvciBjb25zdHJ1Y3RpbmcgYSB0ZW5zb3IgZnJvbSBhIFdlYkdQVSBidWZmZXJcbiAgICovXG4gIGV4cG9ydCB0eXBlIEdwdUJ1ZmZlckRhdGFUeXBlcyA9ICdmbG9hdDMyJ3wnZmxvYXQxNid8J2ludDMyJ3wnaW50NjQnfCd1aW50MzInfCd1aW50OCd8J2Jvb2wnO1xuXG4gIC8qKlxuICAgKiByZXByZXNlbnQgd2hlcmUgdGhlIHRlbnNvciBkYXRhIGlzIHN0b3JlZFxuICAgKi9cbiAgZXhwb3J0IHR5cGUgRGF0YUxvY2F0aW9uID0gJ25vbmUnfCdjcHUnfCdjcHUtcGlubmVkJ3wndGV4dHVyZSd8J2dwdS1idWZmZXInO1xuXG4gIC8qKlxuICAgKiByZXByZXNlbnQgdGhlIGRhdGEgdHlwZSBvZiBhIHRlbnNvclxuICAgKi9cbiAgZXhwb3J0IHR5cGUgVHlwZSA9IGtleW9mIERhdGFUeXBlTWFwO1xufVxuXG4vKipcbiAqIFJlcHJlc2VudCBtdWx0aS1kaW1lbnNpb25hbCBhcnJheXMgdG8gZmVlZCB0byBvciBmZXRjaCBmcm9tIG1vZGVsIGluZmVyZW5jaW5nLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFR5cGVkVGVuc29yPFQgZXh0ZW5kcyBUZW5zb3IuVHlwZT4gZXh0ZW5kcyBUeXBlZFRlbnNvckJhc2U8VD4sIFR5cGVkVGVuc29yVXRpbHM8VD4ge31cbi8qKlxuICogUmVwcmVzZW50IG11bHRpLWRpbWVuc2lvbmFsIGFycmF5cyB0byBmZWVkIHRvIG9yIGZldGNoIGZyb20gbW9kZWwgaW5mZXJlbmNpbmcuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVGVuc29yIGV4dGVuZHMgVHlwZWRUZW5zb3JCYXNlPFRlbnNvci5UeXBlPiwgVHlwZWRUZW5zb3JVdGlsczxUZW5zb3IuVHlwZT4ge31cblxuLyoqXG4gKiB0eXBlIFRlbnNvckNvbnN0cnVjdG9yIGRlZmluZXMgdGhlIGNvbnN0cnVjdG9ycyBvZiAnVGVuc29yJyB0byBjcmVhdGUgQ1BVIHRlbnNvciBpbnN0YW5jZXMuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVGVuc29yQ29uc3RydWN0b3IgZXh0ZW5kcyBUZW5zb3JGYWN0b3J5IHtcbiAgLy8gI3JlZ2lvbiBDUFUgdGVuc29yIC0gc3BlY2lmeSBlbGVtZW50IHR5cGVcbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhIG5ldyBzdHJpbmcgdGVuc29yIG9iamVjdCBmcm9tIHRoZSBnaXZlbiB0eXBlLCBkYXRhIGFuZCBkaW1zLlxuICAgKlxuICAgKiBAcGFyYW0gdHlwZSAtIFNwZWNpZnkgdGhlIGVsZW1lbnQgdHlwZS5cbiAgICogQHBhcmFtIGRhdGEgLSBTcGVjaWZ5IHRoZSBDUFUgdGVuc29yIGRhdGEuXG4gICAqIEBwYXJhbSBkaW1zIC0gU3BlY2lmeSB0aGUgZGltZW5zaW9uIG9mIHRoZSB0ZW5zb3IuIElmIG9taXR0ZWQsIGEgMS1EIHRlbnNvciBpcyBhc3N1bWVkLlxuICAgKi9cbiAgbmV3KHR5cGU6ICdzdHJpbmcnLCBkYXRhOiBUZW5zb3IuRGF0YVR5cGVNYXBbJ3N0cmluZyddfHJlYWRvbmx5IHN0cmluZ1tdLFxuICAgICAgZGltcz86IHJlYWRvbmx5IG51bWJlcltdKTogVHlwZWRUZW5zb3I8J3N0cmluZyc+O1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgYm9vbCB0ZW5zb3Igb2JqZWN0IGZyb20gdGhlIGdpdmVuIHR5cGUsIGRhdGEgYW5kIGRpbXMuXG4gICAqXG4gICAqIEBwYXJhbSB0eXBlIC0gU3BlY2lmeSB0aGUgZWxlbWVudCB0eXBlLlxuICAgKiBAcGFyYW0gZGF0YSAtIFNwZWNpZnkgdGhlIENQVSB0ZW5zb3IgZGF0YS5cbiAgICogQHBhcmFtIGRpbXMgLSBTcGVjaWZ5IHRoZSBkaW1lbnNpb24gb2YgdGhlIHRlbnNvci4gSWYgb21pdHRlZCwgYSAxLUQgdGVuc29yIGlzIGFzc3VtZWQuXG4gICAqL1xuICBuZXcodHlwZTogJ2Jvb2wnLCBkYXRhOiBUZW5zb3IuRGF0YVR5cGVNYXBbJ2Jvb2wnXXxyZWFkb25seSBib29sZWFuW10sIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSk6IFR5cGVkVGVuc29yPCdib29sJz47XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhIG5ldyA2NC1iaXQgaW50ZWdlciB0eXBlZCB0ZW5zb3Igb2JqZWN0IGZyb20gdGhlIGdpdmVuIHR5cGUsIGRhdGEgYW5kIGRpbXMuXG4gICAqXG4gICAqIEBwYXJhbSB0eXBlIC0gU3BlY2lmeSB0aGUgZWxlbWVudCB0eXBlLlxuICAgKiBAcGFyYW0gZGF0YSAtIFNwZWNpZnkgdGhlIENQVSB0ZW5zb3IgZGF0YS5cbiAgICogQHBhcmFtIGRpbXMgLSBTcGVjaWZ5IHRoZSBkaW1lbnNpb24gb2YgdGhlIHRlbnNvci4gSWYgb21pdHRlZCwgYSAxLUQgdGVuc29yIGlzIGFzc3VtZWQuXG4gICAqL1xuICBuZXc8VCBleHRlbmRzICd1aW50NjQnfCdpbnQ2NCc+KFxuICAgICAgdHlwZTogVCwgZGF0YTogVGVuc29yLkRhdGFUeXBlTWFwW1RdfHJlYWRvbmx5IGJpZ2ludFtdfHJlYWRvbmx5IG51bWJlcltdLFxuICAgICAgZGltcz86IHJlYWRvbmx5IG51bWJlcltdKTogVHlwZWRUZW5zb3I8VD47XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhIG5ldyBudW1lcmljIHRlbnNvciBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gdHlwZSwgZGF0YSBhbmQgZGltcy5cbiAgICpcbiAgICogQHBhcmFtIHR5cGUgLSBTcGVjaWZ5IHRoZSBlbGVtZW50IHR5cGUuXG4gICAqIEBwYXJhbSBkYXRhIC0gU3BlY2lmeSB0aGUgQ1BVIHRlbnNvciBkYXRhLlxuICAgKiBAcGFyYW0gZGltcyAtIFNwZWNpZnkgdGhlIGRpbWVuc2lvbiBvZiB0aGUgdGVuc29yLiBJZiBvbWl0dGVkLCBhIDEtRCB0ZW5zb3IgaXMgYXNzdW1lZC5cbiAgICovXG4gIG5ldzxUIGV4dGVuZHMgRXhjbHVkZTxUZW5zb3IuVHlwZSwgJ3N0cmluZyd8J2Jvb2wnfCd1aW50NjQnfCdpbnQ2NCc+PihcbiAgICAgIHR5cGU6IFQsIGRhdGE6IFRlbnNvci5EYXRhVHlwZU1hcFtUXXxyZWFkb25seSBudW1iZXJbXSwgZGltcz86IHJlYWRvbmx5IG51bWJlcltdKTogVHlwZWRUZW5zb3I8VD47XG4gIC8vICNlbmRyZWdpb25cblxuICAvLyAjcmVnaW9uIENQVSB0ZW5zb3IgLSBpbmZlciBlbGVtZW50IHR5cGVzXG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhIG5ldyBmbG9hdDMyIHRlbnNvciBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gZGF0YSBhbmQgZGltcy5cbiAgICpcbiAgICogQHBhcmFtIGRhdGEgLSBTcGVjaWZ5IHRoZSBDUFUgdGVuc29yIGRhdGEuXG4gICAqIEBwYXJhbSBkaW1zIC0gU3BlY2lmeSB0aGUgZGltZW5zaW9uIG9mIHRoZSB0ZW5zb3IuIElmIG9taXR0ZWQsIGEgMS1EIHRlbnNvciBpcyBhc3N1bWVkLlxuICAgKi9cbiAgbmV3KGRhdGE6IEZsb2F0MzJBcnJheSwgZGltcz86IHJlYWRvbmx5IG51bWJlcltdKTogVHlwZWRUZW5zb3I8J2Zsb2F0MzInPjtcblxuICAvKipcbiAgICogQ29uc3RydWN0IGEgbmV3IGludDggdGVuc29yIG9iamVjdCBmcm9tIHRoZSBnaXZlbiBkYXRhIGFuZCBkaW1zLlxuICAgKlxuICAgKiBAcGFyYW0gZGF0YSAtIFNwZWNpZnkgdGhlIENQVSB0ZW5zb3IgZGF0YS5cbiAgICogQHBhcmFtIGRpbXMgLSBTcGVjaWZ5IHRoZSBkaW1lbnNpb24gb2YgdGhlIHRlbnNvci4gSWYgb21pdHRlZCwgYSAxLUQgdGVuc29yIGlzIGFzc3VtZWQuXG4gICAqL1xuICBuZXcoZGF0YTogSW50OEFycmF5LCBkaW1zPzogcmVhZG9ubHkgbnVtYmVyW10pOiBUeXBlZFRlbnNvcjwnaW50OCc+O1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgdWludDggdGVuc29yIG9iamVjdCBmcm9tIHRoZSBnaXZlbiBkYXRhIGFuZCBkaW1zLlxuICAgKlxuICAgKiBAcGFyYW0gZGF0YSAtIFNwZWNpZnkgdGhlIENQVSB0ZW5zb3IgZGF0YS5cbiAgICogQHBhcmFtIGRpbXMgLSBTcGVjaWZ5IHRoZSBkaW1lbnNpb24gb2YgdGhlIHRlbnNvci4gSWYgb21pdHRlZCwgYSAxLUQgdGVuc29yIGlzIGFzc3VtZWQuXG4gICAqL1xuICBuZXcoZGF0YTogVWludDhBcnJheSwgZGltcz86IHJlYWRvbmx5IG51bWJlcltdKTogVHlwZWRUZW5zb3I8J3VpbnQ4Jz47XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhIG5ldyB1aW50MTYgdGVuc29yIG9iamVjdCBmcm9tIHRoZSBnaXZlbiBkYXRhIGFuZCBkaW1zLlxuICAgKlxuICAgKiBAcGFyYW0gZGF0YSAtIFNwZWNpZnkgdGhlIENQVSB0ZW5zb3IgZGF0YS5cbiAgICogQHBhcmFtIGRpbXMgLSBTcGVjaWZ5IHRoZSBkaW1lbnNpb24gb2YgdGhlIHRlbnNvci4gSWYgb21pdHRlZCwgYSAxLUQgdGVuc29yIGlzIGFzc3VtZWQuXG4gICAqL1xuICBuZXcoZGF0YTogVWludDE2QXJyYXksIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSk6IFR5cGVkVGVuc29yPCd1aW50MTYnPjtcblxuICAvKipcbiAgICogQ29uc3RydWN0IGEgbmV3IGludDE2IHRlbnNvciBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gZGF0YSBhbmQgZGltcy5cbiAgICpcbiAgICogQHBhcmFtIGRhdGEgLSBTcGVjaWZ5IHRoZSBDUFUgdGVuc29yIGRhdGEuXG4gICAqIEBwYXJhbSBkaW1zIC0gU3BlY2lmeSB0aGUgZGltZW5zaW9uIG9mIHRoZSB0ZW5zb3IuIElmIG9taXR0ZWQsIGEgMS1EIHRlbnNvciBpcyBhc3N1bWVkLlxuICAgKi9cbiAgbmV3KGRhdGE6IEludDE2QXJyYXksIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSk6IFR5cGVkVGVuc29yPCdpbnQxNic+O1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgaW50MzIgdGVuc29yIG9iamVjdCBmcm9tIHRoZSBnaXZlbiBkYXRhIGFuZCBkaW1zLlxuICAgKlxuICAgKiBAcGFyYW0gZGF0YSAtIFNwZWNpZnkgdGhlIENQVSB0ZW5zb3IgZGF0YS5cbiAgICogQHBhcmFtIGRpbXMgLSBTcGVjaWZ5IHRoZSBkaW1lbnNpb24gb2YgdGhlIHRlbnNvci4gSWYgb21pdHRlZCwgYSAxLUQgdGVuc29yIGlzIGFzc3VtZWQuXG4gICAqL1xuICBuZXcoZGF0YTogSW50MzJBcnJheSwgZGltcz86IHJlYWRvbmx5IG51bWJlcltdKTogVHlwZWRUZW5zb3I8J2ludDMyJz47XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhIG5ldyBpbnQ2NCB0ZW5zb3Igb2JqZWN0IGZyb20gdGhlIGdpdmVuIGRhdGEgYW5kIGRpbXMuXG4gICAqXG4gICAqIEBwYXJhbSBkYXRhIC0gU3BlY2lmeSB0aGUgQ1BVIHRlbnNvciBkYXRhLlxuICAgKiBAcGFyYW0gZGltcyAtIFNwZWNpZnkgdGhlIGRpbWVuc2lvbiBvZiB0aGUgdGVuc29yLiBJZiBvbWl0dGVkLCBhIDEtRCB0ZW5zb3IgaXMgYXNzdW1lZC5cbiAgICovXG4gIG5ldyhkYXRhOiBCaWdJbnQ2NEFycmF5LCBkaW1zPzogcmVhZG9ubHkgbnVtYmVyW10pOiBUeXBlZFRlbnNvcjwnaW50NjQnPjtcblxuICAvKipcbiAgICogQ29uc3RydWN0IGEgbmV3IHN0cmluZyB0ZW5zb3Igb2JqZWN0IGZyb20gdGhlIGdpdmVuIGRhdGEgYW5kIGRpbXMuXG4gICAqXG4gICAqIEBwYXJhbSBkYXRhIC0gU3BlY2lmeSB0aGUgQ1BVIHRlbnNvciBkYXRhLlxuICAgKiBAcGFyYW0gZGltcyAtIFNwZWNpZnkgdGhlIGRpbWVuc2lvbiBvZiB0aGUgdGVuc29yLiBJZiBvbWl0dGVkLCBhIDEtRCB0ZW5zb3IgaXMgYXNzdW1lZC5cbiAgICovXG4gIG5ldyhkYXRhOiByZWFkb25seSBzdHJpbmdbXSwgZGltcz86IHJlYWRvbmx5IG51bWJlcltdKTogVHlwZWRUZW5zb3I8J3N0cmluZyc+O1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgYm9vbCB0ZW5zb3Igb2JqZWN0IGZyb20gdGhlIGdpdmVuIGRhdGEgYW5kIGRpbXMuXG4gICAqXG4gICAqIEBwYXJhbSBkYXRhIC0gU3BlY2lmeSB0aGUgQ1BVIHRlbnNvciBkYXRhLlxuICAgKiBAcGFyYW0gZGltcyAtIFNwZWNpZnkgdGhlIGRpbWVuc2lvbiBvZiB0aGUgdGVuc29yLiBJZiBvbWl0dGVkLCBhIDEtRCB0ZW5zb3IgaXMgYXNzdW1lZC5cbiAgICovXG4gIG5ldyhkYXRhOiByZWFkb25seSBib29sZWFuW10sIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSk6IFR5cGVkVGVuc29yPCdib29sJz47XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhIG5ldyBmbG9hdDY0IHRlbnNvciBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gZGF0YSBhbmQgZGltcy5cbiAgICpcbiAgICogQHBhcmFtIGRhdGEgLSBTcGVjaWZ5IHRoZSBDUFUgdGVuc29yIGRhdGEuXG4gICAqIEBwYXJhbSBkaW1zIC0gU3BlY2lmeSB0aGUgZGltZW5zaW9uIG9mIHRoZSB0ZW5zb3IuIElmIG9taXR0ZWQsIGEgMS1EIHRlbnNvciBpcyBhc3N1bWVkLlxuICAgKi9cbiAgbmV3KGRhdGE6IEZsb2F0NjRBcnJheSwgZGltcz86IHJlYWRvbmx5IG51bWJlcltdKTogVHlwZWRUZW5zb3I8J2Zsb2F0NjQnPjtcblxuICAvKipcbiAgICogQ29uc3RydWN0IGEgbmV3IHVpbnQzMiB0ZW5zb3Igb2JqZWN0IGZyb20gdGhlIGdpdmVuIGRhdGEgYW5kIGRpbXMuXG4gICAqXG4gICAqIEBwYXJhbSBkYXRhIC0gU3BlY2lmeSB0aGUgQ1BVIHRlbnNvciBkYXRhLlxuICAgKiBAcGFyYW0gZGltcyAtIFNwZWNpZnkgdGhlIGRpbWVuc2lvbiBvZiB0aGUgdGVuc29yLiBJZiBvbWl0dGVkLCBhIDEtRCB0ZW5zb3IgaXMgYXNzdW1lZC5cbiAgICovXG4gIG5ldyhkYXRhOiBVaW50MzJBcnJheSwgZGltcz86IHJlYWRvbmx5IG51bWJlcltdKTogVHlwZWRUZW5zb3I8J3VpbnQzMic+O1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgdWludDY0IHRlbnNvciBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gZGF0YSBhbmQgZGltcy5cbiAgICpcbiAgICogQHBhcmFtIGRhdGEgLSBTcGVjaWZ5IHRoZSBDUFUgdGVuc29yIGRhdGEuXG4gICAqIEBwYXJhbSBkaW1zIC0gU3BlY2lmeSB0aGUgZGltZW5zaW9uIG9mIHRoZSB0ZW5zb3IuIElmIG9taXR0ZWQsIGEgMS1EIHRlbnNvciBpcyBhc3N1bWVkLlxuICAgKi9cbiAgbmV3KGRhdGE6IEJpZ1VpbnQ2NEFycmF5LCBkaW1zPzogcmVhZG9ubHkgbnVtYmVyW10pOiBUeXBlZFRlbnNvcjwndWludDY0Jz47XG5cbiAgLy8gI2VuZHJlZ2lvblxuXG4gIC8vICNyZWdpb24gQ1BVIHRlbnNvciAtIGZhbGwgYmFjayB0byBub24tZ2VuZXJpYyB0ZW5zb3IgdHlwZSBkZWNsYXJhdGlvblxuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgdGVuc29yIG9iamVjdCBmcm9tIHRoZSBnaXZlbiB0eXBlLCBkYXRhIGFuZCBkaW1zLlxuICAgKlxuICAgKiBAcGFyYW0gdHlwZSAtIFNwZWNpZnkgdGhlIGVsZW1lbnQgdHlwZS5cbiAgICogQHBhcmFtIGRhdGEgLSBTcGVjaWZ5IHRoZSBDUFUgdGVuc29yIGRhdGEuXG4gICAqIEBwYXJhbSBkaW1zIC0gU3BlY2lmeSB0aGUgZGltZW5zaW9uIG9mIHRoZSB0ZW5zb3IuIElmIG9taXR0ZWQsIGEgMS1EIHRlbnNvciBpcyBhc3N1bWVkLlxuICAgKi9cbiAgbmV3KHR5cGU6IFRlbnNvci5UeXBlLCBkYXRhOiBUZW5zb3IuRGF0YVR5cGV8cmVhZG9ubHkgbnVtYmVyW118cmVhZG9ubHkgc3RyaW5nW118cmVhZG9ubHkgYmlnaW50W118cmVhZG9ubHkgYm9vbGVhbltdLFxuICAgICAgZGltcz86IHJlYWRvbmx5IG51bWJlcltdKTogVGVuc29yO1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgdGVuc29yIG9iamVjdCBmcm9tIHRoZSBnaXZlbiBkYXRhIGFuZCBkaW1zLlxuICAgKlxuICAgKiBAcGFyYW0gZGF0YSAtIFNwZWNpZnkgdGhlIENQVSB0ZW5zb3IgZGF0YS5cbiAgICogQHBhcmFtIGRpbXMgLSBTcGVjaWZ5IHRoZSBkaW1lbnNpb24gb2YgdGhlIHRlbnNvci4gSWYgb21pdHRlZCwgYSAxLUQgdGVuc29yIGlzIGFzc3VtZWQuXG4gICAqL1xuICBuZXcoZGF0YTogVGVuc29yLkRhdGFUeXBlLCBkaW1zPzogcmVhZG9ubHkgbnVtYmVyW10pOiBUZW5zb3I7XG4gIC8vICNlbmRyZWdpb25cbn1cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuZXhwb3J0IGNvbnN0IFRlbnNvciA9IFRlbnNvckltcGwgYXMgVGVuc29yQ29uc3RydWN0b3I7XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7ZW52fSBmcm9tICcuL2Vudi1pbXBsLmpzJztcblxuLyoqXG4gKiBAaWdub3JlXG4gKi9cbmV4cG9ydCBjb25zdCBUUkFDRSA9IChkZXZpY2VUeXBlOiBzdHJpbmcsIGxhYmVsOiBzdHJpbmcpID0+IHtcbiAgaWYgKHR5cGVvZiBlbnYudHJhY2UgPT09ICd1bmRlZmluZWQnID8gIWVudi53YXNtLnRyYWNlIDogIWVudi50cmFjZSkge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICBjb25zb2xlLnRpbWVTdGFtcChgJHtkZXZpY2VUeXBlfTo6T1JUOjoke2xhYmVsfWApO1xufTtcblxuY29uc3QgVFJBQ0VfRlVOQyA9IChtc2c6IHN0cmluZywgZXh0cmFNc2c/OiBzdHJpbmcpID0+IHtcbiAgY29uc3Qgc3RhY2sgPSBuZXcgRXJyb3IoKS5zdGFjaz8uc3BsaXQoL1xcclxcbnxcXHJ8XFxuL2cpIHx8IFtdO1xuICBsZXQgaGFzVHJhY2VGdW5jID0gZmFsc2U7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhY2subGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoaGFzVHJhY2VGdW5jICYmICFzdGFja1tpXS5pbmNsdWRlcygnVFJBQ0VfRlVOQycpKSB7XG4gICAgICBsZXQgbGFiZWwgPSBgRlVOQ18ke21zZ306OiR7c3RhY2tbaV0udHJpbSgpLnNwbGl0KCcgJylbMV19YDtcbiAgICAgIGlmIChleHRyYU1zZykge1xuICAgICAgICBsYWJlbCArPSBgOjoke2V4dHJhTXNnfWA7XG4gICAgICB9XG4gICAgICBUUkFDRSgnQ1BVJywgbGFiZWwpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoc3RhY2tbaV0uaW5jbHVkZXMoJ1RSQUNFX0ZVTkMnKSkge1xuICAgICAgaGFzVHJhY2VGdW5jID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQGlnbm9yZVxuICovXG5leHBvcnQgY29uc3QgVFJBQ0VfRlVOQ19CRUdJTiA9IChleHRyYU1zZz86IHN0cmluZykgPT4ge1xuICBpZiAodHlwZW9mIGVudi50cmFjZSA9PT0gJ3VuZGVmaW5lZCcgPyAhZW52Lndhc20udHJhY2UgOiAhZW52LnRyYWNlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIFRSQUNFX0ZVTkMoJ0JFR0lOJywgZXh0cmFNc2cpO1xufTtcblxuLyoqXG4gKiBAaWdub3JlXG4gKi9cbmV4cG9ydCBjb25zdCBUUkFDRV9GVU5DX0VORCA9IChleHRyYU1zZz86IHN0cmluZykgPT4ge1xuICBpZiAodHlwZW9mIGVudi50cmFjZSA9PT0gJ3VuZGVmaW5lZCcgPyAhZW52Lndhc20udHJhY2UgOiAhZW52LnRyYWNlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIFRSQUNFX0ZVTkMoJ0VORCcsIGV4dHJhTXNnKTtcbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7cmVzb2x2ZUJhY2tlbmRBbmRFeGVjdXRpb25Qcm92aWRlcnN9IGZyb20gJy4vYmFja2VuZC1pbXBsLmpzJztcbmltcG9ydCB7SW5mZXJlbmNlU2Vzc2lvbkhhbmRsZXJ9IGZyb20gJy4vYmFja2VuZC5qcyc7XG5pbXBvcnQge0luZmVyZW5jZVNlc3Npb24gYXMgSW5mZXJlbmNlU2Vzc2lvbkludGVyZmFjZX0gZnJvbSAnLi9pbmZlcmVuY2Utc2Vzc2lvbi5qcyc7XG5pbXBvcnQge09ubnhWYWx1ZX0gZnJvbSAnLi9vbm54LXZhbHVlLmpzJztcbmltcG9ydCB7VGVuc29yfSBmcm9tICcuL3RlbnNvci5qcyc7XG5pbXBvcnQge1RSQUNFX0ZVTkNfQkVHSU4sIFRSQUNFX0ZVTkNfRU5EfSBmcm9tICcuL3RyYWNlLmpzJztcblxudHlwZSBTZXNzaW9uT3B0aW9ucyA9IEluZmVyZW5jZVNlc3Npb25JbnRlcmZhY2UuU2Vzc2lvbk9wdGlvbnM7XG50eXBlIFJ1bk9wdGlvbnMgPSBJbmZlcmVuY2VTZXNzaW9uSW50ZXJmYWNlLlJ1bk9wdGlvbnM7XG50eXBlIEZlZWRzVHlwZSA9IEluZmVyZW5jZVNlc3Npb25JbnRlcmZhY2UuRmVlZHNUeXBlO1xudHlwZSBGZXRjaGVzVHlwZSA9IEluZmVyZW5jZVNlc3Npb25JbnRlcmZhY2UuRmV0Y2hlc1R5cGU7XG50eXBlIFJldHVyblR5cGUgPSBJbmZlcmVuY2VTZXNzaW9uSW50ZXJmYWNlLlJldHVyblR5cGU7XG5cbmV4cG9ydCBjbGFzcyBJbmZlcmVuY2VTZXNzaW9uIGltcGxlbWVudHMgSW5mZXJlbmNlU2Vzc2lvbkludGVyZmFjZSB7XG4gIHByaXZhdGUgY29uc3RydWN0b3IoaGFuZGxlcjogSW5mZXJlbmNlU2Vzc2lvbkhhbmRsZXIpIHtcbiAgICB0aGlzLmhhbmRsZXIgPSBoYW5kbGVyO1xuICB9XG4gIHJ1bihmZWVkczogRmVlZHNUeXBlLCBvcHRpb25zPzogUnVuT3B0aW9ucyk6IFByb21pc2U8UmV0dXJuVHlwZT47XG4gIHJ1bihmZWVkczogRmVlZHNUeXBlLCBmZXRjaGVzOiBGZXRjaGVzVHlwZSwgb3B0aW9ucz86IFJ1bk9wdGlvbnMpOiBQcm9taXNlPFJldHVyblR5cGU+O1xuICBhc3luYyBydW4oZmVlZHM6IEZlZWRzVHlwZSwgYXJnMT86IEZldGNoZXNUeXBlfFJ1bk9wdGlvbnMsIGFyZzI/OiBSdW5PcHRpb25zKTogUHJvbWlzZTxSZXR1cm5UeXBlPiB7XG4gICAgVFJBQ0VfRlVOQ19CRUdJTigpO1xuICAgIGNvbnN0IGZldGNoZXM6IHtbbmFtZTogc3RyaW5nXTogT25ueFZhbHVlfG51bGx9ID0ge307XG4gICAgbGV0IG9wdGlvbnM6IFJ1bk9wdGlvbnMgPSB7fTtcbiAgICAvLyBjaGVjayBpbnB1dHNcbiAgICBpZiAodHlwZW9mIGZlZWRzICE9PSAnb2JqZWN0JyB8fCBmZWVkcyA9PT0gbnVsbCB8fCBmZWVkcyBpbnN0YW5jZW9mIFRlbnNvciB8fCBBcnJheS5pc0FycmF5KGZlZWRzKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAnXFwnZmVlZHNcXCcgbXVzdCBiZSBhbiBvYmplY3QgdGhhdCB1c2UgaW5wdXQgbmFtZXMgYXMga2V5cyBhbmQgT25ueFZhbHVlIGFzIGNvcnJlc3BvbmRpbmcgdmFsdWVzLicpO1xuICAgIH1cblxuICAgIGxldCBpc0ZldGNoZXNFbXB0eSA9IHRydWU7XG4gICAgLy8gZGV0ZXJtaW5lIHdoaWNoIG92ZXJyaWRlIGlzIGJlaW5nIHVzZWRcbiAgICBpZiAodHlwZW9mIGFyZzEgPT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAoYXJnMSA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmV4cGVjdGVkIGFyZ3VtZW50WzFdOiBjYW5ub3QgYmUgbnVsbC4nKTtcbiAgICAgIH1cbiAgICAgIGlmIChhcmcxIGluc3RhbmNlb2YgVGVuc29yKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1xcJ2ZldGNoZXNcXCcgY2Fubm90IGJlIGEgVGVuc29yJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGFyZzEpKSB7XG4gICAgICAgIGlmIChhcmcxLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1xcJ2ZldGNoZXNcXCcgY2Fubm90IGJlIGFuIGVtcHR5IGFycmF5LicpO1xuICAgICAgICB9XG4gICAgICAgIGlzRmV0Y2hlc0VtcHR5ID0gZmFsc2U7XG4gICAgICAgIC8vIG91dHB1dCBuYW1lc1xuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgb2YgYXJnMSkge1xuICAgICAgICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1xcJ2ZldGNoZXNcXCcgbXVzdCBiZSBhIHN0cmluZyBhcnJheSBvciBhbiBvYmplY3QuJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLm91dHB1dE5hbWVzLmluZGV4T2YobmFtZSkgPT09IC0xKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgJ2ZldGNoZXMnIGNvbnRhaW5zIGludmFsaWQgb3V0cHV0IG5hbWU6ICR7bmFtZX0uYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZldGNoZXNbbmFtZV0gPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBhcmcyID09PSAnb2JqZWN0JyAmJiBhcmcyICE9PSBudWxsKSB7XG4gICAgICAgICAgb3B0aW9ucyA9IGFyZzI7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZzIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXFwnb3B0aW9uc1xcJyBtdXN0IGJlIGFuIG9iamVjdC4nKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZGVjaWRlIHdoZXRoZXIgYXJnMSBpcyBmZXRjaGVzIG9yIG9wdGlvbnNcbiAgICAgICAgLy8gaWYgYW55IG91dHB1dCBuYW1lIGlzIHByZXNlbnQgYW5kIGl0cyB2YWx1ZSBpcyB2YWxpZCBPbm54VmFsdWUsIHdlIGNvbnNpZGVyIGl0IGZldGNoZXNcbiAgICAgICAgbGV0IGlzRmV0Y2hlcyA9IGZhbHNlO1xuICAgICAgICBjb25zdCBhcmcxS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGFyZzEpO1xuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgb2YgdGhpcy5vdXRwdXROYW1lcykge1xuICAgICAgICAgIGlmIChhcmcxS2V5cy5pbmRleE9mKG5hbWUpICE9PSAtMSkge1xuICAgICAgICAgICAgY29uc3QgdiA9IChhcmcxIGFzIEluZmVyZW5jZVNlc3Npb25JbnRlcmZhY2UuTnVsbGFibGVPbm54VmFsdWVNYXBUeXBlKVtuYW1lXTtcbiAgICAgICAgICAgIGlmICh2ID09PSBudWxsIHx8IHYgaW5zdGFuY2VvZiBUZW5zb3IpIHtcbiAgICAgICAgICAgICAgaXNGZXRjaGVzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgaXNGZXRjaGVzRW1wdHkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgZmV0Y2hlc1tuYW1lXSA9IHY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzRmV0Y2hlcykge1xuICAgICAgICAgIGlmICh0eXBlb2YgYXJnMiA9PT0gJ29iamVjdCcgJiYgYXJnMiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgb3B0aW9ucyA9IGFyZzI7XG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYXJnMiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1xcJ29wdGlvbnNcXCcgbXVzdCBiZSBhbiBvYmplY3QuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9wdGlvbnMgPSBhcmcxIGFzIFJ1bk9wdGlvbnM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcmcxICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5leHBlY3RlZCBhcmd1bWVudFsxXTogbXVzdCBiZSBcXCdmZXRjaGVzXFwnIG9yIFxcJ29wdGlvbnNcXCcuJyk7XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgaWYgYWxsIGlucHV0cyBhcmUgaW4gZmVlZFxuICAgIGZvciAoY29uc3QgbmFtZSBvZiB0aGlzLmlucHV0TmFtZXMpIHtcbiAgICAgIGlmICh0eXBlb2YgZmVlZHNbbmFtZV0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW5wdXQgJyR7bmFtZX0nIGlzIG1pc3NpbmcgaW4gJ2ZlZWRzJy5gKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBpZiBubyBmZXRjaGVzIGlzIHNwZWNpZmllZCwgd2UgdXNlIHRoZSBmdWxsIG91dHB1dCBuYW1lcyBsaXN0XG4gICAgaWYgKGlzRmV0Y2hlc0VtcHR5KSB7XG4gICAgICBmb3IgKGNvbnN0IG5hbWUgb2YgdGhpcy5vdXRwdXROYW1lcykge1xuICAgICAgICBmZXRjaGVzW25hbWVdID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBmZWVkcywgZmV0Y2hlcyBhbmQgb3B0aW9ucyBhcmUgcHJlcGFyZWRcblxuICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCB0aGlzLmhhbmRsZXIucnVuKGZlZWRzLCBmZXRjaGVzLCBvcHRpb25zKTtcbiAgICBjb25zdCByZXR1cm5WYWx1ZToge1tuYW1lOiBzdHJpbmddOiBPbm54VmFsdWV9ID0ge307XG4gICAgZm9yIChjb25zdCBrZXkgaW4gcmVzdWx0cykge1xuICAgICAgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKHJlc3VsdHMsIGtleSkpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gcmVzdWx0c1trZXldO1xuICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgVGVuc29yKSB7XG4gICAgICAgICAgcmV0dXJuVmFsdWVba2V5XSA9IHJlc3VsdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm5WYWx1ZVtrZXldID0gbmV3IFRlbnNvcihyZXN1bHQudHlwZSwgcmVzdWx0LmRhdGEsIHJlc3VsdC5kaW1zKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBUUkFDRV9GVU5DX0VORCgpO1xuICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgfVxuXG4gIGFzeW5jIHJlbGVhc2UoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlci5kaXNwb3NlKCk7XG4gIH1cblxuICBzdGF0aWMgY3JlYXRlKHBhdGg6IHN0cmluZywgb3B0aW9ucz86IFNlc3Npb25PcHRpb25zKTogUHJvbWlzZTxJbmZlcmVuY2VTZXNzaW9uSW50ZXJmYWNlPjtcbiAgc3RhdGljIGNyZWF0ZShidWZmZXI6IEFycmF5QnVmZmVyTGlrZSwgb3B0aW9ucz86IFNlc3Npb25PcHRpb25zKTogUHJvbWlzZTxJbmZlcmVuY2VTZXNzaW9uSW50ZXJmYWNlPjtcbiAgc3RhdGljIGNyZWF0ZShidWZmZXI6IEFycmF5QnVmZmVyTGlrZSwgYnl0ZU9mZnNldDogbnVtYmVyLCBieXRlTGVuZ3RoPzogbnVtYmVyLCBvcHRpb25zPzogU2Vzc2lvbk9wdGlvbnMpOlxuICAgICAgUHJvbWlzZTxJbmZlcmVuY2VTZXNzaW9uSW50ZXJmYWNlPjtcbiAgc3RhdGljIGNyZWF0ZShidWZmZXI6IFVpbnQ4QXJyYXksIG9wdGlvbnM/OiBTZXNzaW9uT3B0aW9ucyk6IFByb21pc2U8SW5mZXJlbmNlU2Vzc2lvbkludGVyZmFjZT47XG4gIHN0YXRpYyBhc3luYyBjcmVhdGUoXG4gICAgICBhcmcwOiBzdHJpbmd8QXJyYXlCdWZmZXJMaWtlfFVpbnQ4QXJyYXksIGFyZzE/OiBTZXNzaW9uT3B0aW9uc3xudW1iZXIsIGFyZzI/OiBudW1iZXIsXG4gICAgICBhcmczPzogU2Vzc2lvbk9wdGlvbnMpOiBQcm9taXNlPEluZmVyZW5jZVNlc3Npb25JbnRlcmZhY2U+IHtcbiAgICBUUkFDRV9GVU5DX0JFR0lOKCk7XG4gICAgLy8gZWl0aGVyIGxvYWQgZnJvbSBhIGZpbGUgb3IgYnVmZmVyXG4gICAgbGV0IGZpbGVQYXRoT3JVaW50OEFycmF5OiBzdHJpbmd8VWludDhBcnJheTtcbiAgICBsZXQgb3B0aW9uczogU2Vzc2lvbk9wdGlvbnMgPSB7fTtcblxuICAgIGlmICh0eXBlb2YgYXJnMCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGZpbGVQYXRoT3JVaW50OEFycmF5ID0gYXJnMDtcbiAgICAgIGlmICh0eXBlb2YgYXJnMSA9PT0gJ29iamVjdCcgJiYgYXJnMSAhPT0gbnVsbCkge1xuICAgICAgICBvcHRpb25zID0gYXJnMTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZzEgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1xcJ29wdGlvbnNcXCcgbXVzdCBiZSBhbiBvYmplY3QuJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChhcmcwIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgZmlsZVBhdGhPclVpbnQ4QXJyYXkgPSBhcmcwO1xuICAgICAgaWYgKHR5cGVvZiBhcmcxID09PSAnb2JqZWN0JyAmJiBhcmcxICE9PSBudWxsKSB7XG4gICAgICAgIG9wdGlvbnMgPSBhcmcxO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYXJnMSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXFwnb3B0aW9uc1xcJyBtdXN0IGJlIGFuIG9iamVjdC4nKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKFxuICAgICAgICBhcmcwIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgfHxcbiAgICAgICAgKHR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgYXJnMCBpbnN0YW5jZW9mIFNoYXJlZEFycmF5QnVmZmVyKSkge1xuICAgICAgY29uc3QgYnVmZmVyID0gYXJnMDtcbiAgICAgIGxldCBieXRlT2Zmc2V0ID0gMDtcbiAgICAgIGxldCBieXRlTGVuZ3RoID0gYXJnMC5ieXRlTGVuZ3RoO1xuICAgICAgaWYgKHR5cGVvZiBhcmcxID09PSAnb2JqZWN0JyAmJiBhcmcxICE9PSBudWxsKSB7XG4gICAgICAgIG9wdGlvbnMgPSBhcmcxO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYXJnMSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgYnl0ZU9mZnNldCA9IGFyZzE7XG4gICAgICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIoYnl0ZU9mZnNldCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnYnl0ZU9mZnNldFxcJyBtdXN0IGJlIGFuIGludGVnZXIuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGJ5dGVPZmZzZXQgPj0gYnVmZmVyLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgJ2J5dGVPZmZzZXQnIGlzIG91dCBvZiByYW5nZSBbMCwgJHtidWZmZXIuYnl0ZUxlbmd0aH0pLmApO1xuICAgICAgICB9XG4gICAgICAgIGJ5dGVMZW5ndGggPSBhcmcwLmJ5dGVMZW5ndGggLSBieXRlT2Zmc2V0O1xuICAgICAgICBpZiAodHlwZW9mIGFyZzIgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgYnl0ZUxlbmd0aCA9IGFyZzI7XG4gICAgICAgICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihieXRlTGVuZ3RoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ2J5dGVMZW5ndGhcXCcgbXVzdCBiZSBhbiBpbnRlZ2VyLicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYnl0ZUxlbmd0aCA8PSAwIHx8IGJ5dGVPZmZzZXQgKyBieXRlTGVuZ3RoID4gYnVmZmVyLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGAnYnl0ZUxlbmd0aCcgaXMgb3V0IG9mIHJhbmdlICgwLCAke2J1ZmZlci5ieXRlTGVuZ3RoIC0gYnl0ZU9mZnNldH1dLmApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodHlwZW9mIGFyZzMgPT09ICdvYmplY3QnICYmIGFyZzMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBhcmczO1xuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZzMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcXCdvcHRpb25zXFwnIG11c3QgYmUgYW4gb2JqZWN0LicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYXJnMiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcXCdieXRlTGVuZ3RoXFwnIG11c3QgYmUgYSBudW1iZXIuJyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZzEgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1xcJ29wdGlvbnNcXCcgbXVzdCBiZSBhbiBvYmplY3QuJyk7XG4gICAgICB9XG4gICAgICBmaWxlUGF0aE9yVWludDhBcnJheSA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlciwgYnl0ZU9mZnNldCwgYnl0ZUxlbmd0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1VuZXhwZWN0ZWQgYXJndW1lbnRbMF06IG11c3QgYmUgXFwncGF0aFxcJyBvciBcXCdidWZmZXJcXCcuJyk7XG4gICAgfVxuXG4gICAgLy8gcmVzb2x2ZSBiYWNrZW5kLCB1cGRhdGUgc2Vzc2lvbiBvcHRpb25zIHdpdGggdmFsaWRhdGVkIEVQcywgYW5kIGNyZWF0ZSBzZXNzaW9uIGhhbmRsZXJcbiAgICBjb25zdCBbYmFja2VuZCwgb3B0aW9uc1dpdGhWYWxpZGF0ZWRFUHNdID0gYXdhaXQgcmVzb2x2ZUJhY2tlbmRBbmRFeGVjdXRpb25Qcm92aWRlcnMob3B0aW9ucyk7XG4gICAgY29uc3QgaGFuZGxlciA9IGF3YWl0IGJhY2tlbmQuY3JlYXRlSW5mZXJlbmNlU2Vzc2lvbkhhbmRsZXIoZmlsZVBhdGhPclVpbnQ4QXJyYXksIG9wdGlvbnNXaXRoVmFsaWRhdGVkRVBzKTtcbiAgICBUUkFDRV9GVU5DX0VORCgpO1xuICAgIHJldHVybiBuZXcgSW5mZXJlbmNlU2Vzc2lvbihoYW5kbGVyKTtcbiAgfVxuXG4gIHN0YXJ0UHJvZmlsaW5nKCk6IHZvaWQge1xuICAgIHRoaXMuaGFuZGxlci5zdGFydFByb2ZpbGluZygpO1xuICB9XG4gIGVuZFByb2ZpbGluZygpOiB2b2lkIHtcbiAgICB0aGlzLmhhbmRsZXIuZW5kUHJvZmlsaW5nKCk7XG4gIH1cblxuICBnZXQgaW5wdXROYW1lcygpOiByZWFkb25seSBzdHJpbmdbXSB7XG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlci5pbnB1dE5hbWVzO1xuICB9XG4gIGdldCBvdXRwdXROYW1lcygpOiByZWFkb25seSBzdHJpbmdbXSB7XG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlci5vdXRwdXROYW1lcztcbiAgfVxuXG4gIHByaXZhdGUgaGFuZGxlcjogSW5mZXJlbmNlU2Vzc2lvbkhhbmRsZXI7XG59XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7SW5mZXJlbmNlU2Vzc2lvbiBhcyBJbmZlcmVuY2VTZXNzaW9uSW1wbH0gZnJvbSAnLi9pbmZlcmVuY2Utc2Vzc2lvbi1pbXBsLmpzJztcbmltcG9ydCB7T25ueE1vZGVsT3B0aW9uc30gZnJvbSAnLi9vbm54LW1vZGVsLmpzJztcbmltcG9ydCB7T25ueFZhbHVlLCBPbm54VmFsdWVEYXRhTG9jYXRpb259IGZyb20gJy4vb25ueC12YWx1ZS5qcyc7XG5cbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZWRlY2xhcmUgKi9cblxuZXhwb3J0IGRlY2xhcmUgbmFtZXNwYWNlIEluZmVyZW5jZVNlc3Npb24ge1xuICAvLyAjcmVnaW9uIGlucHV0L291dHB1dCB0eXBlc1xuXG4gIHR5cGUgT25ueFZhbHVlTWFwVHlwZSA9IHtyZWFkb25seSBbbmFtZTogc3RyaW5nXTogT25ueFZhbHVlfTtcbiAgdHlwZSBOdWxsYWJsZU9ubnhWYWx1ZU1hcFR5cGUgPSB7cmVhZG9ubHkgW25hbWU6IHN0cmluZ106IE9ubnhWYWx1ZSB8IG51bGx9O1xuXG4gIC8qKlxuICAgKiBBIGZlZWRzIChtb2RlbCBpbnB1dHMpIGlzIGFuIG9iamVjdCB0aGF0IHVzZXMgaW5wdXQgbmFtZXMgYXMga2V5cyBhbmQgT25ueFZhbHVlIGFzIGNvcnJlc3BvbmRpbmcgdmFsdWVzLlxuICAgKi9cbiAgdHlwZSBGZWVkc1R5cGUgPSBPbm54VmFsdWVNYXBUeXBlO1xuXG4gIC8qKlxuICAgKiBBIGZldGNoZXMgKG1vZGVsIG91dHB1dHMpIGNvdWxkIGJlIG9uZSBvZiB0aGUgZm9sbG93aW5nOlxuICAgKlxuICAgKiAtIE9taXR0ZWQuIFVzZSBtb2RlbCdzIG91dHB1dCBuYW1lcyBkZWZpbml0aW9uLlxuICAgKiAtIEFuIGFycmF5IG9mIHN0cmluZyBpbmRpY2F0aW5nIHRoZSBvdXRwdXQgbmFtZXMuXG4gICAqIC0gQW4gb2JqZWN0IHRoYXQgdXNlIG91dHB1dCBuYW1lcyBhcyBrZXlzIGFuZCBPbm54VmFsdWUgb3IgbnVsbCBhcyBjb3JyZXNwb25kaW5nIHZhbHVlcy5cbiAgICpcbiAgICogQHJlbWFya1xuICAgKiBkaWZmZXJlbnQgZnJvbSBpbnB1dCBhcmd1bWVudCwgaW4gb3V0cHV0LCBPbm54VmFsdWUgaXMgb3B0aW9uYWwuIElmIGFuIE9ubnhWYWx1ZSBpcyBwcmVzZW50IGl0IHdpbGwgYmVcbiAgICogdXNlZCBhcyBhIHByZS1hbGxvY2F0ZWQgdmFsdWUgYnkgdGhlIGluZmVyZW5jZSBlbmdpbmU7IGlmIG9taXR0ZWQsIGluZmVyZW5jZSBlbmdpbmUgd2lsbCBhbGxvY2F0ZSBidWZmZXJcbiAgICogaW50ZXJuYWxseS5cbiAgICovXG4gIHR5cGUgRmV0Y2hlc1R5cGUgPSByZWFkb25seSBzdHJpbmdbXXxOdWxsYWJsZU9ubnhWYWx1ZU1hcFR5cGU7XG5cbiAgLyoqXG4gICAqIEEgaW5mZXJlbmNpbmcgcmV0dXJuIHR5cGUgaXMgYW4gb2JqZWN0IHRoYXQgdXNlcyBvdXRwdXQgbmFtZXMgYXMga2V5cyBhbmQgT25ueFZhbHVlIGFzIGNvcnJlc3BvbmRpbmcgdmFsdWVzLlxuICAgKi9cbiAgdHlwZSBSZXR1cm5UeXBlID0gT25ueFZhbHVlTWFwVHlwZTtcblxuICAvLyAjZW5kcmVnaW9uXG5cbiAgLy8gI3JlZ2lvbiBzZXNzaW9uIG9wdGlvbnNcblxuICAvKipcbiAgICogQSBzZXQgb2YgY29uZmlndXJhdGlvbnMgZm9yIHNlc3Npb24gYmVoYXZpb3IuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFNlc3Npb25PcHRpb25zIGV4dGVuZHMgT25ueE1vZGVsT3B0aW9ucyB7XG4gICAgLyoqXG4gICAgICogQW4gYXJyYXkgb2YgZXhlY3V0aW9uIHByb3ZpZGVyIG9wdGlvbnMuXG4gICAgICpcbiAgICAgKiBBbiBleGVjdXRpb24gcHJvdmlkZXIgb3B0aW9uIGNhbiBiZSBhIHN0cmluZyBpbmRpY2F0aW5nIHRoZSBuYW1lIG9mIHRoZSBleGVjdXRpb24gcHJvdmlkZXIsXG4gICAgICogb3IgYW4gb2JqZWN0IG9mIGNvcnJlc3BvbmRpbmcgdHlwZS5cbiAgICAgKi9cbiAgICBleGVjdXRpb25Qcm92aWRlcnM/OiByZWFkb25seSBFeGVjdXRpb25Qcm92aWRlckNvbmZpZ1tdO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGludHJhIE9QIHRocmVhZHMgbnVtYmVyLlxuICAgICAqXG4gICAgICogVGhpcyBzZXR0aW5nIGlzIGF2YWlsYWJsZSBvbmx5IGluIE9OTlhSdW50aW1lIChOb2RlLmpzIGJpbmRpbmcgYW5kIHJlYWN0LW5hdGl2ZSkuXG4gICAgICovXG4gICAgaW50cmFPcE51bVRocmVhZHM/OiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaW50ZXIgT1AgdGhyZWFkcyBudW1iZXIuXG4gICAgICpcbiAgICAgKiBUaGlzIHNldHRpbmcgaXMgYXZhaWxhYmxlIG9ubHkgaW4gT05OWFJ1bnRpbWUgKE5vZGUuanMgYmluZGluZyBhbmQgcmVhY3QtbmF0aXZlKS5cbiAgICAgKi9cbiAgICBpbnRlck9wTnVtVGhyZWFkcz86IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBmcmVlIGRpbWVuc2lvbiBvdmVycmlkZS5cbiAgICAgKlxuICAgICAqIFRoaXMgc2V0dGluZyBpcyBhdmFpbGFibGUgb25seSBpbiBPTk5YUnVudGltZSAoTm9kZS5qcyBiaW5kaW5nIGFuZCByZWFjdC1uYXRpdmUpIG9yIFdlYkFzc2VtYmx5IGJhY2tlbmRcbiAgICAgKi9cbiAgICBmcmVlRGltZW5zaW9uT3ZlcnJpZGVzPzoge3JlYWRvbmx5IFtkaW1lbnNpb25OYW1lOiBzdHJpbmddOiBudW1iZXJ9O1xuXG4gICAgLyoqXG4gICAgICogVGhlIG9wdGltaXphdGlvbiBsZXZlbC5cbiAgICAgKlxuICAgICAqIFRoaXMgc2V0dGluZyBpcyBhdmFpbGFibGUgb25seSBpbiBPTk5YUnVudGltZSAoTm9kZS5qcyBiaW5kaW5nIGFuZCByZWFjdC1uYXRpdmUpIG9yIFdlYkFzc2VtYmx5IGJhY2tlbmRcbiAgICAgKi9cbiAgICBncmFwaE9wdGltaXphdGlvbkxldmVsPzogJ2Rpc2FibGVkJ3wnYmFzaWMnfCdleHRlbmRlZCd8J2FsbCc7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIGVuYWJsZSBDUFUgbWVtb3J5IGFyZW5hLlxuICAgICAqXG4gICAgICogVGhpcyBzZXR0aW5nIGlzIGF2YWlsYWJsZSBvbmx5IGluIE9OTlhSdW50aW1lIChOb2RlLmpzIGJpbmRpbmcgYW5kIHJlYWN0LW5hdGl2ZSkgb3IgV2ViQXNzZW1ibHkgYmFja2VuZFxuICAgICAqL1xuICAgIGVuYWJsZUNwdU1lbUFyZW5hPzogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgZW5hYmxlIG1lbW9yeSBwYXR0ZXJuLlxuICAgICAqXG4gICAgICogVGhpcyBzZXR0aW5nIGlzIGF2YWlsYWJsZSBvbmx5IGluIE9OTlhSdW50aW1lIChOb2RlLmpzIGJpbmRpbmcgYW5kIHJlYWN0LW5hdGl2ZSkgb3IgV2ViQXNzZW1ibHkgYmFja2VuZFxuICAgICAqL1xuICAgIGVuYWJsZU1lbVBhdHRlcm4/OiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogRXhlY3V0aW9uIG1vZGUuXG4gICAgICpcbiAgICAgKiBUaGlzIHNldHRpbmcgaXMgYXZhaWxhYmxlIG9ubHkgaW4gT05OWFJ1bnRpbWUgKE5vZGUuanMgYmluZGluZyBhbmQgcmVhY3QtbmF0aXZlKSBvciBXZWJBc3NlbWJseSBiYWNrZW5kXG4gICAgICovXG4gICAgZXhlY3V0aW9uTW9kZT86ICdzZXF1ZW50aWFsJ3wncGFyYWxsZWwnO1xuXG4gICAgLyoqXG4gICAgICogT3B0aW1pemVkIG1vZGVsIGZpbGUgcGF0aC5cbiAgICAgKlxuICAgICAqIElmIHRoaXMgc2V0dGluZyBpcyBzcGVjaWZpZWQsIHRoZSBvcHRpbWl6ZWQgbW9kZWwgd2lsbCBiZSBkdW1wZWQuIEluIGJyb3dzZXIsIGEgYmxvYiB3aWxsIGJlIGNyZWF0ZWRcbiAgICAgKiB3aXRoIGEgcG9wLXVwIHdpbmRvdy5cbiAgICAgKi9cbiAgICBvcHRpbWl6ZWRNb2RlbEZpbGVQYXRoPzogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciBlbmFibGUgcHJvZmlsaW5nLlxuICAgICAqXG4gICAgICogVGhpcyBzZXR0aW5nIGlzIGEgcGxhY2Vob2xkZXIgZm9yIGEgZnV0dXJlIHVzZS5cbiAgICAgKi9cbiAgICBlbmFibGVQcm9maWxpbmc/OiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogRmlsZSBwcmVmaXggZm9yIHByb2ZpbGluZy5cbiAgICAgKlxuICAgICAqIFRoaXMgc2V0dGluZyBpcyBhIHBsYWNlaG9sZGVyIGZvciBhIGZ1dHVyZSB1c2UuXG4gICAgICovXG4gICAgcHJvZmlsZUZpbGVQcmVmaXg/OiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBMb2cgSUQuXG4gICAgICpcbiAgICAgKiBUaGlzIHNldHRpbmcgaXMgYXZhaWxhYmxlIG9ubHkgaW4gT05OWFJ1bnRpbWUgKE5vZGUuanMgYmluZGluZyBhbmQgcmVhY3QtbmF0aXZlKSBvciBXZWJBc3NlbWJseSBiYWNrZW5kXG4gICAgICovXG4gICAgbG9nSWQ/OiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBMb2cgc2V2ZXJpdHkgbGV2ZWwuIFNlZVxuICAgICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvb25ueHJ1bnRpbWUvYmxvYi9tYWluL2luY2x1ZGUvb25ueHJ1bnRpbWUvY29yZS9jb21tb24vbG9nZ2luZy9zZXZlcml0eS5oXG4gICAgICpcbiAgICAgKiBUaGlzIHNldHRpbmcgaXMgYXZhaWxhYmxlIG9ubHkgaW4gT05OWFJ1bnRpbWUgKE5vZGUuanMgYmluZGluZyBhbmQgcmVhY3QtbmF0aXZlKSBvciBXZWJBc3NlbWJseSBiYWNrZW5kXG4gICAgICovXG4gICAgbG9nU2V2ZXJpdHlMZXZlbD86IDB8MXwyfDN8NDtcblxuICAgIC8qKlxuICAgICAqIExvZyB2ZXJib3NpdHkgbGV2ZWwuXG4gICAgICpcbiAgICAgKiBUaGlzIHNldHRpbmcgaXMgYXZhaWxhYmxlIG9ubHkgaW4gV2ViQXNzZW1ibHkgYmFja2VuZC4gV2lsbCBzdXBwb3J0IE5vZGUuanMgYmluZGluZyBhbmQgcmVhY3QtbmF0aXZlIGxhdGVyXG4gICAgICovXG4gICAgbG9nVmVyYm9zaXR5TGV2ZWw/OiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBTcGVjaWZ5IHN0cmluZyBhcyBhIHByZWZlcnJlZCBkYXRhIGxvY2F0aW9uIGZvciBhbGwgb3V0cHV0cywgb3IgYW4gb2JqZWN0IHRoYXQgdXNlIG91dHB1dCBuYW1lcyBhcyBrZXlzIGFuZCBhXG4gICAgICogcHJlZmVycmVkIGRhdGEgbG9jYXRpb24gYXMgY29ycmVzcG9uZGluZyB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBUaGlzIHNldHRpbmcgaXMgYXZhaWxhYmxlIG9ubHkgaW4gT05OWFJ1bnRpbWUgV2ViIGZvciBXZWJHTCBhbmQgV2ViR1BVIEVQLlxuICAgICAqL1xuICAgIHByZWZlcnJlZE91dHB1dExvY2F0aW9uPzogT25ueFZhbHVlRGF0YUxvY2F0aW9ufHtyZWFkb25seSBbb3V0cHV0TmFtZTogc3RyaW5nXTogT25ueFZhbHVlRGF0YUxvY2F0aW9ufTtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgZW5hYmxlIGdyYXBoIGNhcHR1cmUuXG4gICAgICogVGhpcyBzZXR0aW5nIGlzIGF2YWlsYWJsZSBvbmx5IGluIE9OTlhSdW50aW1lIFdlYiBmb3IgV2ViR1BVIEVQLlxuICAgICAqL1xuICAgIGVuYWJsZUdyYXBoQ2FwdHVyZT86IGJvb2xlYW47XG5cbiAgICAvKipcbiAgICAgKiBTdG9yZSBjb25maWd1cmF0aW9ucyBmb3IgYSBzZXNzaW9uLiBTZWVcbiAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L29ubnhydW50aW1lL2Jsb2IvbWFpbi9pbmNsdWRlL29ubnhydW50aW1lL2NvcmUvc2Vzc2lvbi9cbiAgICAgKiBvbm54cnVudGltZV9zZXNzaW9uX29wdGlvbnNfY29uZmlnX2tleXMuaFxuICAgICAqXG4gICAgICogVGhpcyBzZXR0aW5nIGlzIGF2YWlsYWJsZSBvbmx5IGluIFdlYkFzc2VtYmx5IGJhY2tlbmQuIFdpbGwgc3VwcG9ydCBOb2RlLmpzIGJpbmRpbmcgYW5kIHJlYWN0LW5hdGl2ZSBsYXRlclxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqc1xuICAgICAqIGV4dHJhOiB7XG4gICAgICogICBzZXNzaW9uOiB7XG4gICAgICogICAgIHNldF9kZW5vcm1hbF9hc196ZXJvOiBcIjFcIixcbiAgICAgKiAgICAgZGlzYWJsZV9wcmVwYWNraW5nOiBcIjFcIlxuICAgICAqICAgfSxcbiAgICAgKiAgIG9wdGltaXphdGlvbjoge1xuICAgICAqICAgICBlbmFibGVfZ2VsdV9hcHByb3hpbWF0aW9uOiBcIjFcIlxuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBleHRyYT86IFJlY29yZDxzdHJpbmcsIHVua25vd24+O1xuICB9XG5cbiAgLy8gI3JlZ2lvbiBleGVjdXRpb24gcHJvdmlkZXJzXG5cbiAgLy8gQ3VycmVudGx5LCB3ZSBoYXZlIHRoZSBmb2xsb3dpbmcgYmFja2VuZHMgdG8gc3VwcG9ydCBleGVjdXRpb24gcHJvdmlkZXJzOlxuICAvLyBCYWNrZW5kIE5vZGUuanMgYmluZGluZzogc3VwcG9ydHMgJ2NwdScsICdkbWwnICh3aW4zMiksICdjb3JlbWwnIChtYWNPUykgYW5kICdjdWRhJyAobGludXgpLlxuICAvLyBCYWNrZW5kIFdlYkFzc2VtYmx5OiBzdXBwb3J0cyAnY3B1JywgJ3dhc20nLCAnd2ViZ3B1JyBhbmQgJ3dlYm5uJy5cbiAgLy8gQmFja2VuZCBPTk5YLmpzOiBzdXBwb3J0cyAnd2ViZ2wnLlxuICAvLyBCYWNrZW5kIFJlYWN0IE5hdGl2ZTogc3VwcG9ydHMgJ2NwdScsICd4bm5wYWNrJywgJ2NvcmVtbCcgKGlPUyksICdubmFwaScgKEFuZHJvaWQpLlxuICBpbnRlcmZhY2UgRXhlY3V0aW9uUHJvdmlkZXJPcHRpb25NYXAge1xuICAgIGNvcmVtbDogQ29yZU1MRXhlY3V0aW9uUHJvdmlkZXJPcHRpb247XG4gICAgY3B1OiBDcHVFeGVjdXRpb25Qcm92aWRlck9wdGlvbjtcbiAgICBjdWRhOiBDdWRhRXhlY3V0aW9uUHJvdmlkZXJPcHRpb247XG4gICAgZG1sOiBEbWxFeGVjdXRpb25Qcm92aWRlck9wdGlvbjtcbiAgICBubmFwaTogTm5hcGlFeGVjdXRpb25Qcm92aWRlck9wdGlvbjtcbiAgICB0ZW5zb3JydDogVGVuc29yUnRFeGVjdXRpb25Qcm92aWRlck9wdGlvbjtcbiAgICB3YXNtOiBXZWJBc3NlbWJseUV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uO1xuICAgIHdlYmdsOiBXZWJHTEV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uO1xuICAgIHdlYmdwdTogV2ViR3B1RXhlY3V0aW9uUHJvdmlkZXJPcHRpb247XG4gICAgd2Vibm46IFdlYk5ORXhlY3V0aW9uUHJvdmlkZXJPcHRpb247XG4gICAgeG5ucGFjazogWG5ucGFja0V4ZWN1dGlvblByb3ZpZGVyT3B0aW9uO1xuICB9XG5cbiAgdHlwZSBFeGVjdXRpb25Qcm92aWRlck5hbWUgPSBrZXlvZiBFeGVjdXRpb25Qcm92aWRlck9wdGlvbk1hcDtcbiAgdHlwZSBFeGVjdXRpb25Qcm92aWRlckNvbmZpZyA9XG4gICAgICBFeGVjdXRpb25Qcm92aWRlck9wdGlvbk1hcFtFeGVjdXRpb25Qcm92aWRlck5hbWVdfEV4ZWN1dGlvblByb3ZpZGVyT3B0aW9ufEV4ZWN1dGlvblByb3ZpZGVyTmFtZXxzdHJpbmc7XG5cbiAgZXhwb3J0IGludGVyZmFjZSBFeGVjdXRpb25Qcm92aWRlck9wdGlvbiB7XG4gICAgcmVhZG9ubHkgbmFtZTogc3RyaW5nO1xuICB9XG4gIGV4cG9ydCBpbnRlcmZhY2UgQ3B1RXhlY3V0aW9uUHJvdmlkZXJPcHRpb24gZXh0ZW5kcyBFeGVjdXRpb25Qcm92aWRlck9wdGlvbiB7XG4gICAgcmVhZG9ubHkgbmFtZTogJ2NwdSc7XG4gICAgdXNlQXJlbmE/OiBib29sZWFuO1xuICB9XG4gIGV4cG9ydCBpbnRlcmZhY2UgQ3VkYUV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uIGV4dGVuZHMgRXhlY3V0aW9uUHJvdmlkZXJPcHRpb24ge1xuICAgIHJlYWRvbmx5IG5hbWU6ICdjdWRhJztcbiAgICBkZXZpY2VJZD86IG51bWJlcjtcbiAgfVxuICBleHBvcnQgaW50ZXJmYWNlIERtbEV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uIGV4dGVuZHMgRXhlY3V0aW9uUHJvdmlkZXJPcHRpb24ge1xuICAgIHJlYWRvbmx5IG5hbWU6ICdkbWwnO1xuICAgIGRldmljZUlkPzogbnVtYmVyO1xuICB9XG4gIGV4cG9ydCBpbnRlcmZhY2UgVGVuc29yUnRFeGVjdXRpb25Qcm92aWRlck9wdGlvbiBleHRlbmRzIEV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uIHtcbiAgICByZWFkb25seSBuYW1lOiAndGVuc29ycnQnO1xuICAgIGRldmljZUlkPzogbnVtYmVyO1xuICB9XG4gIGV4cG9ydCBpbnRlcmZhY2UgV2ViQXNzZW1ibHlFeGVjdXRpb25Qcm92aWRlck9wdGlvbiBleHRlbmRzIEV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uIHtcbiAgICByZWFkb25seSBuYW1lOiAnd2FzbSc7XG4gIH1cbiAgZXhwb3J0IGludGVyZmFjZSBXZWJHTEV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uIGV4dGVuZHMgRXhlY3V0aW9uUHJvdmlkZXJPcHRpb24ge1xuICAgIHJlYWRvbmx5IG5hbWU6ICd3ZWJnbCc7XG4gICAgLy8gVE9ETzogYWRkIGZsYWdzXG4gIH1cbiAgZXhwb3J0IGludGVyZmFjZSBYbm5wYWNrRXhlY3V0aW9uUHJvdmlkZXJPcHRpb24gZXh0ZW5kcyBFeGVjdXRpb25Qcm92aWRlck9wdGlvbiB7XG4gICAgcmVhZG9ubHkgbmFtZTogJ3hubnBhY2snO1xuICB9XG4gIGV4cG9ydCBpbnRlcmZhY2UgV2ViR3B1RXhlY3V0aW9uUHJvdmlkZXJPcHRpb24gZXh0ZW5kcyBFeGVjdXRpb25Qcm92aWRlck9wdGlvbiB7XG4gICAgcmVhZG9ubHkgbmFtZTogJ3dlYmdwdSc7XG4gICAgcHJlZmVycmVkTGF5b3V0PzogJ05DSFcnfCdOSFdDJztcbiAgfVxuICBleHBvcnQgaW50ZXJmYWNlIFdlYk5ORXhlY3V0aW9uUHJvdmlkZXJPcHRpb24gZXh0ZW5kcyBFeGVjdXRpb25Qcm92aWRlck9wdGlvbiB7XG4gICAgcmVhZG9ubHkgbmFtZTogJ3dlYm5uJztcbiAgICBkZXZpY2VUeXBlPzogJ2NwdSd8J2dwdSd8J25wdSc7XG4gICAgbnVtVGhyZWFkcz86IG51bWJlcjtcbiAgICBwb3dlclByZWZlcmVuY2U/OiAnZGVmYXVsdCd8J2xvdy1wb3dlcid8J2hpZ2gtcGVyZm9ybWFuY2UnO1xuICB9XG4gIGV4cG9ydCBpbnRlcmZhY2UgQ29yZU1MRXhlY3V0aW9uUHJvdmlkZXJPcHRpb24gZXh0ZW5kcyBFeGVjdXRpb25Qcm92aWRlck9wdGlvbiB7XG4gICAgcmVhZG9ubHkgbmFtZTogJ2NvcmVtbCc7XG4gICAgLyoqXG4gICAgICogVGhlIGJpdCBmbGFncyBmb3IgQ29yZU1MIGV4ZWN1dGlvbiBwcm92aWRlci5cbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIENPUkVNTF9GTEFHX1VTRV9DUFVfT05MWSA9IDB4MDAxXG4gICAgICogQ09SRU1MX0ZMQUdfRU5BQkxFX09OX1NVQkdSQVBIID0gMHgwMDJcbiAgICAgKiBDT1JFTUxfRkxBR19PTkxZX0VOQUJMRV9ERVZJQ0VfV0lUSF9BTkUgPSAweDAwNFxuICAgICAqIENPUkVNTF9GTEFHX09OTFlfQUxMT1dfU1RBVElDX0lOUFVUX1NIQVBFUyA9IDB4MDA4XG4gICAgICogQ09SRU1MX0ZMQUdfQ1JFQVRFX01MUFJPR1JBTSA9IDB4MDEwXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBTZWUgaW5jbHVkZS9vbm54cnVudGltZS9jb3JlL3Byb3ZpZGVycy9jb3JlbWwvY29yZW1sX3Byb3ZpZGVyX2ZhY3RvcnkuaCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqXG4gICAgICogVGhpcyBmbGFnIGlzIGF2YWlsYWJsZSBvbmx5IGluIE9OTlhSdW50aW1lIChOb2RlLmpzIGJpbmRpbmcpLlxuICAgICAqL1xuICAgIGNvcmVNbEZsYWdzPzogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIFNwZWNpZnkgd2hldGhlciB0byB1c2UgQ1BVIG9ubHkgaW4gQ29yZU1MIEVQLlxuICAgICAqXG4gICAgICogVGhpcyBzZXR0aW5nIGlzIGF2YWlsYWJsZSBvbmx5IGluIE9OTlhSdW50aW1lIChyZWFjdC1uYXRpdmUpLlxuICAgICAqL1xuICAgIHVzZUNQVU9ubHk/OiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIFNwZWNpZnkgd2hldGhlciB0byBlbmFibGUgQ29yZU1MIEVQIG9uIHN1YmdyYXBoLlxuICAgICAqXG4gICAgICogVGhpcyBzZXR0aW5nIGlzIGF2YWlsYWJsZSBvbmx5IGluIE9OTlhSdW50aW1lIChyZWFjdC1uYXRpdmUpLlxuICAgICAqL1xuICAgIGVuYWJsZU9uU3ViZ3JhcGg/OiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIFNwZWNpZnkgd2hldGhlciB0byBvbmx5IGVuYWJsZSBDb3JlTUwgRVAgZm9yIEFwcGxlIGRldmljZXMgd2l0aCBBTkUgKEFwcGxlIE5ldXJhbCBFbmdpbmUpLlxuICAgICAqXG4gICAgICogVGhpcyBzZXR0aW5nIGlzIGF2YWlsYWJsZSBvbmx5IGluIE9OTlhSdW50aW1lIChyZWFjdC1uYXRpdmUpLlxuICAgICAqL1xuICAgIG9ubHlFbmFibGVEZXZpY2VXaXRoQU5FPzogYm9vbGVhbjtcbiAgfVxuICBleHBvcnQgaW50ZXJmYWNlIE5uYXBpRXhlY3V0aW9uUHJvdmlkZXJPcHRpb24gZXh0ZW5kcyBFeGVjdXRpb25Qcm92aWRlck9wdGlvbiB7XG4gICAgcmVhZG9ubHkgbmFtZTogJ25uYXBpJztcbiAgICB1c2VGUDE2PzogYm9vbGVhbjtcbiAgICB1c2VOQ0hXPzogYm9vbGVhbjtcbiAgICBjcHVEaXNhYmxlZD86IGJvb2xlYW47XG4gICAgY3B1T25seT86IGJvb2xlYW47XG4gIH1cbiAgLy8gI2VuZHJlZ2lvblxuXG4gIC8vICNlbmRyZWdpb25cblxuICAvLyAjcmVnaW9uIHJ1biBvcHRpb25zXG5cbiAgLyoqXG4gICAqIEEgc2V0IG9mIGNvbmZpZ3VyYXRpb25zIGZvciBpbmZlcmVuY2UgcnVuIGJlaGF2aW9yXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFJ1bk9wdGlvbnMge1xuICAgIC8qKlxuICAgICAqIExvZyBzZXZlcml0eSBsZXZlbC4gU2VlXG4gICAgICogaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9vbm54cnVudGltZS9ibG9iL21haW4vaW5jbHVkZS9vbm54cnVudGltZS9jb3JlL2NvbW1vbi9sb2dnaW5nL3NldmVyaXR5LmhcbiAgICAgKlxuICAgICAqIFRoaXMgc2V0dGluZyBpcyBhdmFpbGFibGUgb25seSBpbiBPTk5YUnVudGltZSAoTm9kZS5qcyBiaW5kaW5nIGFuZCByZWFjdC1uYXRpdmUpIG9yIFdlYkFzc2VtYmx5IGJhY2tlbmRcbiAgICAgKi9cbiAgICBsb2dTZXZlcml0eUxldmVsPzogMHwxfDJ8M3w0O1xuXG4gICAgLyoqXG4gICAgICogTG9nIHZlcmJvc2l0eSBsZXZlbC5cbiAgICAgKlxuICAgICAqIFRoaXMgc2V0dGluZyBpcyBhdmFpbGFibGUgb25seSBpbiBXZWJBc3NlbWJseSBiYWNrZW5kLiBXaWxsIHN1cHBvcnQgTm9kZS5qcyBiaW5kaW5nIGFuZCByZWFjdC1uYXRpdmUgbGF0ZXJcbiAgICAgKi9cbiAgICBsb2dWZXJib3NpdHlMZXZlbD86IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIFRlcm1pbmF0ZSBhbGwgaW5jb21wbGV0ZSBPcnRSdW4gY2FsbHMgYXMgc29vbiBhcyBwb3NzaWJsZSBpZiB0cnVlXG4gICAgICpcbiAgICAgKiBUaGlzIHNldHRpbmcgaXMgYXZhaWxhYmxlIG9ubHkgaW4gV2ViQXNzZW1ibHkgYmFja2VuZC4gV2lsbCBzdXBwb3J0IE5vZGUuanMgYmluZGluZyBhbmQgcmVhY3QtbmF0aXZlIGxhdGVyXG4gICAgICovXG4gICAgdGVybWluYXRlPzogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIEEgdGFnIGZvciB0aGUgUnVuKCkgY2FsbHMgdXNpbmcgdGhpc1xuICAgICAqXG4gICAgICogVGhpcyBzZXR0aW5nIGlzIGF2YWlsYWJsZSBvbmx5IGluIE9OTlhSdW50aW1lIChOb2RlLmpzIGJpbmRpbmcgYW5kIHJlYWN0LW5hdGl2ZSkgb3IgV2ViQXNzZW1ibHkgYmFja2VuZFxuICAgICAqL1xuICAgIHRhZz86IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFNldCBhIHNpbmdsZSBydW4gY29uZmlndXJhdGlvbiBlbnRyeS4gU2VlXG4gICAgICogaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9vbm54cnVudGltZS9ibG9iL21haW4vaW5jbHVkZS9vbm54cnVudGltZS9jb3JlL3Nlc3Npb24vXG4gICAgICogb25ueHJ1bnRpbWVfcnVuX29wdGlvbnNfY29uZmlnX2tleXMuaFxuICAgICAqXG4gICAgICogVGhpcyBzZXR0aW5nIGlzIGF2YWlsYWJsZSBvbmx5IGluIFdlYkFzc2VtYmx5IGJhY2tlbmQuIFdpbGwgc3VwcG9ydCBOb2RlLmpzIGJpbmRpbmcgYW5kIHJlYWN0LW5hdGl2ZSBsYXRlclxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGBgYGpzXG4gICAgICogZXh0cmE6IHtcbiAgICAgKiAgIG1lbW9yeToge1xuICAgICAqICAgICBlbmFibGVfbWVtb3J5X2FyZW5hX3Nocmlua2FnZTogXCIxXCIsXG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGV4dHJhPzogUmVjb3JkPHN0cmluZywgdW5rbm93bj47XG4gIH1cblxuICAvLyAjZW5kcmVnaW9uXG5cbiAgLy8gI3JlZ2lvbiB2YWx1ZSBtZXRhZGF0YVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZW1wdHktaW50ZXJmYWNlXG4gIGludGVyZmFjZSBWYWx1ZU1ldGFkYXRhIHtcbiAgICAvLyBUQkRcbiAgfVxuXG4gIC8vICNlbmRyZWdpb25cbn1cblxuLyoqXG4gKiBSZXByZXNlbnQgYSBydW50aW1lIGluc3RhbmNlIG9mIGFuIE9OTlggbW9kZWwuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSW5mZXJlbmNlU2Vzc2lvbiB7XG4gIC8vICNyZWdpb24gcnVuKClcblxuICAvKipcbiAgICogRXhlY3V0ZSB0aGUgbW9kZWwgYXN5bmNocm9ub3VzbHkgd2l0aCB0aGUgZ2l2ZW4gZmVlZHMgYW5kIG9wdGlvbnMuXG4gICAqXG4gICAqIEBwYXJhbSBmZWVkcyAtIFJlcHJlc2VudGF0aW9uIG9mIHRoZSBtb2RlbCBpbnB1dC4gU2VlIHR5cGUgZGVzY3JpcHRpb24gb2YgYEluZmVyZW5jZVNlc3Npb24uSW5wdXRUeXBlYCBmb3IgZGV0YWlsLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbmFsLiBBIHNldCBvZiBvcHRpb25zIHRoYXQgY29udHJvbHMgdGhlIGJlaGF2aW9yIG9mIG1vZGVsIGluZmVyZW5jZS5cbiAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBtYXAsIHdoaWNoIHVzZXMgb3V0cHV0IG5hbWVzIGFzIGtleXMgYW5kIE9ubnhWYWx1ZSBhcyBjb3JyZXNwb25kaW5nIHZhbHVlcy5cbiAgICovXG4gIHJ1bihmZWVkczogSW5mZXJlbmNlU2Vzc2lvbi5GZWVkc1R5cGUsIG9wdGlvbnM/OiBJbmZlcmVuY2VTZXNzaW9uLlJ1bk9wdGlvbnMpOiBQcm9taXNlPEluZmVyZW5jZVNlc3Npb24uUmV0dXJuVHlwZT47XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGUgdGhlIG1vZGVsIGFzeW5jaHJvbm91c2x5IHdpdGggdGhlIGdpdmVuIGZlZWRzLCBmZXRjaGVzIGFuZCBvcHRpb25zLlxuICAgKlxuICAgKiBAcGFyYW0gZmVlZHMgLSBSZXByZXNlbnRhdGlvbiBvZiB0aGUgbW9kZWwgaW5wdXQuIFNlZSB0eXBlIGRlc2NyaXB0aW9uIG9mIGBJbmZlcmVuY2VTZXNzaW9uLklucHV0VHlwZWAgZm9yIGRldGFpbC5cbiAgICogQHBhcmFtIGZldGNoZXMgLSBSZXByZXNlbnRhdGlvbiBvZiB0aGUgbW9kZWwgb3V0cHV0LiBTZWUgdHlwZSBkZXNjcmlwdGlvbiBvZiBgSW5mZXJlbmNlU2Vzc2lvbi5PdXRwdXRUeXBlYCBmb3JcbiAgICogZGV0YWlsLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbmFsLiBBIHNldCBvZiBvcHRpb25zIHRoYXQgY29udHJvbHMgdGhlIGJlaGF2aW9yIG9mIG1vZGVsIGluZmVyZW5jZS5cbiAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBtYXAsIHdoaWNoIHVzZXMgb3V0cHV0IG5hbWVzIGFzIGtleXMgYW5kIE9ubnhWYWx1ZSBhcyBjb3JyZXNwb25kaW5nIHZhbHVlcy5cbiAgICovXG4gIHJ1bihmZWVkczogSW5mZXJlbmNlU2Vzc2lvbi5GZWVkc1R5cGUsIGZldGNoZXM6IEluZmVyZW5jZVNlc3Npb24uRmV0Y2hlc1R5cGUsXG4gICAgICBvcHRpb25zPzogSW5mZXJlbmNlU2Vzc2lvbi5SdW5PcHRpb25zKTogUHJvbWlzZTxJbmZlcmVuY2VTZXNzaW9uLlJldHVyblR5cGU+O1xuXG4gIC8vICNlbmRyZWdpb25cblxuICAvLyAjcmVnaW9uIHJlbGVhc2UoKVxuXG4gIC8qKlxuICAgKiBSZWxlYXNlIHRoZSBpbmZlcmVuY2Ugc2Vzc2lvbiBhbmQgdGhlIHVuZGVybHlpbmcgcmVzb3VyY2VzLlxuICAgKi9cbiAgcmVsZWFzZSgpOiBQcm9taXNlPHZvaWQ+O1xuXG4gIC8vICNlbmRyZWdpb25cblxuICAvLyAjcmVnaW9uIHByb2ZpbGluZ1xuXG4gIC8qKlxuICAgKiBTdGFydCBwcm9maWxpbmcuXG4gICAqL1xuICBzdGFydFByb2ZpbGluZygpOiB2b2lkO1xuXG4gIC8qKlxuICAgKiBFbmQgcHJvZmlsaW5nLlxuICAgKi9cbiAgZW5kUHJvZmlsaW5nKCk6IHZvaWQ7XG5cbiAgLy8gI2VuZHJlZ2lvblxuXG4gIC8vICNyZWdpb24gbWV0YWRhdGFcblxuICAvKipcbiAgICogR2V0IGlucHV0IG5hbWVzIG9mIHRoZSBsb2FkZWQgbW9kZWwuXG4gICAqL1xuICByZWFkb25seSBpbnB1dE5hbWVzOiByZWFkb25seSBzdHJpbmdbXTtcblxuICAvKipcbiAgICogR2V0IG91dHB1dCBuYW1lcyBvZiB0aGUgbG9hZGVkIG1vZGVsLlxuICAgKi9cbiAgcmVhZG9ubHkgb3V0cHV0TmFtZXM6IHJlYWRvbmx5IHN0cmluZ1tdO1xuXG4gIC8vIC8qKlxuICAvLyAgKiBHZXQgaW5wdXQgbWV0YWRhdGEgb2YgdGhlIGxvYWRlZCBtb2RlbC5cbiAgLy8gICovXG4gIC8vIHJlYWRvbmx5IGlucHV0TWV0YWRhdGE6IFJlYWRvbmx5QXJyYXk8UmVhZG9ubHk8SW5mZXJlbmNlU2Vzc2lvbi5WYWx1ZU1ldGFkYXRhPj47XG5cbiAgLy8gLyoqXG4gIC8vICAqIEdldCBvdXRwdXQgbWV0YWRhdGEgb2YgdGhlIGxvYWRlZCBtb2RlbC5cbiAgLy8gICovXG4gIC8vIHJlYWRvbmx5IG91dHB1dE1ldGFkYXRhOiBSZWFkb25seUFycmF5PFJlYWRvbmx5PEluZmVyZW5jZVNlc3Npb24uVmFsdWVNZXRhZGF0YT4+O1xuXG4gIC8vICNlbmRyZWdpb25cbn1cblxuZXhwb3J0IGludGVyZmFjZSBJbmZlcmVuY2VTZXNzaW9uRmFjdG9yeSB7XG4gIC8vICNyZWdpb24gY3JlYXRlKClcblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGluZmVyZW5jZSBzZXNzaW9uIGFuZCBsb2FkIG1vZGVsIGFzeW5jaHJvbm91c2x5IGZyb20gYW4gT05OWCBtb2RlbCBmaWxlLlxuICAgKlxuICAgKiBAcGFyYW0gdXJpIC0gVGhlIFVSSSBvciBmaWxlIHBhdGggb2YgdGhlIG1vZGVsIHRvIGxvYWQuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gc3BlY2lmeSBjb25maWd1cmF0aW9uIGZvciBjcmVhdGluZyBhIG5ldyBpbmZlcmVuY2Ugc2Vzc2lvbi5cbiAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYW4gSW5mZXJlbmNlU2Vzc2lvbiBvYmplY3QuXG4gICAqL1xuICBjcmVhdGUodXJpOiBzdHJpbmcsIG9wdGlvbnM/OiBJbmZlcmVuY2VTZXNzaW9uLlNlc3Npb25PcHRpb25zKTogUHJvbWlzZTxJbmZlcmVuY2VTZXNzaW9uPjtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGluZmVyZW5jZSBzZXNzaW9uIGFuZCBsb2FkIG1vZGVsIGFzeW5jaHJvbm91c2x5IGZyb20gYW4gYXJyYXkgYnVmZXIuXG4gICAqXG4gICAqIEBwYXJhbSBidWZmZXIgLSBBbiBBcnJheUJ1ZmZlciByZXByZXNlbnRhdGlvbiBvZiBhbiBPTk5YIG1vZGVsLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIHNwZWNpZnkgY29uZmlndXJhdGlvbiBmb3IgY3JlYXRpbmcgYSBuZXcgaW5mZXJlbmNlIHNlc3Npb24uXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGFuIEluZmVyZW5jZVNlc3Npb24gb2JqZWN0LlxuICAgKi9cbiAgY3JlYXRlKGJ1ZmZlcjogQXJyYXlCdWZmZXJMaWtlLCBvcHRpb25zPzogSW5mZXJlbmNlU2Vzc2lvbi5TZXNzaW9uT3B0aW9ucyk6IFByb21pc2U8SW5mZXJlbmNlU2Vzc2lvbj47XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBpbmZlcmVuY2Ugc2Vzc2lvbiBhbmQgbG9hZCBtb2RlbCBhc3luY2hyb25vdXNseSBmcm9tIHNlZ21lbnQgb2YgYW4gYXJyYXkgYnVmZXIuXG4gICAqXG4gICAqIEBwYXJhbSBidWZmZXIgLSBBbiBBcnJheUJ1ZmZlciByZXByZXNlbnRhdGlvbiBvZiBhbiBPTk5YIG1vZGVsLlxuICAgKiBAcGFyYW0gYnl0ZU9mZnNldCAtIFRoZSBiZWdpbm5pbmcgb2YgdGhlIHNwZWNpZmllZCBwb3J0aW9uIG9mIHRoZSBhcnJheSBidWZmZXIuXG4gICAqIEBwYXJhbSBieXRlTGVuZ3RoIC0gVGhlIGxlbmd0aCBpbiBieXRlcyBvZiB0aGUgYXJyYXkgYnVmZmVyLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIHNwZWNpZnkgY29uZmlndXJhdGlvbiBmb3IgY3JlYXRpbmcgYSBuZXcgaW5mZXJlbmNlIHNlc3Npb24uXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGFuIEluZmVyZW5jZVNlc3Npb24gb2JqZWN0LlxuICAgKi9cbiAgY3JlYXRlKGJ1ZmZlcjogQXJyYXlCdWZmZXJMaWtlLCBieXRlT2Zmc2V0OiBudW1iZXIsIGJ5dGVMZW5ndGg/OiBudW1iZXIsIG9wdGlvbnM/OiBJbmZlcmVuY2VTZXNzaW9uLlNlc3Npb25PcHRpb25zKTpcbiAgICAgIFByb21pc2U8SW5mZXJlbmNlU2Vzc2lvbj47XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBpbmZlcmVuY2Ugc2Vzc2lvbiBhbmQgbG9hZCBtb2RlbCBhc3luY2hyb25vdXNseSBmcm9tIGEgVWludDhBcnJheS5cbiAgICpcbiAgICogQHBhcmFtIGJ1ZmZlciAtIEEgVWludDhBcnJheSByZXByZXNlbnRhdGlvbiBvZiBhbiBPTk5YIG1vZGVsLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIHNwZWNpZnkgY29uZmlndXJhdGlvbiBmb3IgY3JlYXRpbmcgYSBuZXcgaW5mZXJlbmNlIHNlc3Npb24uXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGFuIEluZmVyZW5jZVNlc3Npb24gb2JqZWN0LlxuICAgKi9cbiAgY3JlYXRlKGJ1ZmZlcjogVWludDhBcnJheSwgb3B0aW9ucz86IEluZmVyZW5jZVNlc3Npb24uU2Vzc2lvbk9wdGlvbnMpOiBQcm9taXNlPEluZmVyZW5jZVNlc3Npb24+O1xuXG4gIC8vICNlbmRyZWdpb25cbn1cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuZXhwb3J0IGNvbnN0IEluZmVyZW5jZVNlc3Npb246IEluZmVyZW5jZVNlc3Npb25GYWN0b3J5ID0gSW5mZXJlbmNlU2Vzc2lvbkltcGw7XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7T3B0aW9uc0Zvcm1hdCwgT3B0aW9uc05vcm1hbGl6YXRpb25QYXJhbWV0ZXJzLCBPcHRpb25zVGVuc29yTGF5b3V0fSBmcm9tICcuL3RlbnNvci1mYWN0b3J5LmpzJztcblxuZXhwb3J0IGludGVyZmFjZSBUZW5zb3JUb0RhdGFVcmxPcHRpb25zIGV4dGVuZHMgT3B0aW9uc1RlbnNvckxheW91dCwgT3B0aW9uc0Zvcm1hdCwgT3B0aW9uc05vcm1hbGl6YXRpb25QYXJhbWV0ZXJzIHt9XG5cbmV4cG9ydCBpbnRlcmZhY2UgVGVuc29yVG9JbWFnZURhdGFPcHRpb25zIGV4dGVuZHMgT3B0aW9uc1RlbnNvckxheW91dCwgT3B0aW9uc0Zvcm1hdCwgT3B0aW9uc05vcm1hbGl6YXRpb25QYXJhbWV0ZXJzIHt9XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29udmVyc2lvblV0aWxzIHtcbiAgLyoqXG4gICAqIGNyZWF0ZXMgYSBEYXRhVVJMIGluc3RhbmNlIGZyb20gdGVuc29yXG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gQW4gb3B0aW9uYWwgb2JqZWN0IHJlcHJlc2VudGluZyBvcHRpb25zIGZvciBjcmVhdGluZyBhIERhdGFVUkwgaW5zdGFuY2UgZnJvbSB0aGUgdGVuc29yLlxuICAgKlxuICAgKiBUaGUgZm9sbG93aW5nIGRlZmF1bHQgc2V0dGluZ3Mgd2lsbCBiZSBhcHBsaWVkOlxuICAgKiAtIGBmb3JtYXRgOiBgJ1JHQidgXG4gICAqIC0gYHRlbnNvckxheW91dGA6IGAnTkNIVydgXG4gICAqIEByZXR1cm5zIGEgRGF0YVVSTCBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBpbWFnZSBjb252ZXJ0ZWQgZnJvbSB0ZW5zb3IgZGF0YVxuICAgKi9cbiAgdG9EYXRhVVJMKG9wdGlvbnM/OiBUZW5zb3JUb0RhdGFVcmxPcHRpb25zKTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBjcmVhdGVzIGFuIEltYWdlRGF0YSBpbnN0YW5jZSBmcm9tIHRlbnNvclxuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFuIG9wdGlvbmFsIG9iamVjdCByZXByZXNlbnRpbmcgb3B0aW9ucyBmb3IgY3JlYXRpbmcgYW4gSW1hZ2VEYXRhIGluc3RhbmNlIGZyb20gdGhlIHRlbnNvci5cbiAgICpcbiAgICogVGhlIGZvbGxvd2luZyBkZWZhdWx0IHNldHRpbmdzIHdpbGwgYmUgYXBwbGllZDpcbiAgICogLSBgZm9ybWF0YDogYCdSR0InYFxuICAgKiAtIGB0ZW5zb3JMYXlvdXRgOiBgJ05DSFcnYFxuICAgKiBAcmV0dXJucyBhbiBJbWFnZURhdGEgaW5zdGFuY2UgcmVwcmVzZW50aW5nIHRoZSBpbWFnZSBjb252ZXJ0ZWQgZnJvbSB0ZW5zb3IgZGF0YVxuICAgKi9cbiAgdG9JbWFnZURhdGEob3B0aW9ucz86IFRlbnNvclRvSW1hZ2VEYXRhT3B0aW9ucyk6IEltYWdlRGF0YTtcbn1cbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtUZW5zb3IsIFR5cGVkVGVuc29yfSBmcm9tICcuL3RlbnNvci5qcyc7XG5cbmV4cG9ydCB0eXBlIEltYWdlRm9ybWF0ID0gJ1JHQid8J1JHQkEnfCdCR1InfCdSQkcnO1xuZXhwb3J0IHR5cGUgSW1hZ2VUZW5zb3JMYXlvdXQgPSAnTkhXQyd8J05DSFcnO1xuXG4vLyB0aGUgZm9sbG93aW5nIHJlZ2lvbiBjb250YWlucyB0eXBlIGRlZmluaXRpb25zIGZvciBjb25zdHJ1Y3RpbmcgdGVuc29yIGZyb20gYSBzcGVjaWZpYyBsb2NhdGlvbi5cblxuLy8gI3JlZ2lvbiB0eXBlcyBmb3IgY29uc3RydWN0aW5nIGEgdGVuc29yIGZyb20gYSBzcGVjaWZpYyBsb2NhdGlvblxuXG4vKipcbiAqIHJlcHJlc2VudCBjb21tb24gcHJvcGVydGllcyBvZiB0aGUgcGFyYW1ldGVyIGZvciBjb25zdHJ1Y3RpbmcgYSB0ZW5zb3IgZnJvbSBhIHNwZWNpZmljIGxvY2F0aW9uLlxuICovXG5pbnRlcmZhY2UgQ29tbW9uQ29uc3RydWN0b3JQYXJhbWV0ZXJzPFQ+IGV4dGVuZHMgUGljazxUZW5zb3IsICdkaW1zJz4ge1xuICAvKipcbiAgICogU3BlY2lmeSB0aGUgZGF0YSB0eXBlIG9mIHRoZSB0ZW5zb3IuXG4gICAqL1xuICByZWFkb25seSB0eXBlOiBUO1xufVxuXG4vKipcbiAqIHJlcHJlc2VudCB0aGUgcGFyYW1ldGVyIGZvciBjb25zdHJ1Y3RpbmcgYSB0ZW5zb3IgZnJvbSBhIEdQVSByZXNvdXJjZS5cbiAqL1xuaW50ZXJmYWNlIEdwdVJlc291cmNlQ29uc3RydWN0b3JQYXJhbWV0ZXJzPFQgZXh0ZW5kcyBUZW5zb3IuVHlwZT4ge1xuICAvKipcbiAgICogYW4gb3B0aW9uYWwgY2FsbGJhY2sgZnVuY3Rpb24gdG8gZG93bmxvYWQgZGF0YSBmcm9tIEdQVSB0byBDUFUuXG4gICAqXG4gICAqIElmIG5vdCBwcm92aWRlZCwgdGhlIHRlbnNvciB0cmVhdCB0aGUgR1BVIGRhdGEgYXMgZXh0ZXJuYWwgcmVzb3VyY2UuXG4gICAqL1xuICBkb3dubG9hZD8oKTogUHJvbWlzZTxUZW5zb3IuRGF0YVR5cGVNYXBbVF0+O1xuXG4gIC8qKlxuICAgKiBhbiBvcHRpb25hbCBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIHdoZW4gdGhlIHRlbnNvciBpcyBkaXNwb3NlZC5cbiAgICpcbiAgICogSWYgbm90IHByb3ZpZGVkLCB0aGUgdGVuc29yIHRyZWF0IHRoZSBHUFUgZGF0YSBhcyBleHRlcm5hbCByZXNvdXJjZS5cbiAgICovXG4gIGRpc3Bvc2U/KCk6IHZvaWQ7XG59XG5cbi8qKlxuICogcmVwcmVzZW50IHRoZSBwYXJhbWV0ZXIgZm9yIGNvbnN0cnVjdGluZyBhIHRlbnNvciBmcm9tIGEgcGlubmVkIENQVSBidWZmZXJcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDcHVQaW5uZWRDb25zdHJ1Y3RvclBhcmFtZXRlcnM8VCBleHRlbmRzIFRlbnNvci5DcHVQaW5uZWREYXRhVHlwZXMgPSBUZW5zb3IuQ3B1UGlubmVkRGF0YVR5cGVzPiBleHRlbmRzXG4gICAgQ29tbW9uQ29uc3RydWN0b3JQYXJhbWV0ZXJzPFQ+IHtcbiAgLyoqXG4gICAqIFNwZWNpZnkgdGhlIGxvY2F0aW9uIG9mIHRoZSBkYXRhIHRvIGJlICdjcHUtcGlubmVkJy5cbiAgICovXG4gIHJlYWRvbmx5IGxvY2F0aW9uOiAnY3B1LXBpbm5lZCc7XG4gIC8qKlxuICAgKiBTcGVjaWZ5IHRoZSBDUFUgcGlubmVkIGJ1ZmZlciB0aGF0IGhvbGRzIHRoZSB0ZW5zb3IgZGF0YS5cbiAgICovXG4gIHJlYWRvbmx5IGRhdGE6IFRlbnNvci5EYXRhVHlwZU1hcFtUXTtcbn1cblxuLyoqXG4gKiByZXByZXNlbnQgdGhlIHBhcmFtZXRlciBmb3IgY29uc3RydWN0aW5nIGEgdGVuc29yIGZyb20gYSBXZWJHTCB0ZXh0dXJlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVGV4dHVyZUNvbnN0cnVjdG9yUGFyYW1ldGVyczxUIGV4dGVuZHMgVGVuc29yLlRleHR1cmVEYXRhVHlwZXMgPSBUZW5zb3IuVGV4dHVyZURhdGFUeXBlcz4gZXh0ZW5kc1xuICAgIENvbW1vbkNvbnN0cnVjdG9yUGFyYW1ldGVyczxUPiwgR3B1UmVzb3VyY2VDb25zdHJ1Y3RvclBhcmFtZXRlcnM8VD4ge1xuICAvKipcbiAgICogU3BlY2lmeSB0aGUgbG9jYXRpb24gb2YgdGhlIGRhdGEgdG8gYmUgJ3RleHR1cmUnLlxuICAgKi9cbiAgcmVhZG9ubHkgbG9jYXRpb246ICd0ZXh0dXJlJztcbiAgLyoqXG4gICAqIFNwZWNpZnkgdGhlIFdlYkdMIHRleHR1cmUgdGhhdCBob2xkcyB0aGUgdGVuc29yIGRhdGEuXG4gICAqL1xuICByZWFkb25seSB0ZXh0dXJlOiBUZW5zb3IuVGV4dHVyZVR5cGU7XG59XG5cbi8qKlxuICogcmVwcmVzZW50IHRoZSBwYXJhbWV0ZXIgZm9yIGNvbnN0cnVjdGluZyBhIHRlbnNvciBmcm9tIGEgV2ViR1BVIGJ1ZmZlclxuICovXG5leHBvcnQgaW50ZXJmYWNlIEdwdUJ1ZmZlckNvbnN0cnVjdG9yUGFyYW1ldGVyczxUIGV4dGVuZHMgVGVuc29yLkdwdUJ1ZmZlckRhdGFUeXBlcyA9IFRlbnNvci5HcHVCdWZmZXJEYXRhVHlwZXM+IGV4dGVuZHNcbiAgICBDb21tb25Db25zdHJ1Y3RvclBhcmFtZXRlcnM8VD4sIEdwdVJlc291cmNlQ29uc3RydWN0b3JQYXJhbWV0ZXJzPFQ+IHtcbiAgLyoqXG4gICAqIFNwZWNpZnkgdGhlIGxvY2F0aW9uIG9mIHRoZSBkYXRhIHRvIGJlICdncHUtYnVmZmVyJy5cbiAgICovXG4gIHJlYWRvbmx5IGxvY2F0aW9uOiAnZ3B1LWJ1ZmZlcic7XG4gIC8qKlxuICAgKiBTcGVjaWZ5IHRoZSBXZWJHUFUgYnVmZmVyIHRoYXQgaG9sZHMgdGhlIHRlbnNvciBkYXRhLlxuICAgKi9cbiAgcmVhZG9ubHkgZ3B1QnVmZmVyOiBUZW5zb3IuR3B1QnVmZmVyVHlwZTtcbn1cblxuLy8gI2VuZHJlZ2lvblxuXG4vLyB0aGUgZm9sbG93aW5nIHJlZ2lvbiBjb250YWlucyB0eXBlIGRlZmluaXRpb25zIG9mIGVhY2ggaW5kaXZpZHVhbCBvcHRpb25zLlxuLy8gdGhlIHRlbnNvciBmYWN0b3J5IGZ1bmN0aW9ucyB1c2UgYSBjb21wb3NpdGlvbiBvZiB0aG9zZSBvcHRpb25zIGFzIHRoZSBwYXJhbWV0ZXIgdHlwZS5cblxuLy8gI3JlZ2lvbiBPcHRpb25zIGZpZWxkc1xuXG5leHBvcnQgaW50ZXJmYWNlIE9wdGlvbnNGb3JtYXQge1xuICAvKipcbiAgICogRGVzY3JpYmVzIHRoZSBpbWFnZSBmb3JtYXQgcmVwcmVzZW50ZWQgaW4gUkdCQSBjb2xvciBzcGFjZS5cbiAgICovXG4gIGZvcm1hdD86IEltYWdlRm9ybWF0O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE9wdGlvbnNUZW5zb3JGb3JtYXQge1xuICAvKipcbiAgICogRGVzY3JpYmVzIHRoZSBpbWFnZSBmb3JtYXQgb2YgdGhlIHRlbnNvci5cbiAgICpcbiAgICogTk9URTogdGhpcyBpcyBkaWZmZXJlbnQgZnJvbSBvcHRpb24gJ2Zvcm1hdCcuIFdoaWxlIG9wdGlvbiAnZm9ybWF0JyByZXByZXNlbnRzIHRoZSBvcmlnaW5hbCBpbWFnZSwgJ3RlbnNvckZvcm1hdCdcbiAgICogcmVwcmVzZW50cyB0aGUgdGFyZ2V0IGZvcm1hdCBvZiB0aGUgdGVuc29yLiBBIHRyYW5zcG9zZSB3aWxsIGJlIHBlcmZvcm1lZCBpZiB0aGV5IGFyZSBkaWZmZXJlbnQuXG4gICAqL1xuICB0ZW5zb3JGb3JtYXQ/OiBJbWFnZUZvcm1hdDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBPcHRpb25zVGVuc29yRGF0YVR5cGUge1xuICAvKipcbiAgICogRGVzY3JpYmVzIHRoZSBkYXRhIHR5cGUgb2YgdGhlIHRlbnNvci5cbiAgICovXG4gIGRhdGFUeXBlPzogJ2Zsb2F0MzInfCd1aW50OCc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgT3B0aW9uc1RlbnNvckxheW91dCB7XG4gIC8qKlxuICAgKiBEZXNjcmliZXMgdGhlIHRlbnNvciBsYXlvdXQgd2hlbiByZXByZXNlbnRpbmcgZGF0YSBvZiBvbmUgb3IgbW9yZSBpbWFnZShzKS5cbiAgICovXG4gIHRlbnNvckxheW91dD86IEltYWdlVGVuc29yTGF5b3V0O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE9wdGlvbnNEaW1lbnNpb25zIHtcbiAgLyoqXG4gICAqIERlc2NyaWJlcyB0aGUgaW1hZ2UgaGVpZ2h0IGluIHBpeGVsXG4gICAqL1xuICBoZWlnaHQ/OiBudW1iZXI7XG4gIC8qKlxuICAgKiBEZXNjcmliZXMgdGhlIGltYWdlIHdpZHRoIGluIHBpeGVsXG4gICAqL1xuICB3aWR0aD86IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBPcHRpb25SZXNpemVkRGltZW5zaW9ucyB7XG4gIC8qKlxuICAgKiBEZXNjcmliZXMgdGhlIHJlc2l6ZWQgaGVpZ2h0LiBJZiBvbWl0dGVkLCBvcmlnaW5hbCBoZWlnaHQgd2lsbCBiZSB1c2VkLlxuICAgKi9cbiAgcmVzaXplZEhlaWdodD86IG51bWJlcjtcbiAgLyoqXG4gICAqIERlc2NyaWJlcyByZXNpemVkIHdpZHRoIC0gY2FuIGJlIGFjY2Vzc2VkIHZpYSB0ZW5zb3IgZGltZW5zaW9ucyBhcyB3ZWxsXG4gICAqL1xuICByZXNpemVkV2lkdGg/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgT3B0aW9uc05vcm1hbGl6YXRpb25QYXJhbWV0ZXJzIHtcbiAgLyoqXG4gICAqIERlc2NyaWJlcyBub3JtYWxpemF0aW9uIHBhcmFtZXRlcnMgd2hlbiBwcmVwcm9jZXNzaW5nIHRoZSBpbWFnZSBhcyBtb2RlbCBpbnB1dC5cbiAgICpcbiAgICogRGF0YSBlbGVtZW50IGFyZSByYW5nZWQgZnJvbSAwIHRvIDI1NS5cbiAgICovXG4gIG5vcm0/OiB7XG4gICAgLyoqXG4gICAgICogVGhlICdiaWFzJyB2YWx1ZSBmb3IgaW1hZ2Ugbm9ybWFsaXphdGlvbi5cbiAgICAgKiAtIElmIG9taXR0ZWQsIHVzZSBkZWZhdWx0IHZhbHVlIDAuXG4gICAgICogLSBJZiBpdCdzIGEgc2luZ2xlIG51bWJlciwgYXBwbHkgdG8gZWFjaCBjaGFubmVsXG4gICAgICogLSBJZiBpdCdzIGFuIGFycmF5IG9mIDMgb3IgNCBudW1iZXJzLCBhcHBseSBlbGVtZW50LXdpc2UuIE51bWJlciBvZiBlbGVtZW50cyBuZWVkIHRvIG1hdGNoIHRoZSBudW1iZXIgb2YgY2hhbm5lbHNcbiAgICAgKiBmb3IgdGhlIGNvcnJlc3BvbmRpbmcgaW1hZ2UgZm9ybWF0XG4gICAgICovXG4gICAgYmlhcz86IG51bWJlcnxbbnVtYmVyLCBudW1iZXIsIG51bWJlcl18W251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl07XG4gICAgLyoqXG4gICAgICogVGhlICdtZWFuJyB2YWx1ZSBmb3IgaW1hZ2Ugbm9ybWFsaXphdGlvbi5cbiAgICAgKiAtIElmIG9taXR0ZWQsIHVzZSBkZWZhdWx0IHZhbHVlIDI1NS5cbiAgICAgKiAtIElmIGl0J3MgYSBzaW5nbGUgbnVtYmVyLCBhcHBseSB0byBlYWNoIGNoYW5uZWxcbiAgICAgKiAtIElmIGl0J3MgYW4gYXJyYXkgb2YgMyBvciA0IG51bWJlcnMsIGFwcGx5IGVsZW1lbnQtd2lzZS4gTnVtYmVyIG9mIGVsZW1lbnRzIG5lZWQgdG8gbWF0Y2ggdGhlIG51bWJlciBvZiBjaGFubmVsc1xuICAgICAqIGZvciB0aGUgY29ycmVzcG9uZGluZyBpbWFnZSBmb3JtYXRcbiAgICAgKi9cbiAgICBtZWFuPzogbnVtYmVyIHwgW251bWJlciwgbnVtYmVyLCBudW1iZXJdIHwgW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl07XG4gIH07XG59XG5cbi8vICNlbmRyZWdpb25cblxuLy8gI3JlZ2lvbiBPcHRpb25zIGNvbXBvc2l0aW9uXG5cbmV4cG9ydCBpbnRlcmZhY2UgVGVuc29yRnJvbUltYWdlRGF0YU9wdGlvbnMgZXh0ZW5kcyBPcHRpb25SZXNpemVkRGltZW5zaW9ucywgT3B0aW9uc1RlbnNvckZvcm1hdCwgT3B0aW9uc1RlbnNvckxheW91dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPcHRpb25zVGVuc29yRGF0YVR5cGUsIE9wdGlvbnNOb3JtYWxpemF0aW9uUGFyYW1ldGVycyB7fVxuXG5leHBvcnQgaW50ZXJmYWNlIFRlbnNvckZyb21JbWFnZUVsZW1lbnRPcHRpb25zIGV4dGVuZHMgT3B0aW9uUmVzaXplZERpbWVuc2lvbnMsIE9wdGlvbnNUZW5zb3JGb3JtYXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT3B0aW9uc1RlbnNvckxheW91dCwgT3B0aW9uc1RlbnNvckRhdGFUeXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9wdGlvbnNOb3JtYWxpemF0aW9uUGFyYW1ldGVycyB7fVxuXG5leHBvcnQgaW50ZXJmYWNlIFRlbnNvckZyb21VcmxPcHRpb25zIGV4dGVuZHMgT3B0aW9uc0RpbWVuc2lvbnMsIE9wdGlvblJlc2l6ZWREaW1lbnNpb25zLCBPcHRpb25zVGVuc29yRm9ybWF0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9wdGlvbnNUZW5zb3JMYXlvdXQsIE9wdGlvbnNUZW5zb3JEYXRhVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPcHRpb25zTm9ybWFsaXphdGlvblBhcmFtZXRlcnMge31cblxuZXhwb3J0IGludGVyZmFjZSBUZW5zb3JGcm9tSW1hZ2VCaXRtYXBPcHRpb25zIGV4dGVuZHMgT3B0aW9uUmVzaXplZERpbWVuc2lvbnMsIE9wdGlvbnNUZW5zb3JGb3JtYXQsIE9wdGlvbnNUZW5zb3JMYXlvdXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPcHRpb25zVGVuc29yRGF0YVR5cGUsIE9wdGlvbnNOb3JtYWxpemF0aW9uUGFyYW1ldGVycyB7fVxuXG5leHBvcnQgaW50ZXJmYWNlIFRlbnNvckZyb21UZXh0dXJlT3B0aW9uczxUIGV4dGVuZHMgVGVuc29yLlRleHR1cmVEYXRhVHlwZXM+IGV4dGVuZHNcbiAgICBSZXF1aXJlZDxPcHRpb25zRGltZW5zaW9ucz4sIE9wdGlvbnNGb3JtYXQsIEdwdVJlc291cmNlQ29uc3RydWN0b3JQYXJhbWV0ZXJzPFQ+LyogVE9ETzogYWRkIG1vcmUgKi8ge31cblxuZXhwb3J0IGludGVyZmFjZSBUZW5zb3JGcm9tR3B1QnVmZmVyT3B0aW9uczxUIGV4dGVuZHMgVGVuc29yLkdwdUJ1ZmZlckRhdGFUeXBlcz4gZXh0ZW5kc1xuICAgIFBpY2s8VGVuc29yLCAnZGltcyc+LCBHcHVSZXNvdXJjZUNvbnN0cnVjdG9yUGFyYW1ldGVyczxUPiB7XG4gIC8qKlxuICAgKiBEZXNjcmliZXMgdGhlIGRhdGEgdHlwZSBvZiB0aGUgdGVuc29yLlxuICAgKi9cbiAgZGF0YVR5cGU/OiBUO1xufVxuXG4vLyAjZW5kcmVnaW9uXG5cbi8qKlxuICogdHlwZSBUZW5zb3JGYWN0b3J5IGRlZmluZXMgdGhlIGZhY3RvcnkgZnVuY3Rpb25zIG9mICdUZW5zb3InIHRvIGNyZWF0ZSB0ZW5zb3IgaW5zdGFuY2VzIGZyb20gZXhpc3RpbmcgZGF0YSBvclxuICogcmVzb3VyY2VzLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFRlbnNvckZhY3Rvcnkge1xuICAvKipcbiAgICogY3JlYXRlIGEgdGVuc29yIGZyb20gYW4gSW1hZ2VEYXRhIG9iamVjdFxuICAgKlxuICAgKiBAcGFyYW0gaW1hZ2VEYXRhIC0gdGhlIEltYWdlRGF0YSBvYmplY3QgdG8gY3JlYXRlIHRlbnNvciBmcm9tXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gQW4gb3B0aW9uYWwgb2JqZWN0IHJlcHJlc2VudGluZyBvcHRpb25zIGZvciBjcmVhdGluZyB0ZW5zb3IgZnJvbSBJbWFnZURhdGEuXG4gICAqXG4gICAqIFRoZSBmb2xsb3dpbmcgZGVmYXVsdCBzZXR0aW5ncyB3aWxsIGJlIGFwcGxpZWQ6XG4gICAqIC0gYHRlbnNvckZvcm1hdGA6IGAnUkdCJ2BcbiAgICogLSBgdGVuc29yTGF5b3V0YDogYCdOQ0hXJ2BcbiAgICogLSBgZGF0YVR5cGVgOiBgJ2Zsb2F0MzInYFxuICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIHRlbnNvciBvYmplY3RcbiAgICovXG4gIGZyb21JbWFnZShpbWFnZURhdGE6IEltYWdlRGF0YSwgb3B0aW9ucz86IFRlbnNvckZyb21JbWFnZURhdGFPcHRpb25zKTpcbiAgICAgIFByb21pc2U8VHlwZWRUZW5zb3I8J2Zsb2F0MzInPnxUeXBlZFRlbnNvcjwndWludDgnPj47XG5cbiAgLyoqXG4gICAqIGNyZWF0ZSBhIHRlbnNvciBmcm9tIGEgSFRNTEltYWdlRWxlbWVudCBvYmplY3RcbiAgICpcbiAgICogQHBhcmFtIGltYWdlRWxlbWVudCAtIHRoZSBIVE1MSW1hZ2VFbGVtZW50IG9iamVjdCB0byBjcmVhdGUgdGVuc29yIGZyb21cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBBbiBvcHRpb25hbCBvYmplY3QgcmVwcmVzZW50aW5nIG9wdGlvbnMgZm9yIGNyZWF0aW5nIHRlbnNvciBmcm9tIEhUTUxJbWFnZUVsZW1lbnQuXG4gICAqXG4gICAqIFRoZSBmb2xsb3dpbmcgZGVmYXVsdCBzZXR0aW5ncyB3aWxsIGJlIGFwcGxpZWQ6XG4gICAqIC0gYHRlbnNvckZvcm1hdGA6IGAnUkdCJ2BcbiAgICogLSBgdGVuc29yTGF5b3V0YDogYCdOQ0hXJ2BcbiAgICogLSBgZGF0YVR5cGVgOiBgJ2Zsb2F0MzInYFxuICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIHRlbnNvciBvYmplY3RcbiAgICovXG4gIGZyb21JbWFnZShpbWFnZUVsZW1lbnQ6IEhUTUxJbWFnZUVsZW1lbnQsIG9wdGlvbnM/OiBUZW5zb3JGcm9tSW1hZ2VFbGVtZW50T3B0aW9ucyk6XG4gICAgICBQcm9taXNlPFR5cGVkVGVuc29yPCdmbG9hdDMyJz58VHlwZWRUZW5zb3I8J3VpbnQ4Jz4+O1xuXG4gIC8qKlxuICAgKiBjcmVhdGUgYSB0ZW5zb3IgZnJvbSBVUkxcbiAgICpcbiAgICogQHBhcmFtIHVybFNvdXJjZSAtIGEgc3RyaW5nIGFzIGEgVVJMIHRvIHRoZSBpbWFnZSBvciBhIGRhdGEgVVJMIGNvbnRhaW5pbmcgdGhlIGltYWdlIGRhdGEuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gQW4gb3B0aW9uYWwgb2JqZWN0IHJlcHJlc2VudGluZyBvcHRpb25zIGZvciBjcmVhdGluZyB0ZW5zb3IgZnJvbSBVUkwuXG4gICAqXG4gICAqIFRoZSBmb2xsb3dpbmcgZGVmYXVsdCBzZXR0aW5ncyB3aWxsIGJlIGFwcGxpZWQ6XG4gICAqIC0gYHRlbnNvckZvcm1hdGA6IGAnUkdCJ2BcbiAgICogLSBgdGVuc29yTGF5b3V0YDogYCdOQ0hXJ2BcbiAgICogLSBgZGF0YVR5cGVgOiBgJ2Zsb2F0MzInYFxuICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIHRlbnNvciBvYmplY3RcbiAgICovXG4gIGZyb21JbWFnZSh1cmxTb3VyY2U6IHN0cmluZywgb3B0aW9ucz86IFRlbnNvckZyb21VcmxPcHRpb25zKTogUHJvbWlzZTxUeXBlZFRlbnNvcjwnZmxvYXQzMic+fFR5cGVkVGVuc29yPCd1aW50OCc+PjtcblxuICAvKipcbiAgICogY3JlYXRlIGEgdGVuc29yIGZyb20gYW4gSW1hZ2VCaXRtYXAgb2JqZWN0XG4gICAqXG4gICAqIEBwYXJhbSBiaXRtYXAgLSB0aGUgSW1hZ2VCaXRtYXAgb2JqZWN0IHRvIGNyZWF0ZSB0ZW5zb3IgZnJvbVxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFuIG9wdGlvbmFsIG9iamVjdCByZXByZXNlbnRpbmcgb3B0aW9ucyBmb3IgY3JlYXRpbmcgdGVuc29yIGZyb20gVVJMLlxuICAgKlxuICAgKiBUaGUgZm9sbG93aW5nIGRlZmF1bHQgc2V0dGluZ3Mgd2lsbCBiZSBhcHBsaWVkOlxuICAgKiAtIGB0ZW5zb3JGb3JtYXRgOiBgJ1JHQidgXG4gICAqIC0gYHRlbnNvckxheW91dGA6IGAnTkNIVydgXG4gICAqIC0gYGRhdGFUeXBlYDogYCdmbG9hdDMyJ2BcbiAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSB0ZW5zb3Igb2JqZWN0XG4gICAqL1xuICBmcm9tSW1hZ2UoYml0bWFwOiBJbWFnZUJpdG1hcCwgb3B0aW9uczogVGVuc29yRnJvbUltYWdlQml0bWFwT3B0aW9ucyk6XG4gICAgICBQcm9taXNlPFR5cGVkVGVuc29yPCdmbG9hdDMyJz58VHlwZWRUZW5zb3I8J3VpbnQ4Jz4+O1xuXG4gIC8qKlxuICAgKiBjcmVhdGUgYSB0ZW5zb3IgZnJvbSBhIFdlYkdMIHRleHR1cmVcbiAgICpcbiAgICogQHBhcmFtIHRleHR1cmUgLSB0aGUgV2ViR0xUZXh0dXJlIG9iamVjdCB0byBjcmVhdGUgdGVuc29yIGZyb21cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBBbiBvcHRpb25hbCBvYmplY3QgcmVwcmVzZW50aW5nIG9wdGlvbnMgZm9yIGNyZWF0aW5nIHRlbnNvciBmcm9tIFdlYkdMIHRleHR1cmUuXG4gICAqXG4gICAqIFRoZSBvcHRpb25zIGluY2x1ZGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAqIC0gYHdpZHRoYDogdGhlIHdpZHRoIG9mIHRoZSB0ZXh0dXJlLiBSZXF1aXJlZC5cbiAgICogLSBgaGVpZ2h0YDogdGhlIGhlaWdodCBvZiB0aGUgdGV4dHVyZS4gUmVxdWlyZWQuXG4gICAqIC0gYGZvcm1hdGA6IHRoZSBmb3JtYXQgb2YgdGhlIHRleHR1cmUuIElmIG9taXR0ZWQsIGFzc3VtZSAnUkdCQScuXG4gICAqIC0gYGRvd25sb2FkYDogYW4gb3B0aW9uYWwgZnVuY3Rpb24gdG8gZG93bmxvYWQgdGhlIHRlbnNvciBkYXRhIGZyb20gR1BVIHRvIENQVS4gSWYgb21pdHRlZCwgdGhlIEdQVSBkYXRhXG4gICAqIHdpbGwgbm90IGJlIGFibGUgdG8gZG93bmxvYWQuIFVzdWFsbHksIHRoaXMgaXMgcHJvdmlkZWQgYnkgYSBHUFUgYmFja2VuZCBmb3IgdGhlIGluZmVyZW5jZSBvdXRwdXRzLiBVc2VycyBkb24ndFxuICAgKiBuZWVkIHRvIHByb3ZpZGUgdGhpcyBmdW5jdGlvbi5cbiAgICogLSBgZGlzcG9zZWA6IGFuIG9wdGlvbmFsIGZ1bmN0aW9uIHRvIGRpc3Bvc2UgdGhlIHRlbnNvciBkYXRhIG9uIEdQVS4gSWYgb21pdHRlZCwgdGhlIEdQVSBkYXRhIHdpbGwgbm90IGJlIGRpc3Bvc2VkLlxuICAgKiBVc3VhbGx5LCB0aGlzIGlzIHByb3ZpZGVkIGJ5IGEgR1BVIGJhY2tlbmQgZm9yIHRoZSBpbmZlcmVuY2Ugb3V0cHV0cy4gVXNlcnMgZG9uJ3QgbmVlZCB0byBwcm92aWRlIHRoaXMgZnVuY3Rpb24uXG4gICAqXG4gICAqIEByZXR1cm5zIGEgdGVuc29yIG9iamVjdFxuICAgKi9cbiAgZnJvbVRleHR1cmU8VCBleHRlbmRzIFRlbnNvci5UZXh0dXJlRGF0YVR5cGVzID0gJ2Zsb2F0MzInPihcbiAgICAgIHRleHR1cmU6IFRlbnNvci5UZXh0dXJlVHlwZSwgb3B0aW9uczogVGVuc29yRnJvbVRleHR1cmVPcHRpb25zPFQ+KTogVHlwZWRUZW5zb3I8J2Zsb2F0MzInPjtcblxuICAvKipcbiAgICogY3JlYXRlIGEgdGVuc29yIGZyb20gYSBXZWJHUFUgYnVmZmVyXG4gICAqXG4gICAqIEBwYXJhbSBidWZmZXIgLSB0aGUgR1BVQnVmZmVyIG9iamVjdCB0byBjcmVhdGUgdGVuc29yIGZyb21cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBBbiBvcHRpb25hbCBvYmplY3QgcmVwcmVzZW50aW5nIG9wdGlvbnMgZm9yIGNyZWF0aW5nIHRlbnNvciBmcm9tIFdlYkdQVSBidWZmZXIuXG4gICAqXG4gICAqIFRoZSBvcHRpb25zIGluY2x1ZGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAqIC0gYGRhdGFUeXBlYDogdGhlIGRhdGEgdHlwZSBvZiB0aGUgdGVuc29yLiBJZiBvbWl0dGVkLCBhc3N1bWUgJ2Zsb2F0MzInLlxuICAgKiAtIGBkaW1zYDogdGhlIGRpbWVuc2lvbiBvZiB0aGUgdGVuc29yLiBSZXF1aXJlZC5cbiAgICogLSBgZG93bmxvYWRgOiBhbiBvcHRpb25hbCBmdW5jdGlvbiB0byBkb3dubG9hZCB0aGUgdGVuc29yIGRhdGEgZnJvbSBHUFUgdG8gQ1BVLiBJZiBvbWl0dGVkLCB0aGUgR1BVIGRhdGFcbiAgICogd2lsbCBub3QgYmUgYWJsZSB0byBkb3dubG9hZC4gVXN1YWxseSwgdGhpcyBpcyBwcm92aWRlZCBieSBhIEdQVSBiYWNrZW5kIGZvciB0aGUgaW5mZXJlbmNlIG91dHB1dHMuIFVzZXJzIGRvbid0XG4gICAqIG5lZWQgdG8gcHJvdmlkZSB0aGlzIGZ1bmN0aW9uLlxuICAgKiAtIGBkaXNwb3NlYDogYW4gb3B0aW9uYWwgZnVuY3Rpb24gdG8gZGlzcG9zZSB0aGUgdGVuc29yIGRhdGEgb24gR1BVLiBJZiBvbWl0dGVkLCB0aGUgR1BVIGRhdGEgd2lsbCBub3QgYmUgZGlzcG9zZWQuXG4gICAqIFVzdWFsbHksIHRoaXMgaXMgcHJvdmlkZWQgYnkgYSBHUFUgYmFja2VuZCBmb3IgdGhlIGluZmVyZW5jZSBvdXRwdXRzLiBVc2VycyBkb24ndCBuZWVkIHRvIHByb3ZpZGUgdGhpcyBmdW5jdGlvbi5cbiAgICpcbiAgICogQHJldHVybnMgYSB0ZW5zb3Igb2JqZWN0XG4gICAqL1xuICBmcm9tR3B1QnVmZmVyPFQgZXh0ZW5kcyBUZW5zb3IuR3B1QnVmZmVyRGF0YVR5cGVzPihcbiAgICAgIGJ1ZmZlcjogVGVuc29yLkdwdUJ1ZmZlclR5cGUsIG9wdGlvbnM6IFRlbnNvckZyb21HcHVCdWZmZXJPcHRpb25zPFQ+KTogVHlwZWRUZW5zb3I8VD47XG5cbiAgLyoqXG4gICAqIGNyZWF0ZSBhIHRlbnNvciBmcm9tIGEgcHJlLWFsbG9jYXRlZCBidWZmZXIuIFRoZSBidWZmZXIgd2lsbCBiZSB1c2VkIGFzIGEgcGlubmVkIGJ1ZmZlci5cbiAgICpcbiAgICogQHBhcmFtIHR5cGUgLSB0aGUgdGVuc29yIGVsZW1lbnQgdHlwZS5cbiAgICogQHBhcmFtIGJ1ZmZlciAtIGEgVHlwZWRBcnJheSBjb3JyZXNwb25kaW5nIHRvIHRoZSB0eXBlLlxuICAgKiBAcGFyYW0gZGltcyAtIHNwZWNpZnkgdGhlIGRpbWVuc2lvbiBvZiB0aGUgdGVuc29yLiBJZiBvbWl0dGVkLCBhIDEtRCB0ZW5zb3IgaXMgYXNzdW1lZC5cbiAgICpcbiAgICogQHJldHVybnMgYSB0ZW5zb3Igb2JqZWN0XG4gICAqL1xuICBmcm9tUGlubmVkQnVmZmVyPFQgZXh0ZW5kcyBFeGNsdWRlPFRlbnNvci5UeXBlLCAnc3RyaW5nJz4+KFxuICAgICAgdHlwZTogVCwgYnVmZmVyOiBUZW5zb3IuRGF0YVR5cGVNYXBbVF0sIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSk6IFR5cGVkVGVuc29yPFQ+O1xufVxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG4vKipcbiAqIEEgc3RyaW5nIHRoYXQgcmVwcmVzZW50cyBhIGZpbGUncyBVUkwgb3IgcGF0aC5cbiAqXG4gKiBQYXRoIGlzIHZhaWxhYmxlIG9ubHkgaW4gb25ueHJ1bnRpbWUtbm9kZSBvciBvbm54cnVudGltZS13ZWIgcnVubmluZyBpbiBOb2RlLmpzLlxuICovXG5leHBvcnQgdHlwZSBGaWxlVXJsT3JQYXRoID0gc3RyaW5nO1xuXG4vKipcbiAqIEEgQmxvYiBvYmplY3QgdGhhdCByZXByZXNlbnRzIGEgZmlsZS5cbiAqL1xuZXhwb3J0IHR5cGUgRmlsZUJsb2IgPSBCbG9iO1xuXG4vKipcbiAqIEEgVWludDhBcnJheSwgQXJyYXlCdWZmZXIgb3IgU2hhcmVkQXJyYXlCdWZmZXIgb2JqZWN0IHRoYXQgcmVwcmVzZW50cyBhIGZpbGUgY29udGVudC5cbiAqXG4gKiBXaGVuIGl0IGlzIGFuIEFycmF5QnVmZmVyIG9yIFNoYXJlZEFycmF5QnVmZmVyLCB0aGUgd2hvbGUgYnVmZmVyIGlzIGFzc3VtZWQgdG8gYmUgdGhlIGZpbGUgY29udGVudC5cbiAqL1xuZXhwb3J0IHR5cGUgRmlsZURhdGEgPSBVaW50OEFycmF5fEFycmF5QnVmZmVyTGlrZTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgZmlsZSB0aGF0IGNhbiBiZSBsb2FkZWQgYnkgdGhlIE9OTlggUnVudGltZSBKYXZhU2NyaXB0IEFQSS5cbiAqL1xuZXhwb3J0IHR5cGUgRmlsZVR5cGUgPSBGaWxlVXJsT3JQYXRofEZpbGVCbG9ifEZpbGVEYXRhO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYW4gZXh0ZXJuYWwgZGF0YSBmaWxlLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEV4dGVybmFsRGF0YUZpbGVEZXNjcmlwdGlvbiB7XG4gIC8qKlxuICAgKiBTcGVjaWZ5IHRoZSBleHRlcm5hbCBkYXRhIGZpbGUuXG4gICAqL1xuICBkYXRhOiBGaWxlVHlwZTtcbiAgLyoqXG4gICAqIFNwZWNpZnkgdGhlIGZpbGUgcGF0aC5cbiAgICovXG4gIHBhdGg6IHN0cmluZztcbn1cblxuLyoqXG4gKiBSZXByZXNlbnRzIGFuIGV4dGVybmFsIGRhdGEgZmlsZS5cbiAqXG4gKiBXaGVuIHVzaW5nIGEgc3RyaW5nLCBpdCBzaG91bGQgYmUgYSBmaWxlIFVSTCBvciBwYXRoIHRoYXQgaW4gdGhlIHNhbWUgZGlyZWN0b3J5IGFzIHRoZSBtb2RlbCBmaWxlLlxuICovXG5leHBvcnQgdHlwZSBFeHRlcm5hbERhdGFGaWxlVHlwZSA9IEV4dGVybmFsRGF0YUZpbGVEZXNjcmlwdGlvbnxGaWxlVXJsT3JQYXRoO1xuXG4vKipcbiAqIE9wdGlvbnMgZm9yIG1vZGVsIGxvYWRpbmcuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgT25ueE1vZGVsT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBTcGVjaWZ5aW5nIGEgbGlzdCBvZiBmaWxlcyB0aGF0IHJlcHJlc2VudHMgdGhlIGV4dGVybmFsIGRhdGEuXG4gICAqL1xuICBleHRlcm5hbERhdGE/OiByZWFkb25seSBFeHRlcm5hbERhdGFGaWxlVHlwZVtdO1xufVxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi90ZW5zb3IuanMnO1xuXG5leHBvcnQgdHlwZSBOb25UZW5zb3JUeXBlID0gbmV2ZXI7XG5cbi8qKlxuICogVHlwZSBPbm54VmFsdWUgUmVwcmVzZW50cyBib3RoIHRlbnNvcnMgYW5kIG5vbi10ZW5zb3JzIHZhbHVlIGZvciBtb2RlbCdzIGlucHV0cy9vdXRwdXRzLlxuICpcbiAqIE5PVEU6IGN1cnJlbnRseSBub3Qgc3VwcG9ydCBub24tdGVuc29yXG4gKi9cbmV4cG9ydCB0eXBlIE9ubnhWYWx1ZSA9IFRlbnNvcnxOb25UZW5zb3JUeXBlO1xuXG4vKipcbiAqIFR5cGUgT25ueFZhbHVlRGF0YUxvY2F0aW9uIHJlcHJlc2VudHMgdGhlIGxvY2F0aW9uIG9mIHRoZSBkYXRhIG9mIGFuIE9ubnhWYWx1ZS5cbiAqL1xuZXhwb3J0IHR5cGUgT25ueFZhbHVlRGF0YUxvY2F0aW9uID0gVGVuc29yLkRhdGFMb2NhdGlvbjtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtyZXNvbHZlQmFja2VuZEFuZEV4ZWN1dGlvblByb3ZpZGVyc30gZnJvbSAnLi9iYWNrZW5kLWltcGwuanMnO1xuaW1wb3J0IHtTZXNzaW9uSGFuZGxlciwgVHJhaW5pbmdTZXNzaW9uSGFuZGxlcn0gZnJvbSAnLi9iYWNrZW5kLmpzJztcbmltcG9ydCB7SW5mZXJlbmNlU2Vzc2lvbiBhcyBJbmZlcmVuY2VTZXNzaW9ufSBmcm9tICcuL2luZmVyZW5jZS1zZXNzaW9uLmpzJztcbmltcG9ydCB7T25ueFZhbHVlfSBmcm9tICcuL29ubngtdmFsdWUuanMnO1xuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4vdGVuc29yLmpzJztcbmltcG9ydCB7VHJhaW5pbmdTZXNzaW9uIGFzIFRyYWluaW5nU2Vzc2lvbkludGVyZmFjZSwgVHJhaW5pbmdTZXNzaW9uQ3JlYXRlT3B0aW9uc30gZnJvbSAnLi90cmFpbmluZy1zZXNzaW9uLmpzJztcblxudHlwZSBTZXNzaW9uT3B0aW9ucyA9IEluZmVyZW5jZVNlc3Npb24uU2Vzc2lvbk9wdGlvbnM7XG50eXBlIEZlZWRzVHlwZSA9IEluZmVyZW5jZVNlc3Npb24uRmVlZHNUeXBlO1xudHlwZSBGZXRjaGVzVHlwZSA9IEluZmVyZW5jZVNlc3Npb24uRmV0Y2hlc1R5cGU7XG50eXBlIFJldHVyblR5cGUgPSBJbmZlcmVuY2VTZXNzaW9uLlJldHVyblR5cGU7XG50eXBlIFJ1bk9wdGlvbnMgPSBJbmZlcmVuY2VTZXNzaW9uLlJ1bk9wdGlvbnM7XG5cbmNvbnN0IG5vQmFja2VuZEVyck1zZzogc3RyaW5nID0gJ1RyYWluaW5nIGJhY2tlbmQgY291bGQgbm90IGJlIHJlc29sdmVkLiAnICtcbiAgICAnTWFrZSBzdXJlIHlvdVxcJ3JlIHVzaW5nIHRoZSBjb3JyZWN0IGNvbmZpZ3VyYXRpb24gJiBXZWJBc3NlbWJseSBmaWxlcy4nO1xuXG5leHBvcnQgY2xhc3MgVHJhaW5pbmdTZXNzaW9uIGltcGxlbWVudHMgVHJhaW5pbmdTZXNzaW9uSW50ZXJmYWNlIHtcbiAgcHJpdmF0ZSBjb25zdHJ1Y3RvcihoYW5kbGVyOiBUcmFpbmluZ1Nlc3Npb25IYW5kbGVyLCBoYXNPcHRpbWl6ZXJNb2RlbDogYm9vbGVhbiwgaGFzRXZhbE1vZGVsOiBib29sZWFuKSB7XG4gICAgdGhpcy5oYW5kbGVyID0gaGFuZGxlcjtcbiAgICB0aGlzLmhhc09wdGltaXplck1vZGVsID0gaGFzT3B0aW1pemVyTW9kZWw7XG4gICAgdGhpcy5oYXNFdmFsTW9kZWwgPSBoYXNFdmFsTW9kZWw7XG4gIH1cbiAgcHJpdmF0ZSBoYW5kbGVyOiBUcmFpbmluZ1Nlc3Npb25IYW5kbGVyO1xuICBwcml2YXRlIGhhc09wdGltaXplck1vZGVsOiBib29sZWFuO1xuICBwcml2YXRlIGhhc0V2YWxNb2RlbDogYm9vbGVhbjtcblxuICBnZXQgdHJhaW5pbmdJbnB1dE5hbWVzKCk6IHJlYWRvbmx5IHN0cmluZ1tdIHtcbiAgICByZXR1cm4gdGhpcy5oYW5kbGVyLmlucHV0TmFtZXM7XG4gIH1cbiAgZ2V0IHRyYWluaW5nT3V0cHV0TmFtZXMoKTogcmVhZG9ubHkgc3RyaW5nW10ge1xuICAgIHJldHVybiB0aGlzLmhhbmRsZXIub3V0cHV0TmFtZXM7XG4gIH1cblxuICBnZXQgZXZhbElucHV0TmFtZXMoKTogcmVhZG9ubHkgc3RyaW5nW10ge1xuICAgIGlmICh0aGlzLmhhc0V2YWxNb2RlbCkge1xuICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlci5ldmFsSW5wdXROYW1lcztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIHRyYWluaW5nIHNlc3Npb24gaGFzIG5vIGV2YWxNb2RlbCBsb2FkZWQuJyk7XG4gICAgfVxuICB9XG4gIGdldCBldmFsT3V0cHV0TmFtZXMoKTogcmVhZG9ubHkgc3RyaW5nW10ge1xuICAgIGlmICh0aGlzLmhhc0V2YWxNb2RlbCkge1xuICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlci5ldmFsT3V0cHV0TmFtZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyB0cmFpbmluZyBzZXNzaW9uIGhhcyBubyBldmFsTW9kZWwgbG9hZGVkLicpO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBhc3luYyBjcmVhdGUodHJhaW5pbmdPcHRpb25zOiBUcmFpbmluZ1Nlc3Npb25DcmVhdGVPcHRpb25zLCBzZXNzaW9uT3B0aW9ucz86IFNlc3Npb25PcHRpb25zKTpcbiAgICAgIFByb21pc2U8VHJhaW5pbmdTZXNzaW9uPiB7XG4gICAgY29uc3QgZXZhbE1vZGVsOiBzdHJpbmd8VWludDhBcnJheSA9IHRyYWluaW5nT3B0aW9ucy5ldmFsTW9kZWwgfHwgJyc7XG4gICAgY29uc3Qgb3B0aW1pemVyTW9kZWw6IHN0cmluZ3xVaW50OEFycmF5ID0gdHJhaW5pbmdPcHRpb25zLm9wdGltaXplck1vZGVsIHx8ICcnO1xuICAgIGNvbnN0IG9wdGlvbnM6IFNlc3Npb25PcHRpb25zID0gc2Vzc2lvbk9wdGlvbnMgfHwge307XG5cbiAgICAvLyByZXNvbHZlIGJhY2tlbmQsIHVwZGF0ZSBzZXNzaW9uIG9wdGlvbnMgd2l0aCB2YWxpZGF0ZWQgRVBzLCBhbmQgY3JlYXRlIHNlc3Npb24gaGFuZGxlclxuICAgIGNvbnN0IFtiYWNrZW5kLCBvcHRpb25zV2l0aFZhbGlkYXRlZEVQc10gPSBhd2FpdCByZXNvbHZlQmFja2VuZEFuZEV4ZWN1dGlvblByb3ZpZGVycyhvcHRpb25zKTtcbiAgICBpZiAoYmFja2VuZC5jcmVhdGVUcmFpbmluZ1Nlc3Npb25IYW5kbGVyKSB7XG4gICAgICBjb25zdCBoYW5kbGVyID0gYXdhaXQgYmFja2VuZC5jcmVhdGVUcmFpbmluZ1Nlc3Npb25IYW5kbGVyKFxuICAgICAgICAgIHRyYWluaW5nT3B0aW9ucy5jaGVja3BvaW50U3RhdGUsIHRyYWluaW5nT3B0aW9ucy50cmFpbk1vZGVsLCBldmFsTW9kZWwsIG9wdGltaXplck1vZGVsLFxuICAgICAgICAgIG9wdGlvbnNXaXRoVmFsaWRhdGVkRVBzKTtcbiAgICAgIHJldHVybiBuZXcgVHJhaW5pbmdTZXNzaW9uKGhhbmRsZXIsICEhdHJhaW5pbmdPcHRpb25zLm9wdGltaXplck1vZGVsLCAhIXRyYWluaW5nT3B0aW9ucy5ldmFsTW9kZWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3Iobm9CYWNrZW5kRXJyTXNnKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSGVscGVyIGZ1bmN0aW9uIGZvciBydW5UcmFpblN0ZXAgYW5kIGZ1dHVyZSBydW5TdGVwIG1ldGhvZHMgdGhhdCBoYW5kbGVzIHRoZSB0eXBlLW5hcnJvd2luZyBjb252ZXJzaW9uIGZyb21cbiAgICogdGhlIGdpdmVuIHBhcmFtZXRlcnMgdG8gU2Vzc2lvbkhhbmRsZXIuRmV0Y2hlc1R5cGUgYW5kIFJ1bk9wdGlvbnMuXG4gICAqXG4gICAqIEBwYXJhbSBpbnB1dE5hbWVzIHRoZSBmZWVkcyBvYmplY3QgaXMgY2hlY2tlZCB0aGF0IHRoZXkgY29udGFpbiBhbGwgaW5wdXQgbmFtZXMgaW4gdGhlIHByb3ZpZGVkIGxpc3Qgb2YgaW5wdXRcbiAgICogbmFtZXMuXG4gICAqIEBwYXJhbSBvdXRwdXROYW1lcyB0aGUgZmV0Y2hlcyBvYmplY3QgaXMgY2hlY2tlZCB0aGF0IHRoZWlyIGtleXMgbWF0Y2ggdXAgd2l0aCB2YWxpZCBuYW1lcyBpbiB0aGUgbGlzdCBvZiBvdXRwdXRcbiAgICogbmFtZXMuXG4gICAqIEBwYXJhbSBmZWVkcyB0aGUgcmVxdWlyZWQgaW5wdXRcbiAgICogQHBhcmFtIGFyZzEgbmFycm93ZWQgJiBjb252ZXJ0ZWQgaW50byB0aGUgU2Vzc2lvbkhhbmRsZXIuRmV0Y2hlc1R5cGUgb3IgUnVuT3B0aW9ucyBvYmplY3RcbiAgICogQHBhcmFtIGFyZzIgb3B0aW9uYWwgUnVuT3B0aW9ucyBvYmplY3QuXG4gICAqIEByZXR1cm5zXG4gICAqL1xuICB0eXBlTmFycm93aW5nRm9yUnVuU3RlcChcbiAgICAgIGlucHV0TmFtZXM6IHJlYWRvbmx5IHN0cmluZ1tdLCBvdXRwdXROYW1lczogcmVhZG9ubHkgc3RyaW5nW10sIGZlZWRzOiBGZWVkc1R5cGUsIGFyZzE/OiBGZXRjaGVzVHlwZXxSdW5PcHRpb25zLFxuICAgICAgYXJnMj86IFJ1bk9wdGlvbnMpOiBbU2Vzc2lvbkhhbmRsZXIuRmV0Y2hlc1R5cGUsIFJ1bk9wdGlvbnNdIHtcbiAgICBjb25zdCBmZXRjaGVzOiB7W25hbWU6IHN0cmluZ106IE9ubnhWYWx1ZXxudWxsfSA9IHt9O1xuICAgIGxldCBvcHRpb25zOiBSdW5PcHRpb25zID0ge307XG4gICAgLy8gY2hlY2sgaW5wdXRzXG4gICAgaWYgKHR5cGVvZiBmZWVkcyAhPT0gJ29iamVjdCcgfHwgZmVlZHMgPT09IG51bGwgfHwgZmVlZHMgaW5zdGFuY2VvZiBUZW5zb3IgfHwgQXJyYXkuaXNBcnJheShmZWVkcykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgJ1xcJ2ZlZWRzXFwnIG11c3QgYmUgYW4gb2JqZWN0IHRoYXQgdXNlIGlucHV0IG5hbWVzIGFzIGtleXMgYW5kIE9ubnhWYWx1ZSBhcyBjb3JyZXNwb25kaW5nIHZhbHVlcy4nKTtcbiAgICB9XG5cbiAgICBsZXQgaXNGZXRjaGVzRW1wdHkgPSB0cnVlO1xuICAgIC8vIGRldGVybWluZSB3aGljaCBvdmVycmlkZSBpcyBiZWluZyB1c2VkXG4gICAgaWYgKHR5cGVvZiBhcmcxID09PSAnb2JqZWN0Jykge1xuICAgICAgaWYgKGFyZzEgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5leHBlY3RlZCBhcmd1bWVudFsxXTogY2Fubm90IGJlIG51bGwuJyk7XG4gICAgICB9XG4gICAgICBpZiAoYXJnMSBpbnN0YW5jZW9mIFRlbnNvcikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcXCdmZXRjaGVzXFwnIGNhbm5vdCBiZSBhIFRlbnNvcicpO1xuICAgICAgfVxuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShhcmcxKSkge1xuICAgICAgICBpZiAoYXJnMS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcXCdmZXRjaGVzXFwnIGNhbm5vdCBiZSBhbiBlbXB0eSBhcnJheS4nKTtcbiAgICAgICAgfVxuICAgICAgICBpc0ZldGNoZXNFbXB0eSA9IGZhbHNlO1xuICAgICAgICAvLyBvdXRwdXQgbmFtZXNcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIG9mIGFyZzEpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcXCdmZXRjaGVzXFwnIG11c3QgYmUgYSBzdHJpbmcgYXJyYXkgb3IgYW4gb2JqZWN0LicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob3V0cHV0TmFtZXMuaW5kZXhPZihuYW1lKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGAnZmV0Y2hlcycgY29udGFpbnMgaW52YWxpZCBvdXRwdXQgbmFtZTogJHtuYW1lfS5gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZmV0Y2hlc1tuYW1lXSA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGFyZzIgPT09ICdvYmplY3QnICYmIGFyZzIgIT09IG51bGwpIHtcbiAgICAgICAgICBvcHRpb25zID0gYXJnMjtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYXJnMiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcXCdvcHRpb25zXFwnIG11c3QgYmUgYW4gb2JqZWN0LicpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkZWNpZGUgd2hldGhlciBhcmcxIGlzIGZldGNoZXMgb3Igb3B0aW9uc1xuICAgICAgICAvLyBpZiBhbnkgb3V0cHV0IG5hbWUgaXMgcHJlc2VudCBhbmQgaXRzIHZhbHVlIGlzIHZhbGlkIE9ubnhWYWx1ZSwgd2UgY29uc2lkZXIgaXQgZmV0Y2hlc1xuICAgICAgICBsZXQgaXNGZXRjaGVzID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IGFyZzFLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYXJnMSk7XG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBvZiBvdXRwdXROYW1lcykge1xuICAgICAgICAgIGlmIChhcmcxS2V5cy5pbmRleE9mKG5hbWUpICE9PSAtMSkge1xuICAgICAgICAgICAgY29uc3QgdiA9IChhcmcxIGFzIEluZmVyZW5jZVNlc3Npb24uTnVsbGFibGVPbm54VmFsdWVNYXBUeXBlKVtuYW1lXTtcbiAgICAgICAgICAgIGlmICh2ID09PSBudWxsIHx8IHYgaW5zdGFuY2VvZiBUZW5zb3IpIHtcbiAgICAgICAgICAgICAgaXNGZXRjaGVzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgaXNGZXRjaGVzRW1wdHkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgZmV0Y2hlc1tuYW1lXSA9IHY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzRmV0Y2hlcykge1xuICAgICAgICAgIGlmICh0eXBlb2YgYXJnMiA9PT0gJ29iamVjdCcgJiYgYXJnMiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgb3B0aW9ucyA9IGFyZzI7XG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYXJnMiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1xcJ29wdGlvbnNcXCcgbXVzdCBiZSBhbiBvYmplY3QuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9wdGlvbnMgPSBhcmcxIGFzIFJ1bk9wdGlvbnM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcmcxICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5leHBlY3RlZCBhcmd1bWVudFsxXTogbXVzdCBiZSBcXCdmZXRjaGVzXFwnIG9yIFxcJ29wdGlvbnNcXCcuJyk7XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgaWYgYWxsIGlucHV0cyBhcmUgaW4gZmVlZFxuICAgIGZvciAoY29uc3QgbmFtZSBvZiBpbnB1dE5hbWVzKSB7XG4gICAgICBpZiAodHlwZW9mIGZlZWRzW25hbWVdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGlucHV0ICcke25hbWV9JyBpcyBtaXNzaW5nIGluICdmZWVkcycuYCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gaWYgbm8gZmV0Y2hlcyBpcyBzcGVjaWZpZWQsIHdlIHVzZSB0aGUgZnVsbCBvdXRwdXQgbmFtZXMgbGlzdFxuICAgIGlmIChpc0ZldGNoZXNFbXB0eSkge1xuICAgICAgZm9yIChjb25zdCBuYW1lIG9mIG91dHB1dE5hbWVzKSB7XG4gICAgICAgIGZldGNoZXNbbmFtZV0gPSBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBbZmV0Y2hlcywgb3B0aW9uc107XG4gIH1cblxuICAvKipcbiAgICogSGVscGVyIG1ldGhvZCBmb3IgcnVuVHJhaW5TdGVwIGFuZCBhbnkgb3RoZXIgcnVuU3RlcCBtZXRob2RzLiBUYWtlcyB0aGUgUmV0dXJuVHlwZSByZXN1bHQgZnJvbSB0aGUgU2Vzc2lvbkhhbmRsZXJcbiAgICogYW5kIGNoYW5nZXMgaXQgaW50byBhIG1hcCBvZiBUZW5zb3JzLlxuICAgKlxuICAgKiBAcGFyYW0gcmVzdWx0c1xuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgY29udmVydEhhbmRsZXJSZXR1cm5UeXBlVG9NYXBPZlRlbnNvcnMocmVzdWx0czogU2Vzc2lvbkhhbmRsZXIuUmV0dXJuVHlwZSk6IFJldHVyblR5cGUge1xuICAgIGNvbnN0IHJldHVyblZhbHVlOiB7W25hbWU6IHN0cmluZ106IE9ubnhWYWx1ZX0gPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiByZXN1bHRzKSB7XG4gICAgICBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwocmVzdWx0cywga2V5KSkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSByZXN1bHRzW2tleV07XG4gICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBUZW5zb3IpIHtcbiAgICAgICAgICByZXR1cm5WYWx1ZVtrZXldID0gcmVzdWx0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVyblZhbHVlW2tleV0gPSBuZXcgVGVuc29yKHJlc3VsdC50eXBlLCByZXN1bHQuZGF0YSwgcmVzdWx0LmRpbXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgfVxuXG4gIGFzeW5jIGxhenlSZXNldEdyYWQoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgYXdhaXQgdGhpcy5oYW5kbGVyLmxhenlSZXNldEdyYWQoKTtcbiAgfVxuXG4gIHJ1blRyYWluU3RlcChmZWVkczogRmVlZHNUeXBlLCBvcHRpb25zPzogUnVuT3B0aW9ucyk6IFByb21pc2U8UmV0dXJuVHlwZT47XG4gIHJ1blRyYWluU3RlcChmZWVkczogRmVlZHNUeXBlLCBmZXRjaGVzOiBGZXRjaGVzVHlwZSwgb3B0aW9ucz86IFJ1bk9wdGlvbnMpOiBQcm9taXNlPFJldHVyblR5cGU+O1xuICBhc3luYyBydW5UcmFpblN0ZXAoZmVlZHM6IEZlZWRzVHlwZSwgYXJnMT86IEZldGNoZXNUeXBlfFJ1bk9wdGlvbnMsIGFyZzI/OiBSdW5PcHRpb25zKTogUHJvbWlzZTxSZXR1cm5UeXBlPiB7XG4gICAgY29uc3QgW2ZldGNoZXMsIG9wdGlvbnNdID1cbiAgICAgICAgdGhpcy50eXBlTmFycm93aW5nRm9yUnVuU3RlcCh0aGlzLnRyYWluaW5nSW5wdXROYW1lcywgdGhpcy50cmFpbmluZ091dHB1dE5hbWVzLCBmZWVkcywgYXJnMSwgYXJnMik7XG4gICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IHRoaXMuaGFuZGxlci5ydW5UcmFpblN0ZXAoZmVlZHMsIGZldGNoZXMsIG9wdGlvbnMpO1xuICAgIHJldHVybiB0aGlzLmNvbnZlcnRIYW5kbGVyUmV0dXJuVHlwZVRvTWFwT2ZUZW5zb3JzKHJlc3VsdHMpO1xuICB9XG5cbiAgYXN5bmMgcnVuT3B0aW1pemVyU3RlcChvcHRpb25zPzogSW5mZXJlbmNlU2Vzc2lvbi5SdW5PcHRpb25zfHVuZGVmaW5lZCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmICh0aGlzLmhhc09wdGltaXplck1vZGVsKSB7XG4gICAgICBhd2FpdCB0aGlzLmhhbmRsZXIucnVuT3B0aW1pemVyU3RlcChvcHRpb25zIHx8IHt9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIFRyYWluaW5nU2Vzc2lvbiBoYXMgbm8gT3B0aW1pemVyTW9kZWwgbG9hZGVkLicpO1xuICAgIH1cbiAgfVxuXG4gIHJ1bkV2YWxTdGVwKGZlZWRzOiBGZWVkc1R5cGUsIG9wdGlvbnM/OiBSdW5PcHRpb25zfHVuZGVmaW5lZCk6IFByb21pc2U8UmV0dXJuVHlwZT47XG4gIHJ1bkV2YWxTdGVwKGZlZWRzOiBGZWVkc1R5cGUsIGZldGNoZXM6IEZldGNoZXNUeXBlLCBvcHRpb25zPzogUnVuT3B0aW9uc3x1bmRlZmluZWQpOiBQcm9taXNlPFJldHVyblR5cGU+O1xuICBhc3luYyBydW5FdmFsU3RlcChmZWVkczogRmVlZHNUeXBlLCBhcmcxPzogRmV0Y2hlc1R5cGV8UnVuT3B0aW9ucywgYXJnMj86IFJ1bk9wdGlvbnMpOiBQcm9taXNlPFJldHVyblR5cGU+IHtcbiAgICBpZiAodGhpcy5oYXNFdmFsTW9kZWwpIHtcbiAgICAgIGNvbnN0IFtmZXRjaGVzLCBvcHRpb25zXSA9XG4gICAgICAgICAgdGhpcy50eXBlTmFycm93aW5nRm9yUnVuU3RlcCh0aGlzLmV2YWxJbnB1dE5hbWVzLCB0aGlzLmV2YWxPdXRwdXROYW1lcywgZmVlZHMsIGFyZzEsIGFyZzIpO1xuICAgICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IHRoaXMuaGFuZGxlci5ydW5FdmFsU3RlcChmZWVkcywgZmV0Y2hlcywgb3B0aW9ucyk7XG4gICAgICByZXR1cm4gdGhpcy5jb252ZXJ0SGFuZGxlclJldHVyblR5cGVUb01hcE9mVGVuc29ycyhyZXN1bHRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIFRyYWluaW5nU2Vzc2lvbiBoYXMgbm8gRXZhbE1vZGVsIGxvYWRlZC4nKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBnZXRQYXJhbWV0ZXJzU2l6ZSh0cmFpbmFibGVPbmx5ID0gdHJ1ZSk6IFByb21pc2U8bnVtYmVyPiB7XG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlci5nZXRQYXJhbWV0ZXJzU2l6ZSh0cmFpbmFibGVPbmx5KTtcbiAgfVxuXG4gIGFzeW5jIGxvYWRQYXJhbWV0ZXJzQnVmZmVyKGFycmF5OiBVaW50OEFycmF5LCB0cmFpbmFibGVPbmx5ID0gdHJ1ZSk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IHBhcmFtc1NpemUgPSBhd2FpdCB0aGlzLmdldFBhcmFtZXRlcnNTaXplKHRyYWluYWJsZU9ubHkpO1xuICAgIC8vIGNoZWNraW5nIHRoYXQgdGhlIHNpemUgb2YgdGhlIFVpbnQ4QXJyYXkgaXMgZXF1aXZhbGVudCB0byB0aGUgYnl0ZSBsZW5ndGggb2YgYSBGbG9hdDMyQXJyYXkgb2YgdGhlIG51bWJlclxuICAgIC8vIG9mIHBhcmFtZXRlcnNcbiAgICBpZiAoYXJyYXkubGVuZ3RoICE9PSA0ICogcGFyYW1zU2l6ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdTaXplIG9mIHRoZSBidWZmZXIgcGFzc2VkIGludG8gbG9hZFBhcmFtZXRlcnNCdWZmZXIgbXVzdCBtYXRjaCB0aGUgbnVtYmVyIG9mIHBhcmFtZXRlcnMgaW4gJyArXG4gICAgICAgICAgJ3RoZSBtb2RlbC4gUGxlYXNlIHVzZSBnZXRQYXJhbWV0ZXJzU2l6ZSBtZXRob2QgdG8gY2hlY2suJyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmhhbmRsZXIubG9hZFBhcmFtZXRlcnNCdWZmZXIoYXJyYXksIHRyYWluYWJsZU9ubHkpO1xuICB9XG5cbiAgYXN5bmMgZ2V0Q29udGlndW91c1BhcmFtZXRlcnModHJhaW5hYmxlT25seSA9IHRydWUpOiBQcm9taXNlPE9ubnhWYWx1ZT4ge1xuICAgIHJldHVybiB0aGlzLmhhbmRsZXIuZ2V0Q29udGlndW91c1BhcmFtZXRlcnModHJhaW5hYmxlT25seSk7XG4gIH1cblxuICBhc3luYyByZWxlYXNlKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIHJldHVybiB0aGlzLmhhbmRsZXIuZGlzcG9zZSgpO1xuICB9XG59XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7SW5mZXJlbmNlU2Vzc2lvbn0gZnJvbSAnLi9pbmZlcmVuY2Utc2Vzc2lvbi5qcyc7XG5pbXBvcnQge09ubnhWYWx1ZX0gZnJvbSAnLi9vbm54LXZhbHVlLmpzJztcbmltcG9ydCB7VHJhaW5pbmdTZXNzaW9uIGFzIFRyYWluaW5nU2Vzc2lvbkltcGx9IGZyb20gJy4vdHJhaW5pbmctc2Vzc2lvbi1pbXBsLmpzJztcblxuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXJlZGVjbGFyZSAqL1xuXG5leHBvcnQgZGVjbGFyZSBuYW1lc3BhY2UgVHJhaW5pbmdTZXNzaW9uIHtcbiAgLyoqXG4gICAqIEVpdGhlciBVUkkgZmlsZSBwYXRoIChzdHJpbmcpIG9yIFVpbnQ4QXJyYXkgY29udGFpbmluZyBtb2RlbCBvciBjaGVja3BvaW50IGluZm9ybWF0aW9uLlxuICAgKi9cbiAgdHlwZSBVcmlPckJ1ZmZlciA9IHN0cmluZ3xVaW50OEFycmF5O1xufVxuXG4vKipcbiAqIFJlcHJlc2VudCBhIHJ1bnRpbWUgaW5zdGFuY2Ugb2YgYW4gT05OWCB0cmFpbmluZyBzZXNzaW9uLFxuICogd2hpY2ggY29udGFpbnMgYSBtb2RlbCB0aGF0IGNhbiBiZSB0cmFpbmVkLCBhbmQsIG9wdGlvbmFsbHksXG4gKiBhbiBldmFsIGFuZCBvcHRpbWl6ZXIgbW9kZWwuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVHJhaW5pbmdTZXNzaW9uIHtcbiAgLy8gI3JlZ2lvbiBydW4oKVxuXG4gIC8qKlxuICAgKiBMYXppbHkgcmVzZXRzIHRoZSBncmFkaWVudHMgb2YgYWxsIHRyYWluYWJsZSBwYXJhbWV0ZXJzIHRvIHplcm8uIFNob3VsZCBoYXBwZW4gYWZ0ZXIgdGhlIGludm9jYXRpb24gb2ZcbiAgICogcnVuT3B0aW1pemVyU3RlcC5cbiAgICovXG4gIGxhenlSZXNldEdyYWQoKTogUHJvbWlzZTx2b2lkPjtcblxuICAvKipcbiAgICogUnVuIFRyYWluU3RlcCBhc3luY2hyb25vdXNseSB3aXRoIHRoZSBnaXZlbiBmZWVkcyBhbmQgb3B0aW9ucy5cbiAgICpcbiAgICogQHBhcmFtIGZlZWRzIC0gUmVwcmVzZW50YXRpb24gb2YgdGhlIG1vZGVsIGlucHV0LiBTZWUgdHlwZSBkZXNjcmlwdGlvbiBvZiBgSW5mZXJlbmNlU2Vzc2lvbi5JbnB1dFR5cGVgIGZvclxuICAgZGV0YWlsLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbmFsLiBBIHNldCBvZiBvcHRpb25zIHRoYXQgY29udHJvbHMgdGhlIGJlaGF2aW9yIG9mIG1vZGVsIHRyYWluaW5nLlxuICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIG1hcCwgd2hpY2ggdXNlcyBvdXRwdXQgbmFtZXMgYXMga2V5cyBhbmQgT25ueFZhbHVlIGFzIGNvcnJlc3BvbmRpbmcgdmFsdWVzLlxuICAgKi9cbiAgcnVuVHJhaW5TdGVwKGZlZWRzOiBJbmZlcmVuY2VTZXNzaW9uLkZlZWRzVHlwZSwgb3B0aW9ucz86IEluZmVyZW5jZVNlc3Npb24uUnVuT3B0aW9ucyk6XG4gICAgICBQcm9taXNlPEluZmVyZW5jZVNlc3Npb24uUmV0dXJuVHlwZT47XG5cbiAgLyoqXG4gICAqIFJ1biBhIHNpbmdsZSB0cmFpbiBzdGVwIHdpdGggdGhlIGdpdmVuIGlucHV0cyBhbmQgb3B0aW9ucy5cbiAgICpcbiAgICogQHBhcmFtIGZlZWRzIC0gUmVwcmVzZW50YXRpb24gb2YgdGhlIG1vZGVsIGlucHV0LlxuICAgKiBAcGFyYW0gZmV0Y2hlcyAtIFJlcHJlc2VudGF0aW9uIG9mIHRoZSBtb2RlbCBvdXRwdXQuXG4gICAqIGRldGFpbC5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25hbC4gQSBzZXQgb2Ygb3B0aW9ucyB0aGF0IGNvbnRyb2xzIHRoZSBiZWhhdmlvciBvZiBtb2RlbCB0cmFpbmluZy5cbiAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBtYXAsIHdoaWNoIHVzZXMgb3V0cHV0IG5hbWVzIGFzIGtleXMgYW5kIE9ubnhWYWx1ZSBhcyBjb3JyZXNwb25kaW5nXG4gICB2YWx1ZXMuXG4gICAqL1xuICBydW5UcmFpblN0ZXAoXG4gICAgICBmZWVkczogSW5mZXJlbmNlU2Vzc2lvbi5GZWVkc1R5cGUsIGZldGNoZXM6IEluZmVyZW5jZVNlc3Npb24uRmV0Y2hlc1R5cGUsXG4gICAgICBvcHRpb25zPzogSW5mZXJlbmNlU2Vzc2lvbi5SdW5PcHRpb25zKTogUHJvbWlzZTxJbmZlcmVuY2VTZXNzaW9uLlJldHVyblR5cGU+O1xuXG4gIC8qKlxuICAgKiBSdW5zIGEgc2luZ2xlIG9wdGltaXplciBzdGVwLCB3aGljaCBwZXJmb3JtcyB3ZWlnaHQgdXBkYXRlcyBmb3IgdGhlIHRyYWluYWJsZSBwYXJhbWV0ZXJzIHVzaW5nIHRoZSBvcHRpbWl6ZXIgbW9kZWwuXG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9uYWwuIEEgc2V0IG9mIG9wdGlvbnMgdGhhdCBjb250cm9scyB0aGUgYmVoYXZpb3Igb2YgbW9kZWwgb3B0aW1pemluZy5cbiAgICovXG4gIHJ1bk9wdGltaXplclN0ZXAob3B0aW9ucz86IEluZmVyZW5jZVNlc3Npb24uUnVuT3B0aW9ucyk6IFByb21pc2U8dm9pZD47XG5cbiAgLyoqXG4gICAqIFJ1biBhIHNpbmdsZSBldmFsIHN0ZXAgd2l0aCB0aGUgZ2l2ZW4gaW5wdXRzIGFuZCBvcHRpb25zIHVzaW5nIHRoZSBldmFsIG1vZGVsLlxuICAgKlxuICAgKiBAcGFyYW0gZmVlZHMgLSBSZXByZXNlbnRhdGlvbiBvZiB0aGUgbW9kZWwgaW5wdXQuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9uYWwuIEEgc2V0IG9mIG9wdGlvbnMgdGhhdCBjb250cm9scyB0aGUgYmVoYXZpb3Igb2YgbW9kZWwgZXZhbCBzdGVwLlxuICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIG1hcCwgd2hpY2ggdXNlcyBvdXRwdXQgbmFtZXMgYXMga2V5cyBhbmQgT25ueFZhbHVlIGFzIGNvcnJlc3BvbmRpbmdcbiAgIHZhbHVlcy5cbiAgICovXG4gIHJ1bkV2YWxTdGVwKGZlZWRzOiBJbmZlcmVuY2VTZXNzaW9uLkZlZWRzVHlwZSwgb3B0aW9ucz86IEluZmVyZW5jZVNlc3Npb24uUnVuT3B0aW9ucyk6XG4gICAgICBQcm9taXNlPEluZmVyZW5jZVNlc3Npb24uUmV0dXJuVHlwZT47XG5cbiAgLyoqXG4gICAqIFJ1biBhIHNpbmdsZSBldmFsIHN0ZXAgd2l0aCB0aGUgZ2l2ZW4gaW5wdXRzIGFuZCBvcHRpb25zIHVzaW5nIHRoZSBldmFsIG1vZGVsLlxuICAgKlxuICAgKiBAcGFyYW0gZmVlZHMgLSBSZXByZXNlbnRhdGlvbiBvZiB0aGUgbW9kZWwgaW5wdXQuXG4gICAqIEBwYXJhbSBmZXRjaGVzIC0gUmVwcmVzZW50YXRpb24gb2YgdGhlIG1vZGVsIG91dHB1dC5cbiAgICogZGV0YWlsLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbmFsLiBBIHNldCBvZiBvcHRpb25zIHRoYXQgY29udHJvbHMgdGhlIGJlaGF2aW9yIG9mIG1vZGVsIGV2YWwgc3RlcC5cbiAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBtYXAsIHdoaWNoIHVzZXMgb3V0cHV0IG5hbWVzIGFzIGtleXMgYW5kIE9ubnhWYWx1ZSBhcyBjb3JyZXNwb25kaW5nXG4gICB2YWx1ZXMuXG4gICAqL1xuICBydW5FdmFsU3RlcChcbiAgICAgIGZlZWRzOiBJbmZlcmVuY2VTZXNzaW9uLkZlZWRzVHlwZSwgZmV0Y2hlczogSW5mZXJlbmNlU2Vzc2lvbi5GZXRjaGVzVHlwZSxcbiAgICAgIG9wdGlvbnM/OiBJbmZlcmVuY2VTZXNzaW9uLlJ1bk9wdGlvbnMpOiBQcm9taXNlPEluZmVyZW5jZVNlc3Npb24uUmV0dXJuVHlwZT47XG5cbiAgLy8gI2VuZHJlZ2lvblxuXG4gIC8vICNyZWdpb24gY29weSBwYXJhbWV0ZXJzXG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyB0aGUgc2l6ZSBvZiBhbGwgcGFyYW1ldGVycyBmb3IgdGhlIHRyYWluaW5nIHN0YXRlLiBDYWxjdWxhdGVzIHRoZSB0b3RhbCBudW1iZXIgb2YgcHJpbWl0aXZlIChkYXRhdHlwZSBvZlxuICAgKiB0aGUgcGFyYW1ldGVycykgZWxlbWVudHMgb2YgYWxsIHRoZSBwYXJhbWV0ZXJzIGluIHRoZSB0cmFpbmluZyBzdGF0ZS5cbiAgICpcbiAgICogQHBhcmFtIHRyYWluYWJsZU9ubHkgLSBXaGVuIHNldCB0byB0cnVlLCB0aGUgc2l6ZSBpcyBjYWxjdWxhdGVkIGZvciB0cmFpbmFibGUgcGFyYW1zIG9ubHkuIERlZmF1bHQgdmFsdWUgaXMgdHJ1ZS5cbiAgICovXG4gIGdldFBhcmFtZXRlcnNTaXplKHRyYWluYWJsZU9ubHk6IGJvb2xlYW4pOiBQcm9taXNlPG51bWJlcj47XG5cbiAgLyoqXG4gICAqIENvcGllcyBwYXJhbWV0ZXIgdmFsdWVzIGZyb20gdGhlIGdpdmVuIGJ1ZmZlciB0byB0aGUgdHJhaW5pbmcgc3RhdGUuIEN1cnJlbnRseSwgb25seSBzdXBwb3J0aW5nIG1vZGVscyB3aXRoXG4gICAqIHBhcmFtZXRlcnMgb2YgdHlwZSBGbG9hdDMyLlxuICAgKlxuICAgKiBAcGFyYW0gYnVmZmVyIC0gQSBVaW50OEFycmF5IHJlcHJlc2VudGF0aW9uIG9mIEZsb2F0MzIgcGFyYW1ldGVycy5cbiAgICogQHBhcmFtIHRyYWluYWJsZU9ubHkgLSBUcnVlIGlmIHRyYWluYWJsZSBwYXJhbWV0ZXJzIG9ubHkgdG8gYmUgbW9kaWZpZWQsIGZhbHNlIG90aGVyd2lzZS4gRGVmYXVsdCB2YWx1ZSBpcyB0cnVlLlxuICAgKi9cbiAgbG9hZFBhcmFtZXRlcnNCdWZmZXIoYnVmZmVyOiBVaW50OEFycmF5LCB0cmFpbmFibGVPbmx5OiBib29sZWFuKTogUHJvbWlzZTx2b2lkPjtcblxuICAvKipcbiAgICogQ29waWVzIHRoZSBtb2RlbCBwYXJhbWV0ZXJzIHRvIGEgY29udGlndW91cyBidWZmZXIuIFVzdWFsbHkgdXNlZCBpbiB0aGUgY29udGV4dCBvZiBGZWRlcmF0ZWQgTGVhcm5pbmcuXG4gICAqIEN1cnJlbnRseSwgb25seSBzdXBwb3J0aW5nIG1vZGVscyB3aXRoIHBhcmFtZXRlcnMgb2YgdHlwZSBGbG9hdDMyLlxuICAgKlxuICAgKiBAcGFyYW0gdHJhaW5hYmxlT25seSAtIFdoZW4gc2V0IHRvIHRydWUsIG9ubHkgdHJhaW5hYmxlIHBhcmFtZXRlcnMgYXJlIGNvcGllZC4gVHJhaW5hYmxlIHBhcmFtZXRlcnMgYXJlIHBhcmFtZXRlcnNcbiAgICogZm9yIHdoaWNoIHJlcXVpcmVzX2dyYWQgaXMgc2V0IHRvIHRydWUuIERlZmF1bHQgdmFsdWUgaXMgdHJ1ZS5cbiAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBGbG9hdDMyIE9ubnhWYWx1ZSBvZiB0aGUgcmVxdWVzdGVkIHBhcmFtZXRlcnMuXG4gICAqL1xuICBnZXRDb250aWd1b3VzUGFyYW1ldGVycyh0cmFpbmFibGVPbmx5OiBib29sZWFuKTogUHJvbWlzZTxPbm54VmFsdWU+O1xuICAvLyAjZW5kcmVnaW9uXG5cbiAgLy8gI3JlZ2lvbiByZWxlYXNlKClcblxuICAvKipcbiAgICogUmVsZWFzZSB0aGUgaW5mZXJlbmNlIHNlc3Npb24gYW5kIHRoZSB1bmRlcmx5aW5nIHJlc291cmNlcy5cbiAgICovXG4gIHJlbGVhc2UoKTogUHJvbWlzZTx2b2lkPjtcbiAgLy8gI2VuZHJlZ2lvblxuXG4gIC8vICNyZWdpb24gbWV0YWRhdGFcblxuICAvKipcbiAgICogR2V0IGlucHV0IG5hbWVzIG9mIHRoZSBsb2FkZWQgdHJhaW5pbmcgbW9kZWwuXG4gICAqL1xuICByZWFkb25seSB0cmFpbmluZ0lucHV0TmFtZXM6IHJlYWRvbmx5IHN0cmluZ1tdO1xuXG4gIC8qKlxuICAgKiBHZXQgb3V0cHV0IG5hbWVzIG9mIHRoZSBsb2FkZWQgdHJhaW5pbmcgbW9kZWwuXG4gICAqL1xuICByZWFkb25seSB0cmFpbmluZ091dHB1dE5hbWVzOiByZWFkb25seSBzdHJpbmdbXTtcblxuICAvKipcbiAgICogR2V0IGlucHV0IG5hbWVzIG9mIHRoZSBsb2FkZWQgZXZhbCBtb2RlbC4gSXMgYW4gZW1wdHkgYXJyYXkgaWYgbm8gZXZhbCBtb2RlbCBpcyBsb2FkZWQuXG4gICAqL1xuICByZWFkb25seSBldmFsSW5wdXROYW1lczogcmVhZG9ubHkgc3RyaW5nW107XG5cbiAgLyoqXG4gICAqIEdldCBvdXRwdXQgbmFtZXMgb2YgdGhlIGxvYWRlZCBldmFsIG1vZGVsLiBJcyBhbiBlbXB0eSBhcnJheSBpZiBubyBldmFsIG1vZGVsIGlzIGxvYWRlZC5cbiAgICovXG4gIHJlYWRvbmx5IGV2YWxPdXRwdXROYW1lczogcmVhZG9ubHkgc3RyaW5nW107XG5cbiAgLy8gI2VuZHJlZ2lvblxufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIG9wdGlvbmFsIHBhcmFtZXRlcnMgdGhhdCBjYW4gYmUgcGFzc2VkIGludG8gdGhlIFRyYWluaW5nU2Vzc2lvbkZhY3RvcnkuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVHJhaW5pbmdTZXNzaW9uQ3JlYXRlT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBVUkkgb3IgYnVmZmVyIGZvciBhIC5ja3B0IGZpbGUgdGhhdCBjb250YWlucyB0aGUgY2hlY2twb2ludCBmb3IgdGhlIHRyYWluaW5nIG1vZGVsLlxuICAgKi9cbiAgY2hlY2twb2ludFN0YXRlOiBUcmFpbmluZ1Nlc3Npb24uVXJpT3JCdWZmZXI7XG4gIC8qKlxuICAgKiBVUkkgb3IgYnVmZmVyIGZvciB0aGUgLm9ubnggdHJhaW5pbmcgZmlsZS5cbiAgICovXG4gIHRyYWluTW9kZWw6IFRyYWluaW5nU2Vzc2lvbi5VcmlPckJ1ZmZlcjtcbiAgLyoqXG4gICAqIE9wdGlvbmFsLiBVUkkgb3IgYnVmZmVyIGZvciB0aGUgLm9ubnggb3B0aW1pemVyIG1vZGVsIGZpbGUuXG4gICAqL1xuICBvcHRpbWl6ZXJNb2RlbD86IFRyYWluaW5nU2Vzc2lvbi5VcmlPckJ1ZmZlcjtcbiAgLyoqXG4gICAqIE9wdGlvbmFsLiBVUkkgb3IgYnVmZmVyIGZvciB0aGUgLm9ubnggZXZhbCBtb2RlbCBmaWxlLlxuICAgKi9cbiAgZXZhbE1vZGVsPzogVHJhaW5pbmdTZXNzaW9uLlVyaU9yQnVmZmVyO1xufVxuXG4vKipcbiAqIERlZmluZXMgbWV0aG9kIG92ZXJsb2FkIHBvc3NpYmlsaXRpZXMgZm9yIGNyZWF0aW5nIGEgVHJhaW5pbmdTZXNzaW9uLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFRyYWluaW5nU2Vzc2lvbkZhY3Rvcnkge1xuICAvLyAjcmVnaW9uIGNyZWF0ZSgpXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgVHJhaW5pbmdTZXNzaW9uIGFuZCBhc3luY2hyb25vdXNseSBsb2FkcyBhbnkgbW9kZWxzIHBhc3NlZCBpbiB0aHJvdWdoIHRyYWluaW5nT3B0aW9uc1xuICAgKlxuICAgKiBAcGFyYW0gdHJhaW5pbmdPcHRpb25zIHNwZWNpZnkgbW9kZWxzIGFuZCBjaGVja3BvaW50cyB0byBsb2FkIGludG8gdGhlIFRyYWluaW5nIFNlc3Npb25cbiAgICogQHBhcmFtIHNlc3Npb25PcHRpb25zIHNwZWNpZnkgY29uZmlndXJhdGlvbiBmb3IgdHJhaW5pbmcgc2Vzc2lvbiBiZWhhdmlvclxuICAgKlxuICAgKiBAcmV0dXJucyBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBUcmFpbmluZ1Nlc3Npb24gb2JqZWN0XG4gICAqL1xuICBjcmVhdGUodHJhaW5pbmdPcHRpb25zOiBUcmFpbmluZ1Nlc3Npb25DcmVhdGVPcHRpb25zLCBzZXNzaW9uT3B0aW9ucz86IEluZmVyZW5jZVNlc3Npb24uU2Vzc2lvbk9wdGlvbnMpOlxuICAgICAgUHJvbWlzZTxUcmFpbmluZ1Nlc3Npb24+O1xuXG4gIC8vICNlbmRyZWdpb25cbn1cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuZXhwb3J0IGNvbnN0IFRyYWluaW5nU2Vzc2lvbjogVHJhaW5pbmdTZXNzaW9uRmFjdG9yeSA9IFRyYWluaW5nU2Vzc2lvbkltcGw7XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbi8qKlxuICogIyBPTk5YIFJ1bnRpbWUgSmF2YVNjcmlwdCBBUElcbiAqXG4gKiBPTk5YIFJ1bnRpbWUgSmF2YVNjcmlwdCBBUEkgaXMgYSB1bmlmaWVkIEFQSSBmb3IgYWxsIEphdmFTY3JpcHQgdXNhZ2VzLCBpbmNsdWRpbmcgdGhlIGZvbGxvd2luZyBOUE0gcGFja2FnZXM6XG4gKlxuICogLSBbb25ueHJ1bnRpbWUtbm9kZV0oaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2Uvb25ueHJ1bnRpbWUtbm9kZSlcbiAqIC0gW29ubnhydW50aW1lLXdlYl0oaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2Uvb25ueHJ1bnRpbWUtd2ViKVxuICogLSBbb25ueHJ1bnRpbWUtcmVhY3QtbmF0aXZlXShodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9vbm54cnVudGltZS1yZWFjdC1uYXRpdmUpXG4gKlxuICogU2VlIGFsc286XG4gKiAtIFtHZXQgU3RhcnRlZF0oaHR0cHM6Ly9vbm54cnVudGltZS5haS9kb2NzL2dldC1zdGFydGVkL3dpdGgtamF2YXNjcmlwdC8pXG4gKiAtIFtJbmZlcmVuY2UgZXhhbXBsZXNdKGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvb25ueHJ1bnRpbWUtaW5mZXJlbmNlLWV4YW1wbGVzL3RyZWUvbWFpbi9qcylcbiAqXG4gKiBAcGFja2FnZURvY3VtZW50YXRpb25cbiAqL1xuXG5leHBvcnQgKiBmcm9tICcuL2JhY2tlbmQuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9lbnYuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9pbmZlcmVuY2Utc2Vzc2lvbi5qcyc7XG5leHBvcnQgKiBmcm9tICcuL3RlbnNvci5qcyc7XG5leHBvcnQgKiBmcm9tICcuL3RlbnNvci1jb252ZXJzaW9uLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vdGVuc29yLWZhY3RvcnkuanMnO1xuZXhwb3J0ICogZnJvbSAnLi90cmFjZS5qcyc7XG5leHBvcnQgKiBmcm9tICcuL29ubngtbW9kZWwuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9vbm54LXZhbHVlLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vdHJhaW5pbmctc2Vzc2lvbi5qcyc7XG4iLCAiZXhwb3J0IGNvbnN0IHJlYWRGaWxlID0gdW5kZWZpbmVkO2V4cG9ydCBjb25zdCByZWFkRmlsZVN5bmMgPSB1bmRlZmluZWQ7ZXhwb3J0IGNvbnN0IGNyZWF0ZVJlYWRTdHJlYW0gPSB1bmRlZmluZWQ7IiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0Vudn0gZnJvbSAnb25ueHJ1bnRpbWUtY29tbW9uJztcblxuaW1wb3J0IHtXZWJHTENvbnRleHR9IGZyb20gJy4vYmFja2VuZHMvd2ViZ2wvd2ViZ2wtY29udGV4dCc7XG5cbmV4cG9ydCBkZWNsYXJlIG5hbWVzcGFjZSBMb2dnZXIge1xuICBleHBvcnQgaW50ZXJmYWNlIFNldmVyaXR5VHlwZU1hcCB7XG4gICAgdmVyYm9zZTogJ3YnO1xuICAgIGluZm86ICdpJztcbiAgICB3YXJuaW5nOiAndyc7XG4gICAgZXJyb3I6ICdlJztcbiAgICBmYXRhbDogJ2YnO1xuICB9XG5cbiAgZXhwb3J0IHR5cGUgU2V2ZXJpdHkgPSBrZXlvZiBTZXZlcml0eVR5cGVNYXA7XG5cbiAgZXhwb3J0IHR5cGUgUHJvdmlkZXIgPSAnbm9uZSd8J2NvbnNvbGUnO1xuXG4gIC8qKlxuICAgKiBMb2dnaW5nIGNvbmZpZyB0aGF0IHVzZWQgdG8gY29udHJvbCB0aGUgYmVoYXZpb3Igb2YgbG9nZ2VyXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIENvbmZpZyB7XG4gICAgLyoqXG4gICAgICogU3BlY2lmeSB0aGUgbG9nZ2luZyBwcm92aWRlci4gJ2NvbnNvbGUnIGJ5IGRlZmF1bHRcbiAgICAgKi9cbiAgICBwcm92aWRlcj86IFByb3ZpZGVyO1xuICAgIC8qKlxuICAgICAqIFNwZWNpZnkgdGhlIG1pbmltYWwgbG9nZ2VyIHNlcnZlcml0eS4gJ3dhcm5pbmcnIGJ5IGRlZmF1bHRcbiAgICAgKi9cbiAgICBtaW5pbWFsU2V2ZXJpdHk/OiBMb2dnZXIuU2V2ZXJpdHk7XG4gICAgLyoqXG4gICAgICogV2hldGhlciB0byBvdXRwdXQgZGF0ZSB0aW1lIGluIGxvZy4gdHJ1ZSBieSBkZWZhdWx0XG4gICAgICovXG4gICAgbG9nRGF0ZVRpbWU/OiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdG8gb3V0cHV0IHNvdXJjZSBpbmZvcm1hdGlvbiAoTm90IHlldCBzdXBwb3J0ZWQpLiBmYWxzZSBieSBkZWZhdWx0XG4gICAgICovXG4gICAgbG9nU291cmNlTG9jYXRpb24/OiBib29sZWFuO1xuICB9XG5cbiAgZXhwb3J0IGludGVyZmFjZSBDYXRlZ29yaXplZExvZ2dlciB7XG4gICAgdmVyYm9zZShjb250ZW50OiBzdHJpbmcpOiB2b2lkO1xuICAgIGluZm8oY29udGVudDogc3RyaW5nKTogdm9pZDtcbiAgICB3YXJuaW5nKGNvbnRlbnQ6IHN0cmluZyk6IHZvaWQ7XG4gICAgZXJyb3IoY29udGVudDogc3RyaW5nKTogdm9pZDtcbiAgICBmYXRhbChjb250ZW50OiBzdHJpbmcpOiB2b2lkO1xuICB9XG59XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tcmVkZWNsYXJlXG5leHBvcnQgaW50ZXJmYWNlIExvZ2dlciB7XG4gIChjYXRlZ29yeTogc3RyaW5nKTogTG9nZ2VyLkNhdGVnb3JpemVkTG9nZ2VyO1xuXG4gIHZlcmJvc2UoY29udGVudDogc3RyaW5nKTogdm9pZDtcbiAgdmVyYm9zZShjYXRlZ29yeTogc3RyaW5nLCBjb250ZW50OiBzdHJpbmcpOiB2b2lkO1xuICBpbmZvKGNvbnRlbnQ6IHN0cmluZyk6IHZvaWQ7XG4gIGluZm8oY2F0ZWdvcnk6IHN0cmluZywgY29udGVudDogc3RyaW5nKTogdm9pZDtcbiAgd2FybmluZyhjb250ZW50OiBzdHJpbmcpOiB2b2lkO1xuICB3YXJuaW5nKGNhdGVnb3J5OiBzdHJpbmcsIGNvbnRlbnQ6IHN0cmluZyk6IHZvaWQ7XG4gIGVycm9yKGNvbnRlbnQ6IHN0cmluZyk6IHZvaWQ7XG4gIGVycm9yKGNhdGVnb3J5OiBzdHJpbmcsIGNvbnRlbnQ6IHN0cmluZyk6IHZvaWQ7XG4gIGZhdGFsKGNvbnRlbnQ6IHN0cmluZyk6IHZvaWQ7XG4gIGZhdGFsKGNhdGVnb3J5OiBzdHJpbmcsIGNvbnRlbnQ6IHN0cmluZyk6IHZvaWQ7XG5cbiAgLyoqXG4gICAqIFJlc2V0IHRoZSBsb2dnZXIgY29uZmlndXJhdGlvbi5cbiAgICogQHBhcmFtIGNvbmZpZyBzcGVjaWZ5IGFuIG9wdGlvbmFsIGRlZmF1bHQgY29uZmlnXG4gICAqL1xuICByZXNldChjb25maWc/OiBMb2dnZXIuQ29uZmlnKTogdm9pZDtcbiAgLyoqXG4gICAqIFNldCB0aGUgbG9nZ2VyJ3MgYmVoYXZpb3Igb24gdGhlIGdpdmVuIGNhdGVnb3J5XG4gICAqIEBwYXJhbSBjYXRlZ29yeSBzcGVjaWZ5IGEgY2F0ZWdvcnkgc3RyaW5nLiBJZiAnKicgaXMgc3BlY2lmaWVkLCBhbGwgcHJldmlvdXMgY29uZmlndXJhdGlvbiB3aWxsIGJlIG92ZXJ3cml0dGVuLiBJZlxuICAgKiAnJyBpcyBzcGVjaWZpZWQsIHRoZSBkZWZhdWx0IGJlaGF2aW9yIHdpbGwgYmUgdXBkYXRlZC5cbiAgICogQHBhcmFtIGNvbmZpZyB0aGUgY29uZmlnIG9iamVjdCB0byBpbmRpY2F0ZSB0aGUgbG9nZ2VyJ3MgYmVoYXZpb3JcbiAgICovXG4gIHNldChjYXRlZ29yeTogc3RyaW5nLCBjb25maWc6IExvZ2dlci5Db25maWcpOiB2b2lkO1xuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGxvZ2dlcidzIGJlaGF2aW9yIGZyb20gb3J0LWNvbW1vbiBlbnZcbiAgICogQHBhcmFtIGVudiB0aGUgZW52IHVzZWQgdG8gc2V0IGxvZ2dlci4gQ3VycmVudGx5IG9ubHkgc2V0dGluZyBsb2dsZXZlbCBpcyBzdXBwb3J0ZWQgdGhyb3VnaCBFbnYuXG4gICAqL1xuICBzZXRXaXRoRW52KGVudjogRW52KTogdm9pZDtcbn1cblxuaW50ZXJmYWNlIExvZ2dlclByb3ZpZGVyIHtcbiAgbG9nKHNldmVyaXR5OiBMb2dnZXIuU2V2ZXJpdHksIGNvbnRlbnQ6IHN0cmluZywgY2F0ZWdvcnk/OiBzdHJpbmcpOiB2b2lkO1xufVxuY2xhc3MgTm9PcExvZ2dlclByb3ZpZGVyIGltcGxlbWVudHMgTG9nZ2VyUHJvdmlkZXIge1xuICBsb2coX3NldmVyaXR5OiBMb2dnZXIuU2V2ZXJpdHksIF9jb250ZW50OiBzdHJpbmcsIF9jYXRlZ29yeT86IHN0cmluZykge1xuICAgIC8vIGRvIG5vdGhpbmdcbiAgfVxufVxuY2xhc3MgQ29uc29sZUxvZ2dlclByb3ZpZGVyIGltcGxlbWVudHMgTG9nZ2VyUHJvdmlkZXIge1xuICBsb2coc2V2ZXJpdHk6IExvZ2dlci5TZXZlcml0eSwgY29udGVudDogc3RyaW5nLCBjYXRlZ29yeT86IHN0cmluZykge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgY29uc29sZS5sb2coYCR7dGhpcy5jb2xvcihzZXZlcml0eSl9ICR7Y2F0ZWdvcnkgPyAnXFx4MWJbMzVtJyArIGNhdGVnb3J5ICsgJ1xceDFiWzBtICcgOiAnJ30ke2NvbnRlbnR9YCk7XG4gIH1cblxuICBwcml2YXRlIGNvbG9yKHNldmVyaXR5OiBMb2dnZXIuU2V2ZXJpdHkpIHtcbiAgICBzd2l0Y2ggKHNldmVyaXR5KSB7XG4gICAgICBjYXNlICd2ZXJib3NlJzpcbiAgICAgICAgcmV0dXJuICdcXHgxYlszNDs0MG12XFx4MWJbMG0nO1xuICAgICAgY2FzZSAnaW5mbyc6XG4gICAgICAgIHJldHVybiAnXFx4MWJbMzJtaVxceDFiWzBtJztcbiAgICAgIGNhc2UgJ3dhcm5pbmcnOlxuICAgICAgICByZXR1cm4gJ1xceDFiWzMwOzQzbXdcXHgxYlswbSc7XG4gICAgICBjYXNlICdlcnJvcic6XG4gICAgICAgIHJldHVybiAnXFx4MWJbMzE7NDBtZVxceDFiWzBtJztcbiAgICAgIGNhc2UgJ2ZhdGFsJzpcbiAgICAgICAgcmV0dXJuICdcXHgxYlsxMDFtZlxceDFiWzBtJztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgc2V2ZXJpdHk6ICR7c2V2ZXJpdHl9YCk7XG4gICAgfVxuICB9XG59XG5cbmNvbnN0IFNFVkVSSVRZX1ZBTFVFID0ge1xuICB2ZXJib3NlOiAxMDAwLFxuICBpbmZvOiAyMDAwLFxuICB3YXJuaW5nOiA0MDAwLFxuICBlcnJvcjogNTAwMCxcbiAgZmF0YWw6IDYwMDBcbn07XG5cbmNvbnN0IExPR0dFUl9QUk9WSURFUl9NQVA6IHtyZWFkb25seSBbcHJvdmlkZXI6IHN0cmluZ106IFJlYWRvbmx5PExvZ2dlclByb3ZpZGVyPn0gPSB7XG4gIFsnbm9uZSddOiBuZXcgTm9PcExvZ2dlclByb3ZpZGVyKCksXG4gIFsnY29uc29sZSddOiBuZXcgQ29uc29sZUxvZ2dlclByb3ZpZGVyKClcbn07XG5jb25zdCBMT0dHRVJfREVGQVVMVF9DT05GSUcgPSB7XG4gIHByb3ZpZGVyOiAnY29uc29sZScsXG4gIG1pbmltYWxTZXZlcml0eTogJ3dhcm5pbmcnLFxuICBsb2dEYXRlVGltZTogdHJ1ZSxcbiAgbG9nU291cmNlTG9jYXRpb246IGZhbHNlXG59O1xubGV0IExPR0dFUl9DT05GSUdfTUFQOlxuICAgIHtbY2F0ZWdvcnk6IHN0cmluZ106IFJlYWRvbmx5PFJlcXVpcmVkPExvZ2dlci5Db25maWc+Pn0gPSB7WycnXTogTE9HR0VSX0RFRkFVTFRfQ09ORklHIGFzIFJlcXVpcmVkPExvZ2dlci5Db25maWc+fTtcblxuZnVuY3Rpb24gbG9nKGNhdGVnb3J5OiBzdHJpbmcpOiBMb2dnZXIuQ2F0ZWdvcml6ZWRMb2dnZXI7XG5mdW5jdGlvbiBsb2coc2V2ZXJpdHk6IExvZ2dlci5TZXZlcml0eSwgY29udGVudDogc3RyaW5nKTogdm9pZDtcbmZ1bmN0aW9uIGxvZyhzZXZlcml0eTogTG9nZ2VyLlNldmVyaXR5LCBjYXRlZ29yeTogc3RyaW5nLCBjb250ZW50OiBzdHJpbmcpOiB2b2lkO1xuZnVuY3Rpb24gbG9nKHNldmVyaXR5OiBMb2dnZXIuU2V2ZXJpdHksIGFyZzE6IHN0cmluZywgYXJnMj86IHN0cmluZyk6IHZvaWQ7XG5mdW5jdGlvbiBsb2coXG4gICAgYXJnMDogc3RyaW5nfExvZ2dlci5TZXZlcml0eSwgYXJnMT86IHN0cmluZywgYXJnMj86IHN0cmluZ3xudW1iZXIsIGFyZzM/OiBudW1iZXIpOiBMb2dnZXIuQ2F0ZWdvcml6ZWRMb2dnZXJ8dm9pZCB7XG4gIGlmIChhcmcxID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBsb2coY2F0ZWdvcnk6IHN0cmluZyk6IExvZ2dlci5DYXRlZ29yaXplZExvZ2dlcjtcbiAgICByZXR1cm4gY3JlYXRlQ2F0ZWdvcml6ZWRMb2dnZXIoYXJnMCk7XG4gIH0gZWxzZSBpZiAoYXJnMiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gbG9nKHNldmVyaXR5LCBjb250ZW50KTtcbiAgICBsb2dJbnRlcm5hbChhcmcwIGFzIExvZ2dlci5TZXZlcml0eSwgYXJnMSwgMSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGFyZzIgPT09ICdudW1iZXInICYmIGFyZzMgPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIGxvZyhzZXZlcml0eSwgY29udGVudCwgc3RhY2spXG4gICAgbG9nSW50ZXJuYWwoYXJnMCBhcyBMb2dnZXIuU2V2ZXJpdHksIGFyZzEsIGFyZzIpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBhcmcyID09PSAnc3RyaW5nJyAmJiBhcmczID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBsb2coc2V2ZXJpdHksIGNhdGVnb3J5LCBjb250ZW50KVxuICAgIGxvZ0ludGVybmFsKGFyZzAgYXMgTG9nZ2VyLlNldmVyaXR5LCBhcmcyLCAxLCBhcmcxKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgYXJnMiA9PT0gJ3N0cmluZycgJiYgdHlwZW9mIGFyZzMgPT09ICdudW1iZXInKSB7XG4gICAgLy8gbG9nKHNldmVyaXR5LCBjYXRlZ29yeSwgY29udGVudCwgc3RhY2spXG4gICAgbG9nSW50ZXJuYWwoYXJnMCBhcyBMb2dnZXIuU2V2ZXJpdHksIGFyZzIsIGFyZzMsIGFyZzEpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2lucHV0IGlzIHZhbGlkJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlQ2F0ZWdvcml6ZWRMb2dnZXIoY2F0ZWdvcnk6IHN0cmluZyk6IExvZ2dlci5DYXRlZ29yaXplZExvZ2dlciB7XG4gIHJldHVybiB7XG4gICAgdmVyYm9zZTogbG9nLnZlcmJvc2UuYmluZChudWxsLCBjYXRlZ29yeSksXG4gICAgaW5mbzogbG9nLmluZm8uYmluZChudWxsLCBjYXRlZ29yeSksXG4gICAgd2FybmluZzogbG9nLndhcm5pbmcuYmluZChudWxsLCBjYXRlZ29yeSksXG4gICAgZXJyb3I6IGxvZy5lcnJvci5iaW5kKG51bGwsIGNhdGVnb3J5KSxcbiAgICBmYXRhbDogbG9nLmZhdGFsLmJpbmQobnVsbCwgY2F0ZWdvcnkpXG4gIH07XG59XG5cbi8vIE5PVEU6IGFyZ3VtZW50ICdjYXRlZ29yeScgaXMgcHV0IHRoZSBsYXN0IHBhcmFtZXRlciBiZWFjYXVzZSB0eXBlc2NyaXB0XG4vLyBkb2Vzbid0IGFsbG93IG9wdGlvbmFsIGFyZ3VtZW50IHB1dCBpbiBmcm9udCBvZiByZXF1aXJlZCBhcmd1bWVudC4gVGhpc1xuLy8gb3JkZXIgaXMgZGlmZmVyZW50IGZyb20gYSB1c3VhbCBsb2dnaW5nIEFQSS5cbmZ1bmN0aW9uIGxvZ0ludGVybmFsKHNldmVyaXR5OiBMb2dnZXIuU2V2ZXJpdHksIGNvbnRlbnQ6IHN0cmluZywgX3N0YWNrOiBudW1iZXIsIGNhdGVnb3J5Pzogc3RyaW5nKSB7XG4gIGNvbnN0IGNvbmZpZyA9IExPR0dFUl9DT05GSUdfTUFQW2NhdGVnb3J5IHx8ICcnXSB8fCBMT0dHRVJfQ09ORklHX01BUFsnJ107XG4gIGlmIChTRVZFUklUWV9WQUxVRVtzZXZlcml0eV0gPCBTRVZFUklUWV9WQUxVRVtjb25maWcubWluaW1hbFNldmVyaXR5XSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChjb25maWcubG9nRGF0ZVRpbWUpIHtcbiAgICBjb250ZW50ID0gYCR7bmV3IERhdGUoKS50b0lTT1N0cmluZygpfXwke2NvbnRlbnR9YDtcbiAgfVxuXG4gIGlmIChjb25maWcubG9nU291cmNlTG9jYXRpb24pIHtcbiAgICAvLyBUT0RPOiBjYWxjdWxhdGUgc291cmNlIGxvY2F0aW9uIGZyb20gJ3N0YWNrJ1xuICB9XG5cbiAgTE9HR0VSX1BST1ZJREVSX01BUFtjb25maWcucHJvdmlkZXJdLmxvZyhzZXZlcml0eSwgY29udGVudCwgY2F0ZWdvcnkpO1xufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5hbWVzcGFjZVxubmFtZXNwYWNlIGxvZyB7XG4gIGV4cG9ydCBmdW5jdGlvbiB2ZXJib3NlKGNvbnRlbnQ6IHN0cmluZyk6IHZvaWQ7XG4gIGV4cG9ydCBmdW5jdGlvbiB2ZXJib3NlKGNhdGVnb3J5OiBzdHJpbmcsIGNvbnRlbnQ6IHN0cmluZyk6IHZvaWQ7XG4gIGV4cG9ydCBmdW5jdGlvbiB2ZXJib3NlKGFyZzA6IHN0cmluZywgYXJnMT86IHN0cmluZykge1xuICAgIGxvZygndmVyYm9zZScsIGFyZzAsIGFyZzEpO1xuICB9XG4gIGV4cG9ydCBmdW5jdGlvbiBpbmZvKGNvbnRlbnQ6IHN0cmluZyk6IHZvaWQ7XG4gIGV4cG9ydCBmdW5jdGlvbiBpbmZvKGNhdGVnb3J5OiBzdHJpbmcsIGNvbnRlbnQ6IHN0cmluZyk6IHZvaWQ7XG4gIGV4cG9ydCBmdW5jdGlvbiBpbmZvKGFyZzA6IHN0cmluZywgYXJnMT86IHN0cmluZykge1xuICAgIGxvZygnaW5mbycsIGFyZzAsIGFyZzEpO1xuICB9XG4gIGV4cG9ydCBmdW5jdGlvbiB3YXJuaW5nKGNvbnRlbnQ6IHN0cmluZyk6IHZvaWQ7XG4gIGV4cG9ydCBmdW5jdGlvbiB3YXJuaW5nKGNhdGVnb3J5OiBzdHJpbmcsIGNvbnRlbnQ6IHN0cmluZyk6IHZvaWQ7XG4gIGV4cG9ydCBmdW5jdGlvbiB3YXJuaW5nKGFyZzA6IHN0cmluZywgYXJnMT86IHN0cmluZykge1xuICAgIGxvZygnd2FybmluZycsIGFyZzAsIGFyZzEpO1xuICB9XG4gIGV4cG9ydCBmdW5jdGlvbiBlcnJvcihjb250ZW50OiBzdHJpbmcpOiB2b2lkO1xuICBleHBvcnQgZnVuY3Rpb24gZXJyb3IoY2F0ZWdvcnk6IHN0cmluZywgY29udGVudDogc3RyaW5nKTogdm9pZDtcbiAgZXhwb3J0IGZ1bmN0aW9uIGVycm9yKGFyZzA6IHN0cmluZywgYXJnMT86IHN0cmluZykge1xuICAgIGxvZygnZXJyb3InLCBhcmcwLCBhcmcxKTtcbiAgfVxuICBleHBvcnQgZnVuY3Rpb24gZmF0YWwoY29udGVudDogc3RyaW5nKTogdm9pZDtcbiAgZXhwb3J0IGZ1bmN0aW9uIGZhdGFsKGNhdGVnb3J5OiBzdHJpbmcsIGNvbnRlbnQ6IHN0cmluZyk6IHZvaWQ7XG4gIGV4cG9ydCBmdW5jdGlvbiBmYXRhbChhcmcwOiBzdHJpbmcsIGFyZzE/OiBzdHJpbmcpIHtcbiAgICBsb2coJ2ZhdGFsJywgYXJnMCwgYXJnMSk7XG4gIH1cblxuICBleHBvcnQgZnVuY3Rpb24gcmVzZXQoY29uZmlnPzogTG9nZ2VyLkNvbmZpZyk6IHZvaWQge1xuICAgIExPR0dFUl9DT05GSUdfTUFQID0ge307XG4gICAgc2V0KCcnLCBjb25maWcgfHwge30pO1xuICB9XG4gIGV4cG9ydCBmdW5jdGlvbiBzZXQoY2F0ZWdvcnk6IHN0cmluZywgY29uZmlnOiBMb2dnZXIuQ29uZmlnKTogdm9pZCB7XG4gICAgaWYgKGNhdGVnb3J5ID09PSAnKicpIHtcbiAgICAgIHJlc2V0KGNvbmZpZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHByZXZpb3VzQ29uZmlnID0gTE9HR0VSX0NPTkZJR19NQVBbY2F0ZWdvcnldIHx8IExPR0dFUl9ERUZBVUxUX0NPTkZJRztcbiAgICAgIExPR0dFUl9DT05GSUdfTUFQW2NhdGVnb3J5XSA9IHtcbiAgICAgICAgcHJvdmlkZXI6IGNvbmZpZy5wcm92aWRlciB8fCBwcmV2aW91c0NvbmZpZy5wcm92aWRlcixcbiAgICAgICAgbWluaW1hbFNldmVyaXR5OiBjb25maWcubWluaW1hbFNldmVyaXR5IHx8IHByZXZpb3VzQ29uZmlnLm1pbmltYWxTZXZlcml0eSxcbiAgICAgICAgbG9nRGF0ZVRpbWU6IChjb25maWcubG9nRGF0ZVRpbWUgPT09IHVuZGVmaW5lZCkgPyBwcmV2aW91c0NvbmZpZy5sb2dEYXRlVGltZSA6IGNvbmZpZy5sb2dEYXRlVGltZSxcbiAgICAgICAgbG9nU291cmNlTG9jYXRpb246IChjb25maWcubG9nU291cmNlTG9jYXRpb24gPT09IHVuZGVmaW5lZCkgPyBwcmV2aW91c0NvbmZpZy5sb2dTb3VyY2VMb2NhdGlvbiA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLmxvZ1NvdXJjZUxvY2F0aW9uXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIFRPRE86IHdlIHdhbnQgdG8gc3VwcG9ydCB3aWxkY2FyZCBvciByZWdleD9cbiAgfVxuXG4gIGV4cG9ydCBmdW5jdGlvbiBzZXRXaXRoRW52KGVudjogRW52KTogdm9pZCB7XG4gICAgY29uc3QgY29uZmlnOiBMb2dnZXIuQ29uZmlnID0ge307XG4gICAgaWYgKGVudi5sb2dMZXZlbCkge1xuICAgICAgY29uZmlnLm1pbmltYWxTZXZlcml0eSA9IGVudi5sb2dMZXZlbCBhcyBMb2dnZXIuU2V2ZXJpdHk7XG4gICAgfVxuICAgIHNldCgnJywgY29uZmlnKTtcbiAgfVxufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXJlZGVjbGFyZSwgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG5leHBvcnQgY29uc3QgTG9nZ2VyOiBMb2dnZXIgPSBsb2c7XG5cbmV4cG9ydCBkZWNsYXJlIG5hbWVzcGFjZSBQcm9maWxlciB7XG4gIGV4cG9ydCBpbnRlcmZhY2UgQ29uZmlnIHtcbiAgICBtYXhOdW1iZXJFdmVudHM/OiBudW1iZXI7XG4gICAgZmx1c2hCYXRjaFNpemU/OiBudW1iZXI7XG4gICAgZmx1c2hJbnRlcnZhbEluTWlsbGlzZWNvbmRzPzogbnVtYmVyO1xuICB9XG5cbiAgZXhwb3J0IHR5cGUgRXZlbnRDYXRlZ29yeSA9ICdzZXNzaW9uJ3wnbm9kZSd8J29wJ3wnYmFja2VuZCc7XG5cbiAgZXhwb3J0IGludGVyZmFjZSBFdmVudCB7XG4gICAgZW5kKCk6IHZvaWR8UHJvbWlzZTx2b2lkPjtcbiAgfVxufVxuLy8gVE9ET1xuLy8gY2xhc3MgV2ViR0xFdmVudCBpbXBsZW1lbnRzIFByb2ZpbGVyLkV2ZW50IHt9XG5cbmNsYXNzIEV2ZW50IGltcGxlbWVudHMgUHJvZmlsZXIuRXZlbnQge1xuICBjb25zdHJ1Y3RvcihcbiAgICAgIHB1YmxpYyBjYXRlZ29yeTogUHJvZmlsZXIuRXZlbnRDYXRlZ29yeSwgcHVibGljIG5hbWU6IHN0cmluZywgcHVibGljIHN0YXJ0VGltZTogbnVtYmVyLFxuICAgICAgcHJpdmF0ZSBlbmRDYWxsYmFjazogKGU6IEV2ZW50KSA9PiB2b2lkfFByb21pc2U8dm9pZD4sIHB1YmxpYyB0aW1lcj86IFdlYkdMUXVlcnksIHB1YmxpYyBjdHg/OiBXZWJHTENvbnRleHQpIHt9XG5cbiAgYXN5bmMgZW5kKCkge1xuICAgIHJldHVybiB0aGlzLmVuZENhbGxiYWNrKHRoaXMpO1xuICB9XG5cbiAgYXN5bmMgY2hlY2tUaW1lcigpOiBQcm9taXNlPG51bWJlcj4ge1xuICAgIGlmICh0aGlzLmN0eCA9PT0gdW5kZWZpbmVkIHx8IHRoaXMudGltZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyB3ZWJnbCB0aW1lciBmb3VuZCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmN0eC5lbmRUaW1lcigpO1xuICAgICAgcmV0dXJuIHRoaXMuY3R4LndhaXRGb3JRdWVyeUFuZEdldFRpbWUodGhpcy50aW1lcik7XG4gICAgfVxuICB9XG59XG5cbmNsYXNzIEV2ZW50UmVjb3JkIHtcbiAgY29uc3RydWN0b3IoXG4gICAgICBwdWJsaWMgY2F0ZWdvcnk6IFByb2ZpbGVyLkV2ZW50Q2F0ZWdvcnksIHB1YmxpYyBuYW1lOiBzdHJpbmcsIHB1YmxpYyBzdGFydFRpbWU6IG51bWJlciwgcHVibGljIGVuZFRpbWU6IG51bWJlcikge31cbn1cblxuZXhwb3J0IGNsYXNzIFByb2ZpbGVyIHtcbiAgc3RhdGljIGNyZWF0ZShjb25maWc/OiBQcm9maWxlci5Db25maWcpOiBQcm9maWxlciB7XG4gICAgaWYgKGNvbmZpZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gbmV3IHRoaXMoKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyB0aGlzKGNvbmZpZy5tYXhOdW1iZXJFdmVudHMsIGNvbmZpZy5mbHVzaEJhdGNoU2l6ZSwgY29uZmlnLmZsdXNoSW50ZXJ2YWxJbk1pbGxpc2Vjb25kcyk7XG4gIH1cblxuICBwcml2YXRlIGNvbnN0cnVjdG9yKG1heE51bWJlckV2ZW50cz86IG51bWJlciwgZmx1c2hCYXRjaFNpemU/OiBudW1iZXIsIGZsdXNoSW50ZXJ2YWxJbk1pbGxpc2Vjb25kcz86IG51bWJlcikge1xuICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9tYXhOdW1iZXJFdmVudHMgPSBtYXhOdW1iZXJFdmVudHMgPT09IHVuZGVmaW5lZCA/IDEwMDAwIDogbWF4TnVtYmVyRXZlbnRzO1xuICAgIHRoaXMuX2ZsdXNoQmF0Y2hTaXplID0gZmx1c2hCYXRjaFNpemUgPT09IHVuZGVmaW5lZCA/IDEwIDogZmx1c2hCYXRjaFNpemU7XG4gICAgdGhpcy5fZmx1c2hJbnRlcnZhbEluTWlsbGlzZWNvbmRzID0gZmx1c2hJbnRlcnZhbEluTWlsbGlzZWNvbmRzID09PSB1bmRlZmluZWQgPyA1MDAwIDogZmx1c2hJbnRlcnZhbEluTWlsbGlzZWNvbmRzO1xuICB9XG5cbiAgLy8gc3RhcnQgcHJvZmlsaW5nXG4gIHN0YXJ0KCkge1xuICAgIHRoaXMuX3N0YXJ0ZWQgPSB0cnVlO1xuICAgIHRoaXMuX3RpbWluZ0V2ZW50cyA9IFtdO1xuICAgIHRoaXMuX2ZsdXNoVGltZSA9IG5vdygpO1xuICAgIHRoaXMuX2ZsdXNoUG9pbnRlciA9IDA7XG4gIH1cblxuICAvLyBzdG9wIHByb2ZpbGluZ1xuICBzdG9wKCkge1xuICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcbiAgICBmb3IgKDsgdGhpcy5fZmx1c2hQb2ludGVyIDwgdGhpcy5fdGltaW5nRXZlbnRzLmxlbmd0aDsgdGhpcy5fZmx1c2hQb2ludGVyKyspIHtcbiAgICAgIHRoaXMubG9nT25lRXZlbnQodGhpcy5fdGltaW5nRXZlbnRzW3RoaXMuX2ZsdXNoUG9pbnRlcl0pO1xuICAgIH1cbiAgfVxuXG4gIC8vIGNyZWF0ZSBhbiBldmVudCBzY29wZSBmb3IgdGhlIHNwZWNpZmljIGZ1bmN0aW9uXG4gIGV2ZW50PFQ+KGNhdGVnb3J5OiBQcm9maWxlci5FdmVudENhdGVnb3J5LCBuYW1lOiBzdHJpbmcsIGZ1bmM6ICgpID0+IFQsIGN0eD86IFdlYkdMQ29udGV4dCk6IFQ7XG4gIGV2ZW50PFQ+KGNhdGVnb3J5OiBQcm9maWxlci5FdmVudENhdGVnb3J5LCBuYW1lOiBzdHJpbmcsIGZ1bmM6ICgpID0+IFByb21pc2U8VD4sIGN0eD86IFdlYkdMQ29udGV4dCk6IFByb21pc2U8VD47XG5cbiAgZXZlbnQ8VD4oY2F0ZWdvcnk6IFByb2ZpbGVyLkV2ZW50Q2F0ZWdvcnksIG5hbWU6IHN0cmluZywgZnVuYzogKCkgPT4gVCB8IFByb21pc2U8VD4sIGN0eD86IFdlYkdMQ29udGV4dCk6IFRcbiAgICAgIHxQcm9taXNlPFQ+IHtcbiAgICBjb25zdCBldmVudCA9IHRoaXMuX3N0YXJ0ZWQgPyB0aGlzLmJlZ2luKGNhdGVnb3J5LCBuYW1lLCBjdHgpIDogdW5kZWZpbmVkO1xuICAgIGxldCBpc1Byb21pc2UgPSBmYWxzZTtcblxuICAgIGNvbnN0IHJlcyA9IGZ1bmMoKTtcblxuICAgIC8vIHdlIGNvbnNpZGVyIGEgdGhlbi1hYmxlIG9iamVjdCBpcyBhIHByb21pc2VcbiAgICBpZiAocmVzICYmIHR5cGVvZiAocmVzIGFzIFByb21pc2U8VD4pLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlzUHJvbWlzZSA9IHRydWU7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2U8VD4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAocmVzIGFzIFByb21pc2U8VD4pXG4gICAgICAgICAgICAudGhlbihcbiAgICAgICAgICAgICAgICBhc3luYyB2YWx1ZSA9PiB7ICAvLyBmdWxmaWxsZWRcbiAgICAgICAgICAgICAgICAgIGlmIChldmVudCkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBldmVudC5lbmQoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHJlc29sdmUodmFsdWUpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYXN5bmMgcmVhc29uID0+IHsgIC8vIHJlamVjdGVkXG4gICAgICAgICAgICAgICAgICBpZiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgZXZlbnQuZW5kKCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICByZWplY3QocmVhc29uKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoIWlzUHJvbWlzZSAmJiBldmVudCkge1xuICAgICAgY29uc3QgZXZlbnRSZXMgPSBldmVudC5lbmQoKTtcbiAgICAgIGlmIChldmVudFJlcyAmJiB0eXBlb2YgZXZlbnRSZXMudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2U8VD4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgIChldmVudFJlcykudGhlbihcbiAgICAgICAgICAgICAgKCkgPT4geyAgLy8gZnVsZmlsbGVkXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShyZXMpO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAocmVhc29uKSA9PiB7ICAvLyByZWplY3RlZFxuICAgICAgICAgICAgICAgIHJlamVjdChyZWFzb24pO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH1cblxuICAvLyBiZWdpbiBhbiBldmVudFxuICBiZWdpbihjYXRlZ29yeTogUHJvZmlsZXIuRXZlbnRDYXRlZ29yeSwgbmFtZTogc3RyaW5nLCBjdHg/OiBXZWJHTENvbnRleHQpOiBFdmVudCB7XG4gICAgaWYgKCF0aGlzLl9zdGFydGVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2ZpbGVyIGlzIG5vdCBzdGFydGVkIHlldCcpO1xuICAgIH1cbiAgICBpZiAoY3R4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IG5vdygpO1xuICAgICAgdGhpcy5mbHVzaChzdGFydFRpbWUpO1xuICAgICAgcmV0dXJuIG5ldyBFdmVudChjYXRlZ29yeSwgbmFtZSwgc3RhcnRUaW1lLCBlID0+IHRoaXMuZW5kU3luYyhlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHRpbWVyOiBXZWJHTFF1ZXJ5ID0gY3R4LmJlZ2luVGltZXIoKTtcbiAgICAgIHJldHVybiBuZXcgRXZlbnQoY2F0ZWdvcnksIG5hbWUsIDAsIGFzeW5jIGUgPT4gdGhpcy5lbmQoZSksIHRpbWVyLCBjdHgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGVuZCB0aGUgc3BlY2lmaWMgZXZlbnRcbiAgcHJpdmF0ZSBhc3luYyBlbmQoZXZlbnQ6IEV2ZW50KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgZW5kVGltZTogbnVtYmVyID0gYXdhaXQgZXZlbnQuY2hlY2tUaW1lcigpO1xuICAgIGlmICh0aGlzLl90aW1pbmdFdmVudHMubGVuZ3RoIDwgdGhpcy5fbWF4TnVtYmVyRXZlbnRzKSB7XG4gICAgICB0aGlzLl90aW1pbmdFdmVudHMucHVzaChuZXcgRXZlbnRSZWNvcmQoZXZlbnQuY2F0ZWdvcnksIGV2ZW50Lm5hbWUsIGV2ZW50LnN0YXJ0VGltZSwgZW5kVGltZSkpO1xuICAgICAgdGhpcy5mbHVzaChlbmRUaW1lKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGVuZFN5bmMoZXZlbnQ6IEV2ZW50KTogdm9pZCB7XG4gICAgY29uc3QgZW5kVGltZTogbnVtYmVyID0gbm93KCk7XG4gICAgaWYgKHRoaXMuX3RpbWluZ0V2ZW50cy5sZW5ndGggPCB0aGlzLl9tYXhOdW1iZXJFdmVudHMpIHtcbiAgICAgIHRoaXMuX3RpbWluZ0V2ZW50cy5wdXNoKG5ldyBFdmVudFJlY29yZChldmVudC5jYXRlZ29yeSwgZXZlbnQubmFtZSwgZXZlbnQuc3RhcnRUaW1lLCBlbmRUaW1lKSk7XG4gICAgICB0aGlzLmZsdXNoKGVuZFRpbWUpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgbG9nT25lRXZlbnQoZXZlbnQ6IEV2ZW50UmVjb3JkKSB7XG4gICAgTG9nZ2VyLnZlcmJvc2UoXG4gICAgICAgIGBQcm9maWxlci4ke2V2ZW50LmNhdGVnb3J5fWAsXG4gICAgICAgIGAkeyhldmVudC5lbmRUaW1lIC0gZXZlbnQuc3RhcnRUaW1lKS50b0ZpeGVkKDIpfW1zIG9uIGV2ZW50ICcke2V2ZW50Lm5hbWV9JyBhdCAke2V2ZW50LmVuZFRpbWUudG9GaXhlZCgyKX1gKTtcbiAgfVxuXG4gIHByaXZhdGUgZmx1c2goY3VycmVudFRpbWU6IG51bWJlcikge1xuICAgIGlmICh0aGlzLl90aW1pbmdFdmVudHMubGVuZ3RoIC0gdGhpcy5fZmx1c2hQb2ludGVyID49IHRoaXMuX2ZsdXNoQmF0Y2hTaXplIHx8XG4gICAgICAgIGN1cnJlbnRUaW1lIC0gdGhpcy5fZmx1c2hUaW1lID49IHRoaXMuX2ZsdXNoSW50ZXJ2YWxJbk1pbGxpc2Vjb25kcykge1xuICAgICAgLy8gc2hvdWxkIGZsdXNoIHdoZW4gZWl0aGVyIGJhdGNoIHNpemUgYWNjdW1sYXRlZCBvciBpbnRlcnZhbCBlbGVwc2VkXG5cbiAgICAgIGZvciAoY29uc3QgcHJldmlvdXNQb2ludGVyID0gdGhpcy5fZmx1c2hQb2ludGVyOyB0aGlzLl9mbHVzaFBvaW50ZXIgPCBwcmV2aW91c1BvaW50ZXIgKyB0aGlzLl9mbHVzaEJhdGNoU2l6ZSAmJlxuICAgICAgICAgICB0aGlzLl9mbHVzaFBvaW50ZXIgPCB0aGlzLl90aW1pbmdFdmVudHMubGVuZ3RoO1xuICAgICAgICAgICB0aGlzLl9mbHVzaFBvaW50ZXIrKykge1xuICAgICAgICB0aGlzLmxvZ09uZUV2ZW50KHRoaXMuX3RpbWluZ0V2ZW50c1t0aGlzLl9mbHVzaFBvaW50ZXJdKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fZmx1c2hUaW1lID0gbm93KCk7XG4gICAgfVxuICB9XG5cbiAgZ2V0IHN0YXJ0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXJ0ZWQ7XG4gIH1cbiAgcHJpdmF0ZSBfc3RhcnRlZCA9IGZhbHNlO1xuICBwcml2YXRlIF90aW1pbmdFdmVudHM6IEV2ZW50UmVjb3JkW107XG5cbiAgcHJpdmF0ZSByZWFkb25seSBfbWF4TnVtYmVyRXZlbnRzOiBudW1iZXI7XG5cbiAgcHJpdmF0ZSByZWFkb25seSBfZmx1c2hCYXRjaFNpemU6IG51bWJlcjtcbiAgcHJpdmF0ZSByZWFkb25seSBfZmx1c2hJbnRlcnZhbEluTWlsbGlzZWNvbmRzOiBudW1iZXI7XG5cbiAgcHJpdmF0ZSBfZmx1c2hUaW1lOiBudW1iZXI7XG4gIHByaXZhdGUgX2ZsdXNoUG9pbnRlciA9IDA7XG59XG5cbi8qKlxuICogcmV0dXJucyBhIG51bWJlciB0byByZXByZXNlbnQgdGhlIGN1cnJlbnQgdGltZXN0YW1wIGluIGEgcmVzb2x1dGlvbiBhcyBoaWdoIGFzIHBvc3NpYmxlLlxuICovXG5leHBvcnQgY29uc3Qgbm93ID0gKHR5cGVvZiBwZXJmb3JtYW5jZSAhPT0gJ3VuZGVmaW5lZCcgJiYgcGVyZm9ybWFuY2Uubm93KSA/ICgpID0+IHBlcmZvcm1hbmNlLm5vdygpIDogRGF0ZS5ub3c7XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7R3JhcGh9IGZyb20gJy4vZ3JhcGgnO1xuaW1wb3J0IHtPcGVyYXRvckltcGxlbWVudGF0aW9uLCBPcGVyYXRvckluaXRpYWxpemF0aW9ufSBmcm9tICcuL29wZXJhdG9ycyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgT3BTZXQge1xuICBkb21haW46IHN0cmluZztcbiAgdmVyc2lvbjogbnVtYmVyO1xufVxuZXhwb3J0IGRlY2xhcmUgbmFtZXNwYWNlIE9wU2V0IHtcbiAgLyoqXG4gICAqIERvbWFpbiBvZiBhbiBvcHNldCwgaXQgY2FuIGJlIGFuIGVtcHR5IHN0cmluZyhkZWZhdWx0IHZhbHVlLCByZXByZXNlbnQgZm9yIGFpLm9ubngpLCBvciAnYWkub25ueC5tbCdcbiAgICovXG4gIHR5cGUgRG9tYWluID0gJyd8J2FpLm9ubngubWwnfCdjb20ubWljcm9zb2Z0JztcbiAgLyoqXG4gICAqIEEgcmVzb2x2ZSBydWxlIGNvbnNpc3RzIG9mIDQgb3IgNSBpdGVtczogb3BUeXBlLCBvcFNldERvbWFpbiwgdmVyc2lvblNlbGVjdG9yLCBvcGVyYXRvckltcGxlbWVudGF0aW9uIGFuZFxuICAgKiBvcGVyYXRvckluaXRpYWxpemF0aW9uIChvcHRpb25hbClcbiAgICovXG4gIHR5cGUgUmVzb2x2ZVJ1bGUgPSBbXG4gICAgc3RyaW5nLCBEb21haW4sIHN0cmluZywgT3BlcmF0b3JJbXBsZW1lbnRhdGlvbjxHcmFwaC5Ob2RlPlxuICBdfFtzdHJpbmcsIERvbWFpbiwgc3RyaW5nLCBPcGVyYXRvckltcGxlbWVudGF0aW9uPHVua25vd24+LCBPcGVyYXRvckluaXRpYWxpemF0aW9uPHVua25vd24+XTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlc29sdmVPcGVyYXRvcihub2RlOiBHcmFwaC5Ob2RlLCBvcHNldHM6IHJlYWRvbmx5IE9wU2V0W10sIHJ1bGVzOiByZWFkb25seSBPcFNldC5SZXNvbHZlUnVsZVtdKSB7XG4gIGZvciAoY29uc3QgcnVsZSBvZiBydWxlcykge1xuICAgIGNvbnN0IG9wVHlwZSA9IHJ1bGVbMF07XG4gICAgY29uc3QgZG9tYWluID0gcnVsZVsxXTtcbiAgICBjb25zdCB2ZXJzaW9uU2VsZWN0b3IgPSBydWxlWzJdO1xuICAgIGNvbnN0IG9wSW1wbCA9IHJ1bGVbM107XG4gICAgY29uc3Qgb3BJbml0ID0gcnVsZVs0XTtcblxuICAgIGlmIChub2RlLm9wVHlwZSA9PT0gb3BUeXBlKSB7ICAvLyBvcGVyYXRvciB0eXBlIG1hdGNoZXNcbiAgICAgIGZvciAoY29uc3Qgb3BzZXQgb2Ygb3BzZXRzKSB7XG4gICAgICAgIC8vIG9wc2V0ICcnIGFuZCAnYWkub25ueCcgYXJlIGNvbnNpZGVyZWQgdGhlIHNhbWUuXG4gICAgICAgIGlmIChvcHNldC5kb21haW4gPT09IGRvbWFpbiB8fCAob3BzZXQuZG9tYWluID09PSAnYWkub25ueCcgJiYgZG9tYWluID09PSAnJykpIHsgIC8vIG9wc2V0IGRvbWFpbiBmb3VuZFxuICAgICAgICAgIGlmIChtYXRjaFNlbGVjdG9yKG9wc2V0LnZlcnNpb24sIHZlcnNpb25TZWxlY3RvcikpIHtcbiAgICAgICAgICAgIHJldHVybiB7b3BJbXBsLCBvcEluaXR9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoYGNhbm5vdCByZXNvbHZlIG9wZXJhdG9yICcke25vZGUub3BUeXBlfScgd2l0aCBvcHNldHM6ICR7XG4gICAgICBvcHNldHMubWFwKHNldCA9PiBgJHtzZXQuZG9tYWluIHx8ICdhaS5vbm54J30gdiR7c2V0LnZlcnNpb259YCkuam9pbignLCAnKX1gKTtcbn1cblxuZnVuY3Rpb24gbWF0Y2hTZWxlY3Rvcih2ZXJzaW9uOiBudW1iZXIsIHNlbGVjdG9yOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgaWYgKHNlbGVjdG9yLmVuZHNXaXRoKCcrJykpIHtcbiAgICAvLyBtaW5pbXVtIHZlcnNpb24gbWF0Y2ggKCc3KycgZXhwZWN0cyB2ZXJzaW9uPj03KVxuICAgIGNvbnN0IHJhbmdlU3RhcnQgPSBOdW1iZXIucGFyc2VJbnQoc2VsZWN0b3Iuc3Vic3RyaW5nKDAsIHNlbGVjdG9yLmxlbmd0aCAtIDEpLCAxMCk7XG4gICAgcmV0dXJuICFpc05hTihyYW5nZVN0YXJ0KSAmJiByYW5nZVN0YXJ0IDw9IHZlcnNpb247XG4gIH0gZWxzZSBpZiAoc2VsZWN0b3Iuc3BsaXQoJy0nKS5sZW5ndGggPT09IDIpIHtcbiAgICAvLyByYW5nZSBtYXRjaCAoJzYtOCcgZXhwZWN0cyA2PD12ZXJzaW9uPD04KVxuICAgIGNvbnN0IHBhaXIgPSBzZWxlY3Rvci5zcGxpdCgnLScpO1xuICAgIGNvbnN0IHJhbmdlU3RhcnQgPSBOdW1iZXIucGFyc2VJbnQocGFpclswXSwgMTApO1xuICAgIGNvbnN0IHJhbmdlRW5kID0gTnVtYmVyLnBhcnNlSW50KHBhaXJbMV0sIDEwKTtcbiAgICByZXR1cm4gIWlzTmFOKHJhbmdlU3RhcnQpICYmICFpc05hTihyYW5nZUVuZCkgJiYgcmFuZ2VTdGFydCA8PSB2ZXJzaW9uICYmIHZlcnNpb24gPD0gcmFuZ2VFbmQ7XG4gIH0gZWxzZSB7XG4gICAgLy8gZXhhY3QgbWF0Y2ggKCc3JyBleHBlY3RzIHZlcnNpb249PT03KVxuICAgIHJldHVybiBOdW1iZXIucGFyc2VJbnQoc2VsZWN0b3IsIDEwKSA9PT0gdmVyc2lvbjtcbiAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xyXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xyXG52YXIgR3VpZCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEd1aWQoZ3VpZCkge1xyXG4gICAgICAgIGlmICghZ3VpZCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhcmd1bWVudDsgYHZhbHVlYCBoYXMgbm8gdmFsdWUuXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnZhbHVlID0gR3VpZC5FTVBUWTtcclxuICAgICAgICBpZiAoZ3VpZCAmJiBHdWlkLmlzR3VpZChndWlkKSkge1xyXG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gZ3VpZDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBHdWlkLmlzR3VpZCA9IGZ1bmN0aW9uIChndWlkKSB7XHJcbiAgICAgICAgdmFyIHZhbHVlID0gZ3VpZC50b1N0cmluZygpO1xyXG4gICAgICAgIHJldHVybiBndWlkICYmIChndWlkIGluc3RhbmNlb2YgR3VpZCB8fCBHdWlkLnZhbGlkYXRvci50ZXN0KHZhbHVlKSk7XHJcbiAgICB9O1xyXG4gICAgR3VpZC5jcmVhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBHdWlkKFtHdWlkLmdlbigyKSwgR3VpZC5nZW4oMSksIEd1aWQuZ2VuKDEpLCBHdWlkLmdlbigxKSwgR3VpZC5nZW4oMyldLmpvaW4oXCItXCIpKTtcclxuICAgIH07XHJcbiAgICBHdWlkLmNyZWF0ZUVtcHR5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgR3VpZChcImVtcHR5Z3VpZFwiKTtcclxuICAgIH07XHJcbiAgICBHdWlkLnBhcnNlID0gZnVuY3Rpb24gKGd1aWQpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEd1aWQoZ3VpZCk7XHJcbiAgICB9O1xyXG4gICAgR3VpZC5yYXcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIFtHdWlkLmdlbigyKSwgR3VpZC5nZW4oMSksIEd1aWQuZ2VuKDEpLCBHdWlkLmdlbigxKSwgR3VpZC5nZW4oMyldLmpvaW4oXCItXCIpO1xyXG4gICAgfTtcclxuICAgIEd1aWQuZ2VuID0gZnVuY3Rpb24gKGNvdW50KSB7XHJcbiAgICAgICAgdmFyIG91dCA9IFwiXCI7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XHJcbiAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1iaXR3aXNlXHJcbiAgICAgICAgICAgIG91dCArPSAoKCgxICsgTWF0aC5yYW5kb20oKSkgKiAweDEwMDAwKSB8IDApLnRvU3RyaW5nKDE2KS5zdWJzdHJpbmcoMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvdXQ7XHJcbiAgICB9O1xyXG4gICAgR3VpZC5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKG90aGVyKSB7XHJcbiAgICAgICAgLy8gQ29tcGFyaW5nIHN0cmluZyBgdmFsdWVgIGFnYWluc3QgcHJvdmlkZWQgYGd1aWRgIHdpbGwgYXV0by1jYWxsXHJcbiAgICAgICAgLy8gdG9TdHJpbmcgb24gYGd1aWRgIGZvciBjb21wYXJpc29uXHJcbiAgICAgICAgcmV0dXJuIEd1aWQuaXNHdWlkKG90aGVyKSAmJiB0aGlzLnZhbHVlID09PSBvdGhlci50b1N0cmluZygpO1xyXG4gICAgfTtcclxuICAgIEd1aWQucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUgPT09IEd1aWQuRU1QVFk7XHJcbiAgICB9O1xyXG4gICAgR3VpZC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XHJcbiAgICB9O1xyXG4gICAgR3VpZC5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHZhbHVlOiB0aGlzLnZhbHVlXHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbiAgICBHdWlkLnZhbGlkYXRvciA9IG5ldyBSZWdFeHAoXCJeW2EtejAtOV17OH0tW2EtejAtOV17NH0tW2EtejAtOV17NH0tW2EtejAtOV17NH0tW2EtejAtOV17MTJ9JFwiLCBcImlcIik7XHJcbiAgICBHdWlkLkVNUFRZID0gXCIwMDAwMDAwMC0wMDAwLTAwMDAtMDAwMC0wMDAwMDAwMDAwMDBcIjtcclxuICAgIHJldHVybiBHdWlkO1xyXG59KCkpO1xyXG5leHBvcnRzLkd1aWQgPSBHdWlkO1xyXG4iLCAiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMDkgVGhlIENsb3N1cmUgTGlicmFyeSBBdXRob3JzXG4gKiBDb3B5cmlnaHQgMjAyMCBEYW5pZWwgV2lydHogLyBUaGUgbG9uZy5qcyBBdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5cbi8vIFdlYkFzc2VtYmx5IG9wdGltaXphdGlvbnMgdG8gZG8gbmF0aXZlIGk2NCBtdWx0aXBsaWNhdGlvbiBhbmQgZGl2aWRlXG52YXIgd2FzbSA9IG51bGw7XG50cnkge1xuICB3YXNtID0gbmV3IFdlYkFzc2VtYmx5Lkluc3RhbmNlKG5ldyBXZWJBc3NlbWJseS5Nb2R1bGUobmV3IFVpbnQ4QXJyYXkoW1xuICAgIDAsIDk3LCAxMTUsIDEwOSwgMSwgMCwgMCwgMCwgMSwgMTMsIDIsIDk2LCAwLCAxLCAxMjcsIDk2LCA0LCAxMjcsIDEyNywgMTI3LCAxMjcsIDEsIDEyNywgMywgNywgNiwgMCwgMSwgMSwgMSwgMSwgMSwgNiwgNiwgMSwgMTI3LCAxLCA2NSwgMCwgMTEsIDcsIDUwLCA2LCAzLCAxMDksIDExNywgMTA4LCAwLCAxLCA1LCAxMDAsIDEwNSwgMTE4LCA5NSwgMTE1LCAwLCAyLCA1LCAxMDAsIDEwNSwgMTE4LCA5NSwgMTE3LCAwLCAzLCA1LCAxMTQsIDEwMSwgMTA5LCA5NSwgMTE1LCAwLCA0LCA1LCAxMTQsIDEwMSwgMTA5LCA5NSwgMTE3LCAwLCA1LCA4LCAxMDMsIDEwMSwgMTE2LCA5NSwgMTA0LCAxMDUsIDEwMywgMTA0LCAwLCAwLCAxMCwgMTkxLCAxLCA2LCA0LCAwLCAzNSwgMCwgMTEsIDM2LCAxLCAxLCAxMjYsIDMyLCAwLCAxNzMsIDMyLCAxLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDMyLCAyLCAxNzMsIDMyLCAzLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDEyNiwgMzQsIDQsIDY2LCAzMiwgMTM1LCAxNjcsIDM2LCAwLCAzMiwgNCwgMTY3LCAxMSwgMzYsIDEsIDEsIDEyNiwgMzIsIDAsIDE3MywgMzIsIDEsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMzIsIDIsIDE3MywgMzIsIDMsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMTI3LCAzNCwgNCwgNjYsIDMyLCAxMzUsIDE2NywgMzYsIDAsIDMyLCA0LCAxNjcsIDExLCAzNiwgMSwgMSwgMTI2LCAzMiwgMCwgMTczLCAzMiwgMSwgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAzMiwgMiwgMTczLCAzMiwgMywgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAxMjgsIDM0LCA0LCA2NiwgMzIsIDEzNSwgMTY3LCAzNiwgMCwgMzIsIDQsIDE2NywgMTEsIDM2LCAxLCAxLCAxMjYsIDMyLCAwLCAxNzMsIDMyLCAxLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDMyLCAyLCAxNzMsIDMyLCAzLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDEyOSwgMzQsIDQsIDY2LCAzMiwgMTM1LCAxNjcsIDM2LCAwLCAzMiwgNCwgMTY3LCAxMSwgMzYsIDEsIDEsIDEyNiwgMzIsIDAsIDE3MywgMzIsIDEsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMzIsIDIsIDE3MywgMzIsIDMsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMTMwLCAzNCwgNCwgNjYsIDMyLCAxMzUsIDE2NywgMzYsIDAsIDMyLCA0LCAxNjcsIDExXG4gIF0pKSwge30pLmV4cG9ydHM7XG59IGNhdGNoIChlKSB7XG4gIC8vIG5vIHdhc20gc3VwcG9ydCA6KFxufVxuXG4vKipcbiAqIENvbnN0cnVjdHMgYSA2NCBiaXQgdHdvJ3MtY29tcGxlbWVudCBpbnRlZ2VyLCBnaXZlbiBpdHMgbG93IGFuZCBoaWdoIDMyIGJpdCB2YWx1ZXMgYXMgKnNpZ25lZCogaW50ZWdlcnMuXG4gKiAgU2VlIHRoZSBmcm9tKiBmdW5jdGlvbnMgYmVsb3cgZm9yIG1vcmUgY29udmVuaWVudCB3YXlzIG9mIGNvbnN0cnVjdGluZyBMb25ncy5cbiAqIEBleHBvcnRzIExvbmdcbiAqIEBjbGFzcyBBIExvbmcgY2xhc3MgZm9yIHJlcHJlc2VudGluZyBhIDY0IGJpdCB0d28ncy1jb21wbGVtZW50IGludGVnZXIgdmFsdWUuXG4gKiBAcGFyYW0ge251bWJlcn0gbG93IFRoZSBsb3cgKHNpZ25lZCkgMzIgYml0cyBvZiB0aGUgbG9uZ1xuICogQHBhcmFtIHtudW1iZXJ9IGhpZ2ggVGhlIGhpZ2ggKHNpZ25lZCkgMzIgYml0cyBvZiB0aGUgbG9uZ1xuICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3QsIGRlZmF1bHRzIHRvIHNpZ25lZFxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIExvbmcobG93LCBoaWdoLCB1bnNpZ25lZCkge1xuXG4gIC8qKlxuICAgKiBUaGUgbG93IDMyIGJpdHMgYXMgYSBzaWduZWQgdmFsdWUuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICB0aGlzLmxvdyA9IGxvdyB8IDA7XG5cbiAgLyoqXG4gICAqIFRoZSBoaWdoIDMyIGJpdHMgYXMgYSBzaWduZWQgdmFsdWUuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICB0aGlzLmhpZ2ggPSBoaWdoIHwgMDtcblxuICAvKipcbiAgICogV2hldGhlciB1bnNpZ25lZCBvciBub3QuXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgdGhpcy51bnNpZ25lZCA9ICEhdW5zaWduZWQ7XG59XG5cbi8vIFRoZSBpbnRlcm5hbCByZXByZXNlbnRhdGlvbiBvZiBhIGxvbmcgaXMgdGhlIHR3byBnaXZlbiBzaWduZWQsIDMyLWJpdCB2YWx1ZXMuXG4vLyBXZSB1c2UgMzItYml0IHBpZWNlcyBiZWNhdXNlIHRoZXNlIGFyZSB0aGUgc2l6ZSBvZiBpbnRlZ2VycyBvbiB3aGljaFxuLy8gSmF2YXNjcmlwdCBwZXJmb3JtcyBiaXQtb3BlcmF0aW9ucy4gIEZvciBvcGVyYXRpb25zIGxpa2UgYWRkaXRpb24gYW5kXG4vLyBtdWx0aXBsaWNhdGlvbiwgd2Ugc3BsaXQgZWFjaCBudW1iZXIgaW50byAxNiBiaXQgcGllY2VzLCB3aGljaCBjYW4gZWFzaWx5IGJlXG4vLyBtdWx0aXBsaWVkIHdpdGhpbiBKYXZhc2NyaXB0J3MgZmxvYXRpbmctcG9pbnQgcmVwcmVzZW50YXRpb24gd2l0aG91dCBvdmVyZmxvd1xuLy8gb3IgY2hhbmdlIGluIHNpZ24uXG4vL1xuLy8gSW4gdGhlIGFsZ29yaXRobXMgYmVsb3csIHdlIGZyZXF1ZW50bHkgcmVkdWNlIHRoZSBuZWdhdGl2ZSBjYXNlIHRvIHRoZVxuLy8gcG9zaXRpdmUgY2FzZSBieSBuZWdhdGluZyB0aGUgaW5wdXQocykgYW5kIHRoZW4gcG9zdC1wcm9jZXNzaW5nIHRoZSByZXN1bHQuXG4vLyBOb3RlIHRoYXQgd2UgbXVzdCBBTFdBWVMgY2hlY2sgc3BlY2lhbGx5IHdoZXRoZXIgdGhvc2UgdmFsdWVzIGFyZSBNSU5fVkFMVUVcbi8vICgtMl42MykgYmVjYXVzZSAtTUlOX1ZBTFVFID09IE1JTl9WQUxVRSAoc2luY2UgMl42MyBjYW5ub3QgYmUgcmVwcmVzZW50ZWQgYXNcbi8vIGEgcG9zaXRpdmUgbnVtYmVyLCBpdCBvdmVyZmxvd3MgYmFjayBpbnRvIGEgbmVnYXRpdmUpLiAgTm90IGhhbmRsaW5nIHRoaXNcbi8vIGNhc2Ugd291bGQgb2Z0ZW4gcmVzdWx0IGluIGluZmluaXRlIHJlY3Vyc2lvbi5cbi8vXG4vLyBDb21tb24gY29uc3RhbnQgdmFsdWVzIFpFUk8sIE9ORSwgTkVHX09ORSwgZXRjLiBhcmUgZGVmaW5lZCBiZWxvdyB0aGUgZnJvbSpcbi8vIG1ldGhvZHMgb24gd2hpY2ggdGhleSBkZXBlbmQuXG5cbi8qKlxuICogQW4gaW5kaWNhdG9yIHVzZWQgdG8gcmVsaWFibHkgZGV0ZXJtaW5lIGlmIGFuIG9iamVjdCBpcyBhIExvbmcgb3Igbm90LlxuICogQHR5cGUge2Jvb2xlYW59XG4gKiBAY29uc3RcbiAqIEBwcml2YXRlXG4gKi9cbkxvbmcucHJvdG90eXBlLl9faXNMb25nX187XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShMb25nLnByb3RvdHlwZSwgXCJfX2lzTG9uZ19fXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0geyp9IG9iaiBPYmplY3RcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICogQGlubmVyXG4gKi9cbmZ1bmN0aW9uIGlzTG9uZyhvYmopIHtcbiAgcmV0dXJuIChvYmogJiYgb2JqW1wiX19pc0xvbmdfX1wiXSkgPT09IHRydWU7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0geyp9IHZhbHVlIG51bWJlclxuICogQHJldHVybnMge251bWJlcn1cbiAqIEBpbm5lclxuICovXG5mdW5jdGlvbiBjdHozMih2YWx1ZSkge1xuICB2YXIgYyA9IE1hdGguY2x6MzIodmFsdWUgJiAtdmFsdWUpO1xuICByZXR1cm4gdmFsdWUgPyAzMSAtIGMgOiBjO1xufVxuXG4vKipcbiAqIFRlc3RzIGlmIHRoZSBzcGVjaWZpZWQgb2JqZWN0IGlzIGEgTG9uZy5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHsqfSBvYmogT2JqZWN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuTG9uZy5pc0xvbmcgPSBpc0xvbmc7XG5cbi8qKlxuICogQSBjYWNoZSBvZiB0aGUgTG9uZyByZXByZXNlbnRhdGlvbnMgb2Ygc21hbGwgaW50ZWdlciB2YWx1ZXMuXG4gKiBAdHlwZSB7IU9iamVjdH1cbiAqIEBpbm5lclxuICovXG52YXIgSU5UX0NBQ0hFID0ge307XG5cbi8qKlxuICogQSBjYWNoZSBvZiB0aGUgTG9uZyByZXByZXNlbnRhdGlvbnMgb2Ygc21hbGwgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuXG4gKiBAdHlwZSB7IU9iamVjdH1cbiAqIEBpbm5lclxuICovXG52YXIgVUlOVF9DQUNIRSA9IHt9O1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWRcbiAqIEByZXR1cm5zIHshTG9uZ31cbiAqIEBpbm5lclxuICovXG5mdW5jdGlvbiBmcm9tSW50KHZhbHVlLCB1bnNpZ25lZCkge1xuICB2YXIgb2JqLCBjYWNoZWRPYmosIGNhY2hlO1xuICBpZiAodW5zaWduZWQpIHtcbiAgICB2YWx1ZSA+Pj49IDA7XG4gICAgaWYgKGNhY2hlID0gKDAgPD0gdmFsdWUgJiYgdmFsdWUgPCAyNTYpKSB7XG4gICAgICBjYWNoZWRPYmogPSBVSU5UX0NBQ0hFW3ZhbHVlXTtcbiAgICAgIGlmIChjYWNoZWRPYmopXG4gICAgICAgIHJldHVybiBjYWNoZWRPYmo7XG4gICAgfVxuICAgIG9iaiA9IGZyb21CaXRzKHZhbHVlLCAwLCB0cnVlKTtcbiAgICBpZiAoY2FjaGUpXG4gICAgICBVSU5UX0NBQ0hFW3ZhbHVlXSA9IG9iajtcbiAgICByZXR1cm4gb2JqO1xuICB9IGVsc2Uge1xuICAgIHZhbHVlIHw9IDA7XG4gICAgaWYgKGNhY2hlID0gKC0xMjggPD0gdmFsdWUgJiYgdmFsdWUgPCAxMjgpKSB7XG4gICAgICBjYWNoZWRPYmogPSBJTlRfQ0FDSEVbdmFsdWVdO1xuICAgICAgaWYgKGNhY2hlZE9iailcbiAgICAgICAgcmV0dXJuIGNhY2hlZE9iajtcbiAgICB9XG4gICAgb2JqID0gZnJvbUJpdHModmFsdWUsIHZhbHVlIDwgMCA/IC0xIDogMCwgZmFsc2UpO1xuICAgIGlmIChjYWNoZSlcbiAgICAgIElOVF9DQUNIRVt2YWx1ZV0gPSBvYmo7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxufVxuXG4vKipcbiAqIFJldHVybnMgYSBMb25nIHJlcHJlc2VudGluZyB0aGUgZ2l2ZW4gMzIgYml0IGludGVnZXIgdmFsdWUuXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBUaGUgMzIgYml0IGludGVnZXIgaW4gcXVlc3Rpb25cbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBzaWduZWRcbiAqIEByZXR1cm5zIHshTG9uZ30gVGhlIGNvcnJlc3BvbmRpbmcgTG9uZyB2YWx1ZVxuICovXG5Mb25nLmZyb21JbnQgPSBmcm9tSW50O1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWRcbiAqIEByZXR1cm5zIHshTG9uZ31cbiAqIEBpbm5lclxuICovXG5mdW5jdGlvbiBmcm9tTnVtYmVyKHZhbHVlLCB1bnNpZ25lZCkge1xuICBpZiAoaXNOYU4odmFsdWUpKVxuICAgIHJldHVybiB1bnNpZ25lZCA/IFVaRVJPIDogWkVSTztcbiAgaWYgKHVuc2lnbmVkKSB7XG4gICAgaWYgKHZhbHVlIDwgMClcbiAgICAgIHJldHVybiBVWkVSTztcbiAgICBpZiAodmFsdWUgPj0gVFdPX1BXUl82NF9EQkwpXG4gICAgICByZXR1cm4gTUFYX1VOU0lHTkVEX1ZBTFVFO1xuICB9IGVsc2Uge1xuICAgIGlmICh2YWx1ZSA8PSAtVFdPX1BXUl82M19EQkwpXG4gICAgICByZXR1cm4gTUlOX1ZBTFVFO1xuICAgIGlmICh2YWx1ZSArIDEgPj0gVFdPX1BXUl82M19EQkwpXG4gICAgICByZXR1cm4gTUFYX1ZBTFVFO1xuICB9XG4gIGlmICh2YWx1ZSA8IDApXG4gICAgcmV0dXJuIGZyb21OdW1iZXIoLXZhbHVlLCB1bnNpZ25lZCkubmVnKCk7XG4gIHJldHVybiBmcm9tQml0cygodmFsdWUgJSBUV09fUFdSXzMyX0RCTCkgfCAwLCAodmFsdWUgLyBUV09fUFdSXzMyX0RCTCkgfCAwLCB1bnNpZ25lZCk7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIExvbmcgcmVwcmVzZW50aW5nIHRoZSBnaXZlbiB2YWx1ZSwgcHJvdmlkZWQgdGhhdCBpdCBpcyBhIGZpbml0ZSBudW1iZXIuIE90aGVyd2lzZSwgemVybyBpcyByZXR1cm5lZC5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFRoZSBudW1iZXIgaW4gcXVlc3Rpb25cbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBzaWduZWRcbiAqIEByZXR1cm5zIHshTG9uZ30gVGhlIGNvcnJlc3BvbmRpbmcgTG9uZyB2YWx1ZVxuICovXG5Mb25nLmZyb21OdW1iZXIgPSBmcm9tTnVtYmVyO1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBsb3dCaXRzXG4gKiBAcGFyYW0ge251bWJlcn0gaGlnaEJpdHNcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkXG4gKiBAcmV0dXJucyB7IUxvbmd9XG4gKiBAaW5uZXJcbiAqL1xuZnVuY3Rpb24gZnJvbUJpdHMobG93Qml0cywgaGlnaEJpdHMsIHVuc2lnbmVkKSB7XG4gIHJldHVybiBuZXcgTG9uZyhsb3dCaXRzLCBoaWdoQml0cywgdW5zaWduZWQpO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBMb25nIHJlcHJlc2VudGluZyB0aGUgNjQgYml0IGludGVnZXIgdGhhdCBjb21lcyBieSBjb25jYXRlbmF0aW5nIHRoZSBnaXZlbiBsb3cgYW5kIGhpZ2ggYml0cy4gRWFjaCBpc1xuICogIGFzc3VtZWQgdG8gdXNlIDMyIGJpdHMuXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSBsb3dCaXRzIFRoZSBsb3cgMzIgYml0c1xuICogQHBhcmFtIHtudW1iZXJ9IGhpZ2hCaXRzIFRoZSBoaWdoIDMyIGJpdHNcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBzaWduZWRcbiAqIEByZXR1cm5zIHshTG9uZ30gVGhlIGNvcnJlc3BvbmRpbmcgTG9uZyB2YWx1ZVxuICovXG5Mb25nLmZyb21CaXRzID0gZnJvbUJpdHM7XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gYmFzZVxuICogQHBhcmFtIHtudW1iZXJ9IGV4cG9uZW50XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICogQGlubmVyXG4gKi9cbnZhciBwb3dfZGJsID0gTWF0aC5wb3c7IC8vIFVzZWQgNCB0aW1lcyAoNCo4IHRvIDE1KzQpXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICogQHBhcmFtIHsoYm9vbGVhbnxudW1iZXIpPX0gdW5zaWduZWRcbiAqIEBwYXJhbSB7bnVtYmVyPX0gcmFkaXhcbiAqIEByZXR1cm5zIHshTG9uZ31cbiAqIEBpbm5lclxuICovXG5mdW5jdGlvbiBmcm9tU3RyaW5nKHN0ciwgdW5zaWduZWQsIHJhZGl4KSB7XG4gIGlmIChzdHIubGVuZ3RoID09PSAwKVxuICAgIHRocm93IEVycm9yKCdlbXB0eSBzdHJpbmcnKTtcbiAgaWYgKHR5cGVvZiB1bnNpZ25lZCA9PT0gJ251bWJlcicpIHtcbiAgICAvLyBGb3IgZ29vZy5tYXRoLmxvbmcgY29tcGF0aWJpbGl0eVxuICAgIHJhZGl4ID0gdW5zaWduZWQ7XG4gICAgdW5zaWduZWQgPSBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICB1bnNpZ25lZCA9ICEhdW5zaWduZWQ7XG4gIH1cbiAgaWYgKHN0ciA9PT0gXCJOYU5cIiB8fCBzdHIgPT09IFwiSW5maW5pdHlcIiB8fCBzdHIgPT09IFwiK0luZmluaXR5XCIgfHwgc3RyID09PSBcIi1JbmZpbml0eVwiKVxuICAgIHJldHVybiB1bnNpZ25lZCA/IFVaRVJPIDogWkVSTztcbiAgcmFkaXggPSByYWRpeCB8fCAxMDtcbiAgaWYgKHJhZGl4IDwgMiB8fCAzNiA8IHJhZGl4KVxuICAgIHRocm93IFJhbmdlRXJyb3IoJ3JhZGl4Jyk7XG5cbiAgdmFyIHA7XG4gIGlmICgocCA9IHN0ci5pbmRleE9mKCctJykpID4gMClcbiAgICB0aHJvdyBFcnJvcignaW50ZXJpb3IgaHlwaGVuJyk7XG4gIGVsc2UgaWYgKHAgPT09IDApIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyhzdHIuc3Vic3RyaW5nKDEpLCB1bnNpZ25lZCwgcmFkaXgpLm5lZygpO1xuICB9XG5cbiAgLy8gRG8gc2V2ZXJhbCAoOCkgZGlnaXRzIGVhY2ggdGltZSB0aHJvdWdoIHRoZSBsb29wLCBzbyBhcyB0b1xuICAvLyBtaW5pbWl6ZSB0aGUgY2FsbHMgdG8gdGhlIHZlcnkgZXhwZW5zaXZlIGVtdWxhdGVkIGRpdi5cbiAgdmFyIHJhZGl4VG9Qb3dlciA9IGZyb21OdW1iZXIocG93X2RibChyYWRpeCwgOCkpO1xuXG4gIHZhciByZXN1bHQgPSBaRVJPO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkgKz0gOCkge1xuICAgIHZhciBzaXplID0gTWF0aC5taW4oOCwgc3RyLmxlbmd0aCAtIGkpLFxuICAgICAgdmFsdWUgPSBwYXJzZUludChzdHIuc3Vic3RyaW5nKGksIGkgKyBzaXplKSwgcmFkaXgpO1xuICAgIGlmIChzaXplIDwgOCkge1xuICAgICAgdmFyIHBvd2VyID0gZnJvbU51bWJlcihwb3dfZGJsKHJhZGl4LCBzaXplKSk7XG4gICAgICByZXN1bHQgPSByZXN1bHQubXVsKHBvd2VyKS5hZGQoZnJvbU51bWJlcih2YWx1ZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSByZXN1bHQubXVsKHJhZGl4VG9Qb3dlcik7XG4gICAgICByZXN1bHQgPSByZXN1bHQuYWRkKGZyb21OdW1iZXIodmFsdWUpKTtcbiAgICB9XG4gIH1cbiAgcmVzdWx0LnVuc2lnbmVkID0gdW5zaWduZWQ7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIExvbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIHN0cmluZywgd3JpdHRlbiB1c2luZyB0aGUgc3BlY2lmaWVkIHJhZGl4LlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIFRoZSB0ZXh0dWFsIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBMb25nXG4gKiBAcGFyYW0geyhib29sZWFufG51bWJlcik9fSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdCwgZGVmYXVsdHMgdG8gc2lnbmVkXG4gKiBAcGFyYW0ge251bWJlcj19IHJhZGl4IFRoZSByYWRpeCBpbiB3aGljaCB0aGUgdGV4dCBpcyB3cml0dGVuICgyLTM2KSwgZGVmYXVsdHMgdG8gMTBcbiAqIEByZXR1cm5zIHshTG9uZ30gVGhlIGNvcnJlc3BvbmRpbmcgTG9uZyB2YWx1ZVxuICovXG5Mb25nLmZyb21TdHJpbmcgPSBmcm9tU3RyaW5nO1xuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfCF7bG93OiBudW1iZXIsIGhpZ2g6IG51bWJlciwgdW5zaWduZWQ6IGJvb2xlYW59fSB2YWxcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkXG4gKiBAcmV0dXJucyB7IUxvbmd9XG4gKiBAaW5uZXJcbiAqL1xuZnVuY3Rpb24gZnJvbVZhbHVlKHZhbCwgdW5zaWduZWQpIHtcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKVxuICAgIHJldHVybiBmcm9tTnVtYmVyKHZhbCwgdW5zaWduZWQpO1xuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpXG4gICAgcmV0dXJuIGZyb21TdHJpbmcodmFsLCB1bnNpZ25lZCk7XG4gIC8vIFRocm93cyBmb3Igbm9uLW9iamVjdHMsIGNvbnZlcnRzIG5vbi1pbnN0YW5jZW9mIExvbmc6XG4gIHJldHVybiBmcm9tQml0cyh2YWwubG93LCB2YWwuaGlnaCwgdHlwZW9mIHVuc2lnbmVkID09PSAnYm9vbGVhbicgPyB1bnNpZ25lZCA6IHZhbC51bnNpZ25lZCk7XG59XG5cbi8qKlxuICogQ29udmVydHMgdGhlIHNwZWNpZmllZCB2YWx1ZSB0byBhIExvbmcgdXNpbmcgdGhlIGFwcHJvcHJpYXRlIGZyb20qIGZ1bmN0aW9uIGZvciBpdHMgdHlwZS5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfCF7bG93OiBudW1iZXIsIGhpZ2g6IG51bWJlciwgdW5zaWduZWQ6IGJvb2xlYW59fSB2YWwgVmFsdWVcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBzaWduZWRcbiAqIEByZXR1cm5zIHshTG9uZ31cbiAqL1xuTG9uZy5mcm9tVmFsdWUgPSBmcm9tVmFsdWU7XG5cbi8vIE5PVEU6IHRoZSBjb21waWxlciBzaG91bGQgaW5saW5lIHRoZXNlIGNvbnN0YW50IHZhbHVlcyBiZWxvdyBhbmQgdGhlbiByZW1vdmUgdGhlc2UgdmFyaWFibGVzLCBzbyB0aGVyZSBzaG91bGQgYmVcbi8vIG5vIHJ1bnRpbWUgcGVuYWx0eSBmb3IgdGhlc2UuXG5cbi8qKlxuICogQHR5cGUge251bWJlcn1cbiAqIEBjb25zdFxuICogQGlubmVyXG4gKi9cbnZhciBUV09fUFdSXzE2X0RCTCA9IDEgPDwgMTY7XG5cbi8qKlxuICogQHR5cGUge251bWJlcn1cbiAqIEBjb25zdFxuICogQGlubmVyXG4gKi9cbnZhciBUV09fUFdSXzI0X0RCTCA9IDEgPDwgMjQ7XG5cbi8qKlxuICogQHR5cGUge251bWJlcn1cbiAqIEBjb25zdFxuICogQGlubmVyXG4gKi9cbnZhciBUV09fUFdSXzMyX0RCTCA9IFRXT19QV1JfMTZfREJMICogVFdPX1BXUl8xNl9EQkw7XG5cbi8qKlxuICogQHR5cGUge251bWJlcn1cbiAqIEBjb25zdFxuICogQGlubmVyXG4gKi9cbnZhciBUV09fUFdSXzY0X0RCTCA9IFRXT19QV1JfMzJfREJMICogVFdPX1BXUl8zMl9EQkw7XG5cbi8qKlxuICogQHR5cGUge251bWJlcn1cbiAqIEBjb25zdFxuICogQGlubmVyXG4gKi9cbnZhciBUV09fUFdSXzYzX0RCTCA9IFRXT19QV1JfNjRfREJMIC8gMjtcblxuLyoqXG4gKiBAdHlwZSB7IUxvbmd9XG4gKiBAY29uc3RcbiAqIEBpbm5lclxuICovXG52YXIgVFdPX1BXUl8yNCA9IGZyb21JbnQoVFdPX1BXUl8yNF9EQkwpO1xuXG4vKipcbiAqIEB0eXBlIHshTG9uZ31cbiAqIEBpbm5lclxuICovXG52YXIgWkVSTyA9IGZyb21JbnQoMCk7XG5cbi8qKlxuICogU2lnbmVkIHplcm8uXG4gKiBAdHlwZSB7IUxvbmd9XG4gKi9cbkxvbmcuWkVSTyA9IFpFUk87XG5cbi8qKlxuICogQHR5cGUgeyFMb25nfVxuICogQGlubmVyXG4gKi9cbnZhciBVWkVSTyA9IGZyb21JbnQoMCwgdHJ1ZSk7XG5cbi8qKlxuICogVW5zaWduZWQgemVyby5cbiAqIEB0eXBlIHshTG9uZ31cbiAqL1xuTG9uZy5VWkVSTyA9IFVaRVJPO1xuXG4vKipcbiAqIEB0eXBlIHshTG9uZ31cbiAqIEBpbm5lclxuICovXG52YXIgT05FID0gZnJvbUludCgxKTtcblxuLyoqXG4gKiBTaWduZWQgb25lLlxuICogQHR5cGUgeyFMb25nfVxuICovXG5Mb25nLk9ORSA9IE9ORTtcblxuLyoqXG4gKiBAdHlwZSB7IUxvbmd9XG4gKiBAaW5uZXJcbiAqL1xudmFyIFVPTkUgPSBmcm9tSW50KDEsIHRydWUpO1xuXG4vKipcbiAqIFVuc2lnbmVkIG9uZS5cbiAqIEB0eXBlIHshTG9uZ31cbiAqL1xuTG9uZy5VT05FID0gVU9ORTtcblxuLyoqXG4gKiBAdHlwZSB7IUxvbmd9XG4gKiBAaW5uZXJcbiAqL1xudmFyIE5FR19PTkUgPSBmcm9tSW50KC0xKTtcblxuLyoqXG4gKiBTaWduZWQgbmVnYXRpdmUgb25lLlxuICogQHR5cGUgeyFMb25nfVxuICovXG5Mb25nLk5FR19PTkUgPSBORUdfT05FO1xuXG4vKipcbiAqIEB0eXBlIHshTG9uZ31cbiAqIEBpbm5lclxuICovXG52YXIgTUFYX1ZBTFVFID0gZnJvbUJpdHMoMHhGRkZGRkZGRiB8IDAsIDB4N0ZGRkZGRkYgfCAwLCBmYWxzZSk7XG5cbi8qKlxuICogTWF4aW11bSBzaWduZWQgdmFsdWUuXG4gKiBAdHlwZSB7IUxvbmd9XG4gKi9cbkxvbmcuTUFYX1ZBTFVFID0gTUFYX1ZBTFVFO1xuXG4vKipcbiAqIEB0eXBlIHshTG9uZ31cbiAqIEBpbm5lclxuICovXG52YXIgTUFYX1VOU0lHTkVEX1ZBTFVFID0gZnJvbUJpdHMoMHhGRkZGRkZGRiB8IDAsIDB4RkZGRkZGRkYgfCAwLCB0cnVlKTtcblxuLyoqXG4gKiBNYXhpbXVtIHVuc2lnbmVkIHZhbHVlLlxuICogQHR5cGUgeyFMb25nfVxuICovXG5Mb25nLk1BWF9VTlNJR05FRF9WQUxVRSA9IE1BWF9VTlNJR05FRF9WQUxVRTtcblxuLyoqXG4gKiBAdHlwZSB7IUxvbmd9XG4gKiBAaW5uZXJcbiAqL1xudmFyIE1JTl9WQUxVRSA9IGZyb21CaXRzKDAsIDB4ODAwMDAwMDAgfCAwLCBmYWxzZSk7XG5cbi8qKlxuICogTWluaW11bSBzaWduZWQgdmFsdWUuXG4gKiBAdHlwZSB7IUxvbmd9XG4gKi9cbkxvbmcuTUlOX1ZBTFVFID0gTUlOX1ZBTFVFO1xuXG4vKipcbiAqIEBhbGlhcyBMb25nLnByb3RvdHlwZVxuICogQGlubmVyXG4gKi9cbnZhciBMb25nUHJvdG90eXBlID0gTG9uZy5wcm90b3R5cGU7XG5cbi8qKlxuICogQ29udmVydHMgdGhlIExvbmcgdG8gYSAzMiBiaXQgaW50ZWdlciwgYXNzdW1pbmcgaXQgaXMgYSAzMiBiaXQgaW50ZWdlci5cbiAqIEB0aGlzIHshTG9uZ31cbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbkxvbmdQcm90b3R5cGUudG9JbnQgPSBmdW5jdGlvbiB0b0ludCgpIHtcbiAgcmV0dXJuIHRoaXMudW5zaWduZWQgPyB0aGlzLmxvdyA+Pj4gMCA6IHRoaXMubG93O1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGUgTG9uZyB0byBhIHRoZSBuZWFyZXN0IGZsb2F0aW5nLXBvaW50IHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgdmFsdWUgKGRvdWJsZSwgNTMgYml0IG1hbnRpc3NhKS5cbiAqIEB0aGlzIHshTG9uZ31cbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbkxvbmdQcm90b3R5cGUudG9OdW1iZXIgPSBmdW5jdGlvbiB0b051bWJlcigpIHtcbiAgaWYgKHRoaXMudW5zaWduZWQpXG4gICAgcmV0dXJuICgodGhpcy5oaWdoID4+PiAwKSAqIFRXT19QV1JfMzJfREJMKSArICh0aGlzLmxvdyA+Pj4gMCk7XG4gIHJldHVybiB0aGlzLmhpZ2ggKiBUV09fUFdSXzMyX0RCTCArICh0aGlzLmxvdyA+Pj4gMCk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoZSBMb25nIHRvIGEgc3RyaW5nIHdyaXR0ZW4gaW4gdGhlIHNwZWNpZmllZCByYWRpeC5cbiAqIEB0aGlzIHshTG9uZ31cbiAqIEBwYXJhbSB7bnVtYmVyPX0gcmFkaXggUmFkaXggKDItMzYpLCBkZWZhdWx0cyB0byAxMFxuICogQHJldHVybnMge3N0cmluZ31cbiAqIEBvdmVycmlkZVxuICogQHRocm93cyB7UmFuZ2VFcnJvcn0gSWYgYHJhZGl4YCBpcyBvdXQgb2YgcmFuZ2VcbiAqL1xuTG9uZ1Byb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKHJhZGl4KSB7XG4gIHJhZGl4ID0gcmFkaXggfHwgMTA7XG4gIGlmIChyYWRpeCA8IDIgfHwgMzYgPCByYWRpeClcbiAgICB0aHJvdyBSYW5nZUVycm9yKCdyYWRpeCcpO1xuICBpZiAodGhpcy5pc1plcm8oKSlcbiAgICByZXR1cm4gJzAnO1xuICBpZiAodGhpcy5pc05lZ2F0aXZlKCkpIHsgLy8gVW5zaWduZWQgTG9uZ3MgYXJlIG5ldmVyIG5lZ2F0aXZlXG4gICAgaWYgKHRoaXMuZXEoTUlOX1ZBTFVFKSkge1xuICAgICAgLy8gV2UgbmVlZCB0byBjaGFuZ2UgdGhlIExvbmcgdmFsdWUgYmVmb3JlIGl0IGNhbiBiZSBuZWdhdGVkLCBzbyB3ZSByZW1vdmVcbiAgICAgIC8vIHRoZSBib3R0b20tbW9zdCBkaWdpdCBpbiB0aGlzIGJhc2UgYW5kIHRoZW4gcmVjdXJzZSB0byBkbyB0aGUgcmVzdC5cbiAgICAgIHZhciByYWRpeExvbmcgPSBmcm9tTnVtYmVyKHJhZGl4KSxcbiAgICAgICAgZGl2ID0gdGhpcy5kaXYocmFkaXhMb25nKSxcbiAgICAgICAgcmVtMSA9IGRpdi5tdWwocmFkaXhMb25nKS5zdWIodGhpcyk7XG4gICAgICByZXR1cm4gZGl2LnRvU3RyaW5nKHJhZGl4KSArIHJlbTEudG9JbnQoKS50b1N0cmluZyhyYWRpeCk7XG4gICAgfSBlbHNlXG4gICAgICByZXR1cm4gJy0nICsgdGhpcy5uZWcoKS50b1N0cmluZyhyYWRpeCk7XG4gIH1cblxuICAvLyBEbyBzZXZlcmFsICg2KSBkaWdpdHMgZWFjaCB0aW1lIHRocm91Z2ggdGhlIGxvb3AsIHNvIGFzIHRvXG4gIC8vIG1pbmltaXplIHRoZSBjYWxscyB0byB0aGUgdmVyeSBleHBlbnNpdmUgZW11bGF0ZWQgZGl2LlxuICB2YXIgcmFkaXhUb1Bvd2VyID0gZnJvbU51bWJlcihwb3dfZGJsKHJhZGl4LCA2KSwgdGhpcy51bnNpZ25lZCksXG4gICAgcmVtID0gdGhpcztcbiAgdmFyIHJlc3VsdCA9ICcnO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIHZhciByZW1EaXYgPSByZW0uZGl2KHJhZGl4VG9Qb3dlciksXG4gICAgICBpbnR2YWwgPSByZW0uc3ViKHJlbURpdi5tdWwocmFkaXhUb1Bvd2VyKSkudG9JbnQoKSA+Pj4gMCxcbiAgICAgIGRpZ2l0cyA9IGludHZhbC50b1N0cmluZyhyYWRpeCk7XG4gICAgcmVtID0gcmVtRGl2O1xuICAgIGlmIChyZW0uaXNaZXJvKCkpXG4gICAgICByZXR1cm4gZGlnaXRzICsgcmVzdWx0O1xuICAgIGVsc2Uge1xuICAgICAgd2hpbGUgKGRpZ2l0cy5sZW5ndGggPCA2KVxuICAgICAgICBkaWdpdHMgPSAnMCcgKyBkaWdpdHM7XG4gICAgICByZXN1bHQgPSAnJyArIGRpZ2l0cyArIHJlc3VsdDtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogR2V0cyB0aGUgaGlnaCAzMiBiaXRzIGFzIGEgc2lnbmVkIGludGVnZXIuXG4gKiBAdGhpcyB7IUxvbmd9XG4gKiBAcmV0dXJucyB7bnVtYmVyfSBTaWduZWQgaGlnaCBiaXRzXG4gKi9cbkxvbmdQcm90b3R5cGUuZ2V0SGlnaEJpdHMgPSBmdW5jdGlvbiBnZXRIaWdoQml0cygpIHtcbiAgcmV0dXJuIHRoaXMuaGlnaDtcbn07XG5cbi8qKlxuICogR2V0cyB0aGUgaGlnaCAzMiBiaXRzIGFzIGFuIHVuc2lnbmVkIGludGVnZXIuXG4gKiBAdGhpcyB7IUxvbmd9XG4gKiBAcmV0dXJucyB7bnVtYmVyfSBVbnNpZ25lZCBoaWdoIGJpdHNcbiAqL1xuTG9uZ1Byb3RvdHlwZS5nZXRIaWdoQml0c1Vuc2lnbmVkID0gZnVuY3Rpb24gZ2V0SGlnaEJpdHNVbnNpZ25lZCgpIHtcbiAgcmV0dXJuIHRoaXMuaGlnaCA+Pj4gMDtcbn07XG5cbi8qKlxuICogR2V0cyB0aGUgbG93IDMyIGJpdHMgYXMgYSBzaWduZWQgaW50ZWdlci5cbiAqIEB0aGlzIHshTG9uZ31cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFNpZ25lZCBsb3cgYml0c1xuICovXG5Mb25nUHJvdG90eXBlLmdldExvd0JpdHMgPSBmdW5jdGlvbiBnZXRMb3dCaXRzKCkge1xuICByZXR1cm4gdGhpcy5sb3c7XG59O1xuXG4vKipcbiAqIEdldHMgdGhlIGxvdyAzMiBiaXRzIGFzIGFuIHVuc2lnbmVkIGludGVnZXIuXG4gKiBAdGhpcyB7IUxvbmd9XG4gKiBAcmV0dXJucyB7bnVtYmVyfSBVbnNpZ25lZCBsb3cgYml0c1xuICovXG5Mb25nUHJvdG90eXBlLmdldExvd0JpdHNVbnNpZ25lZCA9IGZ1bmN0aW9uIGdldExvd0JpdHNVbnNpZ25lZCgpIHtcbiAgcmV0dXJuIHRoaXMubG93ID4+PiAwO1xufTtcblxuLyoqXG4gKiBHZXRzIHRoZSBudW1iZXIgb2YgYml0cyBuZWVkZWQgdG8gcmVwcmVzZW50IHRoZSBhYnNvbHV0ZSB2YWx1ZSBvZiB0aGlzIExvbmcuXG4gKiBAdGhpcyB7IUxvbmd9XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5Mb25nUHJvdG90eXBlLmdldE51bUJpdHNBYnMgPSBmdW5jdGlvbiBnZXROdW1CaXRzQWJzKCkge1xuICBpZiAodGhpcy5pc05lZ2F0aXZlKCkpIC8vIFVuc2lnbmVkIExvbmdzIGFyZSBuZXZlciBuZWdhdGl2ZVxuICAgIHJldHVybiB0aGlzLmVxKE1JTl9WQUxVRSkgPyA2NCA6IHRoaXMubmVnKCkuZ2V0TnVtQml0c0FicygpO1xuICB2YXIgdmFsID0gdGhpcy5oaWdoICE9IDAgPyB0aGlzLmhpZ2ggOiB0aGlzLmxvdztcbiAgZm9yICh2YXIgYml0ID0gMzE7IGJpdCA+IDA7IGJpdC0tKVxuICAgIGlmICgodmFsICYgKDEgPDwgYml0KSkgIT0gMClcbiAgICAgIGJyZWFrO1xuICByZXR1cm4gdGhpcy5oaWdoICE9IDAgPyBiaXQgKyAzMyA6IGJpdCArIDE7XG59O1xuXG4vKipcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGVxdWFscyB6ZXJvLlxuICogQHRoaXMgeyFMb25nfVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbkxvbmdQcm90b3R5cGUuaXNaZXJvID0gZnVuY3Rpb24gaXNaZXJvKCkge1xuICByZXR1cm4gdGhpcy5oaWdoID09PSAwICYmIHRoaXMubG93ID09PSAwO1xufTtcblxuLyoqXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBlcXVhbHMgemVyby4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNpc1plcm99LlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbkxvbmdQcm90b3R5cGUuZXF6ID0gTG9uZ1Byb3RvdHlwZS5pc1plcm87XG5cbi8qKlxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgbmVnYXRpdmUuXG4gKiBAdGhpcyB7IUxvbmd9XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuTG9uZ1Byb3RvdHlwZS5pc05lZ2F0aXZlID0gZnVuY3Rpb24gaXNOZWdhdGl2ZSgpIHtcbiAgcmV0dXJuICF0aGlzLnVuc2lnbmVkICYmIHRoaXMuaGlnaCA8IDA7XG59O1xuXG4vKipcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIHBvc2l0aXZlIG9yIHplcm8uXG4gKiBAdGhpcyB7IUxvbmd9XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuTG9uZ1Byb3RvdHlwZS5pc1Bvc2l0aXZlID0gZnVuY3Rpb24gaXNQb3NpdGl2ZSgpIHtcbiAgcmV0dXJuIHRoaXMudW5zaWduZWQgfHwgdGhpcy5oaWdoID49IDA7XG59O1xuXG4vKipcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIG9kZC5cbiAqIEB0aGlzIHshTG9uZ31cbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5Mb25nUHJvdG90eXBlLmlzT2RkID0gZnVuY3Rpb24gaXNPZGQoKSB7XG4gIHJldHVybiAodGhpcy5sb3cgJiAxKSA9PT0gMTtcbn07XG5cbi8qKlxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgZXZlbi5cbiAqIEB0aGlzIHshTG9uZ31cbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5Mb25nUHJvdG90eXBlLmlzRXZlbiA9IGZ1bmN0aW9uIGlzRXZlbigpIHtcbiAgcmV0dXJuICh0aGlzLmxvdyAmIDEpID09PSAwO1xufTtcblxuLyoqXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBlcXVhbHMgdGhlIHNwZWNpZmllZCdzLlxuICogQHRoaXMgeyFMb25nfVxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbkxvbmdQcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzKG90aGVyKSB7XG4gIGlmICghaXNMb25nKG90aGVyKSlcbiAgICBvdGhlciA9IGZyb21WYWx1ZShvdGhlcik7XG4gIGlmICh0aGlzLnVuc2lnbmVkICE9PSBvdGhlci51bnNpZ25lZCAmJiAodGhpcy5oaWdoID4+PiAzMSkgPT09IDEgJiYgKG90aGVyLmhpZ2ggPj4+IDMxKSA9PT0gMSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIHJldHVybiB0aGlzLmhpZ2ggPT09IG90aGVyLmhpZ2ggJiYgdGhpcy5sb3cgPT09IG90aGVyLmxvdztcbn07XG5cbi8qKlxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgZXF1YWxzIHRoZSBzcGVjaWZpZWQncy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNlcXVhbHN9LlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuTG9uZ1Byb3RvdHlwZS5lcSA9IExvbmdQcm90b3R5cGUuZXF1YWxzO1xuXG4vKipcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGRpZmZlcnMgZnJvbSB0aGUgc3BlY2lmaWVkJ3MuXG4gKiBAdGhpcyB7IUxvbmd9XG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuTG9uZ1Byb3RvdHlwZS5ub3RFcXVhbHMgPSBmdW5jdGlvbiBub3RFcXVhbHMob3RoZXIpIHtcbiAgcmV0dXJuICF0aGlzLmVxKC8qIHZhbGlkYXRlcyAqLyBvdGhlcik7XG59O1xuXG4vKipcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGRpZmZlcnMgZnJvbSB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjbm90RXF1YWxzfS5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbkxvbmdQcm90b3R5cGUubmVxID0gTG9uZ1Byb3RvdHlwZS5ub3RFcXVhbHM7XG5cbi8qKlxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgZGlmZmVycyBmcm9tIHRoZSBzcGVjaWZpZWQncy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNub3RFcXVhbHN9LlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuTG9uZ1Byb3RvdHlwZS5uZSA9IExvbmdQcm90b3R5cGUubm90RXF1YWxzO1xuXG4vKipcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGxlc3MgdGhhbiB0aGUgc3BlY2lmaWVkJ3MuXG4gKiBAdGhpcyB7IUxvbmd9XG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuTG9uZ1Byb3RvdHlwZS5sZXNzVGhhbiA9IGZ1bmN0aW9uIGxlc3NUaGFuKG90aGVyKSB7XG4gIHJldHVybiB0aGlzLmNvbXAoLyogdmFsaWRhdGVzICovIG90aGVyKSA8IDA7XG59O1xuXG4vKipcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGxlc3MgdGhhbiB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjbGVzc1RoYW59LlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuTG9uZ1Byb3RvdHlwZS5sdCA9IExvbmdQcm90b3R5cGUubGVzc1RoYW47XG5cbi8qKlxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRoZSBzcGVjaWZpZWQncy5cbiAqIEB0aGlzIHshTG9uZ31cbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5Mb25nUHJvdG90eXBlLmxlc3NUaGFuT3JFcXVhbCA9IGZ1bmN0aW9uIGxlc3NUaGFuT3JFcXVhbChvdGhlcikge1xuICByZXR1cm4gdGhpcy5jb21wKC8qIHZhbGlkYXRlcyAqLyBvdGhlcikgPD0gMDtcbn07XG5cbi8qKlxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRoZSBzcGVjaWZpZWQncy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNsZXNzVGhhbk9yRXF1YWx9LlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuTG9uZ1Byb3RvdHlwZS5sdGUgPSBMb25nUHJvdG90eXBlLmxlc3NUaGFuT3JFcXVhbDtcblxuLyoqXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2xlc3NUaGFuT3JFcXVhbH0uXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5Mb25nUHJvdG90eXBlLmxlID0gTG9uZ1Byb3RvdHlwZS5sZXNzVGhhbk9yRXF1YWw7XG5cbi8qKlxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIHRoZSBzcGVjaWZpZWQncy5cbiAqIEB0aGlzIHshTG9uZ31cbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5Mb25nUHJvdG90eXBlLmdyZWF0ZXJUaGFuID0gZnVuY3Rpb24gZ3JlYXRlclRoYW4ob3RoZXIpIHtcbiAgcmV0dXJuIHRoaXMuY29tcCgvKiB2YWxpZGF0ZXMgKi8gb3RoZXIpID4gMDtcbn07XG5cbi8qKlxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIHRoZSBzcGVjaWZpZWQncy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNncmVhdGVyVGhhbn0uXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5Mb25nUHJvdG90eXBlLmd0ID0gTG9uZ1Byb3RvdHlwZS5ncmVhdGVyVGhhbjtcblxuLyoqXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdGhlIHNwZWNpZmllZCdzLlxuICogQHRoaXMgeyFMb25nfVxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbkxvbmdQcm90b3R5cGUuZ3JlYXRlclRoYW5PckVxdWFsID0gZnVuY3Rpb24gZ3JlYXRlclRoYW5PckVxdWFsKG90aGVyKSB7XG4gIHJldHVybiB0aGlzLmNvbXAoLyogdmFsaWRhdGVzICovIG90aGVyKSA+PSAwO1xufTtcblxuLyoqXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2dyZWF0ZXJUaGFuT3JFcXVhbH0uXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5Mb25nUHJvdG90eXBlLmd0ZSA9IExvbmdQcm90b3R5cGUuZ3JlYXRlclRoYW5PckVxdWFsO1xuXG4vKipcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjZ3JlYXRlclRoYW5PckVxdWFsfS5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbkxvbmdQcm90b3R5cGUuZ2UgPSBMb25nUHJvdG90eXBlLmdyZWF0ZXJUaGFuT3JFcXVhbDtcblxuLyoqXG4gKiBDb21wYXJlcyB0aGlzIExvbmcncyB2YWx1ZSB3aXRoIHRoZSBzcGVjaWZpZWQncy5cbiAqIEB0aGlzIHshTG9uZ31cbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcbiAqIEByZXR1cm5zIHtudW1iZXJ9IDAgaWYgdGhleSBhcmUgdGhlIHNhbWUsIDEgaWYgdGhlIHRoaXMgaXMgZ3JlYXRlciBhbmQgLTFcbiAqICBpZiB0aGUgZ2l2ZW4gb25lIGlzIGdyZWF0ZXJcbiAqL1xuTG9uZ1Byb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZShvdGhlcikge1xuICBpZiAoIWlzTG9uZyhvdGhlcikpXG4gICAgb3RoZXIgPSBmcm9tVmFsdWUob3RoZXIpO1xuICBpZiAodGhpcy5lcShvdGhlcikpXG4gICAgcmV0dXJuIDA7XG4gIHZhciB0aGlzTmVnID0gdGhpcy5pc05lZ2F0aXZlKCksXG4gICAgb3RoZXJOZWcgPSBvdGhlci5pc05lZ2F0aXZlKCk7XG4gIGlmICh0aGlzTmVnICYmICFvdGhlck5lZylcbiAgICByZXR1cm4gLTE7XG4gIGlmICghdGhpc05lZyAmJiBvdGhlck5lZylcbiAgICByZXR1cm4gMTtcbiAgLy8gQXQgdGhpcyBwb2ludCB0aGUgc2lnbiBiaXRzIGFyZSB0aGUgc2FtZVxuICBpZiAoIXRoaXMudW5zaWduZWQpXG4gICAgcmV0dXJuIHRoaXMuc3ViKG90aGVyKS5pc05lZ2F0aXZlKCkgPyAtMSA6IDE7XG4gIC8vIEJvdGggYXJlIHBvc2l0aXZlIGlmIGF0IGxlYXN0IG9uZSBpcyB1bnNpZ25lZFxuICByZXR1cm4gKG90aGVyLmhpZ2ggPj4+IDApID4gKHRoaXMuaGlnaCA+Pj4gMCkgfHwgKG90aGVyLmhpZ2ggPT09IHRoaXMuaGlnaCAmJiAob3RoZXIubG93ID4+PiAwKSA+ICh0aGlzLmxvdyA+Pj4gMCkpID8gLTEgOiAxO1xufTtcblxuLyoqXG4gKiBDb21wYXJlcyB0aGlzIExvbmcncyB2YWx1ZSB3aXRoIHRoZSBzcGVjaWZpZWQncy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNjb21wYXJlfS5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxuICogQHJldHVybnMge251bWJlcn0gMCBpZiB0aGV5IGFyZSB0aGUgc2FtZSwgMSBpZiB0aGUgdGhpcyBpcyBncmVhdGVyIGFuZCAtMVxuICogIGlmIHRoZSBnaXZlbiBvbmUgaXMgZ3JlYXRlclxuICovXG5Mb25nUHJvdG90eXBlLmNvbXAgPSBMb25nUHJvdG90eXBlLmNvbXBhcmU7XG5cbi8qKlxuICogTmVnYXRlcyB0aGlzIExvbmcncyB2YWx1ZS5cbiAqIEB0aGlzIHshTG9uZ31cbiAqIEByZXR1cm5zIHshTG9uZ30gTmVnYXRlZCBMb25nXG4gKi9cbkxvbmdQcm90b3R5cGUubmVnYXRlID0gZnVuY3Rpb24gbmVnYXRlKCkge1xuICBpZiAoIXRoaXMudW5zaWduZWQgJiYgdGhpcy5lcShNSU5fVkFMVUUpKVxuICAgIHJldHVybiBNSU5fVkFMVUU7XG4gIHJldHVybiB0aGlzLm5vdCgpLmFkZChPTkUpO1xufTtcblxuLyoqXG4gKiBOZWdhdGVzIHRoaXMgTG9uZydzIHZhbHVlLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI25lZ2F0ZX0uXG4gKiBAZnVuY3Rpb25cbiAqIEByZXR1cm5zIHshTG9uZ30gTmVnYXRlZCBMb25nXG4gKi9cbkxvbmdQcm90b3R5cGUubmVnID0gTG9uZ1Byb3RvdHlwZS5uZWdhdGU7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgc3VtIG9mIHRoaXMgYW5kIHRoZSBzcGVjaWZpZWQgTG9uZy5cbiAqIEB0aGlzIHshTG9uZ31cbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gYWRkZW5kIEFkZGVuZFxuICogQHJldHVybnMgeyFMb25nfSBTdW1cbiAqL1xuTG9uZ1Byb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQoYWRkZW5kKSB7XG4gIGlmICghaXNMb25nKGFkZGVuZCkpXG4gICAgYWRkZW5kID0gZnJvbVZhbHVlKGFkZGVuZCk7XG5cbiAgLy8gRGl2aWRlIGVhY2ggbnVtYmVyIGludG8gNCBjaHVua3Mgb2YgMTYgYml0cywgYW5kIHRoZW4gc3VtIHRoZSBjaHVua3MuXG5cbiAgdmFyIGE0OCA9IHRoaXMuaGlnaCA+Pj4gMTY7XG4gIHZhciBhMzIgPSB0aGlzLmhpZ2ggJiAweEZGRkY7XG4gIHZhciBhMTYgPSB0aGlzLmxvdyA+Pj4gMTY7XG4gIHZhciBhMDAgPSB0aGlzLmxvdyAmIDB4RkZGRjtcblxuICB2YXIgYjQ4ID0gYWRkZW5kLmhpZ2ggPj4+IDE2O1xuICB2YXIgYjMyID0gYWRkZW5kLmhpZ2ggJiAweEZGRkY7XG4gIHZhciBiMTYgPSBhZGRlbmQubG93ID4+PiAxNjtcbiAgdmFyIGIwMCA9IGFkZGVuZC5sb3cgJiAweEZGRkY7XG5cbiAgdmFyIGM0OCA9IDAsIGMzMiA9IDAsIGMxNiA9IDAsIGMwMCA9IDA7XG4gIGMwMCArPSBhMDAgKyBiMDA7XG4gIGMxNiArPSBjMDAgPj4+IDE2O1xuICBjMDAgJj0gMHhGRkZGO1xuICBjMTYgKz0gYTE2ICsgYjE2O1xuICBjMzIgKz0gYzE2ID4+PiAxNjtcbiAgYzE2ICY9IDB4RkZGRjtcbiAgYzMyICs9IGEzMiArIGIzMjtcbiAgYzQ4ICs9IGMzMiA+Pj4gMTY7XG4gIGMzMiAmPSAweEZGRkY7XG4gIGM0OCArPSBhNDggKyBiNDg7XG4gIGM0OCAmPSAweEZGRkY7XG4gIHJldHVybiBmcm9tQml0cygoYzE2IDw8IDE2KSB8IGMwMCwgKGM0OCA8PCAxNikgfCBjMzIsIHRoaXMudW5zaWduZWQpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBkaWZmZXJlbmNlIG9mIHRoaXMgYW5kIHRoZSBzcGVjaWZpZWQgTG9uZy5cbiAqIEB0aGlzIHshTG9uZ31cbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gc3VidHJhaGVuZCBTdWJ0cmFoZW5kXG4gKiBAcmV0dXJucyB7IUxvbmd9IERpZmZlcmVuY2VcbiAqL1xuTG9uZ1Byb3RvdHlwZS5zdWJ0cmFjdCA9IGZ1bmN0aW9uIHN1YnRyYWN0KHN1YnRyYWhlbmQpIHtcbiAgaWYgKCFpc0xvbmcoc3VidHJhaGVuZCkpXG4gICAgc3VidHJhaGVuZCA9IGZyb21WYWx1ZShzdWJ0cmFoZW5kKTtcbiAgcmV0dXJuIHRoaXMuYWRkKHN1YnRyYWhlbmQubmVnKCkpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBkaWZmZXJlbmNlIG9mIHRoaXMgYW5kIHRoZSBzcGVjaWZpZWQgTG9uZy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNzdWJ0cmFjdH0uXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gc3VidHJhaGVuZCBTdWJ0cmFoZW5kXG4gKiBAcmV0dXJucyB7IUxvbmd9IERpZmZlcmVuY2VcbiAqL1xuTG9uZ1Byb3RvdHlwZS5zdWIgPSBMb25nUHJvdG90eXBlLnN1YnRyYWN0O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHByb2R1Y3Qgb2YgdGhpcyBhbmQgdGhlIHNwZWNpZmllZCBMb25nLlxuICogQHRoaXMgeyFMb25nfVxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBtdWx0aXBsaWVyIE11bHRpcGxpZXJcbiAqIEByZXR1cm5zIHshTG9uZ30gUHJvZHVjdFxuICovXG5Mb25nUHJvdG90eXBlLm11bHRpcGx5ID0gZnVuY3Rpb24gbXVsdGlwbHkobXVsdGlwbGllcikge1xuICBpZiAodGhpcy5pc1plcm8oKSlcbiAgICByZXR1cm4gdGhpcztcbiAgaWYgKCFpc0xvbmcobXVsdGlwbGllcikpXG4gICAgbXVsdGlwbGllciA9IGZyb21WYWx1ZShtdWx0aXBsaWVyKTtcblxuICAvLyB1c2Ugd2FzbSBzdXBwb3J0IGlmIHByZXNlbnRcbiAgaWYgKHdhc20pIHtcbiAgICB2YXIgbG93ID0gd2FzbVtcIm11bFwiXSh0aGlzLmxvdyxcbiAgICAgIHRoaXMuaGlnaCxcbiAgICAgIG11bHRpcGxpZXIubG93LFxuICAgICAgbXVsdGlwbGllci5oaWdoKTtcbiAgICByZXR1cm4gZnJvbUJpdHMobG93LCB3YXNtW1wiZ2V0X2hpZ2hcIl0oKSwgdGhpcy51bnNpZ25lZCk7XG4gIH1cblxuICBpZiAobXVsdGlwbGllci5pc1plcm8oKSlcbiAgICByZXR1cm4gdGhpcy51bnNpZ25lZCA/IFVaRVJPIDogWkVSTztcbiAgaWYgKHRoaXMuZXEoTUlOX1ZBTFVFKSlcbiAgICByZXR1cm4gbXVsdGlwbGllci5pc09kZCgpID8gTUlOX1ZBTFVFIDogWkVSTztcbiAgaWYgKG11bHRpcGxpZXIuZXEoTUlOX1ZBTFVFKSlcbiAgICByZXR1cm4gdGhpcy5pc09kZCgpID8gTUlOX1ZBTFVFIDogWkVSTztcblxuICBpZiAodGhpcy5pc05lZ2F0aXZlKCkpIHtcbiAgICBpZiAobXVsdGlwbGllci5pc05lZ2F0aXZlKCkpXG4gICAgICByZXR1cm4gdGhpcy5uZWcoKS5tdWwobXVsdGlwbGllci5uZWcoKSk7XG4gICAgZWxzZVxuICAgICAgcmV0dXJuIHRoaXMubmVnKCkubXVsKG11bHRpcGxpZXIpLm5lZygpO1xuICB9IGVsc2UgaWYgKG11bHRpcGxpZXIuaXNOZWdhdGl2ZSgpKVxuICAgIHJldHVybiB0aGlzLm11bChtdWx0aXBsaWVyLm5lZygpKS5uZWcoKTtcblxuICAvLyBJZiBib3RoIGxvbmdzIGFyZSBzbWFsbCwgdXNlIGZsb2F0IG11bHRpcGxpY2F0aW9uXG4gIGlmICh0aGlzLmx0KFRXT19QV1JfMjQpICYmIG11bHRpcGxpZXIubHQoVFdPX1BXUl8yNCkpXG4gICAgcmV0dXJuIGZyb21OdW1iZXIodGhpcy50b051bWJlcigpICogbXVsdGlwbGllci50b051bWJlcigpLCB0aGlzLnVuc2lnbmVkKTtcblxuICAvLyBEaXZpZGUgZWFjaCBsb25nIGludG8gNCBjaHVua3Mgb2YgMTYgYml0cywgYW5kIHRoZW4gYWRkIHVwIDR4NCBwcm9kdWN0cy5cbiAgLy8gV2UgY2FuIHNraXAgcHJvZHVjdHMgdGhhdCB3b3VsZCBvdmVyZmxvdy5cblxuICB2YXIgYTQ4ID0gdGhpcy5oaWdoID4+PiAxNjtcbiAgdmFyIGEzMiA9IHRoaXMuaGlnaCAmIDB4RkZGRjtcbiAgdmFyIGExNiA9IHRoaXMubG93ID4+PiAxNjtcbiAgdmFyIGEwMCA9IHRoaXMubG93ICYgMHhGRkZGO1xuXG4gIHZhciBiNDggPSBtdWx0aXBsaWVyLmhpZ2ggPj4+IDE2O1xuICB2YXIgYjMyID0gbXVsdGlwbGllci5oaWdoICYgMHhGRkZGO1xuICB2YXIgYjE2ID0gbXVsdGlwbGllci5sb3cgPj4+IDE2O1xuICB2YXIgYjAwID0gbXVsdGlwbGllci5sb3cgJiAweEZGRkY7XG5cbiAgdmFyIGM0OCA9IDAsIGMzMiA9IDAsIGMxNiA9IDAsIGMwMCA9IDA7XG4gIGMwMCArPSBhMDAgKiBiMDA7XG4gIGMxNiArPSBjMDAgPj4+IDE2O1xuICBjMDAgJj0gMHhGRkZGO1xuICBjMTYgKz0gYTE2ICogYjAwO1xuICBjMzIgKz0gYzE2ID4+PiAxNjtcbiAgYzE2ICY9IDB4RkZGRjtcbiAgYzE2ICs9IGEwMCAqIGIxNjtcbiAgYzMyICs9IGMxNiA+Pj4gMTY7XG4gIGMxNiAmPSAweEZGRkY7XG4gIGMzMiArPSBhMzIgKiBiMDA7XG4gIGM0OCArPSBjMzIgPj4+IDE2O1xuICBjMzIgJj0gMHhGRkZGO1xuICBjMzIgKz0gYTE2ICogYjE2O1xuICBjNDggKz0gYzMyID4+PiAxNjtcbiAgYzMyICY9IDB4RkZGRjtcbiAgYzMyICs9IGEwMCAqIGIzMjtcbiAgYzQ4ICs9IGMzMiA+Pj4gMTY7XG4gIGMzMiAmPSAweEZGRkY7XG4gIGM0OCArPSBhNDggKiBiMDAgKyBhMzIgKiBiMTYgKyBhMTYgKiBiMzIgKyBhMDAgKiBiNDg7XG4gIGM0OCAmPSAweEZGRkY7XG4gIHJldHVybiBmcm9tQml0cygoYzE2IDw8IDE2KSB8IGMwMCwgKGM0OCA8PCAxNikgfCBjMzIsIHRoaXMudW5zaWduZWQpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBwcm9kdWN0IG9mIHRoaXMgYW5kIHRoZSBzcGVjaWZpZWQgTG9uZy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNtdWx0aXBseX0uXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gbXVsdGlwbGllciBNdWx0aXBsaWVyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFByb2R1Y3RcbiAqL1xuTG9uZ1Byb3RvdHlwZS5tdWwgPSBMb25nUHJvdG90eXBlLm11bHRpcGx5O1xuXG4vKipcbiAqIFJldHVybnMgdGhpcyBMb25nIGRpdmlkZWQgYnkgdGhlIHNwZWNpZmllZC4gVGhlIHJlc3VsdCBpcyBzaWduZWQgaWYgdGhpcyBMb25nIGlzIHNpZ25lZCBvclxuICogIHVuc2lnbmVkIGlmIHRoaXMgTG9uZyBpcyB1bnNpZ25lZC5cbiAqIEB0aGlzIHshTG9uZ31cbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gZGl2aXNvciBEaXZpc29yXG4gKiBAcmV0dXJucyB7IUxvbmd9IFF1b3RpZW50XG4gKi9cbkxvbmdQcm90b3R5cGUuZGl2aWRlID0gZnVuY3Rpb24gZGl2aWRlKGRpdmlzb3IpIHtcbiAgaWYgKCFpc0xvbmcoZGl2aXNvcikpXG4gICAgZGl2aXNvciA9IGZyb21WYWx1ZShkaXZpc29yKTtcbiAgaWYgKGRpdmlzb3IuaXNaZXJvKCkpXG4gICAgdGhyb3cgRXJyb3IoJ2RpdmlzaW9uIGJ5IHplcm8nKTtcblxuICAvLyB1c2Ugd2FzbSBzdXBwb3J0IGlmIHByZXNlbnRcbiAgaWYgKHdhc20pIHtcbiAgICAvLyBndWFyZCBhZ2FpbnN0IHNpZ25lZCBkaXZpc2lvbiBvdmVyZmxvdzogdGhlIGxhcmdlc3RcbiAgICAvLyBuZWdhdGl2ZSBudW1iZXIgLyAtMSB3b3VsZCBiZSAxIGxhcmdlciB0aGFuIHRoZSBsYXJnZXN0XG4gICAgLy8gcG9zaXRpdmUgbnVtYmVyLCBkdWUgdG8gdHdvJ3MgY29tcGxlbWVudC5cbiAgICBpZiAoIXRoaXMudW5zaWduZWQgJiZcbiAgICAgIHRoaXMuaGlnaCA9PT0gLTB4ODAwMDAwMDAgJiZcbiAgICAgIGRpdmlzb3IubG93ID09PSAtMSAmJiBkaXZpc29yLmhpZ2ggPT09IC0xKSB7XG4gICAgICAvLyBiZSBjb25zaXN0ZW50IHdpdGggbm9uLXdhc20gY29kZSBwYXRoXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdmFyIGxvdyA9ICh0aGlzLnVuc2lnbmVkID8gd2FzbVtcImRpdl91XCJdIDogd2FzbVtcImRpdl9zXCJdKShcbiAgICAgIHRoaXMubG93LFxuICAgICAgdGhpcy5oaWdoLFxuICAgICAgZGl2aXNvci5sb3csXG4gICAgICBkaXZpc29yLmhpZ2hcbiAgICApO1xuICAgIHJldHVybiBmcm9tQml0cyhsb3csIHdhc21bXCJnZXRfaGlnaFwiXSgpLCB0aGlzLnVuc2lnbmVkKTtcbiAgfVxuXG4gIGlmICh0aGlzLmlzWmVybygpKVxuICAgIHJldHVybiB0aGlzLnVuc2lnbmVkID8gVVpFUk8gOiBaRVJPO1xuICB2YXIgYXBwcm94LCByZW0sIHJlcztcbiAgaWYgKCF0aGlzLnVuc2lnbmVkKSB7XG4gICAgLy8gVGhpcyBzZWN0aW9uIGlzIG9ubHkgcmVsZXZhbnQgZm9yIHNpZ25lZCBsb25ncyBhbmQgaXMgZGVyaXZlZCBmcm9tIHRoZVxuICAgIC8vIGNsb3N1cmUgbGlicmFyeSBhcyBhIHdob2xlLlxuICAgIGlmICh0aGlzLmVxKE1JTl9WQUxVRSkpIHtcbiAgICAgIGlmIChkaXZpc29yLmVxKE9ORSkgfHwgZGl2aXNvci5lcShORUdfT05FKSlcbiAgICAgICAgcmV0dXJuIE1JTl9WQUxVRTsgIC8vIHJlY2FsbCB0aGF0IC1NSU5fVkFMVUUgPT0gTUlOX1ZBTFVFXG4gICAgICBlbHNlIGlmIChkaXZpc29yLmVxKE1JTl9WQUxVRSkpXG4gICAgICAgIHJldHVybiBPTkU7XG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gQXQgdGhpcyBwb2ludCwgd2UgaGF2ZSB8b3RoZXJ8ID49IDIsIHNvIHx0aGlzL290aGVyfCA8IHxNSU5fVkFMVUV8LlxuICAgICAgICB2YXIgaGFsZlRoaXMgPSB0aGlzLnNocigxKTtcbiAgICAgICAgYXBwcm94ID0gaGFsZlRoaXMuZGl2KGRpdmlzb3IpLnNobCgxKTtcbiAgICAgICAgaWYgKGFwcHJveC5lcShaRVJPKSkge1xuICAgICAgICAgIHJldHVybiBkaXZpc29yLmlzTmVnYXRpdmUoKSA/IE9ORSA6IE5FR19PTkU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVtID0gdGhpcy5zdWIoZGl2aXNvci5tdWwoYXBwcm94KSk7XG4gICAgICAgICAgcmVzID0gYXBwcm94LmFkZChyZW0uZGl2KGRpdmlzb3IpKTtcbiAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChkaXZpc29yLmVxKE1JTl9WQUxVRSkpXG4gICAgICByZXR1cm4gdGhpcy51bnNpZ25lZCA/IFVaRVJPIDogWkVSTztcbiAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkpIHtcbiAgICAgIGlmIChkaXZpc29yLmlzTmVnYXRpdmUoKSlcbiAgICAgICAgcmV0dXJuIHRoaXMubmVnKCkuZGl2KGRpdmlzb3IubmVnKCkpO1xuICAgICAgcmV0dXJuIHRoaXMubmVnKCkuZGl2KGRpdmlzb3IpLm5lZygpO1xuICAgIH0gZWxzZSBpZiAoZGl2aXNvci5pc05lZ2F0aXZlKCkpXG4gICAgICByZXR1cm4gdGhpcy5kaXYoZGl2aXNvci5uZWcoKSkubmVnKCk7XG4gICAgcmVzID0gWkVSTztcbiAgfSBlbHNlIHtcbiAgICAvLyBUaGUgYWxnb3JpdGhtIGJlbG93IGhhcyBub3QgYmVlbiBtYWRlIGZvciB1bnNpZ25lZCBsb25ncy4gSXQncyB0aGVyZWZvcmVcbiAgICAvLyByZXF1aXJlZCB0byB0YWtlIHNwZWNpYWwgY2FyZSBvZiB0aGUgTVNCIHByaW9yIHRvIHJ1bm5pbmcgaXQuXG4gICAgaWYgKCFkaXZpc29yLnVuc2lnbmVkKVxuICAgICAgZGl2aXNvciA9IGRpdmlzb3IudG9VbnNpZ25lZCgpO1xuICAgIGlmIChkaXZpc29yLmd0KHRoaXMpKVxuICAgICAgcmV0dXJuIFVaRVJPO1xuICAgIGlmIChkaXZpc29yLmd0KHRoaXMuc2hydSgxKSkpIC8vIDE1ID4+PiAxID0gNyA7IHdpdGggZGl2aXNvciA9IDggOyB0cnVlXG4gICAgICByZXR1cm4gVU9ORTtcbiAgICByZXMgPSBVWkVSTztcbiAgfVxuXG4gIC8vIFJlcGVhdCB0aGUgZm9sbG93aW5nIHVudGlsIHRoZSByZW1haW5kZXIgaXMgbGVzcyB0aGFuIG90aGVyOiAgZmluZCBhXG4gIC8vIGZsb2F0aW5nLXBvaW50IHRoYXQgYXBwcm94aW1hdGVzIHJlbWFpbmRlciAvIG90aGVyICpmcm9tIGJlbG93KiwgYWRkIHRoaXNcbiAgLy8gaW50byB0aGUgcmVzdWx0LCBhbmQgc3VidHJhY3QgaXQgZnJvbSB0aGUgcmVtYWluZGVyLiAgSXQgaXMgY3JpdGljYWwgdGhhdFxuICAvLyB0aGUgYXBwcm94aW1hdGUgdmFsdWUgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSByZWFsIHZhbHVlIHNvIHRoYXQgdGhlXG4gIC8vIHJlbWFpbmRlciBuZXZlciBiZWNvbWVzIG5lZ2F0aXZlLlxuICByZW0gPSB0aGlzO1xuICB3aGlsZSAocmVtLmd0ZShkaXZpc29yKSkge1xuICAgIC8vIEFwcHJveGltYXRlIHRoZSByZXN1bHQgb2YgZGl2aXNpb24uIFRoaXMgbWF5IGJlIGEgbGl0dGxlIGdyZWF0ZXIgb3JcbiAgICAvLyBzbWFsbGVyIHRoYW4gdGhlIGFjdHVhbCB2YWx1ZS5cbiAgICBhcHByb3ggPSBNYXRoLm1heCgxLCBNYXRoLmZsb29yKHJlbS50b051bWJlcigpIC8gZGl2aXNvci50b051bWJlcigpKSk7XG5cbiAgICAvLyBXZSB3aWxsIHR3ZWFrIHRoZSBhcHByb3hpbWF0ZSByZXN1bHQgYnkgY2hhbmdpbmcgaXQgaW4gdGhlIDQ4LXRoIGRpZ2l0IG9yXG4gICAgLy8gdGhlIHNtYWxsZXN0IG5vbi1mcmFjdGlvbmFsIGRpZ2l0LCB3aGljaGV2ZXIgaXMgbGFyZ2VyLlxuICAgIHZhciBsb2cyID0gTWF0aC5jZWlsKE1hdGgubG9nKGFwcHJveCkgLyBNYXRoLkxOMiksXG4gICAgICBkZWx0YSA9IChsb2cyIDw9IDQ4KSA/IDEgOiBwb3dfZGJsKDIsIGxvZzIgLSA0OCksXG5cbiAgICAgIC8vIERlY3JlYXNlIHRoZSBhcHByb3hpbWF0aW9uIHVudGlsIGl0IGlzIHNtYWxsZXIgdGhhbiB0aGUgcmVtYWluZGVyLiAgTm90ZVxuICAgICAgLy8gdGhhdCBpZiBpdCBpcyB0b28gbGFyZ2UsIHRoZSBwcm9kdWN0IG92ZXJmbG93cyBhbmQgaXMgbmVnYXRpdmUuXG4gICAgICBhcHByb3hSZXMgPSBmcm9tTnVtYmVyKGFwcHJveCksXG4gICAgICBhcHByb3hSZW0gPSBhcHByb3hSZXMubXVsKGRpdmlzb3IpO1xuICAgIHdoaWxlIChhcHByb3hSZW0uaXNOZWdhdGl2ZSgpIHx8IGFwcHJveFJlbS5ndChyZW0pKSB7XG4gICAgICBhcHByb3ggLT0gZGVsdGE7XG4gICAgICBhcHByb3hSZXMgPSBmcm9tTnVtYmVyKGFwcHJveCwgdGhpcy51bnNpZ25lZCk7XG4gICAgICBhcHByb3hSZW0gPSBhcHByb3hSZXMubXVsKGRpdmlzb3IpO1xuICAgIH1cblxuICAgIC8vIFdlIGtub3cgdGhlIGFuc3dlciBjYW4ndCBiZSB6ZXJvLi4uIGFuZCBhY3R1YWxseSwgemVybyB3b3VsZCBjYXVzZVxuICAgIC8vIGluZmluaXRlIHJlY3Vyc2lvbiBzaW5jZSB3ZSB3b3VsZCBtYWtlIG5vIHByb2dyZXNzLlxuICAgIGlmIChhcHByb3hSZXMuaXNaZXJvKCkpXG4gICAgICBhcHByb3hSZXMgPSBPTkU7XG5cbiAgICByZXMgPSByZXMuYWRkKGFwcHJveFJlcyk7XG4gICAgcmVtID0gcmVtLnN1YihhcHByb3hSZW0pO1xuICB9XG4gIHJldHVybiByZXM7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhpcyBMb25nIGRpdmlkZWQgYnkgdGhlIHNwZWNpZmllZC4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNkaXZpZGV9LlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IGRpdmlzb3IgRGl2aXNvclxuICogQHJldHVybnMgeyFMb25nfSBRdW90aWVudFxuICovXG5Mb25nUHJvdG90eXBlLmRpdiA9IExvbmdQcm90b3R5cGUuZGl2aWRlO1xuXG4vKipcbiAqIFJldHVybnMgdGhpcyBMb25nIG1vZHVsbyB0aGUgc3BlY2lmaWVkLlxuICogQHRoaXMgeyFMb25nfVxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBkaXZpc29yIERpdmlzb3JcbiAqIEByZXR1cm5zIHshTG9uZ30gUmVtYWluZGVyXG4gKi9cbkxvbmdQcm90b3R5cGUubW9kdWxvID0gZnVuY3Rpb24gbW9kdWxvKGRpdmlzb3IpIHtcbiAgaWYgKCFpc0xvbmcoZGl2aXNvcikpXG4gICAgZGl2aXNvciA9IGZyb21WYWx1ZShkaXZpc29yKTtcblxuICAvLyB1c2Ugd2FzbSBzdXBwb3J0IGlmIHByZXNlbnRcbiAgaWYgKHdhc20pIHtcbiAgICB2YXIgbG93ID0gKHRoaXMudW5zaWduZWQgPyB3YXNtW1wicmVtX3VcIl0gOiB3YXNtW1wicmVtX3NcIl0pKFxuICAgICAgdGhpcy5sb3csXG4gICAgICB0aGlzLmhpZ2gsXG4gICAgICBkaXZpc29yLmxvdyxcbiAgICAgIGRpdmlzb3IuaGlnaFxuICAgICk7XG4gICAgcmV0dXJuIGZyb21CaXRzKGxvdywgd2FzbVtcImdldF9oaWdoXCJdKCksIHRoaXMudW5zaWduZWQpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuc3ViKHRoaXMuZGl2KGRpdmlzb3IpLm11bChkaXZpc29yKSk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhpcyBMb25nIG1vZHVsbyB0aGUgc3BlY2lmaWVkLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI21vZHVsb30uXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gZGl2aXNvciBEaXZpc29yXG4gKiBAcmV0dXJucyB7IUxvbmd9IFJlbWFpbmRlclxuICovXG5Mb25nUHJvdG90eXBlLm1vZCA9IExvbmdQcm90b3R5cGUubW9kdWxvO1xuXG4vKipcbiAqIFJldHVybnMgdGhpcyBMb25nIG1vZHVsbyB0aGUgc3BlY2lmaWVkLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI21vZHVsb30uXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gZGl2aXNvciBEaXZpc29yXG4gKiBAcmV0dXJucyB7IUxvbmd9IFJlbWFpbmRlclxuICovXG5Mb25nUHJvdG90eXBlLnJlbSA9IExvbmdQcm90b3R5cGUubW9kdWxvO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGJpdHdpc2UgTk9UIG9mIHRoaXMgTG9uZy5cbiAqIEB0aGlzIHshTG9uZ31cbiAqIEByZXR1cm5zIHshTG9uZ31cbiAqL1xuTG9uZ1Byb3RvdHlwZS5ub3QgPSBmdW5jdGlvbiBub3QoKSB7XG4gIHJldHVybiBmcm9tQml0cyh+dGhpcy5sb3csIH50aGlzLmhpZ2gsIHRoaXMudW5zaWduZWQpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGNvdW50IGxlYWRpbmcgemVyb3Mgb2YgdGhpcyBMb25nLlxuICogQHRoaXMgeyFMb25nfVxuICogQHJldHVybnMgeyFudW1iZXJ9XG4gKi9cbkxvbmdQcm90b3R5cGUuY291bnRMZWFkaW5nWmVyb3MgPSBmdW5jdGlvbiBjb3VudExlYWRpbmdaZXJvcygpIHtcbiAgcmV0dXJuIHRoaXMuaGlnaCA/IE1hdGguY2x6MzIodGhpcy5oaWdoKSA6IE1hdGguY2x6MzIodGhpcy5sb3cpICsgMzI7XG59O1xuXG4vKipcbiAqIFJldHVybnMgY291bnQgbGVhZGluZyB6ZXJvcy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNjb3VudExlYWRpbmdaZXJvc30uXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7IUxvbmd9XG4gKiBAcmV0dXJucyB7IW51bWJlcn1cbiAqL1xuTG9uZ1Byb3RvdHlwZS5jbHogPSBMb25nUHJvdG90eXBlLmNvdW50TGVhZGluZ1plcm9zO1xuXG4vKipcbiAqIFJldHVybnMgY291bnQgdHJhaWxpbmcgemVyb3Mgb2YgdGhpcyBMb25nLlxuICogQHRoaXMgeyFMb25nfVxuICogQHJldHVybnMgeyFudW1iZXJ9XG4gKi9cbkxvbmdQcm90b3R5cGUuY291bnRUcmFpbGluZ1plcm9zID0gZnVuY3Rpb24gY291bnRUcmFpbGluZ1plcm9zKCkge1xuICByZXR1cm4gdGhpcy5sb3cgPyBjdHozMih0aGlzLmxvdykgOiBjdHozMih0aGlzLmhpZ2gpICsgMzI7XG59O1xuXG4vKipcbiAqIFJldHVybnMgY291bnQgdHJhaWxpbmcgemVyb3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjY291bnRUcmFpbGluZ1plcm9zfS5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHshTG9uZ31cbiAqIEByZXR1cm5zIHshbnVtYmVyfVxuICovXG5Mb25nUHJvdG90eXBlLmN0eiA9IExvbmdQcm90b3R5cGUuY291bnRUcmFpbGluZ1plcm9zO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGJpdHdpc2UgQU5EIG9mIHRoaXMgTG9uZyBhbmQgdGhlIHNwZWNpZmllZC5cbiAqIEB0aGlzIHshTG9uZ31cbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgTG9uZ1xuICogQHJldHVybnMgeyFMb25nfVxuICovXG5Mb25nUHJvdG90eXBlLmFuZCA9IGZ1bmN0aW9uIGFuZChvdGhlcikge1xuICBpZiAoIWlzTG9uZyhvdGhlcikpXG4gICAgb3RoZXIgPSBmcm9tVmFsdWUob3RoZXIpO1xuICByZXR1cm4gZnJvbUJpdHModGhpcy5sb3cgJiBvdGhlci5sb3csIHRoaXMuaGlnaCAmIG90aGVyLmhpZ2gsIHRoaXMudW5zaWduZWQpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBiaXR3aXNlIE9SIG9mIHRoaXMgTG9uZyBhbmQgdGhlIHNwZWNpZmllZC5cbiAqIEB0aGlzIHshTG9uZ31cbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgTG9uZ1xuICogQHJldHVybnMgeyFMb25nfVxuICovXG5Mb25nUHJvdG90eXBlLm9yID0gZnVuY3Rpb24gb3Iob3RoZXIpIHtcbiAgaWYgKCFpc0xvbmcob3RoZXIpKVxuICAgIG90aGVyID0gZnJvbVZhbHVlKG90aGVyKTtcbiAgcmV0dXJuIGZyb21CaXRzKHRoaXMubG93IHwgb3RoZXIubG93LCB0aGlzLmhpZ2ggfCBvdGhlci5oaWdoLCB0aGlzLnVuc2lnbmVkKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgYml0d2lzZSBYT1Igb2YgdGhpcyBMb25nIGFuZCB0aGUgZ2l2ZW4gb25lLlxuICogQHRoaXMgeyFMb25nfVxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciBMb25nXG4gKiBAcmV0dXJucyB7IUxvbmd9XG4gKi9cbkxvbmdQcm90b3R5cGUueG9yID0gZnVuY3Rpb24geG9yKG90aGVyKSB7XG4gIGlmICghaXNMb25nKG90aGVyKSlcbiAgICBvdGhlciA9IGZyb21WYWx1ZShvdGhlcik7XG4gIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdyBeIG90aGVyLmxvdywgdGhpcy5oaWdoIF4gb3RoZXIuaGlnaCwgdGhpcy51bnNpZ25lZCk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyBzaGlmdGVkIHRvIHRoZSBsZWZ0IGJ5IHRoZSBnaXZlbiBhbW91bnQuXG4gKiBAdGhpcyB7IUxvbmd9XG4gKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xuICogQHJldHVybnMgeyFMb25nfSBTaGlmdGVkIExvbmdcbiAqL1xuTG9uZ1Byb3RvdHlwZS5zaGlmdExlZnQgPSBmdW5jdGlvbiBzaGlmdExlZnQobnVtQml0cykge1xuICBpZiAoaXNMb25nKG51bUJpdHMpKVxuICAgIG51bUJpdHMgPSBudW1CaXRzLnRvSW50KCk7XG4gIGlmICgobnVtQml0cyAmPSA2MykgPT09IDApXG4gICAgcmV0dXJuIHRoaXM7XG4gIGVsc2UgaWYgKG51bUJpdHMgPCAzMilcbiAgICByZXR1cm4gZnJvbUJpdHModGhpcy5sb3cgPDwgbnVtQml0cywgKHRoaXMuaGlnaCA8PCBudW1CaXRzKSB8ICh0aGlzLmxvdyA+Pj4gKDMyIC0gbnVtQml0cykpLCB0aGlzLnVuc2lnbmVkKTtcbiAgZWxzZVxuICAgIHJldHVybiBmcm9tQml0cygwLCB0aGlzLmxvdyA8PCAobnVtQml0cyAtIDMyKSwgdGhpcy51bnNpZ25lZCk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyBzaGlmdGVkIHRvIHRoZSBsZWZ0IGJ5IHRoZSBnaXZlbiBhbW91bnQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjc2hpZnRMZWZ0fS5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IG51bUJpdHMgTnVtYmVyIG9mIGJpdHNcbiAqIEByZXR1cm5zIHshTG9uZ30gU2hpZnRlZCBMb25nXG4gKi9cbkxvbmdQcm90b3R5cGUuc2hsID0gTG9uZ1Byb3RvdHlwZS5zaGlmdExlZnQ7XG5cbi8qKlxuICogUmV0dXJucyB0aGlzIExvbmcgd2l0aCBiaXRzIGFyaXRobWV0aWNhbGx5IHNoaWZ0ZWQgdG8gdGhlIHJpZ2h0IGJ5IHRoZSBnaXZlbiBhbW91bnQuXG4gKiBAdGhpcyB7IUxvbmd9XG4gKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xuICogQHJldHVybnMgeyFMb25nfSBTaGlmdGVkIExvbmdcbiAqL1xuTG9uZ1Byb3RvdHlwZS5zaGlmdFJpZ2h0ID0gZnVuY3Rpb24gc2hpZnRSaWdodChudW1CaXRzKSB7XG4gIGlmIChpc0xvbmcobnVtQml0cykpXG4gICAgbnVtQml0cyA9IG51bUJpdHMudG9JbnQoKTtcbiAgaWYgKChudW1CaXRzICY9IDYzKSA9PT0gMClcbiAgICByZXR1cm4gdGhpcztcbiAgZWxzZSBpZiAobnVtQml0cyA8IDMyKVxuICAgIHJldHVybiBmcm9tQml0cygodGhpcy5sb3cgPj4+IG51bUJpdHMpIHwgKHRoaXMuaGlnaCA8PCAoMzIgLSBudW1CaXRzKSksIHRoaXMuaGlnaCA+PiBudW1CaXRzLCB0aGlzLnVuc2lnbmVkKTtcbiAgZWxzZVxuICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmhpZ2ggPj4gKG51bUJpdHMgLSAzMiksIHRoaXMuaGlnaCA+PSAwID8gMCA6IC0xLCB0aGlzLnVuc2lnbmVkKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGlzIExvbmcgd2l0aCBiaXRzIGFyaXRobWV0aWNhbGx5IHNoaWZ0ZWQgdG8gdGhlIHJpZ2h0IGJ5IHRoZSBnaXZlbiBhbW91bnQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjc2hpZnRSaWdodH0uXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7bnVtYmVyfCFMb25nfSBudW1CaXRzIE51bWJlciBvZiBiaXRzXG4gKiBAcmV0dXJucyB7IUxvbmd9IFNoaWZ0ZWQgTG9uZ1xuICovXG5Mb25nUHJvdG90eXBlLnNociA9IExvbmdQcm90b3R5cGUuc2hpZnRSaWdodDtcblxuLyoqXG4gKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgbG9naWNhbGx5IHNoaWZ0ZWQgdG8gdGhlIHJpZ2h0IGJ5IHRoZSBnaXZlbiBhbW91bnQuXG4gKiBAdGhpcyB7IUxvbmd9XG4gKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xuICogQHJldHVybnMgeyFMb25nfSBTaGlmdGVkIExvbmdcbiAqL1xuTG9uZ1Byb3RvdHlwZS5zaGlmdFJpZ2h0VW5zaWduZWQgPSBmdW5jdGlvbiBzaGlmdFJpZ2h0VW5zaWduZWQobnVtQml0cykge1xuICBpZiAoaXNMb25nKG51bUJpdHMpKSBudW1CaXRzID0gbnVtQml0cy50b0ludCgpO1xuICBpZiAoKG51bUJpdHMgJj0gNjMpID09PSAwKSByZXR1cm4gdGhpcztcbiAgaWYgKG51bUJpdHMgPCAzMikgcmV0dXJuIGZyb21CaXRzKCh0aGlzLmxvdyA+Pj4gbnVtQml0cykgfCAodGhpcy5oaWdoIDw8ICgzMiAtIG51bUJpdHMpKSwgdGhpcy5oaWdoID4+PiBudW1CaXRzLCB0aGlzLnVuc2lnbmVkKTtcbiAgaWYgKG51bUJpdHMgPT09IDMyKSByZXR1cm4gZnJvbUJpdHModGhpcy5oaWdoLCAwLCB0aGlzLnVuc2lnbmVkKTtcbiAgcmV0dXJuIGZyb21CaXRzKHRoaXMuaGlnaCA+Pj4gKG51bUJpdHMgLSAzMiksIDAsIHRoaXMudW5zaWduZWQpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgbG9naWNhbGx5IHNoaWZ0ZWQgdG8gdGhlIHJpZ2h0IGJ5IHRoZSBnaXZlbiBhbW91bnQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjc2hpZnRSaWdodFVuc2lnbmVkfS5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IG51bUJpdHMgTnVtYmVyIG9mIGJpdHNcbiAqIEByZXR1cm5zIHshTG9uZ30gU2hpZnRlZCBMb25nXG4gKi9cbkxvbmdQcm90b3R5cGUuc2hydSA9IExvbmdQcm90b3R5cGUuc2hpZnRSaWdodFVuc2lnbmVkO1xuXG4vKipcbiAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyBsb2dpY2FsbHkgc2hpZnRlZCB0byB0aGUgcmlnaHQgYnkgdGhlIGdpdmVuIGFtb3VudC4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNzaGlmdFJpZ2h0VW5zaWduZWR9LlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xuICogQHJldHVybnMgeyFMb25nfSBTaGlmdGVkIExvbmdcbiAqL1xuTG9uZ1Byb3RvdHlwZS5zaHJfdSA9IExvbmdQcm90b3R5cGUuc2hpZnRSaWdodFVuc2lnbmVkO1xuXG4vKipcbiAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyByb3RhdGVkIHRvIHRoZSBsZWZ0IGJ5IHRoZSBnaXZlbiBhbW91bnQuXG4gKiBAdGhpcyB7IUxvbmd9XG4gKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xuICogQHJldHVybnMgeyFMb25nfSBSb3RhdGVkIExvbmdcbiAqL1xuTG9uZ1Byb3RvdHlwZS5yb3RhdGVMZWZ0ID0gZnVuY3Rpb24gcm90YXRlTGVmdChudW1CaXRzKSB7XG4gIHZhciBiO1xuICBpZiAoaXNMb25nKG51bUJpdHMpKSBudW1CaXRzID0gbnVtQml0cy50b0ludCgpO1xuICBpZiAoKG51bUJpdHMgJj0gNjMpID09PSAwKSByZXR1cm4gdGhpcztcbiAgaWYgKG51bUJpdHMgPT09IDMyKSByZXR1cm4gZnJvbUJpdHModGhpcy5oaWdoLCB0aGlzLmxvdywgdGhpcy51bnNpZ25lZCk7XG4gIGlmIChudW1CaXRzIDwgMzIpIHtcbiAgICBiID0gKDMyIC0gbnVtQml0cyk7XG4gICAgcmV0dXJuIGZyb21CaXRzKCgodGhpcy5sb3cgPDwgbnVtQml0cykgfCAodGhpcy5oaWdoID4+PiBiKSksICgodGhpcy5oaWdoIDw8IG51bUJpdHMpIHwgKHRoaXMubG93ID4+PiBiKSksIHRoaXMudW5zaWduZWQpO1xuICB9XG4gIG51bUJpdHMgLT0gMzI7XG4gIGIgPSAoMzIgLSBudW1CaXRzKTtcbiAgcmV0dXJuIGZyb21CaXRzKCgodGhpcy5oaWdoIDw8IG51bUJpdHMpIHwgKHRoaXMubG93ID4+PiBiKSksICgodGhpcy5sb3cgPDwgbnVtQml0cykgfCAodGhpcy5oaWdoID4+PiBiKSksIHRoaXMudW5zaWduZWQpO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgcm90YXRlZCB0byB0aGUgbGVmdCBieSB0aGUgZ2l2ZW4gYW1vdW50LiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI3JvdGF0ZUxlZnR9LlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xuICogQHJldHVybnMgeyFMb25nfSBSb3RhdGVkIExvbmdcbiAqL1xuTG9uZ1Byb3RvdHlwZS5yb3RsID0gTG9uZ1Byb3RvdHlwZS5yb3RhdGVMZWZ0O1xuXG4vKipcbiAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyByb3RhdGVkIHRvIHRoZSByaWdodCBieSB0aGUgZ2l2ZW4gYW1vdW50LlxuICogQHRoaXMgeyFMb25nfVxuICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IG51bUJpdHMgTnVtYmVyIG9mIGJpdHNcbiAqIEByZXR1cm5zIHshTG9uZ30gUm90YXRlZCBMb25nXG4gKi9cbkxvbmdQcm90b3R5cGUucm90YXRlUmlnaHQgPSBmdW5jdGlvbiByb3RhdGVSaWdodChudW1CaXRzKSB7XG4gIHZhciBiO1xuICBpZiAoaXNMb25nKG51bUJpdHMpKSBudW1CaXRzID0gbnVtQml0cy50b0ludCgpO1xuICBpZiAoKG51bUJpdHMgJj0gNjMpID09PSAwKSByZXR1cm4gdGhpcztcbiAgaWYgKG51bUJpdHMgPT09IDMyKSByZXR1cm4gZnJvbUJpdHModGhpcy5oaWdoLCB0aGlzLmxvdywgdGhpcy51bnNpZ25lZCk7XG4gIGlmIChudW1CaXRzIDwgMzIpIHtcbiAgICBiID0gKDMyIC0gbnVtQml0cyk7XG4gICAgcmV0dXJuIGZyb21CaXRzKCgodGhpcy5oaWdoIDw8IGIpIHwgKHRoaXMubG93ID4+PiBudW1CaXRzKSksICgodGhpcy5sb3cgPDwgYikgfCAodGhpcy5oaWdoID4+PiBudW1CaXRzKSksIHRoaXMudW5zaWduZWQpO1xuICB9XG4gIG51bUJpdHMgLT0gMzI7XG4gIGIgPSAoMzIgLSBudW1CaXRzKTtcbiAgcmV0dXJuIGZyb21CaXRzKCgodGhpcy5sb3cgPDwgYikgfCAodGhpcy5oaWdoID4+PiBudW1CaXRzKSksICgodGhpcy5oaWdoIDw8IGIpIHwgKHRoaXMubG93ID4+PiBudW1CaXRzKSksIHRoaXMudW5zaWduZWQpO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgcm90YXRlZCB0byB0aGUgcmlnaHQgYnkgdGhlIGdpdmVuIGFtb3VudC4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNyb3RhdGVSaWdodH0uXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7bnVtYmVyfCFMb25nfSBudW1CaXRzIE51bWJlciBvZiBiaXRzXG4gKiBAcmV0dXJucyB7IUxvbmd9IFJvdGF0ZWQgTG9uZ1xuICovXG5Mb25nUHJvdG90eXBlLnJvdHIgPSBMb25nUHJvdG90eXBlLnJvdGF0ZVJpZ2h0O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoaXMgTG9uZyB0byBzaWduZWQuXG4gKiBAdGhpcyB7IUxvbmd9XG4gKiBAcmV0dXJucyB7IUxvbmd9IFNpZ25lZCBsb25nXG4gKi9cbkxvbmdQcm90b3R5cGUudG9TaWduZWQgPSBmdW5jdGlvbiB0b1NpZ25lZCgpIHtcbiAgaWYgKCF0aGlzLnVuc2lnbmVkKVxuICAgIHJldHVybiB0aGlzO1xuICByZXR1cm4gZnJvbUJpdHModGhpcy5sb3csIHRoaXMuaGlnaCwgZmFsc2UpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGlzIExvbmcgdG8gdW5zaWduZWQuXG4gKiBAdGhpcyB7IUxvbmd9XG4gKiBAcmV0dXJucyB7IUxvbmd9IFVuc2lnbmVkIGxvbmdcbiAqL1xuTG9uZ1Byb3RvdHlwZS50b1Vuc2lnbmVkID0gZnVuY3Rpb24gdG9VbnNpZ25lZCgpIHtcbiAgaWYgKHRoaXMudW5zaWduZWQpXG4gICAgcmV0dXJuIHRoaXM7XG4gIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdywgdGhpcy5oaWdoLCB0cnVlKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgdGhpcyBMb25nIHRvIGl0cyBieXRlIHJlcHJlc2VudGF0aW9uLlxuICogQHBhcmFtIHtib29sZWFuPX0gbGUgV2hldGhlciBsaXR0bGUgb3IgYmlnIGVuZGlhbiwgZGVmYXVsdHMgdG8gYmlnIGVuZGlhblxuICogQHRoaXMgeyFMb25nfVxuICogQHJldHVybnMgeyFBcnJheS48bnVtYmVyPn0gQnl0ZSByZXByZXNlbnRhdGlvblxuICovXG5Mb25nUHJvdG90eXBlLnRvQnl0ZXMgPSBmdW5jdGlvbiB0b0J5dGVzKGxlKSB7XG4gIHJldHVybiBsZSA/IHRoaXMudG9CeXRlc0xFKCkgOiB0aGlzLnRvQnl0ZXNCRSgpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGlzIExvbmcgdG8gaXRzIGxpdHRsZSBlbmRpYW4gYnl0ZSByZXByZXNlbnRhdGlvbi5cbiAqIEB0aGlzIHshTG9uZ31cbiAqIEByZXR1cm5zIHshQXJyYXkuPG51bWJlcj59IExpdHRsZSBlbmRpYW4gYnl0ZSByZXByZXNlbnRhdGlvblxuICovXG5Mb25nUHJvdG90eXBlLnRvQnl0ZXNMRSA9IGZ1bmN0aW9uIHRvQnl0ZXNMRSgpIHtcbiAgdmFyIGhpID0gdGhpcy5oaWdoLFxuICAgIGxvID0gdGhpcy5sb3c7XG4gIHJldHVybiBbXG4gICAgbG8gJiAweGZmLFxuICAgIGxvID4+PiA4ICYgMHhmZixcbiAgICBsbyA+Pj4gMTYgJiAweGZmLFxuICAgIGxvID4+PiAyNCxcbiAgICBoaSAmIDB4ZmYsXG4gICAgaGkgPj4+IDggJiAweGZmLFxuICAgIGhpID4+PiAxNiAmIDB4ZmYsXG4gICAgaGkgPj4+IDI0XG4gIF07XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoaXMgTG9uZyB0byBpdHMgYmlnIGVuZGlhbiBieXRlIHJlcHJlc2VudGF0aW9uLlxuICogQHRoaXMgeyFMb25nfVxuICogQHJldHVybnMgeyFBcnJheS48bnVtYmVyPn0gQmlnIGVuZGlhbiBieXRlIHJlcHJlc2VudGF0aW9uXG4gKi9cbkxvbmdQcm90b3R5cGUudG9CeXRlc0JFID0gZnVuY3Rpb24gdG9CeXRlc0JFKCkge1xuICB2YXIgaGkgPSB0aGlzLmhpZ2gsXG4gICAgbG8gPSB0aGlzLmxvdztcbiAgcmV0dXJuIFtcbiAgICBoaSA+Pj4gMjQsXG4gICAgaGkgPj4+IDE2ICYgMHhmZixcbiAgICBoaSA+Pj4gOCAmIDB4ZmYsXG4gICAgaGkgJiAweGZmLFxuICAgIGxvID4+PiAyNCxcbiAgICBsbyA+Pj4gMTYgJiAweGZmLFxuICAgIGxvID4+PiA4ICYgMHhmZixcbiAgICBsbyAmIDB4ZmZcbiAgXTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIExvbmcgZnJvbSBpdHMgYnl0ZSByZXByZXNlbnRhdGlvbi5cbiAqIEBwYXJhbSB7IUFycmF5LjxudW1iZXI+fSBieXRlcyBCeXRlIHJlcHJlc2VudGF0aW9uXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdCwgZGVmYXVsdHMgdG8gc2lnbmVkXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBsZSBXaGV0aGVyIGxpdHRsZSBvciBiaWcgZW5kaWFuLCBkZWZhdWx0cyB0byBiaWcgZW5kaWFuXG4gKiBAcmV0dXJucyB7TG9uZ30gVGhlIGNvcnJlc3BvbmRpbmcgTG9uZyB2YWx1ZVxuICovXG5Mb25nLmZyb21CeXRlcyA9IGZ1bmN0aW9uIGZyb21CeXRlcyhieXRlcywgdW5zaWduZWQsIGxlKSB7XG4gIHJldHVybiBsZSA/IExvbmcuZnJvbUJ5dGVzTEUoYnl0ZXMsIHVuc2lnbmVkKSA6IExvbmcuZnJvbUJ5dGVzQkUoYnl0ZXMsIHVuc2lnbmVkKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIExvbmcgZnJvbSBpdHMgbGl0dGxlIGVuZGlhbiBieXRlIHJlcHJlc2VudGF0aW9uLlxuICogQHBhcmFtIHshQXJyYXkuPG51bWJlcj59IGJ5dGVzIExpdHRsZSBlbmRpYW4gYnl0ZSByZXByZXNlbnRhdGlvblxuICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3QsIGRlZmF1bHRzIHRvIHNpZ25lZFxuICogQHJldHVybnMge0xvbmd9IFRoZSBjb3JyZXNwb25kaW5nIExvbmcgdmFsdWVcbiAqL1xuTG9uZy5mcm9tQnl0ZXNMRSA9IGZ1bmN0aW9uIGZyb21CeXRlc0xFKGJ5dGVzLCB1bnNpZ25lZCkge1xuICByZXR1cm4gbmV3IExvbmcoXG4gICAgYnl0ZXNbMF0gfFxuICAgIGJ5dGVzWzFdIDw8IDggfFxuICAgIGJ5dGVzWzJdIDw8IDE2IHxcbiAgICBieXRlc1szXSA8PCAyNCxcbiAgICBieXRlc1s0XSB8XG4gICAgYnl0ZXNbNV0gPDwgOCB8XG4gICAgYnl0ZXNbNl0gPDwgMTYgfFxuICAgIGJ5dGVzWzddIDw8IDI0LFxuICAgIHVuc2lnbmVkXG4gICk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBMb25nIGZyb20gaXRzIGJpZyBlbmRpYW4gYnl0ZSByZXByZXNlbnRhdGlvbi5cbiAqIEBwYXJhbSB7IUFycmF5LjxudW1iZXI+fSBieXRlcyBCaWcgZW5kaWFuIGJ5dGUgcmVwcmVzZW50YXRpb25cbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBzaWduZWRcbiAqIEByZXR1cm5zIHtMb25nfSBUaGUgY29ycmVzcG9uZGluZyBMb25nIHZhbHVlXG4gKi9cbkxvbmcuZnJvbUJ5dGVzQkUgPSBmdW5jdGlvbiBmcm9tQnl0ZXNCRShieXRlcywgdW5zaWduZWQpIHtcbiAgcmV0dXJuIG5ldyBMb25nKFxuICAgIGJ5dGVzWzRdIDw8IDI0IHxcbiAgICBieXRlc1s1XSA8PCAxNiB8XG4gICAgYnl0ZXNbNl0gPDwgOCB8XG4gICAgYnl0ZXNbN10sXG4gICAgYnl0ZXNbMF0gPDwgMjQgfFxuICAgIGJ5dGVzWzFdIDw8IDE2IHxcbiAgICBieXRlc1syXSA8PCA4IHxcbiAgICBieXRlc1szXSxcbiAgICB1bnNpZ25lZFxuICApO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgTG9uZztcbiIsICIvLy8gQGZpbGVcbi8vLyBAYWRkdG9ncm91cCBmbGF0YnVmZmVyc19qYXZhc2NyaXB0X2FwaVxuLy8vIEB7XG4vLy8gQGNvbmQgRkxBVEJVRkZFUlNfSU5URVJOQUxcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3XG4gKlxuICogTmVlZCB0byBzdXBwcmVzcyAnZ2xvYmFsIHRoaXMnIGVycm9yIHNvIHRoZSBOb2RlLmpzIGV4cG9ydCBsaW5lIGRvZXNuJ3QgY2F1c2VcbiAqIGNsb3N1cmUgY29tcGlsZSB0byBlcnJvciBvdXQuXG4gKiBAc3VwcHJlc3Mge2dsb2JhbFRoaXN9XG4gKi9cblxuLyoqXG4gKiBAY29uc3RcbiAqIEBuYW1lc3BhY2VcbiAqL1xudmFyIGZsYXRidWZmZXJzID0ge307XG5cbi8qKlxuICogQHR5cGVkZWYge251bWJlcn1cbiAqL1xuZmxhdGJ1ZmZlcnMuT2Zmc2V0O1xuXG4vKipcbiAqIEB0eXBlZGVmIHt7XG4gKiAgIGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyLFxuICogICBiYl9wb3M6IG51bWJlclxuICogfX1cbiAqL1xuZmxhdGJ1ZmZlcnMuVGFibGU7XG5cbi8qKlxuICogQHR5cGUge251bWJlcn1cbiAqIEBjb25zdFxuICovXG5mbGF0YnVmZmVycy5TSVpFT0ZfU0hPUlQgPSAyO1xuXG4vKipcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAY29uc3RcbiAqL1xuZmxhdGJ1ZmZlcnMuU0laRU9GX0lOVCA9IDQ7XG5cbi8qKlxuICogQHR5cGUge251bWJlcn1cbiAqIEBjb25zdFxuICovXG5mbGF0YnVmZmVycy5GSUxFX0lERU5USUZJRVJfTEVOR1RIID0gNDtcblxuLyoqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGNvbnN0XG4gKi9cbmZsYXRidWZmZXJzLlNJWkVfUFJFRklYX0xFTkdUSCA9IDQ7XG5cbi8qKlxuICogQGVudW0ge251bWJlcn1cbiAqL1xuZmxhdGJ1ZmZlcnMuRW5jb2RpbmcgPSB7XG4gIFVURjhfQllURVM6IDEsXG4gIFVURjE2X1NUUklORzogMlxufTtcblxuLyoqXG4gKiBAdHlwZSB7SW50MzJBcnJheX1cbiAqIEBjb25zdFxuICovXG5mbGF0YnVmZmVycy5pbnQzMiA9IG5ldyBJbnQzMkFycmF5KDIpO1xuXG4vKipcbiAqIEB0eXBlIHtGbG9hdDMyQXJyYXl9XG4gKiBAY29uc3RcbiAqL1xuZmxhdGJ1ZmZlcnMuZmxvYXQzMiA9IG5ldyBGbG9hdDMyQXJyYXkoZmxhdGJ1ZmZlcnMuaW50MzIuYnVmZmVyKTtcblxuLyoqXG4gKiBAdHlwZSB7RmxvYXQ2NEFycmF5fVxuICogQGNvbnN0XG4gKi9cbmZsYXRidWZmZXJzLmZsb2F0NjQgPSBuZXcgRmxvYXQ2NEFycmF5KGZsYXRidWZmZXJzLmludDMyLmJ1ZmZlcik7XG5cbi8qKlxuICogQHR5cGUge2Jvb2xlYW59XG4gKiBAY29uc3RcbiAqL1xuZmxhdGJ1ZmZlcnMuaXNMaXR0bGVFbmRpYW4gPSBuZXcgVWludDE2QXJyYXkobmV3IFVpbnQ4QXJyYXkoWzEsIDBdKS5idWZmZXIpWzBdID09PSAxO1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtudW1iZXJ9IGxvd1xuICogQHBhcmFtIHtudW1iZXJ9IGhpZ2hcbiAqL1xuZmxhdGJ1ZmZlcnMuTG9uZyA9IGZ1bmN0aW9uKGxvdywgaGlnaCkge1xuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQGNvbnN0XG4gICAqL1xuICB0aGlzLmxvdyA9IGxvdyB8IDA7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBjb25zdFxuICAgKi9cbiAgdGhpcy5oaWdoID0gaGlnaCB8IDA7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBsb3dcbiAqIEBwYXJhbSB7bnVtYmVyfSBoaWdoXG4gKiBAcmV0dXJucyB7IWZsYXRidWZmZXJzLkxvbmd9XG4gKi9cbmZsYXRidWZmZXJzLkxvbmcuY3JlYXRlID0gZnVuY3Rpb24obG93LCBoaWdoKSB7XG4gIC8vIFNwZWNpYWwtY2FzZSB6ZXJvIHRvIGF2b2lkIEdDIG92ZXJoZWFkIGZvciBkZWZhdWx0IHZhbHVlc1xuICByZXR1cm4gbG93ID09IDAgJiYgaGlnaCA9PSAwID8gZmxhdGJ1ZmZlcnMuTG9uZy5aRVJPIDogbmV3IGZsYXRidWZmZXJzLkxvbmcobG93LCBoaWdoKTtcbn07XG5cbi8qKlxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZmxhdGJ1ZmZlcnMuTG9uZy5wcm90b3R5cGUudG9GbG9hdDY0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAodGhpcy5sb3cgPj4+IDApICsgdGhpcy5oaWdoICogMHgxMDAwMDAwMDA7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7ZmxhdGJ1ZmZlcnMuTG9uZ30gb3RoZXJcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mbGF0YnVmZmVycy5Mb25nLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbihvdGhlcikge1xuICByZXR1cm4gdGhpcy5sb3cgPT0gb3RoZXIubG93ICYmIHRoaXMuaGlnaCA9PSBvdGhlci5oaWdoO1xufTtcblxuLyoqXG4gKiBAdHlwZSB7IWZsYXRidWZmZXJzLkxvbmd9XG4gKiBAY29uc3RcbiAqL1xuZmxhdGJ1ZmZlcnMuTG9uZy5aRVJPID0gbmV3IGZsYXRidWZmZXJzLkxvbmcoMCwgMCk7XG5cbi8vLyBAZW5kY29uZFxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8qKlxuICogQ3JlYXRlIGEgRmxhdEJ1ZmZlckJ1aWxkZXIuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge251bWJlcj19IG9wdF9pbml0aWFsX3NpemVcbiAqL1xuZmxhdGJ1ZmZlcnMuQnVpbGRlciA9IGZ1bmN0aW9uKG9wdF9pbml0aWFsX3NpemUpIHtcbiAgaWYgKCFvcHRfaW5pdGlhbF9zaXplKSB7XG4gICAgdmFyIGluaXRpYWxfc2l6ZSA9IDEwMjQ7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGluaXRpYWxfc2l6ZSA9IG9wdF9pbml0aWFsX3NpemU7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge2ZsYXRidWZmZXJzLkJ5dGVCdWZmZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLmJiID0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlci5hbGxvY2F0ZShpbml0aWFsX3NpemUpO1xuXG4gIC8qKlxuICAgKiBSZW1haW5pbmcgc3BhY2UgaW4gdGhlIEJ5dGVCdWZmZXIuXG4gICAqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLnNwYWNlID0gaW5pdGlhbF9zaXplO1xuXG4gIC8qKlxuICAgKiBNaW5pbXVtIGFsaWdubWVudCBlbmNvdW50ZXJlZCBzbyBmYXIuXG4gICAqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLm1pbmFsaWduID0gMTtcblxuICAvKipcbiAgICogVGhlIHZ0YWJsZSBmb3IgdGhlIGN1cnJlbnQgdGFibGUuXG4gICAqXG4gICAqIEB0eXBlIHtBcnJheS48bnVtYmVyPn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMudnRhYmxlID0gbnVsbDtcblxuICAvKipcbiAgICogVGhlIGFtb3VudCBvZiBmaWVsZHMgd2UncmUgYWN0dWFsbHkgdXNpbmcuXG4gICAqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLnZ0YWJsZV9pbl91c2UgPSAwO1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHdlIGFyZSBjdXJyZW50bHkgc2VyaWFsaXppbmcgYSB0YWJsZS5cbiAgICpcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLmlzTmVzdGVkID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIFN0YXJ0aW5nIG9mZnNldCBvZiB0aGUgY3VycmVudCBzdHJ1Y3QvdGFibGUuXG4gICAqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLm9iamVjdF9zdGFydCA9IDA7XG5cbiAgLyoqXG4gICAqIExpc3Qgb2Ygb2Zmc2V0cyBvZiBhbGwgdnRhYmxlcy5cbiAgICpcbiAgICogQHR5cGUge0FycmF5LjxudW1iZXI+fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy52dGFibGVzID0gW107XG5cbiAgLyoqXG4gICAqIEZvciB0aGUgY3VycmVudCB2ZWN0b3IgYmVpbmcgYnVpbHQuXG4gICAqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLnZlY3Rvcl9udW1fZWxlbXMgPSAwO1xuXG4gIC8qKlxuICAgKiBGYWxzZSBvbWl0cyBkZWZhdWx0IHZhbHVlcyBmcm9tIHRoZSBzZXJpYWxpemVkIGRhdGFcbiAgICpcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLmZvcmNlX2RlZmF1bHRzID0gZmFsc2U7XG59O1xuXG5mbGF0YnVmZmVycy5CdWlsZGVyLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmJiLmNsZWFyKCk7XG4gIHRoaXMuc3BhY2UgPSB0aGlzLmJiLmNhcGFjaXR5KCk7XG4gIHRoaXMubWluYWxpZ24gPSAxO1xuICB0aGlzLnZ0YWJsZSA9IG51bGw7XG4gIHRoaXMudnRhYmxlX2luX3VzZSA9IDA7XG4gIHRoaXMuaXNOZXN0ZWQgPSBmYWxzZTtcbiAgdGhpcy5vYmplY3Rfc3RhcnQgPSAwO1xuICB0aGlzLnZ0YWJsZXMgPSBbXTtcbiAgdGhpcy52ZWN0b3JfbnVtX2VsZW1zID0gMDtcbiAgdGhpcy5mb3JjZV9kZWZhdWx0cyA9IGZhbHNlO1xufTtcblxuLyoqXG4gKiBJbiBvcmRlciB0byBzYXZlIHNwYWNlLCBmaWVsZHMgdGhhdCBhcmUgc2V0IHRvIHRoZWlyIGRlZmF1bHQgdmFsdWVcbiAqIGRvbid0IGdldCBzZXJpYWxpemVkIGludG8gdGhlIGJ1ZmZlci4gRm9yY2luZyBkZWZhdWx0cyBwcm92aWRlcyBhXG4gKiB3YXkgdG8gbWFudWFsbHkgZGlzYWJsZSB0aGlzIG9wdGltaXphdGlvbi5cbiAqXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGZvcmNlRGVmYXVsdHMgdHJ1ZSBhbHdheXMgc2VyaWFsaXplcyBkZWZhdWx0IHZhbHVlc1xuICovXG5mbGF0YnVmZmVycy5CdWlsZGVyLnByb3RvdHlwZS5mb3JjZURlZmF1bHRzID0gZnVuY3Rpb24oZm9yY2VEZWZhdWx0cykge1xuICB0aGlzLmZvcmNlX2RlZmF1bHRzID0gZm9yY2VEZWZhdWx0cztcbn07XG5cbi8qKlxuICogR2V0IHRoZSBCeXRlQnVmZmVyIHJlcHJlc2VudGluZyB0aGUgRmxhdEJ1ZmZlci4gT25seSBjYWxsIHRoaXMgYWZ0ZXIgeW91J3ZlXG4gKiBjYWxsZWQgZmluaXNoKCkuIFRoZSBhY3R1YWwgZGF0YSBzdGFydHMgYXQgdGhlIEJ5dGVCdWZmZXIncyBjdXJyZW50IHBvc2l0aW9uLFxuICogbm90IG5lY2Vzc2FyaWx5IGF0IDAuXG4gKlxuICogQHJldHVybnMge2ZsYXRidWZmZXJzLkJ5dGVCdWZmZXJ9XG4gKi9cbmZsYXRidWZmZXJzLkJ1aWxkZXIucHJvdG90eXBlLmRhdGFCdWZmZXIgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuYmI7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgYnl0ZXMgcmVwcmVzZW50aW5nIHRoZSBGbGF0QnVmZmVyLiBPbmx5IGNhbGwgdGhpcyBhZnRlciB5b3UndmVcbiAqIGNhbGxlZCBmaW5pc2goKS5cbiAqXG4gKiBAcmV0dXJucyB7IVVpbnQ4QXJyYXl9XG4gKi9cbmZsYXRidWZmZXJzLkJ1aWxkZXIucHJvdG90eXBlLmFzVWludDhBcnJheSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5iYi5ieXRlcygpLnN1YmFycmF5KHRoaXMuYmIucG9zaXRpb24oKSwgdGhpcy5iYi5wb3NpdGlvbigpICsgdGhpcy5vZmZzZXQoKSk7XG59O1xuXG4vLy8gQGNvbmQgRkxBVEJVRkZFUlNfSU5URVJOQUxcbi8qKlxuICogUHJlcGFyZSB0byB3cml0ZSBhbiBlbGVtZW50IG9mIGBzaXplYCBhZnRlciBgYWRkaXRpb25hbF9ieXRlc2AgaGF2ZSBiZWVuXG4gKiB3cml0dGVuLCBlLmcuIGlmIHlvdSB3cml0ZSBhIHN0cmluZywgeW91IG5lZWQgdG8gYWxpZ24gc3VjaCB0aGUgaW50IGxlbmd0aFxuICogZmllbGQgaXMgYWxpZ25lZCB0byA0IGJ5dGVzLCBhbmQgdGhlIHN0cmluZyBkYXRhIGZvbGxvd3MgaXQgZGlyZWN0bHkuIElmIGFsbFxuICogeW91IG5lZWQgdG8gZG8gaXMgYWxpZ25tZW50LCBgYWRkaXRpb25hbF9ieXRlc2Agd2lsbCBiZSAwLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBzaXplIFRoaXMgaXMgdGhlIG9mIHRoZSBuZXcgZWxlbWVudCB0byB3cml0ZVxuICogQHBhcmFtIHtudW1iZXJ9IGFkZGl0aW9uYWxfYnl0ZXMgVGhlIHBhZGRpbmcgc2l6ZVxuICovXG5mbGF0YnVmZmVycy5CdWlsZGVyLnByb3RvdHlwZS5wcmVwID0gZnVuY3Rpb24oc2l6ZSwgYWRkaXRpb25hbF9ieXRlcykge1xuICAvLyBUcmFjayB0aGUgYmlnZ2VzdCB0aGluZyB3ZSd2ZSBldmVyIGFsaWduZWQgdG8uXG4gIGlmIChzaXplID4gdGhpcy5taW5hbGlnbikge1xuICAgIHRoaXMubWluYWxpZ24gPSBzaXplO1xuICB9XG5cbiAgLy8gRmluZCB0aGUgYW1vdW50IG9mIGFsaWdubWVudCBuZWVkZWQgc3VjaCB0aGF0IGBzaXplYCBpcyBwcm9wZXJseVxuICAvLyBhbGlnbmVkIGFmdGVyIGBhZGRpdGlvbmFsX2J5dGVzYFxuICB2YXIgYWxpZ25fc2l6ZSA9ICgofih0aGlzLmJiLmNhcGFjaXR5KCkgLSB0aGlzLnNwYWNlICsgYWRkaXRpb25hbF9ieXRlcykpICsgMSkgJiAoc2l6ZSAtIDEpO1xuXG4gIC8vIFJlYWxsb2NhdGUgdGhlIGJ1ZmZlciBpZiBuZWVkZWQuXG4gIHdoaWxlICh0aGlzLnNwYWNlIDwgYWxpZ25fc2l6ZSArIHNpemUgKyBhZGRpdGlvbmFsX2J5dGVzKSB7XG4gICAgdmFyIG9sZF9idWZfc2l6ZSA9IHRoaXMuYmIuY2FwYWNpdHkoKTtcbiAgICB0aGlzLmJiID0gZmxhdGJ1ZmZlcnMuQnVpbGRlci5ncm93Qnl0ZUJ1ZmZlcih0aGlzLmJiKTtcbiAgICB0aGlzLnNwYWNlICs9IHRoaXMuYmIuY2FwYWNpdHkoKSAtIG9sZF9idWZfc2l6ZTtcbiAgfVxuXG4gIHRoaXMucGFkKGFsaWduX3NpemUpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gYnl0ZV9zaXplXG4gKi9cbmZsYXRidWZmZXJzLkJ1aWxkZXIucHJvdG90eXBlLnBhZCA9IGZ1bmN0aW9uKGJ5dGVfc2l6ZSkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVfc2l6ZTsgaSsrKSB7XG4gICAgdGhpcy5iYi53cml0ZUludDgoLS10aGlzLnNwYWNlLCAwKTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAqL1xuZmxhdGJ1ZmZlcnMuQnVpbGRlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgdGhpcy5iYi53cml0ZUludDgodGhpcy5zcGFjZSAtPSAxLCB2YWx1ZSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICovXG5mbGF0YnVmZmVycy5CdWlsZGVyLnByb3RvdHlwZS53cml0ZUludDE2ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgdGhpcy5iYi53cml0ZUludDE2KHRoaXMuc3BhY2UgLT0gMiwgdmFsdWUpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAqL1xuZmxhdGJ1ZmZlcnMuQnVpbGRlci5wcm90b3R5cGUud3JpdGVJbnQzMiA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHRoaXMuYmIud3JpdGVJbnQzMih0aGlzLnNwYWNlIC09IDQsIHZhbHVlKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtmbGF0YnVmZmVycy5Mb25nfSB2YWx1ZVxuICovXG5mbGF0YnVmZmVycy5CdWlsZGVyLnByb3RvdHlwZS53cml0ZUludDY0ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgdGhpcy5iYi53cml0ZUludDY0KHRoaXMuc3BhY2UgLT0gOCwgdmFsdWUpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAqL1xuZmxhdGJ1ZmZlcnMuQnVpbGRlci5wcm90b3R5cGUud3JpdGVGbG9hdDMyID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgdGhpcy5iYi53cml0ZUZsb2F0MzIodGhpcy5zcGFjZSAtPSA0LCB2YWx1ZSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICovXG5mbGF0YnVmZmVycy5CdWlsZGVyLnByb3RvdHlwZS53cml0ZUZsb2F0NjQgPSBmdW5jdGlvbih2YWx1ZSkge1xuICB0aGlzLmJiLndyaXRlRmxvYXQ2NCh0aGlzLnNwYWNlIC09IDgsIHZhbHVlKTtcbn07XG4vLy8gQGVuZGNvbmRcblxuLyoqXG4gKiBBZGQgYW4gYGludDhgIHRvIHRoZSBidWZmZXIsIHByb3Blcmx5IGFsaWduZWQsIGFuZCBncm93cyB0aGUgYnVmZmVyIChpZiBuZWNlc3NhcnkpLlxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFRoZSBgaW50OGAgdG8gYWRkIHRoZSB0aGUgYnVmZmVyLlxuICovXG5mbGF0YnVmZmVycy5CdWlsZGVyLnByb3RvdHlwZS5hZGRJbnQ4ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgdGhpcy5wcmVwKDEsIDApO1xuICB0aGlzLndyaXRlSW50OCh2YWx1ZSk7XG59O1xuXG4vKipcbiAqIEFkZCBhbiBgaW50MTZgIHRvIHRoZSBidWZmZXIsIHByb3Blcmx5IGFsaWduZWQsIGFuZCBncm93cyB0aGUgYnVmZmVyIChpZiBuZWNlc3NhcnkpLlxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFRoZSBgaW50MTZgIHRvIGFkZCB0aGUgdGhlIGJ1ZmZlci5cbiAqL1xuZmxhdGJ1ZmZlcnMuQnVpbGRlci5wcm90b3R5cGUuYWRkSW50MTYgPSBmdW5jdGlvbih2YWx1ZSkge1xuICB0aGlzLnByZXAoMiwgMCk7XG4gIHRoaXMud3JpdGVJbnQxNih2YWx1ZSk7XG59O1xuXG4vKipcbiAqIEFkZCBhbiBgaW50MzJgIHRvIHRoZSBidWZmZXIsIHByb3Blcmx5IGFsaWduZWQsIGFuZCBncm93cyB0aGUgYnVmZmVyIChpZiBuZWNlc3NhcnkpLlxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFRoZSBgaW50MzJgIHRvIGFkZCB0aGUgdGhlIGJ1ZmZlci5cbiAqL1xuZmxhdGJ1ZmZlcnMuQnVpbGRlci5wcm90b3R5cGUuYWRkSW50MzIgPSBmdW5jdGlvbih2YWx1ZSkge1xuICB0aGlzLnByZXAoNCwgMCk7XG4gIHRoaXMud3JpdGVJbnQzMih2YWx1ZSk7XG59O1xuXG4vKipcbiAqIEFkZCBhbiBgaW50NjRgIHRvIHRoZSBidWZmZXIsIHByb3Blcmx5IGFsaWduZWQsIGFuZCBncm93cyB0aGUgYnVmZmVyIChpZiBuZWNlc3NhcnkpLlxuICogQHBhcmFtIHtmbGF0YnVmZmVycy5Mb25nfSB2YWx1ZSBUaGUgYGludDY0YCB0byBhZGQgdGhlIHRoZSBidWZmZXIuXG4gKi9cbmZsYXRidWZmZXJzLkJ1aWxkZXIucHJvdG90eXBlLmFkZEludDY0ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgdGhpcy5wcmVwKDgsIDApO1xuICB0aGlzLndyaXRlSW50NjQodmFsdWUpO1xufTtcblxuLyoqXG4gKiBBZGQgYSBgZmxvYXQzMmAgdG8gdGhlIGJ1ZmZlciwgcHJvcGVybHkgYWxpZ25lZCwgYW5kIGdyb3dzIHRoZSBidWZmZXIgKGlmIG5lY2Vzc2FyeSkuXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVGhlIGBmbG9hdDMyYCB0byBhZGQgdGhlIHRoZSBidWZmZXIuXG4gKi9cbmZsYXRidWZmZXJzLkJ1aWxkZXIucHJvdG90eXBlLmFkZEZsb2F0MzIgPSBmdW5jdGlvbih2YWx1ZSkge1xuICB0aGlzLnByZXAoNCwgMCk7XG4gIHRoaXMud3JpdGVGbG9hdDMyKHZhbHVlKTtcbn07XG5cbi8qKlxuICogQWRkIGEgYGZsb2F0NjRgIHRvIHRoZSBidWZmZXIsIHByb3Blcmx5IGFsaWduZWQsIGFuZCBncm93cyB0aGUgYnVmZmVyIChpZiBuZWNlc3NhcnkpLlxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFRoZSBgZmxvYXQ2NGAgdG8gYWRkIHRoZSB0aGUgYnVmZmVyLlxuICovXG5mbGF0YnVmZmVycy5CdWlsZGVyLnByb3RvdHlwZS5hZGRGbG9hdDY0ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgdGhpcy5wcmVwKDgsIDApO1xuICB0aGlzLndyaXRlRmxvYXQ2NCh2YWx1ZSk7XG59O1xuXG4vLy8gQGNvbmQgRkxBVEJVRkZFUlNfSU5URVJOQUxcbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHZvZmZzZXRcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICogQHBhcmFtIHtudW1iZXJ9IGRlZmF1bHRWYWx1ZVxuICovXG5mbGF0YnVmZmVycy5CdWlsZGVyLnByb3RvdHlwZS5hZGRGaWVsZEludDggPSBmdW5jdGlvbih2b2Zmc2V0LCB2YWx1ZSwgZGVmYXVsdFZhbHVlKSB7XG4gIGlmICh0aGlzLmZvcmNlX2RlZmF1bHRzIHx8IHZhbHVlICE9IGRlZmF1bHRWYWx1ZSkge1xuICAgIHRoaXMuYWRkSW50OCh2YWx1ZSk7XG4gICAgdGhpcy5zbG90KHZvZmZzZXQpO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB2b2Zmc2V0XG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAqIEBwYXJhbSB7bnVtYmVyfSBkZWZhdWx0VmFsdWVcbiAqL1xuZmxhdGJ1ZmZlcnMuQnVpbGRlci5wcm90b3R5cGUuYWRkRmllbGRJbnQxNiA9IGZ1bmN0aW9uKHZvZmZzZXQsIHZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcbiAgaWYgKHRoaXMuZm9yY2VfZGVmYXVsdHMgfHwgdmFsdWUgIT0gZGVmYXVsdFZhbHVlKSB7XG4gICAgdGhpcy5hZGRJbnQxNih2YWx1ZSk7XG4gICAgdGhpcy5zbG90KHZvZmZzZXQpO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB2b2Zmc2V0XG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAqIEBwYXJhbSB7bnVtYmVyfSBkZWZhdWx0VmFsdWVcbiAqL1xuZmxhdGJ1ZmZlcnMuQnVpbGRlci5wcm90b3R5cGUuYWRkRmllbGRJbnQzMiA9IGZ1bmN0aW9uKHZvZmZzZXQsIHZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcbiAgaWYgKHRoaXMuZm9yY2VfZGVmYXVsdHMgfHwgdmFsdWUgIT0gZGVmYXVsdFZhbHVlKSB7XG4gICAgdGhpcy5hZGRJbnQzMih2YWx1ZSk7XG4gICAgdGhpcy5zbG90KHZvZmZzZXQpO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB2b2Zmc2V0XG4gKiBAcGFyYW0ge2ZsYXRidWZmZXJzLkxvbmd9IHZhbHVlXG4gKiBAcGFyYW0ge2ZsYXRidWZmZXJzLkxvbmd9IGRlZmF1bHRWYWx1ZVxuICovXG5mbGF0YnVmZmVycy5CdWlsZGVyLnByb3RvdHlwZS5hZGRGaWVsZEludDY0ID0gZnVuY3Rpb24odm9mZnNldCwgdmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xuICBpZiAodGhpcy5mb3JjZV9kZWZhdWx0cyB8fCAhdmFsdWUuZXF1YWxzKGRlZmF1bHRWYWx1ZSkpIHtcbiAgICB0aGlzLmFkZEludDY0KHZhbHVlKTtcbiAgICB0aGlzLnNsb3Qodm9mZnNldCk7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHZvZmZzZXRcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICogQHBhcmFtIHtudW1iZXJ9IGRlZmF1bHRWYWx1ZVxuICovXG5mbGF0YnVmZmVycy5CdWlsZGVyLnByb3RvdHlwZS5hZGRGaWVsZEZsb2F0MzIgPSBmdW5jdGlvbih2b2Zmc2V0LCB2YWx1ZSwgZGVmYXVsdFZhbHVlKSB7XG4gIGlmICh0aGlzLmZvcmNlX2RlZmF1bHRzIHx8IHZhbHVlICE9IGRlZmF1bHRWYWx1ZSkge1xuICAgIHRoaXMuYWRkRmxvYXQzMih2YWx1ZSk7XG4gICAgdGhpcy5zbG90KHZvZmZzZXQpO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB2b2Zmc2V0XG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAqIEBwYXJhbSB7bnVtYmVyfSBkZWZhdWx0VmFsdWVcbiAqL1xuZmxhdGJ1ZmZlcnMuQnVpbGRlci5wcm90b3R5cGUuYWRkRmllbGRGbG9hdDY0ID0gZnVuY3Rpb24odm9mZnNldCwgdmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xuICBpZiAodGhpcy5mb3JjZV9kZWZhdWx0cyB8fCB2YWx1ZSAhPSBkZWZhdWx0VmFsdWUpIHtcbiAgICB0aGlzLmFkZEZsb2F0NjQodmFsdWUpO1xuICAgIHRoaXMuc2xvdCh2b2Zmc2V0KTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gdm9mZnNldFxuICogQHBhcmFtIHtmbGF0YnVmZmVycy5PZmZzZXR9IHZhbHVlXG4gKiBAcGFyYW0ge2ZsYXRidWZmZXJzLk9mZnNldH0gZGVmYXVsdFZhbHVlXG4gKi9cbmZsYXRidWZmZXJzLkJ1aWxkZXIucHJvdG90eXBlLmFkZEZpZWxkT2Zmc2V0ID0gZnVuY3Rpb24odm9mZnNldCwgdmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xuICBpZiAodGhpcy5mb3JjZV9kZWZhdWx0cyB8fCB2YWx1ZSAhPSBkZWZhdWx0VmFsdWUpIHtcbiAgICB0aGlzLmFkZE9mZnNldCh2YWx1ZSk7XG4gICAgdGhpcy5zbG90KHZvZmZzZXQpO1xuICB9XG59O1xuXG4vKipcbiAqIFN0cnVjdHMgYXJlIHN0b3JlZCBpbmxpbmUsIHNvIG5vdGhpbmcgYWRkaXRpb25hbCBpcyBiZWluZyBhZGRlZC4gYGRgIGlzIGFsd2F5cyAwLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSB2b2Zmc2V0XG4gKiBAcGFyYW0ge2ZsYXRidWZmZXJzLk9mZnNldH0gdmFsdWVcbiAqIEBwYXJhbSB7ZmxhdGJ1ZmZlcnMuT2Zmc2V0fSBkZWZhdWx0VmFsdWVcbiAqL1xuZmxhdGJ1ZmZlcnMuQnVpbGRlci5wcm90b3R5cGUuYWRkRmllbGRTdHJ1Y3QgPSBmdW5jdGlvbih2b2Zmc2V0LCB2YWx1ZSwgZGVmYXVsdFZhbHVlKSB7XG4gIGlmICh2YWx1ZSAhPSBkZWZhdWx0VmFsdWUpIHtcbiAgICB0aGlzLm5lc3RlZCh2YWx1ZSk7XG4gICAgdGhpcy5zbG90KHZvZmZzZXQpO1xuICB9XG59O1xuXG4vKipcbiAqIFN0cnVjdHVyZXMgYXJlIGFsd2F5cyBzdG9yZWQgaW5saW5lLCB0aGV5IG5lZWQgdG8gYmUgY3JlYXRlZCByaWdodFxuICogd2hlcmUgdGhleSdyZSB1c2VkLiAgWW91J2xsIGdldCB0aGlzIGFzc2VydGlvbiBmYWlsdXJlIGlmIHlvdVxuICogY3JlYXRlZCBpdCBlbHNld2hlcmUuXG4gKlxuICogQHBhcmFtIHtmbGF0YnVmZmVycy5PZmZzZXR9IG9iaiBUaGUgb2Zmc2V0IG9mIHRoZSBjcmVhdGVkIG9iamVjdFxuICovXG5mbGF0YnVmZmVycy5CdWlsZGVyLnByb3RvdHlwZS5uZXN0ZWQgPSBmdW5jdGlvbihvYmopIHtcbiAgaWYgKG9iaiAhPSB0aGlzLm9mZnNldCgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGbGF0QnVmZmVyczogc3RydWN0IG11c3QgYmUgc2VyaWFsaXplZCBpbmxpbmUuJyk7XG4gIH1cbn07XG5cbi8qKlxuICogU2hvdWxkIG5vdCBiZSBjcmVhdGluZyBhbnkgb3RoZXIgb2JqZWN0LCBzdHJpbmcgb3IgdmVjdG9yXG4gKiB3aGlsZSBhbiBvYmplY3QgaXMgYmVpbmcgY29uc3RydWN0ZWRcbiAqL1xuZmxhdGJ1ZmZlcnMuQnVpbGRlci5wcm90b3R5cGUubm90TmVzdGVkID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLmlzTmVzdGVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGbGF0QnVmZmVyczogb2JqZWN0IHNlcmlhbGl6YXRpb24gbXVzdCBub3QgYmUgbmVzdGVkLicpO1xuICB9XG59O1xuXG4vKipcbiAqIFNldCB0aGUgY3VycmVudCB2dGFibGUgYXQgYHZvZmZzZXRgIHRvIHRoZSBjdXJyZW50IGxvY2F0aW9uIGluIHRoZSBidWZmZXIuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHZvZmZzZXRcbiAqL1xuZmxhdGJ1ZmZlcnMuQnVpbGRlci5wcm90b3R5cGUuc2xvdCA9IGZ1bmN0aW9uKHZvZmZzZXQpIHtcbiAgdGhpcy52dGFibGVbdm9mZnNldF0gPSB0aGlzLm9mZnNldCgpO1xufTtcblxuLyoqXG4gKiBAcmV0dXJucyB7ZmxhdGJ1ZmZlcnMuT2Zmc2V0fSBPZmZzZXQgcmVsYXRpdmUgdG8gdGhlIGVuZCBvZiB0aGUgYnVmZmVyLlxuICovXG5mbGF0YnVmZmVycy5CdWlsZGVyLnByb3RvdHlwZS5vZmZzZXQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuYmIuY2FwYWNpdHkoKSAtIHRoaXMuc3BhY2U7XG59O1xuXG4vKipcbiAqIERvdWJsZXMgdGhlIHNpemUgb2YgdGhlIGJhY2tpbmcgQnl0ZUJ1ZmZlciBhbmQgY29waWVzIHRoZSBvbGQgZGF0YSB0b3dhcmRzXG4gKiB0aGUgZW5kIG9mIHRoZSBuZXcgYnVmZmVyIChzaW5jZSB3ZSBidWlsZCB0aGUgYnVmZmVyIGJhY2t3YXJkcykuXG4gKlxuICogQHBhcmFtIHtmbGF0YnVmZmVycy5CeXRlQnVmZmVyfSBiYiBUaGUgY3VycmVudCBidWZmZXIgd2l0aCB0aGUgZXhpc3RpbmcgZGF0YVxuICogQHJldHVybnMgeyFmbGF0YnVmZmVycy5CeXRlQnVmZmVyfSBBIG5ldyBieXRlIGJ1ZmZlciB3aXRoIHRoZSBvbGQgZGF0YSBjb3BpZWRcbiAqIHRvIGl0LiBUaGUgZGF0YSBpcyBsb2NhdGVkIGF0IHRoZSBlbmQgb2YgdGhlIGJ1ZmZlci5cbiAqXG4gKiB1aW50OEFycmF5LnNldCgpIGZvcm1hbGx5IHRha2VzIHtBcnJheTxudW1iZXI+fEFycmF5QnVmZmVyVmlld30sIHNvIHRvIHBhc3NcbiAqIGl0IGEgdWludDhBcnJheSB3ZSBuZWVkIHRvIHN1cHByZXNzIHRoZSB0eXBlIGNoZWNrOlxuICogQHN1cHByZXNzIHtjaGVja1R5cGVzfVxuICovXG5mbGF0YnVmZmVycy5CdWlsZGVyLmdyb3dCeXRlQnVmZmVyID0gZnVuY3Rpb24oYmIpIHtcbiAgdmFyIG9sZF9idWZfc2l6ZSA9IGJiLmNhcGFjaXR5KCk7XG5cbiAgLy8gRW5zdXJlIHdlIGRvbid0IGdyb3cgYmV5b25kIHdoYXQgZml0cyBpbiBhbiBpbnQuXG4gIGlmIChvbGRfYnVmX3NpemUgJiAweEMwMDAwMDAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGbGF0QnVmZmVyczogY2Fubm90IGdyb3cgYnVmZmVyIGJleW9uZCAyIGdpZ2FieXRlcy4nKTtcbiAgfVxuXG4gIHZhciBuZXdfYnVmX3NpemUgPSBvbGRfYnVmX3NpemUgPDwgMTtcbiAgdmFyIG5iYiA9IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIuYWxsb2NhdGUobmV3X2J1Zl9zaXplKTtcbiAgbmJiLnNldFBvc2l0aW9uKG5ld19idWZfc2l6ZSAtIG9sZF9idWZfc2l6ZSk7XG4gIG5iYi5ieXRlcygpLnNldChiYi5ieXRlcygpLCBuZXdfYnVmX3NpemUgLSBvbGRfYnVmX3NpemUpO1xuICByZXR1cm4gbmJiO1xufTtcbi8vLyBAZW5kY29uZFxuXG4vKipcbiAqIEFkZHMgb24gb2Zmc2V0LCByZWxhdGl2ZSB0byB3aGVyZSBpdCB3aWxsIGJlIHdyaXR0ZW4uXG4gKlxuICogQHBhcmFtIHtmbGF0YnVmZmVycy5PZmZzZXR9IG9mZnNldCBUaGUgb2Zmc2V0IHRvIGFkZC5cbiAqL1xuZmxhdGJ1ZmZlcnMuQnVpbGRlci5wcm90b3R5cGUuYWRkT2Zmc2V0ID0gZnVuY3Rpb24ob2Zmc2V0KSB7XG4gIHRoaXMucHJlcChmbGF0YnVmZmVycy5TSVpFT0ZfSU5ULCAwKTsgLy8gRW5zdXJlIGFsaWdubWVudCBpcyBhbHJlYWR5IGRvbmUuXG4gIHRoaXMud3JpdGVJbnQzMih0aGlzLm9mZnNldCgpIC0gb2Zmc2V0ICsgZmxhdGJ1ZmZlcnMuU0laRU9GX0lOVCk7XG59O1xuXG4vLy8gQGNvbmQgRkxBVEJVRkZFUlNfSU5URVJOQUxcbi8qKlxuICogU3RhcnQgZW5jb2RpbmcgYSBuZXcgb2JqZWN0IGluIHRoZSBidWZmZXIuICBVc2VycyB3aWxsIG5vdCB1c3VhbGx5IG5lZWQgdG9cbiAqIGNhbGwgdGhpcyBkaXJlY3RseS4gVGhlIEZsYXRCdWZmZXJzIGNvbXBpbGVyIHdpbGwgZ2VuZXJhdGUgaGVscGVyIG1ldGhvZHNcbiAqIHRoYXQgY2FsbCB0aGlzIG1ldGhvZCBpbnRlcm5hbGx5LlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBudW1maWVsZHNcbiAqL1xuZmxhdGJ1ZmZlcnMuQnVpbGRlci5wcm90b3R5cGUuc3RhcnRPYmplY3QgPSBmdW5jdGlvbihudW1maWVsZHMpIHtcbiAgdGhpcy5ub3ROZXN0ZWQoKTtcbiAgaWYgKHRoaXMudnRhYmxlID09IG51bGwpIHtcbiAgICB0aGlzLnZ0YWJsZSA9IFtdO1xuICB9XG4gIHRoaXMudnRhYmxlX2luX3VzZSA9IG51bWZpZWxkcztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1maWVsZHM7IGkrKykge1xuICAgIHRoaXMudnRhYmxlW2ldID0gMDsgLy8gVGhpcyB3aWxsIHB1c2ggYWRkaXRpb25hbCBlbGVtZW50cyBhcyBuZWVkZWRcbiAgfVxuICB0aGlzLmlzTmVzdGVkID0gdHJ1ZTtcbiAgdGhpcy5vYmplY3Rfc3RhcnQgPSB0aGlzLm9mZnNldCgpO1xufTtcblxuLyoqXG4gKiBGaW5pc2ggb2ZmIHdyaXRpbmcgdGhlIG9iamVjdCB0aGF0IGlzIHVuZGVyIGNvbnN0cnVjdGlvbi5cbiAqXG4gKiBAcmV0dXJucyB7ZmxhdGJ1ZmZlcnMuT2Zmc2V0fSBUaGUgb2Zmc2V0IHRvIHRoZSBvYmplY3QgaW5zaWRlIGBkYXRhQnVmZmVyYFxuICovXG5mbGF0YnVmZmVycy5CdWlsZGVyLnByb3RvdHlwZS5lbmRPYmplY3QgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMudnRhYmxlID09IG51bGwgfHwgIXRoaXMuaXNOZXN0ZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZsYXRCdWZmZXJzOiBlbmRPYmplY3QgY2FsbGVkIHdpdGhvdXQgc3RhcnRPYmplY3QnKTtcbiAgfVxuXG4gIHRoaXMuYWRkSW50MzIoMCk7XG4gIHZhciB2dGFibGVsb2MgPSB0aGlzLm9mZnNldCgpO1xuXG4gIC8vIFRyaW0gdHJhaWxpbmcgemVyb2VzLlxuICB2YXIgaSA9IHRoaXMudnRhYmxlX2luX3VzZSAtIDE7XG4gIGZvciAoOyBpID49IDAgJiYgdGhpcy52dGFibGVbaV0gPT0gMDsgaS0tKSB7fVxuICB2YXIgdHJpbW1lZF9zaXplID0gaSArIDE7XG5cbiAgLy8gV3JpdGUgb3V0IHRoZSBjdXJyZW50IHZ0YWJsZS5cbiAgZm9yICg7IGkgPj0gMDsgaS0tKSB7XG4gICAgLy8gT2Zmc2V0IHJlbGF0aXZlIHRvIHRoZSBzdGFydCBvZiB0aGUgdGFibGUuXG4gICAgdGhpcy5hZGRJbnQxNih0aGlzLnZ0YWJsZVtpXSAhPSAwID8gdnRhYmxlbG9jIC0gdGhpcy52dGFibGVbaV0gOiAwKTtcbiAgfVxuXG4gIHZhciBzdGFuZGFyZF9maWVsZHMgPSAyOyAvLyBUaGUgZmllbGRzIGJlbG93OlxuICB0aGlzLmFkZEludDE2KHZ0YWJsZWxvYyAtIHRoaXMub2JqZWN0X3N0YXJ0KTtcbiAgdmFyIGxlbiA9ICh0cmltbWVkX3NpemUgKyBzdGFuZGFyZF9maWVsZHMpICogZmxhdGJ1ZmZlcnMuU0laRU9GX1NIT1JUO1xuICB0aGlzLmFkZEludDE2KGxlbik7XG5cbiAgLy8gU2VhcmNoIGZvciBhbiBleGlzdGluZyB2dGFibGUgdGhhdCBtYXRjaGVzIHRoZSBjdXJyZW50IG9uZS5cbiAgdmFyIGV4aXN0aW5nX3Z0YWJsZSA9IDA7XG4gIHZhciB2dDEgPSB0aGlzLnNwYWNlO1xub3V0ZXJfbG9vcDpcbiAgZm9yIChpID0gMDsgaSA8IHRoaXMudnRhYmxlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciB2dDIgPSB0aGlzLmJiLmNhcGFjaXR5KCkgLSB0aGlzLnZ0YWJsZXNbaV07XG4gICAgaWYgKGxlbiA9PSB0aGlzLmJiLnJlYWRJbnQxNih2dDIpKSB7XG4gICAgICBmb3IgKHZhciBqID0gZmxhdGJ1ZmZlcnMuU0laRU9GX1NIT1JUOyBqIDwgbGVuOyBqICs9IGZsYXRidWZmZXJzLlNJWkVPRl9TSE9SVCkge1xuICAgICAgICBpZiAodGhpcy5iYi5yZWFkSW50MTYodnQxICsgaikgIT0gdGhpcy5iYi5yZWFkSW50MTYodnQyICsgaikpIHtcbiAgICAgICAgICBjb250aW51ZSBvdXRlcl9sb29wO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBleGlzdGluZ192dGFibGUgPSB0aGlzLnZ0YWJsZXNbaV07XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAoZXhpc3RpbmdfdnRhYmxlKSB7XG4gICAgLy8gRm91bmQgYSBtYXRjaDpcbiAgICAvLyBSZW1vdmUgdGhlIGN1cnJlbnQgdnRhYmxlLlxuICAgIHRoaXMuc3BhY2UgPSB0aGlzLmJiLmNhcGFjaXR5KCkgLSB2dGFibGVsb2M7XG5cbiAgICAvLyBQb2ludCB0YWJsZSB0byBleGlzdGluZyB2dGFibGUuXG4gICAgdGhpcy5iYi53cml0ZUludDMyKHRoaXMuc3BhY2UsIGV4aXN0aW5nX3Z0YWJsZSAtIHZ0YWJsZWxvYyk7XG4gIH0gZWxzZSB7XG4gICAgLy8gTm8gbWF0Y2g6XG4gICAgLy8gQWRkIHRoZSBsb2NhdGlvbiBvZiB0aGUgY3VycmVudCB2dGFibGUgdG8gdGhlIGxpc3Qgb2YgdnRhYmxlcy5cbiAgICB0aGlzLnZ0YWJsZXMucHVzaCh0aGlzLm9mZnNldCgpKTtcblxuICAgIC8vIFBvaW50IHRhYmxlIHRvIGN1cnJlbnQgdnRhYmxlLlxuICAgIHRoaXMuYmIud3JpdGVJbnQzMih0aGlzLmJiLmNhcGFjaXR5KCkgLSB2dGFibGVsb2MsIHRoaXMub2Zmc2V0KCkgLSB2dGFibGVsb2MpO1xuICB9XG5cbiAgdGhpcy5pc05lc3RlZCA9IGZhbHNlO1xuICByZXR1cm4gdnRhYmxlbG9jO1xufTtcbi8vLyBAZW5kY29uZFxuXG4vKipcbiAqIEZpbmFsaXplIGEgYnVmZmVyLCBwb2l0aW5nIHRvIHRoZSBnaXZlbiBgcm9vdF90YWJsZWAuXG4gKlxuICogQHBhcmFtIHtmbGF0YnVmZmVycy5PZmZzZXR9IHJvb3RfdGFibGVcbiAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X2ZpbGVfaWRlbnRpZmllclxuICogQHBhcmFtIHtib29sZWFuPX0gb3B0X3NpemVfcHJlZml4XG4gKi9cbmZsYXRidWZmZXJzLkJ1aWxkZXIucHJvdG90eXBlLmZpbmlzaCA9IGZ1bmN0aW9uKHJvb3RfdGFibGUsIG9wdF9maWxlX2lkZW50aWZpZXIsIG9wdF9zaXplX3ByZWZpeCkge1xuICB2YXIgc2l6ZV9wcmVmaXggPSBvcHRfc2l6ZV9wcmVmaXggPyBmbGF0YnVmZmVycy5TSVpFX1BSRUZJWF9MRU5HVEggOiAwO1xuICBpZiAob3B0X2ZpbGVfaWRlbnRpZmllcikge1xuICAgIHZhciBmaWxlX2lkZW50aWZpZXIgPSBvcHRfZmlsZV9pZGVudGlmaWVyO1xuICAgIHRoaXMucHJlcCh0aGlzLm1pbmFsaWduLCBmbGF0YnVmZmVycy5TSVpFT0ZfSU5UICtcbiAgICAgIGZsYXRidWZmZXJzLkZJTEVfSURFTlRJRklFUl9MRU5HVEggKyBzaXplX3ByZWZpeCk7XG4gICAgaWYgKGZpbGVfaWRlbnRpZmllci5sZW5ndGggIT0gZmxhdGJ1ZmZlcnMuRklMRV9JREVOVElGSUVSX0xFTkdUSCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGbGF0QnVmZmVyczogZmlsZSBpZGVudGlmaWVyIG11c3QgYmUgbGVuZ3RoICcgK1xuICAgICAgICBmbGF0YnVmZmVycy5GSUxFX0lERU5USUZJRVJfTEVOR1RIKTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IGZsYXRidWZmZXJzLkZJTEVfSURFTlRJRklFUl9MRU5HVEggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdGhpcy53cml0ZUludDgoZmlsZV9pZGVudGlmaWVyLmNoYXJDb2RlQXQoaSkpO1xuICAgIH1cbiAgfVxuICB0aGlzLnByZXAodGhpcy5taW5hbGlnbiwgZmxhdGJ1ZmZlcnMuU0laRU9GX0lOVCArIHNpemVfcHJlZml4KTtcbiAgdGhpcy5hZGRPZmZzZXQocm9vdF90YWJsZSk7XG4gIGlmIChzaXplX3ByZWZpeCkge1xuICAgIHRoaXMuYWRkSW50MzIodGhpcy5iYi5jYXBhY2l0eSgpIC0gdGhpcy5zcGFjZSk7XG4gIH1cbiAgdGhpcy5iYi5zZXRQb3NpdGlvbih0aGlzLnNwYWNlKTtcbn07XG5cbi8qKlxuICogRmluYWxpemUgYSBzaXplIHByZWZpeGVkIGJ1ZmZlciwgcG9pbnRpbmcgdG8gdGhlIGdpdmVuIGByb290X3RhYmxlYC5cbiAqXG4gKiBAcGFyYW0ge2ZsYXRidWZmZXJzLk9mZnNldH0gcm9vdF90YWJsZVxuICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfZmlsZV9pZGVudGlmaWVyXG4gKi9cbmZsYXRidWZmZXJzLkJ1aWxkZXIucHJvdG90eXBlLmZpbmlzaFNpemVQcmVmaXhlZCA9IGZ1bmN0aW9uIChyb290X3RhYmxlLCBvcHRfZmlsZV9pZGVudGlmaWVyKSB7XG4gIHRoaXMuZmluaXNoKHJvb3RfdGFibGUsIG9wdF9maWxlX2lkZW50aWZpZXIsIHRydWUpO1xufTtcblxuLy8vIEBjb25kIEZMQVRCVUZGRVJTX0lOVEVSTkFMXG4vKipcbiAqIFRoaXMgY2hlY2tzIGEgcmVxdWlyZWQgZmllbGQgaGFzIGJlZW4gc2V0IGluIGEgZ2l2ZW4gdGFibGUgdGhhdCBoYXNcbiAqIGp1c3QgYmVlbiBjb25zdHJ1Y3RlZC5cbiAqXG4gKiBAcGFyYW0ge2ZsYXRidWZmZXJzLk9mZnNldH0gdGFibGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBmaWVsZFxuICovXG5mbGF0YnVmZmVycy5CdWlsZGVyLnByb3RvdHlwZS5yZXF1aXJlZEZpZWxkID0gZnVuY3Rpb24odGFibGUsIGZpZWxkKSB7XG4gIHZhciB0YWJsZV9zdGFydCA9IHRoaXMuYmIuY2FwYWNpdHkoKSAtIHRhYmxlO1xuICB2YXIgdnRhYmxlX3N0YXJ0ID0gdGFibGVfc3RhcnQgLSB0aGlzLmJiLnJlYWRJbnQzMih0YWJsZV9zdGFydCk7XG4gIHZhciBvayA9IHRoaXMuYmIucmVhZEludDE2KHZ0YWJsZV9zdGFydCArIGZpZWxkKSAhPSAwO1xuXG4gIC8vIElmIHRoaXMgZmFpbHMsIHRoZSBjYWxsZXIgd2lsbCBzaG93IHdoYXQgZmllbGQgbmVlZHMgdG8gYmUgc2V0LlxuICBpZiAoIW9rKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGbGF0QnVmZmVyczogZmllbGQgJyArIGZpZWxkICsgJyBtdXN0IGJlIHNldCcpO1xuICB9XG59O1xuXG4vKipcbiAqIFN0YXJ0IGEgbmV3IGFycmF5L3ZlY3RvciBvZiBvYmplY3RzLiAgVXNlcnMgdXN1YWxseSB3aWxsIG5vdCBjYWxsXG4gKiB0aGlzIGRpcmVjdGx5LiBUaGUgRmxhdEJ1ZmZlcnMgY29tcGlsZXIgd2lsbCBjcmVhdGUgYSBzdGFydC9lbmRcbiAqIG1ldGhvZCBmb3IgdmVjdG9yIHR5cGVzIGluIGdlbmVyYXRlZCBjb2RlLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBlbGVtX3NpemUgVGhlIHNpemUgb2YgZWFjaCBlbGVtZW50IGluIHRoZSBhcnJheVxuICogQHBhcmFtIHtudW1iZXJ9IG51bV9lbGVtcyBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSBhcnJheVxuICogQHBhcmFtIHtudW1iZXJ9IGFsaWdubWVudCBUaGUgYWxpZ25tZW50IG9mIHRoZSBhcnJheVxuICovXG5mbGF0YnVmZmVycy5CdWlsZGVyLnByb3RvdHlwZS5zdGFydFZlY3RvciA9IGZ1bmN0aW9uKGVsZW1fc2l6ZSwgbnVtX2VsZW1zLCBhbGlnbm1lbnQpIHtcbiAgdGhpcy5ub3ROZXN0ZWQoKTtcbiAgdGhpcy52ZWN0b3JfbnVtX2VsZW1zID0gbnVtX2VsZW1zO1xuICB0aGlzLnByZXAoZmxhdGJ1ZmZlcnMuU0laRU9GX0lOVCwgZWxlbV9zaXplICogbnVtX2VsZW1zKTtcbiAgdGhpcy5wcmVwKGFsaWdubWVudCwgZWxlbV9zaXplICogbnVtX2VsZW1zKTsgLy8gSnVzdCBpbiBjYXNlIGFsaWdubWVudCA+IGludC5cbn07XG5cbi8qKlxuICogRmluaXNoIG9mZiB0aGUgY3JlYXRpb24gb2YgYW4gYXJyYXkgYW5kIGFsbCBpdHMgZWxlbWVudHMuIFRoZSBhcnJheSBtdXN0IGJlXG4gKiBjcmVhdGVkIHdpdGggYHN0YXJ0VmVjdG9yYC5cbiAqXG4gKiBAcmV0dXJucyB7ZmxhdGJ1ZmZlcnMuT2Zmc2V0fSBUaGUgb2Zmc2V0IGF0IHdoaWNoIHRoZSBuZXdseSBjcmVhdGVkIGFycmF5XG4gKiBzdGFydHMuXG4gKi9cbmZsYXRidWZmZXJzLkJ1aWxkZXIucHJvdG90eXBlLmVuZFZlY3RvciA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLndyaXRlSW50MzIodGhpcy52ZWN0b3JfbnVtX2VsZW1zKTtcbiAgcmV0dXJuIHRoaXMub2Zmc2V0KCk7XG59O1xuLy8vIEBlbmRjb25kXG5cbi8qKlxuICogRW5jb2RlIHRoZSBzdHJpbmcgYHNgIGluIHRoZSBidWZmZXIgdXNpbmcgVVRGLTguIElmIGEgVWludDhBcnJheSBpcyBwYXNzZWRcbiAqIGluc3RlYWQgb2YgYSBzdHJpbmcsIGl0IGlzIGFzc3VtZWQgdG8gY29udGFpbiB2YWxpZCBVVEYtOCBlbmNvZGVkIGRhdGEuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8VWludDhBcnJheX0gcyBUaGUgc3RyaW5nIHRvIGVuY29kZVxuICogQHJldHVybiB7ZmxhdGJ1ZmZlcnMuT2Zmc2V0fSBUaGUgb2Zmc2V0IGluIHRoZSBidWZmZXIgd2hlcmUgdGhlIGVuY29kZWQgc3RyaW5nIHN0YXJ0c1xuICovXG5mbGF0YnVmZmVycy5CdWlsZGVyLnByb3RvdHlwZS5jcmVhdGVTdHJpbmcgPSBmdW5jdGlvbihzKSB7XG4gIGlmIChzIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgIHZhciB1dGY4ID0gcztcbiAgfSBlbHNlIHtcbiAgICB2YXIgdXRmOCA9IFtdO1xuICAgIHZhciBpID0gMDtcblxuICAgIHdoaWxlIChpIDwgcy5sZW5ndGgpIHtcbiAgICAgIHZhciBjb2RlUG9pbnQ7XG5cbiAgICAgIC8vIERlY29kZSBVVEYtMTZcbiAgICAgIHZhciBhID0gcy5jaGFyQ29kZUF0KGkrKyk7XG4gICAgICBpZiAoYSA8IDB4RDgwMCB8fCBhID49IDB4REMwMCkge1xuICAgICAgICBjb2RlUG9pbnQgPSBhO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGIgPSBzLmNoYXJDb2RlQXQoaSsrKTtcbiAgICAgICAgY29kZVBvaW50ID0gKGEgPDwgMTApICsgYiArICgweDEwMDAwIC0gKDB4RDgwMCA8PCAxMCkgLSAweERDMDApO1xuICAgICAgfVxuXG4gICAgICAvLyBFbmNvZGUgVVRGLThcbiAgICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XG4gICAgICAgIHV0ZjgucHVzaChjb2RlUG9pbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICAgICAgdXRmOC5wdXNoKCgoY29kZVBvaW50ID4+IDYpICYgMHgxRikgfCAweEMwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgICAgICAgdXRmOC5wdXNoKCgoY29kZVBvaW50ID4+IDEyKSAmIDB4MEYpIHwgMHhFMCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHV0ZjgucHVzaChcbiAgICAgICAgICAgICAgKChjb2RlUG9pbnQgPj4gMTgpICYgMHgwNykgfCAweEYwLFxuICAgICAgICAgICAgICAoKGNvZGVQb2ludCA+PiAxMikgJiAweDNGKSB8IDB4ODApO1xuICAgICAgICAgIH1cbiAgICAgICAgICB1dGY4LnB1c2goKChjb2RlUG9pbnQgPj4gNikgJiAweDNGKSB8IDB4ODApO1xuICAgICAgICB9XG4gICAgICAgIHV0ZjgucHVzaCgoY29kZVBvaW50ICYgMHgzRikgfCAweDgwKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB0aGlzLmFkZEludDgoMCk7XG4gIHRoaXMuc3RhcnRWZWN0b3IoMSwgdXRmOC5sZW5ndGgsIDEpO1xuICB0aGlzLmJiLnNldFBvc2l0aW9uKHRoaXMuc3BhY2UgLT0gdXRmOC5sZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMCwgb2Zmc2V0ID0gdGhpcy5zcGFjZSwgYnl0ZXMgPSB0aGlzLmJiLmJ5dGVzKCk7IGkgPCB1dGY4Lmxlbmd0aDsgaSsrKSB7XG4gICAgYnl0ZXNbb2Zmc2V0KytdID0gdXRmOFtpXTtcbiAgfVxuICByZXR1cm4gdGhpcy5lbmRWZWN0b3IoKTtcbn07XG5cbi8qKlxuICogQSBoZWxwZXIgZnVuY3Rpb24gdG8gYXZvaWQgZ2VuZXJhdGVkIGNvZGUgZGVwZW5kaW5nIG9uIHRoaXMgZmlsZSBkaXJlY3RseS5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gbG93XG4gKiBAcGFyYW0ge251bWJlcn0gaGlnaFxuICogQHJldHVybnMgeyFmbGF0YnVmZmVycy5Mb25nfVxuICovXG5mbGF0YnVmZmVycy5CdWlsZGVyLnByb3RvdHlwZS5jcmVhdGVMb25nID0gZnVuY3Rpb24obG93LCBoaWdoKSB7XG4gIHJldHVybiBmbGF0YnVmZmVycy5Mb25nLmNyZWF0ZShsb3csIGhpZ2gpO1xufTtcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLy8gQGNvbmQgRkxBVEJVRkZFUlNfSU5URVJOQUxcbi8qKlxuICogQ3JlYXRlIGEgbmV3IEJ5dGVCdWZmZXIgd2l0aCBhIGdpdmVuIGFycmF5IG9mIGJ5dGVzIChgVWludDhBcnJheWApLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtVaW50OEFycmF5fSBieXRlc1xuICovXG5mbGF0YnVmZmVycy5CeXRlQnVmZmVyID0gZnVuY3Rpb24oYnl0ZXMpIHtcbiAgLyoqXG4gICAqIEB0eXBlIHtVaW50OEFycmF5fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5ieXRlc18gPSBieXRlcztcblxuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMucG9zaXRpb25fID0gMDtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGFuZCBhbGxvY2F0ZSBhIG5ldyBCeXRlQnVmZmVyIHdpdGggYSBnaXZlbiBzaXplLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBieXRlX3NpemVcbiAqIEByZXR1cm5zIHshZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlcn1cbiAqL1xuZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlci5hbGxvY2F0ZSA9IGZ1bmN0aW9uKGJ5dGVfc2l6ZSkge1xuICByZXR1cm4gbmV3IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIobmV3IFVpbnQ4QXJyYXkoYnl0ZV9zaXplKSk7XG59O1xuXG5mbGF0YnVmZmVycy5CeXRlQnVmZmVyLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnBvc2l0aW9uXyA9IDA7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgdW5kZXJseWluZyBgVWludDhBcnJheWAuXG4gKlxuICogQHJldHVybnMge1VpbnQ4QXJyYXl9XG4gKi9cbmZsYXRidWZmZXJzLkJ5dGVCdWZmZXIucHJvdG90eXBlLmJ5dGVzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmJ5dGVzXztcbn07XG5cbi8qKlxuICogR2V0IHRoZSBidWZmZXIncyBwb3NpdGlvbi5cbiAqXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5mbGF0YnVmZmVycy5CeXRlQnVmZmVyLnByb3RvdHlwZS5wb3NpdGlvbiA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5wb3NpdGlvbl87XG59O1xuXG4vKipcbiAqIFNldCB0aGUgYnVmZmVyJ3MgcG9zaXRpb24uXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHBvc2l0aW9uXG4gKi9cbmZsYXRidWZmZXJzLkJ5dGVCdWZmZXIucHJvdG90eXBlLnNldFBvc2l0aW9uID0gZnVuY3Rpb24ocG9zaXRpb24pIHtcbiAgdGhpcy5wb3NpdGlvbl8gPSBwb3NpdGlvbjtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBidWZmZXIncyBjYXBhY2l0eS5cbiAqXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5mbGF0YnVmZmVycy5CeXRlQnVmZmVyLnByb3RvdHlwZS5jYXBhY2l0eSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5ieXRlc18ubGVuZ3RoO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5mbGF0YnVmZmVycy5CeXRlQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uKG9mZnNldCkge1xuICByZXR1cm4gdGhpcy5yZWFkVWludDgob2Zmc2V0KSA8PCAyNCA+PiAyNDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnQ4ID0gZnVuY3Rpb24ob2Zmc2V0KSB7XG4gIHJldHVybiB0aGlzLmJ5dGVzX1tvZmZzZXRdO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5mbGF0YnVmZmVycy5CeXRlQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTYgPSBmdW5jdGlvbihvZmZzZXQpIHtcbiAgcmV0dXJuIHRoaXMucmVhZFVpbnQxNihvZmZzZXQpIDw8IDE2ID4+IDE2O1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5mbGF0YnVmZmVycy5CeXRlQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludDE2ID0gZnVuY3Rpb24ob2Zmc2V0KSB7XG4gIHJldHVybiB0aGlzLmJ5dGVzX1tvZmZzZXRdIHwgdGhpcy5ieXRlc19bb2Zmc2V0ICsgMV0gPDwgODtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyID0gZnVuY3Rpb24ob2Zmc2V0KSB7XG4gIHJldHVybiB0aGlzLmJ5dGVzX1tvZmZzZXRdIHwgdGhpcy5ieXRlc19bb2Zmc2V0ICsgMV0gPDwgOCB8IHRoaXMuYnl0ZXNfW29mZnNldCArIDJdIDw8IDE2IHwgdGhpcy5ieXRlc19bb2Zmc2V0ICsgM10gPDwgMjQ7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmZsYXRidWZmZXJzLkJ5dGVCdWZmZXIucHJvdG90eXBlLnJlYWRVaW50MzIgPSBmdW5jdGlvbihvZmZzZXQpIHtcbiAgcmV0dXJuIHRoaXMucmVhZEludDMyKG9mZnNldCkgPj4+IDA7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAqIEByZXR1cm5zIHshZmxhdGJ1ZmZlcnMuTG9uZ31cbiAqL1xuZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlci5wcm90b3R5cGUucmVhZEludDY0ID0gZnVuY3Rpb24ob2Zmc2V0KSB7XG4gIHJldHVybiBuZXcgZmxhdGJ1ZmZlcnMuTG9uZyh0aGlzLnJlYWRJbnQzMihvZmZzZXQpLCB0aGlzLnJlYWRJbnQzMihvZmZzZXQgKyA0KSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAqIEByZXR1cm5zIHshZmxhdGJ1ZmZlcnMuTG9uZ31cbiAqL1xuZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnQ2NCA9IGZ1bmN0aW9uKG9mZnNldCkge1xuICByZXR1cm4gbmV3IGZsYXRidWZmZXJzLkxvbmcodGhpcy5yZWFkVWludDMyKG9mZnNldCksIHRoaXMucmVhZFVpbnQzMihvZmZzZXQgKyA0KSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmZsYXRidWZmZXJzLkJ5dGVCdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdDMyID0gZnVuY3Rpb24ob2Zmc2V0KSB7XG4gIGZsYXRidWZmZXJzLmludDMyWzBdID0gdGhpcy5yZWFkSW50MzIob2Zmc2V0KTtcbiAgcmV0dXJuIGZsYXRidWZmZXJzLmZsb2F0MzJbMF07XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmZsYXRidWZmZXJzLkJ5dGVCdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdDY0ID0gZnVuY3Rpb24ob2Zmc2V0KSB7XG4gIGZsYXRidWZmZXJzLmludDMyW2ZsYXRidWZmZXJzLmlzTGl0dGxlRW5kaWFuID8gMCA6IDFdID0gdGhpcy5yZWFkSW50MzIob2Zmc2V0KTtcbiAgZmxhdGJ1ZmZlcnMuaW50MzJbZmxhdGJ1ZmZlcnMuaXNMaXR0bGVFbmRpYW4gPyAxIDogMF0gPSB0aGlzLnJlYWRJbnQzMihvZmZzZXQgKyA0KTtcbiAgcmV0dXJuIGZsYXRidWZmZXJzLmZsb2F0NjRbMF07XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAqIEBwYXJhbSB7bnVtYmVyfGJvb2xlYW59IHZhbHVlXG4gKi9cbmZsYXRidWZmZXJzLkJ5dGVCdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uKG9mZnNldCwgdmFsdWUpIHtcbiAgdGhpcy5ieXRlc19bb2Zmc2V0XSA9IC8qKiBAdHlwZSB7bnVtYmVyfSAqLyh2YWx1ZSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICovXG5mbGF0YnVmZmVycy5CeXRlQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnQ4ID0gZnVuY3Rpb24ob2Zmc2V0LCB2YWx1ZSkge1xuICB0aGlzLmJ5dGVzX1tvZmZzZXRdID0gdmFsdWU7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICovXG5mbGF0YnVmZmVycy5CeXRlQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2ID0gZnVuY3Rpb24ob2Zmc2V0LCB2YWx1ZSkge1xuICB0aGlzLmJ5dGVzX1tvZmZzZXRdID0gdmFsdWU7XG4gIHRoaXMuYnl0ZXNfW29mZnNldCArIDFdID0gdmFsdWUgPj4gODtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gKi9cbmZsYXRidWZmZXJzLkJ5dGVCdWZmZXIucHJvdG90eXBlLndyaXRlVWludDE2ID0gZnVuY3Rpb24ob2Zmc2V0LCB2YWx1ZSkge1xuICAgIHRoaXMuYnl0ZXNfW29mZnNldF0gPSB2YWx1ZTtcbiAgICB0aGlzLmJ5dGVzX1tvZmZzZXQgKyAxXSA9IHZhbHVlID4+IDg7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICovXG5mbGF0YnVmZmVycy5CeXRlQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyID0gZnVuY3Rpb24ob2Zmc2V0LCB2YWx1ZSkge1xuICB0aGlzLmJ5dGVzX1tvZmZzZXRdID0gdmFsdWU7XG4gIHRoaXMuYnl0ZXNfW29mZnNldCArIDFdID0gdmFsdWUgPj4gODtcbiAgdGhpcy5ieXRlc19bb2Zmc2V0ICsgMl0gPSB2YWx1ZSA+PiAxNjtcbiAgdGhpcy5ieXRlc19bb2Zmc2V0ICsgM10gPSB2YWx1ZSA+PiAyNDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gKi9cbmZsYXRidWZmZXJzLkJ5dGVCdWZmZXIucHJvdG90eXBlLndyaXRlVWludDMyID0gZnVuY3Rpb24ob2Zmc2V0LCB2YWx1ZSkge1xuICAgIHRoaXMuYnl0ZXNfW29mZnNldF0gPSB2YWx1ZTtcbiAgICB0aGlzLmJ5dGVzX1tvZmZzZXQgKyAxXSA9IHZhbHVlID4+IDg7XG4gICAgdGhpcy5ieXRlc19bb2Zmc2V0ICsgMl0gPSB2YWx1ZSA+PiAxNjtcbiAgICB0aGlzLmJ5dGVzX1tvZmZzZXQgKyAzXSA9IHZhbHVlID4+IDI0O1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gKiBAcGFyYW0ge2ZsYXRidWZmZXJzLkxvbmd9IHZhbHVlXG4gKi9cbmZsYXRidWZmZXJzLkJ5dGVCdWZmZXIucHJvdG90eXBlLndyaXRlSW50NjQgPSBmdW5jdGlvbihvZmZzZXQsIHZhbHVlKSB7XG4gIHRoaXMud3JpdGVJbnQzMihvZmZzZXQsIHZhbHVlLmxvdyk7XG4gIHRoaXMud3JpdGVJbnQzMihvZmZzZXQgKyA0LCB2YWx1ZS5oaWdoKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICogQHBhcmFtIHtmbGF0YnVmZmVycy5Mb25nfSB2YWx1ZVxuICovXG5mbGF0YnVmZmVycy5CeXRlQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnQ2NCA9IGZ1bmN0aW9uKG9mZnNldCwgdmFsdWUpIHtcbiAgICB0aGlzLndyaXRlVWludDMyKG9mZnNldCwgdmFsdWUubG93KTtcbiAgICB0aGlzLndyaXRlVWludDMyKG9mZnNldCArIDQsIHZhbHVlLmhpZ2gpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAqL1xuZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdDMyID0gZnVuY3Rpb24ob2Zmc2V0LCB2YWx1ZSkge1xuICBmbGF0YnVmZmVycy5mbG9hdDMyWzBdID0gdmFsdWU7XG4gIHRoaXMud3JpdGVJbnQzMihvZmZzZXQsIGZsYXRidWZmZXJzLmludDMyWzBdKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gKi9cbmZsYXRidWZmZXJzLkJ5dGVCdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXQ2NCA9IGZ1bmN0aW9uKG9mZnNldCwgdmFsdWUpIHtcbiAgZmxhdGJ1ZmZlcnMuZmxvYXQ2NFswXSA9IHZhbHVlO1xuICB0aGlzLndyaXRlSW50MzIob2Zmc2V0LCBmbGF0YnVmZmVycy5pbnQzMltmbGF0YnVmZmVycy5pc0xpdHRsZUVuZGlhbiA/IDAgOiAxXSk7XG4gIHRoaXMud3JpdGVJbnQzMihvZmZzZXQgKyA0LCBmbGF0YnVmZmVycy5pbnQzMltmbGF0YnVmZmVycy5pc0xpdHRsZUVuZGlhbiA/IDEgOiAwXSk7XG59O1xuXG4vKipcbiAqIFJldHVybiB0aGUgZmlsZSBpZGVudGlmaWVyLiAgIEJlaGF2aW9yIGlzIHVuZGVmaW5lZCBmb3IgRmxhdEJ1ZmZlcnMgd2hvc2VcbiAqIHNjaGVtYSBkb2VzIG5vdCBpbmNsdWRlIGEgZmlsZV9pZGVudGlmaWVyIChsaWtlbHkgcG9pbnRzIGF0IHBhZGRpbmcgb3IgdGhlXG4gKiBzdGFydCBvZiBhIHRoZSByb290IHZ0YWJsZSkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mbGF0YnVmZmVycy5CeXRlQnVmZmVyLnByb3RvdHlwZS5nZXRCdWZmZXJJZGVudGlmaWVyID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLmJ5dGVzXy5sZW5ndGggPCB0aGlzLnBvc2l0aW9uXyArIGZsYXRidWZmZXJzLlNJWkVPRl9JTlQgK1xuICAgICAgZmxhdGJ1ZmZlcnMuRklMRV9JREVOVElGSUVSX0xFTkdUSCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0ZsYXRCdWZmZXJzOiBCeXRlQnVmZmVyIGlzIHRvbyBzaG9ydCB0byBjb250YWluIGFuIGlkZW50aWZpZXIuJyk7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IFwiXCI7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZmxhdGJ1ZmZlcnMuRklMRV9JREVOVElGSUVSX0xFTkdUSDsgaSsrKSB7XG4gICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoXG4gICAgICAgIHRoaXMucmVhZEludDgodGhpcy5wb3NpdGlvbl8gKyBmbGF0YnVmZmVycy5TSVpFT0ZfSU5UICsgaSkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIExvb2sgdXAgYSBmaWVsZCBpbiB0aGUgdnRhYmxlLCByZXR1cm4gYW4gb2Zmc2V0IGludG8gdGhlIG9iamVjdCwgb3IgMCBpZiB0aGVcbiAqIGZpZWxkIGlzIG5vdCBwcmVzZW50LlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBiYl9wb3NcbiAqIEBwYXJhbSB7bnVtYmVyfSB2dGFibGVfb2Zmc2V0XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5mbGF0YnVmZmVycy5CeXRlQnVmZmVyLnByb3RvdHlwZS5fX29mZnNldCA9IGZ1bmN0aW9uKGJiX3BvcywgdnRhYmxlX29mZnNldCkge1xuICB2YXIgdnRhYmxlID0gYmJfcG9zIC0gdGhpcy5yZWFkSW50MzIoYmJfcG9zKTtcbiAgcmV0dXJuIHZ0YWJsZV9vZmZzZXQgPCB0aGlzLnJlYWRJbnQxNih2dGFibGUpID8gdGhpcy5yZWFkSW50MTYodnRhYmxlICsgdnRhYmxlX29mZnNldCkgOiAwO1xufTtcblxuLyoqXG4gKiBJbml0aWFsaXplIGFueSBUYWJsZS1kZXJpdmVkIHR5cGUgdG8gcG9pbnQgdG8gdGhlIHVuaW9uIGF0IHRoZSBnaXZlbiBvZmZzZXQuXG4gKlxuICogQHBhcmFtIHtmbGF0YnVmZmVycy5UYWJsZX0gdFxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICogQHJldHVybnMge2ZsYXRidWZmZXJzLlRhYmxlfVxuICovXG5mbGF0YnVmZmVycy5CeXRlQnVmZmVyLnByb3RvdHlwZS5fX3VuaW9uID0gZnVuY3Rpb24odCwgb2Zmc2V0KSB7XG4gIHQuYmJfcG9zID0gb2Zmc2V0ICsgdGhpcy5yZWFkSW50MzIob2Zmc2V0KTtcbiAgdC5iYiA9IHRoaXM7XG4gIHJldHVybiB0O1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBKYXZhU2NyaXB0IHN0cmluZyBmcm9tIFVURi04IGRhdGEgc3RvcmVkIGluc2lkZSB0aGUgRmxhdEJ1ZmZlci5cbiAqIFRoaXMgYWxsb2NhdGVzIGEgbmV3IHN0cmluZyBhbmQgY29udmVydHMgdG8gd2lkZSBjaGFycyB1cG9uIGVhY2ggYWNjZXNzLlxuICpcbiAqIFRvIGF2b2lkIHRoZSBjb252ZXJzaW9uIHRvIFVURi0xNiwgcGFzcyBmbGF0YnVmZmVycy5FbmNvZGluZy5VVEY4X0JZVEVTIGFzXG4gKiB0aGUgXCJvcHRpb25hbEVuY29kaW5nXCIgYXJndW1lbnQuIFRoaXMgaXMgdXNlZnVsIGZvciBhdm9pZGluZyBjb252ZXJzaW9uIHRvXG4gKiBhbmQgZnJvbSBVVEYtMTYgd2hlbiB0aGUgZGF0YSB3aWxsIGp1c3QgYmUgcGFja2FnZWQgYmFjayB1cCBpbiBhbm90aGVyXG4gKiBGbGF0QnVmZmVyIGxhdGVyIG9uLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAqIEBwYXJhbSB7ZmxhdGJ1ZmZlcnMuRW5jb2Rpbmc9fSBvcHRfZW5jb2RpbmcgRGVmYXVsdHMgdG8gVVRGMTZfU1RSSU5HXG4gKiBAcmV0dXJucyB7c3RyaW5nfCFVaW50OEFycmF5fVxuICovXG5mbGF0YnVmZmVycy5CeXRlQnVmZmVyLnByb3RvdHlwZS5fX3N0cmluZyA9IGZ1bmN0aW9uKG9mZnNldCwgb3B0X2VuY29kaW5nKSB7XG4gIG9mZnNldCArPSB0aGlzLnJlYWRJbnQzMihvZmZzZXQpO1xuXG4gIHZhciBsZW5ndGggPSB0aGlzLnJlYWRJbnQzMihvZmZzZXQpO1xuICB2YXIgcmVzdWx0ID0gJyc7XG4gIHZhciBpID0gMDtcblxuICBvZmZzZXQgKz0gZmxhdGJ1ZmZlcnMuU0laRU9GX0lOVDtcblxuICBpZiAob3B0X2VuY29kaW5nID09PSBmbGF0YnVmZmVycy5FbmNvZGluZy5VVEY4X0JZVEVTKSB7XG4gICAgcmV0dXJuIHRoaXMuYnl0ZXNfLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgbGVuZ3RoKTtcbiAgfVxuXG4gIHdoaWxlIChpIDwgbGVuZ3RoKSB7XG4gICAgdmFyIGNvZGVQb2ludDtcblxuICAgIC8vIERlY29kZSBVVEYtOFxuICAgIHZhciBhID0gdGhpcy5yZWFkVWludDgob2Zmc2V0ICsgaSsrKTtcbiAgICBpZiAoYSA8IDB4QzApIHtcbiAgICAgIGNvZGVQb2ludCA9IGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBiID0gdGhpcy5yZWFkVWludDgob2Zmc2V0ICsgaSsrKTtcbiAgICAgIGlmIChhIDwgMHhFMCkge1xuICAgICAgICBjb2RlUG9pbnQgPVxuICAgICAgICAgICgoYSAmIDB4MUYpIDw8IDYpIHxcbiAgICAgICAgICAoYiAmIDB4M0YpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGMgPSB0aGlzLnJlYWRVaW50OChvZmZzZXQgKyBpKyspO1xuICAgICAgICBpZiAoYSA8IDB4RjApIHtcbiAgICAgICAgICBjb2RlUG9pbnQgPVxuICAgICAgICAgICAgKChhICYgMHgwRikgPDwgMTIpIHxcbiAgICAgICAgICAgICgoYiAmIDB4M0YpIDw8IDYpIHxcbiAgICAgICAgICAgIChjICYgMHgzRik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGQgPSB0aGlzLnJlYWRVaW50OChvZmZzZXQgKyBpKyspO1xuICAgICAgICAgIGNvZGVQb2ludCA9XG4gICAgICAgICAgICAoKGEgJiAweDA3KSA8PCAxOCkgfFxuICAgICAgICAgICAgKChiICYgMHgzRikgPDwgMTIpIHxcbiAgICAgICAgICAgICgoYyAmIDB4M0YpIDw8IDYpIHxcbiAgICAgICAgICAgIChkICYgMHgzRik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBFbmNvZGUgVVRGLTE2XG4gICAgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcbiAgICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGVQb2ludCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwO1xuICAgICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoXG4gICAgICAgIChjb2RlUG9pbnQgPj4gMTApICsgMHhEODAwLFxuICAgICAgICAoY29kZVBvaW50ICYgKCgxIDw8IDEwKSAtIDEpKSArIDB4REMwMCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogUmV0cmlldmUgdGhlIHJlbGF0aXZlIG9mZnNldCBzdG9yZWQgYXQgXCJvZmZzZXRcIlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlci5wcm90b3R5cGUuX19pbmRpcmVjdCA9IGZ1bmN0aW9uKG9mZnNldCkge1xuICByZXR1cm4gb2Zmc2V0ICsgdGhpcy5yZWFkSW50MzIob2Zmc2V0KTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBzdGFydCBvZiBkYXRhIG9mIGEgdmVjdG9yIHdob3NlIG9mZnNldCBpcyBzdG9yZWQgYXQgXCJvZmZzZXRcIiBpbiB0aGlzIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5mbGF0YnVmZmVycy5CeXRlQnVmZmVyLnByb3RvdHlwZS5fX3ZlY3RvciA9IGZ1bmN0aW9uKG9mZnNldCkge1xuICByZXR1cm4gb2Zmc2V0ICsgdGhpcy5yZWFkSW50MzIob2Zmc2V0KSArIGZsYXRidWZmZXJzLlNJWkVPRl9JTlQ7IC8vIGRhdGEgc3RhcnRzIGFmdGVyIHRoZSBsZW5ndGhcbn07XG5cbi8qKlxuICogR2V0IHRoZSBsZW5ndGggb2YgYSB2ZWN0b3Igd2hvc2Ugb2Zmc2V0IGlzIHN0b3JlZCBhdCBcIm9mZnNldFwiIGluIHRoaXMgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmZsYXRidWZmZXJzLkJ5dGVCdWZmZXIucHJvdG90eXBlLl9fdmVjdG9yX2xlbiA9IGZ1bmN0aW9uKG9mZnNldCkge1xuICByZXR1cm4gdGhpcy5yZWFkSW50MzIob2Zmc2V0ICsgdGhpcy5yZWFkSW50MzIob2Zmc2V0KSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBpZGVudFxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZsYXRidWZmZXJzLkJ5dGVCdWZmZXIucHJvdG90eXBlLl9faGFzX2lkZW50aWZpZXIgPSBmdW5jdGlvbihpZGVudCkge1xuICBpZiAoaWRlbnQubGVuZ3RoICE9IGZsYXRidWZmZXJzLkZJTEVfSURFTlRJRklFUl9MRU5HVEgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZsYXRCdWZmZXJzOiBmaWxlIGlkZW50aWZpZXIgbXVzdCBiZSBsZW5ndGggJyArXG4gICAgICAgICAgICAgICAgICAgIGZsYXRidWZmZXJzLkZJTEVfSURFTlRJRklFUl9MRU5HVEgpO1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZmxhdGJ1ZmZlcnMuRklMRV9JREVOVElGSUVSX0xFTkdUSDsgaSsrKSB7XG4gICAgaWYgKGlkZW50LmNoYXJDb2RlQXQoaSkgIT0gdGhpcy5yZWFkSW50OCh0aGlzLnBvc2l0aW9uXyArIGZsYXRidWZmZXJzLlNJWkVPRl9JTlQgKyBpKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogQSBoZWxwZXIgZnVuY3Rpb24gdG8gYXZvaWQgZ2VuZXJhdGVkIGNvZGUgZGVwZW5kaW5nIG9uIHRoaXMgZmlsZSBkaXJlY3RseS5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gbG93XG4gKiBAcGFyYW0ge251bWJlcn0gaGlnaFxuICogQHJldHVybnMgeyFmbGF0YnVmZmVycy5Mb25nfVxuICovXG5mbGF0YnVmZmVycy5CeXRlQnVmZmVyLnByb3RvdHlwZS5jcmVhdGVMb25nID0gZnVuY3Rpb24obG93LCBoaWdoKSB7XG4gIHJldHVybiBmbGF0YnVmZmVycy5Mb25nLmNyZWF0ZShsb3csIGhpZ2gpO1xufTtcblxuLy8gRXhwb3J0cyBmb3IgTm9kZS5qcyBhbmQgUmVxdWlyZUpTXG5leHBvcnQgeyBmbGF0YnVmZmVycyB9O1xuXG4vLy8gQGVuZGNvbmRcbi8vLyBAfVxuIiwgIi8vIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGVkIGJ5IHRoZSBGbGF0QnVmZmVycyBjb21waWxlciwgZG8gbm90IG1vZGlmeVxuLyogZXNsaW50LWRpc2FibGUgKi9cblxuaW1wb3J0IHtmbGF0YnVmZmVyc30gZnJvbSAnZmxhdGJ1ZmZlcnMnO1xuXG4vKipcbiAqIEBlbnVtIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBuYW1lc3BhY2Ugb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicyB7XG4gIGV4cG9ydCBlbnVtIEF0dHJpYnV0ZVR5cGUge1xuICAgIFVOREVGSU5FRCA9IDAsXG4gICAgRkxPQVQgPSAxLFxuICAgIElOVCA9IDIsXG4gICAgU1RSSU5HID0gMyxcbiAgICBURU5TT1IgPSA0LFxuICAgIEdSQVBIID0gNSxcbiAgICBGTE9BVFMgPSA2LFxuICAgIElOVFMgPSA3LFxuICAgIFNUUklOR1MgPSA4LFxuICAgIFRFTlNPUlMgPSA5LFxuICAgIEdSQVBIUyA9IDEwLFxuICAgIFNQQVJTRV9URU5TT1IgPSAxMSxcbiAgICBTUEFSU0VfVEVOU09SUyA9IDEyXG4gIH1cbn1cblxuLyoqXG4gKiBAZW51bSB7bnVtYmVyfVxuICovXG5leHBvcnQgbmFtZXNwYWNlIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMge1xuICBleHBvcnQgZW51bSBEaW1lbnNpb25WYWx1ZVR5cGUge1VOS05PV04gPSAwLCBWQUxVRSA9IDEsIFBBUkFNID0gMn1cbn1cblxuLyoqXG4gKiBAZW51bSB7bnVtYmVyfVxuICovXG5leHBvcnQgbmFtZXNwYWNlIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMge1xuICBleHBvcnQgZW51bSBUZW5zb3JEYXRhVHlwZSB7XG4gICAgVU5ERUZJTkVEID0gMCxcbiAgICBGTE9BVCA9IDEsXG4gICAgVUlOVDggPSAyLFxuICAgIElOVDggPSAzLFxuICAgIFVJTlQxNiA9IDQsXG4gICAgSU5UMTYgPSA1LFxuICAgIElOVDMyID0gNixcbiAgICBJTlQ2NCA9IDcsXG4gICAgU1RSSU5HID0gOCxcbiAgICBCT09MID0gOSxcbiAgICBGTE9BVDE2ID0gMTAsXG4gICAgRE9VQkxFID0gMTEsXG4gICAgVUlOVDMyID0gMTIsXG4gICAgVUlOVDY0ID0gMTMsXG4gICAgQ09NUExFWDY0ID0gMTQsXG4gICAgQ09NUExFWDEyOCA9IDE1LFxuICAgIEJGTE9BVDE2ID0gMTYsXG4gICAgRkxPQVQ4RTRNM0ZOID0gMTcsXG4gICAgRkxPQVQ4RTRNM0ZOVVogPSAxOCxcbiAgICBGTE9BVDhFNU0yID0gMTksXG4gICAgRkxPQVQ4RTVNMkZOVVogPSAyMCxcbiAgfVxufVxuXG4vKipcbiAqIEBlbnVtIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBuYW1lc3BhY2Ugb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicyB7XG4gIGV4cG9ydCBlbnVtIE5vZGVUeXBlIHtQcmltaXRpdmUgPSAwLCBGdXNlZCA9IDF9XG59XG5cbi8qKlxuICogQGVudW0ge251bWJlcn1cbiAqL1xuZXhwb3J0IG5hbWVzcGFjZSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzIHtcbiAgZXhwb3J0IGVudW0gVHlwZUluZm9WYWx1ZSB7Tk9ORSA9IDAsIHRlbnNvcl90eXBlID0gMSwgc2VxdWVuY2VfdHlwZSA9IDIsIG1hcF90eXBlID0gM31cbn1cblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZXhwb3J0IG5hbWVzcGFjZSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzIHtcbiAgZXhwb3J0IGNsYXNzIFNoYXBlIHtcbiAgICBiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlcnxudWxsID0gbnVsbDtcblxuICAgIGJiX3BvcyA9IDA7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIG51bWJlciBpXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcmV0dXJucyBTaGFwZVxuICAgICAqL1xuICAgIF9faW5pdChpOiBudW1iZXIsIGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyKTogU2hhcGUge1xuICAgICAgdGhpcy5iYl9wb3MgPSBpO1xuICAgICAgdGhpcy5iYiA9IGJiO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcGFyYW0gU2hhcGU9IG9ialxuICAgICAqIEByZXR1cm5zIFNoYXBlXG4gICAgICovXG4gICAgc3RhdGljIGdldFJvb3RBc1NoYXBlKGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyLCBvYmo/OiBTaGFwZSk6IFNoYXBlIHtcbiAgICAgIHJldHVybiAob2JqIHx8IG5ldyBTaGFwZSgpKS5fX2luaXQoYmIucmVhZEludDMyKGJiLnBvc2l0aW9uKCkpICsgYmIucG9zaXRpb24oKSwgYmIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHBhcmFtIFNoYXBlPSBvYmpcbiAgICAgKiBAcmV0dXJucyBTaGFwZVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRTaXplUHJlZml4ZWRSb290QXNTaGFwZShiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciwgb2JqPzogU2hhcGUpOiBTaGFwZSB7XG4gICAgICBiYi5zZXRQb3NpdGlvbihiYi5wb3NpdGlvbigpICsgZmxhdGJ1ZmZlcnMuU0laRV9QUkVGSVhfTEVOR1RIKTtcbiAgICAgIHJldHVybiAob2JqIHx8IG5ldyBTaGFwZSgpKS5fX2luaXQoYmIucmVhZEludDMyKGJiLnBvc2l0aW9uKCkpICsgYmIucG9zaXRpb24oKSwgYmIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBudW1iZXIgaW5kZXhcbiAgICAgKiBAcGFyYW0gb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5EaW1lbnNpb249IG9ialxuICAgICAqIEByZXR1cm5zIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuRGltZW5zaW9uXG4gICAgICovXG4gICAgZGltKGluZGV4OiBudW1iZXIsIG9iaj86IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuRGltZW5zaW9uKTogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5EaW1lbnNpb258bnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDQpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IChvYmogfHwgbmV3IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuRGltZW5zaW9uKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC5fX2luaXQodGhpcy5iYiEuX19pbmRpcmVjdCh0aGlzLmJiIS5fX3ZlY3Rvcih0aGlzLmJiX3BvcyArIG9mZnNldCkgKyBpbmRleCAqIDQpLCB0aGlzLmJiISkgOlxuICAgICAgICAgICAgICAgICAgICAgIG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgbnVtYmVyXG4gICAgICovXG4gICAgZGltTGVuZ3RoKCk6IG51bWJlciB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDQpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLl9fdmVjdG9yX2xlbih0aGlzLmJiX3BvcyArIG9mZnNldCkgOiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKi9cbiAgICBzdGF0aWMgc3RhcnRTaGFwZShidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyKSB7XG4gICAgICBidWlsZGVyLnN0YXJ0T2JqZWN0KDEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IGRpbU9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGREaW0oYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZGltT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoMCwgZGltT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIEFycmF5LjxmbGF0YnVmZmVycy5PZmZzZXQ+IGRhdGFcbiAgICAgKiBAcmV0dXJucyBmbGF0YnVmZmVycy5PZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlRGltVmVjdG9yKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGRhdGE6IGZsYXRidWZmZXJzLk9mZnNldFtdKTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRWZWN0b3IoNCwgZGF0YS5sZW5ndGgsIDQpO1xuICAgICAgZm9yIChsZXQgaSA9IGRhdGEubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgYnVpbGRlci5hZGRPZmZzZXQoZGF0YVtpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYnVpbGRlci5lbmRWZWN0b3IoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIG51bWJlciBudW1FbGVtc1xuICAgICAqL1xuICAgIHN0YXRpYyBzdGFydERpbVZlY3RvcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBudW1FbGVtczogbnVtYmVyKSB7XG4gICAgICBidWlsZGVyLnN0YXJ0VmVjdG9yKDQsIG51bUVsZW1zLCA0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHJldHVybnMgZmxhdGJ1ZmZlcnMuT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGVuZFNoYXBlKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIpOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgbGV0IG9mZnNldCA9IGJ1aWxkZXIuZW5kT2JqZWN0KCk7XG4gICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH1cblxuICAgIHN0YXRpYyBjcmVhdGVTaGFwZShidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBkaW1PZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCk6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBTaGFwZS5zdGFydFNoYXBlKGJ1aWxkZXIpO1xuICAgICAgU2hhcGUuYWRkRGltKGJ1aWxkZXIsIGRpbU9mZnNldCk7XG4gICAgICByZXR1cm4gU2hhcGUuZW5kU2hhcGUoYnVpbGRlcik7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5leHBvcnQgbmFtZXNwYWNlIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMge1xuICBleHBvcnQgY2xhc3MgRGltZW5zaW9uIHtcbiAgICBiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlcnxudWxsID0gbnVsbDtcblxuICAgIGJiX3BvcyA9IDA7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIG51bWJlciBpXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcmV0dXJucyBEaW1lbnNpb25cbiAgICAgKi9cbiAgICBfX2luaXQoaTogbnVtYmVyLCBiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlcik6IERpbWVuc2lvbiB7XG4gICAgICB0aGlzLmJiX3BvcyA9IGk7XG4gICAgICB0aGlzLmJiID0gYmI7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEBwYXJhbSBEaW1lbnNpb249IG9ialxuICAgICAqIEByZXR1cm5zIERpbWVuc2lvblxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRSb290QXNEaW1lbnNpb24oYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIsIG9iaj86IERpbWVuc2lvbik6IERpbWVuc2lvbiB7XG4gICAgICByZXR1cm4gKG9iaiB8fCBuZXcgRGltZW5zaW9uKCkpLl9faW5pdChiYi5yZWFkSW50MzIoYmIucG9zaXRpb24oKSkgKyBiYi5wb3NpdGlvbigpLCBiYik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcGFyYW0gRGltZW5zaW9uPSBvYmpcbiAgICAgKiBAcmV0dXJucyBEaW1lbnNpb25cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0U2l6ZVByZWZpeGVkUm9vdEFzRGltZW5zaW9uKGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyLCBvYmo/OiBEaW1lbnNpb24pOiBEaW1lbnNpb24ge1xuICAgICAgYmIuc2V0UG9zaXRpb24oYmIucG9zaXRpb24oKSArIGZsYXRidWZmZXJzLlNJWkVfUFJFRklYX0xFTkdUSCk7XG4gICAgICByZXR1cm4gKG9iaiB8fCBuZXcgRGltZW5zaW9uKCkpLl9faW5pdChiYi5yZWFkSW50MzIoYmIucG9zaXRpb24oKSkgKyBiYi5wb3NpdGlvbigpLCBiYik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuRGltZW5zaW9uVmFsdWU9IG9ialxuICAgICAqIEByZXR1cm5zIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuRGltZW5zaW9uVmFsdWV8bnVsbFxuICAgICAqL1xuICAgIHZhbHVlKG9iaj86IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuRGltZW5zaW9uVmFsdWUpOiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLkRpbWVuc2lvblZhbHVlfG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA0KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyAob2JqIHx8IG5ldyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLkRpbWVuc2lvblZhbHVlKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC5fX2luaXQodGhpcy5iYiEuX19pbmRpcmVjdCh0aGlzLmJiX3BvcyArIG9mZnNldCksIHRoaXMuYmIhKSA6XG4gICAgICAgICAgICAgICAgICAgICAgbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuRW5jb2Rpbmc9IG9wdGlvbmFsRW5jb2RpbmdcbiAgICAgKiBAcmV0dXJucyBzdHJpbmd8VWludDhBcnJheXxudWxsXG4gICAgICovXG4gICAgZGVub3RhdGlvbigpOiBzdHJpbmd8bnVsbDtcbiAgICBkZW5vdGF0aW9uKG9wdGlvbmFsRW5jb2Rpbmc6IGZsYXRidWZmZXJzLkVuY29kaW5nKTogc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbDtcbiAgICBkZW5vdGF0aW9uKG9wdGlvbmFsRW5jb2Rpbmc/OiBhbnkpOiBzdHJpbmd8VWludDhBcnJheXxudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgNik7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEuX19zdHJpbmcodGhpcy5iYl9wb3MgKyBvZmZzZXQsIG9wdGlvbmFsRW5jb2RpbmcpIDogbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICovXG4gICAgc3RhdGljIHN0YXJ0RGltZW5zaW9uKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIpIHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRPYmplY3QoMik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgdmFsdWVPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkVmFsdWUoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgdmFsdWVPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCgwLCB2YWx1ZU9mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgZGVub3RhdGlvbk9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGREZW5vdGF0aW9uKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGRlbm90YXRpb25PZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCgxLCBkZW5vdGF0aW9uT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHJldHVybnMgZmxhdGJ1ZmZlcnMuT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGVuZERpbWVuc2lvbihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyKTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIGxldCBvZmZzZXQgPSBidWlsZGVyLmVuZE9iamVjdCgpO1xuICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9XG5cbiAgICBzdGF0aWMgY3JlYXRlRGltZW5zaW9uKFxuICAgICAgICBidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCB2YWx1ZU9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0LFxuICAgICAgICBkZW5vdGF0aW9uT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgRGltZW5zaW9uLnN0YXJ0RGltZW5zaW9uKGJ1aWxkZXIpO1xuICAgICAgRGltZW5zaW9uLmFkZFZhbHVlKGJ1aWxkZXIsIHZhbHVlT2Zmc2V0KTtcbiAgICAgIERpbWVuc2lvbi5hZGREZW5vdGF0aW9uKGJ1aWxkZXIsIGRlbm90YXRpb25PZmZzZXQpO1xuICAgICAgcmV0dXJuIERpbWVuc2lvbi5lbmREaW1lbnNpb24oYnVpbGRlcik7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5leHBvcnQgbmFtZXNwYWNlIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMge1xuICBleHBvcnQgY2xhc3MgRGltZW5zaW9uVmFsdWUge1xuICAgIGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyfG51bGwgPSBudWxsO1xuXG4gICAgYmJfcG9zID0gMDtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbnVtYmVyIGlcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEByZXR1cm5zIERpbWVuc2lvblZhbHVlXG4gICAgICovXG4gICAgX19pbml0KGk6IG51bWJlciwgYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIpOiBEaW1lbnNpb25WYWx1ZSB7XG4gICAgICB0aGlzLmJiX3BvcyA9IGk7XG4gICAgICB0aGlzLmJiID0gYmI7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEBwYXJhbSBEaW1lbnNpb25WYWx1ZT0gb2JqXG4gICAgICogQHJldHVybnMgRGltZW5zaW9uVmFsdWVcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0Um9vdEFzRGltZW5zaW9uVmFsdWUoYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIsIG9iaj86IERpbWVuc2lvblZhbHVlKTogRGltZW5zaW9uVmFsdWUge1xuICAgICAgcmV0dXJuIChvYmogfHwgbmV3IERpbWVuc2lvblZhbHVlKCkpLl9faW5pdChiYi5yZWFkSW50MzIoYmIucG9zaXRpb24oKSkgKyBiYi5wb3NpdGlvbigpLCBiYik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcGFyYW0gRGltZW5zaW9uVmFsdWU9IG9ialxuICAgICAqIEByZXR1cm5zIERpbWVuc2lvblZhbHVlXG4gICAgICovXG4gICAgc3RhdGljIGdldFNpemVQcmVmaXhlZFJvb3RBc0RpbWVuc2lvblZhbHVlKGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyLCBvYmo/OiBEaW1lbnNpb25WYWx1ZSk6IERpbWVuc2lvblZhbHVlIHtcbiAgICAgIGJiLnNldFBvc2l0aW9uKGJiLnBvc2l0aW9uKCkgKyBmbGF0YnVmZmVycy5TSVpFX1BSRUZJWF9MRU5HVEgpO1xuICAgICAgcmV0dXJuIChvYmogfHwgbmV3IERpbWVuc2lvblZhbHVlKCkpLl9faW5pdChiYi5yZWFkSW50MzIoYmIucG9zaXRpb24oKSkgKyBiYi5wb3NpdGlvbigpLCBiYik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5EaW1lbnNpb25WYWx1ZVR5cGVcbiAgICAgKi9cbiAgICBkaW1UeXBlKCk6IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuRGltZW5zaW9uVmFsdWVUeXBlIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgNCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gLyoqICAqLyAodGhpcy5iYiEucmVhZEludDgodGhpcy5iYl9wb3MgKyBvZmZzZXQpKSA6XG4gICAgICAgICAgICAgICAgICAgICAgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5EaW1lbnNpb25WYWx1ZVR5cGUuVU5LTk9XTjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBmbGF0YnVmZmVycy5Mb25nXG4gICAgICovXG4gICAgZGltVmFsdWUoKTogZmxhdGJ1ZmZlcnMuTG9uZyB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDYpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLnJlYWRJbnQ2NCh0aGlzLmJiX3BvcyArIG9mZnNldCkgOiB0aGlzLmJiIS5jcmVhdGVMb25nKDAsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5FbmNvZGluZz0gb3B0aW9uYWxFbmNvZGluZ1xuICAgICAqIEByZXR1cm5zIHN0cmluZ3xVaW50OEFycmF5fG51bGxcbiAgICAgKi9cbiAgICBkaW1QYXJhbSgpOiBzdHJpbmd8bnVsbDtcbiAgICBkaW1QYXJhbShvcHRpb25hbEVuY29kaW5nOiBmbGF0YnVmZmVycy5FbmNvZGluZyk6IHN0cmluZ3xVaW50OEFycmF5fG51bGw7XG4gICAgZGltUGFyYW0ob3B0aW9uYWxFbmNvZGluZz86IGFueSk6IHN0cmluZ3xVaW50OEFycmF5fG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA4KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3N0cmluZyh0aGlzLmJiX3BvcyArIG9mZnNldCwgb3B0aW9uYWxFbmNvZGluZykgOiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKi9cbiAgICBzdGF0aWMgc3RhcnREaW1lbnNpb25WYWx1ZShidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyKSB7XG4gICAgICBidWlsZGVyLnN0YXJ0T2JqZWN0KDMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5EaW1lbnNpb25WYWx1ZVR5cGUgZGltVHlwZVxuICAgICAqL1xuICAgIHN0YXRpYyBhZGREaW1UeXBlKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGRpbVR5cGU6IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuRGltZW5zaW9uVmFsdWVUeXBlKSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkSW50OCgwLCBkaW1UeXBlLCBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLkRpbWVuc2lvblZhbHVlVHlwZS5VTktOT1dOKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkxvbmcgZGltVmFsdWVcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkRGltVmFsdWUoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZGltVmFsdWU6IGZsYXRidWZmZXJzLkxvbmcpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRJbnQ2NCgxLCBkaW1WYWx1ZSwgYnVpbGRlci5jcmVhdGVMb25nKDAsIDApKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCBkaW1QYXJhbU9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGREaW1QYXJhbShidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBkaW1QYXJhbU9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDIsIGRpbVBhcmFtT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHJldHVybnMgZmxhdGJ1ZmZlcnMuT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGVuZERpbWVuc2lvblZhbHVlKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIpOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgbGV0IG9mZnNldCA9IGJ1aWxkZXIuZW5kT2JqZWN0KCk7XG4gICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH1cblxuICAgIHN0YXRpYyBjcmVhdGVEaW1lbnNpb25WYWx1ZShcbiAgICAgICAgYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZGltVHlwZTogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5EaW1lbnNpb25WYWx1ZVR5cGUsXG4gICAgICAgIGRpbVZhbHVlOiBmbGF0YnVmZmVycy5Mb25nLCBkaW1QYXJhbU9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIERpbWVuc2lvblZhbHVlLnN0YXJ0RGltZW5zaW9uVmFsdWUoYnVpbGRlcik7XG4gICAgICBEaW1lbnNpb25WYWx1ZS5hZGREaW1UeXBlKGJ1aWxkZXIsIGRpbVR5cGUpO1xuICAgICAgRGltZW5zaW9uVmFsdWUuYWRkRGltVmFsdWUoYnVpbGRlciwgZGltVmFsdWUpO1xuICAgICAgRGltZW5zaW9uVmFsdWUuYWRkRGltUGFyYW0oYnVpbGRlciwgZGltUGFyYW1PZmZzZXQpO1xuICAgICAgcmV0dXJuIERpbWVuc2lvblZhbHVlLmVuZERpbWVuc2lvblZhbHVlKGJ1aWxkZXIpO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZXhwb3J0IG5hbWVzcGFjZSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzIHtcbiAgZXhwb3J0IGNsYXNzIFRlbnNvclR5cGVBbmRTaGFwZSB7XG4gICAgYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXJ8bnVsbCA9IG51bGw7XG5cbiAgICBiYl9wb3MgPSAwO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBudW1iZXIgaVxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHJldHVybnMgVGVuc29yVHlwZUFuZFNoYXBlXG4gICAgICovXG4gICAgX19pbml0KGk6IG51bWJlciwgYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIpOiBUZW5zb3JUeXBlQW5kU2hhcGUge1xuICAgICAgdGhpcy5iYl9wb3MgPSBpO1xuICAgICAgdGhpcy5iYiA9IGJiO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcGFyYW0gVGVuc29yVHlwZUFuZFNoYXBlPSBvYmpcbiAgICAgKiBAcmV0dXJucyBUZW5zb3JUeXBlQW5kU2hhcGVcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0Um9vdEFzVGVuc29yVHlwZUFuZFNoYXBlKGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyLCBvYmo/OiBUZW5zb3JUeXBlQW5kU2hhcGUpOiBUZW5zb3JUeXBlQW5kU2hhcGUge1xuICAgICAgcmV0dXJuIChvYmogfHwgbmV3IFRlbnNvclR5cGVBbmRTaGFwZSgpKS5fX2luaXQoYmIucmVhZEludDMyKGJiLnBvc2l0aW9uKCkpICsgYmIucG9zaXRpb24oKSwgYmIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHBhcmFtIFRlbnNvclR5cGVBbmRTaGFwZT0gb2JqXG4gICAgICogQHJldHVybnMgVGVuc29yVHlwZUFuZFNoYXBlXG4gICAgICovXG4gICAgc3RhdGljIGdldFNpemVQcmVmaXhlZFJvb3RBc1RlbnNvclR5cGVBbmRTaGFwZShiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciwgb2JqPzogVGVuc29yVHlwZUFuZFNoYXBlKTpcbiAgICAgICAgVGVuc29yVHlwZUFuZFNoYXBlIHtcbiAgICAgIGJiLnNldFBvc2l0aW9uKGJiLnBvc2l0aW9uKCkgKyBmbGF0YnVmZmVycy5TSVpFX1BSRUZJWF9MRU5HVEgpO1xuICAgICAgcmV0dXJuIChvYmogfHwgbmV3IFRlbnNvclR5cGVBbmRTaGFwZSgpKS5fX2luaXQoYmIucmVhZEludDMyKGJiLnBvc2l0aW9uKCkpICsgYmIucG9zaXRpb24oKSwgYmIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yRGF0YVR5cGVcbiAgICAgKi9cbiAgICBlbGVtVHlwZSgpOiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlRlbnNvckRhdGFUeXBlIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgNCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gLyoqICAqLyAodGhpcy5iYiEucmVhZEludDMyKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSkgOlxuICAgICAgICAgICAgICAgICAgICAgIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yRGF0YVR5cGUuVU5ERUZJTkVEO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlNoYXBlPSBvYmpcbiAgICAgKiBAcmV0dXJucyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlNoYXBlfG51bGxcbiAgICAgKi9cbiAgICBzaGFwZShvYmo/OiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlNoYXBlKTogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5TaGFwZXxudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgNik7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gKG9iaiB8fCBuZXcgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5TaGFwZSgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAuX19pbml0KHRoaXMuYmIhLl9faW5kaXJlY3QodGhpcy5iYl9wb3MgKyBvZmZzZXQpLCB0aGlzLmJiISkgOlxuICAgICAgICAgICAgICAgICAgICAgIG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqL1xuICAgIHN0YXRpYyBzdGFydFRlbnNvclR5cGVBbmRTaGFwZShidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyKSB7XG4gICAgICBidWlsZGVyLnN0YXJ0T2JqZWN0KDIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UZW5zb3JEYXRhVHlwZSBlbGVtVHlwZVxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRFbGVtVHlwZShidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBlbGVtVHlwZTogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UZW5zb3JEYXRhVHlwZSkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZEludDMyKDAsIGVsZW1UeXBlLCBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlRlbnNvckRhdGFUeXBlLlVOREVGSU5FRCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgc2hhcGVPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkU2hhcGUoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgc2hhcGVPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCgxLCBzaGFwZU9mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLk9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBlbmRUZW5zb3JUeXBlQW5kU2hhcGUoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlcik6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gYnVpbGRlci5lbmRPYmplY3QoKTtcbiAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfVxuXG4gICAgc3RhdGljIGNyZWF0ZVRlbnNvclR5cGVBbmRTaGFwZShcbiAgICAgICAgYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZWxlbVR5cGU6IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yRGF0YVR5cGUsXG4gICAgICAgIHNoYXBlT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgVGVuc29yVHlwZUFuZFNoYXBlLnN0YXJ0VGVuc29yVHlwZUFuZFNoYXBlKGJ1aWxkZXIpO1xuICAgICAgVGVuc29yVHlwZUFuZFNoYXBlLmFkZEVsZW1UeXBlKGJ1aWxkZXIsIGVsZW1UeXBlKTtcbiAgICAgIFRlbnNvclR5cGVBbmRTaGFwZS5hZGRTaGFwZShidWlsZGVyLCBzaGFwZU9mZnNldCk7XG4gICAgICByZXR1cm4gVGVuc29yVHlwZUFuZFNoYXBlLmVuZFRlbnNvclR5cGVBbmRTaGFwZShidWlsZGVyKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmV4cG9ydCBuYW1lc3BhY2Ugb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicyB7XG4gIGV4cG9ydCBjbGFzcyBNYXBUeXBlIHtcbiAgICBiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlcnxudWxsID0gbnVsbDtcblxuICAgIGJiX3BvcyA9IDA7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIG51bWJlciBpXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcmV0dXJucyBNYXBUeXBlXG4gICAgICovXG4gICAgX19pbml0KGk6IG51bWJlciwgYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIpOiBNYXBUeXBlIHtcbiAgICAgIHRoaXMuYmJfcG9zID0gaTtcbiAgICAgIHRoaXMuYmIgPSBiYjtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHBhcmFtIE1hcFR5cGU9IG9ialxuICAgICAqIEByZXR1cm5zIE1hcFR5cGVcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0Um9vdEFzTWFwVHlwZShiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciwgb2JqPzogTWFwVHlwZSk6IE1hcFR5cGUge1xuICAgICAgcmV0dXJuIChvYmogfHwgbmV3IE1hcFR5cGUoKSkuX19pbml0KGJiLnJlYWRJbnQzMihiYi5wb3NpdGlvbigpKSArIGJiLnBvc2l0aW9uKCksIGJiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEBwYXJhbSBNYXBUeXBlPSBvYmpcbiAgICAgKiBAcmV0dXJucyBNYXBUeXBlXG4gICAgICovXG4gICAgc3RhdGljIGdldFNpemVQcmVmaXhlZFJvb3RBc01hcFR5cGUoYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIsIG9iaj86IE1hcFR5cGUpOiBNYXBUeXBlIHtcbiAgICAgIGJiLnNldFBvc2l0aW9uKGJiLnBvc2l0aW9uKCkgKyBmbGF0YnVmZmVycy5TSVpFX1BSRUZJWF9MRU5HVEgpO1xuICAgICAgcmV0dXJuIChvYmogfHwgbmV3IE1hcFR5cGUoKSkuX19pbml0KGJiLnJlYWRJbnQzMihiYi5wb3NpdGlvbigpKSArIGJiLnBvc2l0aW9uKCksIGJiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlRlbnNvckRhdGFUeXBlXG4gICAgICovXG4gICAga2V5VHlwZSgpOiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlRlbnNvckRhdGFUeXBlIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgNCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gLyoqICAqLyAodGhpcy5iYiEucmVhZEludDMyKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSkgOlxuICAgICAgICAgICAgICAgICAgICAgIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yRGF0YVR5cGUuVU5ERUZJTkVEO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlR5cGVJbmZvPSBvYmpcbiAgICAgKiBAcmV0dXJucyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlR5cGVJbmZvfG51bGxcbiAgICAgKi9cbiAgICB2YWx1ZVR5cGUob2JqPzogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UeXBlSW5mbyk6IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVHlwZUluZm98bnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDYpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IChvYmogfHwgbmV3IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVHlwZUluZm8oKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLl9faW5pdCh0aGlzLmJiIS5fX2luZGlyZWN0KHRoaXMuYmJfcG9zICsgb2Zmc2V0KSwgdGhpcy5iYiEpIDpcbiAgICAgICAgICAgICAgICAgICAgICBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKi9cbiAgICBzdGF0aWMgc3RhcnRNYXBUeXBlKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIpIHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRPYmplY3QoMik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlRlbnNvckRhdGFUeXBlIGtleVR5cGVcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkS2V5VHlwZShidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBrZXlUeXBlOiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlRlbnNvckRhdGFUeXBlKSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkSW50MzIoMCwga2V5VHlwZSwgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UZW5zb3JEYXRhVHlwZS5VTkRFRklORUQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IHZhbHVlVHlwZU9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRWYWx1ZVR5cGUoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgdmFsdWVUeXBlT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoMSwgdmFsdWVUeXBlT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHJldHVybnMgZmxhdGJ1ZmZlcnMuT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGVuZE1hcFR5cGUoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlcik6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gYnVpbGRlci5lbmRPYmplY3QoKTtcbiAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfVxuXG4gICAgc3RhdGljIGNyZWF0ZU1hcFR5cGUoXG4gICAgICAgIGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGtleVR5cGU6IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yRGF0YVR5cGUsXG4gICAgICAgIHZhbHVlVHlwZU9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIE1hcFR5cGUuc3RhcnRNYXBUeXBlKGJ1aWxkZXIpO1xuICAgICAgTWFwVHlwZS5hZGRLZXlUeXBlKGJ1aWxkZXIsIGtleVR5cGUpO1xuICAgICAgTWFwVHlwZS5hZGRWYWx1ZVR5cGUoYnVpbGRlciwgdmFsdWVUeXBlT2Zmc2V0KTtcbiAgICAgIHJldHVybiBNYXBUeXBlLmVuZE1hcFR5cGUoYnVpbGRlcik7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5leHBvcnQgbmFtZXNwYWNlIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMge1xuICBleHBvcnQgY2xhc3MgU2VxdWVuY2VUeXBlIHtcbiAgICBiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlcnxudWxsID0gbnVsbDtcblxuICAgIGJiX3BvcyA9IDA7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIG51bWJlciBpXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcmV0dXJucyBTZXF1ZW5jZVR5cGVcbiAgICAgKi9cbiAgICBfX2luaXQoaTogbnVtYmVyLCBiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlcik6IFNlcXVlbmNlVHlwZSB7XG4gICAgICB0aGlzLmJiX3BvcyA9IGk7XG4gICAgICB0aGlzLmJiID0gYmI7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEBwYXJhbSBTZXF1ZW5jZVR5cGU9IG9ialxuICAgICAqIEByZXR1cm5zIFNlcXVlbmNlVHlwZVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRSb290QXNTZXF1ZW5jZVR5cGUoYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIsIG9iaj86IFNlcXVlbmNlVHlwZSk6IFNlcXVlbmNlVHlwZSB7XG4gICAgICByZXR1cm4gKG9iaiB8fCBuZXcgU2VxdWVuY2VUeXBlKCkpLl9faW5pdChiYi5yZWFkSW50MzIoYmIucG9zaXRpb24oKSkgKyBiYi5wb3NpdGlvbigpLCBiYik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcGFyYW0gU2VxdWVuY2VUeXBlPSBvYmpcbiAgICAgKiBAcmV0dXJucyBTZXF1ZW5jZVR5cGVcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0U2l6ZVByZWZpeGVkUm9vdEFzU2VxdWVuY2VUeXBlKGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyLCBvYmo/OiBTZXF1ZW5jZVR5cGUpOiBTZXF1ZW5jZVR5cGUge1xuICAgICAgYmIuc2V0UG9zaXRpb24oYmIucG9zaXRpb24oKSArIGZsYXRidWZmZXJzLlNJWkVfUFJFRklYX0xFTkdUSCk7XG4gICAgICByZXR1cm4gKG9iaiB8fCBuZXcgU2VxdWVuY2VUeXBlKCkpLl9faW5pdChiYi5yZWFkSW50MzIoYmIucG9zaXRpb24oKSkgKyBiYi5wb3NpdGlvbigpLCBiYik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVHlwZUluZm89IG9ialxuICAgICAqIEByZXR1cm5zIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVHlwZUluZm98bnVsbFxuICAgICAqL1xuICAgIGVsZW1UeXBlKG9iaj86IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVHlwZUluZm8pOiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlR5cGVJbmZvfG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA0KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyAob2JqIHx8IG5ldyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlR5cGVJbmZvKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC5fX2luaXQodGhpcy5iYiEuX19pbmRpcmVjdCh0aGlzLmJiX3BvcyArIG9mZnNldCksIHRoaXMuYmIhKSA6XG4gICAgICAgICAgICAgICAgICAgICAgbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICovXG4gICAgc3RhdGljIHN0YXJ0U2VxdWVuY2VUeXBlKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIpIHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRPYmplY3QoMSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgZWxlbVR5cGVPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkRWxlbVR5cGUoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZWxlbVR5cGVPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCgwLCBlbGVtVHlwZU9mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLk9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBlbmRTZXF1ZW5jZVR5cGUoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlcik6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gYnVpbGRlci5lbmRPYmplY3QoKTtcbiAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfVxuXG4gICAgc3RhdGljIGNyZWF0ZVNlcXVlbmNlVHlwZShidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBlbGVtVHlwZU9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIFNlcXVlbmNlVHlwZS5zdGFydFNlcXVlbmNlVHlwZShidWlsZGVyKTtcbiAgICAgIFNlcXVlbmNlVHlwZS5hZGRFbGVtVHlwZShidWlsZGVyLCBlbGVtVHlwZU9mZnNldCk7XG4gICAgICByZXR1cm4gU2VxdWVuY2VUeXBlLmVuZFNlcXVlbmNlVHlwZShidWlsZGVyKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmV4cG9ydCBuYW1lc3BhY2Ugb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicyB7XG4gIGV4cG9ydCBjbGFzcyBFZGdlRW5kIHtcbiAgICBiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlcnxudWxsID0gbnVsbDtcblxuICAgIGJiX3BvcyA9IDA7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIG51bWJlciBpXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcmV0dXJucyBFZGdlRW5kXG4gICAgICovXG4gICAgX19pbml0KGk6IG51bWJlciwgYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIpOiBFZGdlRW5kIHtcbiAgICAgIHRoaXMuYmJfcG9zID0gaTtcbiAgICAgIHRoaXMuYmIgPSBiYjtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIG51bWJlclxuICAgICAqL1xuICAgIG5vZGVJbmRleCgpOiBudW1iZXIge1xuICAgICAgcmV0dXJuIHRoaXMuYmIhLnJlYWRVaW50MzIodGhpcy5iYl9wb3MpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIG51bWJlclxuICAgICAqL1xuICAgIHNyY0FyZ0luZGV4KCk6IG51bWJlciB7XG4gICAgICByZXR1cm4gdGhpcy5iYiEucmVhZEludDMyKHRoaXMuYmJfcG9zICsgNCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgbnVtYmVyXG4gICAgICovXG4gICAgZHN0QXJnSW5kZXgoKTogbnVtYmVyIHtcbiAgICAgIHJldHVybiB0aGlzLmJiIS5yZWFkSW50MzIodGhpcy5iYl9wb3MgKyA4KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIG51bWJlciBub2RlX2luZGV4XG4gICAgICogQHBhcmFtIG51bWJlciBzcmNfYXJnX2luZGV4XG4gICAgICogQHBhcmFtIG51bWJlciBkc3RfYXJnX2luZGV4XG4gICAgICogQHJldHVybnMgZmxhdGJ1ZmZlcnMuT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZUVkZ2VFbmQoXG4gICAgICAgIGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIG5vZGVfaW5kZXg6IG51bWJlciwgc3JjX2FyZ19pbmRleDogbnVtYmVyLFxuICAgICAgICBkc3RfYXJnX2luZGV4OiBudW1iZXIpOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgYnVpbGRlci5wcmVwKDQsIDEyKTtcbiAgICAgIGJ1aWxkZXIud3JpdGVJbnQzMihkc3RfYXJnX2luZGV4KTtcbiAgICAgIGJ1aWxkZXIud3JpdGVJbnQzMihzcmNfYXJnX2luZGV4KTtcbiAgICAgIGJ1aWxkZXIud3JpdGVJbnQzMihub2RlX2luZGV4KTtcbiAgICAgIHJldHVybiBidWlsZGVyLm9mZnNldCgpO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZXhwb3J0IG5hbWVzcGFjZSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzIHtcbiAgZXhwb3J0IGNsYXNzIE5vZGVFZGdlIHtcbiAgICBiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlcnxudWxsID0gbnVsbDtcblxuICAgIGJiX3BvcyA9IDA7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIG51bWJlciBpXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcmV0dXJucyBOb2RlRWRnZVxuICAgICAqL1xuICAgIF9faW5pdChpOiBudW1iZXIsIGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyKTogTm9kZUVkZ2Uge1xuICAgICAgdGhpcy5iYl9wb3MgPSBpO1xuICAgICAgdGhpcy5iYiA9IGJiO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcGFyYW0gTm9kZUVkZ2U9IG9ialxuICAgICAqIEByZXR1cm5zIE5vZGVFZGdlXG4gICAgICovXG4gICAgc3RhdGljIGdldFJvb3RBc05vZGVFZGdlKGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyLCBvYmo/OiBOb2RlRWRnZSk6IE5vZGVFZGdlIHtcbiAgICAgIHJldHVybiAob2JqIHx8IG5ldyBOb2RlRWRnZSgpKS5fX2luaXQoYmIucmVhZEludDMyKGJiLnBvc2l0aW9uKCkpICsgYmIucG9zaXRpb24oKSwgYmIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHBhcmFtIE5vZGVFZGdlPSBvYmpcbiAgICAgKiBAcmV0dXJucyBOb2RlRWRnZVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRTaXplUHJlZml4ZWRSb290QXNOb2RlRWRnZShiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciwgb2JqPzogTm9kZUVkZ2UpOiBOb2RlRWRnZSB7XG4gICAgICBiYi5zZXRQb3NpdGlvbihiYi5wb3NpdGlvbigpICsgZmxhdGJ1ZmZlcnMuU0laRV9QUkVGSVhfTEVOR1RIKTtcbiAgICAgIHJldHVybiAob2JqIHx8IG5ldyBOb2RlRWRnZSgpKS5fX2luaXQoYmIucmVhZEludDMyKGJiLnBvc2l0aW9uKCkpICsgYmIucG9zaXRpb24oKSwgYmIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIG51bWJlclxuICAgICAqL1xuICAgIG5vZGVJbmRleCgpOiBudW1iZXIge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA0KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5yZWFkVWludDMyKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSA6IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIG51bWJlciBpbmRleFxuICAgICAqIEBwYXJhbSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLkVkZ2VFbmQ9IG9ialxuICAgICAqIEByZXR1cm5zIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuRWRnZUVuZFxuICAgICAqL1xuICAgIGlucHV0RWRnZXMoaW5kZXg6IG51bWJlciwgb2JqPzogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5FZGdlRW5kKTogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5FZGdlRW5kfG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA2KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyAob2JqIHx8IG5ldyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLkVkZ2VFbmQoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLl9faW5pdCh0aGlzLmJiIS5fX3ZlY3Rvcih0aGlzLmJiX3BvcyArIG9mZnNldCkgKyBpbmRleCAqIDEyLCB0aGlzLmJiISkgOlxuICAgICAgICAgICAgICAgICAgICAgIG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgbnVtYmVyXG4gICAgICovXG4gICAgaW5wdXRFZGdlc0xlbmd0aCgpOiBudW1iZXIge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA2KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MgKyBvZmZzZXQpIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbnVtYmVyIGluZGV4XG4gICAgICogQHBhcmFtIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuRWRnZUVuZD0gb2JqXG4gICAgICogQHJldHVybnMgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5FZGdlRW5kXG4gICAgICovXG4gICAgb3V0cHV0RWRnZXMoaW5kZXg6IG51bWJlciwgb2JqPzogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5FZGdlRW5kKTogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5FZGdlRW5kfG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA4KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyAob2JqIHx8IG5ldyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLkVkZ2VFbmQoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLl9faW5pdCh0aGlzLmJiIS5fX3ZlY3Rvcih0aGlzLmJiX3BvcyArIG9mZnNldCkgKyBpbmRleCAqIDEyLCB0aGlzLmJiISkgOlxuICAgICAgICAgICAgICAgICAgICAgIG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgbnVtYmVyXG4gICAgICovXG4gICAgb3V0cHV0RWRnZXNMZW5ndGgoKTogbnVtYmVyIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgOCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSA6IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqL1xuICAgIHN0YXRpYyBzdGFydE5vZGVFZGdlKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIpIHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRPYmplY3QoMyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBudW1iZXIgbm9kZUluZGV4XG4gICAgICovXG4gICAgc3RhdGljIGFkZE5vZGVJbmRleChidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBub2RlSW5kZXg6IG51bWJlcikge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZEludDMyKDAsIG5vZGVJbmRleCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgaW5wdXRFZGdlc09mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRJbnB1dEVkZ2VzKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGlucHV0RWRnZXNPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCgxLCBpbnB1dEVkZ2VzT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIG51bWJlciBudW1FbGVtc1xuICAgICAqL1xuICAgIHN0YXRpYyBzdGFydElucHV0RWRnZXNWZWN0b3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgbnVtRWxlbXM6IG51bWJlcikge1xuICAgICAgYnVpbGRlci5zdGFydFZlY3RvcigxMiwgbnVtRWxlbXMsIDQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IG91dHB1dEVkZ2VzT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZE91dHB1dEVkZ2VzKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIG91dHB1dEVkZ2VzT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoMiwgb3V0cHV0RWRnZXNPZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gbnVtYmVyIG51bUVsZW1zXG4gICAgICovXG4gICAgc3RhdGljIHN0YXJ0T3V0cHV0RWRnZXNWZWN0b3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgbnVtRWxlbXM6IG51bWJlcikge1xuICAgICAgYnVpbGRlci5zdGFydFZlY3RvcigxMiwgbnVtRWxlbXMsIDQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcmV0dXJucyBmbGF0YnVmZmVycy5PZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgZW5kTm9kZUVkZ2UoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlcik6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gYnVpbGRlci5lbmRPYmplY3QoKTtcbiAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfVxuXG4gICAgc3RhdGljIGNyZWF0ZU5vZGVFZGdlKFxuICAgICAgICBidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBub2RlSW5kZXg6IG51bWJlciwgaW5wdXRFZGdlc09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0LFxuICAgICAgICBvdXRwdXRFZGdlc09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIE5vZGVFZGdlLnN0YXJ0Tm9kZUVkZ2UoYnVpbGRlcik7XG4gICAgICBOb2RlRWRnZS5hZGROb2RlSW5kZXgoYnVpbGRlciwgbm9kZUluZGV4KTtcbiAgICAgIE5vZGVFZGdlLmFkZElucHV0RWRnZXMoYnVpbGRlciwgaW5wdXRFZGdlc09mZnNldCk7XG4gICAgICBOb2RlRWRnZS5hZGRPdXRwdXRFZGdlcyhidWlsZGVyLCBvdXRwdXRFZGdlc09mZnNldCk7XG4gICAgICByZXR1cm4gTm9kZUVkZ2UuZW5kTm9kZUVkZ2UoYnVpbGRlcik7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5leHBvcnQgbmFtZXNwYWNlIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMge1xuICBleHBvcnQgY2xhc3MgTm9kZSB7XG4gICAgYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXJ8bnVsbCA9IG51bGw7XG5cbiAgICBiYl9wb3MgPSAwO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBudW1iZXIgaVxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHJldHVybnMgTm9kZVxuICAgICAqL1xuICAgIF9faW5pdChpOiBudW1iZXIsIGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyKTogTm9kZSB7XG4gICAgICB0aGlzLmJiX3BvcyA9IGk7XG4gICAgICB0aGlzLmJiID0gYmI7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEBwYXJhbSBOb2RlPSBvYmpcbiAgICAgKiBAcmV0dXJucyBOb2RlXG4gICAgICovXG4gICAgc3RhdGljIGdldFJvb3RBc05vZGUoYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIsIG9iaj86IE5vZGUpOiBOb2RlIHtcbiAgICAgIHJldHVybiAob2JqIHx8IG5ldyBOb2RlKCkpLl9faW5pdChiYi5yZWFkSW50MzIoYmIucG9zaXRpb24oKSkgKyBiYi5wb3NpdGlvbigpLCBiYik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcGFyYW0gTm9kZT0gb2JqXG4gICAgICogQHJldHVybnMgTm9kZVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRTaXplUHJlZml4ZWRSb290QXNOb2RlKGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyLCBvYmo/OiBOb2RlKTogTm9kZSB7XG4gICAgICBiYi5zZXRQb3NpdGlvbihiYi5wb3NpdGlvbigpICsgZmxhdGJ1ZmZlcnMuU0laRV9QUkVGSVhfTEVOR1RIKTtcbiAgICAgIHJldHVybiAob2JqIHx8IG5ldyBOb2RlKCkpLl9faW5pdChiYi5yZWFkSW50MzIoYmIucG9zaXRpb24oKSkgKyBiYi5wb3NpdGlvbigpLCBiYik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkVuY29kaW5nPSBvcHRpb25hbEVuY29kaW5nXG4gICAgICogQHJldHVybnMgc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbFxuICAgICAqL1xuICAgIG5hbWUoKTogc3RyaW5nfG51bGw7XG4gICAgbmFtZShvcHRpb25hbEVuY29kaW5nOiBmbGF0YnVmZmVycy5FbmNvZGluZyk6IHN0cmluZ3xVaW50OEFycmF5fG51bGw7XG4gICAgbmFtZShvcHRpb25hbEVuY29kaW5nPzogYW55KTogc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDQpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLl9fc3RyaW5nKHRoaXMuYmJfcG9zICsgb2Zmc2V0LCBvcHRpb25hbEVuY29kaW5nKSA6IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkVuY29kaW5nPSBvcHRpb25hbEVuY29kaW5nXG4gICAgICogQHJldHVybnMgc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbFxuICAgICAqL1xuICAgIGRvY1N0cmluZygpOiBzdHJpbmd8bnVsbDtcbiAgICBkb2NTdHJpbmcob3B0aW9uYWxFbmNvZGluZzogZmxhdGJ1ZmZlcnMuRW5jb2RpbmcpOiBzdHJpbmd8VWludDhBcnJheXxudWxsO1xuICAgIGRvY1N0cmluZyhvcHRpb25hbEVuY29kaW5nPzogYW55KTogc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDYpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLl9fc3RyaW5nKHRoaXMuYmJfcG9zICsgb2Zmc2V0LCBvcHRpb25hbEVuY29kaW5nKSA6IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkVuY29kaW5nPSBvcHRpb25hbEVuY29kaW5nXG4gICAgICogQHJldHVybnMgc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbFxuICAgICAqL1xuICAgIGRvbWFpbigpOiBzdHJpbmd8bnVsbDtcbiAgICBkb21haW4ob3B0aW9uYWxFbmNvZGluZzogZmxhdGJ1ZmZlcnMuRW5jb2RpbmcpOiBzdHJpbmd8VWludDhBcnJheXxudWxsO1xuICAgIGRvbWFpbihvcHRpb25hbEVuY29kaW5nPzogYW55KTogc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDgpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLl9fc3RyaW5nKHRoaXMuYmJfcG9zICsgb2Zmc2V0LCBvcHRpb25hbEVuY29kaW5nKSA6IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgbnVtYmVyXG4gICAgICovXG4gICAgc2luY2VWZXJzaW9uKCk6IG51bWJlciB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDEwKTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5yZWFkSW50MzIodGhpcy5iYl9wb3MgKyBvZmZzZXQpIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICAgKi9cbiAgICBpbmRleCgpOiBudW1iZXIge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCAxMik7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEucmVhZFVpbnQzMih0aGlzLmJiX3BvcyArIG9mZnNldCkgOiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5FbmNvZGluZz0gb3B0aW9uYWxFbmNvZGluZ1xuICAgICAqIEByZXR1cm5zIHN0cmluZ3xVaW50OEFycmF5fG51bGxcbiAgICAgKi9cbiAgICBvcFR5cGUoKTogc3RyaW5nfG51bGw7XG4gICAgb3BUeXBlKG9wdGlvbmFsRW5jb2Rpbmc6IGZsYXRidWZmZXJzLkVuY29kaW5nKTogc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbDtcbiAgICBvcFR5cGUob3B0aW9uYWxFbmNvZGluZz86IGFueSk6IHN0cmluZ3xVaW50OEFycmF5fG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCAxNCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEuX19zdHJpbmcodGhpcy5iYl9wb3MgKyBvZmZzZXQsIG9wdGlvbmFsRW5jb2RpbmcpIDogbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLk5vZGVUeXBlXG4gICAgICovXG4gICAgdHlwZSgpOiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLk5vZGVUeXBlIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgMTYpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IC8qKiAgKi8gKHRoaXMuYmIhLnJlYWRJbnQzMih0aGlzLmJiX3BvcyArIG9mZnNldCkpIDpcbiAgICAgICAgICAgICAgICAgICAgICBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLk5vZGVUeXBlLlByaW1pdGl2ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuRW5jb2Rpbmc9IG9wdGlvbmFsRW5jb2RpbmdcbiAgICAgKiBAcmV0dXJucyBzdHJpbmd8VWludDhBcnJheXxudWxsXG4gICAgICovXG4gICAgZXhlY3V0aW9uUHJvdmlkZXJUeXBlKCk6IHN0cmluZ3xudWxsO1xuICAgIGV4ZWN1dGlvblByb3ZpZGVyVHlwZShvcHRpb25hbEVuY29kaW5nOiBmbGF0YnVmZmVycy5FbmNvZGluZyk6IHN0cmluZ3xVaW50OEFycmF5fG51bGw7XG4gICAgZXhlY3V0aW9uUHJvdmlkZXJUeXBlKG9wdGlvbmFsRW5jb2Rpbmc/OiBhbnkpOiBzdHJpbmd8VWludDhBcnJheXxudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgMTgpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLl9fc3RyaW5nKHRoaXMuYmJfcG9zICsgb2Zmc2V0LCBvcHRpb25hbEVuY29kaW5nKSA6IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIG51bWJlciBpbmRleFxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5FbmNvZGluZz0gb3B0aW9uYWxFbmNvZGluZ1xuICAgICAqIEByZXR1cm5zIHN0cmluZ3xVaW50OEFycmF5XG4gICAgICovXG4gICAgaW5wdXRzKGluZGV4OiBudW1iZXIpOiBzdHJpbmc7XG4gICAgaW5wdXRzKGluZGV4OiBudW1iZXIsIG9wdGlvbmFsRW5jb2Rpbmc6IGZsYXRidWZmZXJzLkVuY29kaW5nKTogc3RyaW5nfFVpbnQ4QXJyYXk7XG4gICAgaW5wdXRzKGluZGV4OiBudW1iZXIsIG9wdGlvbmFsRW5jb2Rpbmc/OiBhbnkpOiBzdHJpbmd8VWludDhBcnJheXxudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgMjApO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLl9fc3RyaW5nKHRoaXMuYmIhLl9fdmVjdG9yKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSArIGluZGV4ICogNCwgb3B0aW9uYWxFbmNvZGluZykgOiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIG51bWJlclxuICAgICAqL1xuICAgIGlucHV0c0xlbmd0aCgpOiBudW1iZXIge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCAyMCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSA6IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIG51bWJlciBpbmRleFxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5FbmNvZGluZz0gb3B0aW9uYWxFbmNvZGluZ1xuICAgICAqIEByZXR1cm5zIHN0cmluZ3xVaW50OEFycmF5XG4gICAgICovXG4gICAgb3V0cHV0cyhpbmRleDogbnVtYmVyKTogc3RyaW5nO1xuICAgIG91dHB1dHMoaW5kZXg6IG51bWJlciwgb3B0aW9uYWxFbmNvZGluZzogZmxhdGJ1ZmZlcnMuRW5jb2RpbmcpOiBzdHJpbmd8VWludDhBcnJheTtcbiAgICBvdXRwdXRzKGluZGV4OiBudW1iZXIsIG9wdGlvbmFsRW5jb2Rpbmc/OiBhbnkpOiBzdHJpbmd8VWludDhBcnJheXxudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgMjIpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLl9fc3RyaW5nKHRoaXMuYmIhLl9fdmVjdG9yKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSArIGluZGV4ICogNCwgb3B0aW9uYWxFbmNvZGluZykgOiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIG51bWJlclxuICAgICAqL1xuICAgIG91dHB1dHNMZW5ndGgoKTogbnVtYmVyIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgMjIpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLl9fdmVjdG9yX2xlbih0aGlzLmJiX3BvcyArIG9mZnNldCkgOiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBudW1iZXIgaW5kZXhcbiAgICAgKiBAcGFyYW0gb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5BdHRyaWJ1dGU9IG9ialxuICAgICAqIEByZXR1cm5zIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuQXR0cmlidXRlXG4gICAgICovXG4gICAgYXR0cmlidXRlcyhpbmRleDogbnVtYmVyLCBvYmo/OiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLkF0dHJpYnV0ZSk6IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuQXR0cmlidXRlXG4gICAgICAgIHxudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgMjQpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IChvYmogfHwgbmV3IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuQXR0cmlidXRlKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC5fX2luaXQodGhpcy5iYiEuX19pbmRpcmVjdCh0aGlzLmJiIS5fX3ZlY3Rvcih0aGlzLmJiX3BvcyArIG9mZnNldCkgKyBpbmRleCAqIDQpLCB0aGlzLmJiISkgOlxuICAgICAgICAgICAgICAgICAgICAgIG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgbnVtYmVyXG4gICAgICovXG4gICAgYXR0cmlidXRlc0xlbmd0aCgpOiBudW1iZXIge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCAyNCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSA6IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIG51bWJlciBpbmRleFxuICAgICAqIEByZXR1cm5zIG51bWJlclxuICAgICAqL1xuICAgIGlucHV0QXJnQ291bnRzKGluZGV4OiBudW1iZXIpOiBudW1iZXJ8bnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDI2KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5yZWFkSW50MzIodGhpcy5iYiEuX192ZWN0b3IodGhpcy5iYl9wb3MgKyBvZmZzZXQpICsgaW5kZXggKiA0KSA6IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgbnVtYmVyXG4gICAgICovXG4gICAgaW5wdXRBcmdDb3VudHNMZW5ndGgoKTogbnVtYmVyIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgMjYpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLl9fdmVjdG9yX2xlbih0aGlzLmJiX3BvcyArIG9mZnNldCkgOiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIEludDMyQXJyYXlcbiAgICAgKi9cbiAgICBpbnB1dEFyZ0NvdW50c0FycmF5KCk6IEludDMyQXJyYXl8bnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDI2KTtcbiAgICAgIHJldHVybiBvZmZzZXQgP1xuICAgICAgICAgIG5ldyBJbnQzMkFycmF5KFxuICAgICAgICAgICAgICB0aGlzLmJiIS5ieXRlcygpLmJ1ZmZlciwgdGhpcy5iYiEuYnl0ZXMoKS5ieXRlT2Zmc2V0ICsgdGhpcy5iYiEuX192ZWN0b3IodGhpcy5iYl9wb3MgKyBvZmZzZXQpLFxuICAgICAgICAgICAgICB0aGlzLmJiIS5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MgKyBvZmZzZXQpKSA6XG4gICAgICAgICAgbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbnVtYmVyIGluZGV4XG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkVuY29kaW5nPSBvcHRpb25hbEVuY29kaW5nXG4gICAgICogQHJldHVybnMgc3RyaW5nfFVpbnQ4QXJyYXlcbiAgICAgKi9cbiAgICBpbXBsaWNpdElucHV0cyhpbmRleDogbnVtYmVyKTogc3RyaW5nO1xuICAgIGltcGxpY2l0SW5wdXRzKGluZGV4OiBudW1iZXIsIG9wdGlvbmFsRW5jb2Rpbmc6IGZsYXRidWZmZXJzLkVuY29kaW5nKTogc3RyaW5nfFVpbnQ4QXJyYXk7XG4gICAgaW1wbGljaXRJbnB1dHMoaW5kZXg6IG51bWJlciwgb3B0aW9uYWxFbmNvZGluZz86IGFueSk6IHN0cmluZ3xVaW50OEFycmF5fG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCAyOCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEuX19zdHJpbmcodGhpcy5iYiEuX192ZWN0b3IodGhpcy5iYl9wb3MgKyBvZmZzZXQpICsgaW5kZXggKiA0LCBvcHRpb25hbEVuY29kaW5nKSA6IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgbnVtYmVyXG4gICAgICovXG4gICAgaW1wbGljaXRJbnB1dHNMZW5ndGgoKTogbnVtYmVyIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgMjgpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLl9fdmVjdG9yX2xlbih0aGlzLmJiX3BvcyArIG9mZnNldCkgOiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKi9cbiAgICBzdGF0aWMgc3RhcnROb2RlKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIpIHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRPYmplY3QoMTMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IG5hbWVPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkTmFtZShidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBuYW1lT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoMCwgbmFtZU9mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgZG9jU3RyaW5nT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZERvY1N0cmluZyhidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBkb2NTdHJpbmdPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCgxLCBkb2NTdHJpbmdPZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IGRvbWFpbk9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGREb21haW4oYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZG9tYWluT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoMiwgZG9tYWluT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIG51bWJlciBzaW5jZVZlcnNpb25cbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkU2luY2VWZXJzaW9uKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIHNpbmNlVmVyc2lvbjogbnVtYmVyKSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkSW50MzIoMywgc2luY2VWZXJzaW9uLCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIG51bWJlciBpbmRleFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRJbmRleChidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBpbmRleDogbnVtYmVyKSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkSW50MzIoNCwgaW5kZXgsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IG9wVHlwZU9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRPcFR5cGUoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgb3BUeXBlT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoNSwgb3BUeXBlT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuTm9kZVR5cGUgdHlwZVxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRUeXBlKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIHR5cGU6IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuTm9kZVR5cGUpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRJbnQzMig2LCB0eXBlLCBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLk5vZGVUeXBlLlByaW1pdGl2ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgZXhlY3V0aW9uUHJvdmlkZXJUeXBlT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZEV4ZWN1dGlvblByb3ZpZGVyVHlwZShidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBleGVjdXRpb25Qcm92aWRlclR5cGVPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCg3LCBleGVjdXRpb25Qcm92aWRlclR5cGVPZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IGlucHV0c09mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRJbnB1dHMoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgaW5wdXRzT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoOCwgaW5wdXRzT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIEFycmF5LjxmbGF0YnVmZmVycy5PZmZzZXQ+IGRhdGFcbiAgICAgKiBAcmV0dXJucyBmbGF0YnVmZmVycy5PZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlSW5wdXRzVmVjdG9yKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGRhdGE6IGZsYXRidWZmZXJzLk9mZnNldFtdKTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRWZWN0b3IoNCwgZGF0YS5sZW5ndGgsIDQpO1xuICAgICAgZm9yIChsZXQgaSA9IGRhdGEubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgYnVpbGRlci5hZGRPZmZzZXQoZGF0YVtpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYnVpbGRlci5lbmRWZWN0b3IoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIG51bWJlciBudW1FbGVtc1xuICAgICAqL1xuICAgIHN0YXRpYyBzdGFydElucHV0c1ZlY3RvcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBudW1FbGVtczogbnVtYmVyKSB7XG4gICAgICBidWlsZGVyLnN0YXJ0VmVjdG9yKDQsIG51bUVsZW1zLCA0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCBvdXRwdXRzT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZE91dHB1dHMoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgb3V0cHV0c09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDksIG91dHB1dHNPZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gQXJyYXkuPGZsYXRidWZmZXJzLk9mZnNldD4gZGF0YVxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLk9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVPdXRwdXRzVmVjdG9yKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGRhdGE6IGZsYXRidWZmZXJzLk9mZnNldFtdKTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRWZWN0b3IoNCwgZGF0YS5sZW5ndGgsIDQpO1xuICAgICAgZm9yIChsZXQgaSA9IGRhdGEubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgYnVpbGRlci5hZGRPZmZzZXQoZGF0YVtpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYnVpbGRlci5lbmRWZWN0b3IoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIG51bWJlciBudW1FbGVtc1xuICAgICAqL1xuICAgIHN0YXRpYyBzdGFydE91dHB1dHNWZWN0b3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgbnVtRWxlbXM6IG51bWJlcikge1xuICAgICAgYnVpbGRlci5zdGFydFZlY3Rvcig0LCBudW1FbGVtcywgNCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgYXR0cmlidXRlc09mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRBdHRyaWJ1dGVzKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGF0dHJpYnV0ZXNPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCgxMCwgYXR0cmlidXRlc09mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBBcnJheS48ZmxhdGJ1ZmZlcnMuT2Zmc2V0PiBkYXRhXG4gICAgICogQHJldHVybnMgZmxhdGJ1ZmZlcnMuT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZUF0dHJpYnV0ZXNWZWN0b3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZGF0YTogZmxhdGJ1ZmZlcnMuT2Zmc2V0W10pOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgYnVpbGRlci5zdGFydFZlY3Rvcig0LCBkYXRhLmxlbmd0aCwgNCk7XG4gICAgICBmb3IgKGxldCBpID0gZGF0YS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBidWlsZGVyLmFkZE9mZnNldChkYXRhW2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBidWlsZGVyLmVuZFZlY3RvcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gbnVtYmVyIG51bUVsZW1zXG4gICAgICovXG4gICAgc3RhdGljIHN0YXJ0QXR0cmlidXRlc1ZlY3RvcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBudW1FbGVtczogbnVtYmVyKSB7XG4gICAgICBidWlsZGVyLnN0YXJ0VmVjdG9yKDQsIG51bUVsZW1zLCA0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCBpbnB1dEFyZ0NvdW50c09mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRJbnB1dEFyZ0NvdW50cyhidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBpbnB1dEFyZ0NvdW50c09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDExLCBpbnB1dEFyZ0NvdW50c09mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBBcnJheS48bnVtYmVyPiBkYXRhXG4gICAgICogQHJldHVybnMgZmxhdGJ1ZmZlcnMuT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZUlucHV0QXJnQ291bnRzVmVjdG9yKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGRhdGE6IG51bWJlcltdfFVpbnQ4QXJyYXkpOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgYnVpbGRlci5zdGFydFZlY3Rvcig0LCBkYXRhLmxlbmd0aCwgNCk7XG4gICAgICBmb3IgKGxldCBpID0gZGF0YS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBidWlsZGVyLmFkZEludDMyKGRhdGFbaV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1aWxkZXIuZW5kVmVjdG9yKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBudW1iZXIgbnVtRWxlbXNcbiAgICAgKi9cbiAgICBzdGF0aWMgc3RhcnRJbnB1dEFyZ0NvdW50c1ZlY3RvcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBudW1FbGVtczogbnVtYmVyKSB7XG4gICAgICBidWlsZGVyLnN0YXJ0VmVjdG9yKDQsIG51bUVsZW1zLCA0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCBpbXBsaWNpdElucHV0c09mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRJbXBsaWNpdElucHV0cyhidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBpbXBsaWNpdElucHV0c09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDEyLCBpbXBsaWNpdElucHV0c09mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBBcnJheS48ZmxhdGJ1ZmZlcnMuT2Zmc2V0PiBkYXRhXG4gICAgICogQHJldHVybnMgZmxhdGJ1ZmZlcnMuT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZUltcGxpY2l0SW5wdXRzVmVjdG9yKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGRhdGE6IGZsYXRidWZmZXJzLk9mZnNldFtdKTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRWZWN0b3IoNCwgZGF0YS5sZW5ndGgsIDQpO1xuICAgICAgZm9yIChsZXQgaSA9IGRhdGEubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgYnVpbGRlci5hZGRPZmZzZXQoZGF0YVtpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYnVpbGRlci5lbmRWZWN0b3IoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIG51bWJlciBudW1FbGVtc1xuICAgICAqL1xuICAgIHN0YXRpYyBzdGFydEltcGxpY2l0SW5wdXRzVmVjdG9yKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIG51bUVsZW1zOiBudW1iZXIpIHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRWZWN0b3IoNCwgbnVtRWxlbXMsIDQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcmV0dXJucyBmbGF0YnVmZmVycy5PZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgZW5kTm9kZShidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyKTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIGxldCBvZmZzZXQgPSBidWlsZGVyLmVuZE9iamVjdCgpO1xuICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9XG5cbiAgICBzdGF0aWMgY3JlYXRlTm9kZShcbiAgICAgICAgYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgbmFtZU9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0LCBkb2NTdHJpbmdPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCxcbiAgICAgICAgZG9tYWluT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQsIHNpbmNlVmVyc2lvbjogbnVtYmVyLCBpbmRleDogbnVtYmVyLCBvcFR5cGVPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCxcbiAgICAgICAgdHlwZTogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5Ob2RlVHlwZSwgZXhlY3V0aW9uUHJvdmlkZXJUeXBlT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQsXG4gICAgICAgIGlucHV0c09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0LCBvdXRwdXRzT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQsIGF0dHJpYnV0ZXNPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCxcbiAgICAgICAgaW5wdXRBcmdDb3VudHNPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCwgaW1wbGljaXRJbnB1dHNPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCk6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBOb2RlLnN0YXJ0Tm9kZShidWlsZGVyKTtcbiAgICAgIE5vZGUuYWRkTmFtZShidWlsZGVyLCBuYW1lT2Zmc2V0KTtcbiAgICAgIE5vZGUuYWRkRG9jU3RyaW5nKGJ1aWxkZXIsIGRvY1N0cmluZ09mZnNldCk7XG4gICAgICBOb2RlLmFkZERvbWFpbihidWlsZGVyLCBkb21haW5PZmZzZXQpO1xuICAgICAgTm9kZS5hZGRTaW5jZVZlcnNpb24oYnVpbGRlciwgc2luY2VWZXJzaW9uKTtcbiAgICAgIE5vZGUuYWRkSW5kZXgoYnVpbGRlciwgaW5kZXgpO1xuICAgICAgTm9kZS5hZGRPcFR5cGUoYnVpbGRlciwgb3BUeXBlT2Zmc2V0KTtcbiAgICAgIE5vZGUuYWRkVHlwZShidWlsZGVyLCB0eXBlKTtcbiAgICAgIE5vZGUuYWRkRXhlY3V0aW9uUHJvdmlkZXJUeXBlKGJ1aWxkZXIsIGV4ZWN1dGlvblByb3ZpZGVyVHlwZU9mZnNldCk7XG4gICAgICBOb2RlLmFkZElucHV0cyhidWlsZGVyLCBpbnB1dHNPZmZzZXQpO1xuICAgICAgTm9kZS5hZGRPdXRwdXRzKGJ1aWxkZXIsIG91dHB1dHNPZmZzZXQpO1xuICAgICAgTm9kZS5hZGRBdHRyaWJ1dGVzKGJ1aWxkZXIsIGF0dHJpYnV0ZXNPZmZzZXQpO1xuICAgICAgTm9kZS5hZGRJbnB1dEFyZ0NvdW50cyhidWlsZGVyLCBpbnB1dEFyZ0NvdW50c09mZnNldCk7XG4gICAgICBOb2RlLmFkZEltcGxpY2l0SW5wdXRzKGJ1aWxkZXIsIGltcGxpY2l0SW5wdXRzT2Zmc2V0KTtcbiAgICAgIHJldHVybiBOb2RlLmVuZE5vZGUoYnVpbGRlcik7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5leHBvcnQgbmFtZXNwYWNlIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMge1xuICBleHBvcnQgY2xhc3MgVmFsdWVJbmZvIHtcbiAgICBiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlcnxudWxsID0gbnVsbDtcblxuICAgIGJiX3BvcyA9IDA7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIG51bWJlciBpXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcmV0dXJucyBWYWx1ZUluZm9cbiAgICAgKi9cbiAgICBfX2luaXQoaTogbnVtYmVyLCBiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlcik6IFZhbHVlSW5mbyB7XG4gICAgICB0aGlzLmJiX3BvcyA9IGk7XG4gICAgICB0aGlzLmJiID0gYmI7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEBwYXJhbSBWYWx1ZUluZm89IG9ialxuICAgICAqIEByZXR1cm5zIFZhbHVlSW5mb1xuICAgICAqL1xuICAgIHN0YXRpYyBnZXRSb290QXNWYWx1ZUluZm8oYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIsIG9iaj86IFZhbHVlSW5mbyk6IFZhbHVlSW5mbyB7XG4gICAgICByZXR1cm4gKG9iaiB8fCBuZXcgVmFsdWVJbmZvKCkpLl9faW5pdChiYi5yZWFkSW50MzIoYmIucG9zaXRpb24oKSkgKyBiYi5wb3NpdGlvbigpLCBiYik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcGFyYW0gVmFsdWVJbmZvPSBvYmpcbiAgICAgKiBAcmV0dXJucyBWYWx1ZUluZm9cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0U2l6ZVByZWZpeGVkUm9vdEFzVmFsdWVJbmZvKGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyLCBvYmo/OiBWYWx1ZUluZm8pOiBWYWx1ZUluZm8ge1xuICAgICAgYmIuc2V0UG9zaXRpb24oYmIucG9zaXRpb24oKSArIGZsYXRidWZmZXJzLlNJWkVfUFJFRklYX0xFTkdUSCk7XG4gICAgICByZXR1cm4gKG9iaiB8fCBuZXcgVmFsdWVJbmZvKCkpLl9faW5pdChiYi5yZWFkSW50MzIoYmIucG9zaXRpb24oKSkgKyBiYi5wb3NpdGlvbigpLCBiYik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkVuY29kaW5nPSBvcHRpb25hbEVuY29kaW5nXG4gICAgICogQHJldHVybnMgc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbFxuICAgICAqL1xuICAgIG5hbWUoKTogc3RyaW5nfG51bGw7XG4gICAgbmFtZShvcHRpb25hbEVuY29kaW5nOiBmbGF0YnVmZmVycy5FbmNvZGluZyk6IHN0cmluZ3xVaW50OEFycmF5fG51bGw7XG4gICAgbmFtZShvcHRpb25hbEVuY29kaW5nPzogYW55KTogc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDQpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLl9fc3RyaW5nKHRoaXMuYmJfcG9zICsgb2Zmc2V0LCBvcHRpb25hbEVuY29kaW5nKSA6IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkVuY29kaW5nPSBvcHRpb25hbEVuY29kaW5nXG4gICAgICogQHJldHVybnMgc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbFxuICAgICAqL1xuICAgIGRvY1N0cmluZygpOiBzdHJpbmd8bnVsbDtcbiAgICBkb2NTdHJpbmcob3B0aW9uYWxFbmNvZGluZzogZmxhdGJ1ZmZlcnMuRW5jb2RpbmcpOiBzdHJpbmd8VWludDhBcnJheXxudWxsO1xuICAgIGRvY1N0cmluZyhvcHRpb25hbEVuY29kaW5nPzogYW55KTogc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDYpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLl9fc3RyaW5nKHRoaXMuYmJfcG9zICsgb2Zmc2V0LCBvcHRpb25hbEVuY29kaW5nKSA6IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVHlwZUluZm89IG9ialxuICAgICAqIEByZXR1cm5zIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVHlwZUluZm98bnVsbFxuICAgICAqL1xuICAgIHR5cGUob2JqPzogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UeXBlSW5mbyk6IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVHlwZUluZm98bnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDgpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IChvYmogfHwgbmV3IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVHlwZUluZm8oKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLl9faW5pdCh0aGlzLmJiIS5fX2luZGlyZWN0KHRoaXMuYmJfcG9zICsgb2Zmc2V0KSwgdGhpcy5iYiEpIDpcbiAgICAgICAgICAgICAgICAgICAgICBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKi9cbiAgICBzdGF0aWMgc3RhcnRWYWx1ZUluZm8oYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlcikge1xuICAgICAgYnVpbGRlci5zdGFydE9iamVjdCgzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCBuYW1lT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZE5hbWUoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgbmFtZU9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDAsIG5hbWVPZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IGRvY1N0cmluZ09mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGREb2NTdHJpbmcoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZG9jU3RyaW5nT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoMSwgZG9jU3RyaW5nT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCB0eXBlT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZFR5cGUoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgdHlwZU9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDIsIHR5cGVPZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcmV0dXJucyBmbGF0YnVmZmVycy5PZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgZW5kVmFsdWVJbmZvKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIpOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgbGV0IG9mZnNldCA9IGJ1aWxkZXIuZW5kT2JqZWN0KCk7XG4gICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH1cblxuICAgIHN0YXRpYyBjcmVhdGVWYWx1ZUluZm8oXG4gICAgICAgIGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIG5hbWVPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCwgZG9jU3RyaW5nT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQsXG4gICAgICAgIHR5cGVPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCk6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBWYWx1ZUluZm8uc3RhcnRWYWx1ZUluZm8oYnVpbGRlcik7XG4gICAgICBWYWx1ZUluZm8uYWRkTmFtZShidWlsZGVyLCBuYW1lT2Zmc2V0KTtcbiAgICAgIFZhbHVlSW5mby5hZGREb2NTdHJpbmcoYnVpbGRlciwgZG9jU3RyaW5nT2Zmc2V0KTtcbiAgICAgIFZhbHVlSW5mby5hZGRUeXBlKGJ1aWxkZXIsIHR5cGVPZmZzZXQpO1xuICAgICAgcmV0dXJuIFZhbHVlSW5mby5lbmRWYWx1ZUluZm8oYnVpbGRlcik7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5leHBvcnQgbmFtZXNwYWNlIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMge1xuICBleHBvcnQgY2xhc3MgVHlwZUluZm8ge1xuICAgIGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyfG51bGwgPSBudWxsO1xuXG4gICAgYmJfcG9zID0gMDtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbnVtYmVyIGlcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEByZXR1cm5zIFR5cGVJbmZvXG4gICAgICovXG4gICAgX19pbml0KGk6IG51bWJlciwgYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIpOiBUeXBlSW5mbyB7XG4gICAgICB0aGlzLmJiX3BvcyA9IGk7XG4gICAgICB0aGlzLmJiID0gYmI7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEBwYXJhbSBUeXBlSW5mbz0gb2JqXG4gICAgICogQHJldHVybnMgVHlwZUluZm9cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0Um9vdEFzVHlwZUluZm8oYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIsIG9iaj86IFR5cGVJbmZvKTogVHlwZUluZm8ge1xuICAgICAgcmV0dXJuIChvYmogfHwgbmV3IFR5cGVJbmZvKCkpLl9faW5pdChiYi5yZWFkSW50MzIoYmIucG9zaXRpb24oKSkgKyBiYi5wb3NpdGlvbigpLCBiYik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcGFyYW0gVHlwZUluZm89IG9ialxuICAgICAqIEByZXR1cm5zIFR5cGVJbmZvXG4gICAgICovXG4gICAgc3RhdGljIGdldFNpemVQcmVmaXhlZFJvb3RBc1R5cGVJbmZvKGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyLCBvYmo/OiBUeXBlSW5mbyk6IFR5cGVJbmZvIHtcbiAgICAgIGJiLnNldFBvc2l0aW9uKGJiLnBvc2l0aW9uKCkgKyBmbGF0YnVmZmVycy5TSVpFX1BSRUZJWF9MRU5HVEgpO1xuICAgICAgcmV0dXJuIChvYmogfHwgbmV3IFR5cGVJbmZvKCkpLl9faW5pdChiYi5yZWFkSW50MzIoYmIucG9zaXRpb24oKSkgKyBiYi5wb3NpdGlvbigpLCBiYik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkVuY29kaW5nPSBvcHRpb25hbEVuY29kaW5nXG4gICAgICogQHJldHVybnMgc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbFxuICAgICAqL1xuICAgIGRlbm90YXRpb24oKTogc3RyaW5nfG51bGw7XG4gICAgZGVub3RhdGlvbihvcHRpb25hbEVuY29kaW5nOiBmbGF0YnVmZmVycy5FbmNvZGluZyk6IHN0cmluZ3xVaW50OEFycmF5fG51bGw7XG4gICAgZGVub3RhdGlvbihvcHRpb25hbEVuY29kaW5nPzogYW55KTogc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDQpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLl9fc3RyaW5nKHRoaXMuYmJfcG9zICsgb2Zmc2V0LCBvcHRpb25hbEVuY29kaW5nKSA6IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UeXBlSW5mb1ZhbHVlXG4gICAgICovXG4gICAgdmFsdWVUeXBlKCk6IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVHlwZUluZm9WYWx1ZSB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDYpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IC8qKiAgKi8gKHRoaXMuYmIhLnJlYWRVaW50OCh0aGlzLmJiX3BvcyArIG9mZnNldCkpIDpcbiAgICAgICAgICAgICAgICAgICAgICBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlR5cGVJbmZvVmFsdWUuTk9ORTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuVGFibGUgb2JqXG4gICAgICogQHJldHVybnMgP2ZsYXRidWZmZXJzLlRhYmxlXG4gICAgICovXG4gICAgdmFsdWU8VCBleHRlbmRzIGZsYXRidWZmZXJzLlRhYmxlPihvYmo6IFQpOiBUfG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA4KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3VuaW9uKG9iaiwgdGhpcy5iYl9wb3MgKyBvZmZzZXQpIDogbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICovXG4gICAgc3RhdGljIHN0YXJ0VHlwZUluZm8oYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlcikge1xuICAgICAgYnVpbGRlci5zdGFydE9iamVjdCgzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCBkZW5vdGF0aW9uT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZERlbm90YXRpb24oYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZGVub3RhdGlvbk9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDAsIGRlbm90YXRpb25PZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UeXBlSW5mb1ZhbHVlIHZhbHVlVHlwZVxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRWYWx1ZVR5cGUoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgdmFsdWVUeXBlOiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlR5cGVJbmZvVmFsdWUpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRJbnQ4KDEsIHZhbHVlVHlwZSwgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UeXBlSW5mb1ZhbHVlLk5PTkUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IHZhbHVlT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZFZhbHVlKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIHZhbHVlT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoMiwgdmFsdWVPZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcmV0dXJucyBmbGF0YnVmZmVycy5PZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgZW5kVHlwZUluZm8oYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlcik6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gYnVpbGRlci5lbmRPYmplY3QoKTtcbiAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfVxuXG4gICAgc3RhdGljIGNyZWF0ZVR5cGVJbmZvKFxuICAgICAgICBidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBkZW5vdGF0aW9uT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQsXG4gICAgICAgIHZhbHVlVHlwZTogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UeXBlSW5mb1ZhbHVlLCB2YWx1ZU9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIFR5cGVJbmZvLnN0YXJ0VHlwZUluZm8oYnVpbGRlcik7XG4gICAgICBUeXBlSW5mby5hZGREZW5vdGF0aW9uKGJ1aWxkZXIsIGRlbm90YXRpb25PZmZzZXQpO1xuICAgICAgVHlwZUluZm8uYWRkVmFsdWVUeXBlKGJ1aWxkZXIsIHZhbHVlVHlwZSk7XG4gICAgICBUeXBlSW5mby5hZGRWYWx1ZShidWlsZGVyLCB2YWx1ZU9mZnNldCk7XG4gICAgICByZXR1cm4gVHlwZUluZm8uZW5kVHlwZUluZm8oYnVpbGRlcik7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5leHBvcnQgbmFtZXNwYWNlIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMge1xuICBleHBvcnQgY2xhc3MgT3BlcmF0b3JTZXRJZCB7XG4gICAgYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXJ8bnVsbCA9IG51bGw7XG5cbiAgICBiYl9wb3MgPSAwO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBudW1iZXIgaVxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHJldHVybnMgT3BlcmF0b3JTZXRJZFxuICAgICAqL1xuICAgIF9faW5pdChpOiBudW1iZXIsIGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyKTogT3BlcmF0b3JTZXRJZCB7XG4gICAgICB0aGlzLmJiX3BvcyA9IGk7XG4gICAgICB0aGlzLmJiID0gYmI7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEBwYXJhbSBPcGVyYXRvclNldElkPSBvYmpcbiAgICAgKiBAcmV0dXJucyBPcGVyYXRvclNldElkXG4gICAgICovXG4gICAgc3RhdGljIGdldFJvb3RBc09wZXJhdG9yU2V0SWQoYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIsIG9iaj86IE9wZXJhdG9yU2V0SWQpOiBPcGVyYXRvclNldElkIHtcbiAgICAgIHJldHVybiAob2JqIHx8IG5ldyBPcGVyYXRvclNldElkKCkpLl9faW5pdChiYi5yZWFkSW50MzIoYmIucG9zaXRpb24oKSkgKyBiYi5wb3NpdGlvbigpLCBiYik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcGFyYW0gT3BlcmF0b3JTZXRJZD0gb2JqXG4gICAgICogQHJldHVybnMgT3BlcmF0b3JTZXRJZFxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRTaXplUHJlZml4ZWRSb290QXNPcGVyYXRvclNldElkKGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyLCBvYmo/OiBPcGVyYXRvclNldElkKTogT3BlcmF0b3JTZXRJZCB7XG4gICAgICBiYi5zZXRQb3NpdGlvbihiYi5wb3NpdGlvbigpICsgZmxhdGJ1ZmZlcnMuU0laRV9QUkVGSVhfTEVOR1RIKTtcbiAgICAgIHJldHVybiAob2JqIHx8IG5ldyBPcGVyYXRvclNldElkKCkpLl9faW5pdChiYi5yZWFkSW50MzIoYmIucG9zaXRpb24oKSkgKyBiYi5wb3NpdGlvbigpLCBiYik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkVuY29kaW5nPSBvcHRpb25hbEVuY29kaW5nXG4gICAgICogQHJldHVybnMgc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbFxuICAgICAqL1xuICAgIGRvbWFpbigpOiBzdHJpbmd8bnVsbDtcbiAgICBkb21haW4ob3B0aW9uYWxFbmNvZGluZzogZmxhdGJ1ZmZlcnMuRW5jb2RpbmcpOiBzdHJpbmd8VWludDhBcnJheXxudWxsO1xuICAgIGRvbWFpbihvcHRpb25hbEVuY29kaW5nPzogYW55KTogc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDQpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLl9fc3RyaW5nKHRoaXMuYmJfcG9zICsgb2Zmc2V0LCBvcHRpb25hbEVuY29kaW5nKSA6IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgZmxhdGJ1ZmZlcnMuTG9uZ1xuICAgICAqL1xuICAgIHZlcnNpb24oKTogZmxhdGJ1ZmZlcnMuTG9uZyB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDYpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLnJlYWRJbnQ2NCh0aGlzLmJiX3BvcyArIG9mZnNldCkgOiB0aGlzLmJiIS5jcmVhdGVMb25nKDAsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKi9cbiAgICBzdGF0aWMgc3RhcnRPcGVyYXRvclNldElkKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIpIHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRPYmplY3QoMik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgZG9tYWluT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZERvbWFpbihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBkb21haW5PZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCgwLCBkb21haW5PZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuTG9uZyB2ZXJzaW9uXG4gICAgICovXG4gICAgc3RhdGljIGFkZFZlcnNpb24oYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgdmVyc2lvbjogZmxhdGJ1ZmZlcnMuTG9uZykge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZEludDY0KDEsIHZlcnNpb24sIGJ1aWxkZXIuY3JlYXRlTG9uZygwLCAwKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLk9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBlbmRPcGVyYXRvclNldElkKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIpOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgbGV0IG9mZnNldCA9IGJ1aWxkZXIuZW5kT2JqZWN0KCk7XG4gICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH1cblxuICAgIHN0YXRpYyBjcmVhdGVPcGVyYXRvclNldElkKFxuICAgICAgICBidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBkb21haW5PZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCwgdmVyc2lvbjogZmxhdGJ1ZmZlcnMuTG9uZyk6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBPcGVyYXRvclNldElkLnN0YXJ0T3BlcmF0b3JTZXRJZChidWlsZGVyKTtcbiAgICAgIE9wZXJhdG9yU2V0SWQuYWRkRG9tYWluKGJ1aWxkZXIsIGRvbWFpbk9mZnNldCk7XG4gICAgICBPcGVyYXRvclNldElkLmFkZFZlcnNpb24oYnVpbGRlciwgdmVyc2lvbik7XG4gICAgICByZXR1cm4gT3BlcmF0b3JTZXRJZC5lbmRPcGVyYXRvclNldElkKGJ1aWxkZXIpO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZXhwb3J0IG5hbWVzcGFjZSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzIHtcbiAgZXhwb3J0IGNsYXNzIFRlbnNvciB7XG4gICAgYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXJ8bnVsbCA9IG51bGw7XG5cbiAgICBiYl9wb3MgPSAwO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBudW1iZXIgaVxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHJldHVybnMgVGVuc29yXG4gICAgICovXG4gICAgX19pbml0KGk6IG51bWJlciwgYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIpOiBUZW5zb3Ige1xuICAgICAgdGhpcy5iYl9wb3MgPSBpO1xuICAgICAgdGhpcy5iYiA9IGJiO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcGFyYW0gVGVuc29yPSBvYmpcbiAgICAgKiBAcmV0dXJucyBUZW5zb3JcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0Um9vdEFzVGVuc29yKGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyLCBvYmo/OiBUZW5zb3IpOiBUZW5zb3Ige1xuICAgICAgcmV0dXJuIChvYmogfHwgbmV3IFRlbnNvcigpKS5fX2luaXQoYmIucmVhZEludDMyKGJiLnBvc2l0aW9uKCkpICsgYmIucG9zaXRpb24oKSwgYmIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHBhcmFtIFRlbnNvcj0gb2JqXG4gICAgICogQHJldHVybnMgVGVuc29yXG4gICAgICovXG4gICAgc3RhdGljIGdldFNpemVQcmVmaXhlZFJvb3RBc1RlbnNvcihiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciwgb2JqPzogVGVuc29yKTogVGVuc29yIHtcbiAgICAgIGJiLnNldFBvc2l0aW9uKGJiLnBvc2l0aW9uKCkgKyBmbGF0YnVmZmVycy5TSVpFX1BSRUZJWF9MRU5HVEgpO1xuICAgICAgcmV0dXJuIChvYmogfHwgbmV3IFRlbnNvcigpKS5fX2luaXQoYmIucmVhZEludDMyKGJiLnBvc2l0aW9uKCkpICsgYmIucG9zaXRpb24oKSwgYmIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5FbmNvZGluZz0gb3B0aW9uYWxFbmNvZGluZ1xuICAgICAqIEByZXR1cm5zIHN0cmluZ3xVaW50OEFycmF5fG51bGxcbiAgICAgKi9cbiAgICBuYW1lKCk6IHN0cmluZ3xudWxsO1xuICAgIG5hbWUob3B0aW9uYWxFbmNvZGluZzogZmxhdGJ1ZmZlcnMuRW5jb2RpbmcpOiBzdHJpbmd8VWludDhBcnJheXxudWxsO1xuICAgIG5hbWUob3B0aW9uYWxFbmNvZGluZz86IGFueSk6IHN0cmluZ3xVaW50OEFycmF5fG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA0KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3N0cmluZyh0aGlzLmJiX3BvcyArIG9mZnNldCwgb3B0aW9uYWxFbmNvZGluZykgOiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5FbmNvZGluZz0gb3B0aW9uYWxFbmNvZGluZ1xuICAgICAqIEByZXR1cm5zIHN0cmluZ3xVaW50OEFycmF5fG51bGxcbiAgICAgKi9cbiAgICBkb2NTdHJpbmcoKTogc3RyaW5nfG51bGw7XG4gICAgZG9jU3RyaW5nKG9wdGlvbmFsRW5jb2Rpbmc6IGZsYXRidWZmZXJzLkVuY29kaW5nKTogc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbDtcbiAgICBkb2NTdHJpbmcob3B0aW9uYWxFbmNvZGluZz86IGFueSk6IHN0cmluZ3xVaW50OEFycmF5fG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA2KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3N0cmluZyh0aGlzLmJiX3BvcyArIG9mZnNldCwgb3B0aW9uYWxFbmNvZGluZykgOiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBudW1iZXIgaW5kZXhcbiAgICAgKiBAcmV0dXJucyBmbGF0YnVmZmVycy5Mb25nXG4gICAgICovXG4gICAgZGltcyhpbmRleDogbnVtYmVyKTogZmxhdGJ1ZmZlcnMuTG9uZ3xudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgOCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEucmVhZEludDY0KHRoaXMuYmIhLl9fdmVjdG9yKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSArIGluZGV4ICogOCkgOlxuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYmIhLmNyZWF0ZUxvbmcoMCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgbnVtYmVyXG4gICAgICovXG4gICAgZGltc0xlbmd0aCgpOiBudW1iZXIge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA4KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MgKyBvZmZzZXQpIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlRlbnNvckRhdGFUeXBlXG4gICAgICovXG4gICAgZGF0YVR5cGUoKTogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UZW5zb3JEYXRhVHlwZSB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDEwKTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyAvKiogICovICh0aGlzLmJiIS5yZWFkSW50MzIodGhpcy5iYl9wb3MgKyBvZmZzZXQpKSA6XG4gICAgICAgICAgICAgICAgICAgICAgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UZW5zb3JEYXRhVHlwZS5VTkRFRklORUQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIG51bWJlciBpbmRleFxuICAgICAqIEByZXR1cm5zIG51bWJlclxuICAgICAqL1xuICAgIHJhd0RhdGEoaW5kZXg6IG51bWJlcik6IG51bWJlcnxudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgMTIpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLnJlYWRVaW50OCh0aGlzLmJiIS5fX3ZlY3Rvcih0aGlzLmJiX3BvcyArIG9mZnNldCkgKyBpbmRleCkgOiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIG51bWJlclxuICAgICAqL1xuICAgIHJhd0RhdGFMZW5ndGgoKTogbnVtYmVyIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgMTIpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLl9fdmVjdG9yX2xlbih0aGlzLmJiX3BvcyArIG9mZnNldCkgOiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIFVpbnQ4QXJyYXlcbiAgICAgKi9cbiAgICByYXdEYXRhQXJyYXkoKTogVWludDhBcnJheXxudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgMTIpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/XG4gICAgICAgICAgbmV3IFVpbnQ4QXJyYXkoXG4gICAgICAgICAgICAgIHRoaXMuYmIhLmJ5dGVzKCkuYnVmZmVyLCB0aGlzLmJiIS5ieXRlcygpLmJ5dGVPZmZzZXQgKyB0aGlzLmJiIS5fX3ZlY3Rvcih0aGlzLmJiX3BvcyArIG9mZnNldCksXG4gICAgICAgICAgICAgIHRoaXMuYmIhLl9fdmVjdG9yX2xlbih0aGlzLmJiX3BvcyArIG9mZnNldCkpIDpcbiAgICAgICAgICBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBudW1iZXIgaW5kZXhcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuRW5jb2Rpbmc9IG9wdGlvbmFsRW5jb2RpbmdcbiAgICAgKiBAcmV0dXJucyBzdHJpbmd8VWludDhBcnJheVxuICAgICAqL1xuICAgIHN0cmluZ0RhdGEoaW5kZXg6IG51bWJlcik6IHN0cmluZztcbiAgICBzdHJpbmdEYXRhKGluZGV4OiBudW1iZXIsIG9wdGlvbmFsRW5jb2Rpbmc6IGZsYXRidWZmZXJzLkVuY29kaW5nKTogc3RyaW5nfFVpbnQ4QXJyYXk7XG4gICAgc3RyaW5nRGF0YShpbmRleDogbnVtYmVyLCBvcHRpb25hbEVuY29kaW5nPzogYW55KTogc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDE0KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3N0cmluZyh0aGlzLmJiIS5fX3ZlY3Rvcih0aGlzLmJiX3BvcyArIG9mZnNldCkgKyBpbmRleCAqIDQsIG9wdGlvbmFsRW5jb2RpbmcpIDogbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICAgKi9cbiAgICBzdHJpbmdEYXRhTGVuZ3RoKCk6IG51bWJlciB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDE0KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MgKyBvZmZzZXQpIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICovXG4gICAgc3RhdGljIHN0YXJ0VGVuc29yKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIpIHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRPYmplY3QoNik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgbmFtZU9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGROYW1lKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIG5hbWVPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCgwLCBuYW1lT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCBkb2NTdHJpbmdPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkRG9jU3RyaW5nKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGRvY1N0cmluZ09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDEsIGRvY1N0cmluZ09mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgZGltc09mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGREaW1zKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGRpbXNPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCgyLCBkaW1zT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIEFycmF5LjxmbGF0YnVmZmVycy5Mb25nPiBkYXRhXG4gICAgICogQHJldHVybnMgZmxhdGJ1ZmZlcnMuT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZURpbXNWZWN0b3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZGF0YTogZmxhdGJ1ZmZlcnMuTG9uZ1tdKTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRWZWN0b3IoOCwgZGF0YS5sZW5ndGgsIDgpO1xuICAgICAgZm9yIChsZXQgaSA9IGRhdGEubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgYnVpbGRlci5hZGRJbnQ2NChkYXRhW2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBidWlsZGVyLmVuZFZlY3RvcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gbnVtYmVyIG51bUVsZW1zXG4gICAgICovXG4gICAgc3RhdGljIHN0YXJ0RGltc1ZlY3RvcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBudW1FbGVtczogbnVtYmVyKSB7XG4gICAgICBidWlsZGVyLnN0YXJ0VmVjdG9yKDgsIG51bUVsZW1zLCA4KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yRGF0YVR5cGUgZGF0YVR5cGVcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkRGF0YVR5cGUoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZGF0YVR5cGU6IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yRGF0YVR5cGUpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRJbnQzMigzLCBkYXRhVHlwZSwgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UZW5zb3JEYXRhVHlwZS5VTkRFRklORUQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IHJhd0RhdGFPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkUmF3RGF0YShidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCByYXdEYXRhT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoNCwgcmF3RGF0YU9mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBBcnJheS48bnVtYmVyPiBkYXRhXG4gICAgICogQHJldHVybnMgZmxhdGJ1ZmZlcnMuT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZVJhd0RhdGFWZWN0b3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZGF0YTogbnVtYmVyW118VWludDhBcnJheSk6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBidWlsZGVyLnN0YXJ0VmVjdG9yKDEsIGRhdGEubGVuZ3RoLCAxKTtcbiAgICAgIGZvciAobGV0IGkgPSBkYXRhLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGJ1aWxkZXIuYWRkSW50OChkYXRhW2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBidWlsZGVyLmVuZFZlY3RvcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gbnVtYmVyIG51bUVsZW1zXG4gICAgICovXG4gICAgc3RhdGljIHN0YXJ0UmF3RGF0YVZlY3RvcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBudW1FbGVtczogbnVtYmVyKSB7XG4gICAgICBidWlsZGVyLnN0YXJ0VmVjdG9yKDEsIG51bUVsZW1zLCAxKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCBzdHJpbmdEYXRhT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZFN0cmluZ0RhdGEoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgc3RyaW5nRGF0YU9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDUsIHN0cmluZ0RhdGFPZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gQXJyYXkuPGZsYXRidWZmZXJzLk9mZnNldD4gZGF0YVxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLk9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVTdHJpbmdEYXRhVmVjdG9yKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGRhdGE6IGZsYXRidWZmZXJzLk9mZnNldFtdKTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRWZWN0b3IoNCwgZGF0YS5sZW5ndGgsIDQpO1xuICAgICAgZm9yIChsZXQgaSA9IGRhdGEubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgYnVpbGRlci5hZGRPZmZzZXQoZGF0YVtpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYnVpbGRlci5lbmRWZWN0b3IoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIG51bWJlciBudW1FbGVtc1xuICAgICAqL1xuICAgIHN0YXRpYyBzdGFydFN0cmluZ0RhdGFWZWN0b3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgbnVtRWxlbXM6IG51bWJlcikge1xuICAgICAgYnVpbGRlci5zdGFydFZlY3Rvcig0LCBudW1FbGVtcywgNCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLk9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBlbmRUZW5zb3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlcik6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gYnVpbGRlci5lbmRPYmplY3QoKTtcbiAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfVxuXG4gICAgc3RhdGljIGNyZWF0ZVRlbnNvcihcbiAgICAgICAgYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgbmFtZU9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0LCBkb2NTdHJpbmdPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCxcbiAgICAgICAgZGltc09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0LCBkYXRhVHlwZTogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UZW5zb3JEYXRhVHlwZSxcbiAgICAgICAgcmF3RGF0YU9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0LCBzdHJpbmdEYXRhT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgVGVuc29yLnN0YXJ0VGVuc29yKGJ1aWxkZXIpO1xuICAgICAgVGVuc29yLmFkZE5hbWUoYnVpbGRlciwgbmFtZU9mZnNldCk7XG4gICAgICBUZW5zb3IuYWRkRG9jU3RyaW5nKGJ1aWxkZXIsIGRvY1N0cmluZ09mZnNldCk7XG4gICAgICBUZW5zb3IuYWRkRGltcyhidWlsZGVyLCBkaW1zT2Zmc2V0KTtcbiAgICAgIFRlbnNvci5hZGREYXRhVHlwZShidWlsZGVyLCBkYXRhVHlwZSk7XG4gICAgICBUZW5zb3IuYWRkUmF3RGF0YShidWlsZGVyLCByYXdEYXRhT2Zmc2V0KTtcbiAgICAgIFRlbnNvci5hZGRTdHJpbmdEYXRhKGJ1aWxkZXIsIHN0cmluZ0RhdGFPZmZzZXQpO1xuICAgICAgcmV0dXJuIFRlbnNvci5lbmRUZW5zb3IoYnVpbGRlcik7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5leHBvcnQgbmFtZXNwYWNlIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMge1xuICBleHBvcnQgY2xhc3MgU3BhcnNlVGVuc29yIHtcbiAgICBiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlcnxudWxsID0gbnVsbDtcblxuICAgIGJiX3BvcyA9IDA7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIG51bWJlciBpXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcmV0dXJucyBTcGFyc2VUZW5zb3JcbiAgICAgKi9cbiAgICBfX2luaXQoaTogbnVtYmVyLCBiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlcik6IFNwYXJzZVRlbnNvciB7XG4gICAgICB0aGlzLmJiX3BvcyA9IGk7XG4gICAgICB0aGlzLmJiID0gYmI7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEBwYXJhbSBTcGFyc2VUZW5zb3I9IG9ialxuICAgICAqIEByZXR1cm5zIFNwYXJzZVRlbnNvclxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRSb290QXNTcGFyc2VUZW5zb3IoYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIsIG9iaj86IFNwYXJzZVRlbnNvcik6IFNwYXJzZVRlbnNvciB7XG4gICAgICByZXR1cm4gKG9iaiB8fCBuZXcgU3BhcnNlVGVuc29yKCkpLl9faW5pdChiYi5yZWFkSW50MzIoYmIucG9zaXRpb24oKSkgKyBiYi5wb3NpdGlvbigpLCBiYik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcGFyYW0gU3BhcnNlVGVuc29yPSBvYmpcbiAgICAgKiBAcmV0dXJucyBTcGFyc2VUZW5zb3JcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0U2l6ZVByZWZpeGVkUm9vdEFzU3BhcnNlVGVuc29yKGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyLCBvYmo/OiBTcGFyc2VUZW5zb3IpOiBTcGFyc2VUZW5zb3Ige1xuICAgICAgYmIuc2V0UG9zaXRpb24oYmIucG9zaXRpb24oKSArIGZsYXRidWZmZXJzLlNJWkVfUFJFRklYX0xFTkdUSCk7XG4gICAgICByZXR1cm4gKG9iaiB8fCBuZXcgU3BhcnNlVGVuc29yKCkpLl9faW5pdChiYi5yZWFkSW50MzIoYmIucG9zaXRpb24oKSkgKyBiYi5wb3NpdGlvbigpLCBiYik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yPSBvYmpcbiAgICAgKiBAcmV0dXJucyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlRlbnNvcnxudWxsXG4gICAgICovXG4gICAgdmFsdWVzKG9iaj86IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yKTogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UZW5zb3J8bnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDQpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IChvYmogfHwgbmV3IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC5fX2luaXQodGhpcy5iYiEuX19pbmRpcmVjdCh0aGlzLmJiX3BvcyArIG9mZnNldCksIHRoaXMuYmIhKSA6XG4gICAgICAgICAgICAgICAgICAgICAgbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UZW5zb3I9IG9ialxuICAgICAqIEByZXR1cm5zIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yfG51bGxcbiAgICAgKi9cbiAgICBpbmRpY2VzKG9iaj86IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yKTogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UZW5zb3J8bnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDYpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IChvYmogfHwgbmV3IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC5fX2luaXQodGhpcy5iYiEuX19pbmRpcmVjdCh0aGlzLmJiX3BvcyArIG9mZnNldCksIHRoaXMuYmIhKSA6XG4gICAgICAgICAgICAgICAgICAgICAgbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbnVtYmVyIGluZGV4XG4gICAgICogQHJldHVybnMgZmxhdGJ1ZmZlcnMuTG9uZ1xuICAgICAqL1xuICAgIGRpbXMoaW5kZXg6IG51bWJlcik6IGZsYXRidWZmZXJzLkxvbmd8bnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDgpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLnJlYWRJbnQ2NCh0aGlzLmJiIS5fX3ZlY3Rvcih0aGlzLmJiX3BvcyArIG9mZnNldCkgKyBpbmRleCAqIDgpIDpcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLmJiIS5jcmVhdGVMb25nKDAsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIG51bWJlclxuICAgICAqL1xuICAgIGRpbXNMZW5ndGgoKTogbnVtYmVyIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgOCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSA6IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqL1xuICAgIHN0YXRpYyBzdGFydFNwYXJzZVRlbnNvcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyKSB7XG4gICAgICBidWlsZGVyLnN0YXJ0T2JqZWN0KDMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IHZhbHVlc09mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRWYWx1ZXMoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgdmFsdWVzT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoMCwgdmFsdWVzT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCBpbmRpY2VzT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZEluZGljZXMoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgaW5kaWNlc09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDEsIGluZGljZXNPZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IGRpbXNPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkRGltcyhidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBkaW1zT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoMiwgZGltc09mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBBcnJheS48ZmxhdGJ1ZmZlcnMuTG9uZz4gZGF0YVxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLk9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVEaW1zVmVjdG9yKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGRhdGE6IGZsYXRidWZmZXJzLkxvbmdbXSk6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBidWlsZGVyLnN0YXJ0VmVjdG9yKDgsIGRhdGEubGVuZ3RoLCA4KTtcbiAgICAgIGZvciAobGV0IGkgPSBkYXRhLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGJ1aWxkZXIuYWRkSW50NjQoZGF0YVtpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYnVpbGRlci5lbmRWZWN0b3IoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIG51bWJlciBudW1FbGVtc1xuICAgICAqL1xuICAgIHN0YXRpYyBzdGFydERpbXNWZWN0b3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgbnVtRWxlbXM6IG51bWJlcikge1xuICAgICAgYnVpbGRlci5zdGFydFZlY3Rvcig4LCBudW1FbGVtcywgOCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLk9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBlbmRTcGFyc2VUZW5zb3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlcik6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gYnVpbGRlci5lbmRPYmplY3QoKTtcbiAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfVxuXG4gICAgc3RhdGljIGNyZWF0ZVNwYXJzZVRlbnNvcihcbiAgICAgICAgYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgdmFsdWVzT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQsIGluZGljZXNPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCxcbiAgICAgICAgZGltc09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIFNwYXJzZVRlbnNvci5zdGFydFNwYXJzZVRlbnNvcihidWlsZGVyKTtcbiAgICAgIFNwYXJzZVRlbnNvci5hZGRWYWx1ZXMoYnVpbGRlciwgdmFsdWVzT2Zmc2V0KTtcbiAgICAgIFNwYXJzZVRlbnNvci5hZGRJbmRpY2VzKGJ1aWxkZXIsIGluZGljZXNPZmZzZXQpO1xuICAgICAgU3BhcnNlVGVuc29yLmFkZERpbXMoYnVpbGRlciwgZGltc09mZnNldCk7XG4gICAgICByZXR1cm4gU3BhcnNlVGVuc29yLmVuZFNwYXJzZVRlbnNvcihidWlsZGVyKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmV4cG9ydCBuYW1lc3BhY2Ugb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicyB7XG4gIGV4cG9ydCBjbGFzcyBBdHRyaWJ1dGUge1xuICAgIGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyfG51bGwgPSBudWxsO1xuXG4gICAgYmJfcG9zID0gMDtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbnVtYmVyIGlcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEByZXR1cm5zIEF0dHJpYnV0ZVxuICAgICAqL1xuICAgIF9faW5pdChpOiBudW1iZXIsIGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyKTogQXR0cmlidXRlIHtcbiAgICAgIHRoaXMuYmJfcG9zID0gaTtcbiAgICAgIHRoaXMuYmIgPSBiYjtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHBhcmFtIEF0dHJpYnV0ZT0gb2JqXG4gICAgICogQHJldHVybnMgQXR0cmlidXRlXG4gICAgICovXG4gICAgc3RhdGljIGdldFJvb3RBc0F0dHJpYnV0ZShiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciwgb2JqPzogQXR0cmlidXRlKTogQXR0cmlidXRlIHtcbiAgICAgIHJldHVybiAob2JqIHx8IG5ldyBBdHRyaWJ1dGUoKSkuX19pbml0KGJiLnJlYWRJbnQzMihiYi5wb3NpdGlvbigpKSArIGJiLnBvc2l0aW9uKCksIGJiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEBwYXJhbSBBdHRyaWJ1dGU9IG9ialxuICAgICAqIEByZXR1cm5zIEF0dHJpYnV0ZVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRTaXplUHJlZml4ZWRSb290QXNBdHRyaWJ1dGUoYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIsIG9iaj86IEF0dHJpYnV0ZSk6IEF0dHJpYnV0ZSB7XG4gICAgICBiYi5zZXRQb3NpdGlvbihiYi5wb3NpdGlvbigpICsgZmxhdGJ1ZmZlcnMuU0laRV9QUkVGSVhfTEVOR1RIKTtcbiAgICAgIHJldHVybiAob2JqIHx8IG5ldyBBdHRyaWJ1dGUoKSkuX19pbml0KGJiLnJlYWRJbnQzMihiYi5wb3NpdGlvbigpKSArIGJiLnBvc2l0aW9uKCksIGJiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuRW5jb2Rpbmc9IG9wdGlvbmFsRW5jb2RpbmdcbiAgICAgKiBAcmV0dXJucyBzdHJpbmd8VWludDhBcnJheXxudWxsXG4gICAgICovXG4gICAgbmFtZSgpOiBzdHJpbmd8bnVsbDtcbiAgICBuYW1lKG9wdGlvbmFsRW5jb2Rpbmc6IGZsYXRidWZmZXJzLkVuY29kaW5nKTogc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbDtcbiAgICBuYW1lKG9wdGlvbmFsRW5jb2Rpbmc/OiBhbnkpOiBzdHJpbmd8VWludDhBcnJheXxudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgNCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEuX19zdHJpbmcodGhpcy5iYl9wb3MgKyBvZmZzZXQsIG9wdGlvbmFsRW5jb2RpbmcpIDogbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuRW5jb2Rpbmc9IG9wdGlvbmFsRW5jb2RpbmdcbiAgICAgKiBAcmV0dXJucyBzdHJpbmd8VWludDhBcnJheXxudWxsXG4gICAgICovXG4gICAgZG9jU3RyaW5nKCk6IHN0cmluZ3xudWxsO1xuICAgIGRvY1N0cmluZyhvcHRpb25hbEVuY29kaW5nOiBmbGF0YnVmZmVycy5FbmNvZGluZyk6IHN0cmluZ3xVaW50OEFycmF5fG51bGw7XG4gICAgZG9jU3RyaW5nKG9wdGlvbmFsRW5jb2Rpbmc/OiBhbnkpOiBzdHJpbmd8VWludDhBcnJheXxudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgNik7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEuX19zdHJpbmcodGhpcy5iYl9wb3MgKyBvZmZzZXQsIG9wdGlvbmFsRW5jb2RpbmcpIDogbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLkF0dHJpYnV0ZVR5cGVcbiAgICAgKi9cbiAgICB0eXBlKCk6IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuQXR0cmlidXRlVHlwZSB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDgpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IC8qKiAgKi8gKHRoaXMuYmIhLnJlYWRJbnQzMih0aGlzLmJiX3BvcyArIG9mZnNldCkpIDpcbiAgICAgICAgICAgICAgICAgICAgICBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLkF0dHJpYnV0ZVR5cGUuVU5ERUZJTkVEO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIG51bWJlclxuICAgICAqL1xuICAgIGYoKTogbnVtYmVyIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgMTApO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLnJlYWRGbG9hdDMyKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSA6IDAuMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBmbGF0YnVmZmVycy5Mb25nXG4gICAgICovXG4gICAgaSgpOiBmbGF0YnVmZmVycy5Mb25nIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgMTIpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLnJlYWRJbnQ2NCh0aGlzLmJiX3BvcyArIG9mZnNldCkgOiB0aGlzLmJiIS5jcmVhdGVMb25nKDAsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5FbmNvZGluZz0gb3B0aW9uYWxFbmNvZGluZ1xuICAgICAqIEByZXR1cm5zIHN0cmluZ3xVaW50OEFycmF5fG51bGxcbiAgICAgKi9cbiAgICBzKCk6IHN0cmluZ3xudWxsO1xuICAgIHMob3B0aW9uYWxFbmNvZGluZzogZmxhdGJ1ZmZlcnMuRW5jb2RpbmcpOiBzdHJpbmd8VWludDhBcnJheXxudWxsO1xuICAgIHMob3B0aW9uYWxFbmNvZGluZz86IGFueSk6IHN0cmluZ3xVaW50OEFycmF5fG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCAxNCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEuX19zdHJpbmcodGhpcy5iYl9wb3MgKyBvZmZzZXQsIG9wdGlvbmFsRW5jb2RpbmcpIDogbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UZW5zb3I9IG9ialxuICAgICAqIEByZXR1cm5zIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yfG51bGxcbiAgICAgKi9cbiAgICB0KG9iaj86IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yKTogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UZW5zb3J8bnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDE2KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyAob2JqIHx8IG5ldyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlRlbnNvcigpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAuX19pbml0KHRoaXMuYmIhLl9faW5kaXJlY3QodGhpcy5iYl9wb3MgKyBvZmZzZXQpLCB0aGlzLmJiISkgOlxuICAgICAgICAgICAgICAgICAgICAgIG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuR3JhcGg9IG9ialxuICAgICAqIEByZXR1cm5zIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuR3JhcGh8bnVsbFxuICAgICAqL1xuICAgIGcob2JqPzogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5HcmFwaCk6IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuR3JhcGh8bnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDE4KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyAob2JqIHx8IG5ldyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLkdyYXBoKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC5fX2luaXQodGhpcy5iYiEuX19pbmRpcmVjdCh0aGlzLmJiX3BvcyArIG9mZnNldCksIHRoaXMuYmIhKSA6XG4gICAgICAgICAgICAgICAgICAgICAgbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbnVtYmVyIGluZGV4XG4gICAgICogQHJldHVybnMgbnVtYmVyXG4gICAgICovXG4gICAgZmxvYXRzKGluZGV4OiBudW1iZXIpOiBudW1iZXJ8bnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDIwKTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5yZWFkRmxvYXQzMih0aGlzLmJiIS5fX3ZlY3Rvcih0aGlzLmJiX3BvcyArIG9mZnNldCkgKyBpbmRleCAqIDQpIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICAgKi9cbiAgICBmbG9hdHNMZW5ndGgoKTogbnVtYmVyIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgMjApO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLl9fdmVjdG9yX2xlbih0aGlzLmJiX3BvcyArIG9mZnNldCkgOiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIEZsb2F0MzJBcnJheVxuICAgICAqL1xuICAgIGZsb2F0c0FycmF5KCk6IEZsb2F0MzJBcnJheXxudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgMjApO1xuICAgICAgcmV0dXJuIG9mZnNldCA/XG4gICAgICAgICAgbmV3IEZsb2F0MzJBcnJheShcbiAgICAgICAgICAgICAgdGhpcy5iYiEuYnl0ZXMoKS5idWZmZXIsIHRoaXMuYmIhLmJ5dGVzKCkuYnl0ZU9mZnNldCArIHRoaXMuYmIhLl9fdmVjdG9yKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSxcbiAgICAgICAgICAgICAgdGhpcy5iYiEuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSkgOlxuICAgICAgICAgIG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIG51bWJlciBpbmRleFxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLkxvbmdcbiAgICAgKi9cbiAgICBpbnRzKGluZGV4OiBudW1iZXIpOiBmbGF0YnVmZmVycy5Mb25nfG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCAyMik7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEucmVhZEludDY0KHRoaXMuYmIhLl9fdmVjdG9yKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSArIGluZGV4ICogOCkgOlxuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYmIhLmNyZWF0ZUxvbmcoMCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgbnVtYmVyXG4gICAgICovXG4gICAgaW50c0xlbmd0aCgpOiBudW1iZXIge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCAyMik7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSA6IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIG51bWJlciBpbmRleFxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5FbmNvZGluZz0gb3B0aW9uYWxFbmNvZGluZ1xuICAgICAqIEByZXR1cm5zIHN0cmluZ3xVaW50OEFycmF5XG4gICAgICovXG4gICAgc3RyaW5ncyhpbmRleDogbnVtYmVyKTogc3RyaW5nO1xuICAgIHN0cmluZ3MoaW5kZXg6IG51bWJlciwgb3B0aW9uYWxFbmNvZGluZzogZmxhdGJ1ZmZlcnMuRW5jb2RpbmcpOiBzdHJpbmd8VWludDhBcnJheTtcbiAgICBzdHJpbmdzKGluZGV4OiBudW1iZXIsIG9wdGlvbmFsRW5jb2Rpbmc/OiBhbnkpOiBzdHJpbmd8VWludDhBcnJheXxudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgMjQpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLl9fc3RyaW5nKHRoaXMuYmIhLl9fdmVjdG9yKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSArIGluZGV4ICogNCwgb3B0aW9uYWxFbmNvZGluZykgOiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIG51bWJlclxuICAgICAqL1xuICAgIHN0cmluZ3NMZW5ndGgoKTogbnVtYmVyIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgMjQpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLl9fdmVjdG9yX2xlbih0aGlzLmJiX3BvcyArIG9mZnNldCkgOiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBudW1iZXIgaW5kZXhcbiAgICAgKiBAcGFyYW0gb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UZW5zb3I9IG9ialxuICAgICAqIEByZXR1cm5zIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yXG4gICAgICovXG4gICAgdGVuc29ycyhpbmRleDogbnVtYmVyLCBvYmo/OiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlRlbnNvcik6IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yfG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCAyNik7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gKG9iaiB8fCBuZXcgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UZW5zb3IoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLl9faW5pdCh0aGlzLmJiIS5fX2luZGlyZWN0KHRoaXMuYmIhLl9fdmVjdG9yKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSArIGluZGV4ICogNCksIHRoaXMuYmIhKSA6XG4gICAgICAgICAgICAgICAgICAgICAgbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICAgKi9cbiAgICB0ZW5zb3JzTGVuZ3RoKCk6IG51bWJlciB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDI2KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MgKyBvZmZzZXQpIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbnVtYmVyIGluZGV4XG4gICAgICogQHBhcmFtIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuR3JhcGg9IG9ialxuICAgICAqIEByZXR1cm5zIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuR3JhcGhcbiAgICAgKi9cbiAgICBncmFwaHMoaW5kZXg6IG51bWJlciwgb2JqPzogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5HcmFwaCk6IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuR3JhcGh8bnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDI4KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyAob2JqIHx8IG5ldyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLkdyYXBoKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC5fX2luaXQodGhpcy5iYiEuX19pbmRpcmVjdCh0aGlzLmJiIS5fX3ZlY3Rvcih0aGlzLmJiX3BvcyArIG9mZnNldCkgKyBpbmRleCAqIDQpLCB0aGlzLmJiISkgOlxuICAgICAgICAgICAgICAgICAgICAgIG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgbnVtYmVyXG4gICAgICovXG4gICAgZ3JhcGhzTGVuZ3RoKCk6IG51bWJlciB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDI4KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MgKyBvZmZzZXQpIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICovXG4gICAgc3RhdGljIHN0YXJ0QXR0cmlidXRlKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIpIHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRPYmplY3QoMTMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IG5hbWVPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkTmFtZShidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBuYW1lT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoMCwgbmFtZU9mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgZG9jU3RyaW5nT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZERvY1N0cmluZyhidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBkb2NTdHJpbmdPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCgxLCBkb2NTdHJpbmdPZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5BdHRyaWJ1dGVUeXBlIHR5cGVcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkVHlwZShidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCB0eXBlOiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLkF0dHJpYnV0ZVR5cGUpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRJbnQzMigyLCB0eXBlLCBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLkF0dHJpYnV0ZVR5cGUuVU5ERUZJTkVEKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIG51bWJlciBmXG4gICAgICovXG4gICAgc3RhdGljIGFkZEYoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZjogbnVtYmVyKSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkRmxvYXQzMigzLCBmLCAwLjApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuTG9uZyBpXG4gICAgICovXG4gICAgc3RhdGljIGFkZEkoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgaTogZmxhdGJ1ZmZlcnMuTG9uZykge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZEludDY0KDQsIGksIGJ1aWxkZXIuY3JlYXRlTG9uZygwLCAwKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgc09mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRTKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIHNPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCg1LCBzT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCB0T2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZFQoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgdE9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDYsIHRPZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IGdPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkRyhidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBnT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoNywgZ09mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgZmxvYXRzT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZEZsb2F0cyhidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBmbG9hdHNPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCg4LCBmbG9hdHNPZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gQXJyYXkuPG51bWJlcj4gZGF0YVxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLk9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVGbG9hdHNWZWN0b3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZGF0YTogbnVtYmVyW118VWludDhBcnJheSk6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBidWlsZGVyLnN0YXJ0VmVjdG9yKDQsIGRhdGEubGVuZ3RoLCA0KTtcbiAgICAgIGZvciAobGV0IGkgPSBkYXRhLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGJ1aWxkZXIuYWRkRmxvYXQzMihkYXRhW2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBidWlsZGVyLmVuZFZlY3RvcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gbnVtYmVyIG51bUVsZW1zXG4gICAgICovXG4gICAgc3RhdGljIHN0YXJ0RmxvYXRzVmVjdG9yKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIG51bUVsZW1zOiBudW1iZXIpIHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRWZWN0b3IoNCwgbnVtRWxlbXMsIDQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IGludHNPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkSW50cyhidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBpbnRzT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoOSwgaW50c09mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBBcnJheS48ZmxhdGJ1ZmZlcnMuTG9uZz4gZGF0YVxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLk9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVJbnRzVmVjdG9yKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGRhdGE6IGZsYXRidWZmZXJzLkxvbmdbXSk6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBidWlsZGVyLnN0YXJ0VmVjdG9yKDgsIGRhdGEubGVuZ3RoLCA4KTtcbiAgICAgIGZvciAobGV0IGkgPSBkYXRhLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGJ1aWxkZXIuYWRkSW50NjQoZGF0YVtpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYnVpbGRlci5lbmRWZWN0b3IoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIG51bWJlciBudW1FbGVtc1xuICAgICAqL1xuICAgIHN0YXRpYyBzdGFydEludHNWZWN0b3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgbnVtRWxlbXM6IG51bWJlcikge1xuICAgICAgYnVpbGRlci5zdGFydFZlY3Rvcig4LCBudW1FbGVtcywgOCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgc3RyaW5nc09mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRTdHJpbmdzKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIHN0cmluZ3NPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCgxMCwgc3RyaW5nc09mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBBcnJheS48ZmxhdGJ1ZmZlcnMuT2Zmc2V0PiBkYXRhXG4gICAgICogQHJldHVybnMgZmxhdGJ1ZmZlcnMuT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZVN0cmluZ3NWZWN0b3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZGF0YTogZmxhdGJ1ZmZlcnMuT2Zmc2V0W10pOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgYnVpbGRlci5zdGFydFZlY3Rvcig0LCBkYXRhLmxlbmd0aCwgNCk7XG4gICAgICBmb3IgKGxldCBpID0gZGF0YS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBidWlsZGVyLmFkZE9mZnNldChkYXRhW2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBidWlsZGVyLmVuZFZlY3RvcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gbnVtYmVyIG51bUVsZW1zXG4gICAgICovXG4gICAgc3RhdGljIHN0YXJ0U3RyaW5nc1ZlY3RvcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBudW1FbGVtczogbnVtYmVyKSB7XG4gICAgICBidWlsZGVyLnN0YXJ0VmVjdG9yKDQsIG51bUVsZW1zLCA0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCB0ZW5zb3JzT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZFRlbnNvcnMoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgdGVuc29yc09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDExLCB0ZW5zb3JzT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIEFycmF5LjxmbGF0YnVmZmVycy5PZmZzZXQ+IGRhdGFcbiAgICAgKiBAcmV0dXJucyBmbGF0YnVmZmVycy5PZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlVGVuc29yc1ZlY3RvcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBkYXRhOiBmbGF0YnVmZmVycy5PZmZzZXRbXSk6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBidWlsZGVyLnN0YXJ0VmVjdG9yKDQsIGRhdGEubGVuZ3RoLCA0KTtcbiAgICAgIGZvciAobGV0IGkgPSBkYXRhLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGJ1aWxkZXIuYWRkT2Zmc2V0KGRhdGFbaV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1aWxkZXIuZW5kVmVjdG9yKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBudW1iZXIgbnVtRWxlbXNcbiAgICAgKi9cbiAgICBzdGF0aWMgc3RhcnRUZW5zb3JzVmVjdG9yKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIG51bUVsZW1zOiBudW1iZXIpIHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRWZWN0b3IoNCwgbnVtRWxlbXMsIDQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IGdyYXBoc09mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRHcmFwaHMoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZ3JhcGhzT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoMTIsIGdyYXBoc09mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBBcnJheS48ZmxhdGJ1ZmZlcnMuT2Zmc2V0PiBkYXRhXG4gICAgICogQHJldHVybnMgZmxhdGJ1ZmZlcnMuT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZUdyYXBoc1ZlY3RvcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBkYXRhOiBmbGF0YnVmZmVycy5PZmZzZXRbXSk6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBidWlsZGVyLnN0YXJ0VmVjdG9yKDQsIGRhdGEubGVuZ3RoLCA0KTtcbiAgICAgIGZvciAobGV0IGkgPSBkYXRhLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGJ1aWxkZXIuYWRkT2Zmc2V0KGRhdGFbaV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1aWxkZXIuZW5kVmVjdG9yKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBudW1iZXIgbnVtRWxlbXNcbiAgICAgKi9cbiAgICBzdGF0aWMgc3RhcnRHcmFwaHNWZWN0b3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgbnVtRWxlbXM6IG51bWJlcikge1xuICAgICAgYnVpbGRlci5zdGFydFZlY3Rvcig0LCBudW1FbGVtcywgNCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLk9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBlbmRBdHRyaWJ1dGUoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlcik6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gYnVpbGRlci5lbmRPYmplY3QoKTtcbiAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfVxuXG4gICAgc3RhdGljIGNyZWF0ZUF0dHJpYnV0ZShcbiAgICAgICAgYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgbmFtZU9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0LCBkb2NTdHJpbmdPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCxcbiAgICAgICAgdHlwZTogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5BdHRyaWJ1dGVUeXBlLCBmOiBudW1iZXIsIGk6IGZsYXRidWZmZXJzLkxvbmcsIHNPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCxcbiAgICAgICAgdE9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0LCBnT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQsIGZsb2F0c09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0LFxuICAgICAgICBpbnRzT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQsIHN0cmluZ3NPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCwgdGVuc29yc09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0LFxuICAgICAgICBncmFwaHNPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCk6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBBdHRyaWJ1dGUuc3RhcnRBdHRyaWJ1dGUoYnVpbGRlcik7XG4gICAgICBBdHRyaWJ1dGUuYWRkTmFtZShidWlsZGVyLCBuYW1lT2Zmc2V0KTtcbiAgICAgIEF0dHJpYnV0ZS5hZGREb2NTdHJpbmcoYnVpbGRlciwgZG9jU3RyaW5nT2Zmc2V0KTtcbiAgICAgIEF0dHJpYnV0ZS5hZGRUeXBlKGJ1aWxkZXIsIHR5cGUpO1xuICAgICAgQXR0cmlidXRlLmFkZEYoYnVpbGRlciwgZik7XG4gICAgICBBdHRyaWJ1dGUuYWRkSShidWlsZGVyLCBpKTtcbiAgICAgIEF0dHJpYnV0ZS5hZGRTKGJ1aWxkZXIsIHNPZmZzZXQpO1xuICAgICAgQXR0cmlidXRlLmFkZFQoYnVpbGRlciwgdE9mZnNldCk7XG4gICAgICBBdHRyaWJ1dGUuYWRkRyhidWlsZGVyLCBnT2Zmc2V0KTtcbiAgICAgIEF0dHJpYnV0ZS5hZGRGbG9hdHMoYnVpbGRlciwgZmxvYXRzT2Zmc2V0KTtcbiAgICAgIEF0dHJpYnV0ZS5hZGRJbnRzKGJ1aWxkZXIsIGludHNPZmZzZXQpO1xuICAgICAgQXR0cmlidXRlLmFkZFN0cmluZ3MoYnVpbGRlciwgc3RyaW5nc09mZnNldCk7XG4gICAgICBBdHRyaWJ1dGUuYWRkVGVuc29ycyhidWlsZGVyLCB0ZW5zb3JzT2Zmc2V0KTtcbiAgICAgIEF0dHJpYnV0ZS5hZGRHcmFwaHMoYnVpbGRlciwgZ3JhcGhzT2Zmc2V0KTtcbiAgICAgIHJldHVybiBBdHRyaWJ1dGUuZW5kQXR0cmlidXRlKGJ1aWxkZXIpO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZXhwb3J0IG5hbWVzcGFjZSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzIHtcbiAgZXhwb3J0IGNsYXNzIEdyYXBoIHtcbiAgICBiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlcnxudWxsID0gbnVsbDtcblxuICAgIGJiX3BvcyA9IDA7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIG51bWJlciBpXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcmV0dXJucyBHcmFwaFxuICAgICAqL1xuICAgIF9faW5pdChpOiBudW1iZXIsIGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyKTogR3JhcGgge1xuICAgICAgdGhpcy5iYl9wb3MgPSBpO1xuICAgICAgdGhpcy5iYiA9IGJiO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcGFyYW0gR3JhcGg9IG9ialxuICAgICAqIEByZXR1cm5zIEdyYXBoXG4gICAgICovXG4gICAgc3RhdGljIGdldFJvb3RBc0dyYXBoKGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyLCBvYmo/OiBHcmFwaCk6IEdyYXBoIHtcbiAgICAgIHJldHVybiAob2JqIHx8IG5ldyBHcmFwaCgpKS5fX2luaXQoYmIucmVhZEludDMyKGJiLnBvc2l0aW9uKCkpICsgYmIucG9zaXRpb24oKSwgYmIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHBhcmFtIEdyYXBoPSBvYmpcbiAgICAgKiBAcmV0dXJucyBHcmFwaFxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRTaXplUHJlZml4ZWRSb290QXNHcmFwaChiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciwgb2JqPzogR3JhcGgpOiBHcmFwaCB7XG4gICAgICBiYi5zZXRQb3NpdGlvbihiYi5wb3NpdGlvbigpICsgZmxhdGJ1ZmZlcnMuU0laRV9QUkVGSVhfTEVOR1RIKTtcbiAgICAgIHJldHVybiAob2JqIHx8IG5ldyBHcmFwaCgpKS5fX2luaXQoYmIucmVhZEludDMyKGJiLnBvc2l0aW9uKCkpICsgYmIucG9zaXRpb24oKSwgYmIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBudW1iZXIgaW5kZXhcbiAgICAgKiBAcGFyYW0gb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UZW5zb3I9IG9ialxuICAgICAqIEByZXR1cm5zIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZXJzKGluZGV4OiBudW1iZXIsIG9iaj86IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yKTogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UZW5zb3J8bnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDQpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IChvYmogfHwgbmV3IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC5fX2luaXQodGhpcy5iYiEuX19pbmRpcmVjdCh0aGlzLmJiIS5fX3ZlY3Rvcih0aGlzLmJiX3BvcyArIG9mZnNldCkgKyBpbmRleCAqIDQpLCB0aGlzLmJiISkgOlxuICAgICAgICAgICAgICAgICAgICAgIG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgbnVtYmVyXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZXJzTGVuZ3RoKCk6IG51bWJlciB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDQpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLl9fdmVjdG9yX2xlbih0aGlzLmJiX3BvcyArIG9mZnNldCkgOiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBudW1iZXIgaW5kZXhcbiAgICAgKiBAcGFyYW0gb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5WYWx1ZUluZm89IG9ialxuICAgICAqIEByZXR1cm5zIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVmFsdWVJbmZvXG4gICAgICovXG4gICAgbm9kZUFyZ3MoaW5kZXg6IG51bWJlciwgb2JqPzogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5WYWx1ZUluZm8pOiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlZhbHVlSW5mb3xudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgNik7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gKG9iaiB8fCBuZXcgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5WYWx1ZUluZm8oKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLl9faW5pdCh0aGlzLmJiIS5fX2luZGlyZWN0KHRoaXMuYmIhLl9fdmVjdG9yKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSArIGluZGV4ICogNCksIHRoaXMuYmIhKSA6XG4gICAgICAgICAgICAgICAgICAgICAgbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICAgKi9cbiAgICBub2RlQXJnc0xlbmd0aCgpOiBudW1iZXIge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA2KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MgKyBvZmZzZXQpIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbnVtYmVyIGluZGV4XG4gICAgICogQHBhcmFtIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuTm9kZT0gb2JqXG4gICAgICogQHJldHVybnMgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5Ob2RlXG4gICAgICovXG4gICAgbm9kZXMoaW5kZXg6IG51bWJlciwgb2JqPzogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5Ob2RlKTogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5Ob2RlfG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA4KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyAob2JqIHx8IG5ldyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLk5vZGUoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLl9faW5pdCh0aGlzLmJiIS5fX2luZGlyZWN0KHRoaXMuYmIhLl9fdmVjdG9yKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSArIGluZGV4ICogNCksIHRoaXMuYmIhKSA6XG4gICAgICAgICAgICAgICAgICAgICAgbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICAgKi9cbiAgICBub2Rlc0xlbmd0aCgpOiBudW1iZXIge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA4KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MgKyBvZmZzZXQpIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICAgKi9cbiAgICBtYXhOb2RlSW5kZXgoKTogbnVtYmVyIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgMTApO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLnJlYWRVaW50MzIodGhpcy5iYl9wb3MgKyBvZmZzZXQpIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbnVtYmVyIGluZGV4XG4gICAgICogQHBhcmFtIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuTm9kZUVkZ2U9IG9ialxuICAgICAqIEByZXR1cm5zIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuTm9kZUVkZ2VcbiAgICAgKi9cbiAgICBub2RlRWRnZXMoaW5kZXg6IG51bWJlciwgb2JqPzogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5Ob2RlRWRnZSk6IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuTm9kZUVkZ2V8bnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDEyKTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyAob2JqIHx8IG5ldyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLk5vZGVFZGdlKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC5fX2luaXQodGhpcy5iYiEuX19pbmRpcmVjdCh0aGlzLmJiIS5fX3ZlY3Rvcih0aGlzLmJiX3BvcyArIG9mZnNldCkgKyBpbmRleCAqIDQpLCB0aGlzLmJiISkgOlxuICAgICAgICAgICAgICAgICAgICAgIG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgbnVtYmVyXG4gICAgICovXG4gICAgbm9kZUVkZ2VzTGVuZ3RoKCk6IG51bWJlciB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDEyKTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MgKyBvZmZzZXQpIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbnVtYmVyIGluZGV4XG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkVuY29kaW5nPSBvcHRpb25hbEVuY29kaW5nXG4gICAgICogQHJldHVybnMgc3RyaW5nfFVpbnQ4QXJyYXlcbiAgICAgKi9cbiAgICBpbnB1dHMoaW5kZXg6IG51bWJlcik6IHN0cmluZztcbiAgICBpbnB1dHMoaW5kZXg6IG51bWJlciwgb3B0aW9uYWxFbmNvZGluZzogZmxhdGJ1ZmZlcnMuRW5jb2RpbmcpOiBzdHJpbmd8VWludDhBcnJheTtcbiAgICBpbnB1dHMoaW5kZXg6IG51bWJlciwgb3B0aW9uYWxFbmNvZGluZz86IGFueSk6IHN0cmluZ3xVaW50OEFycmF5fG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCAxNCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEuX19zdHJpbmcodGhpcy5iYiEuX192ZWN0b3IodGhpcy5iYl9wb3MgKyBvZmZzZXQpICsgaW5kZXggKiA0LCBvcHRpb25hbEVuY29kaW5nKSA6IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgbnVtYmVyXG4gICAgICovXG4gICAgaW5wdXRzTGVuZ3RoKCk6IG51bWJlciB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDE0KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MgKyBvZmZzZXQpIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbnVtYmVyIGluZGV4XG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkVuY29kaW5nPSBvcHRpb25hbEVuY29kaW5nXG4gICAgICogQHJldHVybnMgc3RyaW5nfFVpbnQ4QXJyYXlcbiAgICAgKi9cbiAgICBvdXRwdXRzKGluZGV4OiBudW1iZXIpOiBzdHJpbmc7XG4gICAgb3V0cHV0cyhpbmRleDogbnVtYmVyLCBvcHRpb25hbEVuY29kaW5nOiBmbGF0YnVmZmVycy5FbmNvZGluZyk6IHN0cmluZ3xVaW50OEFycmF5O1xuICAgIG91dHB1dHMoaW5kZXg6IG51bWJlciwgb3B0aW9uYWxFbmNvZGluZz86IGFueSk6IHN0cmluZ3xVaW50OEFycmF5fG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCAxNik7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEuX19zdHJpbmcodGhpcy5iYiEuX192ZWN0b3IodGhpcy5iYl9wb3MgKyBvZmZzZXQpICsgaW5kZXggKiA0LCBvcHRpb25hbEVuY29kaW5nKSA6IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgbnVtYmVyXG4gICAgICovXG4gICAgb3V0cHV0c0xlbmd0aCgpOiBudW1iZXIge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCAxNik7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSA6IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIG51bWJlciBpbmRleFxuICAgICAqIEBwYXJhbSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlNwYXJzZVRlbnNvcj0gb2JqXG4gICAgICogQHJldHVybnMgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5TcGFyc2VUZW5zb3JcbiAgICAgKi9cbiAgICBzcGFyc2VJbml0aWFsaXplcnMoaW5kZXg6IG51bWJlciwgb2JqPzogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5TcGFyc2VUZW5zb3IpOlxuICAgICAgICBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlNwYXJzZVRlbnNvcnxudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgMTgpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IChvYmogfHwgbmV3IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuU3BhcnNlVGVuc29yKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC5fX2luaXQodGhpcy5iYiEuX19pbmRpcmVjdCh0aGlzLmJiIS5fX3ZlY3Rvcih0aGlzLmJiX3BvcyArIG9mZnNldCkgKyBpbmRleCAqIDQpLCB0aGlzLmJiISkgOlxuICAgICAgICAgICAgICAgICAgICAgIG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgbnVtYmVyXG4gICAgICovXG4gICAgc3BhcnNlSW5pdGlhbGl6ZXJzTGVuZ3RoKCk6IG51bWJlciB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDE4KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MgKyBvZmZzZXQpIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICovXG4gICAgc3RhdGljIHN0YXJ0R3JhcGgoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlcikge1xuICAgICAgYnVpbGRlci5zdGFydE9iamVjdCg4KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCBpbml0aWFsaXplcnNPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkSW5pdGlhbGl6ZXJzKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGluaXRpYWxpemVyc09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDAsIGluaXRpYWxpemVyc09mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBBcnJheS48ZmxhdGJ1ZmZlcnMuT2Zmc2V0PiBkYXRhXG4gICAgICogQHJldHVybnMgZmxhdGJ1ZmZlcnMuT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZUluaXRpYWxpemVyc1ZlY3RvcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBkYXRhOiBmbGF0YnVmZmVycy5PZmZzZXRbXSk6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBidWlsZGVyLnN0YXJ0VmVjdG9yKDQsIGRhdGEubGVuZ3RoLCA0KTtcbiAgICAgIGZvciAobGV0IGkgPSBkYXRhLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGJ1aWxkZXIuYWRkT2Zmc2V0KGRhdGFbaV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1aWxkZXIuZW5kVmVjdG9yKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBudW1iZXIgbnVtRWxlbXNcbiAgICAgKi9cbiAgICBzdGF0aWMgc3RhcnRJbml0aWFsaXplcnNWZWN0b3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgbnVtRWxlbXM6IG51bWJlcikge1xuICAgICAgYnVpbGRlci5zdGFydFZlY3Rvcig0LCBudW1FbGVtcywgNCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgbm9kZUFyZ3NPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkTm9kZUFyZ3MoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgbm9kZUFyZ3NPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCgxLCBub2RlQXJnc09mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBBcnJheS48ZmxhdGJ1ZmZlcnMuT2Zmc2V0PiBkYXRhXG4gICAgICogQHJldHVybnMgZmxhdGJ1ZmZlcnMuT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZU5vZGVBcmdzVmVjdG9yKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGRhdGE6IGZsYXRidWZmZXJzLk9mZnNldFtdKTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRWZWN0b3IoNCwgZGF0YS5sZW5ndGgsIDQpO1xuICAgICAgZm9yIChsZXQgaSA9IGRhdGEubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgYnVpbGRlci5hZGRPZmZzZXQoZGF0YVtpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYnVpbGRlci5lbmRWZWN0b3IoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIG51bWJlciBudW1FbGVtc1xuICAgICAqL1xuICAgIHN0YXRpYyBzdGFydE5vZGVBcmdzVmVjdG9yKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIG51bUVsZW1zOiBudW1iZXIpIHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRWZWN0b3IoNCwgbnVtRWxlbXMsIDQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IG5vZGVzT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZE5vZGVzKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIG5vZGVzT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoMiwgbm9kZXNPZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gQXJyYXkuPGZsYXRidWZmZXJzLk9mZnNldD4gZGF0YVxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLk9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVOb2Rlc1ZlY3RvcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBkYXRhOiBmbGF0YnVmZmVycy5PZmZzZXRbXSk6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBidWlsZGVyLnN0YXJ0VmVjdG9yKDQsIGRhdGEubGVuZ3RoLCA0KTtcbiAgICAgIGZvciAobGV0IGkgPSBkYXRhLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGJ1aWxkZXIuYWRkT2Zmc2V0KGRhdGFbaV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1aWxkZXIuZW5kVmVjdG9yKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBudW1iZXIgbnVtRWxlbXNcbiAgICAgKi9cbiAgICBzdGF0aWMgc3RhcnROb2Rlc1ZlY3RvcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBudW1FbGVtczogbnVtYmVyKSB7XG4gICAgICBidWlsZGVyLnN0YXJ0VmVjdG9yKDQsIG51bUVsZW1zLCA0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIG51bWJlciBtYXhOb2RlSW5kZXhcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkTWF4Tm9kZUluZGV4KGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIG1heE5vZGVJbmRleDogbnVtYmVyKSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkSW50MzIoMywgbWF4Tm9kZUluZGV4LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCBub2RlRWRnZXNPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkTm9kZUVkZ2VzKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIG5vZGVFZGdlc09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDQsIG5vZGVFZGdlc09mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBBcnJheS48ZmxhdGJ1ZmZlcnMuT2Zmc2V0PiBkYXRhXG4gICAgICogQHJldHVybnMgZmxhdGJ1ZmZlcnMuT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZU5vZGVFZGdlc1ZlY3RvcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBkYXRhOiBmbGF0YnVmZmVycy5PZmZzZXRbXSk6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBidWlsZGVyLnN0YXJ0VmVjdG9yKDQsIGRhdGEubGVuZ3RoLCA0KTtcbiAgICAgIGZvciAobGV0IGkgPSBkYXRhLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGJ1aWxkZXIuYWRkT2Zmc2V0KGRhdGFbaV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1aWxkZXIuZW5kVmVjdG9yKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBudW1iZXIgbnVtRWxlbXNcbiAgICAgKi9cbiAgICBzdGF0aWMgc3RhcnROb2RlRWRnZXNWZWN0b3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgbnVtRWxlbXM6IG51bWJlcikge1xuICAgICAgYnVpbGRlci5zdGFydFZlY3Rvcig0LCBudW1FbGVtcywgNCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgaW5wdXRzT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZElucHV0cyhidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBpbnB1dHNPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCg1LCBpbnB1dHNPZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gQXJyYXkuPGZsYXRidWZmZXJzLk9mZnNldD4gZGF0YVxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLk9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVJbnB1dHNWZWN0b3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZGF0YTogZmxhdGJ1ZmZlcnMuT2Zmc2V0W10pOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgYnVpbGRlci5zdGFydFZlY3Rvcig0LCBkYXRhLmxlbmd0aCwgNCk7XG4gICAgICBmb3IgKGxldCBpID0gZGF0YS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBidWlsZGVyLmFkZE9mZnNldChkYXRhW2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBidWlsZGVyLmVuZFZlY3RvcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gbnVtYmVyIG51bUVsZW1zXG4gICAgICovXG4gICAgc3RhdGljIHN0YXJ0SW5wdXRzVmVjdG9yKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIG51bUVsZW1zOiBudW1iZXIpIHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRWZWN0b3IoNCwgbnVtRWxlbXMsIDQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IG91dHB1dHNPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkT3V0cHV0cyhidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBvdXRwdXRzT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoNiwgb3V0cHV0c09mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBBcnJheS48ZmxhdGJ1ZmZlcnMuT2Zmc2V0PiBkYXRhXG4gICAgICogQHJldHVybnMgZmxhdGJ1ZmZlcnMuT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZU91dHB1dHNWZWN0b3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZGF0YTogZmxhdGJ1ZmZlcnMuT2Zmc2V0W10pOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgYnVpbGRlci5zdGFydFZlY3Rvcig0LCBkYXRhLmxlbmd0aCwgNCk7XG4gICAgICBmb3IgKGxldCBpID0gZGF0YS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBidWlsZGVyLmFkZE9mZnNldChkYXRhW2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBidWlsZGVyLmVuZFZlY3RvcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gbnVtYmVyIG51bUVsZW1zXG4gICAgICovXG4gICAgc3RhdGljIHN0YXJ0T3V0cHV0c1ZlY3RvcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBudW1FbGVtczogbnVtYmVyKSB7XG4gICAgICBidWlsZGVyLnN0YXJ0VmVjdG9yKDQsIG51bUVsZW1zLCA0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCBzcGFyc2VJbml0aWFsaXplcnNPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkU3BhcnNlSW5pdGlhbGl6ZXJzKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIHNwYXJzZUluaXRpYWxpemVyc09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDcsIHNwYXJzZUluaXRpYWxpemVyc09mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBBcnJheS48ZmxhdGJ1ZmZlcnMuT2Zmc2V0PiBkYXRhXG4gICAgICogQHJldHVybnMgZmxhdGJ1ZmZlcnMuT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZVNwYXJzZUluaXRpYWxpemVyc1ZlY3RvcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBkYXRhOiBmbGF0YnVmZmVycy5PZmZzZXRbXSk6XG4gICAgICAgIGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBidWlsZGVyLnN0YXJ0VmVjdG9yKDQsIGRhdGEubGVuZ3RoLCA0KTtcbiAgICAgIGZvciAobGV0IGkgPSBkYXRhLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGJ1aWxkZXIuYWRkT2Zmc2V0KGRhdGFbaV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1aWxkZXIuZW5kVmVjdG9yKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBudW1iZXIgbnVtRWxlbXNcbiAgICAgKi9cbiAgICBzdGF0aWMgc3RhcnRTcGFyc2VJbml0aWFsaXplcnNWZWN0b3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgbnVtRWxlbXM6IG51bWJlcikge1xuICAgICAgYnVpbGRlci5zdGFydFZlY3Rvcig0LCBudW1FbGVtcywgNCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLk9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBlbmRHcmFwaChidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyKTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIGxldCBvZmZzZXQgPSBidWlsZGVyLmVuZE9iamVjdCgpO1xuICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9XG5cbiAgICBzdGF0aWMgY3JlYXRlR3JhcGgoXG4gICAgICAgIGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGluaXRpYWxpemVyc09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0LCBub2RlQXJnc09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0LFxuICAgICAgICBub2Rlc09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0LCBtYXhOb2RlSW5kZXg6IG51bWJlciwgbm9kZUVkZ2VzT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQsXG4gICAgICAgIGlucHV0c09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0LCBvdXRwdXRzT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQsXG4gICAgICAgIHNwYXJzZUluaXRpYWxpemVyc09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIEdyYXBoLnN0YXJ0R3JhcGgoYnVpbGRlcik7XG4gICAgICBHcmFwaC5hZGRJbml0aWFsaXplcnMoYnVpbGRlciwgaW5pdGlhbGl6ZXJzT2Zmc2V0KTtcbiAgICAgIEdyYXBoLmFkZE5vZGVBcmdzKGJ1aWxkZXIsIG5vZGVBcmdzT2Zmc2V0KTtcbiAgICAgIEdyYXBoLmFkZE5vZGVzKGJ1aWxkZXIsIG5vZGVzT2Zmc2V0KTtcbiAgICAgIEdyYXBoLmFkZE1heE5vZGVJbmRleChidWlsZGVyLCBtYXhOb2RlSW5kZXgpO1xuICAgICAgR3JhcGguYWRkTm9kZUVkZ2VzKGJ1aWxkZXIsIG5vZGVFZGdlc09mZnNldCk7XG4gICAgICBHcmFwaC5hZGRJbnB1dHMoYnVpbGRlciwgaW5wdXRzT2Zmc2V0KTtcbiAgICAgIEdyYXBoLmFkZE91dHB1dHMoYnVpbGRlciwgb3V0cHV0c09mZnNldCk7XG4gICAgICBHcmFwaC5hZGRTcGFyc2VJbml0aWFsaXplcnMoYnVpbGRlciwgc3BhcnNlSW5pdGlhbGl6ZXJzT2Zmc2V0KTtcbiAgICAgIHJldHVybiBHcmFwaC5lbmRHcmFwaChidWlsZGVyKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmV4cG9ydCBuYW1lc3BhY2Ugb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicyB7XG4gIGV4cG9ydCBjbGFzcyBNb2RlbCB7XG4gICAgYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXJ8bnVsbCA9IG51bGw7XG5cbiAgICBiYl9wb3MgPSAwO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBudW1iZXIgaVxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHJldHVybnMgTW9kZWxcbiAgICAgKi9cbiAgICBfX2luaXQoaTogbnVtYmVyLCBiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlcik6IE1vZGVsIHtcbiAgICAgIHRoaXMuYmJfcG9zID0gaTtcbiAgICAgIHRoaXMuYmIgPSBiYjtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHBhcmFtIE1vZGVsPSBvYmpcbiAgICAgKiBAcmV0dXJucyBNb2RlbFxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRSb290QXNNb2RlbChiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciwgb2JqPzogTW9kZWwpOiBNb2RlbCB7XG4gICAgICByZXR1cm4gKG9iaiB8fCBuZXcgTW9kZWwoKSkuX19pbml0KGJiLnJlYWRJbnQzMihiYi5wb3NpdGlvbigpKSArIGJiLnBvc2l0aW9uKCksIGJiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEBwYXJhbSBNb2RlbD0gb2JqXG4gICAgICogQHJldHVybnMgTW9kZWxcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0U2l6ZVByZWZpeGVkUm9vdEFzTW9kZWwoYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIsIG9iaj86IE1vZGVsKTogTW9kZWwge1xuICAgICAgYmIuc2V0UG9zaXRpb24oYmIucG9zaXRpb24oKSArIGZsYXRidWZmZXJzLlNJWkVfUFJFRklYX0xFTkdUSCk7XG4gICAgICByZXR1cm4gKG9iaiB8fCBuZXcgTW9kZWwoKSkuX19pbml0KGJiLnJlYWRJbnQzMihiYi5wb3NpdGlvbigpKSArIGJiLnBvc2l0aW9uKCksIGJiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBmbGF0YnVmZmVycy5Mb25nXG4gICAgICovXG4gICAgaXJWZXJzaW9uKCk6IGZsYXRidWZmZXJzLkxvbmcge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA0KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5yZWFkSW50NjQodGhpcy5iYl9wb3MgKyBvZmZzZXQpIDogdGhpcy5iYiEuY3JlYXRlTG9uZygwLCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbnVtYmVyIGluZGV4XG4gICAgICogQHBhcmFtIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuT3BlcmF0b3JTZXRJZD0gb2JqXG4gICAgICogQHJldHVybnMgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5PcGVyYXRvclNldElkXG4gICAgICovXG4gICAgb3BzZXRJbXBvcnQoaW5kZXg6IG51bWJlciwgb2JqPzogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5PcGVyYXRvclNldElkKTpcbiAgICAgICAgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5PcGVyYXRvclNldElkfG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA2KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyAob2JqIHx8IG5ldyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLk9wZXJhdG9yU2V0SWQoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLl9faW5pdCh0aGlzLmJiIS5fX2luZGlyZWN0KHRoaXMuYmIhLl9fdmVjdG9yKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSArIGluZGV4ICogNCksIHRoaXMuYmIhKSA6XG4gICAgICAgICAgICAgICAgICAgICAgbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICAgKi9cbiAgICBvcHNldEltcG9ydExlbmd0aCgpOiBudW1iZXIge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA2KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MgKyBvZmZzZXQpIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuRW5jb2Rpbmc9IG9wdGlvbmFsRW5jb2RpbmdcbiAgICAgKiBAcmV0dXJucyBzdHJpbmd8VWludDhBcnJheXxudWxsXG4gICAgICovXG4gICAgcHJvZHVjZXJOYW1lKCk6IHN0cmluZ3xudWxsO1xuICAgIHByb2R1Y2VyTmFtZShvcHRpb25hbEVuY29kaW5nOiBmbGF0YnVmZmVycy5FbmNvZGluZyk6IHN0cmluZ3xVaW50OEFycmF5fG51bGw7XG4gICAgcHJvZHVjZXJOYW1lKG9wdGlvbmFsRW5jb2Rpbmc/OiBhbnkpOiBzdHJpbmd8VWludDhBcnJheXxudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgOCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEuX19zdHJpbmcodGhpcy5iYl9wb3MgKyBvZmZzZXQsIG9wdGlvbmFsRW5jb2RpbmcpIDogbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuRW5jb2Rpbmc9IG9wdGlvbmFsRW5jb2RpbmdcbiAgICAgKiBAcmV0dXJucyBzdHJpbmd8VWludDhBcnJheXxudWxsXG4gICAgICovXG4gICAgcHJvZHVjZXJWZXJzaW9uKCk6IHN0cmluZ3xudWxsO1xuICAgIHByb2R1Y2VyVmVyc2lvbihvcHRpb25hbEVuY29kaW5nOiBmbGF0YnVmZmVycy5FbmNvZGluZyk6IHN0cmluZ3xVaW50OEFycmF5fG51bGw7XG4gICAgcHJvZHVjZXJWZXJzaW9uKG9wdGlvbmFsRW5jb2Rpbmc/OiBhbnkpOiBzdHJpbmd8VWludDhBcnJheXxudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgMTApO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLl9fc3RyaW5nKHRoaXMuYmJfcG9zICsgb2Zmc2V0LCBvcHRpb25hbEVuY29kaW5nKSA6IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkVuY29kaW5nPSBvcHRpb25hbEVuY29kaW5nXG4gICAgICogQHJldHVybnMgc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbFxuICAgICAqL1xuICAgIGRvbWFpbigpOiBzdHJpbmd8bnVsbDtcbiAgICBkb21haW4ob3B0aW9uYWxFbmNvZGluZzogZmxhdGJ1ZmZlcnMuRW5jb2RpbmcpOiBzdHJpbmd8VWludDhBcnJheXxudWxsO1xuICAgIGRvbWFpbihvcHRpb25hbEVuY29kaW5nPzogYW55KTogc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDEyKTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3N0cmluZyh0aGlzLmJiX3BvcyArIG9mZnNldCwgb3B0aW9uYWxFbmNvZGluZykgOiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLkxvbmdcbiAgICAgKi9cbiAgICBtb2RlbFZlcnNpb24oKTogZmxhdGJ1ZmZlcnMuTG9uZyB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDE0KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5yZWFkSW50NjQodGhpcy5iYl9wb3MgKyBvZmZzZXQpIDogdGhpcy5iYiEuY3JlYXRlTG9uZygwLCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuRW5jb2Rpbmc9IG9wdGlvbmFsRW5jb2RpbmdcbiAgICAgKiBAcmV0dXJucyBzdHJpbmd8VWludDhBcnJheXxudWxsXG4gICAgICovXG4gICAgZG9jU3RyaW5nKCk6IHN0cmluZ3xudWxsO1xuICAgIGRvY1N0cmluZyhvcHRpb25hbEVuY29kaW5nOiBmbGF0YnVmZmVycy5FbmNvZGluZyk6IHN0cmluZ3xVaW50OEFycmF5fG51bGw7XG4gICAgZG9jU3RyaW5nKG9wdGlvbmFsRW5jb2Rpbmc/OiBhbnkpOiBzdHJpbmd8VWludDhBcnJheXxudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgMTYpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLl9fc3RyaW5nKHRoaXMuYmJfcG9zICsgb2Zmc2V0LCBvcHRpb25hbEVuY29kaW5nKSA6IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuR3JhcGg9IG9ialxuICAgICAqIEByZXR1cm5zIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuR3JhcGh8bnVsbFxuICAgICAqL1xuICAgIGdyYXBoKG9iaj86IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuR3JhcGgpOiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLkdyYXBofG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCAxOCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gKG9iaiB8fCBuZXcgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5HcmFwaCgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAuX19pbml0KHRoaXMuYmIhLl9faW5kaXJlY3QodGhpcy5iYl9wb3MgKyBvZmZzZXQpLCB0aGlzLmJiISkgOlxuICAgICAgICAgICAgICAgICAgICAgIG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkVuY29kaW5nPSBvcHRpb25hbEVuY29kaW5nXG4gICAgICogQHJldHVybnMgc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbFxuICAgICAqL1xuICAgIGdyYXBoRG9jU3RyaW5nKCk6IHN0cmluZ3xudWxsO1xuICAgIGdyYXBoRG9jU3RyaW5nKG9wdGlvbmFsRW5jb2Rpbmc6IGZsYXRidWZmZXJzLkVuY29kaW5nKTogc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbDtcbiAgICBncmFwaERvY1N0cmluZyhvcHRpb25hbEVuY29kaW5nPzogYW55KTogc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDIwKTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3N0cmluZyh0aGlzLmJiX3BvcyArIG9mZnNldCwgb3B0aW9uYWxFbmNvZGluZykgOiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKi9cbiAgICBzdGF0aWMgc3RhcnRNb2RlbChidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyKSB7XG4gICAgICBidWlsZGVyLnN0YXJ0T2JqZWN0KDkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuTG9uZyBpclZlcnNpb25cbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkSXJWZXJzaW9uKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGlyVmVyc2lvbjogZmxhdGJ1ZmZlcnMuTG9uZykge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZEludDY0KDAsIGlyVmVyc2lvbiwgYnVpbGRlci5jcmVhdGVMb25nKDAsIDApKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCBvcHNldEltcG9ydE9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRPcHNldEltcG9ydChidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBvcHNldEltcG9ydE9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDEsIG9wc2V0SW1wb3J0T2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIEFycmF5LjxmbGF0YnVmZmVycy5PZmZzZXQ+IGRhdGFcbiAgICAgKiBAcmV0dXJucyBmbGF0YnVmZmVycy5PZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlT3BzZXRJbXBvcnRWZWN0b3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZGF0YTogZmxhdGJ1ZmZlcnMuT2Zmc2V0W10pOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgYnVpbGRlci5zdGFydFZlY3Rvcig0LCBkYXRhLmxlbmd0aCwgNCk7XG4gICAgICBmb3IgKGxldCBpID0gZGF0YS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBidWlsZGVyLmFkZE9mZnNldChkYXRhW2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBidWlsZGVyLmVuZFZlY3RvcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gbnVtYmVyIG51bUVsZW1zXG4gICAgICovXG4gICAgc3RhdGljIHN0YXJ0T3BzZXRJbXBvcnRWZWN0b3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgbnVtRWxlbXM6IG51bWJlcikge1xuICAgICAgYnVpbGRlci5zdGFydFZlY3Rvcig0LCBudW1FbGVtcywgNCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgcHJvZHVjZXJOYW1lT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZFByb2R1Y2VyTmFtZShidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBwcm9kdWNlck5hbWVPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCgyLCBwcm9kdWNlck5hbWVPZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IHByb2R1Y2VyVmVyc2lvbk9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRQcm9kdWNlclZlcnNpb24oYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgcHJvZHVjZXJWZXJzaW9uT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoMywgcHJvZHVjZXJWZXJzaW9uT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCBkb21haW5PZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkRG9tYWluKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGRvbWFpbk9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDQsIGRvbWFpbk9mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5Mb25nIG1vZGVsVmVyc2lvblxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRNb2RlbFZlcnNpb24oYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgbW9kZWxWZXJzaW9uOiBmbGF0YnVmZmVycy5Mb25nKSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkSW50NjQoNSwgbW9kZWxWZXJzaW9uLCBidWlsZGVyLmNyZWF0ZUxvbmcoMCwgMCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IGRvY1N0cmluZ09mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGREb2NTdHJpbmcoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZG9jU3RyaW5nT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoNiwgZG9jU3RyaW5nT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCBncmFwaE9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRHcmFwaChidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBncmFwaE9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDcsIGdyYXBoT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCBncmFwaERvY1N0cmluZ09mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRHcmFwaERvY1N0cmluZyhidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBncmFwaERvY1N0cmluZ09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDgsIGdyYXBoRG9jU3RyaW5nT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHJldHVybnMgZmxhdGJ1ZmZlcnMuT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGVuZE1vZGVsKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIpOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgbGV0IG9mZnNldCA9IGJ1aWxkZXIuZW5kT2JqZWN0KCk7XG4gICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH1cblxuICAgIHN0YXRpYyBjcmVhdGVNb2RlbChcbiAgICAgICAgYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgaXJWZXJzaW9uOiBmbGF0YnVmZmVycy5Mb25nLCBvcHNldEltcG9ydE9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0LFxuICAgICAgICBwcm9kdWNlck5hbWVPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCwgcHJvZHVjZXJWZXJzaW9uT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQsXG4gICAgICAgIGRvbWFpbk9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0LCBtb2RlbFZlcnNpb246IGZsYXRidWZmZXJzLkxvbmcsIGRvY1N0cmluZ09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0LFxuICAgICAgICBncmFwaE9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0LCBncmFwaERvY1N0cmluZ09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIE1vZGVsLnN0YXJ0TW9kZWwoYnVpbGRlcik7XG4gICAgICBNb2RlbC5hZGRJclZlcnNpb24oYnVpbGRlciwgaXJWZXJzaW9uKTtcbiAgICAgIE1vZGVsLmFkZE9wc2V0SW1wb3J0KGJ1aWxkZXIsIG9wc2V0SW1wb3J0T2Zmc2V0KTtcbiAgICAgIE1vZGVsLmFkZFByb2R1Y2VyTmFtZShidWlsZGVyLCBwcm9kdWNlck5hbWVPZmZzZXQpO1xuICAgICAgTW9kZWwuYWRkUHJvZHVjZXJWZXJzaW9uKGJ1aWxkZXIsIHByb2R1Y2VyVmVyc2lvbk9mZnNldCk7XG4gICAgICBNb2RlbC5hZGREb21haW4oYnVpbGRlciwgZG9tYWluT2Zmc2V0KTtcbiAgICAgIE1vZGVsLmFkZE1vZGVsVmVyc2lvbihidWlsZGVyLCBtb2RlbFZlcnNpb24pO1xuICAgICAgTW9kZWwuYWRkRG9jU3RyaW5nKGJ1aWxkZXIsIGRvY1N0cmluZ09mZnNldCk7XG4gICAgICBNb2RlbC5hZGRHcmFwaChidWlsZGVyLCBncmFwaE9mZnNldCk7XG4gICAgICBNb2RlbC5hZGRHcmFwaERvY1N0cmluZyhidWlsZGVyLCBncmFwaERvY1N0cmluZ09mZnNldCk7XG4gICAgICByZXR1cm4gTW9kZWwuZW5kTW9kZWwoYnVpbGRlcik7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5leHBvcnQgbmFtZXNwYWNlIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMge1xuICBleHBvcnQgY2xhc3MgS2VybmVsQ3JlYXRlSW5mb3Mge1xuICAgIGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyfG51bGwgPSBudWxsO1xuXG4gICAgYmJfcG9zID0gMDtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbnVtYmVyIGlcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEByZXR1cm5zIEtlcm5lbENyZWF0ZUluZm9zXG4gICAgICovXG4gICAgX19pbml0KGk6IG51bWJlciwgYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIpOiBLZXJuZWxDcmVhdGVJbmZvcyB7XG4gICAgICB0aGlzLmJiX3BvcyA9IGk7XG4gICAgICB0aGlzLmJiID0gYmI7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEBwYXJhbSBLZXJuZWxDcmVhdGVJbmZvcz0gb2JqXG4gICAgICogQHJldHVybnMgS2VybmVsQ3JlYXRlSW5mb3NcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0Um9vdEFzS2VybmVsQ3JlYXRlSW5mb3MoYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIsIG9iaj86IEtlcm5lbENyZWF0ZUluZm9zKTogS2VybmVsQ3JlYXRlSW5mb3Mge1xuICAgICAgcmV0dXJuIChvYmogfHwgbmV3IEtlcm5lbENyZWF0ZUluZm9zKCkpLl9faW5pdChiYi5yZWFkSW50MzIoYmIucG9zaXRpb24oKSkgKyBiYi5wb3NpdGlvbigpLCBiYik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcGFyYW0gS2VybmVsQ3JlYXRlSW5mb3M9IG9ialxuICAgICAqIEByZXR1cm5zIEtlcm5lbENyZWF0ZUluZm9zXG4gICAgICovXG4gICAgc3RhdGljIGdldFNpemVQcmVmaXhlZFJvb3RBc0tlcm5lbENyZWF0ZUluZm9zKGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyLCBvYmo/OiBLZXJuZWxDcmVhdGVJbmZvcyk6XG4gICAgICAgIEtlcm5lbENyZWF0ZUluZm9zIHtcbiAgICAgIGJiLnNldFBvc2l0aW9uKGJiLnBvc2l0aW9uKCkgKyBmbGF0YnVmZmVycy5TSVpFX1BSRUZJWF9MRU5HVEgpO1xuICAgICAgcmV0dXJuIChvYmogfHwgbmV3IEtlcm5lbENyZWF0ZUluZm9zKCkpLl9faW5pdChiYi5yZWFkSW50MzIoYmIucG9zaXRpb24oKSkgKyBiYi5wb3NpdGlvbigpLCBiYik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIG51bWJlciBpbmRleFxuICAgICAqIEByZXR1cm5zIG51bWJlclxuICAgICAqL1xuICAgIG5vZGVJbmRpY2VzKGluZGV4OiBudW1iZXIpOiBudW1iZXJ8bnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDQpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLnJlYWRVaW50MzIodGhpcy5iYiEuX192ZWN0b3IodGhpcy5iYl9wb3MgKyBvZmZzZXQpICsgaW5kZXggKiA0KSA6IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgbnVtYmVyXG4gICAgICovXG4gICAgbm9kZUluZGljZXNMZW5ndGgoKTogbnVtYmVyIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgNCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSA6IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgVWludDMyQXJyYXlcbiAgICAgKi9cbiAgICBub2RlSW5kaWNlc0FycmF5KCk6IFVpbnQzMkFycmF5fG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA0KTtcbiAgICAgIHJldHVybiBvZmZzZXQgP1xuICAgICAgICAgIG5ldyBVaW50MzJBcnJheShcbiAgICAgICAgICAgICAgdGhpcy5iYiEuYnl0ZXMoKS5idWZmZXIsIHRoaXMuYmIhLmJ5dGVzKCkuYnl0ZU9mZnNldCArIHRoaXMuYmIhLl9fdmVjdG9yKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSxcbiAgICAgICAgICAgICAgdGhpcy5iYiEuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSkgOlxuICAgICAgICAgIG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIG51bWJlciBpbmRleFxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLkxvbmdcbiAgICAgKi9cbiAgICBrZXJuZWxEZWZIYXNoZXMoaW5kZXg6IG51bWJlcik6IGZsYXRidWZmZXJzLkxvbmd8bnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDYpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLnJlYWRVaW50NjQodGhpcy5iYiEuX192ZWN0b3IodGhpcy5iYl9wb3MgKyBvZmZzZXQpICsgaW5kZXggKiA4KSA6XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5iYiEuY3JlYXRlTG9uZygwLCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICAgKi9cbiAgICBrZXJuZWxEZWZIYXNoZXNMZW5ndGgoKTogbnVtYmVyIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgNik7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSA6IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqL1xuICAgIHN0YXRpYyBzdGFydEtlcm5lbENyZWF0ZUluZm9zKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIpIHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRPYmplY3QoMik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgbm9kZUluZGljZXNPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkTm9kZUluZGljZXMoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgbm9kZUluZGljZXNPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCgwLCBub2RlSW5kaWNlc09mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBBcnJheS48bnVtYmVyPiBkYXRhXG4gICAgICogQHJldHVybnMgZmxhdGJ1ZmZlcnMuT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZU5vZGVJbmRpY2VzVmVjdG9yKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGRhdGE6IG51bWJlcltdfFVpbnQ4QXJyYXkpOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgYnVpbGRlci5zdGFydFZlY3Rvcig0LCBkYXRhLmxlbmd0aCwgNCk7XG4gICAgICBmb3IgKGxldCBpID0gZGF0YS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBidWlsZGVyLmFkZEludDMyKGRhdGFbaV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1aWxkZXIuZW5kVmVjdG9yKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBudW1iZXIgbnVtRWxlbXNcbiAgICAgKi9cbiAgICBzdGF0aWMgc3RhcnROb2RlSW5kaWNlc1ZlY3RvcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBudW1FbGVtczogbnVtYmVyKSB7XG4gICAgICBidWlsZGVyLnN0YXJ0VmVjdG9yKDQsIG51bUVsZW1zLCA0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCBrZXJuZWxEZWZIYXNoZXNPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkS2VybmVsRGVmSGFzaGVzKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGtlcm5lbERlZkhhc2hlc09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDEsIGtlcm5lbERlZkhhc2hlc09mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBBcnJheS48ZmxhdGJ1ZmZlcnMuTG9uZz4gZGF0YVxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLk9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVLZXJuZWxEZWZIYXNoZXNWZWN0b3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZGF0YTogZmxhdGJ1ZmZlcnMuTG9uZ1tdKTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRWZWN0b3IoOCwgZGF0YS5sZW5ndGgsIDgpO1xuICAgICAgZm9yIChsZXQgaSA9IGRhdGEubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgYnVpbGRlci5hZGRJbnQ2NChkYXRhW2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBidWlsZGVyLmVuZFZlY3RvcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gbnVtYmVyIG51bUVsZW1zXG4gICAgICovXG4gICAgc3RhdGljIHN0YXJ0S2VybmVsRGVmSGFzaGVzVmVjdG9yKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIG51bUVsZW1zOiBudW1iZXIpIHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRWZWN0b3IoOCwgbnVtRWxlbXMsIDgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcmV0dXJucyBmbGF0YnVmZmVycy5PZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgZW5kS2VybmVsQ3JlYXRlSW5mb3MoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlcik6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gYnVpbGRlci5lbmRPYmplY3QoKTtcbiAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfVxuXG4gICAgc3RhdGljIGNyZWF0ZUtlcm5lbENyZWF0ZUluZm9zKFxuICAgICAgICBidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBub2RlSW5kaWNlc09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0LFxuICAgICAgICBrZXJuZWxEZWZIYXNoZXNPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCk6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBLZXJuZWxDcmVhdGVJbmZvcy5zdGFydEtlcm5lbENyZWF0ZUluZm9zKGJ1aWxkZXIpO1xuICAgICAgS2VybmVsQ3JlYXRlSW5mb3MuYWRkTm9kZUluZGljZXMoYnVpbGRlciwgbm9kZUluZGljZXNPZmZzZXQpO1xuICAgICAgS2VybmVsQ3JlYXRlSW5mb3MuYWRkS2VybmVsRGVmSGFzaGVzKGJ1aWxkZXIsIGtlcm5lbERlZkhhc2hlc09mZnNldCk7XG4gICAgICByZXR1cm4gS2VybmVsQ3JlYXRlSW5mb3MuZW5kS2VybmVsQ3JlYXRlSW5mb3MoYnVpbGRlcik7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5leHBvcnQgbmFtZXNwYWNlIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMge1xuICBleHBvcnQgY2xhc3MgU3ViR3JhcGhTZXNzaW9uU3RhdGUge1xuICAgIGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyfG51bGwgPSBudWxsO1xuXG4gICAgYmJfcG9zID0gMDtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbnVtYmVyIGlcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEByZXR1cm5zIFN1YkdyYXBoU2Vzc2lvblN0YXRlXG4gICAgICovXG4gICAgX19pbml0KGk6IG51bWJlciwgYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIpOiBTdWJHcmFwaFNlc3Npb25TdGF0ZSB7XG4gICAgICB0aGlzLmJiX3BvcyA9IGk7XG4gICAgICB0aGlzLmJiID0gYmI7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEBwYXJhbSBTdWJHcmFwaFNlc3Npb25TdGF0ZT0gb2JqXG4gICAgICogQHJldHVybnMgU3ViR3JhcGhTZXNzaW9uU3RhdGVcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0Um9vdEFzU3ViR3JhcGhTZXNzaW9uU3RhdGUoYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIsIG9iaj86IFN1YkdyYXBoU2Vzc2lvblN0YXRlKTogU3ViR3JhcGhTZXNzaW9uU3RhdGUge1xuICAgICAgcmV0dXJuIChvYmogfHwgbmV3IFN1YkdyYXBoU2Vzc2lvblN0YXRlKCkpLl9faW5pdChiYi5yZWFkSW50MzIoYmIucG9zaXRpb24oKSkgKyBiYi5wb3NpdGlvbigpLCBiYik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcGFyYW0gU3ViR3JhcGhTZXNzaW9uU3RhdGU9IG9ialxuICAgICAqIEByZXR1cm5zIFN1YkdyYXBoU2Vzc2lvblN0YXRlXG4gICAgICovXG4gICAgc3RhdGljIGdldFNpemVQcmVmaXhlZFJvb3RBc1N1YkdyYXBoU2Vzc2lvblN0YXRlKGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyLCBvYmo/OiBTdWJHcmFwaFNlc3Npb25TdGF0ZSk6XG4gICAgICAgIFN1YkdyYXBoU2Vzc2lvblN0YXRlIHtcbiAgICAgIGJiLnNldFBvc2l0aW9uKGJiLnBvc2l0aW9uKCkgKyBmbGF0YnVmZmVycy5TSVpFX1BSRUZJWF9MRU5HVEgpO1xuICAgICAgcmV0dXJuIChvYmogfHwgbmV3IFN1YkdyYXBoU2Vzc2lvblN0YXRlKCkpLl9faW5pdChiYi5yZWFkSW50MzIoYmIucG9zaXRpb24oKSkgKyBiYi5wb3NpdGlvbigpLCBiYik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkVuY29kaW5nPSBvcHRpb25hbEVuY29kaW5nXG4gICAgICogQHJldHVybnMgc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbFxuICAgICAqL1xuICAgIGdyYXBoSWQoKTogc3RyaW5nfG51bGw7XG4gICAgZ3JhcGhJZChvcHRpb25hbEVuY29kaW5nOiBmbGF0YnVmZmVycy5FbmNvZGluZyk6IHN0cmluZ3xVaW50OEFycmF5fG51bGw7XG4gICAgZ3JhcGhJZChvcHRpb25hbEVuY29kaW5nPzogYW55KTogc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDQpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLl9fc3RyaW5nKHRoaXMuYmJfcG9zICsgb2Zmc2V0LCBvcHRpb25hbEVuY29kaW5nKSA6IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuU2Vzc2lvblN0YXRlPSBvYmpcbiAgICAgKiBAcmV0dXJucyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlNlc3Npb25TdGF0ZXxudWxsXG4gICAgICovXG4gICAgc2Vzc2lvblN0YXRlKG9iaj86IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuU2Vzc2lvblN0YXRlKTogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5TZXNzaW9uU3RhdGV8bnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDYpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IChvYmogfHwgbmV3IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuU2Vzc2lvblN0YXRlKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC5fX2luaXQodGhpcy5iYiEuX19pbmRpcmVjdCh0aGlzLmJiX3BvcyArIG9mZnNldCksIHRoaXMuYmIhKSA6XG4gICAgICAgICAgICAgICAgICAgICAgbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICovXG4gICAgc3RhdGljIHN0YXJ0U3ViR3JhcGhTZXNzaW9uU3RhdGUoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlcikge1xuICAgICAgYnVpbGRlci5zdGFydE9iamVjdCgyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCBncmFwaElkT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZEdyYXBoSWQoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZ3JhcGhJZE9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDAsIGdyYXBoSWRPZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IHNlc3Npb25TdGF0ZU9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRTZXNzaW9uU3RhdGUoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgc2Vzc2lvblN0YXRlT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoMSwgc2Vzc2lvblN0YXRlT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHJldHVybnMgZmxhdGJ1ZmZlcnMuT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGVuZFN1YkdyYXBoU2Vzc2lvblN0YXRlKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIpOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgbGV0IG9mZnNldCA9IGJ1aWxkZXIuZW5kT2JqZWN0KCk7XG4gICAgICBidWlsZGVyLnJlcXVpcmVkRmllbGQob2Zmc2V0LCA0KTsgIC8vIGdyYXBoX2lkXG4gICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH1cblxuICAgIHN0YXRpYyBjcmVhdGVTdWJHcmFwaFNlc3Npb25TdGF0ZShcbiAgICAgICAgYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZ3JhcGhJZE9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0LFxuICAgICAgICBzZXNzaW9uU3RhdGVPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCk6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBTdWJHcmFwaFNlc3Npb25TdGF0ZS5zdGFydFN1YkdyYXBoU2Vzc2lvblN0YXRlKGJ1aWxkZXIpO1xuICAgICAgU3ViR3JhcGhTZXNzaW9uU3RhdGUuYWRkR3JhcGhJZChidWlsZGVyLCBncmFwaElkT2Zmc2V0KTtcbiAgICAgIFN1YkdyYXBoU2Vzc2lvblN0YXRlLmFkZFNlc3Npb25TdGF0ZShidWlsZGVyLCBzZXNzaW9uU3RhdGVPZmZzZXQpO1xuICAgICAgcmV0dXJuIFN1YkdyYXBoU2Vzc2lvblN0YXRlLmVuZFN1YkdyYXBoU2Vzc2lvblN0YXRlKGJ1aWxkZXIpO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZXhwb3J0IG5hbWVzcGFjZSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzIHtcbiAgZXhwb3J0IGNsYXNzIFNlc3Npb25TdGF0ZSB7XG4gICAgYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXJ8bnVsbCA9IG51bGw7XG5cbiAgICBiYl9wb3MgPSAwO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBudW1iZXIgaVxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHJldHVybnMgU2Vzc2lvblN0YXRlXG4gICAgICovXG4gICAgX19pbml0KGk6IG51bWJlciwgYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIpOiBTZXNzaW9uU3RhdGUge1xuICAgICAgdGhpcy5iYl9wb3MgPSBpO1xuICAgICAgdGhpcy5iYiA9IGJiO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcGFyYW0gU2Vzc2lvblN0YXRlPSBvYmpcbiAgICAgKiBAcmV0dXJucyBTZXNzaW9uU3RhdGVcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0Um9vdEFzU2Vzc2lvblN0YXRlKGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyLCBvYmo/OiBTZXNzaW9uU3RhdGUpOiBTZXNzaW9uU3RhdGUge1xuICAgICAgcmV0dXJuIChvYmogfHwgbmV3IFNlc3Npb25TdGF0ZSgpKS5fX2luaXQoYmIucmVhZEludDMyKGJiLnBvc2l0aW9uKCkpICsgYmIucG9zaXRpb24oKSwgYmIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHBhcmFtIFNlc3Npb25TdGF0ZT0gb2JqXG4gICAgICogQHJldHVybnMgU2Vzc2lvblN0YXRlXG4gICAgICovXG4gICAgc3RhdGljIGdldFNpemVQcmVmaXhlZFJvb3RBc1Nlc3Npb25TdGF0ZShiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciwgb2JqPzogU2Vzc2lvblN0YXRlKTogU2Vzc2lvblN0YXRlIHtcbiAgICAgIGJiLnNldFBvc2l0aW9uKGJiLnBvc2l0aW9uKCkgKyBmbGF0YnVmZmVycy5TSVpFX1BSRUZJWF9MRU5HVEgpO1xuICAgICAgcmV0dXJuIChvYmogfHwgbmV3IFNlc3Npb25TdGF0ZSgpKS5fX2luaXQoYmIucmVhZEludDMyKGJiLnBvc2l0aW9uKCkpICsgYmIucG9zaXRpb24oKSwgYmIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLktlcm5lbENyZWF0ZUluZm9zPSBvYmpcbiAgICAgKiBAcmV0dXJucyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLktlcm5lbENyZWF0ZUluZm9zfG51bGxcbiAgICAgKi9cbiAgICBrZXJuZWxzKG9iaj86IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuS2VybmVsQ3JlYXRlSW5mb3MpOiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLktlcm5lbENyZWF0ZUluZm9zfG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA0KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyAob2JqIHx8IG5ldyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLktlcm5lbENyZWF0ZUluZm9zKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC5fX2luaXQodGhpcy5iYiEuX19pbmRpcmVjdCh0aGlzLmJiX3BvcyArIG9mZnNldCksIHRoaXMuYmIhKSA6XG4gICAgICAgICAgICAgICAgICAgICAgbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbnVtYmVyIGluZGV4XG4gICAgICogQHBhcmFtIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuU3ViR3JhcGhTZXNzaW9uU3RhdGU9IG9ialxuICAgICAqIEByZXR1cm5zIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuU3ViR3JhcGhTZXNzaW9uU3RhdGVcbiAgICAgKi9cbiAgICBzdWJHcmFwaFNlc3Npb25TdGF0ZXMoaW5kZXg6IG51bWJlciwgb2JqPzogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5TdWJHcmFwaFNlc3Npb25TdGF0ZSk6XG4gICAgICAgIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuU3ViR3JhcGhTZXNzaW9uU3RhdGV8bnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDYpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IChvYmogfHwgbmV3IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuU3ViR3JhcGhTZXNzaW9uU3RhdGUoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLl9faW5pdCh0aGlzLmJiIS5fX2luZGlyZWN0KHRoaXMuYmIhLl9fdmVjdG9yKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSArIGluZGV4ICogNCksIHRoaXMuYmIhKSA6XG4gICAgICAgICAgICAgICAgICAgICAgbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICAgKi9cbiAgICBzdWJHcmFwaFNlc3Npb25TdGF0ZXNMZW5ndGgoKTogbnVtYmVyIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgNik7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSA6IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqL1xuICAgIHN0YXRpYyBzdGFydFNlc3Npb25TdGF0ZShidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyKSB7XG4gICAgICBidWlsZGVyLnN0YXJ0T2JqZWN0KDIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IGtlcm5lbHNPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkS2VybmVscyhidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBrZXJuZWxzT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoMCwga2VybmVsc09mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgc3ViR3JhcGhTZXNzaW9uU3RhdGVzT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZFN1YkdyYXBoU2Vzc2lvblN0YXRlcyhidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBzdWJHcmFwaFNlc3Npb25TdGF0ZXNPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCgxLCBzdWJHcmFwaFNlc3Npb25TdGF0ZXNPZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gQXJyYXkuPGZsYXRidWZmZXJzLk9mZnNldD4gZGF0YVxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLk9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVTdWJHcmFwaFNlc3Npb25TdGF0ZXNWZWN0b3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZGF0YTogZmxhdGJ1ZmZlcnMuT2Zmc2V0W10pOlxuICAgICAgICBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgYnVpbGRlci5zdGFydFZlY3Rvcig0LCBkYXRhLmxlbmd0aCwgNCk7XG4gICAgICBmb3IgKGxldCBpID0gZGF0YS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBidWlsZGVyLmFkZE9mZnNldChkYXRhW2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBidWlsZGVyLmVuZFZlY3RvcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gbnVtYmVyIG51bUVsZW1zXG4gICAgICovXG4gICAgc3RhdGljIHN0YXJ0U3ViR3JhcGhTZXNzaW9uU3RhdGVzVmVjdG9yKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIG51bUVsZW1zOiBudW1iZXIpIHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRWZWN0b3IoNCwgbnVtRWxlbXMsIDQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcmV0dXJucyBmbGF0YnVmZmVycy5PZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgZW5kU2Vzc2lvblN0YXRlKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIpOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgbGV0IG9mZnNldCA9IGJ1aWxkZXIuZW5kT2JqZWN0KCk7XG4gICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH1cblxuICAgIHN0YXRpYyBjcmVhdGVTZXNzaW9uU3RhdGUoXG4gICAgICAgIGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGtlcm5lbHNPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCxcbiAgICAgICAgc3ViR3JhcGhTZXNzaW9uU3RhdGVzT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgU2Vzc2lvblN0YXRlLnN0YXJ0U2Vzc2lvblN0YXRlKGJ1aWxkZXIpO1xuICAgICAgU2Vzc2lvblN0YXRlLmFkZEtlcm5lbHMoYnVpbGRlciwga2VybmVsc09mZnNldCk7XG4gICAgICBTZXNzaW9uU3RhdGUuYWRkU3ViR3JhcGhTZXNzaW9uU3RhdGVzKGJ1aWxkZXIsIHN1YkdyYXBoU2Vzc2lvblN0YXRlc09mZnNldCk7XG4gICAgICByZXR1cm4gU2Vzc2lvblN0YXRlLmVuZFNlc3Npb25TdGF0ZShidWlsZGVyKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmV4cG9ydCBuYW1lc3BhY2Ugb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicyB7XG4gIGV4cG9ydCBjbGFzcyBJbmZlcmVuY2VTZXNzaW9uIHtcbiAgICBiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlcnxudWxsID0gbnVsbDtcblxuICAgIGJiX3BvcyA9IDA7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIG51bWJlciBpXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcmV0dXJucyBJbmZlcmVuY2VTZXNzaW9uXG4gICAgICovXG4gICAgX19pbml0KGk6IG51bWJlciwgYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIpOiBJbmZlcmVuY2VTZXNzaW9uIHtcbiAgICAgIHRoaXMuYmJfcG9zID0gaTtcbiAgICAgIHRoaXMuYmIgPSBiYjtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHBhcmFtIEluZmVyZW5jZVNlc3Npb249IG9ialxuICAgICAqIEByZXR1cm5zIEluZmVyZW5jZVNlc3Npb25cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0Um9vdEFzSW5mZXJlbmNlU2Vzc2lvbihiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciwgb2JqPzogSW5mZXJlbmNlU2Vzc2lvbik6IEluZmVyZW5jZVNlc3Npb24ge1xuICAgICAgcmV0dXJuIChvYmogfHwgbmV3IEluZmVyZW5jZVNlc3Npb24oKSkuX19pbml0KGJiLnJlYWRJbnQzMihiYi5wb3NpdGlvbigpKSArIGJiLnBvc2l0aW9uKCksIGJiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEBwYXJhbSBJbmZlcmVuY2VTZXNzaW9uPSBvYmpcbiAgICAgKiBAcmV0dXJucyBJbmZlcmVuY2VTZXNzaW9uXG4gICAgICovXG4gICAgc3RhdGljIGdldFNpemVQcmVmaXhlZFJvb3RBc0luZmVyZW5jZVNlc3Npb24oYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIsIG9iaj86IEluZmVyZW5jZVNlc3Npb24pOiBJbmZlcmVuY2VTZXNzaW9uIHtcbiAgICAgIGJiLnNldFBvc2l0aW9uKGJiLnBvc2l0aW9uKCkgKyBmbGF0YnVmZmVycy5TSVpFX1BSRUZJWF9MRU5HVEgpO1xuICAgICAgcmV0dXJuIChvYmogfHwgbmV3IEluZmVyZW5jZVNlc3Npb24oKSkuX19pbml0KGJiLnJlYWRJbnQzMihiYi5wb3NpdGlvbigpKSArIGJiLnBvc2l0aW9uKCksIGJiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEByZXR1cm5zIGJvb2xlYW5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnVmZmVySGFzSWRlbnRpZmllcihiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlcik6IGJvb2xlYW4ge1xuICAgICAgcmV0dXJuIGJiLl9faGFzX2lkZW50aWZpZXIoJ09SVE0nKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuRW5jb2Rpbmc9IG9wdGlvbmFsRW5jb2RpbmdcbiAgICAgKiBAcmV0dXJucyBzdHJpbmd8VWludDhBcnJheXxudWxsXG4gICAgICovXG4gICAgb3J0VmVyc2lvbigpOiBzdHJpbmd8bnVsbDtcbiAgICBvcnRWZXJzaW9uKG9wdGlvbmFsRW5jb2Rpbmc6IGZsYXRidWZmZXJzLkVuY29kaW5nKTogc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbDtcbiAgICBvcnRWZXJzaW9uKG9wdGlvbmFsRW5jb2Rpbmc/OiBhbnkpOiBzdHJpbmd8VWludDhBcnJheXxudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgNCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEuX19zdHJpbmcodGhpcy5iYl9wb3MgKyBvZmZzZXQsIG9wdGlvbmFsRW5jb2RpbmcpIDogbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5Nb2RlbD0gb2JqXG4gICAgICogQHJldHVybnMgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5Nb2RlbHxudWxsXG4gICAgICovXG4gICAgbW9kZWwob2JqPzogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5Nb2RlbCk6IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuTW9kZWx8bnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDYpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IChvYmogfHwgbmV3IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuTW9kZWwoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLl9faW5pdCh0aGlzLmJiIS5fX2luZGlyZWN0KHRoaXMuYmJfcG9zICsgb2Zmc2V0KSwgdGhpcy5iYiEpIDpcbiAgICAgICAgICAgICAgICAgICAgICBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlNlc3Npb25TdGF0ZT0gb2JqXG4gICAgICogQHJldHVybnMgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5TZXNzaW9uU3RhdGV8bnVsbFxuICAgICAqL1xuICAgIHNlc3Npb25TdGF0ZShvYmo/OiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlNlc3Npb25TdGF0ZSk6IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuU2Vzc2lvblN0YXRlfG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA4KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyAob2JqIHx8IG5ldyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlNlc3Npb25TdGF0ZSgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAuX19pbml0KHRoaXMuYmIhLl9faW5kaXJlY3QodGhpcy5iYl9wb3MgKyBvZmZzZXQpLCB0aGlzLmJiISkgOlxuICAgICAgICAgICAgICAgICAgICAgIG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqL1xuICAgIHN0YXRpYyBzdGFydEluZmVyZW5jZVNlc3Npb24oYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlcikge1xuICAgICAgYnVpbGRlci5zdGFydE9iamVjdCgzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCBvcnRWZXJzaW9uT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZE9ydFZlcnNpb24oYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgb3J0VmVyc2lvbk9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDAsIG9ydFZlcnNpb25PZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IG1vZGVsT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZE1vZGVsKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIG1vZGVsT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoMSwgbW9kZWxPZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IHNlc3Npb25TdGF0ZU9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRTZXNzaW9uU3RhdGUoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgc2Vzc2lvblN0YXRlT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoMiwgc2Vzc2lvblN0YXRlT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHJldHVybnMgZmxhdGJ1ZmZlcnMuT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGVuZEluZmVyZW5jZVNlc3Npb24oYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlcik6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gYnVpbGRlci5lbmRPYmplY3QoKTtcbiAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgb2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGZpbmlzaEluZmVyZW5jZVNlc3Npb25CdWZmZXIoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgb2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuZmluaXNoKG9mZnNldCwgJ09SVE0nKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCBvZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgZmluaXNoU2l6ZVByZWZpeGVkSW5mZXJlbmNlU2Vzc2lvbkJ1ZmZlcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBvZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5maW5pc2gob2Zmc2V0LCAnT1JUTScsIHRydWUpO1xuICAgIH1cblxuICAgIHN0YXRpYyBjcmVhdGVJbmZlcmVuY2VTZXNzaW9uKFxuICAgICAgICBidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBvcnRWZXJzaW9uT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQsIG1vZGVsT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQsXG4gICAgICAgIHNlc3Npb25TdGF0ZU9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIEluZmVyZW5jZVNlc3Npb24uc3RhcnRJbmZlcmVuY2VTZXNzaW9uKGJ1aWxkZXIpO1xuICAgICAgSW5mZXJlbmNlU2Vzc2lvbi5hZGRPcnRWZXJzaW9uKGJ1aWxkZXIsIG9ydFZlcnNpb25PZmZzZXQpO1xuICAgICAgSW5mZXJlbmNlU2Vzc2lvbi5hZGRNb2RlbChidWlsZGVyLCBtb2RlbE9mZnNldCk7XG4gICAgICBJbmZlcmVuY2VTZXNzaW9uLmFkZFNlc3Npb25TdGF0ZShidWlsZGVyLCBzZXNzaW9uU3RhdGVPZmZzZXQpO1xuICAgICAgcmV0dXJuIEluZmVyZW5jZVNlc3Npb24uZW5kSW5mZXJlbmNlU2Vzc2lvbihidWlsZGVyKTtcbiAgICB9XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcclxubW9kdWxlLmV4cG9ydHMgPSBhc1Byb21pc2U7XHJcblxyXG4vKipcclxuICogQ2FsbGJhY2sgYXMgdXNlZCBieSB7QGxpbmsgdXRpbC5hc1Byb21pc2V9LlxyXG4gKiBAdHlwZWRlZiBhc1Byb21pc2VDYWxsYmFja1xyXG4gKiBAdHlwZSB7ZnVuY3Rpb259XHJcbiAqIEBwYXJhbSB7RXJyb3J8bnVsbH0gZXJyb3IgRXJyb3IsIGlmIGFueVxyXG4gKiBAcGFyYW0gey4uLip9IHBhcmFtcyBBZGRpdGlvbmFsIGFyZ3VtZW50c1xyXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgcHJvbWlzZSBmcm9tIGEgbm9kZS1zdHlsZSBjYWxsYmFjayBmdW5jdGlvbi5cclxuICogQG1lbWJlcm9mIHV0aWxcclxuICogQHBhcmFtIHthc1Byb21pc2VDYWxsYmFja30gZm4gRnVuY3Rpb24gdG8gY2FsbFxyXG4gKiBAcGFyYW0geyp9IGN0eCBGdW5jdGlvbiBjb250ZXh0XHJcbiAqIEBwYXJhbSB7Li4uKn0gcGFyYW1zIEZ1bmN0aW9uIGFyZ3VtZW50c1xyXG4gKiBAcmV0dXJucyB7UHJvbWlzZTwqPn0gUHJvbWlzaWZpZWQgZnVuY3Rpb25cclxuICovXHJcbmZ1bmN0aW9uIGFzUHJvbWlzZShmbiwgY3R4LyosIHZhcmFyZ3MgKi8pIHtcclxuICAgIHZhciBwYXJhbXMgID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKSxcclxuICAgICAgICBvZmZzZXQgID0gMCxcclxuICAgICAgICBpbmRleCAgID0gMixcclxuICAgICAgICBwZW5kaW5nID0gdHJ1ZTtcclxuICAgIHdoaWxlIChpbmRleCA8IGFyZ3VtZW50cy5sZW5ndGgpXHJcbiAgICAgICAgcGFyYW1zW29mZnNldCsrXSA9IGFyZ3VtZW50c1tpbmRleCsrXTtcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiBleGVjdXRvcihyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBwYXJhbXNbb2Zmc2V0XSA9IGZ1bmN0aW9uIGNhbGxiYWNrKGVyci8qLCB2YXJhcmdzICovKSB7XHJcbiAgICAgICAgICAgIGlmIChwZW5kaW5nKSB7XHJcbiAgICAgICAgICAgICAgICBwZW5kaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXJyKVxyXG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmFtcyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKG9mZnNldCA8IHBhcmFtcy5sZW5ndGgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtc1tvZmZzZXQrK10gPSBhcmd1bWVudHNbb2Zmc2V0XTtcclxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlLmFwcGx5KG51bGwsIHBhcmFtcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGZuLmFwcGx5KGN0eCB8fCBudWxsLCBwYXJhbXMpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICBpZiAocGVuZGluZykge1xyXG4gICAgICAgICAgICAgICAgcGVuZGluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufVxyXG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4vKipcclxuICogQSBtaW5pbWFsIGJhc2U2NCBpbXBsZW1lbnRhdGlvbiBmb3IgbnVtYmVyIGFycmF5cy5cclxuICogQG1lbWJlcm9mIHV0aWxcclxuICogQG5hbWVzcGFjZVxyXG4gKi9cclxudmFyIGJhc2U2NCA9IGV4cG9ydHM7XHJcblxyXG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgYnl0ZSBsZW5ndGggb2YgYSBiYXNlNjQgZW5jb2RlZCBzdHJpbmcuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgQmFzZTY0IGVuY29kZWQgc3RyaW5nXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IEJ5dGUgbGVuZ3RoXHJcbiAqL1xyXG5iYXNlNjQubGVuZ3RoID0gZnVuY3Rpb24gbGVuZ3RoKHN0cmluZykge1xyXG4gICAgdmFyIHAgPSBzdHJpbmcubGVuZ3RoO1xyXG4gICAgaWYgKCFwKVxyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgdmFyIG4gPSAwO1xyXG4gICAgd2hpbGUgKC0tcCAlIDQgPiAxICYmIHN0cmluZy5jaGFyQXQocCkgPT09IFwiPVwiKVxyXG4gICAgICAgICsrbjtcclxuICAgIHJldHVybiBNYXRoLmNlaWwoc3RyaW5nLmxlbmd0aCAqIDMpIC8gNCAtIG47XHJcbn07XHJcblxyXG4vLyBCYXNlNjQgZW5jb2RpbmcgdGFibGVcclxudmFyIGI2NCA9IG5ldyBBcnJheSg2NCk7XHJcblxyXG4vLyBCYXNlNjQgZGVjb2RpbmcgdGFibGVcclxudmFyIHM2NCA9IG5ldyBBcnJheSgxMjMpO1xyXG5cclxuLy8gNjUuLjkwLCA5Ny4uMTIyLCA0OC4uNTcsIDQzLCA0N1xyXG5mb3IgKHZhciBpID0gMDsgaSA8IDY0OylcclxuICAgIHM2NFtiNjRbaV0gPSBpIDwgMjYgPyBpICsgNjUgOiBpIDwgNTIgPyBpICsgNzEgOiBpIDwgNjIgPyBpIC0gNCA6IGkgLSA1OSB8IDQzXSA9IGkrKztcclxuXHJcbi8qKlxyXG4gKiBFbmNvZGVzIGEgYnVmZmVyIHRvIGEgYmFzZTY0IGVuY29kZWQgc3RyaW5nLlxyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZmZlciBTb3VyY2UgYnVmZmVyXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBTb3VyY2Ugc3RhcnRcclxuICogQHBhcmFtIHtudW1iZXJ9IGVuZCBTb3VyY2UgZW5kXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9IEJhc2U2NCBlbmNvZGVkIHN0cmluZ1xyXG4gKi9cclxuYmFzZTY0LmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShidWZmZXIsIHN0YXJ0LCBlbmQpIHtcclxuICAgIHZhciBwYXJ0cyA9IG51bGwsXHJcbiAgICAgICAgY2h1bmsgPSBbXTtcclxuICAgIHZhciBpID0gMCwgLy8gb3V0cHV0IGluZGV4XHJcbiAgICAgICAgaiA9IDAsIC8vIGdvdG8gaW5kZXhcclxuICAgICAgICB0OyAgICAgLy8gdGVtcG9yYXJ5XHJcbiAgICB3aGlsZSAoc3RhcnQgPCBlbmQpIHtcclxuICAgICAgICB2YXIgYiA9IGJ1ZmZlcltzdGFydCsrXTtcclxuICAgICAgICBzd2l0Y2ggKGopIHtcclxuICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgY2h1bmtbaSsrXSA9IGI2NFtiID4+IDJdO1xyXG4gICAgICAgICAgICAgICAgdCA9IChiICYgMykgPDwgNDtcclxuICAgICAgICAgICAgICAgIGogPSAxO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgIGNodW5rW2krK10gPSBiNjRbdCB8IGIgPj4gNF07XHJcbiAgICAgICAgICAgICAgICB0ID0gKGIgJiAxNSkgPDwgMjtcclxuICAgICAgICAgICAgICAgIGogPSAyO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgIGNodW5rW2krK10gPSBiNjRbdCB8IGIgPj4gNl07XHJcbiAgICAgICAgICAgICAgICBjaHVua1tpKytdID0gYjY0W2IgJiA2M107XHJcbiAgICAgICAgICAgICAgICBqID0gMDtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaSA+IDgxOTEpIHtcclxuICAgICAgICAgICAgKHBhcnRzIHx8IChwYXJ0cyA9IFtdKSkucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY2h1bmspKTtcclxuICAgICAgICAgICAgaSA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGopIHtcclxuICAgICAgICBjaHVua1tpKytdID0gYjY0W3RdO1xyXG4gICAgICAgIGNodW5rW2krK10gPSA2MTtcclxuICAgICAgICBpZiAoaiA9PT0gMSlcclxuICAgICAgICAgICAgY2h1bmtbaSsrXSA9IDYxO1xyXG4gICAgfVxyXG4gICAgaWYgKHBhcnRzKSB7XHJcbiAgICAgICAgaWYgKGkpXHJcbiAgICAgICAgICAgIHBhcnRzLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNodW5rLnNsaWNlKDAsIGkpKSk7XHJcbiAgICAgICAgcmV0dXJuIHBhcnRzLmpvaW4oXCJcIik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNodW5rLnNsaWNlKDAsIGkpKTtcclxufTtcclxuXHJcbnZhciBpbnZhbGlkRW5jb2RpbmcgPSBcImludmFsaWQgZW5jb2RpbmdcIjtcclxuXHJcbi8qKlxyXG4gKiBEZWNvZGVzIGEgYmFzZTY0IGVuY29kZWQgc3RyaW5nIHRvIGEgYnVmZmVyLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFNvdXJjZSBzdHJpbmdcclxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWZmZXIgRGVzdGluYXRpb24gYnVmZmVyXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgRGVzdGluYXRpb24gb2Zmc2V0XHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IE51bWJlciBvZiBieXRlcyB3cml0dGVuXHJcbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBlbmNvZGluZyBpcyBpbnZhbGlkXHJcbiAqL1xyXG5iYXNlNjQuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHN0cmluZywgYnVmZmVyLCBvZmZzZXQpIHtcclxuICAgIHZhciBzdGFydCA9IG9mZnNldDtcclxuICAgIHZhciBqID0gMCwgLy8gZ290byBpbmRleFxyXG4gICAgICAgIHQ7ICAgICAvLyB0ZW1wb3JhcnlcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyaW5nLmxlbmd0aDspIHtcclxuICAgICAgICB2YXIgYyA9IHN0cmluZy5jaGFyQ29kZUF0KGkrKyk7XHJcbiAgICAgICAgaWYgKGMgPT09IDYxICYmIGogPiAxKVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBpZiAoKGMgPSBzNjRbY10pID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgIHRocm93IEVycm9yKGludmFsaWRFbmNvZGluZyk7XHJcbiAgICAgICAgc3dpdGNoIChqKSB7XHJcbiAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgIHQgPSBjO1xyXG4gICAgICAgICAgICAgICAgaiA9IDE7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9IHQgPDwgMiB8IChjICYgNDgpID4+IDQ7XHJcbiAgICAgICAgICAgICAgICB0ID0gYztcclxuICAgICAgICAgICAgICAgIGogPSAyO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQrK10gPSAodCAmIDE1KSA8PCA0IHwgKGMgJiA2MCkgPj4gMjtcclxuICAgICAgICAgICAgICAgIHQgPSBjO1xyXG4gICAgICAgICAgICAgICAgaiA9IDM7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9ICh0ICYgMykgPDwgNiB8IGM7XHJcbiAgICAgICAgICAgICAgICBqID0gMDtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChqID09PSAxKVxyXG4gICAgICAgIHRocm93IEVycm9yKGludmFsaWRFbmNvZGluZyk7XHJcbiAgICByZXR1cm4gb2Zmc2V0IC0gc3RhcnQ7XHJcbn07XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhlIHNwZWNpZmllZCBzdHJpbmcgYXBwZWFycyB0byBiZSBiYXNlNjQgZW5jb2RlZC5cclxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBTdHJpbmcgdG8gdGVzdFxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHByb2JhYmx5IGJhc2U2NCBlbmNvZGVkLCBvdGhlcndpc2UgZmFsc2VcclxuICovXHJcbmJhc2U2NC50ZXN0ID0gZnVuY3Rpb24gdGVzdChzdHJpbmcpIHtcclxuICAgIHJldHVybiAvXig/OltBLVphLXowLTkrL117NH0pKig/OltBLVphLXowLTkrL117Mn09PXxbQS1aYS16MC05Ky9dezN9PSk/JC8udGVzdChzdHJpbmcpO1xyXG59O1xyXG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XHJcbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xyXG5cclxuLyoqXHJcbiAqIENvbnN0cnVjdHMgYSBuZXcgZXZlbnQgZW1pdHRlciBpbnN0YW5jZS5cclxuICogQGNsYXNzZGVzYyBBIG1pbmltYWwgZXZlbnQgZW1pdHRlci5cclxuICogQG1lbWJlcm9mIHV0aWxcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWdpc3RlcmVkIGxpc3RlbmVycy5cclxuICAgICAqIEB0eXBlIHtPYmplY3QuPHN0cmluZywqPn1cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHRoaXMuX2xpc3RlbmVycyA9IHt9O1xyXG59XHJcblxyXG4vKipcclxuICogUmVnaXN0ZXJzIGFuIGV2ZW50IGxpc3RlbmVyLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZ0IEV2ZW50IG5hbWVcclxuICogQHBhcmFtIHtmdW5jdGlvbn0gZm4gTGlzdGVuZXJcclxuICogQHBhcmFtIHsqfSBbY3R4XSBMaXN0ZW5lciBjb250ZXh0XHJcbiAqIEByZXR1cm5zIHt1dGlsLkV2ZW50RW1pdHRlcn0gYHRoaXNgXHJcbiAqL1xyXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gb24oZXZ0LCBmbiwgY3R4KSB7XHJcbiAgICAodGhpcy5fbGlzdGVuZXJzW2V2dF0gfHwgKHRoaXMuX2xpc3RlbmVyc1tldnRdID0gW10pKS5wdXNoKHtcclxuICAgICAgICBmbiAgOiBmbixcclxuICAgICAgICBjdHggOiBjdHggfHwgdGhpc1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZW1vdmVzIGFuIGV2ZW50IGxpc3RlbmVyIG9yIGFueSBtYXRjaGluZyBsaXN0ZW5lcnMgaWYgYXJndW1lbnRzIGFyZSBvbWl0dGVkLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gW2V2dF0gRXZlbnQgbmFtZS4gUmVtb3ZlcyBhbGwgbGlzdGVuZXJzIGlmIG9taXR0ZWQuXHJcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFtmbl0gTGlzdGVuZXIgdG8gcmVtb3ZlLiBSZW1vdmVzIGFsbCBsaXN0ZW5lcnMgb2YgYGV2dGAgaWYgb21pdHRlZC5cclxuICogQHJldHVybnMge3V0aWwuRXZlbnRFbWl0dGVyfSBgdGhpc2BcclxuICovXHJcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24gb2ZmKGV2dCwgZm4pIHtcclxuICAgIGlmIChldnQgPT09IHVuZGVmaW5lZClcclxuICAgICAgICB0aGlzLl9saXN0ZW5lcnMgPSB7fTtcclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGlmIChmbiA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICB0aGlzLl9saXN0ZW5lcnNbZXZ0XSA9IFtdO1xyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzW2V2dF07XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDspXHJcbiAgICAgICAgICAgICAgICBpZiAobGlzdGVuZXJzW2ldLmZuID09PSBmbilcclxuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnMuc3BsaWNlKGksIDEpO1xyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICsraTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBFbWl0cyBhbiBldmVudCBieSBjYWxsaW5nIGl0cyBsaXN0ZW5lcnMgd2l0aCB0aGUgc3BlY2lmaWVkIGFyZ3VtZW50cy5cclxuICogQHBhcmFtIHtzdHJpbmd9IGV2dCBFdmVudCBuYW1lXHJcbiAqIEBwYXJhbSB7Li4uKn0gYXJncyBBcmd1bWVudHNcclxuICogQHJldHVybnMge3V0aWwuRXZlbnRFbWl0dGVyfSBgdGhpc2BcclxuICovXHJcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIGVtaXQoZXZ0KSB7XHJcbiAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzW2V2dF07XHJcbiAgICBpZiAobGlzdGVuZXJzKSB7XHJcbiAgICAgICAgdmFyIGFyZ3MgPSBbXSxcclxuICAgICAgICAgICAgaSA9IDE7XHJcbiAgICAgICAgZm9yICg7IGkgPCBhcmd1bWVudHMubGVuZ3RoOylcclxuICAgICAgICAgICAgYXJncy5wdXNoKGFyZ3VtZW50c1tpKytdKTtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDspXHJcbiAgICAgICAgICAgIGxpc3RlbmVyc1tpXS5mbi5hcHBseShsaXN0ZW5lcnNbaSsrXS5jdHgsIGFyZ3MpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcbiIsICJcInVzZSBzdHJpY3RcIjtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShmYWN0b3J5KTtcclxuXHJcbi8qKlxyXG4gKiBSZWFkcyAvIHdyaXRlcyBmbG9hdHMgLyBkb3VibGVzIGZyb20gLyB0byBidWZmZXJzLlxyXG4gKiBAbmFtZSB1dGlsLmZsb2F0XHJcbiAqIEBuYW1lc3BhY2VcclxuICovXHJcblxyXG4vKipcclxuICogV3JpdGVzIGEgMzIgYml0IGZsb2F0IHRvIGEgYnVmZmVyIHVzaW5nIGxpdHRsZSBlbmRpYW4gYnl0ZSBvcmRlci5cclxuICogQG5hbWUgdXRpbC5mbG9hdC53cml0ZUZsb2F0TEVcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWwgVmFsdWUgdG8gd3JpdGVcclxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWYgVGFyZ2V0IGJ1ZmZlclxyXG4gKiBAcGFyYW0ge251bWJlcn0gcG9zIFRhcmdldCBidWZmZXIgb2Zmc2V0XHJcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFdyaXRlcyBhIDMyIGJpdCBmbG9hdCB0byBhIGJ1ZmZlciB1c2luZyBiaWcgZW5kaWFuIGJ5dGUgb3JkZXIuXHJcbiAqIEBuYW1lIHV0aWwuZmxvYXQud3JpdGVGbG9hdEJFXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsIFZhbHVlIHRvIHdyaXRlXHJcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmIFRhcmdldCBidWZmZXJcclxuICogQHBhcmFtIHtudW1iZXJ9IHBvcyBUYXJnZXQgYnVmZmVyIG9mZnNldFxyXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBSZWFkcyBhIDMyIGJpdCBmbG9hdCBmcm9tIGEgYnVmZmVyIHVzaW5nIGxpdHRsZSBlbmRpYW4gYnl0ZSBvcmRlci5cclxuICogQG5hbWUgdXRpbC5mbG9hdC5yZWFkRmxvYXRMRVxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWYgU291cmNlIGJ1ZmZlclxyXG4gKiBAcGFyYW0ge251bWJlcn0gcG9zIFNvdXJjZSBidWZmZXIgb2Zmc2V0XHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcclxuICovXHJcblxyXG4vKipcclxuICogUmVhZHMgYSAzMiBiaXQgZmxvYXQgZnJvbSBhIGJ1ZmZlciB1c2luZyBiaWcgZW5kaWFuIGJ5dGUgb3JkZXIuXHJcbiAqIEBuYW1lIHV0aWwuZmxvYXQucmVhZEZsb2F0QkVcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmIFNvdXJjZSBidWZmZXJcclxuICogQHBhcmFtIHtudW1iZXJ9IHBvcyBTb3VyY2UgYnVmZmVyIG9mZnNldFxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFdyaXRlcyBhIDY0IGJpdCBkb3VibGUgdG8gYSBidWZmZXIgdXNpbmcgbGl0dGxlIGVuZGlhbiBieXRlIG9yZGVyLlxyXG4gKiBAbmFtZSB1dGlsLmZsb2F0LndyaXRlRG91YmxlTEVcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWwgVmFsdWUgdG8gd3JpdGVcclxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWYgVGFyZ2V0IGJ1ZmZlclxyXG4gKiBAcGFyYW0ge251bWJlcn0gcG9zIFRhcmdldCBidWZmZXIgb2Zmc2V0XHJcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFdyaXRlcyBhIDY0IGJpdCBkb3VibGUgdG8gYSBidWZmZXIgdXNpbmcgYmlnIGVuZGlhbiBieXRlIG9yZGVyLlxyXG4gKiBAbmFtZSB1dGlsLmZsb2F0LndyaXRlRG91YmxlQkVcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWwgVmFsdWUgdG8gd3JpdGVcclxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWYgVGFyZ2V0IGJ1ZmZlclxyXG4gKiBAcGFyYW0ge251bWJlcn0gcG9zIFRhcmdldCBidWZmZXIgb2Zmc2V0XHJcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFJlYWRzIGEgNjQgYml0IGRvdWJsZSBmcm9tIGEgYnVmZmVyIHVzaW5nIGxpdHRsZSBlbmRpYW4gYnl0ZSBvcmRlci5cclxuICogQG5hbWUgdXRpbC5mbG9hdC5yZWFkRG91YmxlTEVcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmIFNvdXJjZSBidWZmZXJcclxuICogQHBhcmFtIHtudW1iZXJ9IHBvcyBTb3VyY2UgYnVmZmVyIG9mZnNldFxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFJlYWRzIGEgNjQgYml0IGRvdWJsZSBmcm9tIGEgYnVmZmVyIHVzaW5nIGJpZyBlbmRpYW4gYnl0ZSBvcmRlci5cclxuICogQG5hbWUgdXRpbC5mbG9hdC5yZWFkRG91YmxlQkVcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmIFNvdXJjZSBidWZmZXJcclxuICogQHBhcmFtIHtudW1iZXJ9IHBvcyBTb3VyY2UgYnVmZmVyIG9mZnNldFxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXHJcbiAqL1xyXG5cclxuLy8gRmFjdG9yeSBmdW5jdGlvbiBmb3IgdGhlIHB1cnBvc2Ugb2Ygbm9kZS1iYXNlZCB0ZXN0aW5nIGluIG1vZGlmaWVkIGdsb2JhbCBlbnZpcm9ubWVudHNcclxuZnVuY3Rpb24gZmFjdG9yeShleHBvcnRzKSB7XHJcblxyXG4gICAgLy8gZmxvYXQ6IHR5cGVkIGFycmF5XHJcbiAgICBpZiAodHlwZW9mIEZsb2F0MzJBcnJheSAhPT0gXCJ1bmRlZmluZWRcIikgKGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgICB2YXIgZjMyID0gbmV3IEZsb2F0MzJBcnJheShbIC0wIF0pLFxyXG4gICAgICAgICAgICBmOGIgPSBuZXcgVWludDhBcnJheShmMzIuYnVmZmVyKSxcclxuICAgICAgICAgICAgbGUgID0gZjhiWzNdID09PSAxMjg7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHdyaXRlRmxvYXRfZjMyX2NweSh2YWwsIGJ1ZiwgcG9zKSB7XHJcbiAgICAgICAgICAgIGYzMlswXSA9IHZhbDtcclxuICAgICAgICAgICAgYnVmW3BvcyAgICBdID0gZjhiWzBdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgMV0gPSBmOGJbMV07XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyAyXSA9IGY4YlsyXTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDNdID0gZjhiWzNdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gd3JpdGVGbG9hdF9mMzJfcmV2KHZhbCwgYnVmLCBwb3MpIHtcclxuICAgICAgICAgICAgZjMyWzBdID0gdmFsO1xyXG4gICAgICAgICAgICBidWZbcG9zICAgIF0gPSBmOGJbM107XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyAxXSA9IGY4YlsyXTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDJdID0gZjhiWzFdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgM10gPSBmOGJbMF07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICAgIGV4cG9ydHMud3JpdGVGbG9hdExFID0gbGUgPyB3cml0ZUZsb2F0X2YzMl9jcHkgOiB3cml0ZUZsb2F0X2YzMl9yZXY7XHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgICAgICBleHBvcnRzLndyaXRlRmxvYXRCRSA9IGxlID8gd3JpdGVGbG9hdF9mMzJfcmV2IDogd3JpdGVGbG9hdF9mMzJfY3B5O1xyXG5cclxuICAgICAgICBmdW5jdGlvbiByZWFkRmxvYXRfZjMyX2NweShidWYsIHBvcykge1xyXG4gICAgICAgICAgICBmOGJbMF0gPSBidWZbcG9zICAgIF07XHJcbiAgICAgICAgICAgIGY4YlsxXSA9IGJ1Zltwb3MgKyAxXTtcclxuICAgICAgICAgICAgZjhiWzJdID0gYnVmW3BvcyArIDJdO1xyXG4gICAgICAgICAgICBmOGJbM10gPSBidWZbcG9zICsgM107XHJcbiAgICAgICAgICAgIHJldHVybiBmMzJbMF07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiByZWFkRmxvYXRfZjMyX3JldihidWYsIHBvcykge1xyXG4gICAgICAgICAgICBmOGJbM10gPSBidWZbcG9zICAgIF07XHJcbiAgICAgICAgICAgIGY4YlsyXSA9IGJ1Zltwb3MgKyAxXTtcclxuICAgICAgICAgICAgZjhiWzFdID0gYnVmW3BvcyArIDJdO1xyXG4gICAgICAgICAgICBmOGJbMF0gPSBidWZbcG9zICsgM107XHJcbiAgICAgICAgICAgIHJldHVybiBmMzJbMF07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICAgIGV4cG9ydHMucmVhZEZsb2F0TEUgPSBsZSA/IHJlYWRGbG9hdF9mMzJfY3B5IDogcmVhZEZsb2F0X2YzMl9yZXY7XHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgICAgICBleHBvcnRzLnJlYWRGbG9hdEJFID0gbGUgPyByZWFkRmxvYXRfZjMyX3JldiA6IHJlYWRGbG9hdF9mMzJfY3B5O1xyXG5cclxuICAgIC8vIGZsb2F0OiBpZWVlNzU0XHJcbiAgICB9KSgpOyBlbHNlIChmdW5jdGlvbigpIHtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gd3JpdGVGbG9hdF9pZWVlNzU0KHdyaXRlVWludCwgdmFsLCBidWYsIHBvcykge1xyXG4gICAgICAgICAgICB2YXIgc2lnbiA9IHZhbCA8IDAgPyAxIDogMDtcclxuICAgICAgICAgICAgaWYgKHNpZ24pXHJcbiAgICAgICAgICAgICAgICB2YWwgPSAtdmFsO1xyXG4gICAgICAgICAgICBpZiAodmFsID09PSAwKVxyXG4gICAgICAgICAgICAgICAgd3JpdGVVaW50KDEgLyB2YWwgPiAwID8gLyogcG9zaXRpdmUgKi8gMCA6IC8qIG5lZ2F0aXZlIDAgKi8gMjE0NzQ4MzY0OCwgYnVmLCBwb3MpO1xyXG4gICAgICAgICAgICBlbHNlIGlmIChpc05hTih2YWwpKVxyXG4gICAgICAgICAgICAgICAgd3JpdGVVaW50KDIxNDMyODkzNDQsIGJ1ZiwgcG9zKTtcclxuICAgICAgICAgICAgZWxzZSBpZiAodmFsID4gMy40MDI4MjM0NjYzODUyODg2ZSszOCkgLy8gKy1JbmZpbml0eVxyXG4gICAgICAgICAgICAgICAgd3JpdGVVaW50KChzaWduIDw8IDMxIHwgMjEzOTA5NTA0MCkgPj4+IDAsIGJ1ZiwgcG9zKTtcclxuICAgICAgICAgICAgZWxzZSBpZiAodmFsIDwgMS4xNzU0OTQzNTA4MjIyODc1ZS0zOCkgLy8gZGVub3JtYWxcclxuICAgICAgICAgICAgICAgIHdyaXRlVWludCgoc2lnbiA8PCAzMSB8IE1hdGgucm91bmQodmFsIC8gMS40MDEyOTg0NjQzMjQ4MTdlLTQ1KSkgPj4+IDAsIGJ1ZiwgcG9zKTtcclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZXhwb25lbnQgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbCkgLyBNYXRoLkxOMiksXHJcbiAgICAgICAgICAgICAgICAgICAgbWFudGlzc2EgPSBNYXRoLnJvdW5kKHZhbCAqIE1hdGgucG93KDIsIC1leHBvbmVudCkgKiA4Mzg4NjA4KSAmIDgzODg2MDc7XHJcbiAgICAgICAgICAgICAgICB3cml0ZVVpbnQoKHNpZ24gPDwgMzEgfCBleHBvbmVudCArIDEyNyA8PCAyMyB8IG1hbnRpc3NhKSA+Pj4gMCwgYnVmLCBwb3MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBleHBvcnRzLndyaXRlRmxvYXRMRSA9IHdyaXRlRmxvYXRfaWVlZTc1NC5iaW5kKG51bGwsIHdyaXRlVWludExFKTtcclxuICAgICAgICBleHBvcnRzLndyaXRlRmxvYXRCRSA9IHdyaXRlRmxvYXRfaWVlZTc1NC5iaW5kKG51bGwsIHdyaXRlVWludEJFKTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gcmVhZEZsb2F0X2llZWU3NTQocmVhZFVpbnQsIGJ1ZiwgcG9zKSB7XHJcbiAgICAgICAgICAgIHZhciB1aW50ID0gcmVhZFVpbnQoYnVmLCBwb3MpLFxyXG4gICAgICAgICAgICAgICAgc2lnbiA9ICh1aW50ID4+IDMxKSAqIDIgKyAxLFxyXG4gICAgICAgICAgICAgICAgZXhwb25lbnQgPSB1aW50ID4+PiAyMyAmIDI1NSxcclxuICAgICAgICAgICAgICAgIG1hbnRpc3NhID0gdWludCAmIDgzODg2MDc7XHJcbiAgICAgICAgICAgIHJldHVybiBleHBvbmVudCA9PT0gMjU1XHJcbiAgICAgICAgICAgICAgICA/IG1hbnRpc3NhXHJcbiAgICAgICAgICAgICAgICA/IE5hTlxyXG4gICAgICAgICAgICAgICAgOiBzaWduICogSW5maW5pdHlcclxuICAgICAgICAgICAgICAgIDogZXhwb25lbnQgPT09IDAgLy8gZGVub3JtYWxcclxuICAgICAgICAgICAgICAgID8gc2lnbiAqIDEuNDAxMjk4NDY0MzI0ODE3ZS00NSAqIG1hbnRpc3NhXHJcbiAgICAgICAgICAgICAgICA6IHNpZ24gKiBNYXRoLnBvdygyLCBleHBvbmVudCAtIDE1MCkgKiAobWFudGlzc2EgKyA4Mzg4NjA4KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGV4cG9ydHMucmVhZEZsb2F0TEUgPSByZWFkRmxvYXRfaWVlZTc1NC5iaW5kKG51bGwsIHJlYWRVaW50TEUpO1xyXG4gICAgICAgIGV4cG9ydHMucmVhZEZsb2F0QkUgPSByZWFkRmxvYXRfaWVlZTc1NC5iaW5kKG51bGwsIHJlYWRVaW50QkUpO1xyXG5cclxuICAgIH0pKCk7XHJcblxyXG4gICAgLy8gZG91YmxlOiB0eXBlZCBhcnJheVxyXG4gICAgaWYgKHR5cGVvZiBGbG9hdDY0QXJyYXkgIT09IFwidW5kZWZpbmVkXCIpIChmdW5jdGlvbigpIHtcclxuXHJcbiAgICAgICAgdmFyIGY2NCA9IG5ldyBGbG9hdDY0QXJyYXkoWy0wXSksXHJcbiAgICAgICAgICAgIGY4YiA9IG5ldyBVaW50OEFycmF5KGY2NC5idWZmZXIpLFxyXG4gICAgICAgICAgICBsZSAgPSBmOGJbN10gPT09IDEyODtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gd3JpdGVEb3VibGVfZjY0X2NweSh2YWwsIGJ1ZiwgcG9zKSB7XHJcbiAgICAgICAgICAgIGY2NFswXSA9IHZhbDtcclxuICAgICAgICAgICAgYnVmW3BvcyAgICBdID0gZjhiWzBdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgMV0gPSBmOGJbMV07XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyAyXSA9IGY4YlsyXTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDNdID0gZjhiWzNdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgNF0gPSBmOGJbNF07XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyA1XSA9IGY4Yls1XTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDZdID0gZjhiWzZdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgN10gPSBmOGJbN107XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiB3cml0ZURvdWJsZV9mNjRfcmV2KHZhbCwgYnVmLCBwb3MpIHtcclxuICAgICAgICAgICAgZjY0WzBdID0gdmFsO1xyXG4gICAgICAgICAgICBidWZbcG9zICAgIF0gPSBmOGJbN107XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyAxXSA9IGY4Yls2XTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDJdID0gZjhiWzVdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgM10gPSBmOGJbNF07XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyA0XSA9IGY4YlszXTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDVdID0gZjhiWzJdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgNl0gPSBmOGJbMV07XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyA3XSA9IGY4YlswXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICAgICAgZXhwb3J0cy53cml0ZURvdWJsZUxFID0gbGUgPyB3cml0ZURvdWJsZV9mNjRfY3B5IDogd3JpdGVEb3VibGVfZjY0X3JldjtcclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICAgIGV4cG9ydHMud3JpdGVEb3VibGVCRSA9IGxlID8gd3JpdGVEb3VibGVfZjY0X3JldiA6IHdyaXRlRG91YmxlX2Y2NF9jcHk7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHJlYWREb3VibGVfZjY0X2NweShidWYsIHBvcykge1xyXG4gICAgICAgICAgICBmOGJbMF0gPSBidWZbcG9zICAgIF07XHJcbiAgICAgICAgICAgIGY4YlsxXSA9IGJ1Zltwb3MgKyAxXTtcclxuICAgICAgICAgICAgZjhiWzJdID0gYnVmW3BvcyArIDJdO1xyXG4gICAgICAgICAgICBmOGJbM10gPSBidWZbcG9zICsgM107XHJcbiAgICAgICAgICAgIGY4Yls0XSA9IGJ1Zltwb3MgKyA0XTtcclxuICAgICAgICAgICAgZjhiWzVdID0gYnVmW3BvcyArIDVdO1xyXG4gICAgICAgICAgICBmOGJbNl0gPSBidWZbcG9zICsgNl07XHJcbiAgICAgICAgICAgIGY4Yls3XSA9IGJ1Zltwb3MgKyA3XTtcclxuICAgICAgICAgICAgcmV0dXJuIGY2NFswXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHJlYWREb3VibGVfZjY0X3JldihidWYsIHBvcykge1xyXG4gICAgICAgICAgICBmOGJbN10gPSBidWZbcG9zICAgIF07XHJcbiAgICAgICAgICAgIGY4Yls2XSA9IGJ1Zltwb3MgKyAxXTtcclxuICAgICAgICAgICAgZjhiWzVdID0gYnVmW3BvcyArIDJdO1xyXG4gICAgICAgICAgICBmOGJbNF0gPSBidWZbcG9zICsgM107XHJcbiAgICAgICAgICAgIGY4YlszXSA9IGJ1Zltwb3MgKyA0XTtcclxuICAgICAgICAgICAgZjhiWzJdID0gYnVmW3BvcyArIDVdO1xyXG4gICAgICAgICAgICBmOGJbMV0gPSBidWZbcG9zICsgNl07XHJcbiAgICAgICAgICAgIGY4YlswXSA9IGJ1Zltwb3MgKyA3XTtcclxuICAgICAgICAgICAgcmV0dXJuIGY2NFswXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICAgICAgZXhwb3J0cy5yZWFkRG91YmxlTEUgPSBsZSA/IHJlYWREb3VibGVfZjY0X2NweSA6IHJlYWREb3VibGVfZjY0X3JldjtcclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICAgIGV4cG9ydHMucmVhZERvdWJsZUJFID0gbGUgPyByZWFkRG91YmxlX2Y2NF9yZXYgOiByZWFkRG91YmxlX2Y2NF9jcHk7XHJcblxyXG4gICAgLy8gZG91YmxlOiBpZWVlNzU0XHJcbiAgICB9KSgpOyBlbHNlIChmdW5jdGlvbigpIHtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gd3JpdGVEb3VibGVfaWVlZTc1NCh3cml0ZVVpbnQsIG9mZjAsIG9mZjEsIHZhbCwgYnVmLCBwb3MpIHtcclxuICAgICAgICAgICAgdmFyIHNpZ24gPSB2YWwgPCAwID8gMSA6IDA7XHJcbiAgICAgICAgICAgIGlmIChzaWduKVxyXG4gICAgICAgICAgICAgICAgdmFsID0gLXZhbDtcclxuICAgICAgICAgICAgaWYgKHZhbCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgd3JpdGVVaW50KDAsIGJ1ZiwgcG9zICsgb2ZmMCk7XHJcbiAgICAgICAgICAgICAgICB3cml0ZVVpbnQoMSAvIHZhbCA+IDAgPyAvKiBwb3NpdGl2ZSAqLyAwIDogLyogbmVnYXRpdmUgMCAqLyAyMTQ3NDgzNjQ4LCBidWYsIHBvcyArIG9mZjEpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzTmFOKHZhbCkpIHtcclxuICAgICAgICAgICAgICAgIHdyaXRlVWludCgwLCBidWYsIHBvcyArIG9mZjApO1xyXG4gICAgICAgICAgICAgICAgd3JpdGVVaW50KDIxNDY5NTkzNjAsIGJ1ZiwgcG9zICsgb2ZmMSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsID4gMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDgpIHsgLy8gKy1JbmZpbml0eVxyXG4gICAgICAgICAgICAgICAgd3JpdGVVaW50KDAsIGJ1ZiwgcG9zICsgb2ZmMCk7XHJcbiAgICAgICAgICAgICAgICB3cml0ZVVpbnQoKHNpZ24gPDwgMzEgfCAyMTQ2NDM1MDcyKSA+Pj4gMCwgYnVmLCBwb3MgKyBvZmYxKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhciBtYW50aXNzYTtcclxuICAgICAgICAgICAgICAgIGlmICh2YWwgPCAyLjIyNTA3Mzg1ODUwNzIwMTRlLTMwOCkgeyAvLyBkZW5vcm1hbFxyXG4gICAgICAgICAgICAgICAgICAgIG1hbnRpc3NhID0gdmFsIC8gNWUtMzI0O1xyXG4gICAgICAgICAgICAgICAgICAgIHdyaXRlVWludChtYW50aXNzYSA+Pj4gMCwgYnVmLCBwb3MgKyBvZmYwKTtcclxuICAgICAgICAgICAgICAgICAgICB3cml0ZVVpbnQoKHNpZ24gPDwgMzEgfCBtYW50aXNzYSAvIDQyOTQ5NjcyOTYpID4+PiAwLCBidWYsIHBvcyArIG9mZjEpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZXhwb25lbnQgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbCkgLyBNYXRoLkxOMik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4cG9uZW50ID09PSAxMDI0KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBleHBvbmVudCA9IDEwMjM7XHJcbiAgICAgICAgICAgICAgICAgICAgbWFudGlzc2EgPSB2YWwgKiBNYXRoLnBvdygyLCAtZXhwb25lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHdyaXRlVWludChtYW50aXNzYSAqIDQ1MDM1OTk2MjczNzA0OTYgPj4+IDAsIGJ1ZiwgcG9zICsgb2ZmMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVVaW50KChzaWduIDw8IDMxIHwgZXhwb25lbnQgKyAxMDIzIDw8IDIwIHwgbWFudGlzc2EgKiAxMDQ4NTc2ICYgMTA0ODU3NSkgPj4+IDAsIGJ1ZiwgcG9zICsgb2ZmMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGV4cG9ydHMud3JpdGVEb3VibGVMRSA9IHdyaXRlRG91YmxlX2llZWU3NTQuYmluZChudWxsLCB3cml0ZVVpbnRMRSwgMCwgNCk7XHJcbiAgICAgICAgZXhwb3J0cy53cml0ZURvdWJsZUJFID0gd3JpdGVEb3VibGVfaWVlZTc1NC5iaW5kKG51bGwsIHdyaXRlVWludEJFLCA0LCAwKTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gcmVhZERvdWJsZV9pZWVlNzU0KHJlYWRVaW50LCBvZmYwLCBvZmYxLCBidWYsIHBvcykge1xyXG4gICAgICAgICAgICB2YXIgbG8gPSByZWFkVWludChidWYsIHBvcyArIG9mZjApLFxyXG4gICAgICAgICAgICAgICAgaGkgPSByZWFkVWludChidWYsIHBvcyArIG9mZjEpO1xyXG4gICAgICAgICAgICB2YXIgc2lnbiA9IChoaSA+PiAzMSkgKiAyICsgMSxcclxuICAgICAgICAgICAgICAgIGV4cG9uZW50ID0gaGkgPj4+IDIwICYgMjA0NyxcclxuICAgICAgICAgICAgICAgIG1hbnRpc3NhID0gNDI5NDk2NzI5NiAqIChoaSAmIDEwNDg1NzUpICsgbG87XHJcbiAgICAgICAgICAgIHJldHVybiBleHBvbmVudCA9PT0gMjA0N1xyXG4gICAgICAgICAgICAgICAgPyBtYW50aXNzYVxyXG4gICAgICAgICAgICAgICAgPyBOYU5cclxuICAgICAgICAgICAgICAgIDogc2lnbiAqIEluZmluaXR5XHJcbiAgICAgICAgICAgICAgICA6IGV4cG9uZW50ID09PSAwIC8vIGRlbm9ybWFsXHJcbiAgICAgICAgICAgICAgICA/IHNpZ24gKiA1ZS0zMjQgKiBtYW50aXNzYVxyXG4gICAgICAgICAgICAgICAgOiBzaWduICogTWF0aC5wb3coMiwgZXhwb25lbnQgLSAxMDc1KSAqIChtYW50aXNzYSArIDQ1MDM1OTk2MjczNzA0OTYpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZXhwb3J0cy5yZWFkRG91YmxlTEUgPSByZWFkRG91YmxlX2llZWU3NTQuYmluZChudWxsLCByZWFkVWludExFLCAwLCA0KTtcclxuICAgICAgICBleHBvcnRzLnJlYWREb3VibGVCRSA9IHJlYWREb3VibGVfaWVlZTc1NC5iaW5kKG51bGwsIHJlYWRVaW50QkUsIDQsIDApO1xyXG5cclxuICAgIH0pKCk7XHJcblxyXG4gICAgcmV0dXJuIGV4cG9ydHM7XHJcbn1cclxuXHJcbi8vIHVpbnQgaGVscGVyc1xyXG5cclxuZnVuY3Rpb24gd3JpdGVVaW50TEUodmFsLCBidWYsIHBvcykge1xyXG4gICAgYnVmW3BvcyAgICBdID0gIHZhbCAgICAgICAgJiAyNTU7XHJcbiAgICBidWZbcG9zICsgMV0gPSAgdmFsID4+PiA4ICAmIDI1NTtcclxuICAgIGJ1Zltwb3MgKyAyXSA9ICB2YWwgPj4+IDE2ICYgMjU1O1xyXG4gICAgYnVmW3BvcyArIDNdID0gIHZhbCA+Pj4gMjQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHdyaXRlVWludEJFKHZhbCwgYnVmLCBwb3MpIHtcclxuICAgIGJ1Zltwb3MgICAgXSA9ICB2YWwgPj4+IDI0O1xyXG4gICAgYnVmW3BvcyArIDFdID0gIHZhbCA+Pj4gMTYgJiAyNTU7XHJcbiAgICBidWZbcG9zICsgMl0gPSAgdmFsID4+PiA4ICAmIDI1NTtcclxuICAgIGJ1Zltwb3MgKyAzXSA9ICB2YWwgICAgICAgICYgMjU1O1xyXG59XHJcblxyXG5mdW5jdGlvbiByZWFkVWludExFKGJ1ZiwgcG9zKSB7XHJcbiAgICByZXR1cm4gKGJ1Zltwb3MgICAgXVxyXG4gICAgICAgICAgfCBidWZbcG9zICsgMV0gPDwgOFxyXG4gICAgICAgICAgfCBidWZbcG9zICsgMl0gPDwgMTZcclxuICAgICAgICAgIHwgYnVmW3BvcyArIDNdIDw8IDI0KSA+Pj4gMDtcclxufVxyXG5cclxuZnVuY3Rpb24gcmVhZFVpbnRCRShidWYsIHBvcykge1xyXG4gICAgcmV0dXJuIChidWZbcG9zICAgIF0gPDwgMjRcclxuICAgICAgICAgIHwgYnVmW3BvcyArIDFdIDw8IDE2XHJcbiAgICAgICAgICB8IGJ1Zltwb3MgKyAyXSA8PCA4XHJcbiAgICAgICAgICB8IGJ1Zltwb3MgKyAzXSkgPj4+IDA7XHJcbn1cclxuIiwgIlwidXNlIHN0cmljdFwiO1xyXG5tb2R1bGUuZXhwb3J0cyA9IGlucXVpcmU7XHJcblxyXG4vKipcclxuICogUmVxdWlyZXMgYSBtb2R1bGUgb25seSBpZiBhdmFpbGFibGUuXHJcbiAqIEBtZW1iZXJvZiB1dGlsXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBtb2R1bGVOYW1lIE1vZHVsZSB0byByZXF1aXJlXHJcbiAqIEByZXR1cm5zIHs/T2JqZWN0fSBSZXF1aXJlZCBtb2R1bGUgaWYgYXZhaWxhYmxlIGFuZCBub3QgZW1wdHksIG90aGVyd2lzZSBgbnVsbGBcclxuICovXHJcbmZ1bmN0aW9uIGlucXVpcmUobW9kdWxlTmFtZSkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICB2YXIgbW9kID0gZXZhbChcInF1aXJlXCIucmVwbGFjZSgvXi8sXCJyZVwiKSkobW9kdWxlTmFtZSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZXZhbFxyXG4gICAgICAgIGlmIChtb2QgJiYgKG1vZC5sZW5ndGggfHwgT2JqZWN0LmtleXMobW9kKS5sZW5ndGgpKVxyXG4gICAgICAgICAgICByZXR1cm4gbW9kO1xyXG4gICAgfSBjYXRjaCAoZSkge30gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1lbXB0eVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbn1cclxuIiwgIlwidXNlIHN0cmljdFwiO1xyXG5cclxuLyoqXHJcbiAqIEEgbWluaW1hbCBVVEY4IGltcGxlbWVudGF0aW9uIGZvciBudW1iZXIgYXJyYXlzLlxyXG4gKiBAbWVtYmVyb2YgdXRpbFxyXG4gKiBAbmFtZXNwYWNlXHJcbiAqL1xyXG52YXIgdXRmOCA9IGV4cG9ydHM7XHJcblxyXG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgVVRGOCBieXRlIGxlbmd0aCBvZiBhIHN0cmluZy5cclxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBTdHJpbmdcclxuICogQHJldHVybnMge251bWJlcn0gQnl0ZSBsZW5ndGhcclxuICovXHJcbnV0ZjgubGVuZ3RoID0gZnVuY3Rpb24gdXRmOF9sZW5ndGgoc3RyaW5nKSB7XHJcbiAgICB2YXIgbGVuID0gMCxcclxuICAgICAgICBjID0gMDtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyaW5nLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgYyA9IHN0cmluZy5jaGFyQ29kZUF0KGkpO1xyXG4gICAgICAgIGlmIChjIDwgMTI4KVxyXG4gICAgICAgICAgICBsZW4gKz0gMTtcclxuICAgICAgICBlbHNlIGlmIChjIDwgMjA0OClcclxuICAgICAgICAgICAgbGVuICs9IDI7XHJcbiAgICAgICAgZWxzZSBpZiAoKGMgJiAweEZDMDApID09PSAweEQ4MDAgJiYgKHN0cmluZy5jaGFyQ29kZUF0KGkgKyAxKSAmIDB4RkMwMCkgPT09IDB4REMwMCkge1xyXG4gICAgICAgICAgICArK2k7XHJcbiAgICAgICAgICAgIGxlbiArPSA0O1xyXG4gICAgICAgIH0gZWxzZVxyXG4gICAgICAgICAgICBsZW4gKz0gMztcclxuICAgIH1cclxuICAgIHJldHVybiBsZW47XHJcbn07XHJcblxyXG4vKipcclxuICogUmVhZHMgVVRGOCBieXRlcyBhcyBhIHN0cmluZy5cclxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWZmZXIgU291cmNlIGJ1ZmZlclxyXG4gKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgU291cmNlIHN0YXJ0XHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgU291cmNlIGVuZFxyXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBTdHJpbmcgcmVhZFxyXG4gKi9cclxudXRmOC5yZWFkID0gZnVuY3Rpb24gdXRmOF9yZWFkKGJ1ZmZlciwgc3RhcnQsIGVuZCkge1xyXG4gICAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0O1xyXG4gICAgaWYgKGxlbiA8IDEpXHJcbiAgICAgICAgcmV0dXJuIFwiXCI7XHJcbiAgICB2YXIgcGFydHMgPSBudWxsLFxyXG4gICAgICAgIGNodW5rID0gW10sXHJcbiAgICAgICAgaSA9IDAsIC8vIGNoYXIgb2Zmc2V0XHJcbiAgICAgICAgdDsgICAgIC8vIHRlbXBvcmFyeVxyXG4gICAgd2hpbGUgKHN0YXJ0IDwgZW5kKSB7XHJcbiAgICAgICAgdCA9IGJ1ZmZlcltzdGFydCsrXTtcclxuICAgICAgICBpZiAodCA8IDEyOClcclxuICAgICAgICAgICAgY2h1bmtbaSsrXSA9IHQ7XHJcbiAgICAgICAgZWxzZSBpZiAodCA+IDE5MSAmJiB0IDwgMjI0KVxyXG4gICAgICAgICAgICBjaHVua1tpKytdID0gKHQgJiAzMSkgPDwgNiB8IGJ1ZmZlcltzdGFydCsrXSAmIDYzO1xyXG4gICAgICAgIGVsc2UgaWYgKHQgPiAyMzkgJiYgdCA8IDM2NSkge1xyXG4gICAgICAgICAgICB0ID0gKCh0ICYgNykgPDwgMTggfCAoYnVmZmVyW3N0YXJ0KytdICYgNjMpIDw8IDEyIHwgKGJ1ZmZlcltzdGFydCsrXSAmIDYzKSA8PCA2IHwgYnVmZmVyW3N0YXJ0KytdICYgNjMpIC0gMHgxMDAwMDtcclxuICAgICAgICAgICAgY2h1bmtbaSsrXSA9IDB4RDgwMCArICh0ID4+IDEwKTtcclxuICAgICAgICAgICAgY2h1bmtbaSsrXSA9IDB4REMwMCArICh0ICYgMTAyMyk7XHJcbiAgICAgICAgfSBlbHNlXHJcbiAgICAgICAgICAgIGNodW5rW2krK10gPSAodCAmIDE1KSA8PCAxMiB8IChidWZmZXJbc3RhcnQrK10gJiA2MykgPDwgNiB8IGJ1ZmZlcltzdGFydCsrXSAmIDYzO1xyXG4gICAgICAgIGlmIChpID4gODE5MSkge1xyXG4gICAgICAgICAgICAocGFydHMgfHwgKHBhcnRzID0gW10pKS5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjaHVuaykpO1xyXG4gICAgICAgICAgICBpID0gMDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAocGFydHMpIHtcclxuICAgICAgICBpZiAoaSlcclxuICAgICAgICAgICAgcGFydHMucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY2h1bmsuc2xpY2UoMCwgaSkpKTtcclxuICAgICAgICByZXR1cm4gcGFydHMuam9pbihcIlwiKTtcclxuICAgIH1cclxuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY2h1bmsuc2xpY2UoMCwgaSkpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFdyaXRlcyBhIHN0cmluZyBhcyBVVEY4IGJ5dGVzLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFNvdXJjZSBzdHJpbmdcclxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWZmZXIgRGVzdGluYXRpb24gYnVmZmVyXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgRGVzdGluYXRpb24gb2Zmc2V0XHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IEJ5dGVzIHdyaXR0ZW5cclxuICovXHJcbnV0Zjgud3JpdGUgPSBmdW5jdGlvbiB1dGY4X3dyaXRlKHN0cmluZywgYnVmZmVyLCBvZmZzZXQpIHtcclxuICAgIHZhciBzdGFydCA9IG9mZnNldCxcclxuICAgICAgICBjMSwgLy8gY2hhcmFjdGVyIDFcclxuICAgICAgICBjMjsgLy8gY2hhcmFjdGVyIDJcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyaW5nLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgYzEgPSBzdHJpbmcuY2hhckNvZGVBdChpKTtcclxuICAgICAgICBpZiAoYzEgPCAxMjgpIHtcclxuICAgICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9IGMxO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoYzEgPCAyMDQ4KSB7XHJcbiAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQrK10gPSBjMSA+PiA2ICAgICAgIHwgMTkyO1xyXG4gICAgICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gYzEgICAgICAgJiA2MyB8IDEyODtcclxuICAgICAgICB9IGVsc2UgaWYgKChjMSAmIDB4RkMwMCkgPT09IDB4RDgwMCAmJiAoKGMyID0gc3RyaW5nLmNoYXJDb2RlQXQoaSArIDEpKSAmIDB4RkMwMCkgPT09IDB4REMwMCkge1xyXG4gICAgICAgICAgICBjMSA9IDB4MTAwMDAgKyAoKGMxICYgMHgwM0ZGKSA8PCAxMCkgKyAoYzIgJiAweDAzRkYpO1xyXG4gICAgICAgICAgICArK2k7XHJcbiAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQrK10gPSBjMSA+PiAxOCAgICAgIHwgMjQwO1xyXG4gICAgICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gYzEgPj4gMTIgJiA2MyB8IDEyODtcclxuICAgICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9IGMxID4+IDYgICYgNjMgfCAxMjg7XHJcbiAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQrK10gPSBjMSAgICAgICAmIDYzIHwgMTI4O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQrK10gPSBjMSA+PiAxMiAgICAgIHwgMjI0O1xyXG4gICAgICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gYzEgPj4gNiAgJiA2MyB8IDEyODtcclxuICAgICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9IGMxICAgICAgICYgNjMgfCAxMjg7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG9mZnNldCAtIHN0YXJ0O1xyXG59O1xyXG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XHJcbm1vZHVsZS5leHBvcnRzID0gcG9vbDtcclxuXHJcbi8qKlxyXG4gKiBBbiBhbGxvY2F0b3IgYXMgdXNlZCBieSB7QGxpbmsgdXRpbC5wb29sfS5cclxuICogQHR5cGVkZWYgUG9vbEFsbG9jYXRvclxyXG4gKiBAdHlwZSB7ZnVuY3Rpb259XHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBzaXplIEJ1ZmZlciBzaXplXHJcbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fSBCdWZmZXJcclxuICovXHJcblxyXG4vKipcclxuICogQSBzbGljZXIgYXMgdXNlZCBieSB7QGxpbmsgdXRpbC5wb29sfS5cclxuICogQHR5cGVkZWYgUG9vbFNsaWNlclxyXG4gKiBAdHlwZSB7ZnVuY3Rpb259XHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBTdGFydCBvZmZzZXRcclxuICogQHBhcmFtIHtudW1iZXJ9IGVuZCBFbmQgb2Zmc2V0XHJcbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fSBCdWZmZXIgc2xpY2VcclxuICogQHRoaXMge1VpbnQ4QXJyYXl9XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEEgZ2VuZXJhbCBwdXJwb3NlIGJ1ZmZlciBwb29sLlxyXG4gKiBAbWVtYmVyb2YgdXRpbFxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtQb29sQWxsb2NhdG9yfSBhbGxvYyBBbGxvY2F0b3JcclxuICogQHBhcmFtIHtQb29sU2xpY2VyfSBzbGljZSBTbGljZXJcclxuICogQHBhcmFtIHtudW1iZXJ9IFtzaXplPTgxOTJdIFNsYWIgc2l6ZVxyXG4gKiBAcmV0dXJucyB7UG9vbEFsbG9jYXRvcn0gUG9vbGVkIGFsbG9jYXRvclxyXG4gKi9cclxuZnVuY3Rpb24gcG9vbChhbGxvYywgc2xpY2UsIHNpemUpIHtcclxuICAgIHZhciBTSVpFICAgPSBzaXplIHx8IDgxOTI7XHJcbiAgICB2YXIgTUFYICAgID0gU0laRSA+Pj4gMTtcclxuICAgIHZhciBzbGFiICAgPSBudWxsO1xyXG4gICAgdmFyIG9mZnNldCA9IFNJWkU7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gcG9vbF9hbGxvYyhzaXplKSB7XHJcbiAgICAgICAgaWYgKHNpemUgPCAxIHx8IHNpemUgPiBNQVgpXHJcbiAgICAgICAgICAgIHJldHVybiBhbGxvYyhzaXplKTtcclxuICAgICAgICBpZiAob2Zmc2V0ICsgc2l6ZSA+IFNJWkUpIHtcclxuICAgICAgICAgICAgc2xhYiA9IGFsbG9jKFNJWkUpO1xyXG4gICAgICAgICAgICBvZmZzZXQgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgYnVmID0gc2xpY2UuY2FsbChzbGFiLCBvZmZzZXQsIG9mZnNldCArPSBzaXplKTtcclxuICAgICAgICBpZiAob2Zmc2V0ICYgNykgLy8gYWxpZ24gdG8gMzIgYml0XHJcbiAgICAgICAgICAgIG9mZnNldCA9IChvZmZzZXQgfCA3KSArIDE7XHJcbiAgICAgICAgcmV0dXJuIGJ1ZjtcclxuICAgIH07XHJcbn1cclxuIiwgIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBMb25nQml0cztcblxudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbC9taW5pbWFsXCIpO1xuXG4vKipcbiAqIENvbnN0cnVjdHMgbmV3IGxvbmcgYml0cy5cbiAqIEBjbGFzc2Rlc2MgSGVscGVyIGNsYXNzIGZvciB3b3JraW5nIHdpdGggdGhlIGxvdyBhbmQgaGlnaCBiaXRzIG9mIGEgNjQgYml0IHZhbHVlLlxuICogQG1lbWJlcm9mIHV0aWxcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtudW1iZXJ9IGxvIExvdyAzMiBiaXRzLCB1bnNpZ25lZFxuICogQHBhcmFtIHtudW1iZXJ9IGhpIEhpZ2ggMzIgYml0cywgdW5zaWduZWRcbiAqL1xuZnVuY3Rpb24gTG9uZ0JpdHMobG8sIGhpKSB7XG5cbiAgICAvLyBub3RlIHRoYXQgdGhlIGNhc3RzIGJlbG93IGFyZSB0aGVvcmV0aWNhbGx5IHVubmVjZXNzYXJ5IGFzIG9mIHRvZGF5LCBidXQgb2xkZXIgc3RhdGljYWxseVxuICAgIC8vIGdlbmVyYXRlZCBjb252ZXJ0ZXIgY29kZSBtaWdodCBzdGlsbCBjYWxsIHRoZSBjdG9yIHdpdGggc2lnbmVkIDMyYml0cy4ga2VwdCBmb3IgY29tcGF0LlxuXG4gICAgLyoqXG4gICAgICogTG93IGJpdHMuXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmxvID0gbG8gPj4+IDA7XG5cbiAgICAvKipcbiAgICAgKiBIaWdoIGJpdHMuXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmhpID0gaGkgPj4+IDA7XG59XG5cbi8qKlxuICogWmVybyBiaXRzLlxuICogQG1lbWJlcm9mIHV0aWwuTG9uZ0JpdHNcbiAqIEB0eXBlIHt1dGlsLkxvbmdCaXRzfVxuICovXG52YXIgemVybyA9IExvbmdCaXRzLnplcm8gPSBuZXcgTG9uZ0JpdHMoMCwgMCk7XG5cbnplcm8udG9OdW1iZXIgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG56ZXJvLnp6RW5jb2RlID0gemVyby56ekRlY29kZSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfTtcbnplcm8ubGVuZ3RoID0gZnVuY3Rpb24oKSB7IHJldHVybiAxOyB9O1xuXG4vKipcbiAqIFplcm8gaGFzaC5cbiAqIEBtZW1iZXJvZiB1dGlsLkxvbmdCaXRzXG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG52YXIgemVyb0hhc2ggPSBMb25nQml0cy56ZXJvSGFzaCA9IFwiXFwwXFwwXFwwXFwwXFwwXFwwXFwwXFwwXCI7XG5cbi8qKlxuICogQ29uc3RydWN0cyBuZXcgbG9uZyBiaXRzIGZyb20gdGhlIHNwZWNpZmllZCBudW1iZXIuXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWVcbiAqIEByZXR1cm5zIHt1dGlsLkxvbmdCaXRzfSBJbnN0YW5jZVxuICovXG5Mb25nQml0cy5mcm9tTnVtYmVyID0gZnVuY3Rpb24gZnJvbU51bWJlcih2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gMClcbiAgICAgICAgcmV0dXJuIHplcm87XG4gICAgdmFyIHNpZ24gPSB2YWx1ZSA8IDA7XG4gICAgaWYgKHNpZ24pXG4gICAgICAgIHZhbHVlID0gLXZhbHVlO1xuICAgIHZhciBsbyA9IHZhbHVlID4+PiAwLFxuICAgICAgICBoaSA9ICh2YWx1ZSAtIGxvKSAvIDQyOTQ5NjcyOTYgPj4+IDA7XG4gICAgaWYgKHNpZ24pIHtcbiAgICAgICAgaGkgPSB+aGkgPj4+IDA7XG4gICAgICAgIGxvID0gfmxvID4+PiAwO1xuICAgICAgICBpZiAoKytsbyA+IDQyOTQ5NjcyOTUpIHtcbiAgICAgICAgICAgIGxvID0gMDtcbiAgICAgICAgICAgIGlmICgrK2hpID4gNDI5NDk2NzI5NSlcbiAgICAgICAgICAgICAgICBoaSA9IDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBMb25nQml0cyhsbywgaGkpO1xufTtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIG5ldyBsb25nIGJpdHMgZnJvbSBhIG51bWJlciwgbG9uZyBvciBzdHJpbmcuXG4gKiBAcGFyYW0ge0xvbmd8bnVtYmVyfHN0cmluZ30gdmFsdWUgVmFsdWVcbiAqIEByZXR1cm5zIHt1dGlsLkxvbmdCaXRzfSBJbnN0YW5jZVxuICovXG5Mb25nQml0cy5mcm9tID0gZnVuY3Rpb24gZnJvbSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpXG4gICAgICAgIHJldHVybiBMb25nQml0cy5mcm9tTnVtYmVyKHZhbHVlKTtcbiAgICBpZiAodXRpbC5pc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgaWYgKHV0aWwuTG9uZylcbiAgICAgICAgICAgIHZhbHVlID0gdXRpbC5Mb25nLmZyb21TdHJpbmcodmFsdWUpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gTG9uZ0JpdHMuZnJvbU51bWJlcihwYXJzZUludCh2YWx1ZSwgMTApKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlLmxvdyB8fCB2YWx1ZS5oaWdoID8gbmV3IExvbmdCaXRzKHZhbHVlLmxvdyA+Pj4gMCwgdmFsdWUuaGlnaCA+Pj4gMCkgOiB6ZXJvO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGlzIGxvbmcgYml0cyB0byBhIHBvc3NpYmx5IHVuc2FmZSBKYXZhU2NyaXB0IG51bWJlci5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Vuc2lnbmVkPWZhbHNlXSBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdFxuICogQHJldHVybnMge251bWJlcn0gUG9zc2libHkgdW5zYWZlIG51bWJlclxuICovXG5Mb25nQml0cy5wcm90b3R5cGUudG9OdW1iZXIgPSBmdW5jdGlvbiB0b051bWJlcih1bnNpZ25lZCkge1xuICAgIGlmICghdW5zaWduZWQgJiYgdGhpcy5oaSA+Pj4gMzEpIHtcbiAgICAgICAgdmFyIGxvID0gfnRoaXMubG8gKyAxID4+PiAwLFxuICAgICAgICAgICAgaGkgPSB+dGhpcy5oaSAgICAgPj4+IDA7XG4gICAgICAgIGlmICghbG8pXG4gICAgICAgICAgICBoaSA9IGhpICsgMSA+Pj4gMDtcbiAgICAgICAgcmV0dXJuIC0obG8gKyBoaSAqIDQyOTQ5NjcyOTYpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5sbyArIHRoaXMuaGkgKiA0Mjk0OTY3Mjk2O1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGlzIGxvbmcgYml0cyB0byBhIGxvbmcuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFt1bnNpZ25lZD1mYWxzZV0gV2hldGhlciB1bnNpZ25lZCBvciBub3RcbiAqIEByZXR1cm5zIHtMb25nfSBMb25nXG4gKi9cbkxvbmdCaXRzLnByb3RvdHlwZS50b0xvbmcgPSBmdW5jdGlvbiB0b0xvbmcodW5zaWduZWQpIHtcbiAgICByZXR1cm4gdXRpbC5Mb25nXG4gICAgICAgID8gbmV3IHV0aWwuTG9uZyh0aGlzLmxvIHwgMCwgdGhpcy5oaSB8IDAsIEJvb2xlYW4odW5zaWduZWQpKVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICA6IHsgbG93OiB0aGlzLmxvIHwgMCwgaGlnaDogdGhpcy5oaSB8IDAsIHVuc2lnbmVkOiBCb29sZWFuKHVuc2lnbmVkKSB9O1xufTtcblxudmFyIGNoYXJDb2RlQXQgPSBTdHJpbmcucHJvdG90eXBlLmNoYXJDb2RlQXQ7XG5cbi8qKlxuICogQ29uc3RydWN0cyBuZXcgbG9uZyBiaXRzIGZyb20gdGhlIHNwZWNpZmllZCA4IGNoYXJhY3RlcnMgbG9uZyBoYXNoLlxuICogQHBhcmFtIHtzdHJpbmd9IGhhc2ggSGFzaFxuICogQHJldHVybnMge3V0aWwuTG9uZ0JpdHN9IEJpdHNcbiAqL1xuTG9uZ0JpdHMuZnJvbUhhc2ggPSBmdW5jdGlvbiBmcm9tSGFzaChoYXNoKSB7XG4gICAgaWYgKGhhc2ggPT09IHplcm9IYXNoKVxuICAgICAgICByZXR1cm4gemVybztcbiAgICByZXR1cm4gbmV3IExvbmdCaXRzKFxuICAgICAgICAoIGNoYXJDb2RlQXQuY2FsbChoYXNoLCAwKVxuICAgICAgICB8IGNoYXJDb2RlQXQuY2FsbChoYXNoLCAxKSA8PCA4XG4gICAgICAgIHwgY2hhckNvZGVBdC5jYWxsKGhhc2gsIDIpIDw8IDE2XG4gICAgICAgIHwgY2hhckNvZGVBdC5jYWxsKGhhc2gsIDMpIDw8IDI0KSA+Pj4gMFxuICAgICxcbiAgICAgICAgKCBjaGFyQ29kZUF0LmNhbGwoaGFzaCwgNClcbiAgICAgICAgfCBjaGFyQ29kZUF0LmNhbGwoaGFzaCwgNSkgPDwgOFxuICAgICAgICB8IGNoYXJDb2RlQXQuY2FsbChoYXNoLCA2KSA8PCAxNlxuICAgICAgICB8IGNoYXJDb2RlQXQuY2FsbChoYXNoLCA3KSA8PCAyNCkgPj4+IDBcbiAgICApO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGlzIGxvbmcgYml0cyB0byBhIDggY2hhcmFjdGVycyBsb25nIGhhc2guXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBIYXNoXG4gKi9cbkxvbmdCaXRzLnByb3RvdHlwZS50b0hhc2ggPSBmdW5jdGlvbiB0b0hhc2goKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoXG4gICAgICAgIHRoaXMubG8gICAgICAgICYgMjU1LFxuICAgICAgICB0aGlzLmxvID4+PiA4ICAmIDI1NSxcbiAgICAgICAgdGhpcy5sbyA+Pj4gMTYgJiAyNTUsXG4gICAgICAgIHRoaXMubG8gPj4+IDI0ICAgICAgLFxuICAgICAgICB0aGlzLmhpICAgICAgICAmIDI1NSxcbiAgICAgICAgdGhpcy5oaSA+Pj4gOCAgJiAyNTUsXG4gICAgICAgIHRoaXMuaGkgPj4+IDE2ICYgMjU1LFxuICAgICAgICB0aGlzLmhpID4+PiAyNFxuICAgICk7XG59O1xuXG4vKipcbiAqIFppZy16YWcgZW5jb2RlcyB0aGlzIGxvbmcgYml0cy5cbiAqIEByZXR1cm5zIHt1dGlsLkxvbmdCaXRzfSBgdGhpc2BcbiAqL1xuTG9uZ0JpdHMucHJvdG90eXBlLnp6RW5jb2RlID0gZnVuY3Rpb24genpFbmNvZGUoKSB7XG4gICAgdmFyIG1hc2sgPSAgIHRoaXMuaGkgPj4gMzE7XG4gICAgdGhpcy5oaSAgPSAoKHRoaXMuaGkgPDwgMSB8IHRoaXMubG8gPj4+IDMxKSBeIG1hc2spID4+PiAwO1xuICAgIHRoaXMubG8gID0gKCB0aGlzLmxvIDw8IDEgICAgICAgICAgICAgICAgICAgXiBtYXNrKSA+Pj4gMDtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogWmlnLXphZyBkZWNvZGVzIHRoaXMgbG9uZyBiaXRzLlxuICogQHJldHVybnMge3V0aWwuTG9uZ0JpdHN9IGB0aGlzYFxuICovXG5Mb25nQml0cy5wcm90b3R5cGUuenpEZWNvZGUgPSBmdW5jdGlvbiB6ekRlY29kZSgpIHtcbiAgICB2YXIgbWFzayA9IC0odGhpcy5sbyAmIDEpO1xuICAgIHRoaXMubG8gID0gKCh0aGlzLmxvID4+PiAxIHwgdGhpcy5oaSA8PCAzMSkgXiBtYXNrKSA+Pj4gMDtcbiAgICB0aGlzLmhpICA9ICggdGhpcy5oaSA+Pj4gMSAgICAgICAgICAgICAgICAgIF4gbWFzaykgPj4+IDA7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGxlbmd0aCBvZiB0aGlzIGxvbmdiaXRzIHdoZW4gZW5jb2RlZCBhcyBhIHZhcmludC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IExlbmd0aFxuICovXG5Mb25nQml0cy5wcm90b3R5cGUubGVuZ3RoID0gZnVuY3Rpb24gbGVuZ3RoKCkge1xuICAgIHZhciBwYXJ0MCA9ICB0aGlzLmxvLFxuICAgICAgICBwYXJ0MSA9ICh0aGlzLmxvID4+PiAyOCB8IHRoaXMuaGkgPDwgNCkgPj4+IDAsXG4gICAgICAgIHBhcnQyID0gIHRoaXMuaGkgPj4+IDI0O1xuICAgIHJldHVybiBwYXJ0MiA9PT0gMFxuICAgICAgICAgPyBwYXJ0MSA9PT0gMFxuICAgICAgICAgICA/IHBhcnQwIDwgMTYzODRcbiAgICAgICAgICAgICA/IHBhcnQwIDwgMTI4ID8gMSA6IDJcbiAgICAgICAgICAgICA6IHBhcnQwIDwgMjA5NzE1MiA/IDMgOiA0XG4gICAgICAgICAgIDogcGFydDEgPCAxNjM4NFxuICAgICAgICAgICAgID8gcGFydDEgPCAxMjggPyA1IDogNlxuICAgICAgICAgICAgIDogcGFydDEgPCAyMDk3MTUyID8gNyA6IDhcbiAgICAgICAgIDogcGFydDIgPCAxMjggPyA5IDogMTA7XG59O1xuIiwgIlwidXNlIHN0cmljdFwiO1xudmFyIHV0aWwgPSBleHBvcnRzO1xuXG4vLyB1c2VkIHRvIHJldHVybiBhIFByb21pc2Ugd2hlcmUgY2FsbGJhY2sgaXMgb21pdHRlZFxudXRpbC5hc1Byb21pc2UgPSByZXF1aXJlKFwiQHByb3RvYnVmanMvYXNwcm9taXNlXCIpO1xuXG4vLyBjb252ZXJ0cyB0byAvIGZyb20gYmFzZTY0IGVuY29kZWQgc3RyaW5nc1xudXRpbC5iYXNlNjQgPSByZXF1aXJlKFwiQHByb3RvYnVmanMvYmFzZTY0XCIpO1xuXG4vLyBiYXNlIGNsYXNzIG9mIHJwYy5TZXJ2aWNlXG51dGlsLkV2ZW50RW1pdHRlciA9IHJlcXVpcmUoXCJAcHJvdG9idWZqcy9ldmVudGVtaXR0ZXJcIik7XG5cbi8vIGZsb2F0IGhhbmRsaW5nIGFjY3Jvc3MgYnJvd3NlcnNcbnV0aWwuZmxvYXQgPSByZXF1aXJlKFwiQHByb3RvYnVmanMvZmxvYXRcIik7XG5cbi8vIHJlcXVpcmVzIG1vZHVsZXMgb3B0aW9uYWxseSBhbmQgaGlkZXMgdGhlIGNhbGwgZnJvbSBidW5kbGVyc1xudXRpbC5pbnF1aXJlID0gcmVxdWlyZShcIkBwcm90b2J1ZmpzL2lucXVpcmVcIik7XG5cbi8vIGNvbnZlcnRzIHRvIC8gZnJvbSB1dGY4IGVuY29kZWQgc3RyaW5nc1xudXRpbC51dGY4ID0gcmVxdWlyZShcIkBwcm90b2J1ZmpzL3V0ZjhcIik7XG5cbi8vIHByb3ZpZGVzIGEgbm9kZS1saWtlIGJ1ZmZlciBwb29sIGluIHRoZSBicm93c2VyXG51dGlsLnBvb2wgPSByZXF1aXJlKFwiQHByb3RvYnVmanMvcG9vbFwiKTtcblxuLy8gdXRpbGl0eSB0byB3b3JrIHdpdGggdGhlIGxvdyBhbmQgaGlnaCBiaXRzIG9mIGEgNjQgYml0IHZhbHVlXG51dGlsLkxvbmdCaXRzID0gcmVxdWlyZShcIi4vbG9uZ2JpdHNcIik7XG5cbi8qKlxuICogV2hldGhlciBydW5uaW5nIHdpdGhpbiBub2RlIG9yIG5vdC5cbiAqIEBtZW1iZXJvZiB1dGlsXG4gKiBAdHlwZSB7Ym9vbGVhbn1cbiAqL1xudXRpbC5pc05vZGUgPSBCb29sZWFuKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCJcbiAgICAgICAgICAgICAgICAgICAmJiBnbG9iYWxcbiAgICAgICAgICAgICAgICAgICAmJiBnbG9iYWwucHJvY2Vzc1xuICAgICAgICAgICAgICAgICAgICYmIGdsb2JhbC5wcm9jZXNzLnZlcnNpb25zXG4gICAgICAgICAgICAgICAgICAgJiYgZ2xvYmFsLnByb2Nlc3MudmVyc2lvbnMubm9kZSk7XG5cbi8qKlxuICogR2xvYmFsIG9iamVjdCByZWZlcmVuY2UuXG4gKiBAbWVtYmVyb2YgdXRpbFxuICogQHR5cGUge09iamVjdH1cbiAqL1xudXRpbC5nbG9iYWwgPSB1dGlsLmlzTm9kZSAmJiBnbG9iYWxcbiAgICAgICAgICAgfHwgdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3dcbiAgICAgICAgICAgfHwgdHlwZW9mIHNlbGYgICAhPT0gXCJ1bmRlZmluZWRcIiAmJiBzZWxmXG4gICAgICAgICAgIHx8IHRoaXM7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8taW52YWxpZC10aGlzXG5cbi8qKlxuICogQW4gaW1tdWFibGUgZW1wdHkgYXJyYXkuXG4gKiBAbWVtYmVyb2YgdXRpbFxuICogQHR5cGUge0FycmF5LjwqPn1cbiAqIEBjb25zdFxuICovXG51dGlsLmVtcHR5QXJyYXkgPSBPYmplY3QuZnJlZXplID8gT2JqZWN0LmZyZWV6ZShbXSkgOiAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyBbXTsgLy8gdXNlZCBvbiBwcm90b3R5cGVzXG5cbi8qKlxuICogQW4gaW1tdXRhYmxlIGVtcHR5IG9iamVjdC5cbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAY29uc3RcbiAqL1xudXRpbC5lbXB0eU9iamVjdCA9IE9iamVjdC5mcmVlemUgPyBPYmplY3QuZnJlZXplKHt9KSA6IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIHt9OyAvLyB1c2VkIG9uIHByb3RvdHlwZXNcblxuLyoqXG4gKiBUZXN0cyBpZiB0aGUgc3BlY2lmaWVkIHZhbHVlIGlzIGFuIGludGVnZXIuXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgdmFsdWUgaXMgYW4gaW50ZWdlclxuICovXG51dGlsLmlzSW50ZWdlciA9IE51bWJlci5pc0ludGVnZXIgfHwgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gZnVuY3Rpb24gaXNJbnRlZ2VyKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIiAmJiBpc0Zpbml0ZSh2YWx1ZSkgJiYgTWF0aC5mbG9vcih2YWx1ZSkgPT09IHZhbHVlO1xufTtcblxuLyoqXG4gKiBUZXN0cyBpZiB0aGUgc3BlY2lmaWVkIHZhbHVlIGlzIGEgc3RyaW5nLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSB2YWx1ZSBpcyBhIHN0cmluZ1xuICovXG51dGlsLmlzU3RyaW5nID0gZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiIHx8IHZhbHVlIGluc3RhbmNlb2YgU3RyaW5nO1xufTtcblxuLyoqXG4gKiBUZXN0cyBpZiB0aGUgc3BlY2lmaWVkIHZhbHVlIGlzIGEgbm9uLW51bGwgb2JqZWN0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSB2YWx1ZSBpcyBhIG5vbi1udWxsIG9iamVjdFxuICovXG51dGlsLmlzT2JqZWN0ID0gZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiO1xufTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBwcm9wZXJ0eSBvbiBhIG1lc3NhZ2UgaXMgY29uc2lkZXJlZCB0byBiZSBwcmVzZW50LlxuICogVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgdXRpbC5pc1NldH0uXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogUGxhaW4gb2JqZWN0IG9yIG1lc3NhZ2UgaW5zdGFuY2VcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wIFByb3BlcnR5IG5hbWVcbiAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgY29uc2lkZXJlZCB0byBiZSBwcmVzZW50LCBvdGhlcndpc2UgYGZhbHNlYFxuICovXG51dGlsLmlzc2V0ID1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBwcm9wZXJ0eSBvbiBhIG1lc3NhZ2UgaXMgY29uc2lkZXJlZCB0byBiZSBwcmVzZW50LlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBQbGFpbiBvYmplY3Qgb3IgbWVzc2FnZSBpbnN0YW5jZVxuICogQHBhcmFtIHtzdHJpbmd9IHByb3AgUHJvcGVydHkgbmFtZVxuICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiBjb25zaWRlcmVkIHRvIGJlIHByZXNlbnQsIG90aGVyd2lzZSBgZmFsc2VgXG4gKi9cbnV0aWwuaXNTZXQgPSBmdW5jdGlvbiBpc1NldChvYmosIHByb3ApIHtcbiAgICB2YXIgdmFsdWUgPSBvYmpbcHJvcF07XG4gICAgaWYgKHZhbHVlICE9IG51bGwgJiYgb2JqLmhhc093blByb3BlcnR5KHByb3ApKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcSwgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgKEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUubGVuZ3RoIDogT2JqZWN0LmtleXModmFsdWUpLmxlbmd0aCkgPiAwO1xuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogQW55IGNvbXBhdGlibGUgQnVmZmVyIGluc3RhbmNlLlxuICogVGhpcyBpcyBhIG1pbmltYWwgc3RhbmQtYWxvbmUgZGVmaW5pdGlvbiBvZiBhIEJ1ZmZlciBpbnN0YW5jZS4gVGhlIGFjdHVhbCB0eXBlIGlzIHRoYXQgZXhwb3J0ZWQgYnkgbm9kZSdzIHR5cGluZ3MuXG4gKiBAaW50ZXJmYWNlIEJ1ZmZlclxuICogQGV4dGVuZHMgVWludDhBcnJheVxuICovXG5cbi8qKlxuICogTm9kZSdzIEJ1ZmZlciBjbGFzcyBpZiBhdmFpbGFibGUuXG4gKiBAdHlwZSB7Q29uc3RydWN0b3I8QnVmZmVyPn1cbiAqL1xudXRpbC5CdWZmZXIgPSAoZnVuY3Rpb24oKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgdmFyIEJ1ZmZlciA9IHV0aWwuaW5xdWlyZShcImJ1ZmZlclwiKS5CdWZmZXI7XG4gICAgICAgIC8vIHJlZnVzZSB0byB1c2Ugbm9uLW5vZGUgYnVmZmVycyBpZiBub3QgZXhwbGljaXRseSBhc3NpZ25lZCAocGVyZiByZWFzb25zKTpcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5wcm90b3R5cGUudXRmOFdyaXRlID8gQnVmZmVyIDogLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gbnVsbDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn0pKCk7XG5cbi8vIEludGVybmFsIGFsaWFzIG9mIG9yIHBvbHlmdWxsIGZvciBCdWZmZXIuZnJvbS5cbnV0aWwuX0J1ZmZlcl9mcm9tID0gbnVsbDtcblxuLy8gSW50ZXJuYWwgYWxpYXMgb2Ygb3IgcG9seWZpbGwgZm9yIEJ1ZmZlci5hbGxvY1Vuc2FmZS5cbnV0aWwuX0J1ZmZlcl9hbGxvY1Vuc2FmZSA9IG51bGw7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBidWZmZXIgb2Ygd2hhdGV2ZXIgdHlwZSBzdXBwb3J0ZWQgYnkgdGhlIGVudmlyb25tZW50LlxuICogQHBhcmFtIHtudW1iZXJ8bnVtYmVyW119IFtzaXplT3JBcnJheT0wXSBCdWZmZXIgc2l6ZSBvciBudW1iZXIgYXJyYXlcbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fEJ1ZmZlcn0gQnVmZmVyXG4gKi9cbnV0aWwubmV3QnVmZmVyID0gZnVuY3Rpb24gbmV3QnVmZmVyKHNpemVPckFycmF5KSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICByZXR1cm4gdHlwZW9mIHNpemVPckFycmF5ID09PSBcIm51bWJlclwiXG4gICAgICAgID8gdXRpbC5CdWZmZXJcbiAgICAgICAgICAgID8gdXRpbC5fQnVmZmVyX2FsbG9jVW5zYWZlKHNpemVPckFycmF5KVxuICAgICAgICAgICAgOiBuZXcgdXRpbC5BcnJheShzaXplT3JBcnJheSlcbiAgICAgICAgOiB1dGlsLkJ1ZmZlclxuICAgICAgICAgICAgPyB1dGlsLl9CdWZmZXJfZnJvbShzaXplT3JBcnJheSlcbiAgICAgICAgICAgIDogdHlwZW9mIFVpbnQ4QXJyYXkgPT09IFwidW5kZWZpbmVkXCJcbiAgICAgICAgICAgICAgICA/IHNpemVPckFycmF5XG4gICAgICAgICAgICAgICAgOiBuZXcgVWludDhBcnJheShzaXplT3JBcnJheSk7XG59O1xuXG4vKipcbiAqIEFycmF5IGltcGxlbWVudGF0aW9uIHVzZWQgaW4gdGhlIGJyb3dzZXIuIGBVaW50OEFycmF5YCBpZiBzdXBwb3J0ZWQsIG90aGVyd2lzZSBgQXJyYXlgLlxuICogQHR5cGUge0NvbnN0cnVjdG9yPFVpbnQ4QXJyYXk+fVxuICovXG51dGlsLkFycmF5ID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09IFwidW5kZWZpbmVkXCIgPyBVaW50OEFycmF5IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIDogQXJyYXk7XG5cbi8qKlxuICogQW55IGNvbXBhdGlibGUgTG9uZyBpbnN0YW5jZS5cbiAqIFRoaXMgaXMgYSBtaW5pbWFsIHN0YW5kLWFsb25lIGRlZmluaXRpb24gb2YgYSBMb25nIGluc3RhbmNlLiBUaGUgYWN0dWFsIHR5cGUgaXMgdGhhdCBleHBvcnRlZCBieSBsb25nLmpzLlxuICogQGludGVyZmFjZSBMb25nXG4gKiBAcHJvcGVydHkge251bWJlcn0gbG93IExvdyBiaXRzXG4gKiBAcHJvcGVydHkge251bWJlcn0gaGlnaCBIaWdoIGJpdHNcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3RcbiAqL1xuXG4vKipcbiAqIExvbmcuanMncyBMb25nIGNsYXNzIGlmIGF2YWlsYWJsZS5cbiAqIEB0eXBlIHtDb25zdHJ1Y3RvcjxMb25nPn1cbiAqL1xudXRpbC5Mb25nID0gLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gdXRpbC5nbG9iYWwuZGNvZGVJTyAmJiAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyB1dGlsLmdsb2JhbC5kY29kZUlPLkxvbmdcbiAgICAgICAgIHx8IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIHV0aWwuZ2xvYmFsLkxvbmdcbiAgICAgICAgIHx8IHV0aWwuaW5xdWlyZShcImxvbmdcIik7XG5cbi8qKlxuICogUmVndWxhciBleHByZXNzaW9uIHVzZWQgdG8gdmVyaWZ5IDIgYml0IChgYm9vbGApIG1hcCBrZXlzLlxuICogQHR5cGUge1JlZ0V4cH1cbiAqIEBjb25zdFxuICovXG51dGlsLmtleTJSZSA9IC9edHJ1ZXxmYWxzZXwwfDEkLztcblxuLyoqXG4gKiBSZWd1bGFyIGV4cHJlc3Npb24gdXNlZCB0byB2ZXJpZnkgMzIgYml0IChgaW50MzJgIGV0Yy4pIG1hcCBrZXlzLlxuICogQHR5cGUge1JlZ0V4cH1cbiAqIEBjb25zdFxuICovXG51dGlsLmtleTMyUmUgPSAvXi0/KD86MHxbMS05XVswLTldKikkLztcblxuLyoqXG4gKiBSZWd1bGFyIGV4cHJlc3Npb24gdXNlZCB0byB2ZXJpZnkgNjQgYml0IChgaW50NjRgIGV0Yy4pIG1hcCBrZXlzLlxuICogQHR5cGUge1JlZ0V4cH1cbiAqIEBjb25zdFxuICovXG51dGlsLmtleTY0UmUgPSAvXig/OltcXFxceDAwLVxcXFx4ZmZdezh9fC0/KD86MHxbMS05XVswLTldKikpJC87XG5cbi8qKlxuICogQ29udmVydHMgYSBudW1iZXIgb3IgbG9uZyB0byBhbiA4IGNoYXJhY3RlcnMgbG9uZyBoYXNoIHN0cmluZy5cbiAqIEBwYXJhbSB7TG9uZ3xudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIGNvbnZlcnRcbiAqIEByZXR1cm5zIHtzdHJpbmd9IEhhc2hcbiAqL1xudXRpbC5sb25nVG9IYXNoID0gZnVuY3Rpb24gbG9uZ1RvSGFzaCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZVxuICAgICAgICA/IHV0aWwuTG9uZ0JpdHMuZnJvbSh2YWx1ZSkudG9IYXNoKClcbiAgICAgICAgOiB1dGlsLkxvbmdCaXRzLnplcm9IYXNoO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhbiA4IGNoYXJhY3RlcnMgbG9uZyBoYXNoIHN0cmluZyB0byBhIGxvbmcgb3IgbnVtYmVyLlxuICogQHBhcmFtIHtzdHJpbmd9IGhhc2ggSGFzaFxuICogQHBhcmFtIHtib29sZWFufSBbdW5zaWduZWQ9ZmFsc2VdIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90XG4gKiBAcmV0dXJucyB7TG9uZ3xudW1iZXJ9IE9yaWdpbmFsIHZhbHVlXG4gKi9cbnV0aWwubG9uZ0Zyb21IYXNoID0gZnVuY3Rpb24gbG9uZ0Zyb21IYXNoKGhhc2gsIHVuc2lnbmVkKSB7XG4gICAgdmFyIGJpdHMgPSB1dGlsLkxvbmdCaXRzLmZyb21IYXNoKGhhc2gpO1xuICAgIGlmICh1dGlsLkxvbmcpXG4gICAgICAgIHJldHVybiB1dGlsLkxvbmcuZnJvbUJpdHMoYml0cy5sbywgYml0cy5oaSwgdW5zaWduZWQpO1xuICAgIHJldHVybiBiaXRzLnRvTnVtYmVyKEJvb2xlYW4odW5zaWduZWQpKTtcbn07XG5cbi8qKlxuICogTWVyZ2VzIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBzb3VyY2Ugb2JqZWN0IGludG8gdGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBtZW1iZXJvZiB1dGlsXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBkc3QgRGVzdGluYXRpb24gb2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBzcmMgU291cmNlIG9iamVjdFxuICogQHBhcmFtIHtib29sZWFufSBbaWZOb3RTZXQ9ZmFsc2VdIE1lcmdlcyBvbmx5IGlmIHRoZSBrZXkgaXMgbm90IGFscmVhZHkgc2V0XG4gKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IERlc3RpbmF0aW9uIG9iamVjdFxuICovXG5mdW5jdGlvbiBtZXJnZShkc3QsIHNyYywgaWZOb3RTZXQpIHsgLy8gdXNlZCBieSBjb252ZXJ0ZXJzXG4gICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHNyYyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSlcbiAgICAgICAgaWYgKGRzdFtrZXlzW2ldXSA9PT0gdW5kZWZpbmVkIHx8ICFpZk5vdFNldClcbiAgICAgICAgICAgIGRzdFtrZXlzW2ldXSA9IHNyY1trZXlzW2ldXTtcbiAgICByZXR1cm4gZHN0O1xufVxuXG51dGlsLm1lcmdlID0gbWVyZ2U7XG5cbi8qKlxuICogQ29udmVydHMgdGhlIGZpcnN0IGNoYXJhY3RlciBvZiBhIHN0cmluZyB0byBsb3dlciBjYXNlLlxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciBTdHJpbmcgdG8gY29udmVydFxuICogQHJldHVybnMge3N0cmluZ30gQ29udmVydGVkIHN0cmluZ1xuICovXG51dGlsLmxjRmlyc3QgPSBmdW5jdGlvbiBsY0ZpcnN0KHN0cikge1xuICAgIHJldHVybiBzdHIuY2hhckF0KDApLnRvTG93ZXJDYXNlKCkgKyBzdHIuc3Vic3RyaW5nKDEpO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY3VzdG9tIGVycm9yIGNvbnN0cnVjdG9yLlxuICogQG1lbWJlcm9mIHV0aWxcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIEVycm9yIG5hbWVcbiAqIEByZXR1cm5zIHtDb25zdHJ1Y3RvcjxFcnJvcj59IEN1c3RvbSBlcnJvciBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBuZXdFcnJvcihuYW1lKSB7XG5cbiAgICBmdW5jdGlvbiBDdXN0b21FcnJvcihtZXNzYWdlLCBwcm9wZXJ0aWVzKSB7XG5cbiAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEN1c3RvbUVycm9yKSlcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ3VzdG9tRXJyb3IobWVzc2FnZSwgcHJvcGVydGllcyk7XG5cbiAgICAgICAgLy8gRXJyb3IuY2FsbCh0aGlzLCBtZXNzYWdlKTtcbiAgICAgICAgLy8gXiBqdXN0IHJldHVybnMgYSBuZXcgZXJyb3IgaW5zdGFuY2UgYmVjYXVzZSB0aGUgY3RvciBjYW4gYmUgY2FsbGVkIGFzIGEgZnVuY3Rpb25cblxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtZXNzYWdlXCIsIHsgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1lc3NhZ2U7IH0gfSk7XG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSAvLyBub2RlXG4gICAgICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBDdXN0b21FcnJvcik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN0YWNrXCIsIHsgdmFsdWU6IG5ldyBFcnJvcigpLnN0YWNrIHx8IFwiXCIgfSk7XG5cbiAgICAgICAgaWYgKHByb3BlcnRpZXMpXG4gICAgICAgICAgICBtZXJnZSh0aGlzLCBwcm9wZXJ0aWVzKTtcbiAgICB9XG5cbiAgICBDdXN0b21FcnJvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSwge1xuICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgICAgdmFsdWU6IEN1c3RvbUVycm9yLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgfSxcbiAgICAgICAgbmFtZToge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7IHJldHVybiBuYW1lOyB9LFxuICAgICAgICAgICAgc2V0OiB1bmRlZmluZWQsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIC8vIGNvbmZpZ3VyYWJsZTogZmFsc2Ugd291bGQgYWNjdXJhdGVseSBwcmVzZXJ2ZSB0aGUgYmVoYXZpb3Igb2ZcbiAgICAgICAgICAgIC8vIHRoZSBvcmlnaW5hbCwgYnV0IEknbSBndWVzc2luZyB0aGF0IHdhcyBub3QgaW50ZW50aW9uYWwuXG4gICAgICAgICAgICAvLyBGb3IgYW4gYWN0dWFsIGVycm9yIHN1YmNsYXNzLCB0aGlzIHByb3BlcnR5IHdvdWxkXG4gICAgICAgICAgICAvLyBiZSBjb25maWd1cmFibGUuXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIH0sXG4gICAgICAgIHRvU3RyaW5nOiB7XG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoKSB7IHJldHVybiB0aGlzLm5hbWUgKyBcIjogXCIgKyB0aGlzLm1lc3NhZ2U7IH0sXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB9LFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIEN1c3RvbUVycm9yO1xufVxuXG51dGlsLm5ld0Vycm9yID0gbmV3RXJyb3I7XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyBwcm90b2NvbCBlcnJvci5cbiAqIEBjbGFzc2Rlc2MgRXJyb3Igc3ViY2xhc3MgaW5kaWNhdGluZyBhIHByb3RvY29sIHNwZWNpZmMgZXJyb3IuXG4gKiBAbWVtYmVyb2YgdXRpbFxuICogQGV4dGVuZHMgRXJyb3JcbiAqIEB0ZW1wbGF0ZSBUIGV4dGVuZHMgTWVzc2FnZTxUPlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZSBFcnJvciBtZXNzYWdlXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBbcHJvcGVydGllc10gQWRkaXRpb25hbCBwcm9wZXJ0aWVzXG4gKiBAZXhhbXBsZVxuICogdHJ5IHtcbiAqICAgICBNeU1lc3NhZ2UuZGVjb2RlKHNvbWVCdWZmZXIpOyAvLyB0aHJvd3MgaWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gKiB9IGNhdGNoIChlKSB7XG4gKiAgICAgaWYgKGUgaW5zdGFuY2VvZiBQcm90b2NvbEVycm9yICYmIGUuaW5zdGFuY2UpXG4gKiAgICAgICAgIGNvbnNvbGUubG9nKFwiZGVjb2RlZCBzbyBmYXI6IFwiICsgSlNPTi5zdHJpbmdpZnkoZS5pbnN0YW5jZSkpO1xuICogfVxuICovXG51dGlsLlByb3RvY29sRXJyb3IgPSBuZXdFcnJvcihcIlByb3RvY29sRXJyb3JcIik7XG5cbi8qKlxuICogU28gZmFyIGRlY29kZWQgbWVzc2FnZSBpbnN0YW5jZS5cbiAqIEBuYW1lIHV0aWwuUHJvdG9jb2xFcnJvciNpbnN0YW5jZVxuICogQHR5cGUge01lc3NhZ2U8VD59XG4gKi9cblxuLyoqXG4gKiBBIE9uZU9mIGdldHRlciBhcyByZXR1cm5lZCBieSB7QGxpbmsgdXRpbC5vbmVPZkdldHRlcn0uXG4gKiBAdHlwZWRlZiBPbmVPZkdldHRlclxuICogQHR5cGUge2Z1bmN0aW9ufVxuICogQHJldHVybnMge3N0cmluZ3x1bmRlZmluZWR9IFNldCBmaWVsZCBuYW1lLCBpZiBhbnlcbiAqL1xuXG4vKipcbiAqIEJ1aWxkcyBhIGdldHRlciBmb3IgYSBvbmVvZidzIHByZXNlbnQgZmllbGQgbmFtZS5cbiAqIEBwYXJhbSB7c3RyaW5nW119IGZpZWxkTmFtZXMgRmllbGQgbmFtZXNcbiAqIEByZXR1cm5zIHtPbmVPZkdldHRlcn0gVW5ib3VuZCBnZXR0ZXJcbiAqL1xudXRpbC5vbmVPZkdldHRlciA9IGZ1bmN0aW9uIGdldE9uZU9mKGZpZWxkTmFtZXMpIHtcbiAgICB2YXIgZmllbGRNYXAgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpZWxkTmFtZXMubGVuZ3RoOyArK2kpXG4gICAgICAgIGZpZWxkTWFwW2ZpZWxkTmFtZXNbaV1dID0gMTtcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8dW5kZWZpbmVkfSBTZXQgZmllbGQgbmFtZSwgaWYgYW55XG4gICAgICogQHRoaXMgT2JqZWN0XG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuICAgIHJldHVybiBmdW5jdGlvbigpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjb25zaXN0ZW50LXJldHVyblxuICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXModGhpcyksIGkgPSBrZXlzLmxlbmd0aCAtIDE7IGkgPiAtMTsgLS1pKVxuICAgICAgICAgICAgaWYgKGZpZWxkTWFwW2tleXNbaV1dID09PSAxICYmIHRoaXNba2V5c1tpXV0gIT09IHVuZGVmaW5lZCAmJiB0aGlzW2tleXNbaV1dICE9PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiBrZXlzW2ldO1xuICAgIH07XG59O1xuXG4vKipcbiAqIEEgT25lT2Ygc2V0dGVyIGFzIHJldHVybmVkIGJ5IHtAbGluayB1dGlsLm9uZU9mU2V0dGVyfS5cbiAqIEB0eXBlZGVmIE9uZU9mU2V0dGVyXG4gKiBAdHlwZSB7ZnVuY3Rpb259XG4gKiBAcGFyYW0ge3N0cmluZ3x1bmRlZmluZWR9IHZhbHVlIEZpZWxkIG5hbWVcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKi9cblxuLyoqXG4gKiBCdWlsZHMgYSBzZXR0ZXIgZm9yIGEgb25lb2YncyBwcmVzZW50IGZpZWxkIG5hbWUuXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBmaWVsZE5hbWVzIEZpZWxkIG5hbWVzXG4gKiBAcmV0dXJucyB7T25lT2ZTZXR0ZXJ9IFVuYm91bmQgc2V0dGVyXG4gKi9cbnV0aWwub25lT2ZTZXR0ZXIgPSBmdW5jdGlvbiBzZXRPbmVPZihmaWVsZE5hbWVzKSB7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBGaWVsZCBuYW1lXG4gICAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICAgKiBAdGhpcyBPYmplY3RcbiAgICAgKiBAaWdub3JlXG4gICAgICovXG4gICAgcmV0dXJuIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWVsZE5hbWVzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgaWYgKGZpZWxkTmFtZXNbaV0gIT09IG5hbWUpXG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXNbZmllbGROYW1lc1tpXV07XG4gICAgfTtcbn07XG5cbi8qKlxuICogRGVmYXVsdCBjb252ZXJzaW9uIG9wdGlvbnMgdXNlZCBmb3Ige0BsaW5rIE1lc3NhZ2UjdG9KU09OfSBpbXBsZW1lbnRhdGlvbnMuXG4gKlxuICogVGhlc2Ugb3B0aW9ucyBhcmUgY2xvc2UgdG8gcHJvdG8zJ3MgSlNPTiBtYXBwaW5nIHdpdGggdGhlIGV4Y2VwdGlvbiB0aGF0IGludGVybmFsIHR5cGVzIGxpa2UgQW55IGFyZSBoYW5kbGVkIGp1c3QgbGlrZSBtZXNzYWdlcy4gTW9yZSBwcmVjaXNlbHk6XG4gKlxuICogLSBMb25ncyBiZWNvbWUgc3RyaW5nc1xuICogLSBFbnVtcyBiZWNvbWUgc3RyaW5nIGtleXNcbiAqIC0gQnl0ZXMgYmVjb21lIGJhc2U2NCBlbmNvZGVkIHN0cmluZ3NcbiAqIC0gKFN1Yi0pTWVzc2FnZXMgYmVjb21lIHBsYWluIG9iamVjdHNcbiAqIC0gTWFwcyBiZWNvbWUgcGxhaW4gb2JqZWN0cyB3aXRoIGFsbCBzdHJpbmcga2V5c1xuICogLSBSZXBlYXRlZCBmaWVsZHMgYmVjb21lIGFycmF5c1xuICogLSBOYU4gYW5kIEluZmluaXR5IGZvciBmbG9hdCBhbmQgZG91YmxlIGZpZWxkcyBiZWNvbWUgc3RyaW5nc1xuICpcbiAqIEB0eXBlIHtJQ29udmVyc2lvbk9wdGlvbnN9XG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL3Byb3RvY29sLWJ1ZmZlcnMvZG9jcy9wcm90bzM/aGw9ZW4janNvblxuICovXG51dGlsLnRvSlNPTk9wdGlvbnMgPSB7XG4gICAgbG9uZ3M6IFN0cmluZyxcbiAgICBlbnVtczogU3RyaW5nLFxuICAgIGJ5dGVzOiBTdHJpbmcsXG4gICAganNvbjogdHJ1ZVxufTtcblxuLy8gU2V0cyB1cCBidWZmZXIgdXRpbGl0eSBhY2NvcmRpbmcgdG8gdGhlIGVudmlyb25tZW50IChjYWxsZWQgaW4gaW5kZXgtbWluaW1hbClcbnV0aWwuX2NvbmZpZ3VyZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBCdWZmZXIgPSB1dGlsLkJ1ZmZlcjtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIUJ1ZmZlcikge1xuICAgICAgICB1dGlsLl9CdWZmZXJfZnJvbSA9IHV0aWwuX0J1ZmZlcl9hbGxvY1Vuc2FmZSA9IG51bGw7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gYmVjYXVzZSBub2RlIDQueCBidWZmZXJzIGFyZSBpbmNvbXBhdGlibGUgJiBpbW11dGFibGVcbiAgICAvLyBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9kY29kZUlPL3Byb3RvYnVmLmpzL3B1bGwvNjY1XG4gICAgdXRpbC5fQnVmZmVyX2Zyb20gPSBCdWZmZXIuZnJvbSAhPT0gVWludDhBcnJheS5mcm9tICYmIEJ1ZmZlci5mcm9tIHx8XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIGZ1bmN0aW9uIEJ1ZmZlcl9mcm9tKHZhbHVlLCBlbmNvZGluZykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXIodmFsdWUsIGVuY29kaW5nKTtcbiAgICAgICAgfTtcbiAgICB1dGlsLl9CdWZmZXJfYWxsb2NVbnNhZmUgPSBCdWZmZXIuYWxsb2NVbnNhZmUgfHxcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgZnVuY3Rpb24gQnVmZmVyX2FsbG9jVW5zYWZlKHNpemUpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQnVmZmVyKHNpemUpO1xuICAgICAgICB9O1xufTtcbiIsICJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gV3JpdGVyO1xuXG52YXIgdXRpbCAgICAgID0gcmVxdWlyZShcIi4vdXRpbC9taW5pbWFsXCIpO1xuXG52YXIgQnVmZmVyV3JpdGVyOyAvLyBjeWNsaWNcblxudmFyIExvbmdCaXRzICA9IHV0aWwuTG9uZ0JpdHMsXG4gICAgYmFzZTY0ICAgID0gdXRpbC5iYXNlNjQsXG4gICAgdXRmOCAgICAgID0gdXRpbC51dGY4O1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgd3JpdGVyIG9wZXJhdGlvbiBpbnN0YW5jZS5cbiAqIEBjbGFzc2Rlc2MgU2NoZWR1bGVkIHdyaXRlciBvcGVyYXRpb24uXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKiwgVWludDhBcnJheSwgbnVtYmVyKX0gZm4gRnVuY3Rpb24gdG8gY2FsbFxuICogQHBhcmFtIHtudW1iZXJ9IGxlbiBWYWx1ZSBieXRlIGxlbmd0aFxuICogQHBhcmFtIHsqfSB2YWwgVmFsdWUgdG8gd3JpdGVcbiAqIEBpZ25vcmVcbiAqL1xuZnVuY3Rpb24gT3AoZm4sIGxlbiwgdmFsKSB7XG5cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiB0byBjYWxsLlxuICAgICAqIEB0eXBlIHtmdW5jdGlvbihVaW50OEFycmF5LCBudW1iZXIsICopfVxuICAgICAqL1xuICAgIHRoaXMuZm4gPSBmbjtcblxuICAgIC8qKlxuICAgICAqIFZhbHVlIGJ5dGUgbGVuZ3RoLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5sZW4gPSBsZW47XG5cbiAgICAvKipcbiAgICAgKiBOZXh0IG9wZXJhdGlvbi5cbiAgICAgKiBAdHlwZSB7V3JpdGVyLk9wfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLm5leHQgPSB1bmRlZmluZWQ7XG5cbiAgICAvKipcbiAgICAgKiBWYWx1ZSB0byB3cml0ZS5cbiAgICAgKiBAdHlwZSB7Kn1cbiAgICAgKi9cbiAgICB0aGlzLnZhbCA9IHZhbDsgLy8gdHlwZSB2YXJpZXNcbn1cblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIG5vb3AoKSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWVtcHR5LWZ1bmN0aW9uXG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyB3cml0ZXIgc3RhdGUgaW5zdGFuY2UuXG4gKiBAY2xhc3NkZXNjIENvcGllZCB3cml0ZXIgc3RhdGUuXG4gKiBAbWVtYmVyb2YgV3JpdGVyXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7V3JpdGVyfSB3cml0ZXIgV3JpdGVyIHRvIGNvcHkgc3RhdGUgZnJvbVxuICogQGlnbm9yZVxuICovXG5mdW5jdGlvbiBTdGF0ZSh3cml0ZXIpIHtcblxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgaGVhZC5cbiAgICAgKiBAdHlwZSB7V3JpdGVyLk9wfVxuICAgICAqL1xuICAgIHRoaXMuaGVhZCA9IHdyaXRlci5oZWFkO1xuXG4gICAgLyoqXG4gICAgICogQ3VycmVudCB0YWlsLlxuICAgICAqIEB0eXBlIHtXcml0ZXIuT3B9XG4gICAgICovXG4gICAgdGhpcy50YWlsID0gd3JpdGVyLnRhaWw7XG5cbiAgICAvKipcbiAgICAgKiBDdXJyZW50IGJ1ZmZlciBsZW5ndGguXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmxlbiA9IHdyaXRlci5sZW47XG5cbiAgICAvKipcbiAgICAgKiBOZXh0IHN0YXRlLlxuICAgICAqIEB0eXBlIHtTdGF0ZXxudWxsfVxuICAgICAqL1xuICAgIHRoaXMubmV4dCA9IHdyaXRlci5zdGF0ZXM7XG59XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyB3cml0ZXIgaW5zdGFuY2UuXG4gKiBAY2xhc3NkZXNjIFdpcmUgZm9ybWF0IHdyaXRlciB1c2luZyBgVWludDhBcnJheWAgaWYgYXZhaWxhYmxlLCBvdGhlcndpc2UgYEFycmF5YC5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBXcml0ZXIoKSB7XG5cbiAgICAvKipcbiAgICAgKiBDdXJyZW50IGxlbmd0aC5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubGVuID0gMDtcblxuICAgIC8qKlxuICAgICAqIE9wZXJhdGlvbnMgaGVhZC5cbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuICAgIHRoaXMuaGVhZCA9IG5ldyBPcChub29wLCAwLCAwKTtcblxuICAgIC8qKlxuICAgICAqIE9wZXJhdGlvbnMgdGFpbFxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG4gICAgdGhpcy50YWlsID0gdGhpcy5oZWFkO1xuXG4gICAgLyoqXG4gICAgICogTGlua2VkIGZvcmtlZCBzdGF0ZXMuXG4gICAgICogQHR5cGUge09iamVjdHxudWxsfVxuICAgICAqL1xuICAgIHRoaXMuc3RhdGVzID0gbnVsbDtcblxuICAgIC8vIFdoZW4gYSB2YWx1ZSBpcyB3cml0dGVuLCB0aGUgd3JpdGVyIGNhbGN1bGF0ZXMgaXRzIGJ5dGUgbGVuZ3RoIGFuZCBwdXRzIGl0IGludG8gYSBsaW5rZWRcbiAgICAvLyBsaXN0IG9mIG9wZXJhdGlvbnMgdG8gcGVyZm9ybSB3aGVuIGZpbmlzaCgpIGlzIGNhbGxlZC4gVGhpcyBib3RoIGFsbG93cyB1cyB0byBhbGxvY2F0ZVxuICAgIC8vIGJ1ZmZlcnMgb2YgdGhlIGV4YWN0IHJlcXVpcmVkIHNpemUgYW5kIHJlZHVjZXMgdGhlIGFtb3VudCBvZiB3b3JrIHdlIGhhdmUgdG8gZG8gY29tcGFyZWRcbiAgICAvLyB0byBmaXJzdCBjYWxjdWxhdGluZyBvdmVyIG9iamVjdHMgYW5kIHRoZW4gZW5jb2Rpbmcgb3ZlciBvYmplY3RzLiBJbiBvdXIgY2FzZSwgdGhlIGVuY29kaW5nXG4gICAgLy8gcGFydCBpcyBqdXN0IGEgbGlua2VkIGxpc3Qgd2FsayBjYWxsaW5nIG9wZXJhdGlvbnMgd2l0aCBhbHJlYWR5IHByZXBhcmVkIHZhbHVlcy5cbn1cblxudmFyIGNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgICByZXR1cm4gdXRpbC5CdWZmZXJcbiAgICAgICAgPyBmdW5jdGlvbiBjcmVhdGVfYnVmZmVyX3NldHVwKCkge1xuICAgICAgICAgICAgcmV0dXJuIChXcml0ZXIuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlX2J1ZmZlcigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJ1ZmZlcldyaXRlcigpO1xuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICA6IGZ1bmN0aW9uIGNyZWF0ZV9hcnJheSgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgV3JpdGVyKCk7XG4gICAgICAgIH07XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgd3JpdGVyLlxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7QnVmZmVyV3JpdGVyfFdyaXRlcn0gQSB7QGxpbmsgQnVmZmVyV3JpdGVyfSB3aGVuIEJ1ZmZlcnMgYXJlIHN1cHBvcnRlZCwgb3RoZXJ3aXNlIGEge0BsaW5rIFdyaXRlcn1cbiAqL1xuV3JpdGVyLmNyZWF0ZSA9IGNyZWF0ZSgpO1xuXG4vKipcbiAqIEFsbG9jYXRlcyBhIGJ1ZmZlciBvZiB0aGUgc3BlY2lmaWVkIHNpemUuXG4gKiBAcGFyYW0ge251bWJlcn0gc2l6ZSBCdWZmZXIgc2l6ZVxuICogQHJldHVybnMge1VpbnQ4QXJyYXl9IEJ1ZmZlclxuICovXG5Xcml0ZXIuYWxsb2MgPSBmdW5jdGlvbiBhbGxvYyhzaXplKSB7XG4gICAgcmV0dXJuIG5ldyB1dGlsLkFycmF5KHNpemUpO1xufTtcblxuLy8gVXNlIFVpbnQ4QXJyYXkgYnVmZmVyIHBvb2wgaW4gdGhlIGJyb3dzZXIsIGp1c3QgbGlrZSBub2RlIGRvZXMgd2l0aCBidWZmZXJzXG4vKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuaWYgKHV0aWwuQXJyYXkgIT09IEFycmF5KVxuICAgIFdyaXRlci5hbGxvYyA9IHV0aWwucG9vbChXcml0ZXIuYWxsb2MsIHV0aWwuQXJyYXkucHJvdG90eXBlLnN1YmFycmF5KTtcblxuLyoqXG4gKiBQdXNoZXMgYSBuZXcgb3BlcmF0aW9uIHRvIHRoZSBxdWV1ZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oVWludDhBcnJheSwgbnVtYmVyLCAqKX0gZm4gRnVuY3Rpb24gdG8gY2FsbFxuICogQHBhcmFtIHtudW1iZXJ9IGxlbiBWYWx1ZSBieXRlIGxlbmd0aFxuICogQHBhcmFtIHtudW1iZXJ9IHZhbCBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKiBAcHJpdmF0ZVxuICovXG5Xcml0ZXIucHJvdG90eXBlLl9wdXNoID0gZnVuY3Rpb24gcHVzaChmbiwgbGVuLCB2YWwpIHtcbiAgICB0aGlzLnRhaWwgPSB0aGlzLnRhaWwubmV4dCA9IG5ldyBPcChmbiwgbGVuLCB2YWwpO1xuICAgIHRoaXMubGVuICs9IGxlbjtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIHdyaXRlQnl0ZSh2YWwsIGJ1ZiwgcG9zKSB7XG4gICAgYnVmW3Bvc10gPSB2YWwgJiAyNTU7XG59XG5cbmZ1bmN0aW9uIHdyaXRlVmFyaW50MzIodmFsLCBidWYsIHBvcykge1xuICAgIHdoaWxlICh2YWwgPiAxMjcpIHtcbiAgICAgICAgYnVmW3BvcysrXSA9IHZhbCAmIDEyNyB8IDEyODtcbiAgICAgICAgdmFsID4+Pj0gNztcbiAgICB9XG4gICAgYnVmW3Bvc10gPSB2YWw7XG59XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyB2YXJpbnQgd3JpdGVyIG9wZXJhdGlvbiBpbnN0YW5jZS5cbiAqIEBjbGFzc2Rlc2MgU2NoZWR1bGVkIHZhcmludCB3cml0ZXIgb3BlcmF0aW9uLlxuICogQGV4dGVuZHMgT3BcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtudW1iZXJ9IGxlbiBWYWx1ZSBieXRlIGxlbmd0aFxuICogQHBhcmFtIHtudW1iZXJ9IHZhbCBWYWx1ZSB0byB3cml0ZVxuICogQGlnbm9yZVxuICovXG5mdW5jdGlvbiBWYXJpbnRPcChsZW4sIHZhbCkge1xuICAgIHRoaXMubGVuID0gbGVuO1xuICAgIHRoaXMubmV4dCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnZhbCA9IHZhbDtcbn1cblxuVmFyaW50T3AucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShPcC5wcm90b3R5cGUpO1xuVmFyaW50T3AucHJvdG90eXBlLmZuID0gd3JpdGVWYXJpbnQzMjtcblxuLyoqXG4gKiBXcml0ZXMgYW4gdW5zaWduZWQgMzIgYml0IHZhbHVlIGFzIGEgdmFyaW50LlxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS51aW50MzIgPSBmdW5jdGlvbiB3cml0ZV91aW50MzIodmFsdWUpIHtcbiAgICAvLyBoZXJlLCB0aGUgY2FsbCB0byB0aGlzLnB1c2ggaGFzIGJlZW4gaW5saW5lZCBhbmQgYSB2YXJpbnQgc3BlY2lmaWMgT3Agc3ViY2xhc3MgaXMgdXNlZC5cbiAgICAvLyB1aW50MzIgaXMgYnkgZmFyIHRoZSBtb3N0IGZyZXF1ZW50bHkgdXNlZCBvcGVyYXRpb24gYW5kIGJlbmVmaXRzIHNpZ25pZmljYW50bHkgZnJvbSB0aGlzLlxuICAgIHRoaXMubGVuICs9ICh0aGlzLnRhaWwgPSB0aGlzLnRhaWwubmV4dCA9IG5ldyBWYXJpbnRPcChcbiAgICAgICAgKHZhbHVlID0gdmFsdWUgPj4+IDApXG4gICAgICAgICAgICAgICAgPCAxMjggICAgICAgPyAxXG4gICAgICAgIDogdmFsdWUgPCAxNjM4NCAgICAgPyAyXG4gICAgICAgIDogdmFsdWUgPCAyMDk3MTUyICAgPyAzXG4gICAgICAgIDogdmFsdWUgPCAyNjg0MzU0NTYgPyA0XG4gICAgICAgIDogICAgICAgICAgICAgICAgICAgICA1LFxuICAgIHZhbHVlKSkubGVuO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBXcml0ZXMgYSBzaWduZWQgMzIgYml0IHZhbHVlIGFzIGEgdmFyaW50LlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICovXG5Xcml0ZXIucHJvdG90eXBlLmludDMyID0gZnVuY3Rpb24gd3JpdGVfaW50MzIodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPCAwXG4gICAgICAgID8gdGhpcy5fcHVzaCh3cml0ZVZhcmludDY0LCAxMCwgTG9uZ0JpdHMuZnJvbU51bWJlcih2YWx1ZSkpIC8vIDEwIGJ5dGVzIHBlciBzcGVjXG4gICAgICAgIDogdGhpcy51aW50MzIodmFsdWUpO1xufTtcblxuLyoqXG4gKiBXcml0ZXMgYSAzMiBiaXQgdmFsdWUgYXMgYSB2YXJpbnQsIHppZy16YWcgZW5jb2RlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKi9cbldyaXRlci5wcm90b3R5cGUuc2ludDMyID0gZnVuY3Rpb24gd3JpdGVfc2ludDMyKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMudWludDMyKCh2YWx1ZSA8PCAxIF4gdmFsdWUgPj4gMzEpID4+PiAwKTtcbn07XG5cbmZ1bmN0aW9uIHdyaXRlVmFyaW50NjQodmFsLCBidWYsIHBvcykge1xuICAgIHdoaWxlICh2YWwuaGkpIHtcbiAgICAgICAgYnVmW3BvcysrXSA9IHZhbC5sbyAmIDEyNyB8IDEyODtcbiAgICAgICAgdmFsLmxvID0gKHZhbC5sbyA+Pj4gNyB8IHZhbC5oaSA8PCAyNSkgPj4+IDA7XG4gICAgICAgIHZhbC5oaSA+Pj49IDc7XG4gICAgfVxuICAgIHdoaWxlICh2YWwubG8gPiAxMjcpIHtcbiAgICAgICAgYnVmW3BvcysrXSA9IHZhbC5sbyAmIDEyNyB8IDEyODtcbiAgICAgICAgdmFsLmxvID0gdmFsLmxvID4+PiA3O1xuICAgIH1cbiAgICBidWZbcG9zKytdID0gdmFsLmxvO1xufVxuXG4vKipcbiAqIFdyaXRlcyBhbiB1bnNpZ25lZCA2NCBiaXQgdmFsdWUgYXMgYSB2YXJpbnQuXG4gKiBAcGFyYW0ge0xvbmd8bnVtYmVyfHN0cmluZ30gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBgdmFsdWVgIGlzIGEgc3RyaW5nIGFuZCBubyBsb25nIGxpYnJhcnkgaXMgcHJlc2VudC5cbiAqL1xuV3JpdGVyLnByb3RvdHlwZS51aW50NjQgPSBmdW5jdGlvbiB3cml0ZV91aW50NjQodmFsdWUpIHtcbiAgICB2YXIgYml0cyA9IExvbmdCaXRzLmZyb20odmFsdWUpO1xuICAgIHJldHVybiB0aGlzLl9wdXNoKHdyaXRlVmFyaW50NjQsIGJpdHMubGVuZ3RoKCksIGJpdHMpO1xufTtcblxuLyoqXG4gKiBXcml0ZXMgYSBzaWduZWQgNjQgYml0IHZhbHVlIGFzIGEgdmFyaW50LlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0xvbmd8bnVtYmVyfHN0cmluZ30gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBgdmFsdWVgIGlzIGEgc3RyaW5nIGFuZCBubyBsb25nIGxpYnJhcnkgaXMgcHJlc2VudC5cbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5pbnQ2NCA9IFdyaXRlci5wcm90b3R5cGUudWludDY0O1xuXG4vKipcbiAqIFdyaXRlcyBhIHNpZ25lZCA2NCBiaXQgdmFsdWUgYXMgYSB2YXJpbnQsIHppZy16YWcgZW5jb2RlZC5cbiAqIEBwYXJhbSB7TG9uZ3xudW1iZXJ8c3RyaW5nfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGB2YWx1ZWAgaXMgYSBzdHJpbmcgYW5kIG5vIGxvbmcgbGlicmFyeSBpcyBwcmVzZW50LlxuICovXG5Xcml0ZXIucHJvdG90eXBlLnNpbnQ2NCA9IGZ1bmN0aW9uIHdyaXRlX3NpbnQ2NCh2YWx1ZSkge1xuICAgIHZhciBiaXRzID0gTG9uZ0JpdHMuZnJvbSh2YWx1ZSkuenpFbmNvZGUoKTtcbiAgICByZXR1cm4gdGhpcy5fcHVzaCh3cml0ZVZhcmludDY0LCBiaXRzLmxlbmd0aCgpLCBiaXRzKTtcbn07XG5cbi8qKlxuICogV3JpdGVzIGEgYm9vbGlzaCB2YWx1ZSBhcyBhIHZhcmludC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICovXG5Xcml0ZXIucHJvdG90eXBlLmJvb2wgPSBmdW5jdGlvbiB3cml0ZV9ib29sKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuX3B1c2god3JpdGVCeXRlLCAxLCB2YWx1ZSA/IDEgOiAwKTtcbn07XG5cbmZ1bmN0aW9uIHdyaXRlRml4ZWQzMih2YWwsIGJ1ZiwgcG9zKSB7XG4gICAgYnVmW3BvcyAgICBdID0gIHZhbCAgICAgICAgICYgMjU1O1xuICAgIGJ1Zltwb3MgKyAxXSA9ICB2YWwgPj4+IDggICAmIDI1NTtcbiAgICBidWZbcG9zICsgMl0gPSAgdmFsID4+PiAxNiAgJiAyNTU7XG4gICAgYnVmW3BvcyArIDNdID0gIHZhbCA+Pj4gMjQ7XG59XG5cbi8qKlxuICogV3JpdGVzIGFuIHVuc2lnbmVkIDMyIGJpdCB2YWx1ZSBhcyBmaXhlZCAzMiBiaXRzLlxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5maXhlZDMyID0gZnVuY3Rpb24gd3JpdGVfZml4ZWQzMih2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLl9wdXNoKHdyaXRlRml4ZWQzMiwgNCwgdmFsdWUgPj4+IDApO1xufTtcblxuLyoqXG4gKiBXcml0ZXMgYSBzaWduZWQgMzIgYml0IHZhbHVlIGFzIGZpeGVkIDMyIGJpdHMuXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKi9cbldyaXRlci5wcm90b3R5cGUuc2ZpeGVkMzIgPSBXcml0ZXIucHJvdG90eXBlLmZpeGVkMzI7XG5cbi8qKlxuICogV3JpdGVzIGFuIHVuc2lnbmVkIDY0IGJpdCB2YWx1ZSBhcyBmaXhlZCA2NCBiaXRzLlxuICogQHBhcmFtIHtMb25nfG51bWJlcnxzdHJpbmd9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYHZhbHVlYCBpcyBhIHN0cmluZyBhbmQgbm8gbG9uZyBsaWJyYXJ5IGlzIHByZXNlbnQuXG4gKi9cbldyaXRlci5wcm90b3R5cGUuZml4ZWQ2NCA9IGZ1bmN0aW9uIHdyaXRlX2ZpeGVkNjQodmFsdWUpIHtcbiAgICB2YXIgYml0cyA9IExvbmdCaXRzLmZyb20odmFsdWUpO1xuICAgIHJldHVybiB0aGlzLl9wdXNoKHdyaXRlRml4ZWQzMiwgNCwgYml0cy5sbykuX3B1c2god3JpdGVGaXhlZDMyLCA0LCBiaXRzLmhpKTtcbn07XG5cbi8qKlxuICogV3JpdGVzIGEgc2lnbmVkIDY0IGJpdCB2YWx1ZSBhcyBmaXhlZCA2NCBiaXRzLlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0xvbmd8bnVtYmVyfHN0cmluZ30gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBgdmFsdWVgIGlzIGEgc3RyaW5nIGFuZCBubyBsb25nIGxpYnJhcnkgaXMgcHJlc2VudC5cbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5zZml4ZWQ2NCA9IFdyaXRlci5wcm90b3R5cGUuZml4ZWQ2NDtcblxuLyoqXG4gKiBXcml0ZXMgYSBmbG9hdCAoMzIgYml0KS5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5mbG9hdCA9IGZ1bmN0aW9uIHdyaXRlX2Zsb2F0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuX3B1c2godXRpbC5mbG9hdC53cml0ZUZsb2F0TEUsIDQsIHZhbHVlKTtcbn07XG5cbi8qKlxuICogV3JpdGVzIGEgZG91YmxlICg2NCBiaXQgZmxvYXQpLlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICovXG5Xcml0ZXIucHJvdG90eXBlLmRvdWJsZSA9IGZ1bmN0aW9uIHdyaXRlX2RvdWJsZSh2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLl9wdXNoKHV0aWwuZmxvYXQud3JpdGVEb3VibGVMRSwgOCwgdmFsdWUpO1xufTtcblxudmFyIHdyaXRlQnl0ZXMgPSB1dGlsLkFycmF5LnByb3RvdHlwZS5zZXRcbiAgICA/IGZ1bmN0aW9uIHdyaXRlQnl0ZXNfc2V0KHZhbCwgYnVmLCBwb3MpIHtcbiAgICAgICAgYnVmLnNldCh2YWwsIHBvcyk7IC8vIGFsc28gd29ya3MgZm9yIHBsYWluIGFycmF5IHZhbHVlc1xuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIDogZnVuY3Rpb24gd3JpdGVCeXRlc19mb3IodmFsLCBidWYsIHBvcykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbC5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgIGJ1Zltwb3MgKyBpXSA9IHZhbFtpXTtcbiAgICB9O1xuXG4vKipcbiAqIFdyaXRlcyBhIHNlcXVlbmNlIG9mIGJ5dGVzLlxuICogQHBhcmFtIHtVaW50OEFycmF5fHN0cmluZ30gdmFsdWUgQnVmZmVyIG9yIGJhc2U2NCBlbmNvZGVkIHN0cmluZyB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKi9cbldyaXRlci5wcm90b3R5cGUuYnl0ZXMgPSBmdW5jdGlvbiB3cml0ZV9ieXRlcyh2YWx1ZSkge1xuICAgIHZhciBsZW4gPSB2YWx1ZS5sZW5ndGggPj4+IDA7XG4gICAgaWYgKCFsZW4pXG4gICAgICAgIHJldHVybiB0aGlzLl9wdXNoKHdyaXRlQnl0ZSwgMSwgMCk7XG4gICAgaWYgKHV0aWwuaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgIHZhciBidWYgPSBXcml0ZXIuYWxsb2MobGVuID0gYmFzZTY0Lmxlbmd0aCh2YWx1ZSkpO1xuICAgICAgICBiYXNlNjQuZGVjb2RlKHZhbHVlLCBidWYsIDApO1xuICAgICAgICB2YWx1ZSA9IGJ1ZjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudWludDMyKGxlbikuX3B1c2god3JpdGVCeXRlcywgbGVuLCB2YWx1ZSk7XG59O1xuXG4vKipcbiAqIFdyaXRlcyBhIHN0cmluZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKi9cbldyaXRlci5wcm90b3R5cGUuc3RyaW5nID0gZnVuY3Rpb24gd3JpdGVfc3RyaW5nKHZhbHVlKSB7XG4gICAgdmFyIGxlbiA9IHV0ZjgubGVuZ3RoKHZhbHVlKTtcbiAgICByZXR1cm4gbGVuXG4gICAgICAgID8gdGhpcy51aW50MzIobGVuKS5fcHVzaCh1dGY4LndyaXRlLCBsZW4sIHZhbHVlKVxuICAgICAgICA6IHRoaXMuX3B1c2god3JpdGVCeXRlLCAxLCAwKTtcbn07XG5cbi8qKlxuICogRm9ya3MgdGhpcyB3cml0ZXIncyBzdGF0ZSBieSBwdXNoaW5nIGl0IHRvIGEgc3RhY2suXG4gKiBDYWxsaW5nIHtAbGluayBXcml0ZXIjcmVzZXR8cmVzZXR9IG9yIHtAbGluayBXcml0ZXIjbGRlbGltfGxkZWxpbX0gcmVzZXRzIHRoZSB3cml0ZXIgdG8gdGhlIHByZXZpb3VzIHN0YXRlLlxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKi9cbldyaXRlci5wcm90b3R5cGUuZm9yayA9IGZ1bmN0aW9uIGZvcmsoKSB7XG4gICAgdGhpcy5zdGF0ZXMgPSBuZXcgU3RhdGUodGhpcyk7XG4gICAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbmV3IE9wKG5vb3AsIDAsIDApO1xuICAgIHRoaXMubGVuID0gMDtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVzZXRzIHRoaXMgaW5zdGFuY2UgdG8gdGhlIGxhc3Qgc3RhdGUuXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgIGlmICh0aGlzLnN0YXRlcykge1xuICAgICAgICB0aGlzLmhlYWQgICA9IHRoaXMuc3RhdGVzLmhlYWQ7XG4gICAgICAgIHRoaXMudGFpbCAgID0gdGhpcy5zdGF0ZXMudGFpbDtcbiAgICAgICAgdGhpcy5sZW4gICAgPSB0aGlzLnN0YXRlcy5sZW47XG4gICAgICAgIHRoaXMuc3RhdGVzID0gdGhpcy5zdGF0ZXMubmV4dDtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBuZXcgT3Aobm9vcCwgMCwgMCk7XG4gICAgICAgIHRoaXMubGVuICA9IDA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZXNldHMgdG8gdGhlIGxhc3Qgc3RhdGUgYW5kIGFwcGVuZHMgdGhlIGZvcmsgc3RhdGUncyBjdXJyZW50IHdyaXRlIGxlbmd0aCBhcyBhIHZhcmludCBmb2xsb3dlZCBieSBpdHMgb3BlcmF0aW9ucy5cbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICovXG5Xcml0ZXIucHJvdG90eXBlLmxkZWxpbSA9IGZ1bmN0aW9uIGxkZWxpbSgpIHtcbiAgICB2YXIgaGVhZCA9IHRoaXMuaGVhZCxcbiAgICAgICAgdGFpbCA9IHRoaXMudGFpbCxcbiAgICAgICAgbGVuICA9IHRoaXMubGVuO1xuICAgIHRoaXMucmVzZXQoKS51aW50MzIobGVuKTtcbiAgICBpZiAobGVuKSB7XG4gICAgICAgIHRoaXMudGFpbC5uZXh0ID0gaGVhZC5uZXh0OyAvLyBza2lwIG5vb3BcbiAgICAgICAgdGhpcy50YWlsID0gdGFpbDtcbiAgICAgICAgdGhpcy5sZW4gKz0gbGVuO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRmluaXNoZXMgdGhlIHdyaXRlIG9wZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fSBGaW5pc2hlZCBidWZmZXJcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5maW5pc2ggPSBmdW5jdGlvbiBmaW5pc2goKSB7XG4gICAgdmFyIGhlYWQgPSB0aGlzLmhlYWQubmV4dCwgLy8gc2tpcCBub29wXG4gICAgICAgIGJ1ZiAgPSB0aGlzLmNvbnN0cnVjdG9yLmFsbG9jKHRoaXMubGVuKSxcbiAgICAgICAgcG9zICA9IDA7XG4gICAgd2hpbGUgKGhlYWQpIHtcbiAgICAgICAgaGVhZC5mbihoZWFkLnZhbCwgYnVmLCBwb3MpO1xuICAgICAgICBwb3MgKz0gaGVhZC5sZW47XG4gICAgICAgIGhlYWQgPSBoZWFkLm5leHQ7XG4gICAgfVxuICAgIC8vIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7XG4gICAgcmV0dXJuIGJ1Zjtcbn07XG5cbldyaXRlci5fY29uZmlndXJlID0gZnVuY3Rpb24oQnVmZmVyV3JpdGVyXykge1xuICAgIEJ1ZmZlcldyaXRlciA9IEJ1ZmZlcldyaXRlcl87XG4gICAgV3JpdGVyLmNyZWF0ZSA9IGNyZWF0ZSgpO1xuICAgIEJ1ZmZlcldyaXRlci5fY29uZmlndXJlKCk7XG59O1xuIiwgIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBCdWZmZXJXcml0ZXI7XG5cbi8vIGV4dGVuZHMgV3JpdGVyXG52YXIgV3JpdGVyID0gcmVxdWlyZShcIi4vd3JpdGVyXCIpO1xuKEJ1ZmZlcldyaXRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFdyaXRlci5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IEJ1ZmZlcldyaXRlcjtcblxudmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsL21pbmltYWxcIik7XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyBidWZmZXIgd3JpdGVyIGluc3RhbmNlLlxuICogQGNsYXNzZGVzYyBXaXJlIGZvcm1hdCB3cml0ZXIgdXNpbmcgbm9kZSBidWZmZXJzLlxuICogQGV4dGVuZHMgV3JpdGVyXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gQnVmZmVyV3JpdGVyKCkge1xuICAgIFdyaXRlci5jYWxsKHRoaXMpO1xufVxuXG5CdWZmZXJXcml0ZXIuX2NvbmZpZ3VyZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBBbGxvY2F0ZXMgYSBidWZmZXIgb2YgdGhlIHNwZWNpZmllZCBzaXplLlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzaXplIEJ1ZmZlciBzaXplXG4gICAgICogQHJldHVybnMge0J1ZmZlcn0gQnVmZmVyXG4gICAgICovXG4gICAgQnVmZmVyV3JpdGVyLmFsbG9jID0gdXRpbC5fQnVmZmVyX2FsbG9jVW5zYWZlO1xuXG4gICAgQnVmZmVyV3JpdGVyLndyaXRlQnl0ZXNCdWZmZXIgPSB1dGlsLkJ1ZmZlciAmJiB1dGlsLkJ1ZmZlci5wcm90b3R5cGUgaW5zdGFuY2VvZiBVaW50OEFycmF5ICYmIHV0aWwuQnVmZmVyLnByb3RvdHlwZS5zZXQubmFtZSA9PT0gXCJzZXRcIlxuICAgICAgICA/IGZ1bmN0aW9uIHdyaXRlQnl0ZXNCdWZmZXJfc2V0KHZhbCwgYnVmLCBwb3MpIHtcbiAgICAgICAgICBidWYuc2V0KHZhbCwgcG9zKTsgLy8gZmFzdGVyIHRoYW4gY29weSAocmVxdWlyZXMgbm9kZSA+PSA0IHdoZXJlIEJ1ZmZlcnMgZXh0ZW5kIFVpbnQ4QXJyYXkgYW5kIHNldCBpcyBwcm9wZXJseSBpbmhlcml0ZWQpXG4gICAgICAgICAgLy8gYWxzbyB3b3JrcyBmb3IgcGxhaW4gYXJyYXkgdmFsdWVzXG4gICAgICAgIH1cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgOiBmdW5jdGlvbiB3cml0ZUJ5dGVzQnVmZmVyX2NvcHkodmFsLCBidWYsIHBvcykge1xuICAgICAgICAgIGlmICh2YWwuY29weSkgLy8gQnVmZmVyIHZhbHVlc1xuICAgICAgICAgICAgdmFsLmNvcHkoYnVmLCBwb3MsIDAsIHZhbC5sZW5ndGgpO1xuICAgICAgICAgIGVsc2UgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWwubGVuZ3RoOykgLy8gcGxhaW4gYXJyYXkgdmFsdWVzXG4gICAgICAgICAgICBidWZbcG9zKytdID0gdmFsW2krK107XG4gICAgICAgIH07XG59O1xuXG5cbi8qKlxuICogQG92ZXJyaWRlXG4gKi9cbkJ1ZmZlcldyaXRlci5wcm90b3R5cGUuYnl0ZXMgPSBmdW5jdGlvbiB3cml0ZV9ieXRlc19idWZmZXIodmFsdWUpIHtcbiAgICBpZiAodXRpbC5pc1N0cmluZyh2YWx1ZSkpXG4gICAgICAgIHZhbHVlID0gdXRpbC5fQnVmZmVyX2Zyb20odmFsdWUsIFwiYmFzZTY0XCIpO1xuICAgIHZhciBsZW4gPSB2YWx1ZS5sZW5ndGggPj4+IDA7XG4gICAgdGhpcy51aW50MzIobGVuKTtcbiAgICBpZiAobGVuKVxuICAgICAgICB0aGlzLl9wdXNoKEJ1ZmZlcldyaXRlci53cml0ZUJ5dGVzQnVmZmVyLCBsZW4sIHZhbHVlKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIHdyaXRlU3RyaW5nQnVmZmVyKHZhbCwgYnVmLCBwb3MpIHtcbiAgICBpZiAodmFsLmxlbmd0aCA8IDQwKSAvLyBwbGFpbiBqcyBpcyBmYXN0ZXIgZm9yIHNob3J0IHN0cmluZ3MgKHByb2JhYmx5IGR1ZSB0byByZWR1bmRhbnQgYXNzZXJ0aW9ucylcbiAgICAgICAgdXRpbC51dGY4LndyaXRlKHZhbCwgYnVmLCBwb3MpO1xuICAgIGVsc2UgaWYgKGJ1Zi51dGY4V3JpdGUpXG4gICAgICAgIGJ1Zi51dGY4V3JpdGUodmFsLCBwb3MpO1xuICAgIGVsc2VcbiAgICAgICAgYnVmLndyaXRlKHZhbCwgcG9zKTtcbn1cblxuLyoqXG4gKiBAb3ZlcnJpZGVcbiAqL1xuQnVmZmVyV3JpdGVyLnByb3RvdHlwZS5zdHJpbmcgPSBmdW5jdGlvbiB3cml0ZV9zdHJpbmdfYnVmZmVyKHZhbHVlKSB7XG4gICAgdmFyIGxlbiA9IHV0aWwuQnVmZmVyLmJ5dGVMZW5ndGgodmFsdWUpO1xuICAgIHRoaXMudWludDMyKGxlbik7XG4gICAgaWYgKGxlbilcbiAgICAgICAgdGhpcy5fcHVzaCh3cml0ZVN0cmluZ0J1ZmZlciwgbGVuLCB2YWx1ZSk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5cbi8qKlxuICogRmluaXNoZXMgdGhlIHdyaXRlIG9wZXJhdGlvbi5cbiAqIEBuYW1lIEJ1ZmZlcldyaXRlciNmaW5pc2hcbiAqIEBmdW5jdGlvblxuICogQHJldHVybnMge0J1ZmZlcn0gRmluaXNoZWQgYnVmZmVyXG4gKi9cblxuQnVmZmVyV3JpdGVyLl9jb25maWd1cmUoKTtcbiIsICJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gUmVhZGVyO1xuXG52YXIgdXRpbCAgICAgID0gcmVxdWlyZShcIi4vdXRpbC9taW5pbWFsXCIpO1xuXG52YXIgQnVmZmVyUmVhZGVyOyAvLyBjeWNsaWNcblxudmFyIExvbmdCaXRzICA9IHV0aWwuTG9uZ0JpdHMsXG4gICAgdXRmOCAgICAgID0gdXRpbC51dGY4O1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gaW5kZXhPdXRPZlJhbmdlKHJlYWRlciwgd3JpdGVMZW5ndGgpIHtcbiAgICByZXR1cm4gUmFuZ2VFcnJvcihcImluZGV4IG91dCBvZiByYW5nZTogXCIgKyByZWFkZXIucG9zICsgXCIgKyBcIiArICh3cml0ZUxlbmd0aCB8fCAxKSArIFwiID4gXCIgKyByZWFkZXIubGVuKTtcbn1cblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IHJlYWRlciBpbnN0YW5jZSB1c2luZyB0aGUgc3BlY2lmaWVkIGJ1ZmZlci5cbiAqIEBjbGFzc2Rlc2MgV2lyZSBmb3JtYXQgcmVhZGVyIHVzaW5nIGBVaW50OEFycmF5YCBpZiBhdmFpbGFibGUsIG90aGVyd2lzZSBgQXJyYXlgLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZmZlciBCdWZmZXIgdG8gcmVhZCBmcm9tXG4gKi9cbmZ1bmN0aW9uIFJlYWRlcihidWZmZXIpIHtcblxuICAgIC8qKlxuICAgICAqIFJlYWQgYnVmZmVyLlxuICAgICAqIEB0eXBlIHtVaW50OEFycmF5fVxuICAgICAqL1xuICAgIHRoaXMuYnVmID0gYnVmZmVyO1xuXG4gICAgLyoqXG4gICAgICogUmVhZCBidWZmZXIgcG9zaXRpb24uXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnBvcyA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBSZWFkIGJ1ZmZlciBsZW5ndGguXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmxlbiA9IGJ1ZmZlci5sZW5ndGg7XG59XG5cbnZhciBjcmVhdGVfYXJyYXkgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gXCJ1bmRlZmluZWRcIlxuICAgID8gZnVuY3Rpb24gY3JlYXRlX3R5cGVkX2FycmF5KGJ1ZmZlcikge1xuICAgICAgICBpZiAoYnVmZmVyIGluc3RhbmNlb2YgVWludDhBcnJheSB8fCBBcnJheS5pc0FycmF5KGJ1ZmZlcikpXG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlYWRlcihidWZmZXIpO1xuICAgICAgICB0aHJvdyBFcnJvcihcImlsbGVnYWwgYnVmZmVyXCIpO1xuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIDogZnVuY3Rpb24gY3JlYXRlX2FycmF5KGJ1ZmZlcikge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShidWZmZXIpKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWFkZXIoYnVmZmVyKTtcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJpbGxlZ2FsIGJ1ZmZlclwiKTtcbiAgICB9O1xuXG52YXIgY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKCkge1xuICAgIHJldHVybiB1dGlsLkJ1ZmZlclxuICAgICAgICA/IGZ1bmN0aW9uIGNyZWF0ZV9idWZmZXJfc2V0dXAoYnVmZmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gKFJlYWRlci5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGVfYnVmZmVyKGJ1ZmZlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiB1dGlsLkJ1ZmZlci5pc0J1ZmZlcihidWZmZXIpXG4gICAgICAgICAgICAgICAgICAgID8gbmV3IEJ1ZmZlclJlYWRlcihidWZmZXIpXG4gICAgICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICAgICAgICAgIDogY3JlYXRlX2FycmF5KGJ1ZmZlcik7XG4gICAgICAgICAgICB9KShidWZmZXIpO1xuICAgICAgICB9XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIDogY3JlYXRlX2FycmF5O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHJlYWRlciB1c2luZyB0aGUgc3BlY2lmaWVkIGJ1ZmZlci5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtVaW50OEFycmF5fEJ1ZmZlcn0gYnVmZmVyIEJ1ZmZlciB0byByZWFkIGZyb21cbiAqIEByZXR1cm5zIHtSZWFkZXJ8QnVmZmVyUmVhZGVyfSBBIHtAbGluayBCdWZmZXJSZWFkZXJ9IGlmIGBidWZmZXJgIGlzIGEgQnVmZmVyLCBvdGhlcndpc2UgYSB7QGxpbmsgUmVhZGVyfVxuICogQHRocm93cyB7RXJyb3J9IElmIGBidWZmZXJgIGlzIG5vdCBhIHZhbGlkIGJ1ZmZlclxuICovXG5SZWFkZXIuY3JlYXRlID0gY3JlYXRlKCk7XG5cblJlYWRlci5wcm90b3R5cGUuX3NsaWNlID0gdXRpbC5BcnJheS5wcm90b3R5cGUuc3ViYXJyYXkgfHwgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gdXRpbC5BcnJheS5wcm90b3R5cGUuc2xpY2U7XG5cbi8qKlxuICogUmVhZHMgYSB2YXJpbnQgYXMgYW4gdW5zaWduZWQgMzIgYml0IHZhbHVlLlxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXG4gKi9cblJlYWRlci5wcm90b3R5cGUudWludDMyID0gKGZ1bmN0aW9uIHJlYWRfdWludDMyX3NldHVwKCkge1xuICAgIHZhciB2YWx1ZSA9IDQyOTQ5NjcyOTU7IC8vIG9wdGltaXplciB0eXBlLWhpbnQsIHRlbmRzIHRvIGRlb3B0IG90aGVyd2lzZSAoPyEpXG4gICAgcmV0dXJuIGZ1bmN0aW9uIHJlYWRfdWludDMyKCkge1xuICAgICAgICB2YWx1ZSA9ICggICAgICAgICB0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxMjcgICAgICAgKSA+Pj4gMDsgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KSByZXR1cm4gdmFsdWU7XG4gICAgICAgIHZhbHVlID0gKHZhbHVlIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmIDEyNykgPDwgIDcpID4+PiAwOyBpZiAodGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpIHJldHVybiB2YWx1ZTtcbiAgICAgICAgdmFsdWUgPSAodmFsdWUgfCAodGhpcy5idWZbdGhpcy5wb3NdICYgMTI3KSA8PCAxNCkgPj4+IDA7IGlmICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSA8IDEyOCkgcmV0dXJuIHZhbHVlO1xuICAgICAgICB2YWx1ZSA9ICh2YWx1ZSB8ICh0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxMjcpIDw8IDIxKSA+Pj4gMDsgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KSByZXR1cm4gdmFsdWU7XG4gICAgICAgIHZhbHVlID0gKHZhbHVlIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmICAxNSkgPDwgMjgpID4+PiAwOyBpZiAodGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpIHJldHVybiB2YWx1ZTtcblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCh0aGlzLnBvcyArPSA1KSA+IHRoaXMubGVuKSB7XG4gICAgICAgICAgICB0aGlzLnBvcyA9IHRoaXMubGVuO1xuICAgICAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMsIDEwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbn0pKCk7XG5cbi8qKlxuICogUmVhZHMgYSB2YXJpbnQgYXMgYSBzaWduZWQgMzIgYml0IHZhbHVlLlxuICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxuICovXG5SZWFkZXIucHJvdG90eXBlLmludDMyID0gZnVuY3Rpb24gcmVhZF9pbnQzMigpIHtcbiAgICByZXR1cm4gdGhpcy51aW50MzIoKSB8IDA7XG59O1xuXG4vKipcbiAqIFJlYWRzIGEgemlnLXphZyBlbmNvZGVkIHZhcmludCBhcyBhIHNpZ25lZCAzMiBiaXQgdmFsdWUuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXG4gKi9cblJlYWRlci5wcm90b3R5cGUuc2ludDMyID0gZnVuY3Rpb24gcmVhZF9zaW50MzIoKSB7XG4gICAgdmFyIHZhbHVlID0gdGhpcy51aW50MzIoKTtcbiAgICByZXR1cm4gdmFsdWUgPj4+IDEgXiAtKHZhbHVlICYgMSkgfCAwO1xufTtcblxuLyogZXNsaW50LWRpc2FibGUgbm8taW52YWxpZC10aGlzICovXG5cbmZ1bmN0aW9uIHJlYWRMb25nVmFyaW50KCkge1xuICAgIC8vIHRlbmRzIHRvIGRlb3B0IHdpdGggbG9jYWwgdmFycyBmb3Igb2N0ZXQgZXRjLlxuICAgIHZhciBiaXRzID0gbmV3IExvbmdCaXRzKDAsIDApO1xuICAgIHZhciBpID0gMDtcbiAgICBpZiAodGhpcy5sZW4gLSB0aGlzLnBvcyA+IDQpIHsgLy8gZmFzdCByb3V0ZSAobG8pXG4gICAgICAgIGZvciAoOyBpIDwgNDsgKytpKSB7XG4gICAgICAgICAgICAvLyAxc3QuLjR0aFxuICAgICAgICAgICAgYml0cy5sbyA9IChiaXRzLmxvIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmIDEyNykgPDwgaSAqIDcpID4+PiAwO1xuICAgICAgICAgICAgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KVxuICAgICAgICAgICAgICAgIHJldHVybiBiaXRzO1xuICAgICAgICB9XG4gICAgICAgIC8vIDV0aFxuICAgICAgICBiaXRzLmxvID0gKGJpdHMubG8gfCAodGhpcy5idWZbdGhpcy5wb3NdICYgMTI3KSA8PCAyOCkgPj4+IDA7XG4gICAgICAgIGJpdHMuaGkgPSAoYml0cy5oaSB8ICh0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxMjcpID4+ICA0KSA+Pj4gMDtcbiAgICAgICAgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KVxuICAgICAgICAgICAgcmV0dXJuIGJpdHM7XG4gICAgICAgIGkgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoOyBpIDwgMzsgKytpKSB7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgIGlmICh0aGlzLnBvcyA+PSB0aGlzLmxlbilcbiAgICAgICAgICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcyk7XG4gICAgICAgICAgICAvLyAxc3QuLjN0aFxuICAgICAgICAgICAgYml0cy5sbyA9IChiaXRzLmxvIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmIDEyNykgPDwgaSAqIDcpID4+PiAwO1xuICAgICAgICAgICAgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KVxuICAgICAgICAgICAgICAgIHJldHVybiBiaXRzO1xuICAgICAgICB9XG4gICAgICAgIC8vIDR0aFxuICAgICAgICBiaXRzLmxvID0gKGJpdHMubG8gfCAodGhpcy5idWZbdGhpcy5wb3MrK10gJiAxMjcpIDw8IGkgKiA3KSA+Pj4gMDtcbiAgICAgICAgcmV0dXJuIGJpdHM7XG4gICAgfVxuICAgIGlmICh0aGlzLmxlbiAtIHRoaXMucG9zID4gNCkgeyAvLyBmYXN0IHJvdXRlIChoaSlcbiAgICAgICAgZm9yICg7IGkgPCA1OyArK2kpIHtcbiAgICAgICAgICAgIC8vIDZ0aC4uMTB0aFxuICAgICAgICAgICAgYml0cy5oaSA9IChiaXRzLmhpIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmIDEyNykgPDwgaSAqIDcgKyAzKSA+Pj4gMDtcbiAgICAgICAgICAgIGlmICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSA8IDEyOClcbiAgICAgICAgICAgICAgICByZXR1cm4gYml0cztcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoOyBpIDwgNTsgKytpKSB7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgIGlmICh0aGlzLnBvcyA+PSB0aGlzLmxlbilcbiAgICAgICAgICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcyk7XG4gICAgICAgICAgICAvLyA2dGguLjEwdGhcbiAgICAgICAgICAgIGJpdHMuaGkgPSAoYml0cy5oaSB8ICh0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxMjcpIDw8IGkgKiA3ICsgMykgPj4+IDA7XG4gICAgICAgICAgICBpZiAodGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJpdHM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICB0aHJvdyBFcnJvcihcImludmFsaWQgdmFyaW50IGVuY29kaW5nXCIpO1xufVxuXG4vKiBlc2xpbnQtZW5hYmxlIG5vLWludmFsaWQtdGhpcyAqL1xuXG4vKipcbiAqIFJlYWRzIGEgdmFyaW50IGFzIGEgc2lnbmVkIDY0IGJpdCB2YWx1ZS5cbiAqIEBuYW1lIFJlYWRlciNpbnQ2NFxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7TG9uZ30gVmFsdWUgcmVhZFxuICovXG5cbi8qKlxuICogUmVhZHMgYSB2YXJpbnQgYXMgYW4gdW5zaWduZWQgNjQgYml0IHZhbHVlLlxuICogQG5hbWUgUmVhZGVyI3VpbnQ2NFxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7TG9uZ30gVmFsdWUgcmVhZFxuICovXG5cbi8qKlxuICogUmVhZHMgYSB6aWctemFnIGVuY29kZWQgdmFyaW50IGFzIGEgc2lnbmVkIDY0IGJpdCB2YWx1ZS5cbiAqIEBuYW1lIFJlYWRlciNzaW50NjRcbiAqIEBmdW5jdGlvblxuICogQHJldHVybnMge0xvbmd9IFZhbHVlIHJlYWRcbiAqL1xuXG4vKipcbiAqIFJlYWRzIGEgdmFyaW50IGFzIGEgYm9vbGVhbi5cbiAqIEByZXR1cm5zIHtib29sZWFufSBWYWx1ZSByZWFkXG4gKi9cblJlYWRlci5wcm90b3R5cGUuYm9vbCA9IGZ1bmN0aW9uIHJlYWRfYm9vbCgpIHtcbiAgICByZXR1cm4gdGhpcy51aW50MzIoKSAhPT0gMDtcbn07XG5cbmZ1bmN0aW9uIHJlYWRGaXhlZDMyX2VuZChidWYsIGVuZCkgeyAvLyBub3RlIHRoYXQgdGhpcyB1c2VzIGBlbmRgLCBub3QgYHBvc2BcbiAgICByZXR1cm4gKGJ1ZltlbmQgLSA0XVxuICAgICAgICAgIHwgYnVmW2VuZCAtIDNdIDw8IDhcbiAgICAgICAgICB8IGJ1ZltlbmQgLSAyXSA8PCAxNlxuICAgICAgICAgIHwgYnVmW2VuZCAtIDFdIDw8IDI0KSA+Pj4gMDtcbn1cblxuLyoqXG4gKiBSZWFkcyBmaXhlZCAzMiBiaXRzIGFzIGFuIHVuc2lnbmVkIDMyIGJpdCBpbnRlZ2VyLlxuICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxuICovXG5SZWFkZXIucHJvdG90eXBlLmZpeGVkMzIgPSBmdW5jdGlvbiByZWFkX2ZpeGVkMzIoKSB7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAodGhpcy5wb3MgKyA0ID4gdGhpcy5sZW4pXG4gICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzLCA0KTtcblxuICAgIHJldHVybiByZWFkRml4ZWQzMl9lbmQodGhpcy5idWYsIHRoaXMucG9zICs9IDQpO1xufTtcblxuLyoqXG4gKiBSZWFkcyBmaXhlZCAzMiBiaXRzIGFzIGEgc2lnbmVkIDMyIGJpdCBpbnRlZ2VyLlxuICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxuICovXG5SZWFkZXIucHJvdG90eXBlLnNmaXhlZDMyID0gZnVuY3Rpb24gcmVhZF9zZml4ZWQzMigpIHtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICh0aGlzLnBvcyArIDQgPiB0aGlzLmxlbilcbiAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMsIDQpO1xuXG4gICAgcmV0dXJuIHJlYWRGaXhlZDMyX2VuZCh0aGlzLmJ1ZiwgdGhpcy5wb3MgKz0gNCkgfCAwO1xufTtcblxuLyogZXNsaW50LWRpc2FibGUgbm8taW52YWxpZC10aGlzICovXG5cbmZ1bmN0aW9uIHJlYWRGaXhlZDY0KC8qIHRoaXM6IFJlYWRlciAqLykge1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHRoaXMucG9zICsgOCA+IHRoaXMubGVuKVxuICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcywgOCk7XG5cbiAgICByZXR1cm4gbmV3IExvbmdCaXRzKHJlYWRGaXhlZDMyX2VuZCh0aGlzLmJ1ZiwgdGhpcy5wb3MgKz0gNCksIHJlYWRGaXhlZDMyX2VuZCh0aGlzLmJ1ZiwgdGhpcy5wb3MgKz0gNCkpO1xufVxuXG4vKiBlc2xpbnQtZW5hYmxlIG5vLWludmFsaWQtdGhpcyAqL1xuXG4vKipcbiAqIFJlYWRzIGZpeGVkIDY0IGJpdHMuXG4gKiBAbmFtZSBSZWFkZXIjZml4ZWQ2NFxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7TG9uZ30gVmFsdWUgcmVhZFxuICovXG5cbi8qKlxuICogUmVhZHMgemlnLXphZyBlbmNvZGVkIGZpeGVkIDY0IGJpdHMuXG4gKiBAbmFtZSBSZWFkZXIjc2ZpeGVkNjRcbiAqIEBmdW5jdGlvblxuICogQHJldHVybnMge0xvbmd9IFZhbHVlIHJlYWRcbiAqL1xuXG4vKipcbiAqIFJlYWRzIGEgZmxvYXQgKDMyIGJpdCkgYXMgYSBudW1iZXIuXG4gKiBAZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcbiAqL1xuUmVhZGVyLnByb3RvdHlwZS5mbG9hdCA9IGZ1bmN0aW9uIHJlYWRfZmxvYXQoKSB7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAodGhpcy5wb3MgKyA0ID4gdGhpcy5sZW4pXG4gICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzLCA0KTtcblxuICAgIHZhciB2YWx1ZSA9IHV0aWwuZmxvYXQucmVhZEZsb2F0TEUodGhpcy5idWYsIHRoaXMucG9zKTtcbiAgICB0aGlzLnBvcyArPSA0O1xuICAgIHJldHVybiB2YWx1ZTtcbn07XG5cbi8qKlxuICogUmVhZHMgYSBkb3VibGUgKDY0IGJpdCBmbG9hdCkgYXMgYSBudW1iZXIuXG4gKiBAZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcbiAqL1xuUmVhZGVyLnByb3RvdHlwZS5kb3VibGUgPSBmdW5jdGlvbiByZWFkX2RvdWJsZSgpIHtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICh0aGlzLnBvcyArIDggPiB0aGlzLmxlbilcbiAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMsIDQpO1xuXG4gICAgdmFyIHZhbHVlID0gdXRpbC5mbG9hdC5yZWFkRG91YmxlTEUodGhpcy5idWYsIHRoaXMucG9zKTtcbiAgICB0aGlzLnBvcyArPSA4O1xuICAgIHJldHVybiB2YWx1ZTtcbn07XG5cbi8qKlxuICogUmVhZHMgYSBzZXF1ZW5jZSBvZiBieXRlcyBwcmVjZWVkZWQgYnkgaXRzIGxlbmd0aCBhcyBhIHZhcmludC5cbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fSBWYWx1ZSByZWFkXG4gKi9cblJlYWRlci5wcm90b3R5cGUuYnl0ZXMgPSBmdW5jdGlvbiByZWFkX2J5dGVzKCkge1xuICAgIHZhciBsZW5ndGggPSB0aGlzLnVpbnQzMigpLFxuICAgICAgICBzdGFydCAgPSB0aGlzLnBvcyxcbiAgICAgICAgZW5kICAgID0gdGhpcy5wb3MgKyBsZW5ndGg7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoZW5kID4gdGhpcy5sZW4pXG4gICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzLCBsZW5ndGgpO1xuXG4gICAgdGhpcy5wb3MgKz0gbGVuZ3RoO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMuYnVmKSkgLy8gcGxhaW4gYXJyYXlcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICAgIHJldHVybiBzdGFydCA9PT0gZW5kIC8vIGZpeCBmb3IgSUUgMTAvV2luOCBhbmQgb3RoZXJzJyBzdWJhcnJheSByZXR1cm5pbmcgYXJyYXkgb2Ygc2l6ZSAxXG4gICAgICAgID8gbmV3IHRoaXMuYnVmLmNvbnN0cnVjdG9yKDApXG4gICAgICAgIDogdGhpcy5fc2xpY2UuY2FsbCh0aGlzLmJ1Ziwgc3RhcnQsIGVuZCk7XG59O1xuXG4vKipcbiAqIFJlYWRzIGEgc3RyaW5nIHByZWNlZWRlZCBieSBpdHMgYnl0ZSBsZW5ndGggYXMgYSB2YXJpbnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBWYWx1ZSByZWFkXG4gKi9cblJlYWRlci5wcm90b3R5cGUuc3RyaW5nID0gZnVuY3Rpb24gcmVhZF9zdHJpbmcoKSB7XG4gICAgdmFyIGJ5dGVzID0gdGhpcy5ieXRlcygpO1xuICAgIHJldHVybiB1dGY4LnJlYWQoYnl0ZXMsIDAsIGJ5dGVzLmxlbmd0aCk7XG59O1xuXG4vKipcbiAqIFNraXBzIHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIGJ5dGVzIGlmIHNwZWNpZmllZCwgb3RoZXJ3aXNlIHNraXBzIGEgdmFyaW50LlxuICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGhdIExlbmd0aCBpZiBrbm93biwgb3RoZXJ3aXNlIGEgdmFyaW50IGlzIGFzc3VtZWRcbiAqIEByZXR1cm5zIHtSZWFkZXJ9IGB0aGlzYFxuICovXG5SZWFkZXIucHJvdG90eXBlLnNraXAgPSBmdW5jdGlvbiBza2lwKGxlbmd0aCkge1xuICAgIGlmICh0eXBlb2YgbGVuZ3RoID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAodGhpcy5wb3MgKyBsZW5ndGggPiB0aGlzLmxlbilcbiAgICAgICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzLCBsZW5ndGgpO1xuICAgICAgICB0aGlzLnBvcyArPSBsZW5ndGg7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICBpZiAodGhpcy5wb3MgPj0gdGhpcy5sZW4pXG4gICAgICAgICAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMpO1xuICAgICAgICB9IHdoaWxlICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSAmIDEyOCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTa2lwcyB0aGUgbmV4dCBlbGVtZW50IG9mIHRoZSBzcGVjaWZpZWQgd2lyZSB0eXBlLlxuICogQHBhcmFtIHtudW1iZXJ9IHdpcmVUeXBlIFdpcmUgdHlwZSByZWNlaXZlZFxuICogQHJldHVybnMge1JlYWRlcn0gYHRoaXNgXG4gKi9cblJlYWRlci5wcm90b3R5cGUuc2tpcFR5cGUgPSBmdW5jdGlvbih3aXJlVHlwZSkge1xuICAgIHN3aXRjaCAod2lyZVR5cGUpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgdGhpcy5za2lwKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgdGhpcy5za2lwKDgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHRoaXMuc2tpcCh0aGlzLnVpbnQzMigpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICB3aGlsZSAoKHdpcmVUeXBlID0gdGhpcy51aW50MzIoKSAmIDcpICE9PSA0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5za2lwVHlwZSh3aXJlVHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgdGhpcy5za2lwKDQpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiaW52YWxpZCB3aXJlIHR5cGUgXCIgKyB3aXJlVHlwZSArIFwiIGF0IG9mZnNldCBcIiArIHRoaXMucG9zKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5SZWFkZXIuX2NvbmZpZ3VyZSA9IGZ1bmN0aW9uKEJ1ZmZlclJlYWRlcl8pIHtcbiAgICBCdWZmZXJSZWFkZXIgPSBCdWZmZXJSZWFkZXJfO1xuICAgIFJlYWRlci5jcmVhdGUgPSBjcmVhdGUoKTtcbiAgICBCdWZmZXJSZWFkZXIuX2NvbmZpZ3VyZSgpO1xuXG4gICAgdmFyIGZuID0gdXRpbC5Mb25nID8gXCJ0b0xvbmdcIiA6IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIFwidG9OdW1iZXJcIjtcbiAgICB1dGlsLm1lcmdlKFJlYWRlci5wcm90b3R5cGUsIHtcblxuICAgICAgICBpbnQ2NDogZnVuY3Rpb24gcmVhZF9pbnQ2NCgpIHtcbiAgICAgICAgICAgIHJldHVybiByZWFkTG9uZ1ZhcmludC5jYWxsKHRoaXMpW2ZuXShmYWxzZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdWludDY0OiBmdW5jdGlvbiByZWFkX3VpbnQ2NCgpIHtcbiAgICAgICAgICAgIHJldHVybiByZWFkTG9uZ1ZhcmludC5jYWxsKHRoaXMpW2ZuXSh0cnVlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBzaW50NjQ6IGZ1bmN0aW9uIHJlYWRfc2ludDY0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlYWRMb25nVmFyaW50LmNhbGwodGhpcykuenpEZWNvZGUoKVtmbl0oZmFsc2UpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpeGVkNjQ6IGZ1bmN0aW9uIHJlYWRfZml4ZWQ2NCgpIHtcbiAgICAgICAgICAgIHJldHVybiByZWFkRml4ZWQ2NC5jYWxsKHRoaXMpW2ZuXSh0cnVlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBzZml4ZWQ2NDogZnVuY3Rpb24gcmVhZF9zZml4ZWQ2NCgpIHtcbiAgICAgICAgICAgIHJldHVybiByZWFkRml4ZWQ2NC5jYWxsKHRoaXMpW2ZuXShmYWxzZSk7XG4gICAgICAgIH1cblxuICAgIH0pO1xufTtcbiIsICJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gQnVmZmVyUmVhZGVyO1xuXG4vLyBleHRlbmRzIFJlYWRlclxudmFyIFJlYWRlciA9IHJlcXVpcmUoXCIuL3JlYWRlclwiKTtcbihCdWZmZXJSZWFkZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShSZWFkZXIucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBCdWZmZXJSZWFkZXI7XG5cbnZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbC9taW5pbWFsXCIpO1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgYnVmZmVyIHJlYWRlciBpbnN0YW5jZS5cbiAqIEBjbGFzc2Rlc2MgV2lyZSBmb3JtYXQgcmVhZGVyIHVzaW5nIG5vZGUgYnVmZmVycy5cbiAqIEBleHRlbmRzIFJlYWRlclxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmZmVyIEJ1ZmZlciB0byByZWFkIGZyb21cbiAqL1xuZnVuY3Rpb24gQnVmZmVyUmVhZGVyKGJ1ZmZlcikge1xuICAgIFJlYWRlci5jYWxsKHRoaXMsIGJ1ZmZlcik7XG5cbiAgICAvKipcbiAgICAgKiBSZWFkIGJ1ZmZlci5cbiAgICAgKiBAbmFtZSBCdWZmZXJSZWFkZXIjYnVmXG4gICAgICogQHR5cGUge0J1ZmZlcn1cbiAgICAgKi9cbn1cblxuQnVmZmVyUmVhZGVyLl9jb25maWd1cmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAodXRpbC5CdWZmZXIpXG4gICAgICAgIEJ1ZmZlclJlYWRlci5wcm90b3R5cGUuX3NsaWNlID0gdXRpbC5CdWZmZXIucHJvdG90eXBlLnNsaWNlO1xufTtcblxuXG4vKipcbiAqIEBvdmVycmlkZVxuICovXG5CdWZmZXJSZWFkZXIucHJvdG90eXBlLnN0cmluZyA9IGZ1bmN0aW9uIHJlYWRfc3RyaW5nX2J1ZmZlcigpIHtcbiAgICB2YXIgbGVuID0gdGhpcy51aW50MzIoKTsgLy8gbW9kaWZpZXMgcG9zXG4gICAgcmV0dXJuIHRoaXMuYnVmLnV0ZjhTbGljZVxuICAgICAgICA/IHRoaXMuYnVmLnV0ZjhTbGljZSh0aGlzLnBvcywgdGhpcy5wb3MgPSBNYXRoLm1pbih0aGlzLnBvcyArIGxlbiwgdGhpcy5sZW4pKVxuICAgICAgICA6IHRoaXMuYnVmLnRvU3RyaW5nKFwidXRmLThcIiwgdGhpcy5wb3MsIHRoaXMucG9zID0gTWF0aC5taW4odGhpcy5wb3MgKyBsZW4sIHRoaXMubGVuKSk7XG59O1xuXG4vKipcbiAqIFJlYWRzIGEgc2VxdWVuY2Ugb2YgYnl0ZXMgcHJlY2VlZGVkIGJ5IGl0cyBsZW5ndGggYXMgYSB2YXJpbnQuXG4gKiBAbmFtZSBCdWZmZXJSZWFkZXIjYnl0ZXNcbiAqIEBmdW5jdGlvblxuICogQHJldHVybnMge0J1ZmZlcn0gVmFsdWUgcmVhZFxuICovXG5cbkJ1ZmZlclJlYWRlci5fY29uZmlndXJlKCk7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IFNlcnZpY2U7XG5cbnZhciB1dGlsID0gcmVxdWlyZShcIi4uL3V0aWwvbWluaW1hbFwiKTtcblxuLy8gRXh0ZW5kcyBFdmVudEVtaXR0ZXJcbihTZXJ2aWNlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodXRpbC5FdmVudEVtaXR0ZXIucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBTZXJ2aWNlO1xuXG4vKipcbiAqIEEgc2VydmljZSBtZXRob2QgY2FsbGJhY2sgYXMgdXNlZCBieSB7QGxpbmsgcnBjLlNlcnZpY2VNZXRob2R8U2VydmljZU1ldGhvZH0uXG4gKlxuICogRGlmZmVycyBmcm9tIHtAbGluayBSUENJbXBsQ2FsbGJhY2t9IGluIHRoYXQgaXQgaXMgYW4gYWN0dWFsIGNhbGxiYWNrIG9mIGEgc2VydmljZSBtZXRob2Qgd2hpY2ggbWF5IG5vdCByZXR1cm4gYHJlc3BvbnNlID0gbnVsbGAuXG4gKiBAdHlwZWRlZiBycGMuU2VydmljZU1ldGhvZENhbGxiYWNrXG4gKiBAdGVtcGxhdGUgVFJlcyBleHRlbmRzIE1lc3NhZ2U8VFJlcz5cbiAqIEB0eXBlIHtmdW5jdGlvbn1cbiAqIEBwYXJhbSB7RXJyb3J8bnVsbH0gZXJyb3IgRXJyb3IsIGlmIGFueVxuICogQHBhcmFtIHtUUmVzfSBbcmVzcG9uc2VdIFJlc3BvbnNlIG1lc3NhZ2VcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKi9cblxuLyoqXG4gKiBBIHNlcnZpY2UgbWV0aG9kIHBhcnQgb2YgYSB7QGxpbmsgcnBjLlNlcnZpY2V9IGFzIGNyZWF0ZWQgYnkge0BsaW5rIFNlcnZpY2UuY3JlYXRlfS5cbiAqIEB0eXBlZGVmIHJwYy5TZXJ2aWNlTWV0aG9kXG4gKiBAdGVtcGxhdGUgVFJlcSBleHRlbmRzIE1lc3NhZ2U8VFJlcT5cbiAqIEB0ZW1wbGF0ZSBUUmVzIGV4dGVuZHMgTWVzc2FnZTxUUmVzPlxuICogQHR5cGUge2Z1bmN0aW9ufVxuICogQHBhcmFtIHtUUmVxfFByb3BlcnRpZXM8VFJlcT59IHJlcXVlc3QgUmVxdWVzdCBtZXNzYWdlIG9yIHBsYWluIG9iamVjdFxuICogQHBhcmFtIHtycGMuU2VydmljZU1ldGhvZENhbGxiYWNrPFRSZXM+fSBbY2FsbGJhY2tdIE5vZGUtc3R5bGUgY2FsbGJhY2sgY2FsbGVkIHdpdGggdGhlIGVycm9yLCBpZiBhbnksIGFuZCB0aGUgcmVzcG9uc2UgbWVzc2FnZVxuICogQHJldHVybnMge1Byb21pc2U8TWVzc2FnZTxUUmVzPj59IFByb21pc2UgaWYgYGNhbGxiYWNrYCBoYXMgYmVlbiBvbWl0dGVkLCBvdGhlcndpc2UgYHVuZGVmaW5lZGBcbiAqL1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgUlBDIHNlcnZpY2UgaW5zdGFuY2UuXG4gKiBAY2xhc3NkZXNjIEFuIFJQQyBzZXJ2aWNlIGFzIHJldHVybmVkIGJ5IHtAbGluayBTZXJ2aWNlI2NyZWF0ZX0uXG4gKiBAZXhwb3J0cyBycGMuU2VydmljZVxuICogQGV4dGVuZHMgdXRpbC5FdmVudEVtaXR0ZXJcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtSUENJbXBsfSBycGNJbXBsIFJQQyBpbXBsZW1lbnRhdGlvblxuICogQHBhcmFtIHtib29sZWFufSBbcmVxdWVzdERlbGltaXRlZD1mYWxzZV0gV2hldGhlciByZXF1ZXN0cyBhcmUgbGVuZ3RoLWRlbGltaXRlZFxuICogQHBhcmFtIHtib29sZWFufSBbcmVzcG9uc2VEZWxpbWl0ZWQ9ZmFsc2VdIFdoZXRoZXIgcmVzcG9uc2VzIGFyZSBsZW5ndGgtZGVsaW1pdGVkXG4gKi9cbmZ1bmN0aW9uIFNlcnZpY2UocnBjSW1wbCwgcmVxdWVzdERlbGltaXRlZCwgcmVzcG9uc2VEZWxpbWl0ZWQpIHtcblxuICAgIGlmICh0eXBlb2YgcnBjSW1wbCAhPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJycGNJbXBsIG11c3QgYmUgYSBmdW5jdGlvblwiKTtcblxuICAgIHV0aWwuRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBSUEMgaW1wbGVtZW50YXRpb24uIEJlY29tZXMgYG51bGxgIG9uY2UgdGhlIHNlcnZpY2UgaXMgZW5kZWQuXG4gICAgICogQHR5cGUge1JQQ0ltcGx8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLnJwY0ltcGwgPSBycGNJbXBsO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciByZXF1ZXN0cyBhcmUgbGVuZ3RoLWRlbGltaXRlZC5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnJlcXVlc3REZWxpbWl0ZWQgPSBCb29sZWFuKHJlcXVlc3REZWxpbWl0ZWQpO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciByZXNwb25zZXMgYXJlIGxlbmd0aC1kZWxpbWl0ZWQuXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5yZXNwb25zZURlbGltaXRlZCA9IEJvb2xlYW4ocmVzcG9uc2VEZWxpbWl0ZWQpO1xufVxuXG4vKipcbiAqIENhbGxzIGEgc2VydmljZSBtZXRob2QgdGhyb3VnaCB7QGxpbmsgcnBjLlNlcnZpY2UjcnBjSW1wbHxycGNJbXBsfS5cbiAqIEBwYXJhbSB7TWV0aG9kfHJwYy5TZXJ2aWNlTWV0aG9kPFRSZXEsVFJlcz59IG1ldGhvZCBSZWZsZWN0ZWQgb3Igc3RhdGljIG1ldGhvZFxuICogQHBhcmFtIHtDb25zdHJ1Y3RvcjxUUmVxPn0gcmVxdWVzdEN0b3IgUmVxdWVzdCBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtDb25zdHJ1Y3RvcjxUUmVzPn0gcmVzcG9uc2VDdG9yIFJlc3BvbnNlIGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1RSZXF8UHJvcGVydGllczxUUmVxPn0gcmVxdWVzdCBSZXF1ZXN0IG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0XG4gKiBAcGFyYW0ge3JwYy5TZXJ2aWNlTWV0aG9kQ2FsbGJhY2s8VFJlcz59IGNhbGxiYWNrIFNlcnZpY2UgY2FsbGJhY2tcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKiBAdGVtcGxhdGUgVFJlcSBleHRlbmRzIE1lc3NhZ2U8VFJlcT5cbiAqIEB0ZW1wbGF0ZSBUUmVzIGV4dGVuZHMgTWVzc2FnZTxUUmVzPlxuICovXG5TZXJ2aWNlLnByb3RvdHlwZS5ycGNDYWxsID0gZnVuY3Rpb24gcnBjQ2FsbChtZXRob2QsIHJlcXVlc3RDdG9yLCByZXNwb25zZUN0b3IsIHJlcXVlc3QsIGNhbGxiYWNrKSB7XG5cbiAgICBpZiAoIXJlcXVlc3QpXG4gICAgICAgIHRocm93IFR5cGVFcnJvcihcInJlcXVlc3QgbXVzdCBiZSBzcGVjaWZpZWRcIik7XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgaWYgKCFjYWxsYmFjaylcbiAgICAgICAgcmV0dXJuIHV0aWwuYXNQcm9taXNlKHJwY0NhbGwsIHNlbGYsIG1ldGhvZCwgcmVxdWVzdEN0b3IsIHJlc3BvbnNlQ3RvciwgcmVxdWVzdCk7XG5cbiAgICBpZiAoIXNlbGYucnBjSW1wbCkge1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyBjYWxsYmFjayhFcnJvcihcImFscmVhZHkgZW5kZWRcIikpOyB9LCAwKTtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gc2VsZi5ycGNJbXBsKFxuICAgICAgICAgICAgbWV0aG9kLFxuICAgICAgICAgICAgcmVxdWVzdEN0b3Jbc2VsZi5yZXF1ZXN0RGVsaW1pdGVkID8gXCJlbmNvZGVEZWxpbWl0ZWRcIiA6IFwiZW5jb2RlXCJdKHJlcXVlc3QpLmZpbmlzaCgpLFxuICAgICAgICAgICAgZnVuY3Rpb24gcnBjQ2FsbGJhY2soZXJyLCByZXNwb25zZSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmVtaXQoXCJlcnJvclwiLCBlcnIsIG1ldGhvZCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmVuZCgvKiBlbmRlZEJ5UlBDICovIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghKHJlc3BvbnNlIGluc3RhbmNlb2YgcmVzcG9uc2VDdG9yKSkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSByZXNwb25zZUN0b3Jbc2VsZi5yZXNwb25zZURlbGltaXRlZCA/IFwiZGVjb2RlRGVsaW1pdGVkXCIgOiBcImRlY29kZVwiXShyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5lbWl0KFwiZXJyb3JcIiwgZXJyLCBtZXRob2QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzZWxmLmVtaXQoXCJkYXRhXCIsIHJlc3BvbnNlLCBtZXRob2QpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCByZXNwb25zZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHNlbGYuZW1pdChcImVycm9yXCIsIGVyciwgbWV0aG9kKTtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHsgY2FsbGJhY2soZXJyKTsgfSwgMCk7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufTtcblxuLyoqXG4gKiBFbmRzIHRoaXMgc2VydmljZSBhbmQgZW1pdHMgdGhlIGBlbmRgIGV2ZW50LlxuICogQHBhcmFtIHtib29sZWFufSBbZW5kZWRCeVJQQz1mYWxzZV0gV2hldGhlciB0aGUgc2VydmljZSBoYXMgYmVlbiBlbmRlZCBieSB0aGUgUlBDIGltcGxlbWVudGF0aW9uLlxuICogQHJldHVybnMge3JwYy5TZXJ2aWNlfSBgdGhpc2BcbiAqL1xuU2VydmljZS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gZW5kKGVuZGVkQnlSUEMpIHtcbiAgICBpZiAodGhpcy5ycGNJbXBsKSB7XG4gICAgICAgIGlmICghZW5kZWRCeVJQQykgLy8gc2lnbmFsIGVuZCB0byBycGNJbXBsXG4gICAgICAgICAgICB0aGlzLnJwY0ltcGwobnVsbCwgbnVsbCwgbnVsbCk7XG4gICAgICAgIHRoaXMucnBjSW1wbCA9IG51bGw7XG4gICAgICAgIHRoaXMuZW1pdChcImVuZFwiKS5vZmYoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIFN0cmVhbWluZyBSUEMgaGVscGVycy5cbiAqIEBuYW1lc3BhY2VcbiAqL1xudmFyIHJwYyA9IGV4cG9ydHM7XG5cbi8qKlxuICogUlBDIGltcGxlbWVudGF0aW9uIHBhc3NlZCB0byB7QGxpbmsgU2VydmljZSNjcmVhdGV9IHBlcmZvcm1pbmcgYSBzZXJ2aWNlIHJlcXVlc3Qgb24gbmV0d29yayBsZXZlbCwgaS5lLiBieSB1dGlsaXppbmcgaHR0cCByZXF1ZXN0cyBvciB3ZWJzb2NrZXRzLlxuICogQHR5cGVkZWYgUlBDSW1wbFxuICogQHR5cGUge2Z1bmN0aW9ufVxuICogQHBhcmFtIHtNZXRob2R8cnBjLlNlcnZpY2VNZXRob2Q8TWVzc2FnZTx7fT4sTWVzc2FnZTx7fT4+fSBtZXRob2QgUmVmbGVjdGVkIG9yIHN0YXRpYyBtZXRob2QgYmVpbmcgY2FsbGVkXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHJlcXVlc3REYXRhIFJlcXVlc3QgZGF0YVxuICogQHBhcmFtIHtSUENJbXBsQ2FsbGJhY2t9IGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICogQGV4YW1wbGVcbiAqIGZ1bmN0aW9uIHJwY0ltcGwobWV0aG9kLCByZXF1ZXN0RGF0YSwgY2FsbGJhY2spIHtcbiAqICAgICBpZiAocHJvdG9idWYudXRpbC5sY0ZpcnN0KG1ldGhvZC5uYW1lKSAhPT0gXCJteU1ldGhvZFwiKSAvLyBjb21wYXRpYmxlIHdpdGggc3RhdGljIGNvZGVcbiAqICAgICAgICAgdGhyb3cgRXJyb3IoXCJubyBzdWNoIG1ldGhvZFwiKTtcbiAqICAgICBhc3luY2hyb25vdXNseU9idGFpbkFSZXNwb25zZShyZXF1ZXN0RGF0YSwgZnVuY3Rpb24oZXJyLCByZXNwb25zZURhdGEpIHtcbiAqICAgICAgICAgY2FsbGJhY2soZXJyLCByZXNwb25zZURhdGEpO1xuICogICAgIH0pO1xuICogfVxuICovXG5cbi8qKlxuICogTm9kZS1zdHlsZSBjYWxsYmFjayBhcyB1c2VkIGJ5IHtAbGluayBSUENJbXBsfS5cbiAqIEB0eXBlZGVmIFJQQ0ltcGxDYWxsYmFja1xuICogQHR5cGUge2Z1bmN0aW9ufVxuICogQHBhcmFtIHtFcnJvcnxudWxsfSBlcnJvciBFcnJvciwgaWYgYW55LCBvdGhlcndpc2UgYG51bGxgXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl8bnVsbH0gW3Jlc3BvbnNlXSBSZXNwb25zZSBkYXRhIG9yIGBudWxsYCB0byBzaWduYWwgZW5kIG9mIHN0cmVhbSwgaWYgdGhlcmUgaGFzbid0IGJlZW4gYW4gZXJyb3JcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKi9cblxucnBjLlNlcnZpY2UgPSByZXF1aXJlKFwiLi9ycGMvc2VydmljZVwiKTtcbiIsICJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0ge307XG5cbi8qKlxuICogTmFtZWQgcm9vdHMuXG4gKiBUaGlzIGlzIHdoZXJlIHBianMgc3RvcmVzIGdlbmVyYXRlZCBzdHJ1Y3R1cmVzICh0aGUgb3B0aW9uIGAtciwgLS1yb290YCBzcGVjaWZpZXMgYSBuYW1lKS5cbiAqIENhbiBhbHNvIGJlIHVzZWQgbWFudWFsbHkgdG8gbWFrZSByb290cyBhdmFpbGFibGUgYWNyb3NzIG1vZHVsZXMuXG4gKiBAbmFtZSByb290c1xuICogQHR5cGUge09iamVjdC48c3RyaW5nLFJvb3Q+fVxuICogQGV4YW1wbGVcbiAqIC8vIHBianMgLXIgbXlyb290IC1vIGNvbXBpbGVkLmpzIC4uLlxuICpcbiAqIC8vIGluIGFub3RoZXIgbW9kdWxlOlxuICogcmVxdWlyZShcIi4vY29tcGlsZWQuanNcIik7XG4gKlxuICogLy8gaW4gYW55IHN1YnNlcXVlbnQgbW9kdWxlOlxuICogdmFyIHJvb3QgPSBwcm90b2J1Zi5yb290c1tcIm15cm9vdFwiXTtcbiAqL1xuIiwgIlwidXNlIHN0cmljdFwiO1xudmFyIHByb3RvYnVmID0gZXhwb3J0cztcblxuLyoqXG4gKiBCdWlsZCB0eXBlLCBvbmUgb2YgYFwiZnVsbFwiYCwgYFwibGlnaHRcImAgb3IgYFwibWluaW1hbFwiYC5cbiAqIEBuYW1lIGJ1aWxkXG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQGNvbnN0XG4gKi9cbnByb3RvYnVmLmJ1aWxkID0gXCJtaW5pbWFsXCI7XG5cbi8vIFNlcmlhbGl6YXRpb25cbnByb3RvYnVmLldyaXRlciAgICAgICA9IHJlcXVpcmUoXCIuL3dyaXRlclwiKTtcbnByb3RvYnVmLkJ1ZmZlcldyaXRlciA9IHJlcXVpcmUoXCIuL3dyaXRlcl9idWZmZXJcIik7XG5wcm90b2J1Zi5SZWFkZXIgICAgICAgPSByZXF1aXJlKFwiLi9yZWFkZXJcIik7XG5wcm90b2J1Zi5CdWZmZXJSZWFkZXIgPSByZXF1aXJlKFwiLi9yZWFkZXJfYnVmZmVyXCIpO1xuXG4vLyBVdGlsaXR5XG5wcm90b2J1Zi51dGlsICAgICAgICAgPSByZXF1aXJlKFwiLi91dGlsL21pbmltYWxcIik7XG5wcm90b2J1Zi5ycGMgICAgICAgICAgPSByZXF1aXJlKFwiLi9ycGNcIik7XG5wcm90b2J1Zi5yb290cyAgICAgICAgPSByZXF1aXJlKFwiLi9yb290c1wiKTtcbnByb3RvYnVmLmNvbmZpZ3VyZSAgICA9IGNvbmZpZ3VyZTtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbi8qKlxuICogUmVjb25maWd1cmVzIHRoZSBsaWJyYXJ5IGFjY29yZGluZyB0byB0aGUgZW52aXJvbm1lbnQuXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICovXG5mdW5jdGlvbiBjb25maWd1cmUoKSB7XG4gICAgcHJvdG9idWYudXRpbC5fY29uZmlndXJlKCk7XG4gICAgcHJvdG9idWYuV3JpdGVyLl9jb25maWd1cmUocHJvdG9idWYuQnVmZmVyV3JpdGVyKTtcbiAgICBwcm90b2J1Zi5SZWFkZXIuX2NvbmZpZ3VyZShwcm90b2J1Zi5CdWZmZXJSZWFkZXIpO1xufVxuXG4vLyBTZXQgdXAgYnVmZmVyIHV0aWxpdHkgYWNjb3JkaW5nIHRvIHRoZSBlbnZpcm9ubWVudFxuY29uZmlndXJlKCk7XG4iLCAiLy8gbWluaW1hbCBsaWJyYXJ5IGVudHJ5IHBvaW50LlxuXG5cInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vc3JjL2luZGV4LW1pbmltYWxcIik7XG4iLCAiLyplc2xpbnQtZGlzYWJsZSBibG9jay1zY29wZWQtdmFyLCBpZC1sZW5ndGgsIG5vLWNvbnRyb2wtcmVnZXgsIG5vLW1hZ2ljLW51bWJlcnMsIG5vLXByb3RvdHlwZS1idWlsdGlucywgbm8tcmVkZWNsYXJlLCBuby1zaGFkb3csIG5vLXZhciwgc29ydC12YXJzKi9cblwidXNlIHN0cmljdFwiO1xuXG52YXIgJHByb3RvYnVmID0gcmVxdWlyZShcInByb3RvYnVmanMvbWluaW1hbFwiKTtcblxuLy8gQ29tbW9uIGFsaWFzZXNcbnZhciAkUmVhZGVyID0gJHByb3RvYnVmLlJlYWRlciwgJFdyaXRlciA9ICRwcm90b2J1Zi5Xcml0ZXIsICR1dGlsID0gJHByb3RvYnVmLnV0aWw7XG5cbi8vIEV4cG9ydGVkIHJvb3QgbmFtZXNwYWNlXG52YXIgJHJvb3QgPSAkcHJvdG9idWYucm9vdHNbXCJkZWZhdWx0XCJdIHx8ICgkcHJvdG9idWYucm9vdHNbXCJkZWZhdWx0XCJdID0ge30pO1xuXG4kcm9vdC5vbm54ID0gKGZ1bmN0aW9uKCkge1xuXG4gICAgLyoqXG4gICAgICogTmFtZXNwYWNlIG9ubnguXG4gICAgICogQGV4cG9ydHMgb25ueFxuICAgICAqIEBuYW1lc3BhY2VcbiAgICAgKi9cbiAgICB2YXIgb25ueCA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogVmVyc2lvbiBlbnVtLlxuICAgICAqIEBuYW1lIG9ubnguVmVyc2lvblxuICAgICAqIEBlbnVtIHtudW1iZXJ9XG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IF9TVEFSVF9WRVJTSU9OPTAgX1NUQVJUX1ZFUlNJT04gdmFsdWVcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gSVJfVkVSU0lPTl8yMDE3XzEwXzEwPTEgSVJfVkVSU0lPTl8yMDE3XzEwXzEwIHZhbHVlXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IElSX1ZFUlNJT05fMjAxN18xMF8zMD0yIElSX1ZFUlNJT05fMjAxN18xMF8zMCB2YWx1ZVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBJUl9WRVJTSU9OXzIwMTdfMTFfMz0zIElSX1ZFUlNJT05fMjAxN18xMV8zIHZhbHVlXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IElSX1ZFUlNJT05fMjAxOV8xXzIyPTQgSVJfVkVSU0lPTl8yMDE5XzFfMjIgdmFsdWVcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gSVJfVkVSU0lPTl8yMDE5XzNfMTg9NSBJUl9WRVJTSU9OXzIwMTlfM18xOCB2YWx1ZVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBJUl9WRVJTSU9OXzIwMTlfOV8xOT02IElSX1ZFUlNJT05fMjAxOV85XzE5IHZhbHVlXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IElSX1ZFUlNJT05fMjAyMF81Xzg9NyBJUl9WRVJTSU9OXzIwMjBfNV84IHZhbHVlXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IElSX1ZFUlNJT05fMjAyMV83XzMwPTggSVJfVkVSU0lPTl8yMDIxXzdfMzAgdmFsdWVcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gSVJfVkVSU0lPTj05IElSX1ZFUlNJT04gdmFsdWVcbiAgICAgKi9cbiAgICBvbm54LlZlcnNpb24gPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2YWx1ZXNCeUlkID0ge30sIHZhbHVlcyA9IE9iamVjdC5jcmVhdGUodmFsdWVzQnlJZCk7XG4gICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzBdID0gXCJfU1RBUlRfVkVSU0lPTlwiXSA9IDA7XG4gICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzFdID0gXCJJUl9WRVJTSU9OXzIwMTdfMTBfMTBcIl0gPSAxO1xuICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFsyXSA9IFwiSVJfVkVSU0lPTl8yMDE3XzEwXzMwXCJdID0gMjtcbiAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbM10gPSBcIklSX1ZFUlNJT05fMjAxN18xMV8zXCJdID0gMztcbiAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbNF0gPSBcIklSX1ZFUlNJT05fMjAxOV8xXzIyXCJdID0gNDtcbiAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbNV0gPSBcIklSX1ZFUlNJT05fMjAxOV8zXzE4XCJdID0gNTtcbiAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbNl0gPSBcIklSX1ZFUlNJT05fMjAxOV85XzE5XCJdID0gNjtcbiAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbN10gPSBcIklSX1ZFUlNJT05fMjAyMF81XzhcIl0gPSA3O1xuICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFs4XSA9IFwiSVJfVkVSU0lPTl8yMDIxXzdfMzBcIl0gPSA4O1xuICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFs5XSA9IFwiSVJfVkVSU0lPTlwiXSA9IDk7XG4gICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgfSkoKTtcblxuICAgIG9ubnguQXR0cmlidXRlUHJvdG8gPSAoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb3BlcnRpZXMgb2YgYW4gQXR0cmlidXRlUHJvdG8uXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54XG4gICAgICAgICAqIEBpbnRlcmZhY2UgSUF0dHJpYnV0ZVByb3RvXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfG51bGx9IFtuYW1lXSBBdHRyaWJ1dGVQcm90byBuYW1lXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfG51bGx9IFtyZWZBdHRyTmFtZV0gQXR0cmlidXRlUHJvdG8gcmVmQXR0ck5hbWVcbiAgICAgICAgICogQHByb3BlcnR5IHtzdHJpbmd8bnVsbH0gW2RvY1N0cmluZ10gQXR0cmlidXRlUHJvdG8gZG9jU3RyaW5nXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7b25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlfG51bGx9IFt0eXBlXSBBdHRyaWJ1dGVQcm90byB0eXBlXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfG51bGx9IFtmXSBBdHRyaWJ1dGVQcm90byBmXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfExvbmd8bnVsbH0gW2ldIEF0dHJpYnV0ZVByb3RvIGlcbiAgICAgICAgICogQHByb3BlcnR5IHtVaW50OEFycmF5fG51bGx9IFtzXSBBdHRyaWJ1dGVQcm90byBzXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7b25ueC5JVGVuc29yUHJvdG98bnVsbH0gW3RdIEF0dHJpYnV0ZVByb3RvIHRcbiAgICAgICAgICogQHByb3BlcnR5IHtvbm54LklHcmFwaFByb3RvfG51bGx9IFtnXSBBdHRyaWJ1dGVQcm90byBnXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7b25ueC5JU3BhcnNlVGVuc29yUHJvdG98bnVsbH0gW3NwYXJzZVRlbnNvcl0gQXR0cmlidXRlUHJvdG8gc3BhcnNlVGVuc29yXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7b25ueC5JVHlwZVByb3RvfG51bGx9IFt0cF0gQXR0cmlidXRlUHJvdG8gdHBcbiAgICAgICAgICogQHByb3BlcnR5IHtBcnJheS48bnVtYmVyPnxudWxsfSBbZmxvYXRzXSBBdHRyaWJ1dGVQcm90byBmbG9hdHNcbiAgICAgICAgICogQHByb3BlcnR5IHtBcnJheS48bnVtYmVyfExvbmc+fG51bGx9IFtpbnRzXSBBdHRyaWJ1dGVQcm90byBpbnRzXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7QXJyYXkuPFVpbnQ4QXJyYXk+fG51bGx9IFtzdHJpbmdzXSBBdHRyaWJ1dGVQcm90byBzdHJpbmdzXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7QXJyYXkuPG9ubnguSVRlbnNvclByb3RvPnxudWxsfSBbdGVuc29yc10gQXR0cmlidXRlUHJvdG8gdGVuc29yc1xuICAgICAgICAgKiBAcHJvcGVydHkge0FycmF5Ljxvbm54LklHcmFwaFByb3RvPnxudWxsfSBbZ3JhcGhzXSBBdHRyaWJ1dGVQcm90byBncmFwaHNcbiAgICAgICAgICogQHByb3BlcnR5IHtBcnJheS48b25ueC5JU3BhcnNlVGVuc29yUHJvdG8+fG51bGx9IFtzcGFyc2VUZW5zb3JzXSBBdHRyaWJ1dGVQcm90byBzcGFyc2VUZW5zb3JzXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7QXJyYXkuPG9ubnguSVR5cGVQcm90bz58bnVsbH0gW3R5cGVQcm90b3NdIEF0dHJpYnV0ZVByb3RvIHR5cGVQcm90b3NcbiAgICAgICAgICovXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnN0cnVjdHMgYSBuZXcgQXR0cmlidXRlUHJvdG8uXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54XG4gICAgICAgICAqIEBjbGFzc2Rlc2MgUmVwcmVzZW50cyBhbiBBdHRyaWJ1dGVQcm90by5cbiAgICAgICAgICogQGltcGxlbWVudHMgSUF0dHJpYnV0ZVByb3RvXG4gICAgICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAgICAgKiBAcGFyYW0ge29ubnguSUF0dHJpYnV0ZVByb3RvPX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBBdHRyaWJ1dGVQcm90byhwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICB0aGlzLmZsb2F0cyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5pbnRzID0gW107XG4gICAgICAgICAgICB0aGlzLnN0cmluZ3MgPSBbXTtcbiAgICAgICAgICAgIHRoaXMudGVuc29ycyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5ncmFwaHMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuc3BhcnNlVGVuc29ycyA9IFtdO1xuICAgICAgICAgICAgdGhpcy50eXBlUHJvdG9zID0gW107XG4gICAgICAgICAgICBpZiAocHJvcGVydGllcylcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvcGVydGllcyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXNba2V5c1tpXV0gIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNba2V5c1tpXV0gPSBwcm9wZXJ0aWVzW2tleXNbaV1dO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEF0dHJpYnV0ZVByb3RvIG5hbWUuXG4gICAgICAgICAqIEBtZW1iZXIge3N0cmluZ30gbmFtZVxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5BdHRyaWJ1dGVQcm90b1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIEF0dHJpYnV0ZVByb3RvLnByb3RvdHlwZS5uYW1lID0gXCJcIjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQXR0cmlidXRlUHJvdG8gcmVmQXR0ck5hbWUuXG4gICAgICAgICAqIEBtZW1iZXIge3N0cmluZ30gcmVmQXR0ck5hbWVcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguQXR0cmlidXRlUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBBdHRyaWJ1dGVQcm90by5wcm90b3R5cGUucmVmQXR0ck5hbWUgPSBcIlwiO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBdHRyaWJ1dGVQcm90byBkb2NTdHJpbmcuXG4gICAgICAgICAqIEBtZW1iZXIge3N0cmluZ30gZG9jU3RyaW5nXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LkF0dHJpYnV0ZVByb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgQXR0cmlidXRlUHJvdG8ucHJvdG90eXBlLmRvY1N0cmluZyA9IFwiXCI7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEF0dHJpYnV0ZVByb3RvIHR5cGUuXG4gICAgICAgICAqIEBtZW1iZXIge29ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZX0gdHlwZVxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5BdHRyaWJ1dGVQcm90b1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIEF0dHJpYnV0ZVByb3RvLnByb3RvdHlwZS50eXBlID0gMDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQXR0cmlidXRlUHJvdG8gZi5cbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfSBmXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LkF0dHJpYnV0ZVByb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgQXR0cmlidXRlUHJvdG8ucHJvdG90eXBlLmYgPSAwO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBdHRyaWJ1dGVQcm90byBpLlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ8TG9uZ30gaVxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5BdHRyaWJ1dGVQcm90b1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIEF0dHJpYnV0ZVByb3RvLnByb3RvdHlwZS5pID0gJHV0aWwuTG9uZyA/ICR1dGlsLkxvbmcuZnJvbUJpdHMoMCwwLGZhbHNlKSA6IDA7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEF0dHJpYnV0ZVByb3RvIHMuXG4gICAgICAgICAqIEBtZW1iZXIge1VpbnQ4QXJyYXl9IHNcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguQXR0cmlidXRlUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBBdHRyaWJ1dGVQcm90by5wcm90b3R5cGUucyA9ICR1dGlsLm5ld0J1ZmZlcihbXSk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEF0dHJpYnV0ZVByb3RvIHQuXG4gICAgICAgICAqIEBtZW1iZXIge29ubnguSVRlbnNvclByb3RvfG51bGx8dW5kZWZpbmVkfSB0XG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LkF0dHJpYnV0ZVByb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgQXR0cmlidXRlUHJvdG8ucHJvdG90eXBlLnQgPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBdHRyaWJ1dGVQcm90byBnLlxuICAgICAgICAgKiBAbWVtYmVyIHtvbm54LklHcmFwaFByb3RvfG51bGx8dW5kZWZpbmVkfSBnXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LkF0dHJpYnV0ZVByb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgQXR0cmlidXRlUHJvdG8ucHJvdG90eXBlLmcgPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBdHRyaWJ1dGVQcm90byBzcGFyc2VUZW5zb3IuXG4gICAgICAgICAqIEBtZW1iZXIge29ubnguSVNwYXJzZVRlbnNvclByb3RvfG51bGx8dW5kZWZpbmVkfSBzcGFyc2VUZW5zb3JcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguQXR0cmlidXRlUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBBdHRyaWJ1dGVQcm90by5wcm90b3R5cGUuc3BhcnNlVGVuc29yID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQXR0cmlidXRlUHJvdG8gdHAuXG4gICAgICAgICAqIEBtZW1iZXIge29ubnguSVR5cGVQcm90b3xudWxsfHVuZGVmaW5lZH0gdHBcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguQXR0cmlidXRlUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBBdHRyaWJ1dGVQcm90by5wcm90b3R5cGUudHAgPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBdHRyaWJ1dGVQcm90byBmbG9hdHMuXG4gICAgICAgICAqIEBtZW1iZXIge0FycmF5LjxudW1iZXI+fSBmbG9hdHNcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguQXR0cmlidXRlUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBBdHRyaWJ1dGVQcm90by5wcm90b3R5cGUuZmxvYXRzID0gJHV0aWwuZW1wdHlBcnJheTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQXR0cmlidXRlUHJvdG8gaW50cy5cbiAgICAgICAgICogQG1lbWJlciB7QXJyYXkuPG51bWJlcnxMb25nPn0gaW50c1xuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5BdHRyaWJ1dGVQcm90b1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIEF0dHJpYnV0ZVByb3RvLnByb3RvdHlwZS5pbnRzID0gJHV0aWwuZW1wdHlBcnJheTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQXR0cmlidXRlUHJvdG8gc3RyaW5ncy5cbiAgICAgICAgICogQG1lbWJlciB7QXJyYXkuPFVpbnQ4QXJyYXk+fSBzdHJpbmdzXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LkF0dHJpYnV0ZVByb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgQXR0cmlidXRlUHJvdG8ucHJvdG90eXBlLnN0cmluZ3MgPSAkdXRpbC5lbXB0eUFycmF5O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBdHRyaWJ1dGVQcm90byB0ZW5zb3JzLlxuICAgICAgICAgKiBAbWVtYmVyIHtBcnJheS48b25ueC5JVGVuc29yUHJvdG8+fSB0ZW5zb3JzXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LkF0dHJpYnV0ZVByb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgQXR0cmlidXRlUHJvdG8ucHJvdG90eXBlLnRlbnNvcnMgPSAkdXRpbC5lbXB0eUFycmF5O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBdHRyaWJ1dGVQcm90byBncmFwaHMuXG4gICAgICAgICAqIEBtZW1iZXIge0FycmF5Ljxvbm54LklHcmFwaFByb3RvPn0gZ3JhcGhzXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LkF0dHJpYnV0ZVByb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgQXR0cmlidXRlUHJvdG8ucHJvdG90eXBlLmdyYXBocyA9ICR1dGlsLmVtcHR5QXJyYXk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEF0dHJpYnV0ZVByb3RvIHNwYXJzZVRlbnNvcnMuXG4gICAgICAgICAqIEBtZW1iZXIge0FycmF5Ljxvbm54LklTcGFyc2VUZW5zb3JQcm90bz59IHNwYXJzZVRlbnNvcnNcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguQXR0cmlidXRlUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBBdHRyaWJ1dGVQcm90by5wcm90b3R5cGUuc3BhcnNlVGVuc29ycyA9ICR1dGlsLmVtcHR5QXJyYXk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEF0dHJpYnV0ZVByb3RvIHR5cGVQcm90b3MuXG4gICAgICAgICAqIEBtZW1iZXIge0FycmF5Ljxvbm54LklUeXBlUHJvdG8+fSB0eXBlUHJvdG9zXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LkF0dHJpYnV0ZVByb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgQXR0cmlidXRlUHJvdG8ucHJvdG90eXBlLnR5cGVQcm90b3MgPSAkdXRpbC5lbXB0eUFycmF5O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgbmV3IEF0dHJpYnV0ZVByb3RvIGluc3RhbmNlIHVzaW5nIHRoZSBzcGVjaWZpZWQgcHJvcGVydGllcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGNyZWF0ZVxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5BdHRyaWJ1dGVQcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7b25ueC5JQXR0cmlidXRlUHJvdG89fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAgICAgICAgICogQHJldHVybnMge29ubnguQXR0cmlidXRlUHJvdG99IEF0dHJpYnV0ZVByb3RvIGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBBdHRyaWJ1dGVQcm90by5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUocHJvcGVydGllcykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBBdHRyaWJ1dGVQcm90byhwcm9wZXJ0aWVzKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRW5jb2RlcyB0aGUgc3BlY2lmaWVkIEF0dHJpYnV0ZVByb3RvIG1lc3NhZ2UuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIG9ubnguQXR0cmlidXRlUHJvdG8udmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBlbmNvZGVcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguQXR0cmlidXRlUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge29ubnguSUF0dHJpYnV0ZVByb3RvfSBtZXNzYWdlIEF0dHJpYnV0ZVByb3RvIG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0IHRvIGVuY29kZVxuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAgICAgICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAgICAgKi9cbiAgICAgICAgQXR0cmlidXRlUHJvdG8uZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgICAgaWYgKCF3cml0ZXIpXG4gICAgICAgICAgICAgICAgd3JpdGVyID0gJFdyaXRlci5jcmVhdGUoKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm5hbWUgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcIm5hbWVcIikpXG4gICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCAxLCB3aXJlVHlwZSAyID0qLzEwKS5zdHJpbmcobWVzc2FnZS5uYW1lKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmYgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcImZcIikpXG4gICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCAyLCB3aXJlVHlwZSA1ID0qLzIxKS5mbG9hdChtZXNzYWdlLmYpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuaSAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwiaVwiKSlcbiAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDMsIHdpcmVUeXBlIDAgPSovMjQpLmludDY0KG1lc3NhZ2UuaSk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5zICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJzXCIpKVxuICAgICAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgNCwgd2lyZVR5cGUgMiA9Ki8zNCkuYnl0ZXMobWVzc2FnZS5zKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnQgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcInRcIikpXG4gICAgICAgICAgICAgICAgJHJvb3Qub25ueC5UZW5zb3JQcm90by5lbmNvZGUobWVzc2FnZS50LCB3cml0ZXIudWludDMyKC8qIGlkIDUsIHdpcmVUeXBlIDIgPSovNDIpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5nICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJnXCIpKVxuICAgICAgICAgICAgICAgICRyb290Lm9ubnguR3JhcGhQcm90by5lbmNvZGUobWVzc2FnZS5nLCB3cml0ZXIudWludDMyKC8qIGlkIDYsIHdpcmVUeXBlIDIgPSovNTApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5mbG9hdHMgIT0gbnVsbCAmJiBtZXNzYWdlLmZsb2F0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDcsIHdpcmVUeXBlIDIgPSovNTgpLmZvcmsoKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UuZmxvYXRzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICB3cml0ZXIuZmxvYXQobWVzc2FnZS5mbG9hdHNbaV0pO1xuICAgICAgICAgICAgICAgIHdyaXRlci5sZGVsaW0oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmludHMgIT0gbnVsbCAmJiBtZXNzYWdlLmludHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCA4LCB3aXJlVHlwZSAyID0qLzY2KS5mb3JrKCk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLmludHMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIHdyaXRlci5pbnQ2NChtZXNzYWdlLmludHNbaV0pO1xuICAgICAgICAgICAgICAgIHdyaXRlci5sZGVsaW0oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnN0cmluZ3MgIT0gbnVsbCAmJiBtZXNzYWdlLnN0cmluZ3MubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5zdHJpbmdzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDksIHdpcmVUeXBlIDIgPSovNzQpLmJ5dGVzKG1lc3NhZ2Uuc3RyaW5nc1tpXSk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS50ZW5zb3JzICE9IG51bGwgJiYgbWVzc2FnZS50ZW5zb3JzLmxlbmd0aClcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UudGVuc29ycy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgJHJvb3Qub25ueC5UZW5zb3JQcm90by5lbmNvZGUobWVzc2FnZS50ZW5zb3JzW2ldLCB3cml0ZXIudWludDMyKC8qIGlkIDEwLCB3aXJlVHlwZSAyID0qLzgyKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZ3JhcGhzICE9IG51bGwgJiYgbWVzc2FnZS5ncmFwaHMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5ncmFwaHMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgICRyb290Lm9ubnguR3JhcGhQcm90by5lbmNvZGUobWVzc2FnZS5ncmFwaHNbaV0sIHdyaXRlci51aW50MzIoLyogaWQgMTEsIHdpcmVUeXBlIDIgPSovOTApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5kb2NTdHJpbmcgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcImRvY1N0cmluZ1wiKSlcbiAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDEzLCB3aXJlVHlwZSAyID0qLzEwNikuc3RyaW5nKG1lc3NhZ2UuZG9jU3RyaW5nKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnRwICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJ0cFwiKSlcbiAgICAgICAgICAgICAgICAkcm9vdC5vbm54LlR5cGVQcm90by5lbmNvZGUobWVzc2FnZS50cCwgd3JpdGVyLnVpbnQzMigvKiBpZCAxNCwgd2lyZVR5cGUgMiA9Ki8xMTQpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS50eXBlUHJvdG9zICE9IG51bGwgJiYgbWVzc2FnZS50eXBlUHJvdG9zLmxlbmd0aClcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UudHlwZVByb3Rvcy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgJHJvb3Qub25ueC5UeXBlUHJvdG8uZW5jb2RlKG1lc3NhZ2UudHlwZVByb3Rvc1tpXSwgd3JpdGVyLnVpbnQzMigvKiBpZCAxNSwgd2lyZVR5cGUgMiA9Ki8xMjIpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS50eXBlICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJ0eXBlXCIpKVxuICAgICAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMjAsIHdpcmVUeXBlIDAgPSovMTYwKS5pbnQzMihtZXNzYWdlLnR5cGUpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UucmVmQXR0ck5hbWUgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcInJlZkF0dHJOYW1lXCIpKVxuICAgICAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMjEsIHdpcmVUeXBlIDIgPSovMTcwKS5zdHJpbmcobWVzc2FnZS5yZWZBdHRyTmFtZSk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5zcGFyc2VUZW5zb3IgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcInNwYXJzZVRlbnNvclwiKSlcbiAgICAgICAgICAgICAgICAkcm9vdC5vbm54LlNwYXJzZVRlbnNvclByb3RvLmVuY29kZShtZXNzYWdlLnNwYXJzZVRlbnNvciwgd3JpdGVyLnVpbnQzMigvKiBpZCAyMiwgd2lyZVR5cGUgMiA9Ki8xNzgpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5zcGFyc2VUZW5zb3JzICE9IG51bGwgJiYgbWVzc2FnZS5zcGFyc2VUZW5zb3JzLmxlbmd0aClcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2Uuc3BhcnNlVGVuc29ycy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgJHJvb3Qub25ueC5TcGFyc2VUZW5zb3JQcm90by5lbmNvZGUobWVzc2FnZS5zcGFyc2VUZW5zb3JzW2ldLCB3cml0ZXIudWludDMyKC8qIGlkIDIzLCB3aXJlVHlwZSAyID0qLzE4NikuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBBdHRyaWJ1dGVQcm90byBtZXNzYWdlLCBsZW5ndGggZGVsaW1pdGVkLiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayBvbm54LkF0dHJpYnV0ZVByb3RvLnZlcmlmeXx2ZXJpZnl9IG1lc3NhZ2VzLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LkF0dHJpYnV0ZVByb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtvbm54LklBdHRyaWJ1dGVQcm90b30gbWVzc2FnZSBBdHRyaWJ1dGVQcm90byBtZXNzYWdlIG9yIHBsYWluIG9iamVjdCB0byBlbmNvZGVcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuV3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gZW5jb2RlIHRvXG4gICAgICAgICAqIEByZXR1cm5zIHskcHJvdG9idWYuV3JpdGVyfSBXcml0ZXJcbiAgICAgICAgICovXG4gICAgICAgIEF0dHJpYnV0ZVByb3RvLmVuY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZChtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVuY29kZShtZXNzYWdlLCB3cml0ZXIpLmxkZWxpbSgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWNvZGVzIGFuIEF0dHJpYnV0ZVByb3RvIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIuXG4gICAgICAgICAqIEBmdW5jdGlvbiBkZWNvZGVcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguQXR0cmlidXRlUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGhdIE1lc3NhZ2UgbGVuZ3RoIGlmIGtub3duIGJlZm9yZWhhbmRcbiAgICAgICAgICogQHJldHVybnMge29ubnguQXR0cmlidXRlUHJvdG99IEF0dHJpYnV0ZVByb3RvXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAgICAgKi9cbiAgICAgICAgQXR0cmlidXRlUHJvdG8uZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHJlYWRlciwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgICByZWFkZXIgPSAkUmVhZGVyLmNyZWF0ZShyZWFkZXIpO1xuICAgICAgICAgICAgdmFyIGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGgsIG1lc3NhZ2UgPSBuZXcgJHJvb3Qub25ueC5BdHRyaWJ1dGVQcm90bygpO1xuICAgICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm5hbWUgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgMjE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucmVmQXR0ck5hbWUgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgMTM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZG9jU3RyaW5nID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIDIwOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSByZWFkZXIuaW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAyOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmYgPSByZWFkZXIuZmxvYXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmkgPSByZWFkZXIuaW50NjQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSA0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnMgPSByZWFkZXIuYnl0ZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSA1OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnQgPSAkcm9vdC5vbm54LlRlbnNvclByb3RvLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgNjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5nID0gJHJvb3Qub25ueC5HcmFwaFByb3RvLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgMjI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc3BhcnNlVGVuc29yID0gJHJvb3Qub25ueC5TcGFyc2VUZW5zb3JQcm90by5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIDE0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnRwID0gJHJvb3Qub25ueC5UeXBlUHJvdG8uZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSA3OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShtZXNzYWdlLmZsb2F0cyAmJiBtZXNzYWdlLmZsb2F0cy5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZmxvYXRzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHRhZyAmIDcpID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVuZDIgPSByZWFkZXIudWludDMyKCkgKyByZWFkZXIucG9zO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kMilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5mbG9hdHMucHVzaChyZWFkZXIuZmxvYXQoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmZsb2F0cy5wdXNoKHJlYWRlci5mbG9hdCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSA4OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShtZXNzYWdlLmludHMgJiYgbWVzc2FnZS5pbnRzLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pbnRzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHRhZyAmIDcpID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVuZDIgPSByZWFkZXIudWludDMyKCkgKyByZWFkZXIucG9zO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kMilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pbnRzLnB1c2gocmVhZGVyLmludDY0KCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pbnRzLnB1c2gocmVhZGVyLmludDY0KCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIDk6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKG1lc3NhZ2Uuc3RyaW5ncyAmJiBtZXNzYWdlLnN0cmluZ3MubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnN0cmluZ3MgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc3RyaW5ncy5wdXNoKHJlYWRlci5ieXRlcygpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAxMDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEobWVzc2FnZS50ZW5zb3JzICYmIG1lc3NhZ2UudGVuc29ycy5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudGVuc29ycyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS50ZW5zb3JzLnB1c2goJHJvb3Qub25ueC5UZW5zb3JQcm90by5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAxMToge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEobWVzc2FnZS5ncmFwaHMgJiYgbWVzc2FnZS5ncmFwaHMubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmdyYXBocyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5ncmFwaHMucHVzaCgkcm9vdC5vbm54LkdyYXBoUHJvdG8uZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgMjM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKG1lc3NhZ2Uuc3BhcnNlVGVuc29ycyAmJiBtZXNzYWdlLnNwYXJzZVRlbnNvcnMubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnNwYXJzZVRlbnNvcnMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc3BhcnNlVGVuc29ycy5wdXNoKCRyb290Lm9ubnguU3BhcnNlVGVuc29yUHJvdG8uZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgMTU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKG1lc3NhZ2UudHlwZVByb3RvcyAmJiBtZXNzYWdlLnR5cGVQcm90b3MubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnR5cGVQcm90b3MgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudHlwZVByb3Rvcy5wdXNoKCRyb290Lm9ubnguVHlwZVByb3RvLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWNvZGVzIGFuIEF0dHJpYnV0ZVByb3RvIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIsIGxlbmd0aCBkZWxpbWl0ZWQuXG4gICAgICAgICAqIEBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWRcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguQXR0cmlidXRlUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgICAgICogQHJldHVybnMge29ubnguQXR0cmlidXRlUHJvdG99IEF0dHJpYnV0ZVByb3RvXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAgICAgKi9cbiAgICAgICAgQXR0cmlidXRlUHJvdG8uZGVjb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkKHJlYWRlcikge1xuICAgICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgICAgcmVhZGVyID0gbmV3ICRSZWFkZXIocmVhZGVyKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFZlcmlmaWVzIGFuIEF0dHJpYnV0ZVByb3RvIG1lc3NhZ2UuXG4gICAgICAgICAqIEBmdW5jdGlvbiB2ZXJpZnlcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguQXR0cmlidXRlUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBtZXNzYWdlIFBsYWluIG9iamVjdCB0byB2ZXJpZnlcbiAgICAgICAgICogQHJldHVybnMge3N0cmluZ3xudWxsfSBgbnVsbGAgaWYgdmFsaWQsIG90aGVyd2lzZSB0aGUgcmVhc29uIHdoeSBpdCBpcyBub3RcbiAgICAgICAgICovXG4gICAgICAgIEF0dHJpYnV0ZVByb3RvLnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtZXNzYWdlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgIT09IFwib2JqZWN0XCIgfHwgbWVzc2FnZSA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJvYmplY3QgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm5hbWUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwibmFtZVwiKSlcbiAgICAgICAgICAgICAgICBpZiAoISR1dGlsLmlzU3RyaW5nKG1lc3NhZ2UubmFtZSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIm5hbWU6IHN0cmluZyBleHBlY3RlZFwiO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UucmVmQXR0ck5hbWUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwicmVmQXR0ck5hbWVcIikpXG4gICAgICAgICAgICAgICAgaWYgKCEkdXRpbC5pc1N0cmluZyhtZXNzYWdlLnJlZkF0dHJOYW1lKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwicmVmQXR0ck5hbWU6IHN0cmluZyBleHBlY3RlZFwiO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZG9jU3RyaW5nICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImRvY1N0cmluZ1wiKSlcbiAgICAgICAgICAgICAgICBpZiAoISR1dGlsLmlzU3RyaW5nKG1lc3NhZ2UuZG9jU3RyaW5nKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiZG9jU3RyaW5nOiBzdHJpbmcgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnR5cGUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwidHlwZVwiKSlcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKG1lc3NhZ2UudHlwZSkge1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcInR5cGU6IGVudW0gdmFsdWUgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5mICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImZcIikpXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlLmYgIT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImY6IG51bWJlciBleHBlY3RlZFwiO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuaSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJpXCIpKVxuICAgICAgICAgICAgICAgIGlmICghJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UuaSkgJiYgIShtZXNzYWdlLmkgJiYgJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UuaS5sb3cpICYmICR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLmkuaGlnaCkpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJpOiBpbnRlZ2VyfExvbmcgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnMgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwic1wiKSlcbiAgICAgICAgICAgICAgICBpZiAoIShtZXNzYWdlLnMgJiYgdHlwZW9mIG1lc3NhZ2Uucy5sZW5ndGggPT09IFwibnVtYmVyXCIgfHwgJHV0aWwuaXNTdHJpbmcobWVzc2FnZS5zKSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcInM6IGJ1ZmZlciBleHBlY3RlZFwiO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UudCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJ0XCIpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVycm9yID0gJHJvb3Qub25ueC5UZW5zb3JQcm90by52ZXJpZnkobWVzc2FnZS50KTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcInQuXCIgKyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmcgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZ1wiKSkge1xuICAgICAgICAgICAgICAgIHZhciBlcnJvciA9ICRyb290Lm9ubnguR3JhcGhQcm90by52ZXJpZnkobWVzc2FnZS5nKTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImcuXCIgKyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnNwYXJzZVRlbnNvciAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJzcGFyc2VUZW5zb3JcIikpIHtcbiAgICAgICAgICAgICAgICB2YXIgZXJyb3IgPSAkcm9vdC5vbm54LlNwYXJzZVRlbnNvclByb3RvLnZlcmlmeShtZXNzYWdlLnNwYXJzZVRlbnNvcik7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJzcGFyc2VUZW5zb3IuXCIgKyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnRwICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInRwXCIpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVycm9yID0gJHJvb3Qub25ueC5UeXBlUHJvdG8udmVyaWZ5KG1lc3NhZ2UudHApO1xuICAgICAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwidHAuXCIgKyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmZsb2F0cyAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJmbG9hdHNcIikpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobWVzc2FnZS5mbG9hdHMpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJmbG9hdHM6IGFycmF5IGV4cGVjdGVkXCI7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLmZsb2F0cy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlLmZsb2F0c1tpXSAhPT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcImZsb2F0czogbnVtYmVyW10gZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmludHMgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiaW50c1wiKSkge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShtZXNzYWdlLmludHMpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJpbnRzOiBhcnJheSBleHBlY3RlZFwiO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5pbnRzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICBpZiAoISR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLmludHNbaV0pICYmICEobWVzc2FnZS5pbnRzW2ldICYmICR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLmludHNbaV0ubG93KSAmJiAkdXRpbC5pc0ludGVnZXIobWVzc2FnZS5pbnRzW2ldLmhpZ2gpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcImludHM6IGludGVnZXJ8TG9uZ1tdIGV4cGVjdGVkXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5zdHJpbmdzICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInN0cmluZ3NcIikpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobWVzc2FnZS5zdHJpbmdzKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwic3RyaW5nczogYXJyYXkgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2Uuc3RyaW5ncy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEobWVzc2FnZS5zdHJpbmdzW2ldICYmIHR5cGVvZiBtZXNzYWdlLnN0cmluZ3NbaV0ubGVuZ3RoID09PSBcIm51bWJlclwiIHx8ICR1dGlsLmlzU3RyaW5nKG1lc3NhZ2Uuc3RyaW5nc1tpXSkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwic3RyaW5nczogYnVmZmVyW10gZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnRlbnNvcnMgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwidGVuc29yc1wiKSkge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShtZXNzYWdlLnRlbnNvcnMpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJ0ZW5zb3JzOiBhcnJheSBleHBlY3RlZFwiO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS50ZW5zb3JzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlcnJvciA9ICRyb290Lm9ubnguVGVuc29yUHJvdG8udmVyaWZ5KG1lc3NhZ2UudGVuc29yc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcInRlbnNvcnMuXCIgKyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5ncmFwaHMgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZ3JhcGhzXCIpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG1lc3NhZ2UuZ3JhcGhzKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiZ3JhcGhzOiBhcnJheSBleHBlY3RlZFwiO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5ncmFwaHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVycm9yID0gJHJvb3Qub25ueC5HcmFwaFByb3RvLnZlcmlmeShtZXNzYWdlLmdyYXBoc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcImdyYXBocy5cIiArIGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnNwYXJzZVRlbnNvcnMgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwic3BhcnNlVGVuc29yc1wiKSkge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShtZXNzYWdlLnNwYXJzZVRlbnNvcnMpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJzcGFyc2VUZW5zb3JzOiBhcnJheSBleHBlY3RlZFwiO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5zcGFyc2VUZW5zb3JzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlcnJvciA9ICRyb290Lm9ubnguU3BhcnNlVGVuc29yUHJvdG8udmVyaWZ5KG1lc3NhZ2Uuc3BhcnNlVGVuc29yc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcInNwYXJzZVRlbnNvcnMuXCIgKyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS50eXBlUHJvdG9zICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInR5cGVQcm90b3NcIikpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobWVzc2FnZS50eXBlUHJvdG9zKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwidHlwZVByb3RvczogYXJyYXkgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UudHlwZVByb3Rvcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXJyb3IgPSAkcm9vdC5vbm54LlR5cGVQcm90by52ZXJpZnkobWVzc2FnZS50eXBlUHJvdG9zW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwidHlwZVByb3Rvcy5cIiArIGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGFuIEF0dHJpYnV0ZVByb3RvIG1lc3NhZ2UgZnJvbSBhIHBsYWluIG9iamVjdC4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gdGhlaXIgcmVzcGVjdGl2ZSBpbnRlcm5hbCB0eXBlcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGZyb21PYmplY3RcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguQXR0cmlidXRlUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBvYmplY3QgUGxhaW4gb2JqZWN0XG4gICAgICAgICAqIEByZXR1cm5zIHtvbm54LkF0dHJpYnV0ZVByb3RvfSBBdHRyaWJ1dGVQcm90b1xuICAgICAgICAgKi9cbiAgICAgICAgQXR0cmlidXRlUHJvdG8uZnJvbU9iamVjdCA9IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgJHJvb3Qub25ueC5BdHRyaWJ1dGVQcm90bylcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBuZXcgJHJvb3Qub25ueC5BdHRyaWJ1dGVQcm90bygpO1xuICAgICAgICAgICAgaWYgKG9iamVjdC5uYW1lICE9IG51bGwpXG4gICAgICAgICAgICAgICAgbWVzc2FnZS5uYW1lID0gU3RyaW5nKG9iamVjdC5uYW1lKTtcbiAgICAgICAgICAgIGlmIChvYmplY3QucmVmQXR0ck5hbWUgIT0gbnVsbClcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnJlZkF0dHJOYW1lID0gU3RyaW5nKG9iamVjdC5yZWZBdHRyTmFtZSk7XG4gICAgICAgICAgICBpZiAob2JqZWN0LmRvY1N0cmluZyAhPSBudWxsKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UuZG9jU3RyaW5nID0gU3RyaW5nKG9iamVjdC5kb2NTdHJpbmcpO1xuICAgICAgICAgICAgc3dpdGNoIChvYmplY3QudHlwZSkge1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC50eXBlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IG9iamVjdC50eXBlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiVU5ERUZJTkVEXCI6XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgbWVzc2FnZS50eXBlID0gMDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJGTE9BVFwiOlxuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiSU5UXCI6XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgbWVzc2FnZS50eXBlID0gMjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJTVFJJTkdcIjpcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSAzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIlRFTlNPUlwiOlxuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IDQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiR1JBUEhcIjpcbiAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSA1O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIlNQQVJTRV9URU5TT1JcIjpcbiAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgICAgbWVzc2FnZS50eXBlID0gMTE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiVFlQRV9QUk9UT1wiOlxuICAgICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSAxMztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJGTE9BVFNcIjpcbiAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSA2O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIklOVFNcIjpcbiAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSA3O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIlNUUklOR1NcIjpcbiAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSA4O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIlRFTlNPUlNcIjpcbiAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSA5O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIkdSQVBIU1wiOlxuICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSAxMDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJTUEFSU0VfVEVOU09SU1wiOlxuICAgICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSAxMjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJUWVBFX1BST1RPU1wiOlxuICAgICAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSAxNDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvYmplY3QuZiAhPSBudWxsKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UuZiA9IE51bWJlcihvYmplY3QuZik7XG4gICAgICAgICAgICBpZiAob2JqZWN0LmkgIT0gbnVsbClcbiAgICAgICAgICAgICAgICBpZiAoJHV0aWwuTG9uZylcbiAgICAgICAgICAgICAgICAgICAgKG1lc3NhZ2UuaSA9ICR1dGlsLkxvbmcuZnJvbVZhbHVlKG9iamVjdC5pKSkudW5zaWduZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LmkgPT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaSA9IHBhcnNlSW50KG9iamVjdC5pLCAxMCk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC5pID09PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmkgPSBvYmplY3QuaTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LmkgPT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaSA9IG5ldyAkdXRpbC5Mb25nQml0cyhvYmplY3QuaS5sb3cgPj4+IDAsIG9iamVjdC5pLmhpZ2ggPj4+IDApLnRvTnVtYmVyKCk7XG4gICAgICAgICAgICBpZiAob2JqZWN0LnMgIT0gbnVsbClcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5zID09PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICAgICAgICAkdXRpbC5iYXNlNjQuZGVjb2RlKG9iamVjdC5zLCBtZXNzYWdlLnMgPSAkdXRpbC5uZXdCdWZmZXIoJHV0aWwuYmFzZTY0Lmxlbmd0aChvYmplY3QucykpLCAwKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChvYmplY3Qucy5sZW5ndGggPj0gMClcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zID0gb2JqZWN0LnM7XG4gICAgICAgICAgICBpZiAob2JqZWN0LnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LnQgIT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5vbm54LkF0dHJpYnV0ZVByb3RvLnQ6IG9iamVjdCBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnQgPSAkcm9vdC5vbm54LlRlbnNvclByb3RvLmZyb21PYmplY3Qob2JqZWN0LnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9iamVjdC5nICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5nICE9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5BdHRyaWJ1dGVQcm90by5nOiBvYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5nID0gJHJvb3Qub25ueC5HcmFwaFByb3RvLmZyb21PYmplY3Qob2JqZWN0LmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9iamVjdC5zcGFyc2VUZW5zb3IgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LnNwYXJzZVRlbnNvciAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguQXR0cmlidXRlUHJvdG8uc3BhcnNlVGVuc29yOiBvYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5zcGFyc2VUZW5zb3IgPSAkcm9vdC5vbm54LlNwYXJzZVRlbnNvclByb3RvLmZyb21PYmplY3Qob2JqZWN0LnNwYXJzZVRlbnNvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2JqZWN0LnRwICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC50cCAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguQXR0cmlidXRlUHJvdG8udHA6IG9iamVjdCBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnRwID0gJHJvb3Qub25ueC5UeXBlUHJvdG8uZnJvbU9iamVjdChvYmplY3QudHApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9iamVjdC5mbG9hdHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqZWN0LmZsb2F0cykpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5vbm54LkF0dHJpYnV0ZVByb3RvLmZsb2F0czogYXJyYXkgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5mbG9hdHMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdC5mbG9hdHMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZmxvYXRzW2ldID0gTnVtYmVyKG9iamVjdC5mbG9hdHNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9iamVjdC5pbnRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9iamVjdC5pbnRzKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguQXR0cmlidXRlUHJvdG8uaW50czogYXJyYXkgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5pbnRzID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3QuaW50cy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKCR1dGlsLkxvbmcpXG4gICAgICAgICAgICAgICAgICAgICAgICAobWVzc2FnZS5pbnRzW2ldID0gJHV0aWwuTG9uZy5mcm9tVmFsdWUob2JqZWN0LmludHNbaV0pKS51bnNpZ25lZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LmludHNbaV0gPT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmludHNbaV0gPSBwYXJzZUludChvYmplY3QuaW50c1tpXSwgMTApO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LmludHNbaV0gPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmludHNbaV0gPSBvYmplY3QuaW50c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC5pbnRzW2ldID09PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pbnRzW2ldID0gbmV3ICR1dGlsLkxvbmdCaXRzKG9iamVjdC5pbnRzW2ldLmxvdyA+Pj4gMCwgb2JqZWN0LmludHNbaV0uaGlnaCA+Pj4gMCkudG9OdW1iZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvYmplY3Quc3RyaW5ncykge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvYmplY3Quc3RyaW5ncykpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5vbm54LkF0dHJpYnV0ZVByb3RvLnN0cmluZ3M6IGFycmF5IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc3RyaW5ncyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0LnN0cmluZ3MubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LnN0cmluZ3NbaV0gPT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAkdXRpbC5iYXNlNjQuZGVjb2RlKG9iamVjdC5zdHJpbmdzW2ldLCBtZXNzYWdlLnN0cmluZ3NbaV0gPSAkdXRpbC5uZXdCdWZmZXIoJHV0aWwuYmFzZTY0Lmxlbmd0aChvYmplY3Quc3RyaW5nc1tpXSkpLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAob2JqZWN0LnN0cmluZ3NbaV0ubGVuZ3RoID49IDApXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnN0cmluZ3NbaV0gPSBvYmplY3Quc3RyaW5nc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvYmplY3QudGVuc29ycykge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvYmplY3QudGVuc29ycykpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5vbm54LkF0dHJpYnV0ZVByb3RvLnRlbnNvcnM6IGFycmF5IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UudGVuc29ycyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0LnRlbnNvcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QudGVuc29yc1tpXSAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5vbm54LkF0dHJpYnV0ZVByb3RvLnRlbnNvcnM6IG9iamVjdCBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS50ZW5zb3JzW2ldID0gJHJvb3Qub25ueC5UZW5zb3JQcm90by5mcm9tT2JqZWN0KG9iamVjdC50ZW5zb3JzW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2JqZWN0LmdyYXBocykge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvYmplY3QuZ3JhcGhzKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguQXR0cmlidXRlUHJvdG8uZ3JhcGhzOiBhcnJheSBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmdyYXBocyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0LmdyYXBocy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5ncmFwaHNbaV0gIT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5BdHRyaWJ1dGVQcm90by5ncmFwaHM6IG9iamVjdCBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5ncmFwaHNbaV0gPSAkcm9vdC5vbm54LkdyYXBoUHJvdG8uZnJvbU9iamVjdChvYmplY3QuZ3JhcGhzW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2JqZWN0LnNwYXJzZVRlbnNvcnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqZWN0LnNwYXJzZVRlbnNvcnMpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5BdHRyaWJ1dGVQcm90by5zcGFyc2VUZW5zb3JzOiBhcnJheSBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnNwYXJzZVRlbnNvcnMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdC5zcGFyc2VUZW5zb3JzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LnNwYXJzZVRlbnNvcnNbaV0gIT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5BdHRyaWJ1dGVQcm90by5zcGFyc2VUZW5zb3JzOiBvYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc3BhcnNlVGVuc29yc1tpXSA9ICRyb290Lm9ubnguU3BhcnNlVGVuc29yUHJvdG8uZnJvbU9iamVjdChvYmplY3Quc3BhcnNlVGVuc29yc1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9iamVjdC50eXBlUHJvdG9zKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9iamVjdC50eXBlUHJvdG9zKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguQXR0cmlidXRlUHJvdG8udHlwZVByb3RvczogYXJyYXkgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS50eXBlUHJvdG9zID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3QudHlwZVByb3Rvcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC50eXBlUHJvdG9zW2ldICE9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguQXR0cmlidXRlUHJvdG8udHlwZVByb3Rvczogb2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnR5cGVQcm90b3NbaV0gPSAkcm9vdC5vbm54LlR5cGVQcm90by5mcm9tT2JqZWN0KG9iamVjdC50eXBlUHJvdG9zW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIHBsYWluIG9iamVjdCBmcm9tIGFuIEF0dHJpYnV0ZVByb3RvIG1lc3NhZ2UuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIG90aGVyIHR5cGVzIGlmIHNwZWNpZmllZC5cbiAgICAgICAgICogQGZ1bmN0aW9uIHRvT2JqZWN0XG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LkF0dHJpYnV0ZVByb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtvbm54LkF0dHJpYnV0ZVByb3RvfSBtZXNzYWdlIEF0dHJpYnV0ZVByb3RvXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLklDb252ZXJzaW9uT3B0aW9uc30gW29wdGlvbnNdIENvbnZlcnNpb24gb3B0aW9uc1xuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IFBsYWluIG9iamVjdFxuICAgICAgICAgKi9cbiAgICAgICAgQXR0cmlidXRlUHJvdG8udG9PYmplY3QgPSBmdW5jdGlvbiB0b09iamVjdChtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMpXG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgICAgdmFyIG9iamVjdCA9IHt9O1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuYXJyYXlzIHx8IG9wdGlvbnMuZGVmYXVsdHMpIHtcbiAgICAgICAgICAgICAgICBvYmplY3QuZmxvYXRzID0gW107XG4gICAgICAgICAgICAgICAgb2JqZWN0LmludHMgPSBbXTtcbiAgICAgICAgICAgICAgICBvYmplY3Quc3RyaW5ncyA9IFtdO1xuICAgICAgICAgICAgICAgIG9iamVjdC50ZW5zb3JzID0gW107XG4gICAgICAgICAgICAgICAgb2JqZWN0LmdyYXBocyA9IFtdO1xuICAgICAgICAgICAgICAgIG9iamVjdC50eXBlUHJvdG9zID0gW107XG4gICAgICAgICAgICAgICAgb2JqZWN0LnNwYXJzZVRlbnNvcnMgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmRlZmF1bHRzKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0Lm5hbWUgPSBcIlwiO1xuICAgICAgICAgICAgICAgIG9iamVjdC5mID0gMDtcbiAgICAgICAgICAgICAgICBpZiAoJHV0aWwuTG9uZykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbG9uZyA9IG5ldyAkdXRpbC5Mb25nKDAsIDAsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LmkgPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyBsb25nLnRvU3RyaW5nKCkgOiBvcHRpb25zLmxvbmdzID09PSBOdW1iZXIgPyBsb25nLnRvTnVtYmVyKCkgOiBsb25nO1xuICAgICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgICAgICBvYmplY3QuaSA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/IFwiMFwiIDogMDtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5ieXRlcyA9PT0gU3RyaW5nKVxuICAgICAgICAgICAgICAgICAgICBvYmplY3QucyA9IFwiXCI7XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5zID0gW107XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmJ5dGVzICE9PSBBcnJheSlcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdC5zID0gJHV0aWwubmV3QnVmZmVyKG9iamVjdC5zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb2JqZWN0LnQgPSBudWxsO1xuICAgICAgICAgICAgICAgIG9iamVjdC5nID0gbnVsbDtcbiAgICAgICAgICAgICAgICBvYmplY3QuZG9jU3RyaW5nID0gXCJcIjtcbiAgICAgICAgICAgICAgICBvYmplY3QudHAgPSBudWxsO1xuICAgICAgICAgICAgICAgIG9iamVjdC50eXBlID0gb3B0aW9ucy5lbnVtcyA9PT0gU3RyaW5nID8gXCJVTkRFRklORURcIiA6IDA7XG4gICAgICAgICAgICAgICAgb2JqZWN0LnJlZkF0dHJOYW1lID0gXCJcIjtcbiAgICAgICAgICAgICAgICBvYmplY3Quc3BhcnNlVGVuc29yID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm5hbWUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwibmFtZVwiKSlcbiAgICAgICAgICAgICAgICBvYmplY3QubmFtZSA9IG1lc3NhZ2UubmFtZTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmYgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZlwiKSlcbiAgICAgICAgICAgICAgICBvYmplY3QuZiA9IG9wdGlvbnMuanNvbiAmJiAhaXNGaW5pdGUobWVzc2FnZS5mKSA/IFN0cmluZyhtZXNzYWdlLmYpIDogbWVzc2FnZS5mO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuaSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJpXCIpKVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZS5pID09PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICAgICAgICBvYmplY3QuaSA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/IFN0cmluZyhtZXNzYWdlLmkpIDogbWVzc2FnZS5pO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LmkgPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyAkdXRpbC5Mb25nLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG1lc3NhZ2UuaSkgOiBvcHRpb25zLmxvbmdzID09PSBOdW1iZXIgPyBuZXcgJHV0aWwuTG9uZ0JpdHMobWVzc2FnZS5pLmxvdyA+Pj4gMCwgbWVzc2FnZS5pLmhpZ2ggPj4+IDApLnRvTnVtYmVyKCkgOiBtZXNzYWdlLmk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5zICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInNcIikpXG4gICAgICAgICAgICAgICAgb2JqZWN0LnMgPSBvcHRpb25zLmJ5dGVzID09PSBTdHJpbmcgPyAkdXRpbC5iYXNlNjQuZW5jb2RlKG1lc3NhZ2UucywgMCwgbWVzc2FnZS5zLmxlbmd0aCkgOiBvcHRpb25zLmJ5dGVzID09PSBBcnJheSA/IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKG1lc3NhZ2UucykgOiBtZXNzYWdlLnM7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS50ICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInRcIikpXG4gICAgICAgICAgICAgICAgb2JqZWN0LnQgPSAkcm9vdC5vbm54LlRlbnNvclByb3RvLnRvT2JqZWN0KG1lc3NhZ2UudCwgb3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5nICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImdcIikpXG4gICAgICAgICAgICAgICAgb2JqZWN0LmcgPSAkcm9vdC5vbm54LkdyYXBoUHJvdG8udG9PYmplY3QobWVzc2FnZS5nLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmZsb2F0cyAmJiBtZXNzYWdlLmZsb2F0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBvYmplY3QuZmxvYXRzID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtZXNzYWdlLmZsb2F0cy5sZW5ndGg7ICsrailcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LmZsb2F0c1tqXSA9IG9wdGlvbnMuanNvbiAmJiAhaXNGaW5pdGUobWVzc2FnZS5mbG9hdHNbal0pID8gU3RyaW5nKG1lc3NhZ2UuZmxvYXRzW2pdKSA6IG1lc3NhZ2UuZmxvYXRzW2pdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuaW50cyAmJiBtZXNzYWdlLmludHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0LmludHMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1lc3NhZ2UuaW50cy5sZW5ndGg7ICsrailcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlLmludHNbal0gPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBvYmplY3QuaW50c1tqXSA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/IFN0cmluZyhtZXNzYWdlLmludHNbal0pIDogbWVzc2FnZS5pbnRzW2pdO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBvYmplY3QuaW50c1tqXSA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/ICR1dGlsLkxvbmcucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobWVzc2FnZS5pbnRzW2pdKSA6IG9wdGlvbnMubG9uZ3MgPT09IE51bWJlciA/IG5ldyAkdXRpbC5Mb25nQml0cyhtZXNzYWdlLmludHNbal0ubG93ID4+PiAwLCBtZXNzYWdlLmludHNbal0uaGlnaCA+Pj4gMCkudG9OdW1iZXIoKSA6IG1lc3NhZ2UuaW50c1tqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnN0cmluZ3MgJiYgbWVzc2FnZS5zdHJpbmdzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIG9iamVjdC5zdHJpbmdzID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtZXNzYWdlLnN0cmluZ3MubGVuZ3RoOyArK2opXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5zdHJpbmdzW2pdID0gb3B0aW9ucy5ieXRlcyA9PT0gU3RyaW5nID8gJHV0aWwuYmFzZTY0LmVuY29kZShtZXNzYWdlLnN0cmluZ3Nbal0sIDAsIG1lc3NhZ2Uuc3RyaW5nc1tqXS5sZW5ndGgpIDogb3B0aW9ucy5ieXRlcyA9PT0gQXJyYXkgPyBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChtZXNzYWdlLnN0cmluZ3Nbal0pIDogbWVzc2FnZS5zdHJpbmdzW2pdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UudGVuc29ycyAmJiBtZXNzYWdlLnRlbnNvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0LnRlbnNvcnMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1lc3NhZ2UudGVuc29ycy5sZW5ndGg7ICsrailcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LnRlbnNvcnNbal0gPSAkcm9vdC5vbm54LlRlbnNvclByb3RvLnRvT2JqZWN0KG1lc3NhZ2UudGVuc29yc1tqXSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5ncmFwaHMgJiYgbWVzc2FnZS5ncmFwaHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0LmdyYXBocyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWVzc2FnZS5ncmFwaHMubGVuZ3RoOyArK2opXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5ncmFwaHNbal0gPSAkcm9vdC5vbm54LkdyYXBoUHJvdG8udG9PYmplY3QobWVzc2FnZS5ncmFwaHNbal0sIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZG9jU3RyaW5nICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImRvY1N0cmluZ1wiKSlcbiAgICAgICAgICAgICAgICBvYmplY3QuZG9jU3RyaW5nID0gbWVzc2FnZS5kb2NTdHJpbmc7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS50cCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJ0cFwiKSlcbiAgICAgICAgICAgICAgICBvYmplY3QudHAgPSAkcm9vdC5vbm54LlR5cGVQcm90by50b09iamVjdChtZXNzYWdlLnRwLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnR5cGVQcm90b3MgJiYgbWVzc2FnZS50eXBlUHJvdG9zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIG9iamVjdC50eXBlUHJvdG9zID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtZXNzYWdlLnR5cGVQcm90b3MubGVuZ3RoOyArK2opXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC50eXBlUHJvdG9zW2pdID0gJHJvb3Qub25ueC5UeXBlUHJvdG8udG9PYmplY3QobWVzc2FnZS50eXBlUHJvdG9zW2pdLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnR5cGUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwidHlwZVwiKSlcbiAgICAgICAgICAgICAgICBvYmplY3QudHlwZSA9IG9wdGlvbnMuZW51bXMgPT09IFN0cmluZyA/ICRyb290Lm9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZVttZXNzYWdlLnR5cGVdID09PSB1bmRlZmluZWQgPyBtZXNzYWdlLnR5cGUgOiAkcm9vdC5vbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGVbbWVzc2FnZS50eXBlXSA6IG1lc3NhZ2UudHlwZTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnJlZkF0dHJOYW1lICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInJlZkF0dHJOYW1lXCIpKVxuICAgICAgICAgICAgICAgIG9iamVjdC5yZWZBdHRyTmFtZSA9IG1lc3NhZ2UucmVmQXR0ck5hbWU7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5zcGFyc2VUZW5zb3IgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwic3BhcnNlVGVuc29yXCIpKVxuICAgICAgICAgICAgICAgIG9iamVjdC5zcGFyc2VUZW5zb3IgPSAkcm9vdC5vbm54LlNwYXJzZVRlbnNvclByb3RvLnRvT2JqZWN0KG1lc3NhZ2Uuc3BhcnNlVGVuc29yLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnNwYXJzZVRlbnNvcnMgJiYgbWVzc2FnZS5zcGFyc2VUZW5zb3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIG9iamVjdC5zcGFyc2VUZW5zb3JzID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtZXNzYWdlLnNwYXJzZVRlbnNvcnMubGVuZ3RoOyArK2opXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5zcGFyc2VUZW5zb3JzW2pdID0gJHJvb3Qub25ueC5TcGFyc2VUZW5zb3JQcm90by50b09iamVjdChtZXNzYWdlLnNwYXJzZVRlbnNvcnNbal0sIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29udmVydHMgdGhpcyBBdHRyaWJ1dGVQcm90byB0byBKU09OLlxuICAgICAgICAgKiBAZnVuY3Rpb24gdG9KU09OXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LkF0dHJpYnV0ZVByb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IEpTT04gb2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICBBdHRyaWJ1dGVQcm90by5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcywgJHByb3RvYnVmLnV0aWwudG9KU09OT3B0aW9ucyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHMgdGhlIGRlZmF1bHQgdHlwZSB1cmwgZm9yIEF0dHJpYnV0ZVByb3RvXG4gICAgICAgICAqIEBmdW5jdGlvbiBnZXRUeXBlVXJsXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LkF0dHJpYnV0ZVByb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFt0eXBlVXJsUHJlZml4XSB5b3VyIGN1c3RvbSB0eXBlVXJsUHJlZml4KGRlZmF1bHQgXCJ0eXBlLmdvb2dsZWFwaXMuY29tXCIpXG4gICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBkZWZhdWx0IHR5cGUgdXJsXG4gICAgICAgICAqL1xuICAgICAgICBBdHRyaWJ1dGVQcm90by5nZXRUeXBlVXJsID0gZnVuY3Rpb24gZ2V0VHlwZVVybCh0eXBlVXJsUHJlZml4KSB7XG4gICAgICAgICAgICBpZiAodHlwZVVybFByZWZpeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdHlwZVVybFByZWZpeCA9IFwidHlwZS5nb29nbGVhcGlzLmNvbVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHR5cGVVcmxQcmVmaXggKyBcIi9vbm54LkF0dHJpYnV0ZVByb3RvXCI7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEF0dHJpYnV0ZVR5cGUgZW51bS5cbiAgICAgICAgICogQG5hbWUgb25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlXG4gICAgICAgICAqIEBlbnVtIHtudW1iZXJ9XG4gICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBVTkRFRklORUQ9MCBVTkRFRklORUQgdmFsdWVcbiAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IEZMT0FUPTEgRkxPQVQgdmFsdWVcbiAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IElOVD0yIElOVCB2YWx1ZVxuICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcn0gU1RSSU5HPTMgU1RSSU5HIHZhbHVlXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBURU5TT1I9NCBURU5TT1IgdmFsdWVcbiAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IEdSQVBIPTUgR1JBUEggdmFsdWVcbiAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IFNQQVJTRV9URU5TT1I9MTEgU1BBUlNFX1RFTlNPUiB2YWx1ZVxuICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcn0gVFlQRV9QUk9UTz0xMyBUWVBFX1BST1RPIHZhbHVlXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBGTE9BVFM9NiBGTE9BVFMgdmFsdWVcbiAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IElOVFM9NyBJTlRTIHZhbHVlXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBTVFJJTkdTPTggU1RSSU5HUyB2YWx1ZVxuICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcn0gVEVOU09SUz05IFRFTlNPUlMgdmFsdWVcbiAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IEdSQVBIUz0xMCBHUkFQSFMgdmFsdWVcbiAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IFNQQVJTRV9URU5TT1JTPTEyIFNQQVJTRV9URU5TT1JTIHZhbHVlXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBUWVBFX1BST1RPUz0xNCBUWVBFX1BST1RPUyB2YWx1ZVxuICAgICAgICAgKi9cbiAgICAgICAgQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZSA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZXNCeUlkID0ge30sIHZhbHVlcyA9IE9iamVjdC5jcmVhdGUodmFsdWVzQnlJZCk7XG4gICAgICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFswXSA9IFwiVU5ERUZJTkVEXCJdID0gMDtcbiAgICAgICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzFdID0gXCJGTE9BVFwiXSA9IDE7XG4gICAgICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFsyXSA9IFwiSU5UXCJdID0gMjtcbiAgICAgICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzNdID0gXCJTVFJJTkdcIl0gPSAzO1xuICAgICAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbNF0gPSBcIlRFTlNPUlwiXSA9IDQ7XG4gICAgICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFs1XSA9IFwiR1JBUEhcIl0gPSA1O1xuICAgICAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbMTFdID0gXCJTUEFSU0VfVEVOU09SXCJdID0gMTE7XG4gICAgICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFsxM10gPSBcIlRZUEVfUFJPVE9cIl0gPSAxMztcbiAgICAgICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzZdID0gXCJGTE9BVFNcIl0gPSA2O1xuICAgICAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbN10gPSBcIklOVFNcIl0gPSA3O1xuICAgICAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbOF0gPSBcIlNUUklOR1NcIl0gPSA4O1xuICAgICAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbOV0gPSBcIlRFTlNPUlNcIl0gPSA5O1xuICAgICAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbMTBdID0gXCJHUkFQSFNcIl0gPSAxMDtcbiAgICAgICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzEyXSA9IFwiU1BBUlNFX1RFTlNPUlNcIl0gPSAxMjtcbiAgICAgICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzE0XSA9IFwiVFlQRV9QUk9UT1NcIl0gPSAxNDtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgICAgIH0pKCk7XG5cbiAgICAgICAgcmV0dXJuIEF0dHJpYnV0ZVByb3RvO1xuICAgIH0pKCk7XG5cbiAgICBvbm54LlZhbHVlSW5mb1Byb3RvID0gKGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm9wZXJ0aWVzIG9mIGEgVmFsdWVJbmZvUHJvdG8uXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54XG4gICAgICAgICAqIEBpbnRlcmZhY2UgSVZhbHVlSW5mb1Byb3RvXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfG51bGx9IFtuYW1lXSBWYWx1ZUluZm9Qcm90byBuYW1lXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7b25ueC5JVHlwZVByb3RvfG51bGx9IFt0eXBlXSBWYWx1ZUluZm9Qcm90byB0eXBlXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfG51bGx9IFtkb2NTdHJpbmddIFZhbHVlSW5mb1Byb3RvIGRvY1N0cmluZ1xuICAgICAgICAgKi9cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29uc3RydWN0cyBhIG5ldyBWYWx1ZUluZm9Qcm90by5cbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnhcbiAgICAgICAgICogQGNsYXNzZGVzYyBSZXByZXNlbnRzIGEgVmFsdWVJbmZvUHJvdG8uXG4gICAgICAgICAqIEBpbXBsZW1lbnRzIElWYWx1ZUluZm9Qcm90b1xuICAgICAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgICAgICogQHBhcmFtIHtvbm54LklWYWx1ZUluZm9Qcm90bz19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gVmFsdWVJbmZvUHJvdG8ocHJvcGVydGllcykge1xuICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMpXG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzW2tleXNbaV1dICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2tleXNbaV1dID0gcHJvcGVydGllc1trZXlzW2ldXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBWYWx1ZUluZm9Qcm90byBuYW1lLlxuICAgICAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IG5hbWVcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVmFsdWVJbmZvUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBWYWx1ZUluZm9Qcm90by5wcm90b3R5cGUubmFtZSA9IFwiXCI7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFZhbHVlSW5mb1Byb3RvIHR5cGUuXG4gICAgICAgICAqIEBtZW1iZXIge29ubnguSVR5cGVQcm90b3xudWxsfHVuZGVmaW5lZH0gdHlwZVxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5WYWx1ZUluZm9Qcm90b1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIFZhbHVlSW5mb1Byb3RvLnByb3RvdHlwZS50eXBlID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVmFsdWVJbmZvUHJvdG8gZG9jU3RyaW5nLlxuICAgICAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IGRvY1N0cmluZ1xuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5WYWx1ZUluZm9Qcm90b1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIFZhbHVlSW5mb1Byb3RvLnByb3RvdHlwZS5kb2NTdHJpbmcgPSBcIlwiO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgbmV3IFZhbHVlSW5mb1Byb3RvIGluc3RhbmNlIHVzaW5nIHRoZSBzcGVjaWZpZWQgcHJvcGVydGllcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGNyZWF0ZVxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5WYWx1ZUluZm9Qcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7b25ueC5JVmFsdWVJbmZvUHJvdG89fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAgICAgICAgICogQHJldHVybnMge29ubnguVmFsdWVJbmZvUHJvdG99IFZhbHVlSW5mb1Byb3RvIGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBWYWx1ZUluZm9Qcm90by5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUocHJvcGVydGllcykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBWYWx1ZUluZm9Qcm90byhwcm9wZXJ0aWVzKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRW5jb2RlcyB0aGUgc3BlY2lmaWVkIFZhbHVlSW5mb1Byb3RvIG1lc3NhZ2UuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIG9ubnguVmFsdWVJbmZvUHJvdG8udmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBlbmNvZGVcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVmFsdWVJbmZvUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge29ubnguSVZhbHVlSW5mb1Byb3RvfSBtZXNzYWdlIFZhbHVlSW5mb1Byb3RvIG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0IHRvIGVuY29kZVxuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAgICAgICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAgICAgKi9cbiAgICAgICAgVmFsdWVJbmZvUHJvdG8uZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgICAgaWYgKCF3cml0ZXIpXG4gICAgICAgICAgICAgICAgd3JpdGVyID0gJFdyaXRlci5jcmVhdGUoKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm5hbWUgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcIm5hbWVcIikpXG4gICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCAxLCB3aXJlVHlwZSAyID0qLzEwKS5zdHJpbmcobWVzc2FnZS5uYW1lKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnR5cGUgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcInR5cGVcIikpXG4gICAgICAgICAgICAgICAgJHJvb3Qub25ueC5UeXBlUHJvdG8uZW5jb2RlKG1lc3NhZ2UudHlwZSwgd3JpdGVyLnVpbnQzMigvKiBpZCAyLCB3aXJlVHlwZSAyID0qLzE4KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZG9jU3RyaW5nICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJkb2NTdHJpbmdcIikpXG4gICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCAzLCB3aXJlVHlwZSAyID0qLzI2KS5zdHJpbmcobWVzc2FnZS5kb2NTdHJpbmcpO1xuICAgICAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRW5jb2RlcyB0aGUgc3BlY2lmaWVkIFZhbHVlSW5mb1Byb3RvIG1lc3NhZ2UsIGxlbmd0aCBkZWxpbWl0ZWQuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIG9ubnguVmFsdWVJbmZvUHJvdG8udmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWRcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVmFsdWVJbmZvUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge29ubnguSVZhbHVlSW5mb1Byb3RvfSBtZXNzYWdlIFZhbHVlSW5mb1Byb3RvIG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0IHRvIGVuY29kZVxuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAgICAgICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAgICAgKi9cbiAgICAgICAgVmFsdWVJbmZvUHJvdG8uZW5jb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikubGRlbGltKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlY29kZXMgYSBWYWx1ZUluZm9Qcm90byBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZGVjb2RlXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlZhbHVlSW5mb1Byb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoXSBNZXNzYWdlIGxlbmd0aCBpZiBrbm93biBiZWZvcmVoYW5kXG4gICAgICAgICAqIEByZXR1cm5zIHtvbm54LlZhbHVlSW5mb1Byb3RvfSBWYWx1ZUluZm9Qcm90b1xuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcbiAgICAgICAgICovXG4gICAgICAgIFZhbHVlSW5mb1Byb3RvLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyZWFkZXIsIGxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgICAgcmVhZGVyID0gJFJlYWRlci5jcmVhdGUocmVhZGVyKTtcbiAgICAgICAgICAgIHZhciBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoLCBtZXNzYWdlID0gbmV3ICRyb290Lm9ubnguVmFsdWVJbmZvUHJvdG8oKTtcbiAgICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMToge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5uYW1lID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIDI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudHlwZSA9ICRyb290Lm9ubnguVHlwZVByb3RvLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgMzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5kb2NTdHJpbmcgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlY29kZXMgYSBWYWx1ZUluZm9Qcm90byBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLCBsZW5ndGggZGVsaW1pdGVkLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlZhbHVlSW5mb1Byb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gICAgICAgICAqIEByZXR1cm5zIHtvbm54LlZhbHVlSW5mb1Byb3RvfSBWYWx1ZUluZm9Qcm90b1xuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcbiAgICAgICAgICovXG4gICAgICAgIFZhbHVlSW5mb1Byb3RvLmRlY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZChyZWFkZXIpIHtcbiAgICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgICAgIHJlYWRlciA9IG5ldyAkUmVhZGVyKHJlYWRlcik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBWZXJpZmllcyBhIFZhbHVlSW5mb1Byb3RvIG1lc3NhZ2UuXG4gICAgICAgICAqIEBmdW5jdGlvbiB2ZXJpZnlcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVmFsdWVJbmZvUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBtZXNzYWdlIFBsYWluIG9iamVjdCB0byB2ZXJpZnlcbiAgICAgICAgICogQHJldHVybnMge3N0cmluZ3xudWxsfSBgbnVsbGAgaWYgdmFsaWQsIG90aGVyd2lzZSB0aGUgcmVhc29uIHdoeSBpdCBpcyBub3RcbiAgICAgICAgICovXG4gICAgICAgIFZhbHVlSW5mb1Byb3RvLnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtZXNzYWdlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgIT09IFwib2JqZWN0XCIgfHwgbWVzc2FnZSA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJvYmplY3QgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm5hbWUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwibmFtZVwiKSlcbiAgICAgICAgICAgICAgICBpZiAoISR1dGlsLmlzU3RyaW5nKG1lc3NhZ2UubmFtZSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIm5hbWU6IHN0cmluZyBleHBlY3RlZFwiO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UudHlwZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJ0eXBlXCIpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVycm9yID0gJHJvb3Qub25ueC5UeXBlUHJvdG8udmVyaWZ5KG1lc3NhZ2UudHlwZSk7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJ0eXBlLlwiICsgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5kb2NTdHJpbmcgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZG9jU3RyaW5nXCIpKVxuICAgICAgICAgICAgICAgIGlmICghJHV0aWwuaXNTdHJpbmcobWVzc2FnZS5kb2NTdHJpbmcpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJkb2NTdHJpbmc6IHN0cmluZyBleHBlY3RlZFwiO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBWYWx1ZUluZm9Qcm90byBtZXNzYWdlIGZyb20gYSBwbGFpbiBvYmplY3QuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIHRoZWlyIHJlc3BlY3RpdmUgaW50ZXJuYWwgdHlwZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBmcm9tT2JqZWN0XG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlZhbHVlSW5mb1Byb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gb2JqZWN0IFBsYWluIG9iamVjdFxuICAgICAgICAgKiBAcmV0dXJucyB7b25ueC5WYWx1ZUluZm9Qcm90b30gVmFsdWVJbmZvUHJvdG9cbiAgICAgICAgICovXG4gICAgICAgIFZhbHVlSW5mb1Byb3RvLmZyb21PYmplY3QgPSBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mICRyb290Lm9ubnguVmFsdWVJbmZvUHJvdG8pXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgICAgIHZhciBtZXNzYWdlID0gbmV3ICRyb290Lm9ubnguVmFsdWVJbmZvUHJvdG8oKTtcbiAgICAgICAgICAgIGlmIChvYmplY3QubmFtZSAhPSBudWxsKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UubmFtZSA9IFN0cmluZyhvYmplY3QubmFtZSk7XG4gICAgICAgICAgICBpZiAob2JqZWN0LnR5cGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LnR5cGUgIT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5vbm54LlZhbHVlSW5mb1Byb3RvLnR5cGU6IG9iamVjdCBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSAkcm9vdC5vbm54LlR5cGVQcm90by5mcm9tT2JqZWN0KG9iamVjdC50eXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvYmplY3QuZG9jU3RyaW5nICE9IG51bGwpXG4gICAgICAgICAgICAgICAgbWVzc2FnZS5kb2NTdHJpbmcgPSBTdHJpbmcob2JqZWN0LmRvY1N0cmluZyk7XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIHBsYWluIG9iamVjdCBmcm9tIGEgVmFsdWVJbmZvUHJvdG8gbWVzc2FnZS4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gb3RoZXIgdHlwZXMgaWYgc3BlY2lmaWVkLlxuICAgICAgICAgKiBAZnVuY3Rpb24gdG9PYmplY3RcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVmFsdWVJbmZvUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge29ubnguVmFsdWVJbmZvUHJvdG99IG1lc3NhZ2UgVmFsdWVJbmZvUHJvdG9cbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuSUNvbnZlcnNpb25PcHRpb25zfSBbb3B0aW9uc10gQ29udmVyc2lvbiBvcHRpb25zXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gUGxhaW4gb2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICBWYWx1ZUluZm9Qcm90by50b09iamVjdCA9IGZ1bmN0aW9uIHRvT2JqZWN0KG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucylcbiAgICAgICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgICAgICB2YXIgb2JqZWN0ID0ge307XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5kZWZhdWx0cykge1xuICAgICAgICAgICAgICAgIG9iamVjdC5uYW1lID0gXCJcIjtcbiAgICAgICAgICAgICAgICBvYmplY3QudHlwZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgb2JqZWN0LmRvY1N0cmluZyA9IFwiXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5uYW1lICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIm5hbWVcIikpXG4gICAgICAgICAgICAgICAgb2JqZWN0Lm5hbWUgPSBtZXNzYWdlLm5hbWU7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS50eXBlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInR5cGVcIikpXG4gICAgICAgICAgICAgICAgb2JqZWN0LnR5cGUgPSAkcm9vdC5vbm54LlR5cGVQcm90by50b09iamVjdChtZXNzYWdlLnR5cGUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZG9jU3RyaW5nICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImRvY1N0cmluZ1wiKSlcbiAgICAgICAgICAgICAgICBvYmplY3QuZG9jU3RyaW5nID0gbWVzc2FnZS5kb2NTdHJpbmc7XG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb252ZXJ0cyB0aGlzIFZhbHVlSW5mb1Byb3RvIHRvIEpTT04uXG4gICAgICAgICAqIEBmdW5jdGlvbiB0b0pTT05cbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVmFsdWVJbmZvUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gSlNPTiBvYmplY3RcbiAgICAgICAgICovXG4gICAgICAgIFZhbHVlSW5mb1Byb3RvLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLCAkcHJvdG9idWYudXRpbC50b0pTT05PcHRpb25zKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0cyB0aGUgZGVmYXVsdCB0eXBlIHVybCBmb3IgVmFsdWVJbmZvUHJvdG9cbiAgICAgICAgICogQGZ1bmN0aW9uIGdldFR5cGVVcmxcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVmFsdWVJbmZvUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3R5cGVVcmxQcmVmaXhdIHlvdXIgY3VzdG9tIHR5cGVVcmxQcmVmaXgoZGVmYXVsdCBcInR5cGUuZ29vZ2xlYXBpcy5jb21cIilcbiAgICAgICAgICogQHJldHVybnMge3N0cmluZ30gVGhlIGRlZmF1bHQgdHlwZSB1cmxcbiAgICAgICAgICovXG4gICAgICAgIFZhbHVlSW5mb1Byb3RvLmdldFR5cGVVcmwgPSBmdW5jdGlvbiBnZXRUeXBlVXJsKHR5cGVVcmxQcmVmaXgpIHtcbiAgICAgICAgICAgIGlmICh0eXBlVXJsUHJlZml4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0eXBlVXJsUHJlZml4ID0gXCJ0eXBlLmdvb2dsZWFwaXMuY29tXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHlwZVVybFByZWZpeCArIFwiL29ubnguVmFsdWVJbmZvUHJvdG9cIjtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gVmFsdWVJbmZvUHJvdG87XG4gICAgfSkoKTtcblxuICAgIG9ubnguTm9kZVByb3RvID0gKGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm9wZXJ0aWVzIG9mIGEgTm9kZVByb3RvLlxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueFxuICAgICAgICAgKiBAaW50ZXJmYWNlIElOb2RlUHJvdG9cbiAgICAgICAgICogQHByb3BlcnR5IHtBcnJheS48c3RyaW5nPnxudWxsfSBbaW5wdXRdIE5vZGVQcm90byBpbnB1dFxuICAgICAgICAgKiBAcHJvcGVydHkge0FycmF5LjxzdHJpbmc+fG51bGx9IFtvdXRwdXRdIE5vZGVQcm90byBvdXRwdXRcbiAgICAgICAgICogQHByb3BlcnR5IHtzdHJpbmd8bnVsbH0gW25hbWVdIE5vZGVQcm90byBuYW1lXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfG51bGx9IFtvcFR5cGVdIE5vZGVQcm90byBvcFR5cGVcbiAgICAgICAgICogQHByb3BlcnR5IHtzdHJpbmd8bnVsbH0gW2RvbWFpbl0gTm9kZVByb3RvIGRvbWFpblxuICAgICAgICAgKiBAcHJvcGVydHkge0FycmF5Ljxvbm54LklBdHRyaWJ1dGVQcm90bz58bnVsbH0gW2F0dHJpYnV0ZV0gTm9kZVByb3RvIGF0dHJpYnV0ZVxuICAgICAgICAgKiBAcHJvcGVydHkge3N0cmluZ3xudWxsfSBbZG9jU3RyaW5nXSBOb2RlUHJvdG8gZG9jU3RyaW5nXG4gICAgICAgICAqL1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IE5vZGVQcm90by5cbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnhcbiAgICAgICAgICogQGNsYXNzZGVzYyBSZXByZXNlbnRzIGEgTm9kZVByb3RvLlxuICAgICAgICAgKiBAaW1wbGVtZW50cyBJTm9kZVByb3RvXG4gICAgICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAgICAgKiBAcGFyYW0ge29ubnguSU5vZGVQcm90bz19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gTm9kZVByb3RvKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHRoaXMuaW5wdXQgPSBbXTtcbiAgICAgICAgICAgIHRoaXMub3V0cHV0ID0gW107XG4gICAgICAgICAgICB0aGlzLmF0dHJpYnV0ZSA9IFtdO1xuICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMpXG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzW2tleXNbaV1dICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2tleXNbaV1dID0gcHJvcGVydGllc1trZXlzW2ldXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOb2RlUHJvdG8gaW5wdXQuXG4gICAgICAgICAqIEBtZW1iZXIge0FycmF5LjxzdHJpbmc+fSBpbnB1dFxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5Ob2RlUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBOb2RlUHJvdG8ucHJvdG90eXBlLmlucHV0ID0gJHV0aWwuZW1wdHlBcnJheTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogTm9kZVByb3RvIG91dHB1dC5cbiAgICAgICAgICogQG1lbWJlciB7QXJyYXkuPHN0cmluZz59IG91dHB1dFxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5Ob2RlUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBOb2RlUHJvdG8ucHJvdG90eXBlLm91dHB1dCA9ICR1dGlsLmVtcHR5QXJyYXk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5vZGVQcm90byBuYW1lLlxuICAgICAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IG5hbWVcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguTm9kZVByb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgTm9kZVByb3RvLnByb3RvdHlwZS5uYW1lID0gXCJcIjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogTm9kZVByb3RvIG9wVHlwZS5cbiAgICAgICAgICogQG1lbWJlciB7c3RyaW5nfSBvcFR5cGVcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguTm9kZVByb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgTm9kZVByb3RvLnByb3RvdHlwZS5vcFR5cGUgPSBcIlwiO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOb2RlUHJvdG8gZG9tYWluLlxuICAgICAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IGRvbWFpblxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5Ob2RlUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBOb2RlUHJvdG8ucHJvdG90eXBlLmRvbWFpbiA9IFwiXCI7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5vZGVQcm90byBhdHRyaWJ1dGUuXG4gICAgICAgICAqIEBtZW1iZXIge0FycmF5Ljxvbm54LklBdHRyaWJ1dGVQcm90bz59IGF0dHJpYnV0ZVxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5Ob2RlUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBOb2RlUHJvdG8ucHJvdG90eXBlLmF0dHJpYnV0ZSA9ICR1dGlsLmVtcHR5QXJyYXk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5vZGVQcm90byBkb2NTdHJpbmcuXG4gICAgICAgICAqIEBtZW1iZXIge3N0cmluZ30gZG9jU3RyaW5nXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54Lk5vZGVQcm90b1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIE5vZGVQcm90by5wcm90b3R5cGUuZG9jU3RyaW5nID0gXCJcIjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIG5ldyBOb2RlUHJvdG8gaW5zdGFuY2UgdXNpbmcgdGhlIHNwZWNpZmllZCBwcm9wZXJ0aWVzLlxuICAgICAgICAgKiBAZnVuY3Rpb24gY3JlYXRlXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54Lk5vZGVQcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7b25ueC5JTm9kZVByb3RvPX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gICAgICAgICAqIEByZXR1cm5zIHtvbm54Lk5vZGVQcm90b30gTm9kZVByb3RvIGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBOb2RlUHJvdG8uY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTm9kZVByb3RvKHByb3BlcnRpZXMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgTm9kZVByb3RvIG1lc3NhZ2UuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIG9ubnguTm9kZVByb3RvLnZlcmlmeXx2ZXJpZnl9IG1lc3NhZ2VzLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZW5jb2RlXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54Lk5vZGVQcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7b25ueC5JTm9kZVByb3RvfSBtZXNzYWdlIE5vZGVQcm90byBtZXNzYWdlIG9yIHBsYWluIG9iamVjdCB0byBlbmNvZGVcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuV3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gZW5jb2RlIHRvXG4gICAgICAgICAqIEByZXR1cm5zIHskcHJvdG9idWYuV3JpdGVyfSBXcml0ZXJcbiAgICAgICAgICovXG4gICAgICAgIE5vZGVQcm90by5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgICBpZiAoIXdyaXRlcilcbiAgICAgICAgICAgICAgICB3cml0ZXIgPSAkV3JpdGVyLmNyZWF0ZSgpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuaW5wdXQgIT0gbnVsbCAmJiBtZXNzYWdlLmlucHV0Lmxlbmd0aClcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UuaW5wdXQubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMSwgd2lyZVR5cGUgMiA9Ki8xMCkuc3RyaW5nKG1lc3NhZ2UuaW5wdXRbaV0pO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2Uub3V0cHV0ICE9IG51bGwgJiYgbWVzc2FnZS5vdXRwdXQubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5vdXRwdXQubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMiwgd2lyZVR5cGUgMiA9Ki8xOCkuc3RyaW5nKG1lc3NhZ2Uub3V0cHV0W2ldKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm5hbWUgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcIm5hbWVcIikpXG4gICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCAzLCB3aXJlVHlwZSAyID0qLzI2KS5zdHJpbmcobWVzc2FnZS5uYW1lKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm9wVHlwZSAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwib3BUeXBlXCIpKVxuICAgICAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgNCwgd2lyZVR5cGUgMiA9Ki8zNCkuc3RyaW5nKG1lc3NhZ2Uub3BUeXBlKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmF0dHJpYnV0ZSAhPSBudWxsICYmIG1lc3NhZ2UuYXR0cmlidXRlLmxlbmd0aClcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UuYXR0cmlidXRlLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICAkcm9vdC5vbm54LkF0dHJpYnV0ZVByb3RvLmVuY29kZShtZXNzYWdlLmF0dHJpYnV0ZVtpXSwgd3JpdGVyLnVpbnQzMigvKiBpZCA1LCB3aXJlVHlwZSAyID0qLzQyKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZG9jU3RyaW5nICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJkb2NTdHJpbmdcIikpXG4gICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCA2LCB3aXJlVHlwZSAyID0qLzUwKS5zdHJpbmcobWVzc2FnZS5kb2NTdHJpbmcpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZG9tYWluICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJkb21haW5cIikpXG4gICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCA3LCB3aXJlVHlwZSAyID0qLzU4KS5zdHJpbmcobWVzc2FnZS5kb21haW4pO1xuICAgICAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRW5jb2RlcyB0aGUgc3BlY2lmaWVkIE5vZGVQcm90byBtZXNzYWdlLCBsZW5ndGggZGVsaW1pdGVkLiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayBvbm54Lk5vZGVQcm90by52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZFxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5Ob2RlUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge29ubnguSU5vZGVQcm90b30gbWVzc2FnZSBOb2RlUHJvdG8gbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLldyaXRlcn0gW3dyaXRlcl0gV3JpdGVyIHRvIGVuY29kZSB0b1xuICAgICAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXG4gICAgICAgICAqL1xuICAgICAgICBOb2RlUHJvdG8uZW5jb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikubGRlbGltKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlY29kZXMgYSBOb2RlUHJvdG8gbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyIG9yIGJ1ZmZlci5cbiAgICAgICAgICogQGZ1bmN0aW9uIGRlY29kZVxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5Ob2RlUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGhdIE1lc3NhZ2UgbGVuZ3RoIGlmIGtub3duIGJlZm9yZWhhbmRcbiAgICAgICAgICogQHJldHVybnMge29ubnguTm9kZVByb3RvfSBOb2RlUHJvdG9cbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcbiAgICAgICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICAgICAqL1xuICAgICAgICBOb2RlUHJvdG8uZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHJlYWRlciwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgICByZWFkZXIgPSAkUmVhZGVyLmNyZWF0ZShyZWFkZXIpO1xuICAgICAgICAgICAgdmFyIGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGgsIG1lc3NhZ2UgPSBuZXcgJHJvb3Qub25ueC5Ob2RlUHJvdG8oKTtcbiAgICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMToge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEobWVzc2FnZS5pbnB1dCAmJiBtZXNzYWdlLmlucHV0Lmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pbnB1dCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pbnB1dC5wdXNoKHJlYWRlci5zdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgMjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEobWVzc2FnZS5vdXRwdXQgJiYgbWVzc2FnZS5vdXRwdXQubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm91dHB1dCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5vdXRwdXQucHVzaChyZWFkZXIuc3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIDM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UubmFtZSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSA0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm9wVHlwZSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSA3OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmRvbWFpbiA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSA1OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShtZXNzYWdlLmF0dHJpYnV0ZSAmJiBtZXNzYWdlLmF0dHJpYnV0ZS5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuYXR0cmlidXRlID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmF0dHJpYnV0ZS5wdXNoKCRyb290Lm9ubnguQXR0cmlidXRlUHJvdG8uZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgNjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5kb2NTdHJpbmcgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlY29kZXMgYSBOb2RlUHJvdG8gbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyIG9yIGJ1ZmZlciwgbGVuZ3RoIGRlbGltaXRlZC5cbiAgICAgICAgICogQGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZFxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5Ob2RlUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgICAgICogQHJldHVybnMge29ubnguTm9kZVByb3RvfSBOb2RlUHJvdG9cbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcbiAgICAgICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICAgICAqL1xuICAgICAgICBOb2RlUHJvdG8uZGVjb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkKHJlYWRlcikge1xuICAgICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgICAgcmVhZGVyID0gbmV3ICRSZWFkZXIocmVhZGVyKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFZlcmlmaWVzIGEgTm9kZVByb3RvIG1lc3NhZ2UuXG4gICAgICAgICAqIEBmdW5jdGlvbiB2ZXJpZnlcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguTm9kZVByb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gbWVzc2FnZSBQbGFpbiBvYmplY3QgdG8gdmVyaWZ5XG4gICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd8bnVsbH0gYG51bGxgIGlmIHZhbGlkLCBvdGhlcndpc2UgdGhlIHJlYXNvbiB3aHkgaXQgaXMgbm90XG4gICAgICAgICAqL1xuICAgICAgICBOb2RlUHJvdG8udmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5KG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSAhPT0gXCJvYmplY3RcIiB8fCBtZXNzYWdlID09PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiBcIm9iamVjdCBleHBlY3RlZFwiO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuaW5wdXQgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiaW5wdXRcIikpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobWVzc2FnZS5pbnB1dCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImlucHV0OiBhcnJheSBleHBlY3RlZFwiO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5pbnB1dC5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEkdXRpbC5pc1N0cmluZyhtZXNzYWdlLmlucHV0W2ldKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcImlucHV0OiBzdHJpbmdbXSBleHBlY3RlZFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2Uub3V0cHV0ICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIm91dHB1dFwiKSkge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShtZXNzYWdlLm91dHB1dCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIm91dHB1dDogYXJyYXkgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2Uub3V0cHV0Lmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICBpZiAoISR1dGlsLmlzU3RyaW5nKG1lc3NhZ2Uub3V0cHV0W2ldKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIm91dHB1dDogc3RyaW5nW10gZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm5hbWUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwibmFtZVwiKSlcbiAgICAgICAgICAgICAgICBpZiAoISR1dGlsLmlzU3RyaW5nKG1lc3NhZ2UubmFtZSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIm5hbWU6IHN0cmluZyBleHBlY3RlZFwiO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2Uub3BUeXBlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIm9wVHlwZVwiKSlcbiAgICAgICAgICAgICAgICBpZiAoISR1dGlsLmlzU3RyaW5nKG1lc3NhZ2Uub3BUeXBlKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwib3BUeXBlOiBzdHJpbmcgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmRvbWFpbiAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJkb21haW5cIikpXG4gICAgICAgICAgICAgICAgaWYgKCEkdXRpbC5pc1N0cmluZyhtZXNzYWdlLmRvbWFpbikpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImRvbWFpbjogc3RyaW5nIGV4cGVjdGVkXCI7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5hdHRyaWJ1dGUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiYXR0cmlidXRlXCIpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG1lc3NhZ2UuYXR0cmlidXRlKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiYXR0cmlidXRlOiBhcnJheSBleHBlY3RlZFwiO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5hdHRyaWJ1dGUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVycm9yID0gJHJvb3Qub25ueC5BdHRyaWJ1dGVQcm90by52ZXJpZnkobWVzc2FnZS5hdHRyaWJ1dGVbaV0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJhdHRyaWJ1dGUuXCIgKyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5kb2NTdHJpbmcgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZG9jU3RyaW5nXCIpKVxuICAgICAgICAgICAgICAgIGlmICghJHV0aWwuaXNTdHJpbmcobWVzc2FnZS5kb2NTdHJpbmcpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJkb2NTdHJpbmc6IHN0cmluZyBleHBlY3RlZFwiO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBOb2RlUHJvdG8gbWVzc2FnZSBmcm9tIGEgcGxhaW4gb2JqZWN0LiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byB0aGVpciByZXNwZWN0aXZlIGludGVybmFsIHR5cGVzLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZnJvbU9iamVjdFxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5Ob2RlUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBvYmplY3QgUGxhaW4gb2JqZWN0XG4gICAgICAgICAqIEByZXR1cm5zIHtvbm54Lk5vZGVQcm90b30gTm9kZVByb3RvXG4gICAgICAgICAqL1xuICAgICAgICBOb2RlUHJvdG8uZnJvbU9iamVjdCA9IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgJHJvb3Qub25ueC5Ob2RlUHJvdG8pXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgICAgIHZhciBtZXNzYWdlID0gbmV3ICRyb290Lm9ubnguTm9kZVByb3RvKCk7XG4gICAgICAgICAgICBpZiAob2JqZWN0LmlucHV0KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9iamVjdC5pbnB1dCkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5vbm54Lk5vZGVQcm90by5pbnB1dDogYXJyYXkgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5pbnB1dCA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0LmlucHV0Lmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmlucHV0W2ldID0gU3RyaW5nKG9iamVjdC5pbnB1dFtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2JqZWN0Lm91dHB1dCkge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvYmplY3Qub3V0cHV0KSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguTm9kZVByb3RvLm91dHB1dDogYXJyYXkgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5vdXRwdXQgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdC5vdXRwdXQubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uub3V0cHV0W2ldID0gU3RyaW5nKG9iamVjdC5vdXRwdXRbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9iamVjdC5uYW1lICE9IG51bGwpXG4gICAgICAgICAgICAgICAgbWVzc2FnZS5uYW1lID0gU3RyaW5nKG9iamVjdC5uYW1lKTtcbiAgICAgICAgICAgIGlmIChvYmplY3Qub3BUeXBlICE9IG51bGwpXG4gICAgICAgICAgICAgICAgbWVzc2FnZS5vcFR5cGUgPSBTdHJpbmcob2JqZWN0Lm9wVHlwZSk7XG4gICAgICAgICAgICBpZiAob2JqZWN0LmRvbWFpbiAhPSBudWxsKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UuZG9tYWluID0gU3RyaW5nKG9iamVjdC5kb21haW4pO1xuICAgICAgICAgICAgaWYgKG9iamVjdC5hdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqZWN0LmF0dHJpYnV0ZSkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5vbm54Lk5vZGVQcm90by5hdHRyaWJ1dGU6IGFycmF5IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UuYXR0cmlidXRlID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3QuYXR0cmlidXRlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LmF0dHJpYnV0ZVtpXSAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5vbm54Lk5vZGVQcm90by5hdHRyaWJ1dGU6IG9iamVjdCBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5hdHRyaWJ1dGVbaV0gPSAkcm9vdC5vbm54LkF0dHJpYnV0ZVByb3RvLmZyb21PYmplY3Qob2JqZWN0LmF0dHJpYnV0ZVtpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9iamVjdC5kb2NTdHJpbmcgIT0gbnVsbClcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmRvY1N0cmluZyA9IFN0cmluZyhvYmplY3QuZG9jU3RyaW5nKTtcbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgcGxhaW4gb2JqZWN0IGZyb20gYSBOb2RlUHJvdG8gbWVzc2FnZS4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gb3RoZXIgdHlwZXMgaWYgc3BlY2lmaWVkLlxuICAgICAgICAgKiBAZnVuY3Rpb24gdG9PYmplY3RcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguTm9kZVByb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtvbm54Lk5vZGVQcm90b30gbWVzc2FnZSBOb2RlUHJvdG9cbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuSUNvbnZlcnNpb25PcHRpb25zfSBbb3B0aW9uc10gQ29udmVyc2lvbiBvcHRpb25zXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gUGxhaW4gb2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICBOb2RlUHJvdG8udG9PYmplY3QgPSBmdW5jdGlvbiB0b09iamVjdChtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMpXG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgICAgdmFyIG9iamVjdCA9IHt9O1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuYXJyYXlzIHx8IG9wdGlvbnMuZGVmYXVsdHMpIHtcbiAgICAgICAgICAgICAgICBvYmplY3QuaW5wdXQgPSBbXTtcbiAgICAgICAgICAgICAgICBvYmplY3Qub3V0cHV0ID0gW107XG4gICAgICAgICAgICAgICAgb2JqZWN0LmF0dHJpYnV0ZSA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGVmYXVsdHMpIHtcbiAgICAgICAgICAgICAgICBvYmplY3QubmFtZSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgb2JqZWN0Lm9wVHlwZSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgb2JqZWN0LmRvY1N0cmluZyA9IFwiXCI7XG4gICAgICAgICAgICAgICAgb2JqZWN0LmRvbWFpbiA9IFwiXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5pbnB1dCAmJiBtZXNzYWdlLmlucHV0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIG9iamVjdC5pbnB1dCA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWVzc2FnZS5pbnB1dC5sZW5ndGg7ICsrailcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LmlucHV0W2pdID0gbWVzc2FnZS5pbnB1dFtqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm91dHB1dCAmJiBtZXNzYWdlLm91dHB1dC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBvYmplY3Qub3V0cHV0ID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtZXNzYWdlLm91dHB1dC5sZW5ndGg7ICsrailcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0Lm91dHB1dFtqXSA9IG1lc3NhZ2Uub3V0cHV0W2pdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UubmFtZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJuYW1lXCIpKVxuICAgICAgICAgICAgICAgIG9iamVjdC5uYW1lID0gbWVzc2FnZS5uYW1lO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2Uub3BUeXBlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIm9wVHlwZVwiKSlcbiAgICAgICAgICAgICAgICBvYmplY3Qub3BUeXBlID0gbWVzc2FnZS5vcFR5cGU7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5hdHRyaWJ1dGUgJiYgbWVzc2FnZS5hdHRyaWJ1dGUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0LmF0dHJpYnV0ZSA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWVzc2FnZS5hdHRyaWJ1dGUubGVuZ3RoOyArK2opXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5hdHRyaWJ1dGVbal0gPSAkcm9vdC5vbm54LkF0dHJpYnV0ZVByb3RvLnRvT2JqZWN0KG1lc3NhZ2UuYXR0cmlidXRlW2pdLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmRvY1N0cmluZyAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJkb2NTdHJpbmdcIikpXG4gICAgICAgICAgICAgICAgb2JqZWN0LmRvY1N0cmluZyA9IG1lc3NhZ2UuZG9jU3RyaW5nO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZG9tYWluICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImRvbWFpblwiKSlcbiAgICAgICAgICAgICAgICBvYmplY3QuZG9tYWluID0gbWVzc2FnZS5kb21haW47XG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb252ZXJ0cyB0aGlzIE5vZGVQcm90byB0byBKU09OLlxuICAgICAgICAgKiBAZnVuY3Rpb24gdG9KU09OXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54Lk5vZGVQcm90b1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBKU09OIG9iamVjdFxuICAgICAgICAgKi9cbiAgICAgICAgTm9kZVByb3RvLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLCAkcHJvdG9idWYudXRpbC50b0pTT05PcHRpb25zKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0cyB0aGUgZGVmYXVsdCB0eXBlIHVybCBmb3IgTm9kZVByb3RvXG4gICAgICAgICAqIEBmdW5jdGlvbiBnZXRUeXBlVXJsXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54Lk5vZGVQcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbdHlwZVVybFByZWZpeF0geW91ciBjdXN0b20gdHlwZVVybFByZWZpeChkZWZhdWx0IFwidHlwZS5nb29nbGVhcGlzLmNvbVwiKVxuICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgZGVmYXVsdCB0eXBlIHVybFxuICAgICAgICAgKi9cbiAgICAgICAgTm9kZVByb3RvLmdldFR5cGVVcmwgPSBmdW5jdGlvbiBnZXRUeXBlVXJsKHR5cGVVcmxQcmVmaXgpIHtcbiAgICAgICAgICAgIGlmICh0eXBlVXJsUHJlZml4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0eXBlVXJsUHJlZml4ID0gXCJ0eXBlLmdvb2dsZWFwaXMuY29tXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHlwZVVybFByZWZpeCArIFwiL29ubnguTm9kZVByb3RvXCI7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIE5vZGVQcm90bztcbiAgICB9KSgpO1xuXG4gICAgb25ueC5UcmFpbmluZ0luZm9Qcm90byA9IChmdW5jdGlvbigpIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUHJvcGVydGllcyBvZiBhIFRyYWluaW5nSW5mb1Byb3RvLlxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueFxuICAgICAgICAgKiBAaW50ZXJmYWNlIElUcmFpbmluZ0luZm9Qcm90b1xuICAgICAgICAgKiBAcHJvcGVydHkge29ubnguSUdyYXBoUHJvdG98bnVsbH0gW2luaXRpYWxpemF0aW9uXSBUcmFpbmluZ0luZm9Qcm90byBpbml0aWFsaXphdGlvblxuICAgICAgICAgKiBAcHJvcGVydHkge29ubnguSUdyYXBoUHJvdG98bnVsbH0gW2FsZ29yaXRobV0gVHJhaW5pbmdJbmZvUHJvdG8gYWxnb3JpdGhtXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7QXJyYXkuPG9ubnguSVN0cmluZ1N0cmluZ0VudHJ5UHJvdG8+fG51bGx9IFtpbml0aWFsaXphdGlvbkJpbmRpbmddIFRyYWluaW5nSW5mb1Byb3RvIGluaXRpYWxpemF0aW9uQmluZGluZ1xuICAgICAgICAgKiBAcHJvcGVydHkge0FycmF5Ljxvbm54LklTdHJpbmdTdHJpbmdFbnRyeVByb3RvPnxudWxsfSBbdXBkYXRlQmluZGluZ10gVHJhaW5pbmdJbmZvUHJvdG8gdXBkYXRlQmluZGluZ1xuICAgICAgICAgKi9cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29uc3RydWN0cyBhIG5ldyBUcmFpbmluZ0luZm9Qcm90by5cbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnhcbiAgICAgICAgICogQGNsYXNzZGVzYyBSZXByZXNlbnRzIGEgVHJhaW5pbmdJbmZvUHJvdG8uXG4gICAgICAgICAqIEBpbXBsZW1lbnRzIElUcmFpbmluZ0luZm9Qcm90b1xuICAgICAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgICAgICogQHBhcmFtIHtvbm54LklUcmFpbmluZ0luZm9Qcm90bz19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gVHJhaW5pbmdJbmZvUHJvdG8ocHJvcGVydGllcykge1xuICAgICAgICAgICAgdGhpcy5pbml0aWFsaXphdGlvbkJpbmRpbmcgPSBbXTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQmluZGluZyA9IFtdO1xuICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMpXG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzW2tleXNbaV1dICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2tleXNbaV1dID0gcHJvcGVydGllc1trZXlzW2ldXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcmFpbmluZ0luZm9Qcm90byBpbml0aWFsaXphdGlvbi5cbiAgICAgICAgICogQG1lbWJlciB7b25ueC5JR3JhcGhQcm90b3xudWxsfHVuZGVmaW5lZH0gaW5pdGlhbGl6YXRpb25cbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVHJhaW5pbmdJbmZvUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBUcmFpbmluZ0luZm9Qcm90by5wcm90b3R5cGUuaW5pdGlhbGl6YXRpb24gPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcmFpbmluZ0luZm9Qcm90byBhbGdvcml0aG0uXG4gICAgICAgICAqIEBtZW1iZXIge29ubnguSUdyYXBoUHJvdG98bnVsbHx1bmRlZmluZWR9IGFsZ29yaXRobVxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UcmFpbmluZ0luZm9Qcm90b1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIFRyYWluaW5nSW5mb1Byb3RvLnByb3RvdHlwZS5hbGdvcml0aG0gPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcmFpbmluZ0luZm9Qcm90byBpbml0aWFsaXphdGlvbkJpbmRpbmcuXG4gICAgICAgICAqIEBtZW1iZXIge0FycmF5Ljxvbm54LklTdHJpbmdTdHJpbmdFbnRyeVByb3RvPn0gaW5pdGlhbGl6YXRpb25CaW5kaW5nXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRyYWluaW5nSW5mb1Byb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgVHJhaW5pbmdJbmZvUHJvdG8ucHJvdG90eXBlLmluaXRpYWxpemF0aW9uQmluZGluZyA9ICR1dGlsLmVtcHR5QXJyYXk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRyYWluaW5nSW5mb1Byb3RvIHVwZGF0ZUJpbmRpbmcuXG4gICAgICAgICAqIEBtZW1iZXIge0FycmF5Ljxvbm54LklTdHJpbmdTdHJpbmdFbnRyeVByb3RvPn0gdXBkYXRlQmluZGluZ1xuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UcmFpbmluZ0luZm9Qcm90b1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIFRyYWluaW5nSW5mb1Byb3RvLnByb3RvdHlwZS51cGRhdGVCaW5kaW5nID0gJHV0aWwuZW1wdHlBcnJheTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIG5ldyBUcmFpbmluZ0luZm9Qcm90byBpbnN0YW5jZSB1c2luZyB0aGUgc3BlY2lmaWVkIHByb3BlcnRpZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBjcmVhdGVcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVHJhaW5pbmdJbmZvUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge29ubnguSVRyYWluaW5nSW5mb1Byb3RvPX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gICAgICAgICAqIEByZXR1cm5zIHtvbm54LlRyYWluaW5nSW5mb1Byb3RvfSBUcmFpbmluZ0luZm9Qcm90byBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgVHJhaW5pbmdJbmZvUHJvdG8uY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVHJhaW5pbmdJbmZvUHJvdG8ocHJvcGVydGllcyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBUcmFpbmluZ0luZm9Qcm90byBtZXNzYWdlLiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayBvbm54LlRyYWluaW5nSW5mb1Byb3RvLnZlcmlmeXx2ZXJpZnl9IG1lc3NhZ2VzLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZW5jb2RlXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRyYWluaW5nSW5mb1Byb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtvbm54LklUcmFpbmluZ0luZm9Qcm90b30gbWVzc2FnZSBUcmFpbmluZ0luZm9Qcm90byBtZXNzYWdlIG9yIHBsYWluIG9iamVjdCB0byBlbmNvZGVcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuV3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gZW5jb2RlIHRvXG4gICAgICAgICAqIEByZXR1cm5zIHskcHJvdG9idWYuV3JpdGVyfSBXcml0ZXJcbiAgICAgICAgICovXG4gICAgICAgIFRyYWluaW5nSW5mb1Byb3RvLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICAgIGlmICghd3JpdGVyKVxuICAgICAgICAgICAgICAgIHdyaXRlciA9ICRXcml0ZXIuY3JlYXRlKCk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5pbml0aWFsaXphdGlvbiAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwiaW5pdGlhbGl6YXRpb25cIikpXG4gICAgICAgICAgICAgICAgJHJvb3Qub25ueC5HcmFwaFByb3RvLmVuY29kZShtZXNzYWdlLmluaXRpYWxpemF0aW9uLCB3cml0ZXIudWludDMyKC8qIGlkIDEsIHdpcmVUeXBlIDIgPSovMTApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5hbGdvcml0aG0gIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcImFsZ29yaXRobVwiKSlcbiAgICAgICAgICAgICAgICAkcm9vdC5vbm54LkdyYXBoUHJvdG8uZW5jb2RlKG1lc3NhZ2UuYWxnb3JpdGhtLCB3cml0ZXIudWludDMyKC8qIGlkIDIsIHdpcmVUeXBlIDIgPSovMTgpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5pbml0aWFsaXphdGlvbkJpbmRpbmcgIT0gbnVsbCAmJiBtZXNzYWdlLmluaXRpYWxpemF0aW9uQmluZGluZy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLmluaXRpYWxpemF0aW9uQmluZGluZy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgJHJvb3Qub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvLmVuY29kZShtZXNzYWdlLmluaXRpYWxpemF0aW9uQmluZGluZ1tpXSwgd3JpdGVyLnVpbnQzMigvKiBpZCAzLCB3aXJlVHlwZSAyID0qLzI2KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UudXBkYXRlQmluZGluZyAhPSBudWxsICYmIG1lc3NhZ2UudXBkYXRlQmluZGluZy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLnVwZGF0ZUJpbmRpbmcubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgICRyb290Lm9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90by5lbmNvZGUobWVzc2FnZS51cGRhdGVCaW5kaW5nW2ldLCB3cml0ZXIudWludDMyKC8qIGlkIDQsIHdpcmVUeXBlIDIgPSovMzQpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgVHJhaW5pbmdJbmZvUHJvdG8gbWVzc2FnZSwgbGVuZ3RoIGRlbGltaXRlZC4gRG9lcyBub3QgaW1wbGljaXRseSB7QGxpbmsgb25ueC5UcmFpbmluZ0luZm9Qcm90by52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZFxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UcmFpbmluZ0luZm9Qcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7b25ueC5JVHJhaW5pbmdJbmZvUHJvdG99IG1lc3NhZ2UgVHJhaW5pbmdJbmZvUHJvdG8gbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLldyaXRlcn0gW3dyaXRlcl0gV3JpdGVyIHRvIGVuY29kZSB0b1xuICAgICAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXG4gICAgICAgICAqL1xuICAgICAgICBUcmFpbmluZ0luZm9Qcm90by5lbmNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWQobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGUobWVzc2FnZSwgd3JpdGVyKS5sZGVsaW0oKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGVjb2RlcyBhIFRyYWluaW5nSW5mb1Byb3RvIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIuXG4gICAgICAgICAqIEBmdW5jdGlvbiBkZWNvZGVcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVHJhaW5pbmdJbmZvUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGhdIE1lc3NhZ2UgbGVuZ3RoIGlmIGtub3duIGJlZm9yZWhhbmRcbiAgICAgICAgICogQHJldHVybnMge29ubnguVHJhaW5pbmdJbmZvUHJvdG99IFRyYWluaW5nSW5mb1Byb3RvXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAgICAgKi9cbiAgICAgICAgVHJhaW5pbmdJbmZvUHJvdG8uZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHJlYWRlciwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgICByZWFkZXIgPSAkUmVhZGVyLmNyZWF0ZShyZWFkZXIpO1xuICAgICAgICAgICAgdmFyIGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGgsIG1lc3NhZ2UgPSBuZXcgJHJvb3Qub25ueC5UcmFpbmluZ0luZm9Qcm90bygpO1xuICAgICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmluaXRpYWxpemF0aW9uID0gJHJvb3Qub25ueC5HcmFwaFByb3RvLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgMjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5hbGdvcml0aG0gPSAkcm9vdC5vbm54LkdyYXBoUHJvdG8uZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShtZXNzYWdlLmluaXRpYWxpemF0aW9uQmluZGluZyAmJiBtZXNzYWdlLmluaXRpYWxpemF0aW9uQmluZGluZy5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaW5pdGlhbGl6YXRpb25CaW5kaW5nID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmluaXRpYWxpemF0aW9uQmluZGluZy5wdXNoKCRyb290Lm9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90by5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSA0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShtZXNzYWdlLnVwZGF0ZUJpbmRpbmcgJiYgbWVzc2FnZS51cGRhdGVCaW5kaW5nLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS51cGRhdGVCaW5kaW5nID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnVwZGF0ZUJpbmRpbmcucHVzaCgkcm9vdC5vbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG8uZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlY29kZXMgYSBUcmFpbmluZ0luZm9Qcm90byBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLCBsZW5ndGggZGVsaW1pdGVkLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRyYWluaW5nSW5mb1Byb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gICAgICAgICAqIEByZXR1cm5zIHtvbm54LlRyYWluaW5nSW5mb1Byb3RvfSBUcmFpbmluZ0luZm9Qcm90b1xuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcbiAgICAgICAgICovXG4gICAgICAgIFRyYWluaW5nSW5mb1Byb3RvLmRlY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZChyZWFkZXIpIHtcbiAgICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgICAgIHJlYWRlciA9IG5ldyAkUmVhZGVyKHJlYWRlcik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBWZXJpZmllcyBhIFRyYWluaW5nSW5mb1Byb3RvIG1lc3NhZ2UuXG4gICAgICAgICAqIEBmdW5jdGlvbiB2ZXJpZnlcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVHJhaW5pbmdJbmZvUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBtZXNzYWdlIFBsYWluIG9iamVjdCB0byB2ZXJpZnlcbiAgICAgICAgICogQHJldHVybnMge3N0cmluZ3xudWxsfSBgbnVsbGAgaWYgdmFsaWQsIG90aGVyd2lzZSB0aGUgcmVhc29uIHdoeSBpdCBpcyBub3RcbiAgICAgICAgICovXG4gICAgICAgIFRyYWluaW5nSW5mb1Byb3RvLnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtZXNzYWdlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgIT09IFwib2JqZWN0XCIgfHwgbWVzc2FnZSA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJvYmplY3QgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmluaXRpYWxpemF0aW9uICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImluaXRpYWxpemF0aW9uXCIpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVycm9yID0gJHJvb3Qub25ueC5HcmFwaFByb3RvLnZlcmlmeShtZXNzYWdlLmluaXRpYWxpemF0aW9uKTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImluaXRpYWxpemF0aW9uLlwiICsgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5hbGdvcml0aG0gIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiYWxnb3JpdGhtXCIpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVycm9yID0gJHJvb3Qub25ueC5HcmFwaFByb3RvLnZlcmlmeShtZXNzYWdlLmFsZ29yaXRobSk7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJhbGdvcml0aG0uXCIgKyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmluaXRpYWxpemF0aW9uQmluZGluZyAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJpbml0aWFsaXphdGlvbkJpbmRpbmdcIikpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobWVzc2FnZS5pbml0aWFsaXphdGlvbkJpbmRpbmcpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJpbml0aWFsaXphdGlvbkJpbmRpbmc6IGFycmF5IGV4cGVjdGVkXCI7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLmluaXRpYWxpemF0aW9uQmluZGluZy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXJyb3IgPSAkcm9vdC5vbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG8udmVyaWZ5KG1lc3NhZ2UuaW5pdGlhbGl6YXRpb25CaW5kaW5nW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiaW5pdGlhbGl6YXRpb25CaW5kaW5nLlwiICsgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UudXBkYXRlQmluZGluZyAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJ1cGRhdGVCaW5kaW5nXCIpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG1lc3NhZ2UudXBkYXRlQmluZGluZykpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcInVwZGF0ZUJpbmRpbmc6IGFycmF5IGV4cGVjdGVkXCI7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLnVwZGF0ZUJpbmRpbmcubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVycm9yID0gJHJvb3Qub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvLnZlcmlmeShtZXNzYWdlLnVwZGF0ZUJpbmRpbmdbaV0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJ1cGRhdGVCaW5kaW5nLlwiICsgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBUcmFpbmluZ0luZm9Qcm90byBtZXNzYWdlIGZyb20gYSBwbGFpbiBvYmplY3QuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIHRoZWlyIHJlc3BlY3RpdmUgaW50ZXJuYWwgdHlwZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBmcm9tT2JqZWN0XG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRyYWluaW5nSW5mb1Byb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gb2JqZWN0IFBsYWluIG9iamVjdFxuICAgICAgICAgKiBAcmV0dXJucyB7b25ueC5UcmFpbmluZ0luZm9Qcm90b30gVHJhaW5pbmdJbmZvUHJvdG9cbiAgICAgICAgICovXG4gICAgICAgIFRyYWluaW5nSW5mb1Byb3RvLmZyb21PYmplY3QgPSBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mICRyb290Lm9ubnguVHJhaW5pbmdJbmZvUHJvdG8pXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgICAgIHZhciBtZXNzYWdlID0gbmV3ICRyb290Lm9ubnguVHJhaW5pbmdJbmZvUHJvdG8oKTtcbiAgICAgICAgICAgIGlmIChvYmplY3QuaW5pdGlhbGl6YXRpb24gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LmluaXRpYWxpemF0aW9uICE9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5UcmFpbmluZ0luZm9Qcm90by5pbml0aWFsaXphdGlvbjogb2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UuaW5pdGlhbGl6YXRpb24gPSAkcm9vdC5vbm54LkdyYXBoUHJvdG8uZnJvbU9iamVjdChvYmplY3QuaW5pdGlhbGl6YXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9iamVjdC5hbGdvcml0aG0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LmFsZ29yaXRobSAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguVHJhaW5pbmdJbmZvUHJvdG8uYWxnb3JpdGhtOiBvYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5hbGdvcml0aG0gPSAkcm9vdC5vbm54LkdyYXBoUHJvdG8uZnJvbU9iamVjdChvYmplY3QuYWxnb3JpdGhtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvYmplY3QuaW5pdGlhbGl6YXRpb25CaW5kaW5nKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9iamVjdC5pbml0aWFsaXphdGlvbkJpbmRpbmcpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5UcmFpbmluZ0luZm9Qcm90by5pbml0aWFsaXphdGlvbkJpbmRpbmc6IGFycmF5IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UuaW5pdGlhbGl6YXRpb25CaW5kaW5nID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3QuaW5pdGlhbGl6YXRpb25CaW5kaW5nLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LmluaXRpYWxpemF0aW9uQmluZGluZ1tpXSAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5vbm54LlRyYWluaW5nSW5mb1Byb3RvLmluaXRpYWxpemF0aW9uQmluZGluZzogb2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmluaXRpYWxpemF0aW9uQmluZGluZ1tpXSA9ICRyb290Lm9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90by5mcm9tT2JqZWN0KG9iamVjdC5pbml0aWFsaXphdGlvbkJpbmRpbmdbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvYmplY3QudXBkYXRlQmluZGluZykge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvYmplY3QudXBkYXRlQmluZGluZykpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5vbm54LlRyYWluaW5nSW5mb1Byb3RvLnVwZGF0ZUJpbmRpbmc6IGFycmF5IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UudXBkYXRlQmluZGluZyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0LnVwZGF0ZUJpbmRpbmcubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QudXBkYXRlQmluZGluZ1tpXSAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5vbm54LlRyYWluaW5nSW5mb1Byb3RvLnVwZGF0ZUJpbmRpbmc6IG9iamVjdCBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS51cGRhdGVCaW5kaW5nW2ldID0gJHJvb3Qub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvLmZyb21PYmplY3Qob2JqZWN0LnVwZGF0ZUJpbmRpbmdbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgcGxhaW4gb2JqZWN0IGZyb20gYSBUcmFpbmluZ0luZm9Qcm90byBtZXNzYWdlLiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byBvdGhlciB0eXBlcyBpZiBzcGVjaWZpZWQuXG4gICAgICAgICAqIEBmdW5jdGlvbiB0b09iamVjdFxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UcmFpbmluZ0luZm9Qcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7b25ueC5UcmFpbmluZ0luZm9Qcm90b30gbWVzc2FnZSBUcmFpbmluZ0luZm9Qcm90b1xuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5JQ29udmVyc2lvbk9wdGlvbnN9IFtvcHRpb25zXSBDb252ZXJzaW9uIG9wdGlvbnNcbiAgICAgICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBQbGFpbiBvYmplY3RcbiAgICAgICAgICovXG4gICAgICAgIFRyYWluaW5nSW5mb1Byb3RvLnRvT2JqZWN0ID0gZnVuY3Rpb24gdG9PYmplY3QobWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zKVxuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgICAgIHZhciBvYmplY3QgPSB7fTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmFycmF5cyB8fCBvcHRpb25zLmRlZmF1bHRzKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0LmluaXRpYWxpemF0aW9uQmluZGluZyA9IFtdO1xuICAgICAgICAgICAgICAgIG9iamVjdC51cGRhdGVCaW5kaW5nID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5kZWZhdWx0cykge1xuICAgICAgICAgICAgICAgIG9iamVjdC5pbml0aWFsaXphdGlvbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgb2JqZWN0LmFsZ29yaXRobSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5pbml0aWFsaXphdGlvbiAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJpbml0aWFsaXphdGlvblwiKSlcbiAgICAgICAgICAgICAgICBvYmplY3QuaW5pdGlhbGl6YXRpb24gPSAkcm9vdC5vbm54LkdyYXBoUHJvdG8udG9PYmplY3QobWVzc2FnZS5pbml0aWFsaXphdGlvbiwgb3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5hbGdvcml0aG0gIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiYWxnb3JpdGhtXCIpKVxuICAgICAgICAgICAgICAgIG9iamVjdC5hbGdvcml0aG0gPSAkcm9vdC5vbm54LkdyYXBoUHJvdG8udG9PYmplY3QobWVzc2FnZS5hbGdvcml0aG0sIG9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuaW5pdGlhbGl6YXRpb25CaW5kaW5nICYmIG1lc3NhZ2UuaW5pdGlhbGl6YXRpb25CaW5kaW5nLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIG9iamVjdC5pbml0aWFsaXphdGlvbkJpbmRpbmcgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1lc3NhZ2UuaW5pdGlhbGl6YXRpb25CaW5kaW5nLmxlbmd0aDsgKytqKVxuICAgICAgICAgICAgICAgICAgICBvYmplY3QuaW5pdGlhbGl6YXRpb25CaW5kaW5nW2pdID0gJHJvb3Qub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvLnRvT2JqZWN0KG1lc3NhZ2UuaW5pdGlhbGl6YXRpb25CaW5kaW5nW2pdLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnVwZGF0ZUJpbmRpbmcgJiYgbWVzc2FnZS51cGRhdGVCaW5kaW5nLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIG9iamVjdC51cGRhdGVCaW5kaW5nID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtZXNzYWdlLnVwZGF0ZUJpbmRpbmcubGVuZ3RoOyArK2opXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC51cGRhdGVCaW5kaW5nW2pdID0gJHJvb3Qub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvLnRvT2JqZWN0KG1lc3NhZ2UudXBkYXRlQmluZGluZ1tqXSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb252ZXJ0cyB0aGlzIFRyYWluaW5nSW5mb1Byb3RvIHRvIEpTT04uXG4gICAgICAgICAqIEBmdW5jdGlvbiB0b0pTT05cbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVHJhaW5pbmdJbmZvUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gSlNPTiBvYmplY3RcbiAgICAgICAgICovXG4gICAgICAgIFRyYWluaW5nSW5mb1Byb3RvLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLCAkcHJvdG9idWYudXRpbC50b0pTT05PcHRpb25zKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0cyB0aGUgZGVmYXVsdCB0eXBlIHVybCBmb3IgVHJhaW5pbmdJbmZvUHJvdG9cbiAgICAgICAgICogQGZ1bmN0aW9uIGdldFR5cGVVcmxcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVHJhaW5pbmdJbmZvUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3R5cGVVcmxQcmVmaXhdIHlvdXIgY3VzdG9tIHR5cGVVcmxQcmVmaXgoZGVmYXVsdCBcInR5cGUuZ29vZ2xlYXBpcy5jb21cIilcbiAgICAgICAgICogQHJldHVybnMge3N0cmluZ30gVGhlIGRlZmF1bHQgdHlwZSB1cmxcbiAgICAgICAgICovXG4gICAgICAgIFRyYWluaW5nSW5mb1Byb3RvLmdldFR5cGVVcmwgPSBmdW5jdGlvbiBnZXRUeXBlVXJsKHR5cGVVcmxQcmVmaXgpIHtcbiAgICAgICAgICAgIGlmICh0eXBlVXJsUHJlZml4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0eXBlVXJsUHJlZml4ID0gXCJ0eXBlLmdvb2dsZWFwaXMuY29tXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHlwZVVybFByZWZpeCArIFwiL29ubnguVHJhaW5pbmdJbmZvUHJvdG9cIjtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gVHJhaW5pbmdJbmZvUHJvdG87XG4gICAgfSkoKTtcblxuICAgIG9ubnguTW9kZWxQcm90byA9IChmdW5jdGlvbigpIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUHJvcGVydGllcyBvZiBhIE1vZGVsUHJvdG8uXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54XG4gICAgICAgICAqIEBpbnRlcmZhY2UgSU1vZGVsUHJvdG9cbiAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ8TG9uZ3xudWxsfSBbaXJWZXJzaW9uXSBNb2RlbFByb3RvIGlyVmVyc2lvblxuICAgICAgICAgKiBAcHJvcGVydHkge0FycmF5Ljxvbm54LklPcGVyYXRvclNldElkUHJvdG8+fG51bGx9IFtvcHNldEltcG9ydF0gTW9kZWxQcm90byBvcHNldEltcG9ydFxuICAgICAgICAgKiBAcHJvcGVydHkge3N0cmluZ3xudWxsfSBbcHJvZHVjZXJOYW1lXSBNb2RlbFByb3RvIHByb2R1Y2VyTmFtZVxuICAgICAgICAgKiBAcHJvcGVydHkge3N0cmluZ3xudWxsfSBbcHJvZHVjZXJWZXJzaW9uXSBNb2RlbFByb3RvIHByb2R1Y2VyVmVyc2lvblxuICAgICAgICAgKiBAcHJvcGVydHkge3N0cmluZ3xudWxsfSBbZG9tYWluXSBNb2RlbFByb3RvIGRvbWFpblxuICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcnxMb25nfG51bGx9IFttb2RlbFZlcnNpb25dIE1vZGVsUHJvdG8gbW9kZWxWZXJzaW9uXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfG51bGx9IFtkb2NTdHJpbmddIE1vZGVsUHJvdG8gZG9jU3RyaW5nXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7b25ueC5JR3JhcGhQcm90b3xudWxsfSBbZ3JhcGhdIE1vZGVsUHJvdG8gZ3JhcGhcbiAgICAgICAgICogQHByb3BlcnR5IHtBcnJheS48b25ueC5JU3RyaW5nU3RyaW5nRW50cnlQcm90bz58bnVsbH0gW21ldGFkYXRhUHJvcHNdIE1vZGVsUHJvdG8gbWV0YWRhdGFQcm9wc1xuICAgICAgICAgKiBAcHJvcGVydHkge0FycmF5Ljxvbm54LklUcmFpbmluZ0luZm9Qcm90bz58bnVsbH0gW3RyYWluaW5nSW5mb10gTW9kZWxQcm90byB0cmFpbmluZ0luZm9cbiAgICAgICAgICogQHByb3BlcnR5IHtBcnJheS48b25ueC5JRnVuY3Rpb25Qcm90bz58bnVsbH0gW2Z1bmN0aW9uc10gTW9kZWxQcm90byBmdW5jdGlvbnNcbiAgICAgICAgICovXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnN0cnVjdHMgYSBuZXcgTW9kZWxQcm90by5cbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnhcbiAgICAgICAgICogQGNsYXNzZGVzYyBSZXByZXNlbnRzIGEgTW9kZWxQcm90by5cbiAgICAgICAgICogQGltcGxlbWVudHMgSU1vZGVsUHJvdG9cbiAgICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgICAqIEBwYXJhbSB7b25ueC5JTW9kZWxQcm90bz19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gTW9kZWxQcm90byhwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICB0aGlzLm9wc2V0SW1wb3J0ID0gW107XG4gICAgICAgICAgICB0aGlzLm1ldGFkYXRhUHJvcHMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMudHJhaW5pbmdJbmZvID0gW107XG4gICAgICAgICAgICB0aGlzLmZ1bmN0aW9ucyA9IFtdO1xuICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMpXG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzW2tleXNbaV1dICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2tleXNbaV1dID0gcHJvcGVydGllc1trZXlzW2ldXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNb2RlbFByb3RvIGlyVmVyc2lvbi5cbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfExvbmd9IGlyVmVyc2lvblxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5Nb2RlbFByb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgTW9kZWxQcm90by5wcm90b3R5cGUuaXJWZXJzaW9uID0gJHV0aWwuTG9uZyA/ICR1dGlsLkxvbmcuZnJvbUJpdHMoMCwwLGZhbHNlKSA6IDA7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1vZGVsUHJvdG8gb3BzZXRJbXBvcnQuXG4gICAgICAgICAqIEBtZW1iZXIge0FycmF5Ljxvbm54LklPcGVyYXRvclNldElkUHJvdG8+fSBvcHNldEltcG9ydFxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5Nb2RlbFByb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgTW9kZWxQcm90by5wcm90b3R5cGUub3BzZXRJbXBvcnQgPSAkdXRpbC5lbXB0eUFycmF5O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNb2RlbFByb3RvIHByb2R1Y2VyTmFtZS5cbiAgICAgICAgICogQG1lbWJlciB7c3RyaW5nfSBwcm9kdWNlck5hbWVcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguTW9kZWxQcm90b1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIE1vZGVsUHJvdG8ucHJvdG90eXBlLnByb2R1Y2VyTmFtZSA9IFwiXCI7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1vZGVsUHJvdG8gcHJvZHVjZXJWZXJzaW9uLlxuICAgICAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IHByb2R1Y2VyVmVyc2lvblxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5Nb2RlbFByb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgTW9kZWxQcm90by5wcm90b3R5cGUucHJvZHVjZXJWZXJzaW9uID0gXCJcIjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogTW9kZWxQcm90byBkb21haW4uXG4gICAgICAgICAqIEBtZW1iZXIge3N0cmluZ30gZG9tYWluXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54Lk1vZGVsUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBNb2RlbFByb3RvLnByb3RvdHlwZS5kb21haW4gPSBcIlwiO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNb2RlbFByb3RvIG1vZGVsVmVyc2lvbi5cbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfExvbmd9IG1vZGVsVmVyc2lvblxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5Nb2RlbFByb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgTW9kZWxQcm90by5wcm90b3R5cGUubW9kZWxWZXJzaW9uID0gJHV0aWwuTG9uZyA/ICR1dGlsLkxvbmcuZnJvbUJpdHMoMCwwLGZhbHNlKSA6IDA7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1vZGVsUHJvdG8gZG9jU3RyaW5nLlxuICAgICAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IGRvY1N0cmluZ1xuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5Nb2RlbFByb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgTW9kZWxQcm90by5wcm90b3R5cGUuZG9jU3RyaW5nID0gXCJcIjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogTW9kZWxQcm90byBncmFwaC5cbiAgICAgICAgICogQG1lbWJlciB7b25ueC5JR3JhcGhQcm90b3xudWxsfHVuZGVmaW5lZH0gZ3JhcGhcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguTW9kZWxQcm90b1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIE1vZGVsUHJvdG8ucHJvdG90eXBlLmdyYXBoID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogTW9kZWxQcm90byBtZXRhZGF0YVByb3BzLlxuICAgICAgICAgKiBAbWVtYmVyIHtBcnJheS48b25ueC5JU3RyaW5nU3RyaW5nRW50cnlQcm90bz59IG1ldGFkYXRhUHJvcHNcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguTW9kZWxQcm90b1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIE1vZGVsUHJvdG8ucHJvdG90eXBlLm1ldGFkYXRhUHJvcHMgPSAkdXRpbC5lbXB0eUFycmF5O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNb2RlbFByb3RvIHRyYWluaW5nSW5mby5cbiAgICAgICAgICogQG1lbWJlciB7QXJyYXkuPG9ubnguSVRyYWluaW5nSW5mb1Byb3RvPn0gdHJhaW5pbmdJbmZvXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54Lk1vZGVsUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBNb2RlbFByb3RvLnByb3RvdHlwZS50cmFpbmluZ0luZm8gPSAkdXRpbC5lbXB0eUFycmF5O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNb2RlbFByb3RvIGZ1bmN0aW9ucy5cbiAgICAgICAgICogQG1lbWJlciB7QXJyYXkuPG9ubnguSUZ1bmN0aW9uUHJvdG8+fSBmdW5jdGlvbnNcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguTW9kZWxQcm90b1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIE1vZGVsUHJvdG8ucHJvdG90eXBlLmZ1bmN0aW9ucyA9ICR1dGlsLmVtcHR5QXJyYXk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBuZXcgTW9kZWxQcm90byBpbnN0YW5jZSB1c2luZyB0aGUgc3BlY2lmaWVkIHByb3BlcnRpZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBjcmVhdGVcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguTW9kZWxQcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7b25ueC5JTW9kZWxQcm90bz19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxuICAgICAgICAgKiBAcmV0dXJucyB7b25ueC5Nb2RlbFByb3RvfSBNb2RlbFByb3RvIGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBNb2RlbFByb3RvLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE1vZGVsUHJvdG8ocHJvcGVydGllcyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBNb2RlbFByb3RvIG1lc3NhZ2UuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIG9ubnguTW9kZWxQcm90by52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGVuY29kZVxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5Nb2RlbFByb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtvbm54LklNb2RlbFByb3RvfSBtZXNzYWdlIE1vZGVsUHJvdG8gbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLldyaXRlcn0gW3dyaXRlcl0gV3JpdGVyIHRvIGVuY29kZSB0b1xuICAgICAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXG4gICAgICAgICAqL1xuICAgICAgICBNb2RlbFByb3RvLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICAgIGlmICghd3JpdGVyKVxuICAgICAgICAgICAgICAgIHdyaXRlciA9ICRXcml0ZXIuY3JlYXRlKCk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5pclZlcnNpb24gIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcImlyVmVyc2lvblwiKSlcbiAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDEsIHdpcmVUeXBlIDAgPSovOCkuaW50NjQobWVzc2FnZS5pclZlcnNpb24pO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UucHJvZHVjZXJOYW1lICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJwcm9kdWNlck5hbWVcIikpXG4gICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCAyLCB3aXJlVHlwZSAyID0qLzE4KS5zdHJpbmcobWVzc2FnZS5wcm9kdWNlck5hbWUpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UucHJvZHVjZXJWZXJzaW9uICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJwcm9kdWNlclZlcnNpb25cIikpXG4gICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCAzLCB3aXJlVHlwZSAyID0qLzI2KS5zdHJpbmcobWVzc2FnZS5wcm9kdWNlclZlcnNpb24pO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZG9tYWluICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJkb21haW5cIikpXG4gICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCA0LCB3aXJlVHlwZSAyID0qLzM0KS5zdHJpbmcobWVzc2FnZS5kb21haW4pO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UubW9kZWxWZXJzaW9uICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJtb2RlbFZlcnNpb25cIikpXG4gICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCA1LCB3aXJlVHlwZSAwID0qLzQwKS5pbnQ2NChtZXNzYWdlLm1vZGVsVmVyc2lvbik7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5kb2NTdHJpbmcgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcImRvY1N0cmluZ1wiKSlcbiAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDYsIHdpcmVUeXBlIDIgPSovNTApLnN0cmluZyhtZXNzYWdlLmRvY1N0cmluZyk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5ncmFwaCAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwiZ3JhcGhcIikpXG4gICAgICAgICAgICAgICAgJHJvb3Qub25ueC5HcmFwaFByb3RvLmVuY29kZShtZXNzYWdlLmdyYXBoLCB3cml0ZXIudWludDMyKC8qIGlkIDcsIHdpcmVUeXBlIDIgPSovNTgpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5vcHNldEltcG9ydCAhPSBudWxsICYmIG1lc3NhZ2Uub3BzZXRJbXBvcnQubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5vcHNldEltcG9ydC5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgJHJvb3Qub25ueC5PcGVyYXRvclNldElkUHJvdG8uZW5jb2RlKG1lc3NhZ2Uub3BzZXRJbXBvcnRbaV0sIHdyaXRlci51aW50MzIoLyogaWQgOCwgd2lyZVR5cGUgMiA9Ki82NikuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm1ldGFkYXRhUHJvcHMgIT0gbnVsbCAmJiBtZXNzYWdlLm1ldGFkYXRhUHJvcHMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5tZXRhZGF0YVByb3BzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICAkcm9vdC5vbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG8uZW5jb2RlKG1lc3NhZ2UubWV0YWRhdGFQcm9wc1tpXSwgd3JpdGVyLnVpbnQzMigvKiBpZCAxNCwgd2lyZVR5cGUgMiA9Ki8xMTQpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS50cmFpbmluZ0luZm8gIT0gbnVsbCAmJiBtZXNzYWdlLnRyYWluaW5nSW5mby5sZW5ndGgpXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLnRyYWluaW5nSW5mby5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgJHJvb3Qub25ueC5UcmFpbmluZ0luZm9Qcm90by5lbmNvZGUobWVzc2FnZS50cmFpbmluZ0luZm9baV0sIHdyaXRlci51aW50MzIoLyogaWQgMjAsIHdpcmVUeXBlIDIgPSovMTYyKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZnVuY3Rpb25zICE9IG51bGwgJiYgbWVzc2FnZS5mdW5jdGlvbnMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5mdW5jdGlvbnMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgICRyb290Lm9ubnguRnVuY3Rpb25Qcm90by5lbmNvZGUobWVzc2FnZS5mdW5jdGlvbnNbaV0sIHdyaXRlci51aW50MzIoLyogaWQgMjUsIHdpcmVUeXBlIDIgPSovMjAyKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRW5jb2RlcyB0aGUgc3BlY2lmaWVkIE1vZGVsUHJvdG8gbWVzc2FnZSwgbGVuZ3RoIGRlbGltaXRlZC4gRG9lcyBub3QgaW1wbGljaXRseSB7QGxpbmsgb25ueC5Nb2RlbFByb3RvLnZlcmlmeXx2ZXJpZnl9IG1lc3NhZ2VzLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54Lk1vZGVsUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge29ubnguSU1vZGVsUHJvdG99IG1lc3NhZ2UgTW9kZWxQcm90byBtZXNzYWdlIG9yIHBsYWluIG9iamVjdCB0byBlbmNvZGVcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuV3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gZW5jb2RlIHRvXG4gICAgICAgICAqIEByZXR1cm5zIHskcHJvdG9idWYuV3JpdGVyfSBXcml0ZXJcbiAgICAgICAgICovXG4gICAgICAgIE1vZGVsUHJvdG8uZW5jb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikubGRlbGltKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlY29kZXMgYSBNb2RlbFByb3RvIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIuXG4gICAgICAgICAqIEBmdW5jdGlvbiBkZWNvZGVcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguTW9kZWxQcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLlJlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGUgZnJvbVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aF0gTWVzc2FnZSBsZW5ndGggaWYga25vd24gYmVmb3JlaGFuZFxuICAgICAgICAgKiBAcmV0dXJucyB7b25ueC5Nb2RlbFByb3RvfSBNb2RlbFByb3RvXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAgICAgKi9cbiAgICAgICAgTW9kZWxQcm90by5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUocmVhZGVyLCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgICAgIHJlYWRlciA9ICRSZWFkZXIuY3JlYXRlKHJlYWRlcik7XG4gICAgICAgICAgICB2YXIgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aCwgbWVzc2FnZSA9IG5ldyAkcm9vdC5vbm54Lk1vZGVsUHJvdG8oKTtcbiAgICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMToge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pclZlcnNpb24gPSByZWFkZXIuaW50NjQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSA4OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShtZXNzYWdlLm9wc2V0SW1wb3J0ICYmIG1lc3NhZ2Uub3BzZXRJbXBvcnQubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm9wc2V0SW1wb3J0ID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm9wc2V0SW1wb3J0LnB1c2goJHJvb3Qub25ueC5PcGVyYXRvclNldElkUHJvdG8uZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgMjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5wcm9kdWNlck5hbWUgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgMzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5wcm9kdWNlclZlcnNpb24gPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgNDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5kb21haW4gPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgNToge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5tb2RlbFZlcnNpb24gPSByZWFkZXIuaW50NjQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSA2OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmRvY1N0cmluZyA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSA3OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmdyYXBoID0gJHJvb3Qub25ueC5HcmFwaFByb3RvLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgMTQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKG1lc3NhZ2UubWV0YWRhdGFQcm9wcyAmJiBtZXNzYWdlLm1ldGFkYXRhUHJvcHMubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm1ldGFkYXRhUHJvcHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UubWV0YWRhdGFQcm9wcy5wdXNoKCRyb290Lm9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90by5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAyMDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEobWVzc2FnZS50cmFpbmluZ0luZm8gJiYgbWVzc2FnZS50cmFpbmluZ0luZm8ubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnRyYWluaW5nSW5mbyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS50cmFpbmluZ0luZm8ucHVzaCgkcm9vdC5vbm54LlRyYWluaW5nSW5mb1Byb3RvLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIDI1OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShtZXNzYWdlLmZ1bmN0aW9ucyAmJiBtZXNzYWdlLmZ1bmN0aW9ucy5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZnVuY3Rpb25zID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmZ1bmN0aW9ucy5wdXNoKCRyb290Lm9ubnguRnVuY3Rpb25Qcm90by5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGVjb2RlcyBhIE1vZGVsUHJvdG8gbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyIG9yIGJ1ZmZlciwgbGVuZ3RoIGRlbGltaXRlZC5cbiAgICAgICAgICogQGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZFxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5Nb2RlbFByb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gICAgICAgICAqIEByZXR1cm5zIHtvbm54Lk1vZGVsUHJvdG99IE1vZGVsUHJvdG9cbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcbiAgICAgICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICAgICAqL1xuICAgICAgICBNb2RlbFByb3RvLmRlY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZChyZWFkZXIpIHtcbiAgICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgICAgIHJlYWRlciA9IG5ldyAkUmVhZGVyKHJlYWRlcik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBWZXJpZmllcyBhIE1vZGVsUHJvdG8gbWVzc2FnZS5cbiAgICAgICAgICogQGZ1bmN0aW9uIHZlcmlmeVxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5Nb2RlbFByb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gbWVzc2FnZSBQbGFpbiBvYmplY3QgdG8gdmVyaWZ5XG4gICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd8bnVsbH0gYG51bGxgIGlmIHZhbGlkLCBvdGhlcndpc2UgdGhlIHJlYXNvbiB3aHkgaXQgaXMgbm90XG4gICAgICAgICAqL1xuICAgICAgICBNb2RlbFByb3RvLnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtZXNzYWdlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgIT09IFwib2JqZWN0XCIgfHwgbWVzc2FnZSA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJvYmplY3QgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmlyVmVyc2lvbiAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJpclZlcnNpb25cIikpXG4gICAgICAgICAgICAgICAgaWYgKCEkdXRpbC5pc0ludGVnZXIobWVzc2FnZS5pclZlcnNpb24pICYmICEobWVzc2FnZS5pclZlcnNpb24gJiYgJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UuaXJWZXJzaW9uLmxvdykgJiYgJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UuaXJWZXJzaW9uLmhpZ2gpKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiaXJWZXJzaW9uOiBpbnRlZ2VyfExvbmcgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm9wc2V0SW1wb3J0ICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIm9wc2V0SW1wb3J0XCIpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG1lc3NhZ2Uub3BzZXRJbXBvcnQpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJvcHNldEltcG9ydDogYXJyYXkgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2Uub3BzZXRJbXBvcnQubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVycm9yID0gJHJvb3Qub25ueC5PcGVyYXRvclNldElkUHJvdG8udmVyaWZ5KG1lc3NhZ2Uub3BzZXRJbXBvcnRbaV0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJvcHNldEltcG9ydC5cIiArIGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnByb2R1Y2VyTmFtZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJwcm9kdWNlck5hbWVcIikpXG4gICAgICAgICAgICAgICAgaWYgKCEkdXRpbC5pc1N0cmluZyhtZXNzYWdlLnByb2R1Y2VyTmFtZSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcInByb2R1Y2VyTmFtZTogc3RyaW5nIGV4cGVjdGVkXCI7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5wcm9kdWNlclZlcnNpb24gIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwicHJvZHVjZXJWZXJzaW9uXCIpKVxuICAgICAgICAgICAgICAgIGlmICghJHV0aWwuaXNTdHJpbmcobWVzc2FnZS5wcm9kdWNlclZlcnNpb24pKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJwcm9kdWNlclZlcnNpb246IHN0cmluZyBleHBlY3RlZFwiO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZG9tYWluICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImRvbWFpblwiKSlcbiAgICAgICAgICAgICAgICBpZiAoISR1dGlsLmlzU3RyaW5nKG1lc3NhZ2UuZG9tYWluKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiZG9tYWluOiBzdHJpbmcgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm1vZGVsVmVyc2lvbiAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJtb2RlbFZlcnNpb25cIikpXG4gICAgICAgICAgICAgICAgaWYgKCEkdXRpbC5pc0ludGVnZXIobWVzc2FnZS5tb2RlbFZlcnNpb24pICYmICEobWVzc2FnZS5tb2RlbFZlcnNpb24gJiYgJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UubW9kZWxWZXJzaW9uLmxvdykgJiYgJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UubW9kZWxWZXJzaW9uLmhpZ2gpKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwibW9kZWxWZXJzaW9uOiBpbnRlZ2VyfExvbmcgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmRvY1N0cmluZyAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJkb2NTdHJpbmdcIikpXG4gICAgICAgICAgICAgICAgaWYgKCEkdXRpbC5pc1N0cmluZyhtZXNzYWdlLmRvY1N0cmluZykpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImRvY1N0cmluZzogc3RyaW5nIGV4cGVjdGVkXCI7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5ncmFwaCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJncmFwaFwiKSkge1xuICAgICAgICAgICAgICAgIHZhciBlcnJvciA9ICRyb290Lm9ubnguR3JhcGhQcm90by52ZXJpZnkobWVzc2FnZS5ncmFwaCk7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJncmFwaC5cIiArIGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UubWV0YWRhdGFQcm9wcyAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJtZXRhZGF0YVByb3BzXCIpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG1lc3NhZ2UubWV0YWRhdGFQcm9wcykpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIm1ldGFkYXRhUHJvcHM6IGFycmF5IGV4cGVjdGVkXCI7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLm1ldGFkYXRhUHJvcHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVycm9yID0gJHJvb3Qub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvLnZlcmlmeShtZXNzYWdlLm1ldGFkYXRhUHJvcHNbaV0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJtZXRhZGF0YVByb3BzLlwiICsgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UudHJhaW5pbmdJbmZvICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInRyYWluaW5nSW5mb1wiKSkge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShtZXNzYWdlLnRyYWluaW5nSW5mbykpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcInRyYWluaW5nSW5mbzogYXJyYXkgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UudHJhaW5pbmdJbmZvLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlcnJvciA9ICRyb290Lm9ubnguVHJhaW5pbmdJbmZvUHJvdG8udmVyaWZ5KG1lc3NhZ2UudHJhaW5pbmdJbmZvW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwidHJhaW5pbmdJbmZvLlwiICsgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZnVuY3Rpb25zICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImZ1bmN0aW9uc1wiKSkge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShtZXNzYWdlLmZ1bmN0aW9ucykpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImZ1bmN0aW9uczogYXJyYXkgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UuZnVuY3Rpb25zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlcnJvciA9ICRyb290Lm9ubnguRnVuY3Rpb25Qcm90by52ZXJpZnkobWVzc2FnZS5mdW5jdGlvbnNbaV0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJmdW5jdGlvbnMuXCIgKyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIE1vZGVsUHJvdG8gbWVzc2FnZSBmcm9tIGEgcGxhaW4gb2JqZWN0LiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byB0aGVpciByZXNwZWN0aXZlIGludGVybmFsIHR5cGVzLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZnJvbU9iamVjdFxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5Nb2RlbFByb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gb2JqZWN0IFBsYWluIG9iamVjdFxuICAgICAgICAgKiBAcmV0dXJucyB7b25ueC5Nb2RlbFByb3RvfSBNb2RlbFByb3RvXG4gICAgICAgICAqL1xuICAgICAgICBNb2RlbFByb3RvLmZyb21PYmplY3QgPSBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mICRyb290Lm9ubnguTW9kZWxQcm90bylcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBuZXcgJHJvb3Qub25ueC5Nb2RlbFByb3RvKCk7XG4gICAgICAgICAgICBpZiAob2JqZWN0LmlyVmVyc2lvbiAhPSBudWxsKVxuICAgICAgICAgICAgICAgIGlmICgkdXRpbC5Mb25nKVxuICAgICAgICAgICAgICAgICAgICAobWVzc2FnZS5pclZlcnNpb24gPSAkdXRpbC5Mb25nLmZyb21WYWx1ZShvYmplY3QuaXJWZXJzaW9uKSkudW5zaWduZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LmlyVmVyc2lvbiA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pclZlcnNpb24gPSBwYXJzZUludChvYmplY3QuaXJWZXJzaW9uLCAxMCk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC5pclZlcnNpb24gPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaXJWZXJzaW9uID0gb2JqZWN0LmlyVmVyc2lvbjtcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LmlyVmVyc2lvbiA9PT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pclZlcnNpb24gPSBuZXcgJHV0aWwuTG9uZ0JpdHMob2JqZWN0LmlyVmVyc2lvbi5sb3cgPj4+IDAsIG9iamVjdC5pclZlcnNpb24uaGlnaCA+Pj4gMCkudG9OdW1iZXIoKTtcbiAgICAgICAgICAgIGlmIChvYmplY3Qub3BzZXRJbXBvcnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqZWN0Lm9wc2V0SW1wb3J0KSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguTW9kZWxQcm90by5vcHNldEltcG9ydDogYXJyYXkgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5vcHNldEltcG9ydCA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0Lm9wc2V0SW1wb3J0Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0Lm9wc2V0SW1wb3J0W2ldICE9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguTW9kZWxQcm90by5vcHNldEltcG9ydDogb2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm9wc2V0SW1wb3J0W2ldID0gJHJvb3Qub25ueC5PcGVyYXRvclNldElkUHJvdG8uZnJvbU9iamVjdChvYmplY3Qub3BzZXRJbXBvcnRbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvYmplY3QucHJvZHVjZXJOYW1lICE9IG51bGwpXG4gICAgICAgICAgICAgICAgbWVzc2FnZS5wcm9kdWNlck5hbWUgPSBTdHJpbmcob2JqZWN0LnByb2R1Y2VyTmFtZSk7XG4gICAgICAgICAgICBpZiAob2JqZWN0LnByb2R1Y2VyVmVyc2lvbiAhPSBudWxsKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UucHJvZHVjZXJWZXJzaW9uID0gU3RyaW5nKG9iamVjdC5wcm9kdWNlclZlcnNpb24pO1xuICAgICAgICAgICAgaWYgKG9iamVjdC5kb21haW4gIT0gbnVsbClcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmRvbWFpbiA9IFN0cmluZyhvYmplY3QuZG9tYWluKTtcbiAgICAgICAgICAgIGlmIChvYmplY3QubW9kZWxWZXJzaW9uICE9IG51bGwpXG4gICAgICAgICAgICAgICAgaWYgKCR1dGlsLkxvbmcpXG4gICAgICAgICAgICAgICAgICAgIChtZXNzYWdlLm1vZGVsVmVyc2lvbiA9ICR1dGlsLkxvbmcuZnJvbVZhbHVlKG9iamVjdC5tb2RlbFZlcnNpb24pKS51bnNpZ25lZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QubW9kZWxWZXJzaW9uID09PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm1vZGVsVmVyc2lvbiA9IHBhcnNlSW50KG9iamVjdC5tb2RlbFZlcnNpb24sIDEwKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0Lm1vZGVsVmVyc2lvbiA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5tb2RlbFZlcnNpb24gPSBvYmplY3QubW9kZWxWZXJzaW9uO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QubW9kZWxWZXJzaW9uID09PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm1vZGVsVmVyc2lvbiA9IG5ldyAkdXRpbC5Mb25nQml0cyhvYmplY3QubW9kZWxWZXJzaW9uLmxvdyA+Pj4gMCwgb2JqZWN0Lm1vZGVsVmVyc2lvbi5oaWdoID4+PiAwKS50b051bWJlcigpO1xuICAgICAgICAgICAgaWYgKG9iamVjdC5kb2NTdHJpbmcgIT0gbnVsbClcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmRvY1N0cmluZyA9IFN0cmluZyhvYmplY3QuZG9jU3RyaW5nKTtcbiAgICAgICAgICAgIGlmIChvYmplY3QuZ3JhcGggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LmdyYXBoICE9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5Nb2RlbFByb3RvLmdyYXBoOiBvYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5ncmFwaCA9ICRyb290Lm9ubnguR3JhcGhQcm90by5mcm9tT2JqZWN0KG9iamVjdC5ncmFwaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2JqZWN0Lm1ldGFkYXRhUHJvcHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqZWN0Lm1ldGFkYXRhUHJvcHMpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5Nb2RlbFByb3RvLm1ldGFkYXRhUHJvcHM6IGFycmF5IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UubWV0YWRhdGFQcm9wcyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0Lm1ldGFkYXRhUHJvcHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QubWV0YWRhdGFQcm9wc1tpXSAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5vbm54Lk1vZGVsUHJvdG8ubWV0YWRhdGFQcm9wczogb2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm1ldGFkYXRhUHJvcHNbaV0gPSAkcm9vdC5vbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG8uZnJvbU9iamVjdChvYmplY3QubWV0YWRhdGFQcm9wc1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9iamVjdC50cmFpbmluZ0luZm8pIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqZWN0LnRyYWluaW5nSW5mbykpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5vbm54Lk1vZGVsUHJvdG8udHJhaW5pbmdJbmZvOiBhcnJheSBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnRyYWluaW5nSW5mbyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0LnRyYWluaW5nSW5mby5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC50cmFpbmluZ0luZm9baV0gIT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5Nb2RlbFByb3RvLnRyYWluaW5nSW5mbzogb2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnRyYWluaW5nSW5mb1tpXSA9ICRyb290Lm9ubnguVHJhaW5pbmdJbmZvUHJvdG8uZnJvbU9iamVjdChvYmplY3QudHJhaW5pbmdJbmZvW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2JqZWN0LmZ1bmN0aW9ucykge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvYmplY3QuZnVuY3Rpb25zKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguTW9kZWxQcm90by5mdW5jdGlvbnM6IGFycmF5IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UuZnVuY3Rpb25zID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3QuZnVuY3Rpb25zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LmZ1bmN0aW9uc1tpXSAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5vbm54Lk1vZGVsUHJvdG8uZnVuY3Rpb25zOiBvYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZnVuY3Rpb25zW2ldID0gJHJvb3Qub25ueC5GdW5jdGlvblByb3RvLmZyb21PYmplY3Qob2JqZWN0LmZ1bmN0aW9uc1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBwbGFpbiBvYmplY3QgZnJvbSBhIE1vZGVsUHJvdG8gbWVzc2FnZS4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gb3RoZXIgdHlwZXMgaWYgc3BlY2lmaWVkLlxuICAgICAgICAgKiBAZnVuY3Rpb24gdG9PYmplY3RcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguTW9kZWxQcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7b25ueC5Nb2RlbFByb3RvfSBtZXNzYWdlIE1vZGVsUHJvdG9cbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuSUNvbnZlcnNpb25PcHRpb25zfSBbb3B0aW9uc10gQ29udmVyc2lvbiBvcHRpb25zXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gUGxhaW4gb2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICBNb2RlbFByb3RvLnRvT2JqZWN0ID0gZnVuY3Rpb24gdG9PYmplY3QobWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zKVxuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgICAgIHZhciBvYmplY3QgPSB7fTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmFycmF5cyB8fCBvcHRpb25zLmRlZmF1bHRzKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0Lm9wc2V0SW1wb3J0ID0gW107XG4gICAgICAgICAgICAgICAgb2JqZWN0Lm1ldGFkYXRhUHJvcHMgPSBbXTtcbiAgICAgICAgICAgICAgICBvYmplY3QudHJhaW5pbmdJbmZvID0gW107XG4gICAgICAgICAgICAgICAgb2JqZWN0LmZ1bmN0aW9ucyA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGVmYXVsdHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoJHV0aWwuTG9uZykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbG9uZyA9IG5ldyAkdXRpbC5Mb25nKDAsIDAsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LmlyVmVyc2lvbiA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/IGxvbmcudG9TdHJpbmcoKSA6IG9wdGlvbnMubG9uZ3MgPT09IE51bWJlciA/IGxvbmcudG9OdW1iZXIoKSA6IGxvbmc7XG4gICAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5pclZlcnNpb24gPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyBcIjBcIiA6IDA7XG4gICAgICAgICAgICAgICAgb2JqZWN0LnByb2R1Y2VyTmFtZSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgb2JqZWN0LnByb2R1Y2VyVmVyc2lvbiA9IFwiXCI7XG4gICAgICAgICAgICAgICAgb2JqZWN0LmRvbWFpbiA9IFwiXCI7XG4gICAgICAgICAgICAgICAgaWYgKCR1dGlsLkxvbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxvbmcgPSBuZXcgJHV0aWwuTG9uZygwLCAwLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5tb2RlbFZlcnNpb24gPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyBsb25nLnRvU3RyaW5nKCkgOiBvcHRpb25zLmxvbmdzID09PSBOdW1iZXIgPyBsb25nLnRvTnVtYmVyKCkgOiBsb25nO1xuICAgICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgICAgICBvYmplY3QubW9kZWxWZXJzaW9uID0gb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nID8gXCIwXCIgOiAwO1xuICAgICAgICAgICAgICAgIG9iamVjdC5kb2NTdHJpbmcgPSBcIlwiO1xuICAgICAgICAgICAgICAgIG9iamVjdC5ncmFwaCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5pclZlcnNpb24gIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiaXJWZXJzaW9uXCIpKVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZS5pclZlcnNpb24gPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5pclZlcnNpb24gPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyBTdHJpbmcobWVzc2FnZS5pclZlcnNpb24pIDogbWVzc2FnZS5pclZlcnNpb247XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBvYmplY3QuaXJWZXJzaW9uID0gb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nID8gJHV0aWwuTG9uZy5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChtZXNzYWdlLmlyVmVyc2lvbikgOiBvcHRpb25zLmxvbmdzID09PSBOdW1iZXIgPyBuZXcgJHV0aWwuTG9uZ0JpdHMobWVzc2FnZS5pclZlcnNpb24ubG93ID4+PiAwLCBtZXNzYWdlLmlyVmVyc2lvbi5oaWdoID4+PiAwKS50b051bWJlcigpIDogbWVzc2FnZS5pclZlcnNpb247XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5wcm9kdWNlck5hbWUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwicHJvZHVjZXJOYW1lXCIpKVxuICAgICAgICAgICAgICAgIG9iamVjdC5wcm9kdWNlck5hbWUgPSBtZXNzYWdlLnByb2R1Y2VyTmFtZTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnByb2R1Y2VyVmVyc2lvbiAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJwcm9kdWNlclZlcnNpb25cIikpXG4gICAgICAgICAgICAgICAgb2JqZWN0LnByb2R1Y2VyVmVyc2lvbiA9IG1lc3NhZ2UucHJvZHVjZXJWZXJzaW9uO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZG9tYWluICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImRvbWFpblwiKSlcbiAgICAgICAgICAgICAgICBvYmplY3QuZG9tYWluID0gbWVzc2FnZS5kb21haW47XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5tb2RlbFZlcnNpb24gIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwibW9kZWxWZXJzaW9uXCIpKVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZS5tb2RlbFZlcnNpb24gPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5tb2RlbFZlcnNpb24gPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyBTdHJpbmcobWVzc2FnZS5tb2RlbFZlcnNpb24pIDogbWVzc2FnZS5tb2RlbFZlcnNpb247XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBvYmplY3QubW9kZWxWZXJzaW9uID0gb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nID8gJHV0aWwuTG9uZy5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChtZXNzYWdlLm1vZGVsVmVyc2lvbikgOiBvcHRpb25zLmxvbmdzID09PSBOdW1iZXIgPyBuZXcgJHV0aWwuTG9uZ0JpdHMobWVzc2FnZS5tb2RlbFZlcnNpb24ubG93ID4+PiAwLCBtZXNzYWdlLm1vZGVsVmVyc2lvbi5oaWdoID4+PiAwKS50b051bWJlcigpIDogbWVzc2FnZS5tb2RlbFZlcnNpb247XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5kb2NTdHJpbmcgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZG9jU3RyaW5nXCIpKVxuICAgICAgICAgICAgICAgIG9iamVjdC5kb2NTdHJpbmcgPSBtZXNzYWdlLmRvY1N0cmluZztcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmdyYXBoICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImdyYXBoXCIpKVxuICAgICAgICAgICAgICAgIG9iamVjdC5ncmFwaCA9ICRyb290Lm9ubnguR3JhcGhQcm90by50b09iamVjdChtZXNzYWdlLmdyYXBoLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm9wc2V0SW1wb3J0ICYmIG1lc3NhZ2Uub3BzZXRJbXBvcnQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0Lm9wc2V0SW1wb3J0ID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtZXNzYWdlLm9wc2V0SW1wb3J0Lmxlbmd0aDsgKytqKVxuICAgICAgICAgICAgICAgICAgICBvYmplY3Qub3BzZXRJbXBvcnRbal0gPSAkcm9vdC5vbm54Lk9wZXJhdG9yU2V0SWRQcm90by50b09iamVjdChtZXNzYWdlLm9wc2V0SW1wb3J0W2pdLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm1ldGFkYXRhUHJvcHMgJiYgbWVzc2FnZS5tZXRhZGF0YVByb3BzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIG9iamVjdC5tZXRhZGF0YVByb3BzID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtZXNzYWdlLm1ldGFkYXRhUHJvcHMubGVuZ3RoOyArK2opXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5tZXRhZGF0YVByb3BzW2pdID0gJHJvb3Qub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvLnRvT2JqZWN0KG1lc3NhZ2UubWV0YWRhdGFQcm9wc1tqXSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS50cmFpbmluZ0luZm8gJiYgbWVzc2FnZS50cmFpbmluZ0luZm8ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0LnRyYWluaW5nSW5mbyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWVzc2FnZS50cmFpbmluZ0luZm8ubGVuZ3RoOyArK2opXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC50cmFpbmluZ0luZm9bal0gPSAkcm9vdC5vbm54LlRyYWluaW5nSW5mb1Byb3RvLnRvT2JqZWN0KG1lc3NhZ2UudHJhaW5pbmdJbmZvW2pdLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmZ1bmN0aW9ucyAmJiBtZXNzYWdlLmZ1bmN0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBvYmplY3QuZnVuY3Rpb25zID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtZXNzYWdlLmZ1bmN0aW9ucy5sZW5ndGg7ICsrailcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LmZ1bmN0aW9uc1tqXSA9ICRyb290Lm9ubnguRnVuY3Rpb25Qcm90by50b09iamVjdChtZXNzYWdlLmZ1bmN0aW9uc1tqXSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb252ZXJ0cyB0aGlzIE1vZGVsUHJvdG8gdG8gSlNPTi5cbiAgICAgICAgICogQGZ1bmN0aW9uIHRvSlNPTlxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5Nb2RlbFByb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IEpTT04gb2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICBNb2RlbFByb3RvLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLCAkcHJvdG9idWYudXRpbC50b0pTT05PcHRpb25zKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0cyB0aGUgZGVmYXVsdCB0eXBlIHVybCBmb3IgTW9kZWxQcm90b1xuICAgICAgICAgKiBAZnVuY3Rpb24gZ2V0VHlwZVVybFxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5Nb2RlbFByb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFt0eXBlVXJsUHJlZml4XSB5b3VyIGN1c3RvbSB0eXBlVXJsUHJlZml4KGRlZmF1bHQgXCJ0eXBlLmdvb2dsZWFwaXMuY29tXCIpXG4gICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBkZWZhdWx0IHR5cGUgdXJsXG4gICAgICAgICAqL1xuICAgICAgICBNb2RlbFByb3RvLmdldFR5cGVVcmwgPSBmdW5jdGlvbiBnZXRUeXBlVXJsKHR5cGVVcmxQcmVmaXgpIHtcbiAgICAgICAgICAgIGlmICh0eXBlVXJsUHJlZml4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0eXBlVXJsUHJlZml4ID0gXCJ0eXBlLmdvb2dsZWFwaXMuY29tXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHlwZVVybFByZWZpeCArIFwiL29ubnguTW9kZWxQcm90b1wiO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBNb2RlbFByb3RvO1xuICAgIH0pKCk7XG5cbiAgICBvbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG8gPSAoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb3BlcnRpZXMgb2YgYSBTdHJpbmdTdHJpbmdFbnRyeVByb3RvLlxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueFxuICAgICAgICAgKiBAaW50ZXJmYWNlIElTdHJpbmdTdHJpbmdFbnRyeVByb3RvXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfG51bGx9IFtrZXldIFN0cmluZ1N0cmluZ0VudHJ5UHJvdG8ga2V5XG4gICAgICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfG51bGx9IFt2YWx1ZV0gU3RyaW5nU3RyaW5nRW50cnlQcm90byB2YWx1ZVxuICAgICAgICAgKi9cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29uc3RydWN0cyBhIG5ldyBTdHJpbmdTdHJpbmdFbnRyeVByb3RvLlxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueFxuICAgICAgICAgKiBAY2xhc3NkZXNjIFJlcHJlc2VudHMgYSBTdHJpbmdTdHJpbmdFbnRyeVByb3RvLlxuICAgICAgICAgKiBAaW1wbGVtZW50cyBJU3RyaW5nU3RyaW5nRW50cnlQcm90b1xuICAgICAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgICAgICogQHBhcmFtIHtvbm54LklTdHJpbmdTdHJpbmdFbnRyeVByb3RvPX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBTdHJpbmdTdHJpbmdFbnRyeVByb3RvKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzKVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKSwgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllc1trZXlzW2ldXSAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1trZXlzW2ldXSA9IHByb3BlcnRpZXNba2V5c1tpXV07XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogU3RyaW5nU3RyaW5nRW50cnlQcm90byBrZXkuXG4gICAgICAgICAqIEBtZW1iZXIge3N0cmluZ30ga2V5XG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBTdHJpbmdTdHJpbmdFbnRyeVByb3RvLnByb3RvdHlwZS5rZXkgPSBcIlwiO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdHJpbmdTdHJpbmdFbnRyeVByb3RvIHZhbHVlLlxuICAgICAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IHZhbHVlXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBTdHJpbmdTdHJpbmdFbnRyeVByb3RvLnByb3RvdHlwZS52YWx1ZSA9IFwiXCI7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBuZXcgU3RyaW5nU3RyaW5nRW50cnlQcm90byBpbnN0YW5jZSB1c2luZyB0aGUgc3BlY2lmaWVkIHByb3BlcnRpZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBjcmVhdGVcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7b25ueC5JU3RyaW5nU3RyaW5nRW50cnlQcm90bz19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxuICAgICAgICAgKiBAcmV0dXJucyB7b25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvfSBTdHJpbmdTdHJpbmdFbnRyeVByb3RvIGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBTdHJpbmdTdHJpbmdFbnRyeVByb3RvLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFN0cmluZ1N0cmluZ0VudHJ5UHJvdG8ocHJvcGVydGllcyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBTdHJpbmdTdHJpbmdFbnRyeVByb3RvIG1lc3NhZ2UuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIG9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90by52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGVuY29kZVxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtvbm54LklTdHJpbmdTdHJpbmdFbnRyeVByb3RvfSBtZXNzYWdlIFN0cmluZ1N0cmluZ0VudHJ5UHJvdG8gbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLldyaXRlcn0gW3dyaXRlcl0gV3JpdGVyIHRvIGVuY29kZSB0b1xuICAgICAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXG4gICAgICAgICAqL1xuICAgICAgICBTdHJpbmdTdHJpbmdFbnRyeVByb3RvLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICAgIGlmICghd3JpdGVyKVxuICAgICAgICAgICAgICAgIHdyaXRlciA9ICRXcml0ZXIuY3JlYXRlKCk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5rZXkgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcImtleVwiKSlcbiAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDEsIHdpcmVUeXBlIDIgPSovMTApLnN0cmluZyhtZXNzYWdlLmtleSk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS52YWx1ZSAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwidmFsdWVcIikpXG4gICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCAyLCB3aXJlVHlwZSAyID0qLzE4KS5zdHJpbmcobWVzc2FnZS52YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgU3RyaW5nU3RyaW5nRW50cnlQcm90byBtZXNzYWdlLCBsZW5ndGggZGVsaW1pdGVkLiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayBvbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG8udmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWRcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7b25ueC5JU3RyaW5nU3RyaW5nRW50cnlQcm90b30gbWVzc2FnZSBTdHJpbmdTdHJpbmdFbnRyeVByb3RvIG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0IHRvIGVuY29kZVxuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAgICAgICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAgICAgKi9cbiAgICAgICAgU3RyaW5nU3RyaW5nRW50cnlQcm90by5lbmNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWQobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGUobWVzc2FnZSwgd3JpdGVyKS5sZGVsaW0oKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGVjb2RlcyBhIFN0cmluZ1N0cmluZ0VudHJ5UHJvdG8gbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyIG9yIGJ1ZmZlci5cbiAgICAgICAgICogQGZ1bmN0aW9uIGRlY29kZVxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoXSBNZXNzYWdlIGxlbmd0aCBpZiBrbm93biBiZWZvcmVoYW5kXG4gICAgICAgICAqIEByZXR1cm5zIHtvbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG99IFN0cmluZ1N0cmluZ0VudHJ5UHJvdG9cbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcbiAgICAgICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICAgICAqL1xuICAgICAgICBTdHJpbmdTdHJpbmdFbnRyeVByb3RvLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyZWFkZXIsIGxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgICAgcmVhZGVyID0gJFJlYWRlci5jcmVhdGUocmVhZGVyKTtcbiAgICAgICAgICAgIHZhciBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoLCBtZXNzYWdlID0gbmV3ICRyb290Lm9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90bygpO1xuICAgICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmtleSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAyOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnZhbHVlID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWNvZGVzIGEgU3RyaW5nU3RyaW5nRW50cnlQcm90byBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLCBsZW5ndGggZGVsaW1pdGVkLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgICAgICogQHJldHVybnMge29ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90b30gU3RyaW5nU3RyaW5nRW50cnlQcm90b1xuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcbiAgICAgICAgICovXG4gICAgICAgIFN0cmluZ1N0cmluZ0VudHJ5UHJvdG8uZGVjb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkKHJlYWRlcikge1xuICAgICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgICAgcmVhZGVyID0gbmV3ICRSZWFkZXIocmVhZGVyKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFZlcmlmaWVzIGEgU3RyaW5nU3RyaW5nRW50cnlQcm90byBtZXNzYWdlLlxuICAgICAgICAgKiBAZnVuY3Rpb24gdmVyaWZ5XG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBtZXNzYWdlIFBsYWluIG9iamVjdCB0byB2ZXJpZnlcbiAgICAgICAgICogQHJldHVybnMge3N0cmluZ3xudWxsfSBgbnVsbGAgaWYgdmFsaWQsIG90aGVyd2lzZSB0aGUgcmVhc29uIHdoeSBpdCBpcyBub3RcbiAgICAgICAgICovXG4gICAgICAgIFN0cmluZ1N0cmluZ0VudHJ5UHJvdG8udmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5KG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSAhPT0gXCJvYmplY3RcIiB8fCBtZXNzYWdlID09PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiBcIm9iamVjdCBleHBlY3RlZFwiO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2Uua2V5ICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImtleVwiKSlcbiAgICAgICAgICAgICAgICBpZiAoISR1dGlsLmlzU3RyaW5nKG1lc3NhZ2Uua2V5KSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwia2V5OiBzdHJpbmcgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnZhbHVlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInZhbHVlXCIpKVxuICAgICAgICAgICAgICAgIGlmICghJHV0aWwuaXNTdHJpbmcobWVzc2FnZS52YWx1ZSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcInZhbHVlOiBzdHJpbmcgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgU3RyaW5nU3RyaW5nRW50cnlQcm90byBtZXNzYWdlIGZyb20gYSBwbGFpbiBvYmplY3QuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIHRoZWlyIHJlc3BlY3RpdmUgaW50ZXJuYWwgdHlwZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBmcm9tT2JqZWN0XG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBvYmplY3QgUGxhaW4gb2JqZWN0XG4gICAgICAgICAqIEByZXR1cm5zIHtvbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG99IFN0cmluZ1N0cmluZ0VudHJ5UHJvdG9cbiAgICAgICAgICovXG4gICAgICAgIFN0cmluZ1N0cmluZ0VudHJ5UHJvdG8uZnJvbU9iamVjdCA9IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgJHJvb3Qub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvKVxuICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgICAgICB2YXIgbWVzc2FnZSA9IG5ldyAkcm9vdC5vbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG8oKTtcbiAgICAgICAgICAgIGlmIChvYmplY3Qua2V5ICE9IG51bGwpXG4gICAgICAgICAgICAgICAgbWVzc2FnZS5rZXkgPSBTdHJpbmcob2JqZWN0LmtleSk7XG4gICAgICAgICAgICBpZiAob2JqZWN0LnZhbHVlICE9IG51bGwpXG4gICAgICAgICAgICAgICAgbWVzc2FnZS52YWx1ZSA9IFN0cmluZyhvYmplY3QudmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBwbGFpbiBvYmplY3QgZnJvbSBhIFN0cmluZ1N0cmluZ0VudHJ5UHJvdG8gbWVzc2FnZS4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gb3RoZXIgdHlwZXMgaWYgc3BlY2lmaWVkLlxuICAgICAgICAgKiBAZnVuY3Rpb24gdG9PYmplY3RcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7b25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvfSBtZXNzYWdlIFN0cmluZ1N0cmluZ0VudHJ5UHJvdG9cbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuSUNvbnZlcnNpb25PcHRpb25zfSBbb3B0aW9uc10gQ29udmVyc2lvbiBvcHRpb25zXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gUGxhaW4gb2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICBTdHJpbmdTdHJpbmdFbnRyeVByb3RvLnRvT2JqZWN0ID0gZnVuY3Rpb24gdG9PYmplY3QobWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zKVxuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgICAgIHZhciBvYmplY3QgPSB7fTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmRlZmF1bHRzKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0LmtleSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgb2JqZWN0LnZhbHVlID0gXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmtleSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJrZXlcIikpXG4gICAgICAgICAgICAgICAgb2JqZWN0LmtleSA9IG1lc3NhZ2Uua2V5O1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UudmFsdWUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwidmFsdWVcIikpXG4gICAgICAgICAgICAgICAgb2JqZWN0LnZhbHVlID0gbWVzc2FnZS52YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlcnRzIHRoaXMgU3RyaW5nU3RyaW5nRW50cnlQcm90byB0byBKU09OLlxuICAgICAgICAgKiBAZnVuY3Rpb24gdG9KU09OXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gSlNPTiBvYmplY3RcbiAgICAgICAgICovXG4gICAgICAgIFN0cmluZ1N0cmluZ0VudHJ5UHJvdG8ucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsICRwcm90b2J1Zi51dGlsLnRvSlNPTk9wdGlvbnMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIHRoZSBkZWZhdWx0IHR5cGUgdXJsIGZvciBTdHJpbmdTdHJpbmdFbnRyeVByb3RvXG4gICAgICAgICAqIEBmdW5jdGlvbiBnZXRUeXBlVXJsXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3R5cGVVcmxQcmVmaXhdIHlvdXIgY3VzdG9tIHR5cGVVcmxQcmVmaXgoZGVmYXVsdCBcInR5cGUuZ29vZ2xlYXBpcy5jb21cIilcbiAgICAgICAgICogQHJldHVybnMge3N0cmluZ30gVGhlIGRlZmF1bHQgdHlwZSB1cmxcbiAgICAgICAgICovXG4gICAgICAgIFN0cmluZ1N0cmluZ0VudHJ5UHJvdG8uZ2V0VHlwZVVybCA9IGZ1bmN0aW9uIGdldFR5cGVVcmwodHlwZVVybFByZWZpeCkge1xuICAgICAgICAgICAgaWYgKHR5cGVVcmxQcmVmaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHR5cGVVcmxQcmVmaXggPSBcInR5cGUuZ29vZ2xlYXBpcy5jb21cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0eXBlVXJsUHJlZml4ICsgXCIvb25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvXCI7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIFN0cmluZ1N0cmluZ0VudHJ5UHJvdG87XG4gICAgfSkoKTtcblxuICAgIG9ubnguVGVuc29yQW5ub3RhdGlvbiA9IChmdW5jdGlvbigpIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUHJvcGVydGllcyBvZiBhIFRlbnNvckFubm90YXRpb24uXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54XG4gICAgICAgICAqIEBpbnRlcmZhY2UgSVRlbnNvckFubm90YXRpb25cbiAgICAgICAgICogQHByb3BlcnR5IHtzdHJpbmd8bnVsbH0gW3RlbnNvck5hbWVdIFRlbnNvckFubm90YXRpb24gdGVuc29yTmFtZVxuICAgICAgICAgKiBAcHJvcGVydHkge0FycmF5Ljxvbm54LklTdHJpbmdTdHJpbmdFbnRyeVByb3RvPnxudWxsfSBbcXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lc10gVGVuc29yQW5ub3RhdGlvbiBxdWFudFBhcmFtZXRlclRlbnNvck5hbWVzXG4gICAgICAgICAqL1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IFRlbnNvckFubm90YXRpb24uXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54XG4gICAgICAgICAqIEBjbGFzc2Rlc2MgUmVwcmVzZW50cyBhIFRlbnNvckFubm90YXRpb24uXG4gICAgICAgICAqIEBpbXBsZW1lbnRzIElUZW5zb3JBbm5vdGF0aW9uXG4gICAgICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAgICAgKiBAcGFyYW0ge29ubnguSVRlbnNvckFubm90YXRpb249fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIFRlbnNvckFubm90YXRpb24ocHJvcGVydGllcykge1xuICAgICAgICAgICAgdGhpcy5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzID0gW107XG4gICAgICAgICAgICBpZiAocHJvcGVydGllcylcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvcGVydGllcyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXNba2V5c1tpXV0gIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNba2V5c1tpXV0gPSBwcm9wZXJ0aWVzW2tleXNbaV1dO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRlbnNvckFubm90YXRpb24gdGVuc29yTmFtZS5cbiAgICAgICAgICogQG1lbWJlciB7c3RyaW5nfSB0ZW5zb3JOYW1lXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvckFubm90YXRpb25cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBUZW5zb3JBbm5vdGF0aW9uLnByb3RvdHlwZS50ZW5zb3JOYW1lID0gXCJcIjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGVuc29yQW5ub3RhdGlvbiBxdWFudFBhcmFtZXRlclRlbnNvck5hbWVzLlxuICAgICAgICAgKiBAbWVtYmVyIHtBcnJheS48b25ueC5JU3RyaW5nU3RyaW5nRW50cnlQcm90bz59IHF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXNcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yQW5ub3RhdGlvblxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIFRlbnNvckFubm90YXRpb24ucHJvdG90eXBlLnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXMgPSAkdXRpbC5lbXB0eUFycmF5O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgbmV3IFRlbnNvckFubm90YXRpb24gaW5zdGFuY2UgdXNpbmcgdGhlIHNwZWNpZmllZCBwcm9wZXJ0aWVzLlxuICAgICAgICAgKiBAZnVuY3Rpb24gY3JlYXRlXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvckFubm90YXRpb25cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge29ubnguSVRlbnNvckFubm90YXRpb249fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAgICAgICAgICogQHJldHVybnMge29ubnguVGVuc29yQW5ub3RhdGlvbn0gVGVuc29yQW5ub3RhdGlvbiBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgVGVuc29yQW5ub3RhdGlvbi5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUocHJvcGVydGllcykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBUZW5zb3JBbm5vdGF0aW9uKHByb3BlcnRpZXMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgVGVuc29yQW5ub3RhdGlvbiBtZXNzYWdlLiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayBvbm54LlRlbnNvckFubm90YXRpb24udmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBlbmNvZGVcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yQW5ub3RhdGlvblxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7b25ueC5JVGVuc29yQW5ub3RhdGlvbn0gbWVzc2FnZSBUZW5zb3JBbm5vdGF0aW9uIG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0IHRvIGVuY29kZVxuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAgICAgICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAgICAgKi9cbiAgICAgICAgVGVuc29yQW5ub3RhdGlvbi5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgICBpZiAoIXdyaXRlcilcbiAgICAgICAgICAgICAgICB3cml0ZXIgPSAkV3JpdGVyLmNyZWF0ZSgpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UudGVuc29yTmFtZSAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwidGVuc29yTmFtZVwiKSlcbiAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDEsIHdpcmVUeXBlIDIgPSovMTApLnN0cmluZyhtZXNzYWdlLnRlbnNvck5hbWUpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lcyAhPSBudWxsICYmIG1lc3NhZ2UucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lcy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgICRyb290Lm9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90by5lbmNvZGUobWVzc2FnZS5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzW2ldLCB3cml0ZXIudWludDMyKC8qIGlkIDIsIHdpcmVUeXBlIDIgPSovMTgpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgVGVuc29yQW5ub3RhdGlvbiBtZXNzYWdlLCBsZW5ndGggZGVsaW1pdGVkLiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayBvbm54LlRlbnNvckFubm90YXRpb24udmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWRcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yQW5ub3RhdGlvblxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7b25ueC5JVGVuc29yQW5ub3RhdGlvbn0gbWVzc2FnZSBUZW5zb3JBbm5vdGF0aW9uIG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0IHRvIGVuY29kZVxuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAgICAgICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAgICAgKi9cbiAgICAgICAgVGVuc29yQW5ub3RhdGlvbi5lbmNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWQobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGUobWVzc2FnZSwgd3JpdGVyKS5sZGVsaW0oKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGVjb2RlcyBhIFRlbnNvckFubm90YXRpb24gbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyIG9yIGJ1ZmZlci5cbiAgICAgICAgICogQGZ1bmN0aW9uIGRlY29kZVxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JBbm5vdGF0aW9uXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoXSBNZXNzYWdlIGxlbmd0aCBpZiBrbm93biBiZWZvcmVoYW5kXG4gICAgICAgICAqIEByZXR1cm5zIHtvbm54LlRlbnNvckFubm90YXRpb259IFRlbnNvckFubm90YXRpb25cbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcbiAgICAgICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICAgICAqL1xuICAgICAgICBUZW5zb3JBbm5vdGF0aW9uLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyZWFkZXIsIGxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgICAgcmVhZGVyID0gJFJlYWRlci5jcmVhdGUocmVhZGVyKTtcbiAgICAgICAgICAgIHZhciBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoLCBtZXNzYWdlID0gbmV3ICRyb290Lm9ubnguVGVuc29yQW5ub3RhdGlvbigpO1xuICAgICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnRlbnNvck5hbWUgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgMjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEobWVzc2FnZS5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzICYmIG1lc3NhZ2UucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lcy5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzLnB1c2goJHJvb3Qub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWNvZGVzIGEgVGVuc29yQW5ub3RhdGlvbiBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLCBsZW5ndGggZGVsaW1pdGVkLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvckFubm90YXRpb25cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgICAgICogQHJldHVybnMge29ubnguVGVuc29yQW5ub3RhdGlvbn0gVGVuc29yQW5ub3RhdGlvblxuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcbiAgICAgICAgICovXG4gICAgICAgIFRlbnNvckFubm90YXRpb24uZGVjb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkKHJlYWRlcikge1xuICAgICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgICAgcmVhZGVyID0gbmV3ICRSZWFkZXIocmVhZGVyKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFZlcmlmaWVzIGEgVGVuc29yQW5ub3RhdGlvbiBtZXNzYWdlLlxuICAgICAgICAgKiBAZnVuY3Rpb24gdmVyaWZ5XG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvckFubm90YXRpb25cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBtZXNzYWdlIFBsYWluIG9iamVjdCB0byB2ZXJpZnlcbiAgICAgICAgICogQHJldHVybnMge3N0cmluZ3xudWxsfSBgbnVsbGAgaWYgdmFsaWQsIG90aGVyd2lzZSB0aGUgcmVhc29uIHdoeSBpdCBpcyBub3RcbiAgICAgICAgICovXG4gICAgICAgIFRlbnNvckFubm90YXRpb24udmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5KG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSAhPT0gXCJvYmplY3RcIiB8fCBtZXNzYWdlID09PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiBcIm9iamVjdCBleHBlY3RlZFwiO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UudGVuc29yTmFtZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJ0ZW5zb3JOYW1lXCIpKVxuICAgICAgICAgICAgICAgIGlmICghJHV0aWwuaXNTdHJpbmcobWVzc2FnZS50ZW5zb3JOYW1lKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwidGVuc29yTmFtZTogc3RyaW5nIGV4cGVjdGVkXCI7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXNcIikpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobWVzc2FnZS5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwicXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lczogYXJyYXkgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXJyb3IgPSAkcm9vdC5vbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG8udmVyaWZ5KG1lc3NhZ2UucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcInF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXMuXCIgKyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIFRlbnNvckFubm90YXRpb24gbWVzc2FnZSBmcm9tIGEgcGxhaW4gb2JqZWN0LiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byB0aGVpciByZXNwZWN0aXZlIGludGVybmFsIHR5cGVzLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZnJvbU9iamVjdFxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JBbm5vdGF0aW9uXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gb2JqZWN0IFBsYWluIG9iamVjdFxuICAgICAgICAgKiBAcmV0dXJucyB7b25ueC5UZW5zb3JBbm5vdGF0aW9ufSBUZW5zb3JBbm5vdGF0aW9uXG4gICAgICAgICAqL1xuICAgICAgICBUZW5zb3JBbm5vdGF0aW9uLmZyb21PYmplY3QgPSBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mICRyb290Lm9ubnguVGVuc29yQW5ub3RhdGlvbilcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBuZXcgJHJvb3Qub25ueC5UZW5zb3JBbm5vdGF0aW9uKCk7XG4gICAgICAgICAgICBpZiAob2JqZWN0LnRlbnNvck5hbWUgIT0gbnVsbClcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnRlbnNvck5hbWUgPSBTdHJpbmcob2JqZWN0LnRlbnNvck5hbWUpO1xuICAgICAgICAgICAgaWYgKG9iamVjdC5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9iamVjdC5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguVGVuc29yQW5ub3RhdGlvbi5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzOiBhcnJheSBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdC5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXNbaV0gIT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5UZW5zb3JBbm5vdGF0aW9uLnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXM6IG9iamVjdCBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzW2ldID0gJHJvb3Qub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvLmZyb21PYmplY3Qob2JqZWN0LnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXNbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgcGxhaW4gb2JqZWN0IGZyb20gYSBUZW5zb3JBbm5vdGF0aW9uIG1lc3NhZ2UuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIG90aGVyIHR5cGVzIGlmIHNwZWNpZmllZC5cbiAgICAgICAgICogQGZ1bmN0aW9uIHRvT2JqZWN0XG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvckFubm90YXRpb25cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge29ubnguVGVuc29yQW5ub3RhdGlvbn0gbWVzc2FnZSBUZW5zb3JBbm5vdGF0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLklDb252ZXJzaW9uT3B0aW9uc30gW29wdGlvbnNdIENvbnZlcnNpb24gb3B0aW9uc1xuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IFBsYWluIG9iamVjdFxuICAgICAgICAgKi9cbiAgICAgICAgVGVuc29yQW5ub3RhdGlvbi50b09iamVjdCA9IGZ1bmN0aW9uIHRvT2JqZWN0KG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucylcbiAgICAgICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgICAgICB2YXIgb2JqZWN0ID0ge307XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5hcnJheXMgfHwgb3B0aW9ucy5kZWZhdWx0cylcbiAgICAgICAgICAgICAgICBvYmplY3QucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lcyA9IFtdO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGVmYXVsdHMpXG4gICAgICAgICAgICAgICAgb2JqZWN0LnRlbnNvck5hbWUgPSBcIlwiO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UudGVuc29yTmFtZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJ0ZW5zb3JOYW1lXCIpKVxuICAgICAgICAgICAgICAgIG9iamVjdC50ZW5zb3JOYW1lID0gbWVzc2FnZS50ZW5zb3JOYW1lO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lcyAmJiBtZXNzYWdlLnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0LnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1lc3NhZ2UucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lcy5sZW5ndGg7ICsrailcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXNbal0gPSAkcm9vdC5vbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG8udG9PYmplY3QobWVzc2FnZS5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzW2pdLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlcnRzIHRoaXMgVGVuc29yQW5ub3RhdGlvbiB0byBKU09OLlxuICAgICAgICAgKiBAZnVuY3Rpb24gdG9KU09OXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvckFubm90YXRpb25cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gSlNPTiBvYmplY3RcbiAgICAgICAgICovXG4gICAgICAgIFRlbnNvckFubm90YXRpb24ucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsICRwcm90b2J1Zi51dGlsLnRvSlNPTk9wdGlvbnMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIHRoZSBkZWZhdWx0IHR5cGUgdXJsIGZvciBUZW5zb3JBbm5vdGF0aW9uXG4gICAgICAgICAqIEBmdW5jdGlvbiBnZXRUeXBlVXJsXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvckFubm90YXRpb25cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3R5cGVVcmxQcmVmaXhdIHlvdXIgY3VzdG9tIHR5cGVVcmxQcmVmaXgoZGVmYXVsdCBcInR5cGUuZ29vZ2xlYXBpcy5jb21cIilcbiAgICAgICAgICogQHJldHVybnMge3N0cmluZ30gVGhlIGRlZmF1bHQgdHlwZSB1cmxcbiAgICAgICAgICovXG4gICAgICAgIFRlbnNvckFubm90YXRpb24uZ2V0VHlwZVVybCA9IGZ1bmN0aW9uIGdldFR5cGVVcmwodHlwZVVybFByZWZpeCkge1xuICAgICAgICAgICAgaWYgKHR5cGVVcmxQcmVmaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHR5cGVVcmxQcmVmaXggPSBcInR5cGUuZ29vZ2xlYXBpcy5jb21cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0eXBlVXJsUHJlZml4ICsgXCIvb25ueC5UZW5zb3JBbm5vdGF0aW9uXCI7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIFRlbnNvckFubm90YXRpb247XG4gICAgfSkoKTtcblxuICAgIG9ubnguR3JhcGhQcm90byA9IChmdW5jdGlvbigpIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUHJvcGVydGllcyBvZiBhIEdyYXBoUHJvdG8uXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54XG4gICAgICAgICAqIEBpbnRlcmZhY2UgSUdyYXBoUHJvdG9cbiAgICAgICAgICogQHByb3BlcnR5IHtBcnJheS48b25ueC5JTm9kZVByb3RvPnxudWxsfSBbbm9kZV0gR3JhcGhQcm90byBub2RlXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfG51bGx9IFtuYW1lXSBHcmFwaFByb3RvIG5hbWVcbiAgICAgICAgICogQHByb3BlcnR5IHtBcnJheS48b25ueC5JVGVuc29yUHJvdG8+fG51bGx9IFtpbml0aWFsaXplcl0gR3JhcGhQcm90byBpbml0aWFsaXplclxuICAgICAgICAgKiBAcHJvcGVydHkge0FycmF5Ljxvbm54LklTcGFyc2VUZW5zb3JQcm90bz58bnVsbH0gW3NwYXJzZUluaXRpYWxpemVyXSBHcmFwaFByb3RvIHNwYXJzZUluaXRpYWxpemVyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfG51bGx9IFtkb2NTdHJpbmddIEdyYXBoUHJvdG8gZG9jU3RyaW5nXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7QXJyYXkuPG9ubnguSVZhbHVlSW5mb1Byb3RvPnxudWxsfSBbaW5wdXRdIEdyYXBoUHJvdG8gaW5wdXRcbiAgICAgICAgICogQHByb3BlcnR5IHtBcnJheS48b25ueC5JVmFsdWVJbmZvUHJvdG8+fG51bGx9IFtvdXRwdXRdIEdyYXBoUHJvdG8gb3V0cHV0XG4gICAgICAgICAqIEBwcm9wZXJ0eSB7QXJyYXkuPG9ubnguSVZhbHVlSW5mb1Byb3RvPnxudWxsfSBbdmFsdWVJbmZvXSBHcmFwaFByb3RvIHZhbHVlSW5mb1xuICAgICAgICAgKiBAcHJvcGVydHkge0FycmF5Ljxvbm54LklUZW5zb3JBbm5vdGF0aW9uPnxudWxsfSBbcXVhbnRpemF0aW9uQW5ub3RhdGlvbl0gR3JhcGhQcm90byBxdWFudGl6YXRpb25Bbm5vdGF0aW9uXG4gICAgICAgICAqL1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IEdyYXBoUHJvdG8uXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54XG4gICAgICAgICAqIEBjbGFzc2Rlc2MgUmVwcmVzZW50cyBhIEdyYXBoUHJvdG8uXG4gICAgICAgICAqIEBpbXBsZW1lbnRzIElHcmFwaFByb3RvXG4gICAgICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAgICAgKiBAcGFyYW0ge29ubnguSUdyYXBoUHJvdG89fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIEdyYXBoUHJvdG8ocHJvcGVydGllcykge1xuICAgICAgICAgICAgdGhpcy5ub2RlID0gW107XG4gICAgICAgICAgICB0aGlzLmluaXRpYWxpemVyID0gW107XG4gICAgICAgICAgICB0aGlzLnNwYXJzZUluaXRpYWxpemVyID0gW107XG4gICAgICAgICAgICB0aGlzLmlucHV0ID0gW107XG4gICAgICAgICAgICB0aGlzLm91dHB1dCA9IFtdO1xuICAgICAgICAgICAgdGhpcy52YWx1ZUluZm8gPSBbXTtcbiAgICAgICAgICAgIHRoaXMucXVhbnRpemF0aW9uQW5ub3RhdGlvbiA9IFtdO1xuICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMpXG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzW2tleXNbaV1dICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2tleXNbaV1dID0gcHJvcGVydGllc1trZXlzW2ldXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHcmFwaFByb3RvIG5vZGUuXG4gICAgICAgICAqIEBtZW1iZXIge0FycmF5Ljxvbm54LklOb2RlUHJvdG8+fSBub2RlXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LkdyYXBoUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBHcmFwaFByb3RvLnByb3RvdHlwZS5ub2RlID0gJHV0aWwuZW1wdHlBcnJheTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogR3JhcGhQcm90byBuYW1lLlxuICAgICAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IG5hbWVcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguR3JhcGhQcm90b1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIEdyYXBoUHJvdG8ucHJvdG90eXBlLm5hbWUgPSBcIlwiO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHcmFwaFByb3RvIGluaXRpYWxpemVyLlxuICAgICAgICAgKiBAbWVtYmVyIHtBcnJheS48b25ueC5JVGVuc29yUHJvdG8+fSBpbml0aWFsaXplclxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5HcmFwaFByb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgR3JhcGhQcm90by5wcm90b3R5cGUuaW5pdGlhbGl6ZXIgPSAkdXRpbC5lbXB0eUFycmF5O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHcmFwaFByb3RvIHNwYXJzZUluaXRpYWxpemVyLlxuICAgICAgICAgKiBAbWVtYmVyIHtBcnJheS48b25ueC5JU3BhcnNlVGVuc29yUHJvdG8+fSBzcGFyc2VJbml0aWFsaXplclxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5HcmFwaFByb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgR3JhcGhQcm90by5wcm90b3R5cGUuc3BhcnNlSW5pdGlhbGl6ZXIgPSAkdXRpbC5lbXB0eUFycmF5O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHcmFwaFByb3RvIGRvY1N0cmluZy5cbiAgICAgICAgICogQG1lbWJlciB7c3RyaW5nfSBkb2NTdHJpbmdcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguR3JhcGhQcm90b1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIEdyYXBoUHJvdG8ucHJvdG90eXBlLmRvY1N0cmluZyA9IFwiXCI7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdyYXBoUHJvdG8gaW5wdXQuXG4gICAgICAgICAqIEBtZW1iZXIge0FycmF5Ljxvbm54LklWYWx1ZUluZm9Qcm90bz59IGlucHV0XG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LkdyYXBoUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBHcmFwaFByb3RvLnByb3RvdHlwZS5pbnB1dCA9ICR1dGlsLmVtcHR5QXJyYXk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdyYXBoUHJvdG8gb3V0cHV0LlxuICAgICAgICAgKiBAbWVtYmVyIHtBcnJheS48b25ueC5JVmFsdWVJbmZvUHJvdG8+fSBvdXRwdXRcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguR3JhcGhQcm90b1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIEdyYXBoUHJvdG8ucHJvdG90eXBlLm91dHB1dCA9ICR1dGlsLmVtcHR5QXJyYXk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdyYXBoUHJvdG8gdmFsdWVJbmZvLlxuICAgICAgICAgKiBAbWVtYmVyIHtBcnJheS48b25ueC5JVmFsdWVJbmZvUHJvdG8+fSB2YWx1ZUluZm9cbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguR3JhcGhQcm90b1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIEdyYXBoUHJvdG8ucHJvdG90eXBlLnZhbHVlSW5mbyA9ICR1dGlsLmVtcHR5QXJyYXk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdyYXBoUHJvdG8gcXVhbnRpemF0aW9uQW5ub3RhdGlvbi5cbiAgICAgICAgICogQG1lbWJlciB7QXJyYXkuPG9ubnguSVRlbnNvckFubm90YXRpb24+fSBxdWFudGl6YXRpb25Bbm5vdGF0aW9uXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LkdyYXBoUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBHcmFwaFByb3RvLnByb3RvdHlwZS5xdWFudGl6YXRpb25Bbm5vdGF0aW9uID0gJHV0aWwuZW1wdHlBcnJheTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIG5ldyBHcmFwaFByb3RvIGluc3RhbmNlIHVzaW5nIHRoZSBzcGVjaWZpZWQgcHJvcGVydGllcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGNyZWF0ZVxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5HcmFwaFByb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtvbm54LklHcmFwaFByb3RvPX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gICAgICAgICAqIEByZXR1cm5zIHtvbm54LkdyYXBoUHJvdG99IEdyYXBoUHJvdG8gaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIEdyYXBoUHJvdG8uY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgR3JhcGhQcm90byhwcm9wZXJ0aWVzKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRW5jb2RlcyB0aGUgc3BlY2lmaWVkIEdyYXBoUHJvdG8gbWVzc2FnZS4gRG9lcyBub3QgaW1wbGljaXRseSB7QGxpbmsgb25ueC5HcmFwaFByb3RvLnZlcmlmeXx2ZXJpZnl9IG1lc3NhZ2VzLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZW5jb2RlXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LkdyYXBoUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge29ubnguSUdyYXBoUHJvdG99IG1lc3NhZ2UgR3JhcGhQcm90byBtZXNzYWdlIG9yIHBsYWluIG9iamVjdCB0byBlbmNvZGVcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuV3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gZW5jb2RlIHRvXG4gICAgICAgICAqIEByZXR1cm5zIHskcHJvdG9idWYuV3JpdGVyfSBXcml0ZXJcbiAgICAgICAgICovXG4gICAgICAgIEdyYXBoUHJvdG8uZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgICAgaWYgKCF3cml0ZXIpXG4gICAgICAgICAgICAgICAgd3JpdGVyID0gJFdyaXRlci5jcmVhdGUoKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm5vZGUgIT0gbnVsbCAmJiBtZXNzYWdlLm5vZGUubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5ub2RlLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICAkcm9vdC5vbm54Lk5vZGVQcm90by5lbmNvZGUobWVzc2FnZS5ub2RlW2ldLCB3cml0ZXIudWludDMyKC8qIGlkIDEsIHdpcmVUeXBlIDIgPSovMTApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5uYW1lICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJuYW1lXCIpKVxuICAgICAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMiwgd2lyZVR5cGUgMiA9Ki8xOCkuc3RyaW5nKG1lc3NhZ2UubmFtZSk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5pbml0aWFsaXplciAhPSBudWxsICYmIG1lc3NhZ2UuaW5pdGlhbGl6ZXIubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5pbml0aWFsaXplci5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgJHJvb3Qub25ueC5UZW5zb3JQcm90by5lbmNvZGUobWVzc2FnZS5pbml0aWFsaXplcltpXSwgd3JpdGVyLnVpbnQzMigvKiBpZCA1LCB3aXJlVHlwZSAyID0qLzQyKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZG9jU3RyaW5nICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJkb2NTdHJpbmdcIikpXG4gICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCAxMCwgd2lyZVR5cGUgMiA9Ki84Mikuc3RyaW5nKG1lc3NhZ2UuZG9jU3RyaW5nKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmlucHV0ICE9IG51bGwgJiYgbWVzc2FnZS5pbnB1dC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLmlucHV0Lmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICAkcm9vdC5vbm54LlZhbHVlSW5mb1Byb3RvLmVuY29kZShtZXNzYWdlLmlucHV0W2ldLCB3cml0ZXIudWludDMyKC8qIGlkIDExLCB3aXJlVHlwZSAyID0qLzkwKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2Uub3V0cHV0ICE9IG51bGwgJiYgbWVzc2FnZS5vdXRwdXQubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5vdXRwdXQubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgICRyb290Lm9ubnguVmFsdWVJbmZvUHJvdG8uZW5jb2RlKG1lc3NhZ2Uub3V0cHV0W2ldLCB3cml0ZXIudWludDMyKC8qIGlkIDEyLCB3aXJlVHlwZSAyID0qLzk4KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UudmFsdWVJbmZvICE9IG51bGwgJiYgbWVzc2FnZS52YWx1ZUluZm8ubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS52YWx1ZUluZm8ubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgICRyb290Lm9ubnguVmFsdWVJbmZvUHJvdG8uZW5jb2RlKG1lc3NhZ2UudmFsdWVJbmZvW2ldLCB3cml0ZXIudWludDMyKC8qIGlkIDEzLCB3aXJlVHlwZSAyID0qLzEwNikuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnF1YW50aXphdGlvbkFubm90YXRpb24gIT0gbnVsbCAmJiBtZXNzYWdlLnF1YW50aXphdGlvbkFubm90YXRpb24ubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5xdWFudGl6YXRpb25Bbm5vdGF0aW9uLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICAkcm9vdC5vbm54LlRlbnNvckFubm90YXRpb24uZW5jb2RlKG1lc3NhZ2UucXVhbnRpemF0aW9uQW5ub3RhdGlvbltpXSwgd3JpdGVyLnVpbnQzMigvKiBpZCAxNCwgd2lyZVR5cGUgMiA9Ki8xMTQpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5zcGFyc2VJbml0aWFsaXplciAhPSBudWxsICYmIG1lc3NhZ2Uuc3BhcnNlSW5pdGlhbGl6ZXIubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5zcGFyc2VJbml0aWFsaXplci5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgJHJvb3Qub25ueC5TcGFyc2VUZW5zb3JQcm90by5lbmNvZGUobWVzc2FnZS5zcGFyc2VJbml0aWFsaXplcltpXSwgd3JpdGVyLnVpbnQzMigvKiBpZCAxNSwgd2lyZVR5cGUgMiA9Ki8xMjIpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgR3JhcGhQcm90byBtZXNzYWdlLCBsZW5ndGggZGVsaW1pdGVkLiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayBvbm54LkdyYXBoUHJvdG8udmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWRcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguR3JhcGhQcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7b25ueC5JR3JhcGhQcm90b30gbWVzc2FnZSBHcmFwaFByb3RvIG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0IHRvIGVuY29kZVxuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAgICAgICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAgICAgKi9cbiAgICAgICAgR3JhcGhQcm90by5lbmNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWQobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGUobWVzc2FnZSwgd3JpdGVyKS5sZGVsaW0oKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGVjb2RlcyBhIEdyYXBoUHJvdG8gbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyIG9yIGJ1ZmZlci5cbiAgICAgICAgICogQGZ1bmN0aW9uIGRlY29kZVxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5HcmFwaFByb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoXSBNZXNzYWdlIGxlbmd0aCBpZiBrbm93biBiZWZvcmVoYW5kXG4gICAgICAgICAqIEByZXR1cm5zIHtvbm54LkdyYXBoUHJvdG99IEdyYXBoUHJvdG9cbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcbiAgICAgICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICAgICAqL1xuICAgICAgICBHcmFwaFByb3RvLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyZWFkZXIsIGxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgICAgcmVhZGVyID0gJFJlYWRlci5jcmVhdGUocmVhZGVyKTtcbiAgICAgICAgICAgIHZhciBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoLCBtZXNzYWdlID0gbmV3ICRyb290Lm9ubnguR3JhcGhQcm90bygpO1xuICAgICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShtZXNzYWdlLm5vZGUgJiYgbWVzc2FnZS5ub2RlLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5ub2RlID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm5vZGUucHVzaCgkcm9vdC5vbm54Lk5vZGVQcm90by5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAyOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm5hbWUgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgNToge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEobWVzc2FnZS5pbml0aWFsaXplciAmJiBtZXNzYWdlLmluaXRpYWxpemVyLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pbml0aWFsaXplciA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pbml0aWFsaXplci5wdXNoKCRyb290Lm9ubnguVGVuc29yUHJvdG8uZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgMTU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKG1lc3NhZ2Uuc3BhcnNlSW5pdGlhbGl6ZXIgJiYgbWVzc2FnZS5zcGFyc2VJbml0aWFsaXplci5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc3BhcnNlSW5pdGlhbGl6ZXIgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc3BhcnNlSW5pdGlhbGl6ZXIucHVzaCgkcm9vdC5vbm54LlNwYXJzZVRlbnNvclByb3RvLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIDEwOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmRvY1N0cmluZyA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAxMToge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEobWVzc2FnZS5pbnB1dCAmJiBtZXNzYWdlLmlucHV0Lmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pbnB1dCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pbnB1dC5wdXNoKCRyb290Lm9ubnguVmFsdWVJbmZvUHJvdG8uZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgMTI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKG1lc3NhZ2Uub3V0cHV0ICYmIG1lc3NhZ2Uub3V0cHV0Lmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5vdXRwdXQgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uub3V0cHV0LnB1c2goJHJvb3Qub25ueC5WYWx1ZUluZm9Qcm90by5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAxMzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEobWVzc2FnZS52YWx1ZUluZm8gJiYgbWVzc2FnZS52YWx1ZUluZm8ubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnZhbHVlSW5mbyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS52YWx1ZUluZm8ucHVzaCgkcm9vdC5vbm54LlZhbHVlSW5mb1Byb3RvLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIDE0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShtZXNzYWdlLnF1YW50aXphdGlvbkFubm90YXRpb24gJiYgbWVzc2FnZS5xdWFudGl6YXRpb25Bbm5vdGF0aW9uLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5xdWFudGl6YXRpb25Bbm5vdGF0aW9uID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnF1YW50aXphdGlvbkFubm90YXRpb24ucHVzaCgkcm9vdC5vbm54LlRlbnNvckFubm90YXRpb24uZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlY29kZXMgYSBHcmFwaFByb3RvIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIsIGxlbmd0aCBkZWxpbWl0ZWQuXG4gICAgICAgICAqIEBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWRcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguR3JhcGhQcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLlJlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGUgZnJvbVxuICAgICAgICAgKiBAcmV0dXJucyB7b25ueC5HcmFwaFByb3RvfSBHcmFwaFByb3RvXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAgICAgKi9cbiAgICAgICAgR3JhcGhQcm90by5kZWNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWQocmVhZGVyKSB7XG4gICAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgICByZWFkZXIgPSBuZXcgJFJlYWRlcihyZWFkZXIpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVmVyaWZpZXMgYSBHcmFwaFByb3RvIG1lc3NhZ2UuXG4gICAgICAgICAqIEBmdW5jdGlvbiB2ZXJpZnlcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguR3JhcGhQcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG1lc3NhZ2UgUGxhaW4gb2JqZWN0IHRvIHZlcmlmeVxuICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9IGBudWxsYCBpZiB2YWxpZCwgb3RoZXJ3aXNlIHRoZSByZWFzb24gd2h5IGl0IGlzIG5vdFxuICAgICAgICAgKi9cbiAgICAgICAgR3JhcGhQcm90by52ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnkobWVzc2FnZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlICE9PSBcIm9iamVjdFwiIHx8IG1lc3NhZ2UgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwib2JqZWN0IGV4cGVjdGVkXCI7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5ub2RlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIm5vZGVcIikpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobWVzc2FnZS5ub2RlKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwibm9kZTogYXJyYXkgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2Uubm9kZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXJyb3IgPSAkcm9vdC5vbm54Lk5vZGVQcm90by52ZXJpZnkobWVzc2FnZS5ub2RlW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwibm9kZS5cIiArIGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm5hbWUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwibmFtZVwiKSlcbiAgICAgICAgICAgICAgICBpZiAoISR1dGlsLmlzU3RyaW5nKG1lc3NhZ2UubmFtZSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIm5hbWU6IHN0cmluZyBleHBlY3RlZFwiO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuaW5pdGlhbGl6ZXIgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiaW5pdGlhbGl6ZXJcIikpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobWVzc2FnZS5pbml0aWFsaXplcikpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImluaXRpYWxpemVyOiBhcnJheSBleHBlY3RlZFwiO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5pbml0aWFsaXplci5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXJyb3IgPSAkcm9vdC5vbm54LlRlbnNvclByb3RvLnZlcmlmeShtZXNzYWdlLmluaXRpYWxpemVyW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiaW5pdGlhbGl6ZXIuXCIgKyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5zcGFyc2VJbml0aWFsaXplciAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJzcGFyc2VJbml0aWFsaXplclwiKSkge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShtZXNzYWdlLnNwYXJzZUluaXRpYWxpemVyKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwic3BhcnNlSW5pdGlhbGl6ZXI6IGFycmF5IGV4cGVjdGVkXCI7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLnNwYXJzZUluaXRpYWxpemVyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlcnJvciA9ICRyb290Lm9ubnguU3BhcnNlVGVuc29yUHJvdG8udmVyaWZ5KG1lc3NhZ2Uuc3BhcnNlSW5pdGlhbGl6ZXJbaV0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJzcGFyc2VJbml0aWFsaXplci5cIiArIGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmRvY1N0cmluZyAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJkb2NTdHJpbmdcIikpXG4gICAgICAgICAgICAgICAgaWYgKCEkdXRpbC5pc1N0cmluZyhtZXNzYWdlLmRvY1N0cmluZykpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImRvY1N0cmluZzogc3RyaW5nIGV4cGVjdGVkXCI7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5pbnB1dCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJpbnB1dFwiKSkge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShtZXNzYWdlLmlucHV0KSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiaW5wdXQ6IGFycmF5IGV4cGVjdGVkXCI7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLmlucHV0Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlcnJvciA9ICRyb290Lm9ubnguVmFsdWVJbmZvUHJvdG8udmVyaWZ5KG1lc3NhZ2UuaW5wdXRbaV0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJpbnB1dC5cIiArIGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm91dHB1dCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJvdXRwdXRcIikpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobWVzc2FnZS5vdXRwdXQpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJvdXRwdXQ6IGFycmF5IGV4cGVjdGVkXCI7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLm91dHB1dC5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXJyb3IgPSAkcm9vdC5vbm54LlZhbHVlSW5mb1Byb3RvLnZlcmlmeShtZXNzYWdlLm91dHB1dFtpXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIm91dHB1dC5cIiArIGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnZhbHVlSW5mbyAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJ2YWx1ZUluZm9cIikpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobWVzc2FnZS52YWx1ZUluZm8pKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJ2YWx1ZUluZm86IGFycmF5IGV4cGVjdGVkXCI7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLnZhbHVlSW5mby5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXJyb3IgPSAkcm9vdC5vbm54LlZhbHVlSW5mb1Byb3RvLnZlcmlmeShtZXNzYWdlLnZhbHVlSW5mb1tpXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcInZhbHVlSW5mby5cIiArIGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnF1YW50aXphdGlvbkFubm90YXRpb24gIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwicXVhbnRpemF0aW9uQW5ub3RhdGlvblwiKSkge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShtZXNzYWdlLnF1YW50aXphdGlvbkFubm90YXRpb24pKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJxdWFudGl6YXRpb25Bbm5vdGF0aW9uOiBhcnJheSBleHBlY3RlZFwiO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5xdWFudGl6YXRpb25Bbm5vdGF0aW9uLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlcnJvciA9ICRyb290Lm9ubnguVGVuc29yQW5ub3RhdGlvbi52ZXJpZnkobWVzc2FnZS5xdWFudGl6YXRpb25Bbm5vdGF0aW9uW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwicXVhbnRpemF0aW9uQW5ub3RhdGlvbi5cIiArIGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgR3JhcGhQcm90byBtZXNzYWdlIGZyb20gYSBwbGFpbiBvYmplY3QuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIHRoZWlyIHJlc3BlY3RpdmUgaW50ZXJuYWwgdHlwZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBmcm9tT2JqZWN0XG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LkdyYXBoUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBvYmplY3QgUGxhaW4gb2JqZWN0XG4gICAgICAgICAqIEByZXR1cm5zIHtvbm54LkdyYXBoUHJvdG99IEdyYXBoUHJvdG9cbiAgICAgICAgICovXG4gICAgICAgIEdyYXBoUHJvdG8uZnJvbU9iamVjdCA9IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgJHJvb3Qub25ueC5HcmFwaFByb3RvKVxuICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgICAgICB2YXIgbWVzc2FnZSA9IG5ldyAkcm9vdC5vbm54LkdyYXBoUHJvdG8oKTtcbiAgICAgICAgICAgIGlmIChvYmplY3Qubm9kZSkge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvYmplY3Qubm9kZSkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5vbm54LkdyYXBoUHJvdG8ubm9kZTogYXJyYXkgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5ub2RlID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3Qubm9kZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5ub2RlW2ldICE9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguR3JhcGhQcm90by5ub2RlOiBvYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uubm9kZVtpXSA9ICRyb290Lm9ubnguTm9kZVByb3RvLmZyb21PYmplY3Qob2JqZWN0Lm5vZGVbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvYmplY3QubmFtZSAhPSBudWxsKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UubmFtZSA9IFN0cmluZyhvYmplY3QubmFtZSk7XG4gICAgICAgICAgICBpZiAob2JqZWN0LmluaXRpYWxpemVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9iamVjdC5pbml0aWFsaXplcikpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5vbm54LkdyYXBoUHJvdG8uaW5pdGlhbGl6ZXI6IGFycmF5IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UuaW5pdGlhbGl6ZXIgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdC5pbml0aWFsaXplci5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5pbml0aWFsaXplcltpXSAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5vbm54LkdyYXBoUHJvdG8uaW5pdGlhbGl6ZXI6IG9iamVjdCBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pbml0aWFsaXplcltpXSA9ICRyb290Lm9ubnguVGVuc29yUHJvdG8uZnJvbU9iamVjdChvYmplY3QuaW5pdGlhbGl6ZXJbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvYmplY3Quc3BhcnNlSW5pdGlhbGl6ZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqZWN0LnNwYXJzZUluaXRpYWxpemVyKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguR3JhcGhQcm90by5zcGFyc2VJbml0aWFsaXplcjogYXJyYXkgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5zcGFyc2VJbml0aWFsaXplciA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0LnNwYXJzZUluaXRpYWxpemVyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LnNwYXJzZUluaXRpYWxpemVyW2ldICE9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguR3JhcGhQcm90by5zcGFyc2VJbml0aWFsaXplcjogb2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnNwYXJzZUluaXRpYWxpemVyW2ldID0gJHJvb3Qub25ueC5TcGFyc2VUZW5zb3JQcm90by5mcm9tT2JqZWN0KG9iamVjdC5zcGFyc2VJbml0aWFsaXplcltpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9iamVjdC5kb2NTdHJpbmcgIT0gbnVsbClcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmRvY1N0cmluZyA9IFN0cmluZyhvYmplY3QuZG9jU3RyaW5nKTtcbiAgICAgICAgICAgIGlmIChvYmplY3QuaW5wdXQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqZWN0LmlucHV0KSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguR3JhcGhQcm90by5pbnB1dDogYXJyYXkgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5pbnB1dCA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0LmlucHV0Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LmlucHV0W2ldICE9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguR3JhcGhQcm90by5pbnB1dDogb2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmlucHV0W2ldID0gJHJvb3Qub25ueC5WYWx1ZUluZm9Qcm90by5mcm9tT2JqZWN0KG9iamVjdC5pbnB1dFtpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9iamVjdC5vdXRwdXQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqZWN0Lm91dHB1dCkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5vbm54LkdyYXBoUHJvdG8ub3V0cHV0OiBhcnJheSBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLm91dHB1dCA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0Lm91dHB1dC5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5vdXRwdXRbaV0gIT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5HcmFwaFByb3RvLm91dHB1dDogb2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm91dHB1dFtpXSA9ICRyb290Lm9ubnguVmFsdWVJbmZvUHJvdG8uZnJvbU9iamVjdChvYmplY3Qub3V0cHV0W2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2JqZWN0LnZhbHVlSW5mbykge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvYmplY3QudmFsdWVJbmZvKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguR3JhcGhQcm90by52YWx1ZUluZm86IGFycmF5IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UudmFsdWVJbmZvID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3QudmFsdWVJbmZvLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LnZhbHVlSW5mb1tpXSAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5vbm54LkdyYXBoUHJvdG8udmFsdWVJbmZvOiBvYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudmFsdWVJbmZvW2ldID0gJHJvb3Qub25ueC5WYWx1ZUluZm9Qcm90by5mcm9tT2JqZWN0KG9iamVjdC52YWx1ZUluZm9baV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvYmplY3QucXVhbnRpemF0aW9uQW5ub3RhdGlvbikge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvYmplY3QucXVhbnRpemF0aW9uQW5ub3RhdGlvbikpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5vbm54LkdyYXBoUHJvdG8ucXVhbnRpemF0aW9uQW5ub3RhdGlvbjogYXJyYXkgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5xdWFudGl6YXRpb25Bbm5vdGF0aW9uID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3QucXVhbnRpemF0aW9uQW5ub3RhdGlvbi5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5xdWFudGl6YXRpb25Bbm5vdGF0aW9uW2ldICE9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguR3JhcGhQcm90by5xdWFudGl6YXRpb25Bbm5vdGF0aW9uOiBvYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucXVhbnRpemF0aW9uQW5ub3RhdGlvbltpXSA9ICRyb290Lm9ubnguVGVuc29yQW5ub3RhdGlvbi5mcm9tT2JqZWN0KG9iamVjdC5xdWFudGl6YXRpb25Bbm5vdGF0aW9uW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIHBsYWluIG9iamVjdCBmcm9tIGEgR3JhcGhQcm90byBtZXNzYWdlLiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byBvdGhlciB0eXBlcyBpZiBzcGVjaWZpZWQuXG4gICAgICAgICAqIEBmdW5jdGlvbiB0b09iamVjdFxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5HcmFwaFByb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtvbm54LkdyYXBoUHJvdG99IG1lc3NhZ2UgR3JhcGhQcm90b1xuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5JQ29udmVyc2lvbk9wdGlvbnN9IFtvcHRpb25zXSBDb252ZXJzaW9uIG9wdGlvbnNcbiAgICAgICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBQbGFpbiBvYmplY3RcbiAgICAgICAgICovXG4gICAgICAgIEdyYXBoUHJvdG8udG9PYmplY3QgPSBmdW5jdGlvbiB0b09iamVjdChtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMpXG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgICAgdmFyIG9iamVjdCA9IHt9O1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuYXJyYXlzIHx8IG9wdGlvbnMuZGVmYXVsdHMpIHtcbiAgICAgICAgICAgICAgICBvYmplY3Qubm9kZSA9IFtdO1xuICAgICAgICAgICAgICAgIG9iamVjdC5pbml0aWFsaXplciA9IFtdO1xuICAgICAgICAgICAgICAgIG9iamVjdC5pbnB1dCA9IFtdO1xuICAgICAgICAgICAgICAgIG9iamVjdC5vdXRwdXQgPSBbXTtcbiAgICAgICAgICAgICAgICBvYmplY3QudmFsdWVJbmZvID0gW107XG4gICAgICAgICAgICAgICAgb2JqZWN0LnF1YW50aXphdGlvbkFubm90YXRpb24gPSBbXTtcbiAgICAgICAgICAgICAgICBvYmplY3Quc3BhcnNlSW5pdGlhbGl6ZXIgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmRlZmF1bHRzKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0Lm5hbWUgPSBcIlwiO1xuICAgICAgICAgICAgICAgIG9iamVjdC5kb2NTdHJpbmcgPSBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2Uubm9kZSAmJiBtZXNzYWdlLm5vZGUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0Lm5vZGUgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1lc3NhZ2Uubm9kZS5sZW5ndGg7ICsrailcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0Lm5vZGVbal0gPSAkcm9vdC5vbm54Lk5vZGVQcm90by50b09iamVjdChtZXNzYWdlLm5vZGVbal0sIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UubmFtZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJuYW1lXCIpKVxuICAgICAgICAgICAgICAgIG9iamVjdC5uYW1lID0gbWVzc2FnZS5uYW1lO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuaW5pdGlhbGl6ZXIgJiYgbWVzc2FnZS5pbml0aWFsaXplci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBvYmplY3QuaW5pdGlhbGl6ZXIgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1lc3NhZ2UuaW5pdGlhbGl6ZXIubGVuZ3RoOyArK2opXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5pbml0aWFsaXplcltqXSA9ICRyb290Lm9ubnguVGVuc29yUHJvdG8udG9PYmplY3QobWVzc2FnZS5pbml0aWFsaXplcltqXSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5kb2NTdHJpbmcgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZG9jU3RyaW5nXCIpKVxuICAgICAgICAgICAgICAgIG9iamVjdC5kb2NTdHJpbmcgPSBtZXNzYWdlLmRvY1N0cmluZztcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmlucHV0ICYmIG1lc3NhZ2UuaW5wdXQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0LmlucHV0ID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtZXNzYWdlLmlucHV0Lmxlbmd0aDsgKytqKVxuICAgICAgICAgICAgICAgICAgICBvYmplY3QuaW5wdXRbal0gPSAkcm9vdC5vbm54LlZhbHVlSW5mb1Byb3RvLnRvT2JqZWN0KG1lc3NhZ2UuaW5wdXRbal0sIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2Uub3V0cHV0ICYmIG1lc3NhZ2Uub3V0cHV0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIG9iamVjdC5vdXRwdXQgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1lc3NhZ2Uub3V0cHV0Lmxlbmd0aDsgKytqKVxuICAgICAgICAgICAgICAgICAgICBvYmplY3Qub3V0cHV0W2pdID0gJHJvb3Qub25ueC5WYWx1ZUluZm9Qcm90by50b09iamVjdChtZXNzYWdlLm91dHB1dFtqXSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS52YWx1ZUluZm8gJiYgbWVzc2FnZS52YWx1ZUluZm8ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0LnZhbHVlSW5mbyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWVzc2FnZS52YWx1ZUluZm8ubGVuZ3RoOyArK2opXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC52YWx1ZUluZm9bal0gPSAkcm9vdC5vbm54LlZhbHVlSW5mb1Byb3RvLnRvT2JqZWN0KG1lc3NhZ2UudmFsdWVJbmZvW2pdLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnF1YW50aXphdGlvbkFubm90YXRpb24gJiYgbWVzc2FnZS5xdWFudGl6YXRpb25Bbm5vdGF0aW9uLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIG9iamVjdC5xdWFudGl6YXRpb25Bbm5vdGF0aW9uID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtZXNzYWdlLnF1YW50aXphdGlvbkFubm90YXRpb24ubGVuZ3RoOyArK2opXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5xdWFudGl6YXRpb25Bbm5vdGF0aW9uW2pdID0gJHJvb3Qub25ueC5UZW5zb3JBbm5vdGF0aW9uLnRvT2JqZWN0KG1lc3NhZ2UucXVhbnRpemF0aW9uQW5ub3RhdGlvbltqXSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5zcGFyc2VJbml0aWFsaXplciAmJiBtZXNzYWdlLnNwYXJzZUluaXRpYWxpemVyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIG9iamVjdC5zcGFyc2VJbml0aWFsaXplciA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWVzc2FnZS5zcGFyc2VJbml0aWFsaXplci5sZW5ndGg7ICsrailcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LnNwYXJzZUluaXRpYWxpemVyW2pdID0gJHJvb3Qub25ueC5TcGFyc2VUZW5zb3JQcm90by50b09iamVjdChtZXNzYWdlLnNwYXJzZUluaXRpYWxpemVyW2pdLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlcnRzIHRoaXMgR3JhcGhQcm90byB0byBKU09OLlxuICAgICAgICAgKiBAZnVuY3Rpb24gdG9KU09OXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LkdyYXBoUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gSlNPTiBvYmplY3RcbiAgICAgICAgICovXG4gICAgICAgIEdyYXBoUHJvdG8ucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsICRwcm90b2J1Zi51dGlsLnRvSlNPTk9wdGlvbnMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIHRoZSBkZWZhdWx0IHR5cGUgdXJsIGZvciBHcmFwaFByb3RvXG4gICAgICAgICAqIEBmdW5jdGlvbiBnZXRUeXBlVXJsXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LkdyYXBoUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3R5cGVVcmxQcmVmaXhdIHlvdXIgY3VzdG9tIHR5cGVVcmxQcmVmaXgoZGVmYXVsdCBcInR5cGUuZ29vZ2xlYXBpcy5jb21cIilcbiAgICAgICAgICogQHJldHVybnMge3N0cmluZ30gVGhlIGRlZmF1bHQgdHlwZSB1cmxcbiAgICAgICAgICovXG4gICAgICAgIEdyYXBoUHJvdG8uZ2V0VHlwZVVybCA9IGZ1bmN0aW9uIGdldFR5cGVVcmwodHlwZVVybFByZWZpeCkge1xuICAgICAgICAgICAgaWYgKHR5cGVVcmxQcmVmaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHR5cGVVcmxQcmVmaXggPSBcInR5cGUuZ29vZ2xlYXBpcy5jb21cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0eXBlVXJsUHJlZml4ICsgXCIvb25ueC5HcmFwaFByb3RvXCI7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIEdyYXBoUHJvdG87XG4gICAgfSkoKTtcblxuICAgIG9ubnguVGVuc29yUHJvdG8gPSAoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb3BlcnRpZXMgb2YgYSBUZW5zb3JQcm90by5cbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnhcbiAgICAgICAgICogQGludGVyZmFjZSBJVGVuc29yUHJvdG9cbiAgICAgICAgICogQHByb3BlcnR5IHtBcnJheS48bnVtYmVyfExvbmc+fG51bGx9IFtkaW1zXSBUZW5zb3JQcm90byBkaW1zXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfG51bGx9IFtkYXRhVHlwZV0gVGVuc29yUHJvdG8gZGF0YVR5cGVcbiAgICAgICAgICogQHByb3BlcnR5IHtvbm54LlRlbnNvclByb3RvLklTZWdtZW50fG51bGx9IFtzZWdtZW50XSBUZW5zb3JQcm90byBzZWdtZW50XG4gICAgICAgICAqIEBwcm9wZXJ0eSB7QXJyYXkuPG51bWJlcj58bnVsbH0gW2Zsb2F0RGF0YV0gVGVuc29yUHJvdG8gZmxvYXREYXRhXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7QXJyYXkuPG51bWJlcj58bnVsbH0gW2ludDMyRGF0YV0gVGVuc29yUHJvdG8gaW50MzJEYXRhXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7QXJyYXkuPFVpbnQ4QXJyYXk+fG51bGx9IFtzdHJpbmdEYXRhXSBUZW5zb3JQcm90byBzdHJpbmdEYXRhXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7QXJyYXkuPG51bWJlcnxMb25nPnxudWxsfSBbaW50NjREYXRhXSBUZW5zb3JQcm90byBpbnQ2NERhdGFcbiAgICAgICAgICogQHByb3BlcnR5IHtzdHJpbmd8bnVsbH0gW25hbWVdIFRlbnNvclByb3RvIG5hbWVcbiAgICAgICAgICogQHByb3BlcnR5IHtzdHJpbmd8bnVsbH0gW2RvY1N0cmluZ10gVGVuc29yUHJvdG8gZG9jU3RyaW5nXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7VWludDhBcnJheXxudWxsfSBbcmF3RGF0YV0gVGVuc29yUHJvdG8gcmF3RGF0YVxuICAgICAgICAgKiBAcHJvcGVydHkge0FycmF5Ljxvbm54LklTdHJpbmdTdHJpbmdFbnRyeVByb3RvPnxudWxsfSBbZXh0ZXJuYWxEYXRhXSBUZW5zb3JQcm90byBleHRlcm5hbERhdGFcbiAgICAgICAgICogQHByb3BlcnR5IHtvbm54LlRlbnNvclByb3RvLkRhdGFMb2NhdGlvbnxudWxsfSBbZGF0YUxvY2F0aW9uXSBUZW5zb3JQcm90byBkYXRhTG9jYXRpb25cbiAgICAgICAgICogQHByb3BlcnR5IHtBcnJheS48bnVtYmVyPnxudWxsfSBbZG91YmxlRGF0YV0gVGVuc29yUHJvdG8gZG91YmxlRGF0YVxuICAgICAgICAgKiBAcHJvcGVydHkge0FycmF5LjxudW1iZXJ8TG9uZz58bnVsbH0gW3VpbnQ2NERhdGFdIFRlbnNvclByb3RvIHVpbnQ2NERhdGFcbiAgICAgICAgICovXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnN0cnVjdHMgYSBuZXcgVGVuc29yUHJvdG8uXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54XG4gICAgICAgICAqIEBjbGFzc2Rlc2MgUmVwcmVzZW50cyBhIFRlbnNvclByb3RvLlxuICAgICAgICAgKiBAaW1wbGVtZW50cyBJVGVuc29yUHJvdG9cbiAgICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgICAqIEBwYXJhbSB7b25ueC5JVGVuc29yUHJvdG89fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIFRlbnNvclByb3RvKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHRoaXMuZGltcyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5mbG9hdERhdGEgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuaW50MzJEYXRhID0gW107XG4gICAgICAgICAgICB0aGlzLnN0cmluZ0RhdGEgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuaW50NjREYXRhID0gW107XG4gICAgICAgICAgICB0aGlzLmV4dGVybmFsRGF0YSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5kb3VibGVEYXRhID0gW107XG4gICAgICAgICAgICB0aGlzLnVpbnQ2NERhdGEgPSBbXTtcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzKVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKSwgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllc1trZXlzW2ldXSAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1trZXlzW2ldXSA9IHByb3BlcnRpZXNba2V5c1tpXV07XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogVGVuc29yUHJvdG8gZGltcy5cbiAgICAgICAgICogQG1lbWJlciB7QXJyYXkuPG51bWJlcnxMb25nPn0gZGltc1xuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JQcm90b1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIFRlbnNvclByb3RvLnByb3RvdHlwZS5kaW1zID0gJHV0aWwuZW1wdHlBcnJheTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGVuc29yUHJvdG8gZGF0YVR5cGUuXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn0gZGF0YVR5cGVcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBUZW5zb3JQcm90by5wcm90b3R5cGUuZGF0YVR5cGUgPSAwO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUZW5zb3JQcm90byBzZWdtZW50LlxuICAgICAgICAgKiBAbWVtYmVyIHtvbm54LlRlbnNvclByb3RvLklTZWdtZW50fG51bGx8dW5kZWZpbmVkfSBzZWdtZW50XG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclByb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgVGVuc29yUHJvdG8ucHJvdG90eXBlLnNlZ21lbnQgPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUZW5zb3JQcm90byBmbG9hdERhdGEuXG4gICAgICAgICAqIEBtZW1iZXIge0FycmF5LjxudW1iZXI+fSBmbG9hdERhdGFcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBUZW5zb3JQcm90by5wcm90b3R5cGUuZmxvYXREYXRhID0gJHV0aWwuZW1wdHlBcnJheTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGVuc29yUHJvdG8gaW50MzJEYXRhLlxuICAgICAgICAgKiBAbWVtYmVyIHtBcnJheS48bnVtYmVyPn0gaW50MzJEYXRhXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclByb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgVGVuc29yUHJvdG8ucHJvdG90eXBlLmludDMyRGF0YSA9ICR1dGlsLmVtcHR5QXJyYXk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRlbnNvclByb3RvIHN0cmluZ0RhdGEuXG4gICAgICAgICAqIEBtZW1iZXIge0FycmF5LjxVaW50OEFycmF5Pn0gc3RyaW5nRGF0YVxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JQcm90b1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIFRlbnNvclByb3RvLnByb3RvdHlwZS5zdHJpbmdEYXRhID0gJHV0aWwuZW1wdHlBcnJheTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGVuc29yUHJvdG8gaW50NjREYXRhLlxuICAgICAgICAgKiBAbWVtYmVyIHtBcnJheS48bnVtYmVyfExvbmc+fSBpbnQ2NERhdGFcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBUZW5zb3JQcm90by5wcm90b3R5cGUuaW50NjREYXRhID0gJHV0aWwuZW1wdHlBcnJheTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGVuc29yUHJvdG8gbmFtZS5cbiAgICAgICAgICogQG1lbWJlciB7c3RyaW5nfSBuYW1lXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclByb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgVGVuc29yUHJvdG8ucHJvdG90eXBlLm5hbWUgPSBcIlwiO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUZW5zb3JQcm90byBkb2NTdHJpbmcuXG4gICAgICAgICAqIEBtZW1iZXIge3N0cmluZ30gZG9jU3RyaW5nXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclByb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgVGVuc29yUHJvdG8ucHJvdG90eXBlLmRvY1N0cmluZyA9IFwiXCI7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRlbnNvclByb3RvIHJhd0RhdGEuXG4gICAgICAgICAqIEBtZW1iZXIge1VpbnQ4QXJyYXl9IHJhd0RhdGFcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBUZW5zb3JQcm90by5wcm90b3R5cGUucmF3RGF0YSA9ICR1dGlsLm5ld0J1ZmZlcihbXSk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRlbnNvclByb3RvIGV4dGVybmFsRGF0YS5cbiAgICAgICAgICogQG1lbWJlciB7QXJyYXkuPG9ubnguSVN0cmluZ1N0cmluZ0VudHJ5UHJvdG8+fSBleHRlcm5hbERhdGFcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBUZW5zb3JQcm90by5wcm90b3R5cGUuZXh0ZXJuYWxEYXRhID0gJHV0aWwuZW1wdHlBcnJheTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGVuc29yUHJvdG8gZGF0YUxvY2F0aW9uLlxuICAgICAgICAgKiBAbWVtYmVyIHtvbm54LlRlbnNvclByb3RvLkRhdGFMb2NhdGlvbn0gZGF0YUxvY2F0aW9uXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclByb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgVGVuc29yUHJvdG8ucHJvdG90eXBlLmRhdGFMb2NhdGlvbiA9IDA7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRlbnNvclByb3RvIGRvdWJsZURhdGEuXG4gICAgICAgICAqIEBtZW1iZXIge0FycmF5LjxudW1iZXI+fSBkb3VibGVEYXRhXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclByb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgVGVuc29yUHJvdG8ucHJvdG90eXBlLmRvdWJsZURhdGEgPSAkdXRpbC5lbXB0eUFycmF5O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUZW5zb3JQcm90byB1aW50NjREYXRhLlxuICAgICAgICAgKiBAbWVtYmVyIHtBcnJheS48bnVtYmVyfExvbmc+fSB1aW50NjREYXRhXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclByb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgVGVuc29yUHJvdG8ucHJvdG90eXBlLnVpbnQ2NERhdGEgPSAkdXRpbC5lbXB0eUFycmF5O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgbmV3IFRlbnNvclByb3RvIGluc3RhbmNlIHVzaW5nIHRoZSBzcGVjaWZpZWQgcHJvcGVydGllcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGNyZWF0ZVxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JQcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7b25ueC5JVGVuc29yUHJvdG89fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAgICAgICAgICogQHJldHVybnMge29ubnguVGVuc29yUHJvdG99IFRlbnNvclByb3RvIGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBUZW5zb3JQcm90by5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUocHJvcGVydGllcykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBUZW5zb3JQcm90byhwcm9wZXJ0aWVzKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRW5jb2RlcyB0aGUgc3BlY2lmaWVkIFRlbnNvclByb3RvIG1lc3NhZ2UuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIG9ubnguVGVuc29yUHJvdG8udmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBlbmNvZGVcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge29ubnguSVRlbnNvclByb3RvfSBtZXNzYWdlIFRlbnNvclByb3RvIG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0IHRvIGVuY29kZVxuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAgICAgICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAgICAgKi9cbiAgICAgICAgVGVuc29yUHJvdG8uZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgICAgaWYgKCF3cml0ZXIpXG4gICAgICAgICAgICAgICAgd3JpdGVyID0gJFdyaXRlci5jcmVhdGUoKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmRpbXMgIT0gbnVsbCAmJiBtZXNzYWdlLmRpbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCAxLCB3aXJlVHlwZSAyID0qLzEwKS5mb3JrKCk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLmRpbXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIHdyaXRlci5pbnQ2NChtZXNzYWdlLmRpbXNbaV0pO1xuICAgICAgICAgICAgICAgIHdyaXRlci5sZGVsaW0oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmRhdGFUeXBlICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJkYXRhVHlwZVwiKSlcbiAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDIsIHdpcmVUeXBlIDAgPSovMTYpLmludDMyKG1lc3NhZ2UuZGF0YVR5cGUpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2Uuc2VnbWVudCAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwic2VnbWVudFwiKSlcbiAgICAgICAgICAgICAgICAkcm9vdC5vbm54LlRlbnNvclByb3RvLlNlZ21lbnQuZW5jb2RlKG1lc3NhZ2Uuc2VnbWVudCwgd3JpdGVyLnVpbnQzMigvKiBpZCAzLCB3aXJlVHlwZSAyID0qLzI2KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZmxvYXREYXRhICE9IG51bGwgJiYgbWVzc2FnZS5mbG9hdERhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCA0LCB3aXJlVHlwZSAyID0qLzM0KS5mb3JrKCk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLmZsb2F0RGF0YS5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVyLmZsb2F0KG1lc3NhZ2UuZmxvYXREYXRhW2ldKTtcbiAgICAgICAgICAgICAgICB3cml0ZXIubGRlbGltKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5pbnQzMkRhdGEgIT0gbnVsbCAmJiBtZXNzYWdlLmludDMyRGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDUsIHdpcmVUeXBlIDIgPSovNDIpLmZvcmsoKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UuaW50MzJEYXRhLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICB3cml0ZXIuaW50MzIobWVzc2FnZS5pbnQzMkRhdGFbaV0pO1xuICAgICAgICAgICAgICAgIHdyaXRlci5sZGVsaW0oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnN0cmluZ0RhdGEgIT0gbnVsbCAmJiBtZXNzYWdlLnN0cmluZ0RhdGEubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5zdHJpbmdEYXRhLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDYsIHdpcmVUeXBlIDIgPSovNTApLmJ5dGVzKG1lc3NhZ2Uuc3RyaW5nRGF0YVtpXSk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5pbnQ2NERhdGEgIT0gbnVsbCAmJiBtZXNzYWdlLmludDY0RGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDcsIHdpcmVUeXBlIDIgPSovNTgpLmZvcmsoKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UuaW50NjREYXRhLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICB3cml0ZXIuaW50NjQobWVzc2FnZS5pbnQ2NERhdGFbaV0pO1xuICAgICAgICAgICAgICAgIHdyaXRlci5sZGVsaW0oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm5hbWUgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcIm5hbWVcIikpXG4gICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCA4LCB3aXJlVHlwZSAyID0qLzY2KS5zdHJpbmcobWVzc2FnZS5uYW1lKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnJhd0RhdGEgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcInJhd0RhdGFcIikpXG4gICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCA5LCB3aXJlVHlwZSAyID0qLzc0KS5ieXRlcyhtZXNzYWdlLnJhd0RhdGEpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZG91YmxlRGF0YSAhPSBudWxsICYmIG1lc3NhZ2UuZG91YmxlRGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDEwLCB3aXJlVHlwZSAyID0qLzgyKS5mb3JrKCk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLmRvdWJsZURhdGEubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIHdyaXRlci5kb3VibGUobWVzc2FnZS5kb3VibGVEYXRhW2ldKTtcbiAgICAgICAgICAgICAgICB3cml0ZXIubGRlbGltKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS51aW50NjREYXRhICE9IG51bGwgJiYgbWVzc2FnZS51aW50NjREYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMTEsIHdpcmVUeXBlIDIgPSovOTApLmZvcmsoKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UudWludDY0RGF0YS5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQ2NChtZXNzYWdlLnVpbnQ2NERhdGFbaV0pO1xuICAgICAgICAgICAgICAgIHdyaXRlci5sZGVsaW0oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmRvY1N0cmluZyAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwiZG9jU3RyaW5nXCIpKVxuICAgICAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMTIsIHdpcmVUeXBlIDIgPSovOTgpLnN0cmluZyhtZXNzYWdlLmRvY1N0cmluZyk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5leHRlcm5hbERhdGEgIT0gbnVsbCAmJiBtZXNzYWdlLmV4dGVybmFsRGF0YS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLmV4dGVybmFsRGF0YS5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgJHJvb3Qub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvLmVuY29kZShtZXNzYWdlLmV4dGVybmFsRGF0YVtpXSwgd3JpdGVyLnVpbnQzMigvKiBpZCAxMywgd2lyZVR5cGUgMiA9Ki8xMDYpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5kYXRhTG9jYXRpb24gIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcImRhdGFMb2NhdGlvblwiKSlcbiAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDE0LCB3aXJlVHlwZSAwID0qLzExMikuaW50MzIobWVzc2FnZS5kYXRhTG9jYXRpb24pO1xuICAgICAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRW5jb2RlcyB0aGUgc3BlY2lmaWVkIFRlbnNvclByb3RvIG1lc3NhZ2UsIGxlbmd0aCBkZWxpbWl0ZWQuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIG9ubnguVGVuc29yUHJvdG8udmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWRcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge29ubnguSVRlbnNvclByb3RvfSBtZXNzYWdlIFRlbnNvclByb3RvIG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0IHRvIGVuY29kZVxuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAgICAgICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAgICAgKi9cbiAgICAgICAgVGVuc29yUHJvdG8uZW5jb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikubGRlbGltKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlY29kZXMgYSBUZW5zb3JQcm90byBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZGVjb2RlXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclByb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoXSBNZXNzYWdlIGxlbmd0aCBpZiBrbm93biBiZWZvcmVoYW5kXG4gICAgICAgICAqIEByZXR1cm5zIHtvbm54LlRlbnNvclByb3RvfSBUZW5zb3JQcm90b1xuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcbiAgICAgICAgICovXG4gICAgICAgIFRlbnNvclByb3RvLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyZWFkZXIsIGxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgICAgcmVhZGVyID0gJFJlYWRlci5jcmVhdGUocmVhZGVyKTtcbiAgICAgICAgICAgIHZhciBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoLCBtZXNzYWdlID0gbmV3ICRyb290Lm9ubnguVGVuc29yUHJvdG8oKTtcbiAgICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMToge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEobWVzc2FnZS5kaW1zICYmIG1lc3NhZ2UuZGltcy5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZGltcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCh0YWcgJiA3KSA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbmQyID0gcmVhZGVyLnVpbnQzMigpICsgcmVhZGVyLnBvcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZDIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZGltcy5wdXNoKHJlYWRlci5pbnQ2NCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZGltcy5wdXNoKHJlYWRlci5pbnQ2NCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAyOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmRhdGFUeXBlID0gcmVhZGVyLmludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgMzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zZWdtZW50ID0gJHJvb3Qub25ueC5UZW5zb3JQcm90by5TZWdtZW50LmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgNDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEobWVzc2FnZS5mbG9hdERhdGEgJiYgbWVzc2FnZS5mbG9hdERhdGEubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmZsb2F0RGF0YSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCh0YWcgJiA3KSA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbmQyID0gcmVhZGVyLnVpbnQzMigpICsgcmVhZGVyLnBvcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZDIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZmxvYXREYXRhLnB1c2gocmVhZGVyLmZsb2F0KCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5mbG9hdERhdGEucHVzaChyZWFkZXIuZmxvYXQoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgNToge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEobWVzc2FnZS5pbnQzMkRhdGEgJiYgbWVzc2FnZS5pbnQzMkRhdGEubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmludDMyRGF0YSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCh0YWcgJiA3KSA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbmQyID0gcmVhZGVyLnVpbnQzMigpICsgcmVhZGVyLnBvcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZDIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaW50MzJEYXRhLnB1c2gocmVhZGVyLmludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pbnQzMkRhdGEucHVzaChyZWFkZXIuaW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgNjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEobWVzc2FnZS5zdHJpbmdEYXRhICYmIG1lc3NhZ2Uuc3RyaW5nRGF0YS5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc3RyaW5nRGF0YSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zdHJpbmdEYXRhLnB1c2gocmVhZGVyLmJ5dGVzKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIDc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKG1lc3NhZ2UuaW50NjREYXRhICYmIG1lc3NhZ2UuaW50NjREYXRhLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pbnQ2NERhdGEgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgodGFnICYgNykgPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZW5kMiA9IHJlYWRlci51aW50MzIoKSArIHJlYWRlci5wb3M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQyKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmludDY0RGF0YS5wdXNoKHJlYWRlci5pbnQ2NCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaW50NjREYXRhLnB1c2gocmVhZGVyLmludDY0KCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIDg6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UubmFtZSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAxMjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5kb2NTdHJpbmcgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgOToge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5yYXdEYXRhID0gcmVhZGVyLmJ5dGVzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgMTM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKG1lc3NhZ2UuZXh0ZXJuYWxEYXRhICYmIG1lc3NhZ2UuZXh0ZXJuYWxEYXRhLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5leHRlcm5hbERhdGEgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZXh0ZXJuYWxEYXRhLnB1c2goJHJvb3Qub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIDE0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmRhdGFMb2NhdGlvbiA9IHJlYWRlci5pbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIDEwOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShtZXNzYWdlLmRvdWJsZURhdGEgJiYgbWVzc2FnZS5kb3VibGVEYXRhLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5kb3VibGVEYXRhID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHRhZyAmIDcpID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVuZDIgPSByZWFkZXIudWludDMyKCkgKyByZWFkZXIucG9zO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kMilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5kb3VibGVEYXRhLnB1c2gocmVhZGVyLmRvdWJsZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZG91YmxlRGF0YS5wdXNoKHJlYWRlci5kb3VibGUoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgMTE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKG1lc3NhZ2UudWludDY0RGF0YSAmJiBtZXNzYWdlLnVpbnQ2NERhdGEubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnVpbnQ2NERhdGEgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgodGFnICYgNykgPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZW5kMiA9IHJlYWRlci51aW50MzIoKSArIHJlYWRlci5wb3M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQyKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnVpbnQ2NERhdGEucHVzaChyZWFkZXIudWludDY0KCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS51aW50NjREYXRhLnB1c2gocmVhZGVyLnVpbnQ2NCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGVjb2RlcyBhIFRlbnNvclByb3RvIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIsIGxlbmd0aCBkZWxpbWl0ZWQuXG4gICAgICAgICAqIEBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWRcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgICAgICogQHJldHVybnMge29ubnguVGVuc29yUHJvdG99IFRlbnNvclByb3RvXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAgICAgKi9cbiAgICAgICAgVGVuc29yUHJvdG8uZGVjb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkKHJlYWRlcikge1xuICAgICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgICAgcmVhZGVyID0gbmV3ICRSZWFkZXIocmVhZGVyKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFZlcmlmaWVzIGEgVGVuc29yUHJvdG8gbWVzc2FnZS5cbiAgICAgICAgICogQGZ1bmN0aW9uIHZlcmlmeVxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JQcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG1lc3NhZ2UgUGxhaW4gb2JqZWN0IHRvIHZlcmlmeVxuICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9IGBudWxsYCBpZiB2YWxpZCwgb3RoZXJ3aXNlIHRoZSByZWFzb24gd2h5IGl0IGlzIG5vdFxuICAgICAgICAgKi9cbiAgICAgICAgVGVuc29yUHJvdG8udmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5KG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSAhPT0gXCJvYmplY3RcIiB8fCBtZXNzYWdlID09PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiBcIm9iamVjdCBleHBlY3RlZFwiO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZGltcyAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJkaW1zXCIpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG1lc3NhZ2UuZGltcykpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImRpbXM6IGFycmF5IGV4cGVjdGVkXCI7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLmRpbXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIGlmICghJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UuZGltc1tpXSkgJiYgIShtZXNzYWdlLmRpbXNbaV0gJiYgJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UuZGltc1tpXS5sb3cpICYmICR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLmRpbXNbaV0uaGlnaCkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiZGltczogaW50ZWdlcnxMb25nW10gZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmRhdGFUeXBlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImRhdGFUeXBlXCIpKVxuICAgICAgICAgICAgICAgIGlmICghJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UuZGF0YVR5cGUpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJkYXRhVHlwZTogaW50ZWdlciBleHBlY3RlZFwiO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2Uuc2VnbWVudCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJzZWdtZW50XCIpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVycm9yID0gJHJvb3Qub25ueC5UZW5zb3JQcm90by5TZWdtZW50LnZlcmlmeShtZXNzYWdlLnNlZ21lbnQpO1xuICAgICAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwic2VnbWVudC5cIiArIGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZmxvYXREYXRhICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImZsb2F0RGF0YVwiKSkge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShtZXNzYWdlLmZsb2F0RGF0YSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImZsb2F0RGF0YTogYXJyYXkgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UuZmxvYXREYXRhLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UuZmxvYXREYXRhW2ldICE9PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiZmxvYXREYXRhOiBudW1iZXJbXSBleHBlY3RlZFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuaW50MzJEYXRhICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImludDMyRGF0YVwiKSkge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShtZXNzYWdlLmludDMyRGF0YSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImludDMyRGF0YTogYXJyYXkgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UuaW50MzJEYXRhLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICBpZiAoISR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLmludDMyRGF0YVtpXSkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJpbnQzMkRhdGE6IGludGVnZXJbXSBleHBlY3RlZFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2Uuc3RyaW5nRGF0YSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJzdHJpbmdEYXRhXCIpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG1lc3NhZ2Uuc3RyaW5nRGF0YSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcInN0cmluZ0RhdGE6IGFycmF5IGV4cGVjdGVkXCI7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLnN0cmluZ0RhdGEubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIGlmICghKG1lc3NhZ2Uuc3RyaW5nRGF0YVtpXSAmJiB0eXBlb2YgbWVzc2FnZS5zdHJpbmdEYXRhW2ldLmxlbmd0aCA9PT0gXCJudW1iZXJcIiB8fCAkdXRpbC5pc1N0cmluZyhtZXNzYWdlLnN0cmluZ0RhdGFbaV0pKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcInN0cmluZ0RhdGE6IGJ1ZmZlcltdIGV4cGVjdGVkXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5pbnQ2NERhdGEgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiaW50NjREYXRhXCIpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG1lc3NhZ2UuaW50NjREYXRhKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiaW50NjREYXRhOiBhcnJheSBleHBlY3RlZFwiO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5pbnQ2NERhdGEubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIGlmICghJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UuaW50NjREYXRhW2ldKSAmJiAhKG1lc3NhZ2UuaW50NjREYXRhW2ldICYmICR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLmludDY0RGF0YVtpXS5sb3cpICYmICR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLmludDY0RGF0YVtpXS5oaWdoKSkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJpbnQ2NERhdGE6IGludGVnZXJ8TG9uZ1tdIGV4cGVjdGVkXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5uYW1lICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIm5hbWVcIikpXG4gICAgICAgICAgICAgICAgaWYgKCEkdXRpbC5pc1N0cmluZyhtZXNzYWdlLm5hbWUpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJuYW1lOiBzdHJpbmcgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmRvY1N0cmluZyAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJkb2NTdHJpbmdcIikpXG4gICAgICAgICAgICAgICAgaWYgKCEkdXRpbC5pc1N0cmluZyhtZXNzYWdlLmRvY1N0cmluZykpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImRvY1N0cmluZzogc3RyaW5nIGV4cGVjdGVkXCI7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5yYXdEYXRhICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInJhd0RhdGFcIikpXG4gICAgICAgICAgICAgICAgaWYgKCEobWVzc2FnZS5yYXdEYXRhICYmIHR5cGVvZiBtZXNzYWdlLnJhd0RhdGEubGVuZ3RoID09PSBcIm51bWJlclwiIHx8ICR1dGlsLmlzU3RyaW5nKG1lc3NhZ2UucmF3RGF0YSkpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJyYXdEYXRhOiBidWZmZXIgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmV4dGVybmFsRGF0YSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJleHRlcm5hbERhdGFcIikpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobWVzc2FnZS5leHRlcm5hbERhdGEpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJleHRlcm5hbERhdGE6IGFycmF5IGV4cGVjdGVkXCI7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLmV4dGVybmFsRGF0YS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXJyb3IgPSAkcm9vdC5vbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG8udmVyaWZ5KG1lc3NhZ2UuZXh0ZXJuYWxEYXRhW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiZXh0ZXJuYWxEYXRhLlwiICsgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZGF0YUxvY2F0aW9uICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImRhdGFMb2NhdGlvblwiKSlcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKG1lc3NhZ2UuZGF0YUxvY2F0aW9uKSB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiZGF0YUxvY2F0aW9uOiBlbnVtIHZhbHVlIGV4cGVjdGVkXCI7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZG91YmxlRGF0YSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJkb3VibGVEYXRhXCIpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG1lc3NhZ2UuZG91YmxlRGF0YSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImRvdWJsZURhdGE6IGFycmF5IGV4cGVjdGVkXCI7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLmRvdWJsZURhdGEubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZS5kb3VibGVEYXRhW2ldICE9PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiZG91YmxlRGF0YTogbnVtYmVyW10gZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnVpbnQ2NERhdGEgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwidWludDY0RGF0YVwiKSkge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShtZXNzYWdlLnVpbnQ2NERhdGEpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJ1aW50NjREYXRhOiBhcnJheSBleHBlY3RlZFwiO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS51aW50NjREYXRhLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICBpZiAoISR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLnVpbnQ2NERhdGFbaV0pICYmICEobWVzc2FnZS51aW50NjREYXRhW2ldICYmICR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLnVpbnQ2NERhdGFbaV0ubG93KSAmJiAkdXRpbC5pc0ludGVnZXIobWVzc2FnZS51aW50NjREYXRhW2ldLmhpZ2gpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcInVpbnQ2NERhdGE6IGludGVnZXJ8TG9uZ1tdIGV4cGVjdGVkXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIFRlbnNvclByb3RvIG1lc3NhZ2UgZnJvbSBhIHBsYWluIG9iamVjdC4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gdGhlaXIgcmVzcGVjdGl2ZSBpbnRlcm5hbCB0eXBlcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGZyb21PYmplY3RcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBvYmplY3QgUGxhaW4gb2JqZWN0XG4gICAgICAgICAqIEByZXR1cm5zIHtvbm54LlRlbnNvclByb3RvfSBUZW5zb3JQcm90b1xuICAgICAgICAgKi9cbiAgICAgICAgVGVuc29yUHJvdG8uZnJvbU9iamVjdCA9IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgJHJvb3Qub25ueC5UZW5zb3JQcm90bylcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBuZXcgJHJvb3Qub25ueC5UZW5zb3JQcm90bygpO1xuICAgICAgICAgICAgaWYgKG9iamVjdC5kaW1zKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9iamVjdC5kaW1zKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguVGVuc29yUHJvdG8uZGltczogYXJyYXkgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5kaW1zID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3QuZGltcy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKCR1dGlsLkxvbmcpXG4gICAgICAgICAgICAgICAgICAgICAgICAobWVzc2FnZS5kaW1zW2ldID0gJHV0aWwuTG9uZy5mcm9tVmFsdWUob2JqZWN0LmRpbXNbaV0pKS51bnNpZ25lZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LmRpbXNbaV0gPT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmRpbXNbaV0gPSBwYXJzZUludChvYmplY3QuZGltc1tpXSwgMTApO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LmRpbXNbaV0gPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmRpbXNbaV0gPSBvYmplY3QuZGltc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC5kaW1zW2ldID09PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5kaW1zW2ldID0gbmV3ICR1dGlsLkxvbmdCaXRzKG9iamVjdC5kaW1zW2ldLmxvdyA+Pj4gMCwgb2JqZWN0LmRpbXNbaV0uaGlnaCA+Pj4gMCkudG9OdW1iZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvYmplY3QuZGF0YVR5cGUgIT0gbnVsbClcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmRhdGFUeXBlID0gb2JqZWN0LmRhdGFUeXBlIHwgMDtcbiAgICAgICAgICAgIGlmIChvYmplY3Quc2VnbWVudCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3Quc2VnbWVudCAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguVGVuc29yUHJvdG8uc2VnbWVudDogb2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc2VnbWVudCA9ICRyb290Lm9ubnguVGVuc29yUHJvdG8uU2VnbWVudC5mcm9tT2JqZWN0KG9iamVjdC5zZWdtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvYmplY3QuZmxvYXREYXRhKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9iamVjdC5mbG9hdERhdGEpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5UZW5zb3JQcm90by5mbG9hdERhdGE6IGFycmF5IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UuZmxvYXREYXRhID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3QuZmxvYXREYXRhLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmZsb2F0RGF0YVtpXSA9IE51bWJlcihvYmplY3QuZmxvYXREYXRhW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvYmplY3QuaW50MzJEYXRhKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9iamVjdC5pbnQzMkRhdGEpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5UZW5zb3JQcm90by5pbnQzMkRhdGE6IGFycmF5IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UuaW50MzJEYXRhID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3QuaW50MzJEYXRhLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmludDMyRGF0YVtpXSA9IG9iamVjdC5pbnQzMkRhdGFbaV0gfCAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9iamVjdC5zdHJpbmdEYXRhKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9iamVjdC5zdHJpbmdEYXRhKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguVGVuc29yUHJvdG8uc3RyaW5nRGF0YTogYXJyYXkgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5zdHJpbmdEYXRhID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3Quc3RyaW5nRGF0YS5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3Quc3RyaW5nRGF0YVtpXSA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICR1dGlsLmJhc2U2NC5kZWNvZGUob2JqZWN0LnN0cmluZ0RhdGFbaV0sIG1lc3NhZ2Uuc3RyaW5nRGF0YVtpXSA9ICR1dGlsLm5ld0J1ZmZlcigkdXRpbC5iYXNlNjQubGVuZ3RoKG9iamVjdC5zdHJpbmdEYXRhW2ldKSksIDApO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChvYmplY3Quc3RyaW5nRGF0YVtpXS5sZW5ndGggPj0gMClcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc3RyaW5nRGF0YVtpXSA9IG9iamVjdC5zdHJpbmdEYXRhW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9iamVjdC5pbnQ2NERhdGEpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqZWN0LmludDY0RGF0YSkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5vbm54LlRlbnNvclByb3RvLmludDY0RGF0YTogYXJyYXkgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5pbnQ2NERhdGEgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdC5pbnQ2NERhdGEubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIGlmICgkdXRpbC5Mb25nKVxuICAgICAgICAgICAgICAgICAgICAgICAgKG1lc3NhZ2UuaW50NjREYXRhW2ldID0gJHV0aWwuTG9uZy5mcm9tVmFsdWUob2JqZWN0LmludDY0RGF0YVtpXSkpLnVuc2lnbmVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QuaW50NjREYXRhW2ldID09PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pbnQ2NERhdGFbaV0gPSBwYXJzZUludChvYmplY3QuaW50NjREYXRhW2ldLCAxMCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QuaW50NjREYXRhW2ldID09PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pbnQ2NERhdGFbaV0gPSBvYmplY3QuaW50NjREYXRhW2ldO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LmludDY0RGF0YVtpXSA9PT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaW50NjREYXRhW2ldID0gbmV3ICR1dGlsLkxvbmdCaXRzKG9iamVjdC5pbnQ2NERhdGFbaV0ubG93ID4+PiAwLCBvYmplY3QuaW50NjREYXRhW2ldLmhpZ2ggPj4+IDApLnRvTnVtYmVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2JqZWN0Lm5hbWUgIT0gbnVsbClcbiAgICAgICAgICAgICAgICBtZXNzYWdlLm5hbWUgPSBTdHJpbmcob2JqZWN0Lm5hbWUpO1xuICAgICAgICAgICAgaWYgKG9iamVjdC5kb2NTdHJpbmcgIT0gbnVsbClcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmRvY1N0cmluZyA9IFN0cmluZyhvYmplY3QuZG9jU3RyaW5nKTtcbiAgICAgICAgICAgIGlmIChvYmplY3QucmF3RGF0YSAhPSBudWxsKVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LnJhd0RhdGEgPT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgICAgICR1dGlsLmJhc2U2NC5kZWNvZGUob2JqZWN0LnJhd0RhdGEsIG1lc3NhZ2UucmF3RGF0YSA9ICR1dGlsLm5ld0J1ZmZlcigkdXRpbC5iYXNlNjQubGVuZ3RoKG9iamVjdC5yYXdEYXRhKSksIDApO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9iamVjdC5yYXdEYXRhLmxlbmd0aCA+PSAwKVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnJhd0RhdGEgPSBvYmplY3QucmF3RGF0YTtcbiAgICAgICAgICAgIGlmIChvYmplY3QuZXh0ZXJuYWxEYXRhKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9iamVjdC5leHRlcm5hbERhdGEpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5UZW5zb3JQcm90by5leHRlcm5hbERhdGE6IGFycmF5IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UuZXh0ZXJuYWxEYXRhID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3QuZXh0ZXJuYWxEYXRhLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LmV4dGVybmFsRGF0YVtpXSAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5vbm54LlRlbnNvclByb3RvLmV4dGVybmFsRGF0YTogb2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmV4dGVybmFsRGF0YVtpXSA9ICRyb290Lm9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90by5mcm9tT2JqZWN0KG9iamVjdC5leHRlcm5hbERhdGFbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN3aXRjaCAob2JqZWN0LmRhdGFMb2NhdGlvbikge1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5kYXRhTG9jYXRpb24gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5kYXRhTG9jYXRpb24gPSBvYmplY3QuZGF0YUxvY2F0aW9uO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiREVGQVVMVFwiOlxuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIG1lc3NhZ2UuZGF0YUxvY2F0aW9uID0gMDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJFWFRFUk5BTFwiOlxuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIG1lc3NhZ2UuZGF0YUxvY2F0aW9uID0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvYmplY3QuZG91YmxlRGF0YSkge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvYmplY3QuZG91YmxlRGF0YSkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5vbm54LlRlbnNvclByb3RvLmRvdWJsZURhdGE6IGFycmF5IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UuZG91YmxlRGF0YSA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0LmRvdWJsZURhdGEubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZG91YmxlRGF0YVtpXSA9IE51bWJlcihvYmplY3QuZG91YmxlRGF0YVtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2JqZWN0LnVpbnQ2NERhdGEpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqZWN0LnVpbnQ2NERhdGEpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5UZW5zb3JQcm90by51aW50NjREYXRhOiBhcnJheSBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnVpbnQ2NERhdGEgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdC51aW50NjREYXRhLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICBpZiAoJHV0aWwuTG9uZylcbiAgICAgICAgICAgICAgICAgICAgICAgIChtZXNzYWdlLnVpbnQ2NERhdGFbaV0gPSAkdXRpbC5Mb25nLmZyb21WYWx1ZShvYmplY3QudWludDY0RGF0YVtpXSkpLnVuc2lnbmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC51aW50NjREYXRhW2ldID09PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS51aW50NjREYXRhW2ldID0gcGFyc2VJbnQob2JqZWN0LnVpbnQ2NERhdGFbaV0sIDEwKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC51aW50NjREYXRhW2ldID09PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS51aW50NjREYXRhW2ldID0gb2JqZWN0LnVpbnQ2NERhdGFbaV07XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QudWludDY0RGF0YVtpXSA9PT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudWludDY0RGF0YVtpXSA9IG5ldyAkdXRpbC5Mb25nQml0cyhvYmplY3QudWludDY0RGF0YVtpXS5sb3cgPj4+IDAsIG9iamVjdC51aW50NjREYXRhW2ldLmhpZ2ggPj4+IDApLnRvTnVtYmVyKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBwbGFpbiBvYmplY3QgZnJvbSBhIFRlbnNvclByb3RvIG1lc3NhZ2UuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIG90aGVyIHR5cGVzIGlmIHNwZWNpZmllZC5cbiAgICAgICAgICogQGZ1bmN0aW9uIHRvT2JqZWN0XG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclByb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtvbm54LlRlbnNvclByb3RvfSBtZXNzYWdlIFRlbnNvclByb3RvXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLklDb252ZXJzaW9uT3B0aW9uc30gW29wdGlvbnNdIENvbnZlcnNpb24gb3B0aW9uc1xuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IFBsYWluIG9iamVjdFxuICAgICAgICAgKi9cbiAgICAgICAgVGVuc29yUHJvdG8udG9PYmplY3QgPSBmdW5jdGlvbiB0b09iamVjdChtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMpXG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgICAgdmFyIG9iamVjdCA9IHt9O1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuYXJyYXlzIHx8IG9wdGlvbnMuZGVmYXVsdHMpIHtcbiAgICAgICAgICAgICAgICBvYmplY3QuZGltcyA9IFtdO1xuICAgICAgICAgICAgICAgIG9iamVjdC5mbG9hdERhdGEgPSBbXTtcbiAgICAgICAgICAgICAgICBvYmplY3QuaW50MzJEYXRhID0gW107XG4gICAgICAgICAgICAgICAgb2JqZWN0LnN0cmluZ0RhdGEgPSBbXTtcbiAgICAgICAgICAgICAgICBvYmplY3QuaW50NjREYXRhID0gW107XG4gICAgICAgICAgICAgICAgb2JqZWN0LmRvdWJsZURhdGEgPSBbXTtcbiAgICAgICAgICAgICAgICBvYmplY3QudWludDY0RGF0YSA9IFtdO1xuICAgICAgICAgICAgICAgIG9iamVjdC5leHRlcm5hbERhdGEgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmRlZmF1bHRzKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0LmRhdGFUeXBlID0gMDtcbiAgICAgICAgICAgICAgICBvYmplY3Quc2VnbWVudCA9IG51bGw7XG4gICAgICAgICAgICAgICAgb2JqZWN0Lm5hbWUgPSBcIlwiO1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmJ5dGVzID09PSBTdHJpbmcpXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5yYXdEYXRhID0gXCJcIjtcbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LnJhd0RhdGEgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuYnl0ZXMgIT09IEFycmF5KVxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0LnJhd0RhdGEgPSAkdXRpbC5uZXdCdWZmZXIob2JqZWN0LnJhd0RhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvYmplY3QuZG9jU3RyaW5nID0gXCJcIjtcbiAgICAgICAgICAgICAgICBvYmplY3QuZGF0YUxvY2F0aW9uID0gb3B0aW9ucy5lbnVtcyA9PT0gU3RyaW5nID8gXCJERUZBVUxUXCIgOiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZGltcyAmJiBtZXNzYWdlLmRpbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0LmRpbXMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1lc3NhZ2UuZGltcy5sZW5ndGg7ICsrailcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlLmRpbXNbal0gPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBvYmplY3QuZGltc1tqXSA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/IFN0cmluZyhtZXNzYWdlLmRpbXNbal0pIDogbWVzc2FnZS5kaW1zW2pdO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBvYmplY3QuZGltc1tqXSA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/ICR1dGlsLkxvbmcucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobWVzc2FnZS5kaW1zW2pdKSA6IG9wdGlvbnMubG9uZ3MgPT09IE51bWJlciA/IG5ldyAkdXRpbC5Mb25nQml0cyhtZXNzYWdlLmRpbXNbal0ubG93ID4+PiAwLCBtZXNzYWdlLmRpbXNbal0uaGlnaCA+Pj4gMCkudG9OdW1iZXIoKSA6IG1lc3NhZ2UuZGltc1tqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmRhdGFUeXBlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImRhdGFUeXBlXCIpKVxuICAgICAgICAgICAgICAgIG9iamVjdC5kYXRhVHlwZSA9IG1lc3NhZ2UuZGF0YVR5cGU7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5zZWdtZW50ICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInNlZ21lbnRcIikpXG4gICAgICAgICAgICAgICAgb2JqZWN0LnNlZ21lbnQgPSAkcm9vdC5vbm54LlRlbnNvclByb3RvLlNlZ21lbnQudG9PYmplY3QobWVzc2FnZS5zZWdtZW50LCBvcHRpb25zKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmZsb2F0RGF0YSAmJiBtZXNzYWdlLmZsb2F0RGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBvYmplY3QuZmxvYXREYXRhID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtZXNzYWdlLmZsb2F0RGF0YS5sZW5ndGg7ICsrailcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LmZsb2F0RGF0YVtqXSA9IG9wdGlvbnMuanNvbiAmJiAhaXNGaW5pdGUobWVzc2FnZS5mbG9hdERhdGFbal0pID8gU3RyaW5nKG1lc3NhZ2UuZmxvYXREYXRhW2pdKSA6IG1lc3NhZ2UuZmxvYXREYXRhW2pdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuaW50MzJEYXRhICYmIG1lc3NhZ2UuaW50MzJEYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIG9iamVjdC5pbnQzMkRhdGEgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1lc3NhZ2UuaW50MzJEYXRhLmxlbmd0aDsgKytqKVxuICAgICAgICAgICAgICAgICAgICBvYmplY3QuaW50MzJEYXRhW2pdID0gbWVzc2FnZS5pbnQzMkRhdGFbal07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5zdHJpbmdEYXRhICYmIG1lc3NhZ2Uuc3RyaW5nRGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBvYmplY3Quc3RyaW5nRGF0YSA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWVzc2FnZS5zdHJpbmdEYXRhLmxlbmd0aDsgKytqKVxuICAgICAgICAgICAgICAgICAgICBvYmplY3Quc3RyaW5nRGF0YVtqXSA9IG9wdGlvbnMuYnl0ZXMgPT09IFN0cmluZyA/ICR1dGlsLmJhc2U2NC5lbmNvZGUobWVzc2FnZS5zdHJpbmdEYXRhW2pdLCAwLCBtZXNzYWdlLnN0cmluZ0RhdGFbal0ubGVuZ3RoKSA6IG9wdGlvbnMuYnl0ZXMgPT09IEFycmF5ID8gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwobWVzc2FnZS5zdHJpbmdEYXRhW2pdKSA6IG1lc3NhZ2Uuc3RyaW5nRGF0YVtqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmludDY0RGF0YSAmJiBtZXNzYWdlLmludDY0RGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBvYmplY3QuaW50NjREYXRhID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtZXNzYWdlLmludDY0RGF0YS5sZW5ndGg7ICsrailcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlLmludDY0RGF0YVtqXSA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdC5pbnQ2NERhdGFbal0gPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyBTdHJpbmcobWVzc2FnZS5pbnQ2NERhdGFbal0pIDogbWVzc2FnZS5pbnQ2NERhdGFbal07XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdC5pbnQ2NERhdGFbal0gPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyAkdXRpbC5Mb25nLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG1lc3NhZ2UuaW50NjREYXRhW2pdKSA6IG9wdGlvbnMubG9uZ3MgPT09IE51bWJlciA/IG5ldyAkdXRpbC5Mb25nQml0cyhtZXNzYWdlLmludDY0RGF0YVtqXS5sb3cgPj4+IDAsIG1lc3NhZ2UuaW50NjREYXRhW2pdLmhpZ2ggPj4+IDApLnRvTnVtYmVyKCkgOiBtZXNzYWdlLmludDY0RGF0YVtqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm5hbWUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwibmFtZVwiKSlcbiAgICAgICAgICAgICAgICBvYmplY3QubmFtZSA9IG1lc3NhZ2UubmFtZTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnJhd0RhdGEgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwicmF3RGF0YVwiKSlcbiAgICAgICAgICAgICAgICBvYmplY3QucmF3RGF0YSA9IG9wdGlvbnMuYnl0ZXMgPT09IFN0cmluZyA/ICR1dGlsLmJhc2U2NC5lbmNvZGUobWVzc2FnZS5yYXdEYXRhLCAwLCBtZXNzYWdlLnJhd0RhdGEubGVuZ3RoKSA6IG9wdGlvbnMuYnl0ZXMgPT09IEFycmF5ID8gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwobWVzc2FnZS5yYXdEYXRhKSA6IG1lc3NhZ2UucmF3RGF0YTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmRvdWJsZURhdGEgJiYgbWVzc2FnZS5kb3VibGVEYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIG9iamVjdC5kb3VibGVEYXRhID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtZXNzYWdlLmRvdWJsZURhdGEubGVuZ3RoOyArK2opXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5kb3VibGVEYXRhW2pdID0gb3B0aW9ucy5qc29uICYmICFpc0Zpbml0ZShtZXNzYWdlLmRvdWJsZURhdGFbal0pID8gU3RyaW5nKG1lc3NhZ2UuZG91YmxlRGF0YVtqXSkgOiBtZXNzYWdlLmRvdWJsZURhdGFbal07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS51aW50NjREYXRhICYmIG1lc3NhZ2UudWludDY0RGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBvYmplY3QudWludDY0RGF0YSA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWVzc2FnZS51aW50NjREYXRhLmxlbmd0aDsgKytqKVxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UudWludDY0RGF0YVtqXSA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdC51aW50NjREYXRhW2pdID0gb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nID8gU3RyaW5nKG1lc3NhZ2UudWludDY0RGF0YVtqXSkgOiBtZXNzYWdlLnVpbnQ2NERhdGFbal07XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdC51aW50NjREYXRhW2pdID0gb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nID8gJHV0aWwuTG9uZy5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChtZXNzYWdlLnVpbnQ2NERhdGFbal0pIDogb3B0aW9ucy5sb25ncyA9PT0gTnVtYmVyID8gbmV3ICR1dGlsLkxvbmdCaXRzKG1lc3NhZ2UudWludDY0RGF0YVtqXS5sb3cgPj4+IDAsIG1lc3NhZ2UudWludDY0RGF0YVtqXS5oaWdoID4+PiAwKS50b051bWJlcih0cnVlKSA6IG1lc3NhZ2UudWludDY0RGF0YVtqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmRvY1N0cmluZyAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJkb2NTdHJpbmdcIikpXG4gICAgICAgICAgICAgICAgb2JqZWN0LmRvY1N0cmluZyA9IG1lc3NhZ2UuZG9jU3RyaW5nO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZXh0ZXJuYWxEYXRhICYmIG1lc3NhZ2UuZXh0ZXJuYWxEYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIG9iamVjdC5leHRlcm5hbERhdGEgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1lc3NhZ2UuZXh0ZXJuYWxEYXRhLmxlbmd0aDsgKytqKVxuICAgICAgICAgICAgICAgICAgICBvYmplY3QuZXh0ZXJuYWxEYXRhW2pdID0gJHJvb3Qub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvLnRvT2JqZWN0KG1lc3NhZ2UuZXh0ZXJuYWxEYXRhW2pdLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmRhdGFMb2NhdGlvbiAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJkYXRhTG9jYXRpb25cIikpXG4gICAgICAgICAgICAgICAgb2JqZWN0LmRhdGFMb2NhdGlvbiA9IG9wdGlvbnMuZW51bXMgPT09IFN0cmluZyA/ICRyb290Lm9ubnguVGVuc29yUHJvdG8uRGF0YUxvY2F0aW9uW21lc3NhZ2UuZGF0YUxvY2F0aW9uXSA9PT0gdW5kZWZpbmVkID8gbWVzc2FnZS5kYXRhTG9jYXRpb24gOiAkcm9vdC5vbm54LlRlbnNvclByb3RvLkRhdGFMb2NhdGlvblttZXNzYWdlLmRhdGFMb2NhdGlvbl0gOiBtZXNzYWdlLmRhdGFMb2NhdGlvbjtcbiAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlcnRzIHRoaXMgVGVuc29yUHJvdG8gdG8gSlNPTi5cbiAgICAgICAgICogQGZ1bmN0aW9uIHRvSlNPTlxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JQcm90b1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBKU09OIG9iamVjdFxuICAgICAgICAgKi9cbiAgICAgICAgVGVuc29yUHJvdG8ucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsICRwcm90b2J1Zi51dGlsLnRvSlNPTk9wdGlvbnMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIHRoZSBkZWZhdWx0IHR5cGUgdXJsIGZvciBUZW5zb3JQcm90b1xuICAgICAgICAgKiBAZnVuY3Rpb24gZ2V0VHlwZVVybFxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JQcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbdHlwZVVybFByZWZpeF0geW91ciBjdXN0b20gdHlwZVVybFByZWZpeChkZWZhdWx0IFwidHlwZS5nb29nbGVhcGlzLmNvbVwiKVxuICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgZGVmYXVsdCB0eXBlIHVybFxuICAgICAgICAgKi9cbiAgICAgICAgVGVuc29yUHJvdG8uZ2V0VHlwZVVybCA9IGZ1bmN0aW9uIGdldFR5cGVVcmwodHlwZVVybFByZWZpeCkge1xuICAgICAgICAgICAgaWYgKHR5cGVVcmxQcmVmaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHR5cGVVcmxQcmVmaXggPSBcInR5cGUuZ29vZ2xlYXBpcy5jb21cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0eXBlVXJsUHJlZml4ICsgXCIvb25ueC5UZW5zb3JQcm90b1wiO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEYXRhVHlwZSBlbnVtLlxuICAgICAgICAgKiBAbmFtZSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlXG4gICAgICAgICAqIEBlbnVtIHtudW1iZXJ9XG4gICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBVTkRFRklORUQ9MCBVTkRFRklORUQgdmFsdWVcbiAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IEZMT0FUPTEgRkxPQVQgdmFsdWVcbiAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IFVJTlQ4PTIgVUlOVDggdmFsdWVcbiAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IElOVDg9MyBJTlQ4IHZhbHVlXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBVSU5UMTY9NCBVSU5UMTYgdmFsdWVcbiAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IElOVDE2PTUgSU5UMTYgdmFsdWVcbiAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IElOVDMyPTYgSU5UMzIgdmFsdWVcbiAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IElOVDY0PTcgSU5UNjQgdmFsdWVcbiAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IFNUUklORz04IFNUUklORyB2YWx1ZVxuICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcn0gQk9PTD05IEJPT0wgdmFsdWVcbiAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IEZMT0FUMTY9MTAgRkxPQVQxNiB2YWx1ZVxuICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcn0gRE9VQkxFPTExIERPVUJMRSB2YWx1ZVxuICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcn0gVUlOVDMyPTEyIFVJTlQzMiB2YWx1ZVxuICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcn0gVUlOVDY0PTEzIFVJTlQ2NCB2YWx1ZVxuICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcn0gQ09NUExFWDY0PTE0IENPTVBMRVg2NCB2YWx1ZVxuICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcn0gQ09NUExFWDEyOD0xNSBDT01QTEVYMTI4IHZhbHVlXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBCRkxPQVQxNj0xNiBCRkxPQVQxNiB2YWx1ZVxuICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcn0gRkxPQVQ4RTRNM0ZOPTE3IEZMT0FUOEU0TTNGTiB2YWx1ZVxuICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcn0gRkxPQVQ4RTRNM0ZOVVo9MTggRkxPQVQ4RTRNM0ZOVVogdmFsdWVcbiAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IEZMT0FUOEU1TTI9MTkgRkxPQVQ4RTVNMiB2YWx1ZVxuICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcn0gRkxPQVQ4RTVNMkZOVVo9MjAgRkxPQVQ4RTVNMkZOVVogdmFsdWVcbiAgICAgICAgICovXG4gICAgICAgIFRlbnNvclByb3RvLkRhdGFUeXBlID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHZhbHVlc0J5SWQgPSB7fSwgdmFsdWVzID0gT2JqZWN0LmNyZWF0ZSh2YWx1ZXNCeUlkKTtcbiAgICAgICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzBdID0gXCJVTkRFRklORURcIl0gPSAwO1xuICAgICAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbMV0gPSBcIkZMT0FUXCJdID0gMTtcbiAgICAgICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzJdID0gXCJVSU5UOFwiXSA9IDI7XG4gICAgICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFszXSA9IFwiSU5UOFwiXSA9IDM7XG4gICAgICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFs0XSA9IFwiVUlOVDE2XCJdID0gNDtcbiAgICAgICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzVdID0gXCJJTlQxNlwiXSA9IDU7XG4gICAgICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFs2XSA9IFwiSU5UMzJcIl0gPSA2O1xuICAgICAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbN10gPSBcIklOVDY0XCJdID0gNztcbiAgICAgICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzhdID0gXCJTVFJJTkdcIl0gPSA4O1xuICAgICAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbOV0gPSBcIkJPT0xcIl0gPSA5O1xuICAgICAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbMTBdID0gXCJGTE9BVDE2XCJdID0gMTA7XG4gICAgICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFsxMV0gPSBcIkRPVUJMRVwiXSA9IDExO1xuICAgICAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbMTJdID0gXCJVSU5UMzJcIl0gPSAxMjtcbiAgICAgICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzEzXSA9IFwiVUlOVDY0XCJdID0gMTM7XG4gICAgICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFsxNF0gPSBcIkNPTVBMRVg2NFwiXSA9IDE0O1xuICAgICAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbMTVdID0gXCJDT01QTEVYMTI4XCJdID0gMTU7XG4gICAgICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFsxNl0gPSBcIkJGTE9BVDE2XCJdID0gMTY7XG4gICAgICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFsxN10gPSBcIkZMT0FUOEU0TTNGTlwiXSA9IDE3O1xuICAgICAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbMThdID0gXCJGTE9BVDhFNE0zRk5VWlwiXSA9IDE4O1xuICAgICAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbMTldID0gXCJGTE9BVDhFNU0yXCJdID0gMTk7XG4gICAgICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFsyMF0gPSBcIkZMT0FUOEU1TTJGTlVaXCJdID0gMjA7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgICAgICB9KSgpO1xuXG4gICAgICAgIFRlbnNvclByb3RvLlNlZ21lbnQgPSAoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUHJvcGVydGllcyBvZiBhIFNlZ21lbnQuXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JQcm90b1xuICAgICAgICAgICAgICogQGludGVyZmFjZSBJU2VnbWVudFxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ8TG9uZ3xudWxsfSBbYmVnaW5dIFNlZ21lbnQgYmVnaW5cbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfExvbmd8bnVsbH0gW2VuZF0gU2VnbWVudCBlbmRcbiAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIENvbnN0cnVjdHMgYSBuZXcgU2VnbWVudC5cbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclByb3RvXG4gICAgICAgICAgICAgKiBAY2xhc3NkZXNjIFJlcHJlc2VudHMgYSBTZWdtZW50LlxuICAgICAgICAgICAgICogQGltcGxlbWVudHMgSVNlZ21lbnRcbiAgICAgICAgICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAgICAgICAgICogQHBhcmFtIHtvbm54LlRlbnNvclByb3RvLklTZWdtZW50PX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIFNlZ21lbnQocHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzKVxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvcGVydGllcyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzW2tleXNbaV1dICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1trZXlzW2ldXSA9IHByb3BlcnRpZXNba2V5c1tpXV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogU2VnbWVudCBiZWdpbi5cbiAgICAgICAgICAgICAqIEBtZW1iZXIge251bWJlcnxMb25nfSBiZWdpblxuICAgICAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yUHJvdG8uU2VnbWVudFxuICAgICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFNlZ21lbnQucHJvdG90eXBlLmJlZ2luID0gJHV0aWwuTG9uZyA/ICR1dGlsLkxvbmcuZnJvbUJpdHMoMCwwLGZhbHNlKSA6IDA7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogU2VnbWVudCBlbmQuXG4gICAgICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ8TG9uZ30gZW5kXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JQcm90by5TZWdtZW50XG4gICAgICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgU2VnbWVudC5wcm90b3R5cGUuZW5kID0gJHV0aWwuTG9uZyA/ICR1dGlsLkxvbmcuZnJvbUJpdHMoMCwwLGZhbHNlKSA6IDA7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ3JlYXRlcyBhIG5ldyBTZWdtZW50IGluc3RhbmNlIHVzaW5nIHRoZSBzcGVjaWZpZWQgcHJvcGVydGllcy5cbiAgICAgICAgICAgICAqIEBmdW5jdGlvbiBjcmVhdGVcbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclByb3RvLlNlZ21lbnRcbiAgICAgICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICAgICAqIEBwYXJhbSB7b25ueC5UZW5zb3JQcm90by5JU2VnbWVudD19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxuICAgICAgICAgICAgICogQHJldHVybnMge29ubnguVGVuc29yUHJvdG8uU2VnbWVudH0gU2VnbWVudCBpbnN0YW5jZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBTZWdtZW50LmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTZWdtZW50KHByb3BlcnRpZXMpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgU2VnbWVudCBtZXNzYWdlLiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayBvbm54LlRlbnNvclByb3RvLlNlZ21lbnQudmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXG4gICAgICAgICAgICAgKiBAZnVuY3Rpb24gZW5jb2RlXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JQcm90by5TZWdtZW50XG4gICAgICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAgICAgKiBAcGFyYW0ge29ubnguVGVuc29yUHJvdG8uSVNlZ21lbnR9IG1lc3NhZ2UgU2VnbWVudCBtZXNzYWdlIG9yIHBsYWluIG9iamVjdCB0byBlbmNvZGVcbiAgICAgICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLldyaXRlcn0gW3dyaXRlcl0gV3JpdGVyIHRvIGVuY29kZSB0b1xuICAgICAgICAgICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBTZWdtZW50LmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXdyaXRlcilcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVyID0gJFdyaXRlci5jcmVhdGUoKTtcbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZS5iZWdpbiAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwiYmVnaW5cIikpXG4gICAgICAgICAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMSwgd2lyZVR5cGUgMCA9Ki84KS5pbnQ2NChtZXNzYWdlLmJlZ2luKTtcbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZS5lbmQgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcImVuZFwiKSlcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCAyLCB3aXJlVHlwZSAwID0qLzE2KS5pbnQ2NChtZXNzYWdlLmVuZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRW5jb2RlcyB0aGUgc3BlY2lmaWVkIFNlZ21lbnQgbWVzc2FnZSwgbGVuZ3RoIGRlbGltaXRlZC4gRG9lcyBub3QgaW1wbGljaXRseSB7QGxpbmsgb25ueC5UZW5zb3JQcm90by5TZWdtZW50LnZlcmlmeXx2ZXJpZnl9IG1lc3NhZ2VzLlxuICAgICAgICAgICAgICogQGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZFxuICAgICAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yUHJvdG8uU2VnbWVudFxuICAgICAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgICAgICogQHBhcmFtIHtvbm54LlRlbnNvclByb3RvLklTZWdtZW50fSBtZXNzYWdlIFNlZ21lbnQgbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXG4gICAgICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAgICAgICAgICAgICAqIEByZXR1cm5zIHskcHJvdG9idWYuV3JpdGVyfSBXcml0ZXJcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgU2VnbWVudC5lbmNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWQobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikubGRlbGltKCk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIERlY29kZXMgYSBTZWdtZW50IG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIuXG4gICAgICAgICAgICAgKiBAZnVuY3Rpb24gZGVjb2RlXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JQcm90by5TZWdtZW50XG4gICAgICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoXSBNZXNzYWdlIGxlbmd0aCBpZiBrbm93biBiZWZvcmVoYW5kXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7b25ueC5UZW5zb3JQcm90by5TZWdtZW50fSBTZWdtZW50XG4gICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAgICAgICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFNlZ21lbnQuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHJlYWRlciwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgICAgICAgIHJlYWRlciA9ICRSZWFkZXIuY3JlYXRlKHJlYWRlcik7XG4gICAgICAgICAgICAgICAgdmFyIGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGgsIG1lc3NhZ2UgPSBuZXcgJHJvb3Qub25ueC5UZW5zb3JQcm90by5TZWdtZW50KCk7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5iZWdpbiA9IHJlYWRlci5pbnQ2NCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmVuZCA9IHJlYWRlci5pbnQ2NCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIERlY29kZXMgYSBTZWdtZW50IG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIsIGxlbmd0aCBkZWxpbWl0ZWQuXG4gICAgICAgICAgICAgKiBAZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JQcm90by5TZWdtZW50XG4gICAgICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtvbm54LlRlbnNvclByb3RvLlNlZ21lbnR9IFNlZ21lbnRcbiAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICAgICAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgU2VnbWVudC5kZWNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWQocmVhZGVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgICAgICAgIHJlYWRlciA9IG5ldyAkUmVhZGVyKHJlYWRlcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVmVyaWZpZXMgYSBTZWdtZW50IG1lc3NhZ2UuXG4gICAgICAgICAgICAgKiBAZnVuY3Rpb24gdmVyaWZ5XG4gICAgICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JQcm90by5TZWdtZW50XG4gICAgICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBtZXNzYWdlIFBsYWluIG9iamVjdCB0byB2ZXJpZnlcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd8bnVsbH0gYG51bGxgIGlmIHZhbGlkLCBvdGhlcndpc2UgdGhlIHJlYXNvbiB3aHkgaXQgaXMgbm90XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFNlZ21lbnQudmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5KG1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgIT09IFwib2JqZWN0XCIgfHwgbWVzc2FnZSA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwib2JqZWN0IGV4cGVjdGVkXCI7XG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UuYmVnaW4gIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiYmVnaW5cIikpXG4gICAgICAgICAgICAgICAgICAgIGlmICghJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UuYmVnaW4pICYmICEobWVzc2FnZS5iZWdpbiAmJiAkdXRpbC5pc0ludGVnZXIobWVzc2FnZS5iZWdpbi5sb3cpICYmICR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLmJlZ2luLmhpZ2gpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcImJlZ2luOiBpbnRlZ2VyfExvbmcgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZS5lbmQgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZW5kXCIpKVxuICAgICAgICAgICAgICAgICAgICBpZiAoISR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLmVuZCkgJiYgIShtZXNzYWdlLmVuZCAmJiAkdXRpbC5pc0ludGVnZXIobWVzc2FnZS5lbmQubG93KSAmJiAkdXRpbC5pc0ludGVnZXIobWVzc2FnZS5lbmQuaGlnaCkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiZW5kOiBpbnRlZ2VyfExvbmcgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ3JlYXRlcyBhIFNlZ21lbnQgbWVzc2FnZSBmcm9tIGEgcGxhaW4gb2JqZWN0LiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byB0aGVpciByZXNwZWN0aXZlIGludGVybmFsIHR5cGVzLlxuICAgICAgICAgICAgICogQGZ1bmN0aW9uIGZyb21PYmplY3RcbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclByb3RvLlNlZ21lbnRcbiAgICAgICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG9iamVjdCBQbGFpbiBvYmplY3RcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtvbm54LlRlbnNvclByb3RvLlNlZ21lbnR9IFNlZ21lbnRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgU2VnbWVudC5mcm9tT2JqZWN0ID0gZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgICAgICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgJHJvb3Qub25ueC5UZW5zb3JQcm90by5TZWdtZW50KVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlID0gbmV3ICRyb290Lm9ubnguVGVuc29yUHJvdG8uU2VnbWVudCgpO1xuICAgICAgICAgICAgICAgIGlmIChvYmplY3QuYmVnaW4gIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgaWYgKCR1dGlsLkxvbmcpXG4gICAgICAgICAgICAgICAgICAgICAgICAobWVzc2FnZS5iZWdpbiA9ICR1dGlsLkxvbmcuZnJvbVZhbHVlKG9iamVjdC5iZWdpbikpLnVuc2lnbmVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QuYmVnaW4gPT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmJlZ2luID0gcGFyc2VJbnQob2JqZWN0LmJlZ2luLCAxMCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QuYmVnaW4gPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmJlZ2luID0gb2JqZWN0LmJlZ2luO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LmJlZ2luID09PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5iZWdpbiA9IG5ldyAkdXRpbC5Mb25nQml0cyhvYmplY3QuYmVnaW4ubG93ID4+PiAwLCBvYmplY3QuYmVnaW4uaGlnaCA+Pj4gMCkudG9OdW1iZXIoKTtcbiAgICAgICAgICAgICAgICBpZiAob2JqZWN0LmVuZCAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICBpZiAoJHV0aWwuTG9uZylcbiAgICAgICAgICAgICAgICAgICAgICAgIChtZXNzYWdlLmVuZCA9ICR1dGlsLkxvbmcuZnJvbVZhbHVlKG9iamVjdC5lbmQpKS51bnNpZ25lZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LmVuZCA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZW5kID0gcGFyc2VJbnQob2JqZWN0LmVuZCwgMTApO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LmVuZCA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZW5kID0gb2JqZWN0LmVuZDtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC5lbmQgPT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmVuZCA9IG5ldyAkdXRpbC5Mb25nQml0cyhvYmplY3QuZW5kLmxvdyA+Pj4gMCwgb2JqZWN0LmVuZC5oaWdoID4+PiAwKS50b051bWJlcigpO1xuICAgICAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDcmVhdGVzIGEgcGxhaW4gb2JqZWN0IGZyb20gYSBTZWdtZW50IG1lc3NhZ2UuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIG90aGVyIHR5cGVzIGlmIHNwZWNpZmllZC5cbiAgICAgICAgICAgICAqIEBmdW5jdGlvbiB0b09iamVjdFxuICAgICAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yUHJvdG8uU2VnbWVudFxuICAgICAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgICAgICogQHBhcmFtIHtvbm54LlRlbnNvclByb3RvLlNlZ21lbnR9IG1lc3NhZ2UgU2VnbWVudFxuICAgICAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuSUNvbnZlcnNpb25PcHRpb25zfSBbb3B0aW9uc10gQ29udmVyc2lvbiBvcHRpb25zXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IFBsYWluIG9iamVjdFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBTZWdtZW50LnRvT2JqZWN0ID0gZnVuY3Rpb24gdG9PYmplY3QobWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgICAgIGlmICghb3B0aW9ucylcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgICAgICAgIHZhciBvYmplY3QgPSB7fTtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5kZWZhdWx0cykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoJHV0aWwuTG9uZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxvbmcgPSBuZXcgJHV0aWwuTG9uZygwLCAwLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmplY3QuYmVnaW4gPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyBsb25nLnRvU3RyaW5nKCkgOiBvcHRpb25zLmxvbmdzID09PSBOdW1iZXIgPyBsb25nLnRvTnVtYmVyKCkgOiBsb25nO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdC5iZWdpbiA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/IFwiMFwiIDogMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCR1dGlsLkxvbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsb25nID0gbmV3ICR1dGlsLkxvbmcoMCwgMCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0LmVuZCA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/IGxvbmcudG9TdHJpbmcoKSA6IG9wdGlvbnMubG9uZ3MgPT09IE51bWJlciA/IGxvbmcudG9OdW1iZXIoKSA6IGxvbmc7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0LmVuZCA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/IFwiMFwiIDogMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UuYmVnaW4gIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiYmVnaW5cIikpXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZS5iZWdpbiA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdC5iZWdpbiA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/IFN0cmluZyhtZXNzYWdlLmJlZ2luKSA6IG1lc3NhZ2UuYmVnaW47XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdC5iZWdpbiA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/ICR1dGlsLkxvbmcucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobWVzc2FnZS5iZWdpbikgOiBvcHRpb25zLmxvbmdzID09PSBOdW1iZXIgPyBuZXcgJHV0aWwuTG9uZ0JpdHMobWVzc2FnZS5iZWdpbi5sb3cgPj4+IDAsIG1lc3NhZ2UuYmVnaW4uaGlnaCA+Pj4gMCkudG9OdW1iZXIoKSA6IG1lc3NhZ2UuYmVnaW47XG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZW5kICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImVuZFwiKSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlLmVuZCA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdC5lbmQgPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyBTdHJpbmcobWVzc2FnZS5lbmQpIDogbWVzc2FnZS5lbmQ7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdC5lbmQgPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyAkdXRpbC5Mb25nLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG1lc3NhZ2UuZW5kKSA6IG9wdGlvbnMubG9uZ3MgPT09IE51bWJlciA/IG5ldyAkdXRpbC5Mb25nQml0cyhtZXNzYWdlLmVuZC5sb3cgPj4+IDAsIG1lc3NhZ2UuZW5kLmhpZ2ggPj4+IDApLnRvTnVtYmVyKCkgOiBtZXNzYWdlLmVuZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDb252ZXJ0cyB0aGlzIFNlZ21lbnQgdG8gSlNPTi5cbiAgICAgICAgICAgICAqIEBmdW5jdGlvbiB0b0pTT05cbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclByb3RvLlNlZ21lbnRcbiAgICAgICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBKU09OIG9iamVjdFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBTZWdtZW50LnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcywgJHByb3RvYnVmLnV0aWwudG9KU09OT3B0aW9ucyk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEdldHMgdGhlIGRlZmF1bHQgdHlwZSB1cmwgZm9yIFNlZ21lbnRcbiAgICAgICAgICAgICAqIEBmdW5jdGlvbiBnZXRUeXBlVXJsXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JQcm90by5TZWdtZW50XG4gICAgICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3R5cGVVcmxQcmVmaXhdIHlvdXIgY3VzdG9tIHR5cGVVcmxQcmVmaXgoZGVmYXVsdCBcInR5cGUuZ29vZ2xlYXBpcy5jb21cIilcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBkZWZhdWx0IHR5cGUgdXJsXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFNlZ21lbnQuZ2V0VHlwZVVybCA9IGZ1bmN0aW9uIGdldFR5cGVVcmwodHlwZVVybFByZWZpeCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlVXJsUHJlZml4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZVVybFByZWZpeCA9IFwidHlwZS5nb29nbGVhcGlzLmNvbVwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZVVybFByZWZpeCArIFwiL29ubnguVGVuc29yUHJvdG8uU2VnbWVudFwiO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmV0dXJuIFNlZ21lbnQ7XG4gICAgICAgIH0pKCk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERhdGFMb2NhdGlvbiBlbnVtLlxuICAgICAgICAgKiBAbmFtZSBvbm54LlRlbnNvclByb3RvLkRhdGFMb2NhdGlvblxuICAgICAgICAgKiBAZW51bSB7bnVtYmVyfVxuICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcn0gREVGQVVMVD0wIERFRkFVTFQgdmFsdWVcbiAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IEVYVEVSTkFMPTEgRVhURVJOQUwgdmFsdWVcbiAgICAgICAgICovXG4gICAgICAgIFRlbnNvclByb3RvLkRhdGFMb2NhdGlvbiA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZXNCeUlkID0ge30sIHZhbHVlcyA9IE9iamVjdC5jcmVhdGUodmFsdWVzQnlJZCk7XG4gICAgICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFswXSA9IFwiREVGQVVMVFwiXSA9IDA7XG4gICAgICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFsxXSA9IFwiRVhURVJOQUxcIl0gPSAxO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICAgICAgfSkoKTtcblxuICAgICAgICByZXR1cm4gVGVuc29yUHJvdG87XG4gICAgfSkoKTtcblxuICAgIG9ubnguU3BhcnNlVGVuc29yUHJvdG8gPSAoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb3BlcnRpZXMgb2YgYSBTcGFyc2VUZW5zb3JQcm90by5cbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnhcbiAgICAgICAgICogQGludGVyZmFjZSBJU3BhcnNlVGVuc29yUHJvdG9cbiAgICAgICAgICogQHByb3BlcnR5IHtvbm54LklUZW5zb3JQcm90b3xudWxsfSBbdmFsdWVzXSBTcGFyc2VUZW5zb3JQcm90byB2YWx1ZXNcbiAgICAgICAgICogQHByb3BlcnR5IHtvbm54LklUZW5zb3JQcm90b3xudWxsfSBbaW5kaWNlc10gU3BhcnNlVGVuc29yUHJvdG8gaW5kaWNlc1xuICAgICAgICAgKiBAcHJvcGVydHkge0FycmF5LjxudW1iZXJ8TG9uZz58bnVsbH0gW2RpbXNdIFNwYXJzZVRlbnNvclByb3RvIGRpbXNcbiAgICAgICAgICovXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnN0cnVjdHMgYSBuZXcgU3BhcnNlVGVuc29yUHJvdG8uXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54XG4gICAgICAgICAqIEBjbGFzc2Rlc2MgUmVwcmVzZW50cyBhIFNwYXJzZVRlbnNvclByb3RvLlxuICAgICAgICAgKiBAaW1wbGVtZW50cyBJU3BhcnNlVGVuc29yUHJvdG9cbiAgICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgICAqIEBwYXJhbSB7b25ueC5JU3BhcnNlVGVuc29yUHJvdG89fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIFNwYXJzZVRlbnNvclByb3RvKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHRoaXMuZGltcyA9IFtdO1xuICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMpXG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzW2tleXNbaV1dICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2tleXNbaV1dID0gcHJvcGVydGllc1trZXlzW2ldXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGFyc2VUZW5zb3JQcm90byB2YWx1ZXMuXG4gICAgICAgICAqIEBtZW1iZXIge29ubnguSVRlbnNvclByb3RvfG51bGx8dW5kZWZpbmVkfSB2YWx1ZXNcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguU3BhcnNlVGVuc29yUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBTcGFyc2VUZW5zb3JQcm90by5wcm90b3R5cGUudmFsdWVzID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogU3BhcnNlVGVuc29yUHJvdG8gaW5kaWNlcy5cbiAgICAgICAgICogQG1lbWJlciB7b25ueC5JVGVuc29yUHJvdG98bnVsbHx1bmRlZmluZWR9IGluZGljZXNcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguU3BhcnNlVGVuc29yUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBTcGFyc2VUZW5zb3JQcm90by5wcm90b3R5cGUuaW5kaWNlcyA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwYXJzZVRlbnNvclByb3RvIGRpbXMuXG4gICAgICAgICAqIEBtZW1iZXIge0FycmF5LjxudW1iZXJ8TG9uZz59IGRpbXNcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguU3BhcnNlVGVuc29yUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBTcGFyc2VUZW5zb3JQcm90by5wcm90b3R5cGUuZGltcyA9ICR1dGlsLmVtcHR5QXJyYXk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBuZXcgU3BhcnNlVGVuc29yUHJvdG8gaW5zdGFuY2UgdXNpbmcgdGhlIHNwZWNpZmllZCBwcm9wZXJ0aWVzLlxuICAgICAgICAgKiBAZnVuY3Rpb24gY3JlYXRlXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlNwYXJzZVRlbnNvclByb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtvbm54LklTcGFyc2VUZW5zb3JQcm90bz19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxuICAgICAgICAgKiBAcmV0dXJucyB7b25ueC5TcGFyc2VUZW5zb3JQcm90b30gU3BhcnNlVGVuc29yUHJvdG8gaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIFNwYXJzZVRlbnNvclByb3RvLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNwYXJzZVRlbnNvclByb3RvKHByb3BlcnRpZXMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgU3BhcnNlVGVuc29yUHJvdG8gbWVzc2FnZS4gRG9lcyBub3QgaW1wbGljaXRseSB7QGxpbmsgb25ueC5TcGFyc2VUZW5zb3JQcm90by52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGVuY29kZVxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5TcGFyc2VUZW5zb3JQcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7b25ueC5JU3BhcnNlVGVuc29yUHJvdG99IG1lc3NhZ2UgU3BhcnNlVGVuc29yUHJvdG8gbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLldyaXRlcn0gW3dyaXRlcl0gV3JpdGVyIHRvIGVuY29kZSB0b1xuICAgICAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXG4gICAgICAgICAqL1xuICAgICAgICBTcGFyc2VUZW5zb3JQcm90by5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgICBpZiAoIXdyaXRlcilcbiAgICAgICAgICAgICAgICB3cml0ZXIgPSAkV3JpdGVyLmNyZWF0ZSgpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UudmFsdWVzICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJ2YWx1ZXNcIikpXG4gICAgICAgICAgICAgICAgJHJvb3Qub25ueC5UZW5zb3JQcm90by5lbmNvZGUobWVzc2FnZS52YWx1ZXMsIHdyaXRlci51aW50MzIoLyogaWQgMSwgd2lyZVR5cGUgMiA9Ki8xMCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmluZGljZXMgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcImluZGljZXNcIikpXG4gICAgICAgICAgICAgICAgJHJvb3Qub25ueC5UZW5zb3JQcm90by5lbmNvZGUobWVzc2FnZS5pbmRpY2VzLCB3cml0ZXIudWludDMyKC8qIGlkIDIsIHdpcmVUeXBlIDIgPSovMTgpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5kaW1zICE9IG51bGwgJiYgbWVzc2FnZS5kaW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMywgd2lyZVR5cGUgMiA9Ki8yNikuZm9yaygpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5kaW1zLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICB3cml0ZXIuaW50NjQobWVzc2FnZS5kaW1zW2ldKTtcbiAgICAgICAgICAgICAgICB3cml0ZXIubGRlbGltKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgU3BhcnNlVGVuc29yUHJvdG8gbWVzc2FnZSwgbGVuZ3RoIGRlbGltaXRlZC4gRG9lcyBub3QgaW1wbGljaXRseSB7QGxpbmsgb25ueC5TcGFyc2VUZW5zb3JQcm90by52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZFxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5TcGFyc2VUZW5zb3JQcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7b25ueC5JU3BhcnNlVGVuc29yUHJvdG99IG1lc3NhZ2UgU3BhcnNlVGVuc29yUHJvdG8gbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLldyaXRlcn0gW3dyaXRlcl0gV3JpdGVyIHRvIGVuY29kZSB0b1xuICAgICAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXG4gICAgICAgICAqL1xuICAgICAgICBTcGFyc2VUZW5zb3JQcm90by5lbmNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWQobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGUobWVzc2FnZSwgd3JpdGVyKS5sZGVsaW0oKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGVjb2RlcyBhIFNwYXJzZVRlbnNvclByb3RvIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIuXG4gICAgICAgICAqIEBmdW5jdGlvbiBkZWNvZGVcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguU3BhcnNlVGVuc29yUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGhdIE1lc3NhZ2UgbGVuZ3RoIGlmIGtub3duIGJlZm9yZWhhbmRcbiAgICAgICAgICogQHJldHVybnMge29ubnguU3BhcnNlVGVuc29yUHJvdG99IFNwYXJzZVRlbnNvclByb3RvXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAgICAgKi9cbiAgICAgICAgU3BhcnNlVGVuc29yUHJvdG8uZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHJlYWRlciwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgICByZWFkZXIgPSAkUmVhZGVyLmNyZWF0ZShyZWFkZXIpO1xuICAgICAgICAgICAgdmFyIGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGgsIG1lc3NhZ2UgPSBuZXcgJHJvb3Qub25ueC5TcGFyc2VUZW5zb3JQcm90bygpO1xuICAgICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnZhbHVlcyA9ICRyb290Lm9ubnguVGVuc29yUHJvdG8uZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAyOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmluZGljZXMgPSAkcm9vdC5vbm54LlRlbnNvclByb3RvLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgMzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEobWVzc2FnZS5kaW1zICYmIG1lc3NhZ2UuZGltcy5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZGltcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCh0YWcgJiA3KSA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbmQyID0gcmVhZGVyLnVpbnQzMigpICsgcmVhZGVyLnBvcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZDIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZGltcy5wdXNoKHJlYWRlci5pbnQ2NCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZGltcy5wdXNoKHJlYWRlci5pbnQ2NCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGVjb2RlcyBhIFNwYXJzZVRlbnNvclByb3RvIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIsIGxlbmd0aCBkZWxpbWl0ZWQuXG4gICAgICAgICAqIEBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWRcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguU3BhcnNlVGVuc29yUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgICAgICogQHJldHVybnMge29ubnguU3BhcnNlVGVuc29yUHJvdG99IFNwYXJzZVRlbnNvclByb3RvXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAgICAgKi9cbiAgICAgICAgU3BhcnNlVGVuc29yUHJvdG8uZGVjb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkKHJlYWRlcikge1xuICAgICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgICAgcmVhZGVyID0gbmV3ICRSZWFkZXIocmVhZGVyKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFZlcmlmaWVzIGEgU3BhcnNlVGVuc29yUHJvdG8gbWVzc2FnZS5cbiAgICAgICAgICogQGZ1bmN0aW9uIHZlcmlmeVxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5TcGFyc2VUZW5zb3JQcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG1lc3NhZ2UgUGxhaW4gb2JqZWN0IHRvIHZlcmlmeVxuICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9IGBudWxsYCBpZiB2YWxpZCwgb3RoZXJ3aXNlIHRoZSByZWFzb24gd2h5IGl0IGlzIG5vdFxuICAgICAgICAgKi9cbiAgICAgICAgU3BhcnNlVGVuc29yUHJvdG8udmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5KG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSAhPT0gXCJvYmplY3RcIiB8fCBtZXNzYWdlID09PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiBcIm9iamVjdCBleHBlY3RlZFwiO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UudmFsdWVzICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInZhbHVlc1wiKSkge1xuICAgICAgICAgICAgICAgIHZhciBlcnJvciA9ICRyb290Lm9ubnguVGVuc29yUHJvdG8udmVyaWZ5KG1lc3NhZ2UudmFsdWVzKTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcInZhbHVlcy5cIiArIGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuaW5kaWNlcyAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJpbmRpY2VzXCIpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVycm9yID0gJHJvb3Qub25ueC5UZW5zb3JQcm90by52ZXJpZnkobWVzc2FnZS5pbmRpY2VzKTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImluZGljZXMuXCIgKyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmRpbXMgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZGltc1wiKSkge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShtZXNzYWdlLmRpbXMpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJkaW1zOiBhcnJheSBleHBlY3RlZFwiO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5kaW1zLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICBpZiAoISR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLmRpbXNbaV0pICYmICEobWVzc2FnZS5kaW1zW2ldICYmICR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLmRpbXNbaV0ubG93KSAmJiAkdXRpbC5pc0ludGVnZXIobWVzc2FnZS5kaW1zW2ldLmhpZ2gpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcImRpbXM6IGludGVnZXJ8TG9uZ1tdIGV4cGVjdGVkXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIFNwYXJzZVRlbnNvclByb3RvIG1lc3NhZ2UgZnJvbSBhIHBsYWluIG9iamVjdC4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gdGhlaXIgcmVzcGVjdGl2ZSBpbnRlcm5hbCB0eXBlcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGZyb21PYmplY3RcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguU3BhcnNlVGVuc29yUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBvYmplY3QgUGxhaW4gb2JqZWN0XG4gICAgICAgICAqIEByZXR1cm5zIHtvbm54LlNwYXJzZVRlbnNvclByb3RvfSBTcGFyc2VUZW5zb3JQcm90b1xuICAgICAgICAgKi9cbiAgICAgICAgU3BhcnNlVGVuc29yUHJvdG8uZnJvbU9iamVjdCA9IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgJHJvb3Qub25ueC5TcGFyc2VUZW5zb3JQcm90bylcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBuZXcgJHJvb3Qub25ueC5TcGFyc2VUZW5zb3JQcm90bygpO1xuICAgICAgICAgICAgaWYgKG9iamVjdC52YWx1ZXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LnZhbHVlcyAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguU3BhcnNlVGVuc29yUHJvdG8udmFsdWVzOiBvYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS52YWx1ZXMgPSAkcm9vdC5vbm54LlRlbnNvclByb3RvLmZyb21PYmplY3Qob2JqZWN0LnZhbHVlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2JqZWN0LmluZGljZXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LmluZGljZXMgIT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5vbm54LlNwYXJzZVRlbnNvclByb3RvLmluZGljZXM6IG9iamVjdCBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmluZGljZXMgPSAkcm9vdC5vbm54LlRlbnNvclByb3RvLmZyb21PYmplY3Qob2JqZWN0LmluZGljZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9iamVjdC5kaW1zKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9iamVjdC5kaW1zKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguU3BhcnNlVGVuc29yUHJvdG8uZGltczogYXJyYXkgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5kaW1zID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3QuZGltcy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKCR1dGlsLkxvbmcpXG4gICAgICAgICAgICAgICAgICAgICAgICAobWVzc2FnZS5kaW1zW2ldID0gJHV0aWwuTG9uZy5mcm9tVmFsdWUob2JqZWN0LmRpbXNbaV0pKS51bnNpZ25lZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LmRpbXNbaV0gPT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmRpbXNbaV0gPSBwYXJzZUludChvYmplY3QuZGltc1tpXSwgMTApO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LmRpbXNbaV0gPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmRpbXNbaV0gPSBvYmplY3QuZGltc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC5kaW1zW2ldID09PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5kaW1zW2ldID0gbmV3ICR1dGlsLkxvbmdCaXRzKG9iamVjdC5kaW1zW2ldLmxvdyA+Pj4gMCwgb2JqZWN0LmRpbXNbaV0uaGlnaCA+Pj4gMCkudG9OdW1iZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgcGxhaW4gb2JqZWN0IGZyb20gYSBTcGFyc2VUZW5zb3JQcm90byBtZXNzYWdlLiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byBvdGhlciB0eXBlcyBpZiBzcGVjaWZpZWQuXG4gICAgICAgICAqIEBmdW5jdGlvbiB0b09iamVjdFxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5TcGFyc2VUZW5zb3JQcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7b25ueC5TcGFyc2VUZW5zb3JQcm90b30gbWVzc2FnZSBTcGFyc2VUZW5zb3JQcm90b1xuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5JQ29udmVyc2lvbk9wdGlvbnN9IFtvcHRpb25zXSBDb252ZXJzaW9uIG9wdGlvbnNcbiAgICAgICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBQbGFpbiBvYmplY3RcbiAgICAgICAgICovXG4gICAgICAgIFNwYXJzZVRlbnNvclByb3RvLnRvT2JqZWN0ID0gZnVuY3Rpb24gdG9PYmplY3QobWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zKVxuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgICAgIHZhciBvYmplY3QgPSB7fTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmFycmF5cyB8fCBvcHRpb25zLmRlZmF1bHRzKVxuICAgICAgICAgICAgICAgIG9iamVjdC5kaW1zID0gW107XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5kZWZhdWx0cykge1xuICAgICAgICAgICAgICAgIG9iamVjdC52YWx1ZXMgPSBudWxsO1xuICAgICAgICAgICAgICAgIG9iamVjdC5pbmRpY2VzID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnZhbHVlcyAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJ2YWx1ZXNcIikpXG4gICAgICAgICAgICAgICAgb2JqZWN0LnZhbHVlcyA9ICRyb290Lm9ubnguVGVuc29yUHJvdG8udG9PYmplY3QobWVzc2FnZS52YWx1ZXMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuaW5kaWNlcyAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJpbmRpY2VzXCIpKVxuICAgICAgICAgICAgICAgIG9iamVjdC5pbmRpY2VzID0gJHJvb3Qub25ueC5UZW5zb3JQcm90by50b09iamVjdChtZXNzYWdlLmluZGljZXMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZGltcyAmJiBtZXNzYWdlLmRpbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0LmRpbXMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1lc3NhZ2UuZGltcy5sZW5ndGg7ICsrailcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlLmRpbXNbal0gPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBvYmplY3QuZGltc1tqXSA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/IFN0cmluZyhtZXNzYWdlLmRpbXNbal0pIDogbWVzc2FnZS5kaW1zW2pdO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBvYmplY3QuZGltc1tqXSA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/ICR1dGlsLkxvbmcucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobWVzc2FnZS5kaW1zW2pdKSA6IG9wdGlvbnMubG9uZ3MgPT09IE51bWJlciA/IG5ldyAkdXRpbC5Mb25nQml0cyhtZXNzYWdlLmRpbXNbal0ubG93ID4+PiAwLCBtZXNzYWdlLmRpbXNbal0uaGlnaCA+Pj4gMCkudG9OdW1iZXIoKSA6IG1lc3NhZ2UuZGltc1tqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlcnRzIHRoaXMgU3BhcnNlVGVuc29yUHJvdG8gdG8gSlNPTi5cbiAgICAgICAgICogQGZ1bmN0aW9uIHRvSlNPTlxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5TcGFyc2VUZW5zb3JQcm90b1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBKU09OIG9iamVjdFxuICAgICAgICAgKi9cbiAgICAgICAgU3BhcnNlVGVuc29yUHJvdG8ucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsICRwcm90b2J1Zi51dGlsLnRvSlNPTk9wdGlvbnMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIHRoZSBkZWZhdWx0IHR5cGUgdXJsIGZvciBTcGFyc2VUZW5zb3JQcm90b1xuICAgICAgICAgKiBAZnVuY3Rpb24gZ2V0VHlwZVVybFxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5TcGFyc2VUZW5zb3JQcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbdHlwZVVybFByZWZpeF0geW91ciBjdXN0b20gdHlwZVVybFByZWZpeChkZWZhdWx0IFwidHlwZS5nb29nbGVhcGlzLmNvbVwiKVxuICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgZGVmYXVsdCB0eXBlIHVybFxuICAgICAgICAgKi9cbiAgICAgICAgU3BhcnNlVGVuc29yUHJvdG8uZ2V0VHlwZVVybCA9IGZ1bmN0aW9uIGdldFR5cGVVcmwodHlwZVVybFByZWZpeCkge1xuICAgICAgICAgICAgaWYgKHR5cGVVcmxQcmVmaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHR5cGVVcmxQcmVmaXggPSBcInR5cGUuZ29vZ2xlYXBpcy5jb21cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0eXBlVXJsUHJlZml4ICsgXCIvb25ueC5TcGFyc2VUZW5zb3JQcm90b1wiO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBTcGFyc2VUZW5zb3JQcm90bztcbiAgICB9KSgpO1xuXG4gICAgb25ueC5UZW5zb3JTaGFwZVByb3RvID0gKGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm9wZXJ0aWVzIG9mIGEgVGVuc29yU2hhcGVQcm90by5cbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnhcbiAgICAgICAgICogQGludGVyZmFjZSBJVGVuc29yU2hhcGVQcm90b1xuICAgICAgICAgKiBAcHJvcGVydHkge0FycmF5Ljxvbm54LlRlbnNvclNoYXBlUHJvdG8uSURpbWVuc2lvbj58bnVsbH0gW2RpbV0gVGVuc29yU2hhcGVQcm90byBkaW1cbiAgICAgICAgICovXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnN0cnVjdHMgYSBuZXcgVGVuc29yU2hhcGVQcm90by5cbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnhcbiAgICAgICAgICogQGNsYXNzZGVzYyBSZXByZXNlbnRzIGEgVGVuc29yU2hhcGVQcm90by5cbiAgICAgICAgICogQGltcGxlbWVudHMgSVRlbnNvclNoYXBlUHJvdG9cbiAgICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgICAqIEBwYXJhbSB7b25ueC5JVGVuc29yU2hhcGVQcm90bz19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gVGVuc29yU2hhcGVQcm90byhwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICB0aGlzLmRpbSA9IFtdO1xuICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMpXG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzW2tleXNbaV1dICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2tleXNbaV1dID0gcHJvcGVydGllc1trZXlzW2ldXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUZW5zb3JTaGFwZVByb3RvIGRpbS5cbiAgICAgICAgICogQG1lbWJlciB7QXJyYXkuPG9ubnguVGVuc29yU2hhcGVQcm90by5JRGltZW5zaW9uPn0gZGltXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclNoYXBlUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBUZW5zb3JTaGFwZVByb3RvLnByb3RvdHlwZS5kaW0gPSAkdXRpbC5lbXB0eUFycmF5O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgbmV3IFRlbnNvclNoYXBlUHJvdG8gaW5zdGFuY2UgdXNpbmcgdGhlIHNwZWNpZmllZCBwcm9wZXJ0aWVzLlxuICAgICAgICAgKiBAZnVuY3Rpb24gY3JlYXRlXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclNoYXBlUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge29ubnguSVRlbnNvclNoYXBlUHJvdG89fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAgICAgICAgICogQHJldHVybnMge29ubnguVGVuc29yU2hhcGVQcm90b30gVGVuc29yU2hhcGVQcm90byBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgVGVuc29yU2hhcGVQcm90by5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUocHJvcGVydGllcykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBUZW5zb3JTaGFwZVByb3RvKHByb3BlcnRpZXMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgVGVuc29yU2hhcGVQcm90byBtZXNzYWdlLiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayBvbm54LlRlbnNvclNoYXBlUHJvdG8udmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBlbmNvZGVcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yU2hhcGVQcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7b25ueC5JVGVuc29yU2hhcGVQcm90b30gbWVzc2FnZSBUZW5zb3JTaGFwZVByb3RvIG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0IHRvIGVuY29kZVxuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAgICAgICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAgICAgKi9cbiAgICAgICAgVGVuc29yU2hhcGVQcm90by5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgICBpZiAoIXdyaXRlcilcbiAgICAgICAgICAgICAgICB3cml0ZXIgPSAkV3JpdGVyLmNyZWF0ZSgpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZGltICE9IG51bGwgJiYgbWVzc2FnZS5kaW0ubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5kaW0ubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgICRyb290Lm9ubnguVGVuc29yU2hhcGVQcm90by5EaW1lbnNpb24uZW5jb2RlKG1lc3NhZ2UuZGltW2ldLCB3cml0ZXIudWludDMyKC8qIGlkIDEsIHdpcmVUeXBlIDIgPSovMTApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgVGVuc29yU2hhcGVQcm90byBtZXNzYWdlLCBsZW5ndGggZGVsaW1pdGVkLiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayBvbm54LlRlbnNvclNoYXBlUHJvdG8udmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWRcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yU2hhcGVQcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7b25ueC5JVGVuc29yU2hhcGVQcm90b30gbWVzc2FnZSBUZW5zb3JTaGFwZVByb3RvIG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0IHRvIGVuY29kZVxuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAgICAgICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAgICAgKi9cbiAgICAgICAgVGVuc29yU2hhcGVQcm90by5lbmNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWQobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGUobWVzc2FnZSwgd3JpdGVyKS5sZGVsaW0oKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGVjb2RlcyBhIFRlbnNvclNoYXBlUHJvdG8gbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyIG9yIGJ1ZmZlci5cbiAgICAgICAgICogQGZ1bmN0aW9uIGRlY29kZVxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JTaGFwZVByb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoXSBNZXNzYWdlIGxlbmd0aCBpZiBrbm93biBiZWZvcmVoYW5kXG4gICAgICAgICAqIEByZXR1cm5zIHtvbm54LlRlbnNvclNoYXBlUHJvdG99IFRlbnNvclNoYXBlUHJvdG9cbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcbiAgICAgICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICAgICAqL1xuICAgICAgICBUZW5zb3JTaGFwZVByb3RvLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyZWFkZXIsIGxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgICAgcmVhZGVyID0gJFJlYWRlci5jcmVhdGUocmVhZGVyKTtcbiAgICAgICAgICAgIHZhciBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoLCBtZXNzYWdlID0gbmV3ICRyb290Lm9ubnguVGVuc29yU2hhcGVQcm90bygpO1xuICAgICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShtZXNzYWdlLmRpbSAmJiBtZXNzYWdlLmRpbS5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZGltID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmRpbS5wdXNoKCRyb290Lm9ubnguVGVuc29yU2hhcGVQcm90by5EaW1lbnNpb24uZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlY29kZXMgYSBUZW5zb3JTaGFwZVByb3RvIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIsIGxlbmd0aCBkZWxpbWl0ZWQuXG4gICAgICAgICAqIEBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWRcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yU2hhcGVQcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLlJlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGUgZnJvbVxuICAgICAgICAgKiBAcmV0dXJucyB7b25ueC5UZW5zb3JTaGFwZVByb3RvfSBUZW5zb3JTaGFwZVByb3RvXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAgICAgKi9cbiAgICAgICAgVGVuc29yU2hhcGVQcm90by5kZWNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWQocmVhZGVyKSB7XG4gICAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgICByZWFkZXIgPSBuZXcgJFJlYWRlcihyZWFkZXIpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVmVyaWZpZXMgYSBUZW5zb3JTaGFwZVByb3RvIG1lc3NhZ2UuXG4gICAgICAgICAqIEBmdW5jdGlvbiB2ZXJpZnlcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yU2hhcGVQcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG1lc3NhZ2UgUGxhaW4gb2JqZWN0IHRvIHZlcmlmeVxuICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9IGBudWxsYCBpZiB2YWxpZCwgb3RoZXJ3aXNlIHRoZSByZWFzb24gd2h5IGl0IGlzIG5vdFxuICAgICAgICAgKi9cbiAgICAgICAgVGVuc29yU2hhcGVQcm90by52ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnkobWVzc2FnZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlICE9PSBcIm9iamVjdFwiIHx8IG1lc3NhZ2UgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwib2JqZWN0IGV4cGVjdGVkXCI7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5kaW0gIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZGltXCIpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG1lc3NhZ2UuZGltKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiZGltOiBhcnJheSBleHBlY3RlZFwiO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5kaW0ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVycm9yID0gJHJvb3Qub25ueC5UZW5zb3JTaGFwZVByb3RvLkRpbWVuc2lvbi52ZXJpZnkobWVzc2FnZS5kaW1baV0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJkaW0uXCIgKyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIFRlbnNvclNoYXBlUHJvdG8gbWVzc2FnZSBmcm9tIGEgcGxhaW4gb2JqZWN0LiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byB0aGVpciByZXNwZWN0aXZlIGludGVybmFsIHR5cGVzLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZnJvbU9iamVjdFxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JTaGFwZVByb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gb2JqZWN0IFBsYWluIG9iamVjdFxuICAgICAgICAgKiBAcmV0dXJucyB7b25ueC5UZW5zb3JTaGFwZVByb3RvfSBUZW5zb3JTaGFwZVByb3RvXG4gICAgICAgICAqL1xuICAgICAgICBUZW5zb3JTaGFwZVByb3RvLmZyb21PYmplY3QgPSBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mICRyb290Lm9ubnguVGVuc29yU2hhcGVQcm90bylcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBuZXcgJHJvb3Qub25ueC5UZW5zb3JTaGFwZVByb3RvKCk7XG4gICAgICAgICAgICBpZiAob2JqZWN0LmRpbSkge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvYmplY3QuZGltKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguVGVuc29yU2hhcGVQcm90by5kaW06IGFycmF5IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UuZGltID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3QuZGltLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LmRpbVtpXSAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5vbm54LlRlbnNvclNoYXBlUHJvdG8uZGltOiBvYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZGltW2ldID0gJHJvb3Qub25ueC5UZW5zb3JTaGFwZVByb3RvLkRpbWVuc2lvbi5mcm9tT2JqZWN0KG9iamVjdC5kaW1baV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgcGxhaW4gb2JqZWN0IGZyb20gYSBUZW5zb3JTaGFwZVByb3RvIG1lc3NhZ2UuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIG90aGVyIHR5cGVzIGlmIHNwZWNpZmllZC5cbiAgICAgICAgICogQGZ1bmN0aW9uIHRvT2JqZWN0XG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclNoYXBlUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge29ubnguVGVuc29yU2hhcGVQcm90b30gbWVzc2FnZSBUZW5zb3JTaGFwZVByb3RvXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLklDb252ZXJzaW9uT3B0aW9uc30gW29wdGlvbnNdIENvbnZlcnNpb24gb3B0aW9uc1xuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IFBsYWluIG9iamVjdFxuICAgICAgICAgKi9cbiAgICAgICAgVGVuc29yU2hhcGVQcm90by50b09iamVjdCA9IGZ1bmN0aW9uIHRvT2JqZWN0KG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucylcbiAgICAgICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgICAgICB2YXIgb2JqZWN0ID0ge307XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5hcnJheXMgfHwgb3B0aW9ucy5kZWZhdWx0cylcbiAgICAgICAgICAgICAgICBvYmplY3QuZGltID0gW107XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5kaW0gJiYgbWVzc2FnZS5kaW0ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0LmRpbSA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWVzc2FnZS5kaW0ubGVuZ3RoOyArK2opXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5kaW1bal0gPSAkcm9vdC5vbm54LlRlbnNvclNoYXBlUHJvdG8uRGltZW5zaW9uLnRvT2JqZWN0KG1lc3NhZ2UuZGltW2pdLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlcnRzIHRoaXMgVGVuc29yU2hhcGVQcm90byB0byBKU09OLlxuICAgICAgICAgKiBAZnVuY3Rpb24gdG9KU09OXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclNoYXBlUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gSlNPTiBvYmplY3RcbiAgICAgICAgICovXG4gICAgICAgIFRlbnNvclNoYXBlUHJvdG8ucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsICRwcm90b2J1Zi51dGlsLnRvSlNPTk9wdGlvbnMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIHRoZSBkZWZhdWx0IHR5cGUgdXJsIGZvciBUZW5zb3JTaGFwZVByb3RvXG4gICAgICAgICAqIEBmdW5jdGlvbiBnZXRUeXBlVXJsXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclNoYXBlUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3R5cGVVcmxQcmVmaXhdIHlvdXIgY3VzdG9tIHR5cGVVcmxQcmVmaXgoZGVmYXVsdCBcInR5cGUuZ29vZ2xlYXBpcy5jb21cIilcbiAgICAgICAgICogQHJldHVybnMge3N0cmluZ30gVGhlIGRlZmF1bHQgdHlwZSB1cmxcbiAgICAgICAgICovXG4gICAgICAgIFRlbnNvclNoYXBlUHJvdG8uZ2V0VHlwZVVybCA9IGZ1bmN0aW9uIGdldFR5cGVVcmwodHlwZVVybFByZWZpeCkge1xuICAgICAgICAgICAgaWYgKHR5cGVVcmxQcmVmaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHR5cGVVcmxQcmVmaXggPSBcInR5cGUuZ29vZ2xlYXBpcy5jb21cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0eXBlVXJsUHJlZml4ICsgXCIvb25ueC5UZW5zb3JTaGFwZVByb3RvXCI7XG4gICAgICAgIH07XG5cbiAgICAgICAgVGVuc29yU2hhcGVQcm90by5EaW1lbnNpb24gPSAoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUHJvcGVydGllcyBvZiBhIERpbWVuc2lvbi5cbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclNoYXBlUHJvdG9cbiAgICAgICAgICAgICAqIEBpbnRlcmZhY2UgSURpbWVuc2lvblxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ8TG9uZ3xudWxsfSBbZGltVmFsdWVdIERpbWVuc2lvbiBkaW1WYWx1ZVxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtzdHJpbmd8bnVsbH0gW2RpbVBhcmFtXSBEaW1lbnNpb24gZGltUGFyYW1cbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfG51bGx9IFtkZW5vdGF0aW9uXSBEaW1lbnNpb24gZGVub3RhdGlvblxuICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ29uc3RydWN0cyBhIG5ldyBEaW1lbnNpb24uXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JTaGFwZVByb3RvXG4gICAgICAgICAgICAgKiBAY2xhc3NkZXNjIFJlcHJlc2VudHMgYSBEaW1lbnNpb24uXG4gICAgICAgICAgICAgKiBAaW1wbGVtZW50cyBJRGltZW5zaW9uXG4gICAgICAgICAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgICAgICAgICAqIEBwYXJhbSB7b25ueC5UZW5zb3JTaGFwZVByb3RvLklEaW1lbnNpb249fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gRGltZW5zaW9uKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllcylcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllc1trZXlzW2ldXSAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNba2V5c1tpXV0gPSBwcm9wZXJ0aWVzW2tleXNbaV1dO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIERpbWVuc2lvbiBkaW1WYWx1ZS5cbiAgICAgICAgICAgICAqIEBtZW1iZXIge251bWJlcnxMb25nfG51bGx8dW5kZWZpbmVkfSBkaW1WYWx1ZVxuICAgICAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yU2hhcGVQcm90by5EaW1lbnNpb25cbiAgICAgICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBEaW1lbnNpb24ucHJvdG90eXBlLmRpbVZhbHVlID0gbnVsbDtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBEaW1lbnNpb24gZGltUGFyYW0uXG4gICAgICAgICAgICAgKiBAbWVtYmVyIHtzdHJpbmd8bnVsbHx1bmRlZmluZWR9IGRpbVBhcmFtXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JTaGFwZVByb3RvLkRpbWVuc2lvblxuICAgICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIERpbWVuc2lvbi5wcm90b3R5cGUuZGltUGFyYW0gPSBudWxsO1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIERpbWVuc2lvbiBkZW5vdGF0aW9uLlxuICAgICAgICAgICAgICogQG1lbWJlciB7c3RyaW5nfSBkZW5vdGF0aW9uXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JTaGFwZVByb3RvLkRpbWVuc2lvblxuICAgICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIERpbWVuc2lvbi5wcm90b3R5cGUuZGVub3RhdGlvbiA9IFwiXCI7XG5cbiAgICAgICAgICAgIC8vIE9uZU9mIGZpZWxkIG5hbWVzIGJvdW5kIHRvIHZpcnR1YWwgZ2V0dGVycyBhbmQgc2V0dGVyc1xuICAgICAgICAgICAgdmFyICRvbmVPZkZpZWxkcztcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBEaW1lbnNpb24gdmFsdWUuXG4gICAgICAgICAgICAgKiBAbWVtYmVyIHtcImRpbVZhbHVlXCJ8XCJkaW1QYXJhbVwifHVuZGVmaW5lZH0gdmFsdWVcbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclNoYXBlUHJvdG8uRGltZW5zaW9uXG4gICAgICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERpbWVuc2lvbi5wcm90b3R5cGUsIFwidmFsdWVcIiwge1xuICAgICAgICAgICAgICAgIGdldDogJHV0aWwub25lT2ZHZXR0ZXIoJG9uZU9mRmllbGRzID0gW1wiZGltVmFsdWVcIiwgXCJkaW1QYXJhbVwiXSksXG4gICAgICAgICAgICAgICAgc2V0OiAkdXRpbC5vbmVPZlNldHRlcigkb25lT2ZGaWVsZHMpXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDcmVhdGVzIGEgbmV3IERpbWVuc2lvbiBpbnN0YW5jZSB1c2luZyB0aGUgc3BlY2lmaWVkIHByb3BlcnRpZXMuXG4gICAgICAgICAgICAgKiBAZnVuY3Rpb24gY3JlYXRlXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JTaGFwZVByb3RvLkRpbWVuc2lvblxuICAgICAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgICAgICogQHBhcmFtIHtvbm54LlRlbnNvclNoYXBlUHJvdG8uSURpbWVuc2lvbj19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxuICAgICAgICAgICAgICogQHJldHVybnMge29ubnguVGVuc29yU2hhcGVQcm90by5EaW1lbnNpb259IERpbWVuc2lvbiBpbnN0YW5jZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBEaW1lbnNpb24uY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IERpbWVuc2lvbihwcm9wZXJ0aWVzKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRW5jb2RlcyB0aGUgc3BlY2lmaWVkIERpbWVuc2lvbiBtZXNzYWdlLiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayBvbm54LlRlbnNvclNoYXBlUHJvdG8uRGltZW5zaW9uLnZlcmlmeXx2ZXJpZnl9IG1lc3NhZ2VzLlxuICAgICAgICAgICAgICogQGZ1bmN0aW9uIGVuY29kZVxuICAgICAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yU2hhcGVQcm90by5EaW1lbnNpb25cbiAgICAgICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICAgICAqIEBwYXJhbSB7b25ueC5UZW5zb3JTaGFwZVByb3RvLklEaW1lbnNpb259IG1lc3NhZ2UgRGltZW5zaW9uIG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0IHRvIGVuY29kZVxuICAgICAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuV3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gZW5jb2RlIHRvXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIERpbWVuc2lvbi5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF3cml0ZXIpXG4gICAgICAgICAgICAgICAgICAgIHdyaXRlciA9ICRXcml0ZXIuY3JlYXRlKCk7XG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZGltVmFsdWUgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcImRpbVZhbHVlXCIpKVxuICAgICAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDEsIHdpcmVUeXBlIDAgPSovOCkuaW50NjQobWVzc2FnZS5kaW1WYWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZGltUGFyYW0gIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcImRpbVBhcmFtXCIpKVxuICAgICAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDIsIHdpcmVUeXBlIDIgPSovMTgpLnN0cmluZyhtZXNzYWdlLmRpbVBhcmFtKTtcbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZS5kZW5vdGF0aW9uICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJkZW5vdGF0aW9uXCIpKVxuICAgICAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDMsIHdpcmVUeXBlIDIgPSovMjYpLnN0cmluZyhtZXNzYWdlLmRlbm90YXRpb24pO1xuICAgICAgICAgICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBEaW1lbnNpb24gbWVzc2FnZSwgbGVuZ3RoIGRlbGltaXRlZC4gRG9lcyBub3QgaW1wbGljaXRseSB7QGxpbmsgb25ueC5UZW5zb3JTaGFwZVByb3RvLkRpbWVuc2lvbi52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cbiAgICAgICAgICAgICAqIEBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWRcbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclNoYXBlUHJvdG8uRGltZW5zaW9uXG4gICAgICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAgICAgKiBAcGFyYW0ge29ubnguVGVuc29yU2hhcGVQcm90by5JRGltZW5zaW9ufSBtZXNzYWdlIERpbWVuc2lvbiBtZXNzYWdlIG9yIHBsYWluIG9iamVjdCB0byBlbmNvZGVcbiAgICAgICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLldyaXRlcn0gW3dyaXRlcl0gV3JpdGVyIHRvIGVuY29kZSB0b1xuICAgICAgICAgICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBEaW1lbnNpb24uZW5jb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVuY29kZShtZXNzYWdlLCB3cml0ZXIpLmxkZWxpbSgpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBEZWNvZGVzIGEgRGltZW5zaW9uIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIuXG4gICAgICAgICAgICAgKiBAZnVuY3Rpb24gZGVjb2RlXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JTaGFwZVByb3RvLkRpbWVuc2lvblxuICAgICAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aF0gTWVzc2FnZSBsZW5ndGggaWYga25vd24gYmVmb3JlaGFuZFxuICAgICAgICAgICAgICogQHJldHVybnMge29ubnguVGVuc29yU2hhcGVQcm90by5EaW1lbnNpb259IERpbWVuc2lvblxuICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcbiAgICAgICAgICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBEaW1lbnNpb24uZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHJlYWRlciwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgICAgICAgIHJlYWRlciA9ICRSZWFkZXIuY3JlYXRlKHJlYWRlcik7XG4gICAgICAgICAgICAgICAgdmFyIGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGgsIG1lc3NhZ2UgPSBuZXcgJHJvb3Qub25ueC5UZW5zb3JTaGFwZVByb3RvLkRpbWVuc2lvbigpO1xuICAgICAgICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZGltVmFsdWUgPSByZWFkZXIuaW50NjQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5kaW1QYXJhbSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5kZW5vdGF0aW9uID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIERlY29kZXMgYSBEaW1lbnNpb24gbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyIG9yIGJ1ZmZlciwgbGVuZ3RoIGRlbGltaXRlZC5cbiAgICAgICAgICAgICAqIEBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWRcbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclNoYXBlUHJvdG8uRGltZW5zaW9uXG4gICAgICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtvbm54LlRlbnNvclNoYXBlUHJvdG8uRGltZW5zaW9ufSBEaW1lbnNpb25cbiAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICAgICAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgRGltZW5zaW9uLmRlY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZChyZWFkZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyID0gbmV3ICRSZWFkZXIocmVhZGVyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBWZXJpZmllcyBhIERpbWVuc2lvbiBtZXNzYWdlLlxuICAgICAgICAgICAgICogQGZ1bmN0aW9uIHZlcmlmeVxuICAgICAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yU2hhcGVQcm90by5EaW1lbnNpb25cbiAgICAgICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG1lc3NhZ2UgUGxhaW4gb2JqZWN0IHRvIHZlcmlmeVxuICAgICAgICAgICAgICogQHJldHVybnMge3N0cmluZ3xudWxsfSBgbnVsbGAgaWYgdmFsaWQsIG90aGVyd2lzZSB0aGUgcmVhc29uIHdoeSBpdCBpcyBub3RcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgRGltZW5zaW9uLnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlICE9PSBcIm9iamVjdFwiIHx8IG1lc3NhZ2UgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIm9iamVjdCBleHBlY3RlZFwiO1xuICAgICAgICAgICAgICAgIHZhciBwcm9wZXJ0aWVzID0ge307XG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZGltVmFsdWUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZGltVmFsdWVcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllcy52YWx1ZSA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGlmICghJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UuZGltVmFsdWUpICYmICEobWVzc2FnZS5kaW1WYWx1ZSAmJiAkdXRpbC5pc0ludGVnZXIobWVzc2FnZS5kaW1WYWx1ZS5sb3cpICYmICR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLmRpbVZhbHVlLmhpZ2gpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcImRpbVZhbHVlOiBpbnRlZ2VyfExvbmcgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZGltUGFyYW0gIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZGltUGFyYW1cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMudmFsdWUgPT09IDEpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJ2YWx1ZTogbXVsdGlwbGUgdmFsdWVzXCI7XG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXMudmFsdWUgPSAxO1xuICAgICAgICAgICAgICAgICAgICBpZiAoISR1dGlsLmlzU3RyaW5nKG1lc3NhZ2UuZGltUGFyYW0pKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiZGltUGFyYW06IHN0cmluZyBleHBlY3RlZFwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZS5kZW5vdGF0aW9uICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImRlbm90YXRpb25cIikpXG4gICAgICAgICAgICAgICAgICAgIGlmICghJHV0aWwuaXNTdHJpbmcobWVzc2FnZS5kZW5vdGF0aW9uKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcImRlbm90YXRpb246IHN0cmluZyBleHBlY3RlZFwiO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDcmVhdGVzIGEgRGltZW5zaW9uIG1lc3NhZ2UgZnJvbSBhIHBsYWluIG9iamVjdC4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gdGhlaXIgcmVzcGVjdGl2ZSBpbnRlcm5hbCB0eXBlcy5cbiAgICAgICAgICAgICAqIEBmdW5jdGlvbiBmcm9tT2JqZWN0XG4gICAgICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JTaGFwZVByb3RvLkRpbWVuc2lvblxuICAgICAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gb2JqZWN0IFBsYWluIG9iamVjdFxuICAgICAgICAgICAgICogQHJldHVybnMge29ubnguVGVuc29yU2hhcGVQcm90by5EaW1lbnNpb259IERpbWVuc2lvblxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBEaW1lbnNpb24uZnJvbU9iamVjdCA9IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mICRyb290Lm9ubnguVGVuc29yU2hhcGVQcm90by5EaW1lbnNpb24pXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBuZXcgJHJvb3Qub25ueC5UZW5zb3JTaGFwZVByb3RvLkRpbWVuc2lvbigpO1xuICAgICAgICAgICAgICAgIGlmIChvYmplY3QuZGltVmFsdWUgIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgaWYgKCR1dGlsLkxvbmcpXG4gICAgICAgICAgICAgICAgICAgICAgICAobWVzc2FnZS5kaW1WYWx1ZSA9ICR1dGlsLkxvbmcuZnJvbVZhbHVlKG9iamVjdC5kaW1WYWx1ZSkpLnVuc2lnbmVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QuZGltVmFsdWUgPT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmRpbVZhbHVlID0gcGFyc2VJbnQob2JqZWN0LmRpbVZhbHVlLCAxMCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QuZGltVmFsdWUgPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmRpbVZhbHVlID0gb2JqZWN0LmRpbVZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LmRpbVZhbHVlID09PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5kaW1WYWx1ZSA9IG5ldyAkdXRpbC5Mb25nQml0cyhvYmplY3QuZGltVmFsdWUubG93ID4+PiAwLCBvYmplY3QuZGltVmFsdWUuaGlnaCA+Pj4gMCkudG9OdW1iZXIoKTtcbiAgICAgICAgICAgICAgICBpZiAob2JqZWN0LmRpbVBhcmFtICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZGltUGFyYW0gPSBTdHJpbmcob2JqZWN0LmRpbVBhcmFtKTtcbiAgICAgICAgICAgICAgICBpZiAob2JqZWN0LmRlbm90YXRpb24gIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5kZW5vdGF0aW9uID0gU3RyaW5nKG9iamVjdC5kZW5vdGF0aW9uKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ3JlYXRlcyBhIHBsYWluIG9iamVjdCBmcm9tIGEgRGltZW5zaW9uIG1lc3NhZ2UuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIG90aGVyIHR5cGVzIGlmIHNwZWNpZmllZC5cbiAgICAgICAgICAgICAqIEBmdW5jdGlvbiB0b09iamVjdFxuICAgICAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yU2hhcGVQcm90by5EaW1lbnNpb25cbiAgICAgICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICAgICAqIEBwYXJhbSB7b25ueC5UZW5zb3JTaGFwZVByb3RvLkRpbWVuc2lvbn0gbWVzc2FnZSBEaW1lbnNpb25cbiAgICAgICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLklDb252ZXJzaW9uT3B0aW9uc30gW29wdGlvbnNdIENvbnZlcnNpb24gb3B0aW9uc1xuICAgICAgICAgICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBQbGFpbiBvYmplY3RcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgRGltZW5zaW9uLnRvT2JqZWN0ID0gZnVuY3Rpb24gdG9PYmplY3QobWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgICAgIGlmICghb3B0aW9ucylcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgICAgICAgIHZhciBvYmplY3QgPSB7fTtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5kZWZhdWx0cylcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LmRlbm90YXRpb24gPSBcIlwiO1xuICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLmRpbVZhbHVlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImRpbVZhbHVlXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZS5kaW1WYWx1ZSA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdC5kaW1WYWx1ZSA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/IFN0cmluZyhtZXNzYWdlLmRpbVZhbHVlKSA6IG1lc3NhZ2UuZGltVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdC5kaW1WYWx1ZSA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/ICR1dGlsLkxvbmcucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobWVzc2FnZS5kaW1WYWx1ZSkgOiBvcHRpb25zLmxvbmdzID09PSBOdW1iZXIgPyBuZXcgJHV0aWwuTG9uZ0JpdHMobWVzc2FnZS5kaW1WYWx1ZS5sb3cgPj4+IDAsIG1lc3NhZ2UuZGltVmFsdWUuaGlnaCA+Pj4gMCkudG9OdW1iZXIoKSA6IG1lc3NhZ2UuZGltVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLm9uZW9mcylcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdC52YWx1ZSA9IFwiZGltVmFsdWVcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZGltUGFyYW0gIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZGltUGFyYW1cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LmRpbVBhcmFtID0gbWVzc2FnZS5kaW1QYXJhbTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMub25lb2ZzKVxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0LnZhbHVlID0gXCJkaW1QYXJhbVwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZS5kZW5vdGF0aW9uICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImRlbm90YXRpb25cIikpXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5kZW5vdGF0aW9uID0gbWVzc2FnZS5kZW5vdGF0aW9uO1xuICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIENvbnZlcnRzIHRoaXMgRGltZW5zaW9uIHRvIEpTT04uXG4gICAgICAgICAgICAgKiBAZnVuY3Rpb24gdG9KU09OXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JTaGFwZVByb3RvLkRpbWVuc2lvblxuICAgICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IEpTT04gb2JqZWN0XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIERpbWVuc2lvbi5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsICRwcm90b2J1Zi51dGlsLnRvSlNPTk9wdGlvbnMpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZXRzIHRoZSBkZWZhdWx0IHR5cGUgdXJsIGZvciBEaW1lbnNpb25cbiAgICAgICAgICAgICAqIEBmdW5jdGlvbiBnZXRUeXBlVXJsXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JTaGFwZVByb3RvLkRpbWVuc2lvblxuICAgICAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFt0eXBlVXJsUHJlZml4XSB5b3VyIGN1c3RvbSB0eXBlVXJsUHJlZml4KGRlZmF1bHQgXCJ0eXBlLmdvb2dsZWFwaXMuY29tXCIpXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgZGVmYXVsdCB0eXBlIHVybFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBEaW1lbnNpb24uZ2V0VHlwZVVybCA9IGZ1bmN0aW9uIGdldFR5cGVVcmwodHlwZVVybFByZWZpeCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlVXJsUHJlZml4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZVVybFByZWZpeCA9IFwidHlwZS5nb29nbGVhcGlzLmNvbVwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZVVybFByZWZpeCArIFwiL29ubnguVGVuc29yU2hhcGVQcm90by5EaW1lbnNpb25cIjtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJldHVybiBEaW1lbnNpb247XG4gICAgICAgIH0pKCk7XG5cbiAgICAgICAgcmV0dXJuIFRlbnNvclNoYXBlUHJvdG87XG4gICAgfSkoKTtcblxuICAgIG9ubnguVHlwZVByb3RvID0gKGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm9wZXJ0aWVzIG9mIGEgVHlwZVByb3RvLlxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueFxuICAgICAgICAgKiBAaW50ZXJmYWNlIElUeXBlUHJvdG9cbiAgICAgICAgICogQHByb3BlcnR5IHtvbm54LlR5cGVQcm90by5JVGVuc29yfG51bGx9IFt0ZW5zb3JUeXBlXSBUeXBlUHJvdG8gdGVuc29yVHlwZVxuICAgICAgICAgKiBAcHJvcGVydHkge29ubnguVHlwZVByb3RvLklTZXF1ZW5jZXxudWxsfSBbc2VxdWVuY2VUeXBlXSBUeXBlUHJvdG8gc2VxdWVuY2VUeXBlXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7b25ueC5UeXBlUHJvdG8uSU1hcHxudWxsfSBbbWFwVHlwZV0gVHlwZVByb3RvIG1hcFR5cGVcbiAgICAgICAgICogQHByb3BlcnR5IHtvbm54LlR5cGVQcm90by5JT3B0aW9uYWx8bnVsbH0gW29wdGlvbmFsVHlwZV0gVHlwZVByb3RvIG9wdGlvbmFsVHlwZVxuICAgICAgICAgKiBAcHJvcGVydHkge29ubnguVHlwZVByb3RvLklTcGFyc2VUZW5zb3J8bnVsbH0gW3NwYXJzZVRlbnNvclR5cGVdIFR5cGVQcm90byBzcGFyc2VUZW5zb3JUeXBlXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfG51bGx9IFtkZW5vdGF0aW9uXSBUeXBlUHJvdG8gZGVub3RhdGlvblxuICAgICAgICAgKi9cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29uc3RydWN0cyBhIG5ldyBUeXBlUHJvdG8uXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54XG4gICAgICAgICAqIEBjbGFzc2Rlc2MgUmVwcmVzZW50cyBhIFR5cGVQcm90by5cbiAgICAgICAgICogQGltcGxlbWVudHMgSVR5cGVQcm90b1xuICAgICAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgICAgICogQHBhcmFtIHtvbm54LklUeXBlUHJvdG89fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIFR5cGVQcm90byhwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICBpZiAocHJvcGVydGllcylcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvcGVydGllcyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXNba2V5c1tpXV0gIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNba2V5c1tpXV0gPSBwcm9wZXJ0aWVzW2tleXNbaV1dO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFR5cGVQcm90byB0ZW5zb3JUeXBlLlxuICAgICAgICAgKiBAbWVtYmVyIHtvbm54LlR5cGVQcm90by5JVGVuc29yfG51bGx8dW5kZWZpbmVkfSB0ZW5zb3JUeXBlXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90b1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIFR5cGVQcm90by5wcm90b3R5cGUudGVuc29yVHlwZSA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFR5cGVQcm90byBzZXF1ZW5jZVR5cGUuXG4gICAgICAgICAqIEBtZW1iZXIge29ubnguVHlwZVByb3RvLklTZXF1ZW5jZXxudWxsfHVuZGVmaW5lZH0gc2VxdWVuY2VUeXBlXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90b1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIFR5cGVQcm90by5wcm90b3R5cGUuc2VxdWVuY2VUeXBlID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVHlwZVByb3RvIG1hcFR5cGUuXG4gICAgICAgICAqIEBtZW1iZXIge29ubnguVHlwZVByb3RvLklNYXB8bnVsbHx1bmRlZmluZWR9IG1hcFR5cGVcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgVHlwZVByb3RvLnByb3RvdHlwZS5tYXBUeXBlID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVHlwZVByb3RvIG9wdGlvbmFsVHlwZS5cbiAgICAgICAgICogQG1lbWJlciB7b25ueC5UeXBlUHJvdG8uSU9wdGlvbmFsfG51bGx8dW5kZWZpbmVkfSBvcHRpb25hbFR5cGVcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgVHlwZVByb3RvLnByb3RvdHlwZS5vcHRpb25hbFR5cGUgPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUeXBlUHJvdG8gc3BhcnNlVGVuc29yVHlwZS5cbiAgICAgICAgICogQG1lbWJlciB7b25ueC5UeXBlUHJvdG8uSVNwYXJzZVRlbnNvcnxudWxsfHVuZGVmaW5lZH0gc3BhcnNlVGVuc29yVHlwZVxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBUeXBlUHJvdG8ucHJvdG90eXBlLnNwYXJzZVRlbnNvclR5cGUgPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUeXBlUHJvdG8gZGVub3RhdGlvbi5cbiAgICAgICAgICogQG1lbWJlciB7c3RyaW5nfSBkZW5vdGF0aW9uXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90b1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIFR5cGVQcm90by5wcm90b3R5cGUuZGVub3RhdGlvbiA9IFwiXCI7XG5cbiAgICAgICAgLy8gT25lT2YgZmllbGQgbmFtZXMgYm91bmQgdG8gdmlydHVhbCBnZXR0ZXJzIGFuZCBzZXR0ZXJzXG4gICAgICAgIHZhciAkb25lT2ZGaWVsZHM7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFR5cGVQcm90byB2YWx1ZS5cbiAgICAgICAgICogQG1lbWJlciB7XCJ0ZW5zb3JUeXBlXCJ8XCJzZXF1ZW5jZVR5cGVcInxcIm1hcFR5cGVcInxcIm9wdGlvbmFsVHlwZVwifFwic3BhcnNlVGVuc29yVHlwZVwifHVuZGVmaW5lZH0gdmFsdWVcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFR5cGVQcm90by5wcm90b3R5cGUsIFwidmFsdWVcIiwge1xuICAgICAgICAgICAgZ2V0OiAkdXRpbC5vbmVPZkdldHRlcigkb25lT2ZGaWVsZHMgPSBbXCJ0ZW5zb3JUeXBlXCIsIFwic2VxdWVuY2VUeXBlXCIsIFwibWFwVHlwZVwiLCBcIm9wdGlvbmFsVHlwZVwiLCBcInNwYXJzZVRlbnNvclR5cGVcIl0pLFxuICAgICAgICAgICAgc2V0OiAkdXRpbC5vbmVPZlNldHRlcigkb25lT2ZGaWVsZHMpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgbmV3IFR5cGVQcm90byBpbnN0YW5jZSB1c2luZyB0aGUgc3BlY2lmaWVkIHByb3BlcnRpZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBjcmVhdGVcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtvbm54LklUeXBlUHJvdG89fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAgICAgICAgICogQHJldHVybnMge29ubnguVHlwZVByb3RvfSBUeXBlUHJvdG8gaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIFR5cGVQcm90by5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUocHJvcGVydGllcykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBUeXBlUHJvdG8ocHJvcGVydGllcyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBUeXBlUHJvdG8gbWVzc2FnZS4gRG9lcyBub3QgaW1wbGljaXRseSB7QGxpbmsgb25ueC5UeXBlUHJvdG8udmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBlbmNvZGVcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtvbm54LklUeXBlUHJvdG99IG1lc3NhZ2UgVHlwZVByb3RvIG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0IHRvIGVuY29kZVxuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAgICAgICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAgICAgKi9cbiAgICAgICAgVHlwZVByb3RvLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICAgIGlmICghd3JpdGVyKVxuICAgICAgICAgICAgICAgIHdyaXRlciA9ICRXcml0ZXIuY3JlYXRlKCk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS50ZW5zb3JUeXBlICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJ0ZW5zb3JUeXBlXCIpKVxuICAgICAgICAgICAgICAgICRyb290Lm9ubnguVHlwZVByb3RvLlRlbnNvci5lbmNvZGUobWVzc2FnZS50ZW5zb3JUeXBlLCB3cml0ZXIudWludDMyKC8qIGlkIDEsIHdpcmVUeXBlIDIgPSovMTApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5zZXF1ZW5jZVR5cGUgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcInNlcXVlbmNlVHlwZVwiKSlcbiAgICAgICAgICAgICAgICAkcm9vdC5vbm54LlR5cGVQcm90by5TZXF1ZW5jZS5lbmNvZGUobWVzc2FnZS5zZXF1ZW5jZVR5cGUsIHdyaXRlci51aW50MzIoLyogaWQgNCwgd2lyZVR5cGUgMiA9Ki8zNCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm1hcFR5cGUgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcIm1hcFR5cGVcIikpXG4gICAgICAgICAgICAgICAgJHJvb3Qub25ueC5UeXBlUHJvdG8uTWFwLmVuY29kZShtZXNzYWdlLm1hcFR5cGUsIHdyaXRlci51aW50MzIoLyogaWQgNSwgd2lyZVR5cGUgMiA9Ki80MikuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmRlbm90YXRpb24gIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcImRlbm90YXRpb25cIikpXG4gICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCA2LCB3aXJlVHlwZSAyID0qLzUwKS5zdHJpbmcobWVzc2FnZS5kZW5vdGF0aW9uKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnNwYXJzZVRlbnNvclR5cGUgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcInNwYXJzZVRlbnNvclR5cGVcIikpXG4gICAgICAgICAgICAgICAgJHJvb3Qub25ueC5UeXBlUHJvdG8uU3BhcnNlVGVuc29yLmVuY29kZShtZXNzYWdlLnNwYXJzZVRlbnNvclR5cGUsIHdyaXRlci51aW50MzIoLyogaWQgOCwgd2lyZVR5cGUgMiA9Ki82NikuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm9wdGlvbmFsVHlwZSAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwib3B0aW9uYWxUeXBlXCIpKVxuICAgICAgICAgICAgICAgICRyb290Lm9ubnguVHlwZVByb3RvLk9wdGlvbmFsLmVuY29kZShtZXNzYWdlLm9wdGlvbmFsVHlwZSwgd3JpdGVyLnVpbnQzMigvKiBpZCA5LCB3aXJlVHlwZSAyID0qLzc0KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRW5jb2RlcyB0aGUgc3BlY2lmaWVkIFR5cGVQcm90byBtZXNzYWdlLCBsZW5ndGggZGVsaW1pdGVkLiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayBvbm54LlR5cGVQcm90by52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZFxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge29ubnguSVR5cGVQcm90b30gbWVzc2FnZSBUeXBlUHJvdG8gbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLldyaXRlcn0gW3dyaXRlcl0gV3JpdGVyIHRvIGVuY29kZSB0b1xuICAgICAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXG4gICAgICAgICAqL1xuICAgICAgICBUeXBlUHJvdG8uZW5jb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikubGRlbGltKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlY29kZXMgYSBUeXBlUHJvdG8gbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyIG9yIGJ1ZmZlci5cbiAgICAgICAgICogQGZ1bmN0aW9uIGRlY29kZVxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGhdIE1lc3NhZ2UgbGVuZ3RoIGlmIGtub3duIGJlZm9yZWhhbmRcbiAgICAgICAgICogQHJldHVybnMge29ubnguVHlwZVByb3RvfSBUeXBlUHJvdG9cbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcbiAgICAgICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICAgICAqL1xuICAgICAgICBUeXBlUHJvdG8uZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHJlYWRlciwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgICByZWFkZXIgPSAkUmVhZGVyLmNyZWF0ZShyZWFkZXIpO1xuICAgICAgICAgICAgdmFyIGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGgsIG1lc3NhZ2UgPSBuZXcgJHJvb3Qub25ueC5UeXBlUHJvdG8oKTtcbiAgICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMToge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS50ZW5zb3JUeXBlID0gJHJvb3Qub25ueC5UeXBlUHJvdG8uVGVuc29yLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgNDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zZXF1ZW5jZVR5cGUgPSAkcm9vdC5vbm54LlR5cGVQcm90by5TZXF1ZW5jZS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIDU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UubWFwVHlwZSA9ICRyb290Lm9ubnguVHlwZVByb3RvLk1hcC5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIDk6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uub3B0aW9uYWxUeXBlID0gJHJvb3Qub25ueC5UeXBlUHJvdG8uT3B0aW9uYWwuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSA4OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnNwYXJzZVRlbnNvclR5cGUgPSAkcm9vdC5vbm54LlR5cGVQcm90by5TcGFyc2VUZW5zb3IuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSA2OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmRlbm90YXRpb24gPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlY29kZXMgYSBUeXBlUHJvdG8gbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyIG9yIGJ1ZmZlciwgbGVuZ3RoIGRlbGltaXRlZC5cbiAgICAgICAgICogQGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZFxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgICAgICogQHJldHVybnMge29ubnguVHlwZVByb3RvfSBUeXBlUHJvdG9cbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcbiAgICAgICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICAgICAqL1xuICAgICAgICBUeXBlUHJvdG8uZGVjb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkKHJlYWRlcikge1xuICAgICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgICAgcmVhZGVyID0gbmV3ICRSZWFkZXIocmVhZGVyKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFZlcmlmaWVzIGEgVHlwZVByb3RvIG1lc3NhZ2UuXG4gICAgICAgICAqIEBmdW5jdGlvbiB2ZXJpZnlcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gbWVzc2FnZSBQbGFpbiBvYmplY3QgdG8gdmVyaWZ5XG4gICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd8bnVsbH0gYG51bGxgIGlmIHZhbGlkLCBvdGhlcndpc2UgdGhlIHJlYXNvbiB3aHkgaXQgaXMgbm90XG4gICAgICAgICAqL1xuICAgICAgICBUeXBlUHJvdG8udmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5KG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSAhPT0gXCJvYmplY3RcIiB8fCBtZXNzYWdlID09PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiBcIm9iamVjdCBleHBlY3RlZFwiO1xuICAgICAgICAgICAgdmFyIHByb3BlcnRpZXMgPSB7fTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnRlbnNvclR5cGUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwidGVuc29yVHlwZVwiKSkge1xuICAgICAgICAgICAgICAgIHByb3BlcnRpZXMudmFsdWUgPSAxO1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVycm9yID0gJHJvb3Qub25ueC5UeXBlUHJvdG8uVGVuc29yLnZlcmlmeShtZXNzYWdlLnRlbnNvclR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJ0ZW5zb3JUeXBlLlwiICsgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2Uuc2VxdWVuY2VUeXBlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInNlcXVlbmNlVHlwZVwiKSkge1xuICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzLnZhbHVlID09PSAxKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJ2YWx1ZTogbXVsdGlwbGUgdmFsdWVzXCI7XG4gICAgICAgICAgICAgICAgcHJvcGVydGllcy52YWx1ZSA9IDE7XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXJyb3IgPSAkcm9vdC5vbm54LlR5cGVQcm90by5TZXF1ZW5jZS52ZXJpZnkobWVzc2FnZS5zZXF1ZW5jZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJzZXF1ZW5jZVR5cGUuXCIgKyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5tYXBUeXBlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIm1hcFR5cGVcIikpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllcy52YWx1ZSA9PT0gMSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwidmFsdWU6IG11bHRpcGxlIHZhbHVlc1wiO1xuICAgICAgICAgICAgICAgIHByb3BlcnRpZXMudmFsdWUgPSAxO1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVycm9yID0gJHJvb3Qub25ueC5UeXBlUHJvdG8uTWFwLnZlcmlmeShtZXNzYWdlLm1hcFR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJtYXBUeXBlLlwiICsgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2Uub3B0aW9uYWxUeXBlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIm9wdGlvbmFsVHlwZVwiKSkge1xuICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzLnZhbHVlID09PSAxKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJ2YWx1ZTogbXVsdGlwbGUgdmFsdWVzXCI7XG4gICAgICAgICAgICAgICAgcHJvcGVydGllcy52YWx1ZSA9IDE7XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXJyb3IgPSAkcm9vdC5vbm54LlR5cGVQcm90by5PcHRpb25hbC52ZXJpZnkobWVzc2FnZS5vcHRpb25hbFR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJvcHRpb25hbFR5cGUuXCIgKyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5zcGFyc2VUZW5zb3JUeXBlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInNwYXJzZVRlbnNvclR5cGVcIikpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllcy52YWx1ZSA9PT0gMSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwidmFsdWU6IG11bHRpcGxlIHZhbHVlc1wiO1xuICAgICAgICAgICAgICAgIHByb3BlcnRpZXMudmFsdWUgPSAxO1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVycm9yID0gJHJvb3Qub25ueC5UeXBlUHJvdG8uU3BhcnNlVGVuc29yLnZlcmlmeShtZXNzYWdlLnNwYXJzZVRlbnNvclR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJzcGFyc2VUZW5zb3JUeXBlLlwiICsgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZGVub3RhdGlvbiAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJkZW5vdGF0aW9uXCIpKVxuICAgICAgICAgICAgICAgIGlmICghJHV0aWwuaXNTdHJpbmcobWVzc2FnZS5kZW5vdGF0aW9uKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiZGVub3RhdGlvbjogc3RyaW5nIGV4cGVjdGVkXCI7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIFR5cGVQcm90byBtZXNzYWdlIGZyb20gYSBwbGFpbiBvYmplY3QuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIHRoZWlyIHJlc3BlY3RpdmUgaW50ZXJuYWwgdHlwZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBmcm9tT2JqZWN0XG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG9iamVjdCBQbGFpbiBvYmplY3RcbiAgICAgICAgICogQHJldHVybnMge29ubnguVHlwZVByb3RvfSBUeXBlUHJvdG9cbiAgICAgICAgICovXG4gICAgICAgIFR5cGVQcm90by5mcm9tT2JqZWN0ID0gZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiAkcm9vdC5vbm54LlR5cGVQcm90bylcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBuZXcgJHJvb3Qub25ueC5UeXBlUHJvdG8oKTtcbiAgICAgICAgICAgIGlmIChvYmplY3QudGVuc29yVHlwZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QudGVuc29yVHlwZSAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguVHlwZVByb3RvLnRlbnNvclR5cGU6IG9iamVjdCBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnRlbnNvclR5cGUgPSAkcm9vdC5vbm54LlR5cGVQcm90by5UZW5zb3IuZnJvbU9iamVjdChvYmplY3QudGVuc29yVHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2JqZWN0LnNlcXVlbmNlVHlwZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3Quc2VxdWVuY2VUeXBlICE9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5UeXBlUHJvdG8uc2VxdWVuY2VUeXBlOiBvYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5zZXF1ZW5jZVR5cGUgPSAkcm9vdC5vbm54LlR5cGVQcm90by5TZXF1ZW5jZS5mcm9tT2JqZWN0KG9iamVjdC5zZXF1ZW5jZVR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9iamVjdC5tYXBUeXBlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5tYXBUeXBlICE9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5UeXBlUHJvdG8ubWFwVHlwZTogb2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UubWFwVHlwZSA9ICRyb290Lm9ubnguVHlwZVByb3RvLk1hcC5mcm9tT2JqZWN0KG9iamVjdC5tYXBUeXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvYmplY3Qub3B0aW9uYWxUeXBlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5vcHRpb25hbFR5cGUgIT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5vbm54LlR5cGVQcm90by5vcHRpb25hbFR5cGU6IG9iamVjdCBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLm9wdGlvbmFsVHlwZSA9ICRyb290Lm9ubnguVHlwZVByb3RvLk9wdGlvbmFsLmZyb21PYmplY3Qob2JqZWN0Lm9wdGlvbmFsVHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2JqZWN0LnNwYXJzZVRlbnNvclR5cGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LnNwYXJzZVRlbnNvclR5cGUgIT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5vbm54LlR5cGVQcm90by5zcGFyc2VUZW5zb3JUeXBlOiBvYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5zcGFyc2VUZW5zb3JUeXBlID0gJHJvb3Qub25ueC5UeXBlUHJvdG8uU3BhcnNlVGVuc29yLmZyb21PYmplY3Qob2JqZWN0LnNwYXJzZVRlbnNvclR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9iamVjdC5kZW5vdGF0aW9uICE9IG51bGwpXG4gICAgICAgICAgICAgICAgbWVzc2FnZS5kZW5vdGF0aW9uID0gU3RyaW5nKG9iamVjdC5kZW5vdGF0aW9uKTtcbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgcGxhaW4gb2JqZWN0IGZyb20gYSBUeXBlUHJvdG8gbWVzc2FnZS4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gb3RoZXIgdHlwZXMgaWYgc3BlY2lmaWVkLlxuICAgICAgICAgKiBAZnVuY3Rpb24gdG9PYmplY3RcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtvbm54LlR5cGVQcm90b30gbWVzc2FnZSBUeXBlUHJvdG9cbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuSUNvbnZlcnNpb25PcHRpb25zfSBbb3B0aW9uc10gQ29udmVyc2lvbiBvcHRpb25zXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gUGxhaW4gb2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICBUeXBlUHJvdG8udG9PYmplY3QgPSBmdW5jdGlvbiB0b09iamVjdChtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMpXG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgICAgdmFyIG9iamVjdCA9IHt9O1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGVmYXVsdHMpXG4gICAgICAgICAgICAgICAgb2JqZWN0LmRlbm90YXRpb24gPSBcIlwiO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UudGVuc29yVHlwZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJ0ZW5zb3JUeXBlXCIpKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0LnRlbnNvclR5cGUgPSAkcm9vdC5vbm54LlR5cGVQcm90by5UZW5zb3IudG9PYmplY3QobWVzc2FnZS50ZW5zb3JUeXBlLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5vbmVvZnMpXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC52YWx1ZSA9IFwidGVuc29yVHlwZVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2Uuc2VxdWVuY2VUeXBlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInNlcXVlbmNlVHlwZVwiKSkge1xuICAgICAgICAgICAgICAgIG9iamVjdC5zZXF1ZW5jZVR5cGUgPSAkcm9vdC5vbm54LlR5cGVQcm90by5TZXF1ZW5jZS50b09iamVjdChtZXNzYWdlLnNlcXVlbmNlVHlwZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMub25lb2ZzKVxuICAgICAgICAgICAgICAgICAgICBvYmplY3QudmFsdWUgPSBcInNlcXVlbmNlVHlwZVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UubWFwVHlwZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJtYXBUeXBlXCIpKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0Lm1hcFR5cGUgPSAkcm9vdC5vbm54LlR5cGVQcm90by5NYXAudG9PYmplY3QobWVzc2FnZS5tYXBUeXBlLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5vbmVvZnMpXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC52YWx1ZSA9IFwibWFwVHlwZVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZGVub3RhdGlvbiAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJkZW5vdGF0aW9uXCIpKVxuICAgICAgICAgICAgICAgIG9iamVjdC5kZW5vdGF0aW9uID0gbWVzc2FnZS5kZW5vdGF0aW9uO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2Uuc3BhcnNlVGVuc29yVHlwZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJzcGFyc2VUZW5zb3JUeXBlXCIpKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0LnNwYXJzZVRlbnNvclR5cGUgPSAkcm9vdC5vbm54LlR5cGVQcm90by5TcGFyc2VUZW5zb3IudG9PYmplY3QobWVzc2FnZS5zcGFyc2VUZW5zb3JUeXBlLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5vbmVvZnMpXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC52YWx1ZSA9IFwic3BhcnNlVGVuc29yVHlwZVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2Uub3B0aW9uYWxUeXBlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIm9wdGlvbmFsVHlwZVwiKSkge1xuICAgICAgICAgICAgICAgIG9iamVjdC5vcHRpb25hbFR5cGUgPSAkcm9vdC5vbm54LlR5cGVQcm90by5PcHRpb25hbC50b09iamVjdChtZXNzYWdlLm9wdGlvbmFsVHlwZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMub25lb2ZzKVxuICAgICAgICAgICAgICAgICAgICBvYmplY3QudmFsdWUgPSBcIm9wdGlvbmFsVHlwZVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29udmVydHMgdGhpcyBUeXBlUHJvdG8gdG8gSlNPTi5cbiAgICAgICAgICogQGZ1bmN0aW9uIHRvSlNPTlxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gSlNPTiBvYmplY3RcbiAgICAgICAgICovXG4gICAgICAgIFR5cGVQcm90by5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcywgJHByb3RvYnVmLnV0aWwudG9KU09OT3B0aW9ucyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHMgdGhlIGRlZmF1bHQgdHlwZSB1cmwgZm9yIFR5cGVQcm90b1xuICAgICAgICAgKiBAZnVuY3Rpb24gZ2V0VHlwZVVybFxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3R5cGVVcmxQcmVmaXhdIHlvdXIgY3VzdG9tIHR5cGVVcmxQcmVmaXgoZGVmYXVsdCBcInR5cGUuZ29vZ2xlYXBpcy5jb21cIilcbiAgICAgICAgICogQHJldHVybnMge3N0cmluZ30gVGhlIGRlZmF1bHQgdHlwZSB1cmxcbiAgICAgICAgICovXG4gICAgICAgIFR5cGVQcm90by5nZXRUeXBlVXJsID0gZnVuY3Rpb24gZ2V0VHlwZVVybCh0eXBlVXJsUHJlZml4KSB7XG4gICAgICAgICAgICBpZiAodHlwZVVybFByZWZpeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdHlwZVVybFByZWZpeCA9IFwidHlwZS5nb29nbGVhcGlzLmNvbVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHR5cGVVcmxQcmVmaXggKyBcIi9vbm54LlR5cGVQcm90b1wiO1xuICAgICAgICB9O1xuXG4gICAgICAgIFR5cGVQcm90by5UZW5zb3IgPSAoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUHJvcGVydGllcyBvZiBhIFRlbnNvci5cbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90b1xuICAgICAgICAgICAgICogQGludGVyZmFjZSBJVGVuc29yXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcnxudWxsfSBbZWxlbVR5cGVdIFRlbnNvciBlbGVtVHlwZVxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtvbm54LklUZW5zb3JTaGFwZVByb3RvfG51bGx9IFtzaGFwZV0gVGVuc29yIHNoYXBlXG4gICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IFRlbnNvci5cbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90b1xuICAgICAgICAgICAgICogQGNsYXNzZGVzYyBSZXByZXNlbnRzIGEgVGVuc29yLlxuICAgICAgICAgICAgICogQGltcGxlbWVudHMgSVRlbnNvclxuICAgICAgICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgICAgICAgKiBAcGFyYW0ge29ubnguVHlwZVByb3RvLklUZW5zb3I9fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gVGVuc29yKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllcylcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllc1trZXlzW2ldXSAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNba2V5c1tpXV0gPSBwcm9wZXJ0aWVzW2tleXNbaV1dO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRlbnNvciBlbGVtVHlwZS5cbiAgICAgICAgICAgICAqIEBtZW1iZXIge251bWJlcn0gZWxlbVR5cGVcbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90by5UZW5zb3JcbiAgICAgICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBUZW5zb3IucHJvdG90eXBlLmVsZW1UeXBlID0gMDtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUZW5zb3Igc2hhcGUuXG4gICAgICAgICAgICAgKiBAbWVtYmVyIHtvbm54LklUZW5zb3JTaGFwZVByb3RvfG51bGx8dW5kZWZpbmVkfSBzaGFwZVxuICAgICAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvLlRlbnNvclxuICAgICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFRlbnNvci5wcm90b3R5cGUuc2hhcGUgPSBudWxsO1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIENyZWF0ZXMgYSBuZXcgVGVuc29yIGluc3RhbmNlIHVzaW5nIHRoZSBzcGVjaWZpZWQgcHJvcGVydGllcy5cbiAgICAgICAgICAgICAqIEBmdW5jdGlvbiBjcmVhdGVcbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90by5UZW5zb3JcbiAgICAgICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICAgICAqIEBwYXJhbSB7b25ueC5UeXBlUHJvdG8uSVRlbnNvcj19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxuICAgICAgICAgICAgICogQHJldHVybnMge29ubnguVHlwZVByb3RvLlRlbnNvcn0gVGVuc29yIGluc3RhbmNlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFRlbnNvci5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUocHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVGVuc29yKHByb3BlcnRpZXMpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgVGVuc29yIG1lc3NhZ2UuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIG9ubnguVHlwZVByb3RvLlRlbnNvci52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cbiAgICAgICAgICAgICAqIEBmdW5jdGlvbiBlbmNvZGVcbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90by5UZW5zb3JcbiAgICAgICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICAgICAqIEBwYXJhbSB7b25ueC5UeXBlUHJvdG8uSVRlbnNvcn0gbWVzc2FnZSBUZW5zb3IgbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXG4gICAgICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAgICAgICAgICAgICAqIEByZXR1cm5zIHskcHJvdG9idWYuV3JpdGVyfSBXcml0ZXJcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgVGVuc29yLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXdyaXRlcilcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVyID0gJFdyaXRlci5jcmVhdGUoKTtcbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZS5lbGVtVHlwZSAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwiZWxlbVR5cGVcIikpXG4gICAgICAgICAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMSwgd2lyZVR5cGUgMCA9Ki84KS5pbnQzMihtZXNzYWdlLmVsZW1UeXBlKTtcbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZS5zaGFwZSAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwic2hhcGVcIikpXG4gICAgICAgICAgICAgICAgICAgICRyb290Lm9ubnguVGVuc29yU2hhcGVQcm90by5lbmNvZGUobWVzc2FnZS5zaGFwZSwgd3JpdGVyLnVpbnQzMigvKiBpZCAyLCB3aXJlVHlwZSAyID0qLzE4KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBUZW5zb3IgbWVzc2FnZSwgbGVuZ3RoIGRlbGltaXRlZC4gRG9lcyBub3QgaW1wbGljaXRseSB7QGxpbmsgb25ueC5UeXBlUHJvdG8uVGVuc29yLnZlcmlmeXx2ZXJpZnl9IG1lc3NhZ2VzLlxuICAgICAgICAgICAgICogQGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZFxuICAgICAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvLlRlbnNvclxuICAgICAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgICAgICogQHBhcmFtIHtvbm54LlR5cGVQcm90by5JVGVuc29yfSBtZXNzYWdlIFRlbnNvciBtZXNzYWdlIG9yIHBsYWluIG9iamVjdCB0byBlbmNvZGVcbiAgICAgICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLldyaXRlcn0gW3dyaXRlcl0gV3JpdGVyIHRvIGVuY29kZSB0b1xuICAgICAgICAgICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBUZW5zb3IuZW5jb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVuY29kZShtZXNzYWdlLCB3cml0ZXIpLmxkZWxpbSgpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBEZWNvZGVzIGEgVGVuc29yIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIuXG4gICAgICAgICAgICAgKiBAZnVuY3Rpb24gZGVjb2RlXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG8uVGVuc29yXG4gICAgICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoXSBNZXNzYWdlIGxlbmd0aCBpZiBrbm93biBiZWZvcmVoYW5kXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7b25ueC5UeXBlUHJvdG8uVGVuc29yfSBUZW5zb3JcbiAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICAgICAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgVGVuc29yLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyZWFkZXIsIGxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgICAgICAgICByZWFkZXIgPSAkUmVhZGVyLmNyZWF0ZShyZWFkZXIpO1xuICAgICAgICAgICAgICAgIHZhciBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoLCBtZXNzYWdlID0gbmV3ICRyb290Lm9ubnguVHlwZVByb3RvLlRlbnNvcigpO1xuICAgICAgICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZWxlbVR5cGUgPSByZWFkZXIuaW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zaGFwZSA9ICRyb290Lm9ubnguVGVuc29yU2hhcGVQcm90by5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIERlY29kZXMgYSBUZW5zb3IgbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyIG9yIGJ1ZmZlciwgbGVuZ3RoIGRlbGltaXRlZC5cbiAgICAgICAgICAgICAqIEBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWRcbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90by5UZW5zb3JcbiAgICAgICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLlJlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGUgZnJvbVxuICAgICAgICAgICAgICogQHJldHVybnMge29ubnguVHlwZVByb3RvLlRlbnNvcn0gVGVuc29yXG4gICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAgICAgICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFRlbnNvci5kZWNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWQocmVhZGVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgICAgICAgIHJlYWRlciA9IG5ldyAkUmVhZGVyKHJlYWRlcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVmVyaWZpZXMgYSBUZW5zb3IgbWVzc2FnZS5cbiAgICAgICAgICAgICAqIEBmdW5jdGlvbiB2ZXJpZnlcbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90by5UZW5zb3JcbiAgICAgICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG1lc3NhZ2UgUGxhaW4gb2JqZWN0IHRvIHZlcmlmeVxuICAgICAgICAgICAgICogQHJldHVybnMge3N0cmluZ3xudWxsfSBgbnVsbGAgaWYgdmFsaWQsIG90aGVyd2lzZSB0aGUgcmVhc29uIHdoeSBpdCBpcyBub3RcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgVGVuc29yLnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlICE9PSBcIm9iamVjdFwiIHx8IG1lc3NhZ2UgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIm9iamVjdCBleHBlY3RlZFwiO1xuICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLmVsZW1UeXBlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImVsZW1UeXBlXCIpKVxuICAgICAgICAgICAgICAgICAgICBpZiAoISR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLmVsZW1UeXBlKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcImVsZW1UeXBlOiBpbnRlZ2VyIGV4cGVjdGVkXCI7XG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2Uuc2hhcGUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwic2hhcGVcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVycm9yID0gJHJvb3Qub25ueC5UZW5zb3JTaGFwZVByb3RvLnZlcmlmeShtZXNzYWdlLnNoYXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwic2hhcGUuXCIgKyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIENyZWF0ZXMgYSBUZW5zb3IgbWVzc2FnZSBmcm9tIGEgcGxhaW4gb2JqZWN0LiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byB0aGVpciByZXNwZWN0aXZlIGludGVybmFsIHR5cGVzLlxuICAgICAgICAgICAgICogQGZ1bmN0aW9uIGZyb21PYmplY3RcbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90by5UZW5zb3JcbiAgICAgICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG9iamVjdCBQbGFpbiBvYmplY3RcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtvbm54LlR5cGVQcm90by5UZW5zb3J9IFRlbnNvclxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBUZW5zb3IuZnJvbU9iamVjdCA9IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mICRyb290Lm9ubnguVHlwZVByb3RvLlRlbnNvcilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgICAgICAgICB2YXIgbWVzc2FnZSA9IG5ldyAkcm9vdC5vbm54LlR5cGVQcm90by5UZW5zb3IoKTtcbiAgICAgICAgICAgICAgICBpZiAob2JqZWN0LmVsZW1UeXBlICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZWxlbVR5cGUgPSBvYmplY3QuZWxlbVR5cGUgfCAwO1xuICAgICAgICAgICAgICAgIGlmIChvYmplY3Quc2hhcGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5zaGFwZSAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5vbm54LlR5cGVQcm90by5UZW5zb3Iuc2hhcGU6IG9iamVjdCBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zaGFwZSA9ICRyb290Lm9ubnguVGVuc29yU2hhcGVQcm90by5mcm9tT2JqZWN0KG9iamVjdC5zaGFwZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDcmVhdGVzIGEgcGxhaW4gb2JqZWN0IGZyb20gYSBUZW5zb3IgbWVzc2FnZS4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gb3RoZXIgdHlwZXMgaWYgc3BlY2lmaWVkLlxuICAgICAgICAgICAgICogQGZ1bmN0aW9uIHRvT2JqZWN0XG4gICAgICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG8uVGVuc29yXG4gICAgICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAgICAgKiBAcGFyYW0ge29ubnguVHlwZVByb3RvLlRlbnNvcn0gbWVzc2FnZSBUZW5zb3JcbiAgICAgICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLklDb252ZXJzaW9uT3B0aW9uc30gW29wdGlvbnNdIENvbnZlcnNpb24gb3B0aW9uc1xuICAgICAgICAgICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBQbGFpbiBvYmplY3RcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgVGVuc29yLnRvT2JqZWN0ID0gZnVuY3Rpb24gdG9PYmplY3QobWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgICAgIGlmICghb3B0aW9ucylcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgICAgICAgIHZhciBvYmplY3QgPSB7fTtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5kZWZhdWx0cykge1xuICAgICAgICAgICAgICAgICAgICBvYmplY3QuZWxlbVR5cGUgPSAwO1xuICAgICAgICAgICAgICAgICAgICBvYmplY3Quc2hhcGUgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZS5lbGVtVHlwZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJlbGVtVHlwZVwiKSlcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LmVsZW1UeXBlID0gbWVzc2FnZS5lbGVtVHlwZTtcbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZS5zaGFwZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJzaGFwZVwiKSlcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LnNoYXBlID0gJHJvb3Qub25ueC5UZW5zb3JTaGFwZVByb3RvLnRvT2JqZWN0KG1lc3NhZ2Uuc2hhcGUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIENvbnZlcnRzIHRoaXMgVGVuc29yIHRvIEpTT04uXG4gICAgICAgICAgICAgKiBAZnVuY3Rpb24gdG9KU09OXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG8uVGVuc29yXG4gICAgICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gSlNPTiBvYmplY3RcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgVGVuc29yLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcywgJHByb3RvYnVmLnV0aWwudG9KU09OT3B0aW9ucyk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEdldHMgdGhlIGRlZmF1bHQgdHlwZSB1cmwgZm9yIFRlbnNvclxuICAgICAgICAgICAgICogQGZ1bmN0aW9uIGdldFR5cGVVcmxcbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90by5UZW5zb3JcbiAgICAgICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbdHlwZVVybFByZWZpeF0geW91ciBjdXN0b20gdHlwZVVybFByZWZpeChkZWZhdWx0IFwidHlwZS5nb29nbGVhcGlzLmNvbVwiKVxuICAgICAgICAgICAgICogQHJldHVybnMge3N0cmluZ30gVGhlIGRlZmF1bHQgdHlwZSB1cmxcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgVGVuc29yLmdldFR5cGVVcmwgPSBmdW5jdGlvbiBnZXRUeXBlVXJsKHR5cGVVcmxQcmVmaXgpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZVVybFByZWZpeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGVVcmxQcmVmaXggPSBcInR5cGUuZ29vZ2xlYXBpcy5jb21cIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVVcmxQcmVmaXggKyBcIi9vbm54LlR5cGVQcm90by5UZW5zb3JcIjtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJldHVybiBUZW5zb3I7XG4gICAgICAgIH0pKCk7XG5cbiAgICAgICAgVHlwZVByb3RvLlNlcXVlbmNlID0gKGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFByb3BlcnRpZXMgb2YgYSBTZXF1ZW5jZS5cbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90b1xuICAgICAgICAgICAgICogQGludGVyZmFjZSBJU2VxdWVuY2VcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7b25ueC5JVHlwZVByb3RvfG51bGx9IFtlbGVtVHlwZV0gU2VxdWVuY2UgZWxlbVR5cGVcbiAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIENvbnN0cnVjdHMgYSBuZXcgU2VxdWVuY2UuXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG9cbiAgICAgICAgICAgICAqIEBjbGFzc2Rlc2MgUmVwcmVzZW50cyBhIFNlcXVlbmNlLlxuICAgICAgICAgICAgICogQGltcGxlbWVudHMgSVNlcXVlbmNlXG4gICAgICAgICAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgICAgICAgICAqIEBwYXJhbSB7b25ueC5UeXBlUHJvdG8uSVNlcXVlbmNlPX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIFNlcXVlbmNlKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllcylcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllc1trZXlzW2ldXSAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNba2V5c1tpXV0gPSBwcm9wZXJ0aWVzW2tleXNbaV1dO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFNlcXVlbmNlIGVsZW1UeXBlLlxuICAgICAgICAgICAgICogQG1lbWJlciB7b25ueC5JVHlwZVByb3RvfG51bGx8dW5kZWZpbmVkfSBlbGVtVHlwZVxuICAgICAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvLlNlcXVlbmNlXG4gICAgICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgU2VxdWVuY2UucHJvdG90eXBlLmVsZW1UeXBlID0gbnVsbDtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDcmVhdGVzIGEgbmV3IFNlcXVlbmNlIGluc3RhbmNlIHVzaW5nIHRoZSBzcGVjaWZpZWQgcHJvcGVydGllcy5cbiAgICAgICAgICAgICAqIEBmdW5jdGlvbiBjcmVhdGVcbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90by5TZXF1ZW5jZVxuICAgICAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgICAgICogQHBhcmFtIHtvbm54LlR5cGVQcm90by5JU2VxdWVuY2U9fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtvbm54LlR5cGVQcm90by5TZXF1ZW5jZX0gU2VxdWVuY2UgaW5zdGFuY2VcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgU2VxdWVuY2UuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFNlcXVlbmNlKHByb3BlcnRpZXMpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgU2VxdWVuY2UgbWVzc2FnZS4gRG9lcyBub3QgaW1wbGljaXRseSB7QGxpbmsgb25ueC5UeXBlUHJvdG8uU2VxdWVuY2UudmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXG4gICAgICAgICAgICAgKiBAZnVuY3Rpb24gZW5jb2RlXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG8uU2VxdWVuY2VcbiAgICAgICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICAgICAqIEBwYXJhbSB7b25ueC5UeXBlUHJvdG8uSVNlcXVlbmNlfSBtZXNzYWdlIFNlcXVlbmNlIG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0IHRvIGVuY29kZVxuICAgICAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuV3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gZW5jb2RlIHRvXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFNlcXVlbmNlLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXdyaXRlcilcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVyID0gJFdyaXRlci5jcmVhdGUoKTtcbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZS5lbGVtVHlwZSAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwiZWxlbVR5cGVcIikpXG4gICAgICAgICAgICAgICAgICAgICRyb290Lm9ubnguVHlwZVByb3RvLmVuY29kZShtZXNzYWdlLmVsZW1UeXBlLCB3cml0ZXIudWludDMyKC8qIGlkIDEsIHdpcmVUeXBlIDIgPSovMTApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRW5jb2RlcyB0aGUgc3BlY2lmaWVkIFNlcXVlbmNlIG1lc3NhZ2UsIGxlbmd0aCBkZWxpbWl0ZWQuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIG9ubnguVHlwZVByb3RvLlNlcXVlbmNlLnZlcmlmeXx2ZXJpZnl9IG1lc3NhZ2VzLlxuICAgICAgICAgICAgICogQGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZFxuICAgICAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvLlNlcXVlbmNlXG4gICAgICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAgICAgKiBAcGFyYW0ge29ubnguVHlwZVByb3RvLklTZXF1ZW5jZX0gbWVzc2FnZSBTZXF1ZW5jZSBtZXNzYWdlIG9yIHBsYWluIG9iamVjdCB0byBlbmNvZGVcbiAgICAgICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLldyaXRlcn0gW3dyaXRlcl0gV3JpdGVyIHRvIGVuY29kZSB0b1xuICAgICAgICAgICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBTZXF1ZW5jZS5lbmNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWQobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikubGRlbGltKCk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIERlY29kZXMgYSBTZXF1ZW5jZSBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLlxuICAgICAgICAgICAgICogQGZ1bmN0aW9uIGRlY29kZVxuICAgICAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvLlNlcXVlbmNlXG4gICAgICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoXSBNZXNzYWdlIGxlbmd0aCBpZiBrbm93biBiZWZvcmVoYW5kXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7b25ueC5UeXBlUHJvdG8uU2VxdWVuY2V9IFNlcXVlbmNlXG4gICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAgICAgICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFNlcXVlbmNlLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyZWFkZXIsIGxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgICAgICAgICByZWFkZXIgPSAkUmVhZGVyLmNyZWF0ZShyZWFkZXIpO1xuICAgICAgICAgICAgICAgIHZhciBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoLCBtZXNzYWdlID0gbmV3ICRyb290Lm9ubnguVHlwZVByb3RvLlNlcXVlbmNlKCk7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5lbGVtVHlwZSA9ICRyb290Lm9ubnguVHlwZVByb3RvLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRGVjb2RlcyBhIFNlcXVlbmNlIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIsIGxlbmd0aCBkZWxpbWl0ZWQuXG4gICAgICAgICAgICAgKiBAZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG8uU2VxdWVuY2VcbiAgICAgICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLlJlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGUgZnJvbVxuICAgICAgICAgICAgICogQHJldHVybnMge29ubnguVHlwZVByb3RvLlNlcXVlbmNlfSBTZXF1ZW5jZVxuICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcbiAgICAgICAgICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBTZXF1ZW5jZS5kZWNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWQocmVhZGVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgICAgICAgIHJlYWRlciA9IG5ldyAkUmVhZGVyKHJlYWRlcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVmVyaWZpZXMgYSBTZXF1ZW5jZSBtZXNzYWdlLlxuICAgICAgICAgICAgICogQGZ1bmN0aW9uIHZlcmlmeVxuICAgICAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvLlNlcXVlbmNlXG4gICAgICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBtZXNzYWdlIFBsYWluIG9iamVjdCB0byB2ZXJpZnlcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd8bnVsbH0gYG51bGxgIGlmIHZhbGlkLCBvdGhlcndpc2UgdGhlIHJlYXNvbiB3aHkgaXQgaXMgbm90XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFNlcXVlbmNlLnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlICE9PSBcIm9iamVjdFwiIHx8IG1lc3NhZ2UgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIm9iamVjdCBleHBlY3RlZFwiO1xuICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLmVsZW1UeXBlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImVsZW1UeXBlXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlcnJvciA9ICRyb290Lm9ubnguVHlwZVByb3RvLnZlcmlmeShtZXNzYWdlLmVsZW1UeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiZWxlbVR5cGUuXCIgKyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIENyZWF0ZXMgYSBTZXF1ZW5jZSBtZXNzYWdlIGZyb20gYSBwbGFpbiBvYmplY3QuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIHRoZWlyIHJlc3BlY3RpdmUgaW50ZXJuYWwgdHlwZXMuXG4gICAgICAgICAgICAgKiBAZnVuY3Rpb24gZnJvbU9iamVjdFxuICAgICAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvLlNlcXVlbmNlXG4gICAgICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBvYmplY3QgUGxhaW4gb2JqZWN0XG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7b25ueC5UeXBlUHJvdG8uU2VxdWVuY2V9IFNlcXVlbmNlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFNlcXVlbmNlLmZyb21PYmplY3QgPSBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgICAgICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiAkcm9vdC5vbm54LlR5cGVQcm90by5TZXF1ZW5jZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgICAgICAgICB2YXIgbWVzc2FnZSA9IG5ldyAkcm9vdC5vbm54LlR5cGVQcm90by5TZXF1ZW5jZSgpO1xuICAgICAgICAgICAgICAgIGlmIChvYmplY3QuZWxlbVR5cGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5lbGVtVHlwZSAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5vbm54LlR5cGVQcm90by5TZXF1ZW5jZS5lbGVtVHlwZTogb2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmVsZW1UeXBlID0gJHJvb3Qub25ueC5UeXBlUHJvdG8uZnJvbU9iamVjdChvYmplY3QuZWxlbVR5cGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ3JlYXRlcyBhIHBsYWluIG9iamVjdCBmcm9tIGEgU2VxdWVuY2UgbWVzc2FnZS4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gb3RoZXIgdHlwZXMgaWYgc3BlY2lmaWVkLlxuICAgICAgICAgICAgICogQGZ1bmN0aW9uIHRvT2JqZWN0XG4gICAgICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG8uU2VxdWVuY2VcbiAgICAgICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICAgICAqIEBwYXJhbSB7b25ueC5UeXBlUHJvdG8uU2VxdWVuY2V9IG1lc3NhZ2UgU2VxdWVuY2VcbiAgICAgICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLklDb252ZXJzaW9uT3B0aW9uc30gW29wdGlvbnNdIENvbnZlcnNpb24gb3B0aW9uc1xuICAgICAgICAgICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBQbGFpbiBvYmplY3RcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgU2VxdWVuY2UudG9PYmplY3QgPSBmdW5jdGlvbiB0b09iamVjdChtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFvcHRpb25zKVxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgICAgICAgICAgdmFyIG9iamVjdCA9IHt9O1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmRlZmF1bHRzKVxuICAgICAgICAgICAgICAgICAgICBvYmplY3QuZWxlbVR5cGUgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLmVsZW1UeXBlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImVsZW1UeXBlXCIpKVxuICAgICAgICAgICAgICAgICAgICBvYmplY3QuZWxlbVR5cGUgPSAkcm9vdC5vbm54LlR5cGVQcm90by50b09iamVjdChtZXNzYWdlLmVsZW1UeXBlLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDb252ZXJ0cyB0aGlzIFNlcXVlbmNlIHRvIEpTT04uXG4gICAgICAgICAgICAgKiBAZnVuY3Rpb24gdG9KU09OXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG8uU2VxdWVuY2VcbiAgICAgICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBKU09OIG9iamVjdFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBTZXF1ZW5jZS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsICRwcm90b2J1Zi51dGlsLnRvSlNPTk9wdGlvbnMpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZXRzIHRoZSBkZWZhdWx0IHR5cGUgdXJsIGZvciBTZXF1ZW5jZVxuICAgICAgICAgICAgICogQGZ1bmN0aW9uIGdldFR5cGVVcmxcbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90by5TZXF1ZW5jZVxuICAgICAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFt0eXBlVXJsUHJlZml4XSB5b3VyIGN1c3RvbSB0eXBlVXJsUHJlZml4KGRlZmF1bHQgXCJ0eXBlLmdvb2dsZWFwaXMuY29tXCIpXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgZGVmYXVsdCB0eXBlIHVybFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBTZXF1ZW5jZS5nZXRUeXBlVXJsID0gZnVuY3Rpb24gZ2V0VHlwZVVybCh0eXBlVXJsUHJlZml4KSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVVcmxQcmVmaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0eXBlVXJsUHJlZml4ID0gXCJ0eXBlLmdvb2dsZWFwaXMuY29tXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlVXJsUHJlZml4ICsgXCIvb25ueC5UeXBlUHJvdG8uU2VxdWVuY2VcIjtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJldHVybiBTZXF1ZW5jZTtcbiAgICAgICAgfSkoKTtcblxuICAgICAgICBUeXBlUHJvdG8uTWFwID0gKGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFByb3BlcnRpZXMgb2YgYSBNYXAuXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG9cbiAgICAgICAgICAgICAqIEBpbnRlcmZhY2UgSU1hcFxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ8bnVsbH0gW2tleVR5cGVdIE1hcCBrZXlUeXBlXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge29ubnguSVR5cGVQcm90b3xudWxsfSBbdmFsdWVUeXBlXSBNYXAgdmFsdWVUeXBlXG4gICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IE1hcC5cbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90b1xuICAgICAgICAgICAgICogQGNsYXNzZGVzYyBSZXByZXNlbnRzIGEgTWFwLlxuICAgICAgICAgICAgICogQGltcGxlbWVudHMgSU1hcFxuICAgICAgICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgICAgICAgKiBAcGFyYW0ge29ubnguVHlwZVByb3RvLklNYXA9fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gTWFwKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllcylcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllc1trZXlzW2ldXSAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNba2V5c1tpXV0gPSBwcm9wZXJ0aWVzW2tleXNbaV1dO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIE1hcCBrZXlUeXBlLlxuICAgICAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfSBrZXlUeXBlXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG8uTWFwXG4gICAgICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgTWFwLnByb3RvdHlwZS5rZXlUeXBlID0gMDtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBNYXAgdmFsdWVUeXBlLlxuICAgICAgICAgICAgICogQG1lbWJlciB7b25ueC5JVHlwZVByb3RvfG51bGx8dW5kZWZpbmVkfSB2YWx1ZVR5cGVcbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90by5NYXBcbiAgICAgICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBNYXAucHJvdG90eXBlLnZhbHVlVHlwZSA9IG51bGw7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ3JlYXRlcyBhIG5ldyBNYXAgaW5zdGFuY2UgdXNpbmcgdGhlIHNwZWNpZmllZCBwcm9wZXJ0aWVzLlxuICAgICAgICAgICAgICogQGZ1bmN0aW9uIGNyZWF0ZVxuICAgICAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvLk1hcFxuICAgICAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgICAgICogQHBhcmFtIHtvbm54LlR5cGVQcm90by5JTWFwPX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7b25ueC5UeXBlUHJvdG8uTWFwfSBNYXAgaW5zdGFuY2VcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgTWFwLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBNYXAocHJvcGVydGllcyk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBNYXAgbWVzc2FnZS4gRG9lcyBub3QgaW1wbGljaXRseSB7QGxpbmsgb25ueC5UeXBlUHJvdG8uTWFwLnZlcmlmeXx2ZXJpZnl9IG1lc3NhZ2VzLlxuICAgICAgICAgICAgICogQGZ1bmN0aW9uIGVuY29kZVxuICAgICAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvLk1hcFxuICAgICAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgICAgICogQHBhcmFtIHtvbm54LlR5cGVQcm90by5JTWFwfSBtZXNzYWdlIE1hcCBtZXNzYWdlIG9yIHBsYWluIG9iamVjdCB0byBlbmNvZGVcbiAgICAgICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLldyaXRlcn0gW3dyaXRlcl0gV3JpdGVyIHRvIGVuY29kZSB0b1xuICAgICAgICAgICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBNYXAuZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgICAgICAgIGlmICghd3JpdGVyKVxuICAgICAgICAgICAgICAgICAgICB3cml0ZXIgPSAkV3JpdGVyLmNyZWF0ZSgpO1xuICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLmtleVR5cGUgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcImtleVR5cGVcIikpXG4gICAgICAgICAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMSwgd2lyZVR5cGUgMCA9Ki84KS5pbnQzMihtZXNzYWdlLmtleVR5cGUpO1xuICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLnZhbHVlVHlwZSAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwidmFsdWVUeXBlXCIpKVxuICAgICAgICAgICAgICAgICAgICAkcm9vdC5vbm54LlR5cGVQcm90by5lbmNvZGUobWVzc2FnZS52YWx1ZVR5cGUsIHdyaXRlci51aW50MzIoLyogaWQgMiwgd2lyZVR5cGUgMiA9Ki8xOCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgTWFwIG1lc3NhZ2UsIGxlbmd0aCBkZWxpbWl0ZWQuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIG9ubnguVHlwZVByb3RvLk1hcC52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cbiAgICAgICAgICAgICAqIEBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWRcbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90by5NYXBcbiAgICAgICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICAgICAqIEBwYXJhbSB7b25ueC5UeXBlUHJvdG8uSU1hcH0gbWVzc2FnZSBNYXAgbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXG4gICAgICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAgICAgICAgICAgICAqIEByZXR1cm5zIHskcHJvdG9idWYuV3JpdGVyfSBXcml0ZXJcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgTWFwLmVuY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZChtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGUobWVzc2FnZSwgd3JpdGVyKS5sZGVsaW0oKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRGVjb2RlcyBhIE1hcCBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLlxuICAgICAgICAgICAgICogQGZ1bmN0aW9uIGRlY29kZVxuICAgICAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvLk1hcFxuICAgICAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aF0gTWVzc2FnZSBsZW5ndGggaWYga25vd24gYmVmb3JlaGFuZFxuICAgICAgICAgICAgICogQHJldHVybnMge29ubnguVHlwZVByb3RvLk1hcH0gTWFwXG4gICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAgICAgICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIE1hcC5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUocmVhZGVyLCBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyID0gJFJlYWRlci5jcmVhdGUocmVhZGVyKTtcbiAgICAgICAgICAgICAgICB2YXIgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aCwgbWVzc2FnZSA9IG5ldyAkcm9vdC5vbm54LlR5cGVQcm90by5NYXAoKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmtleVR5cGUgPSByZWFkZXIuaW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS52YWx1ZVR5cGUgPSAkcm9vdC5vbm54LlR5cGVQcm90by5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIERlY29kZXMgYSBNYXAgbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyIG9yIGJ1ZmZlciwgbGVuZ3RoIGRlbGltaXRlZC5cbiAgICAgICAgICAgICAqIEBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWRcbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90by5NYXBcbiAgICAgICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLlJlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGUgZnJvbVxuICAgICAgICAgICAgICogQHJldHVybnMge29ubnguVHlwZVByb3RvLk1hcH0gTWFwXG4gICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAgICAgICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIE1hcC5kZWNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWQocmVhZGVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgICAgICAgIHJlYWRlciA9IG5ldyAkUmVhZGVyKHJlYWRlcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVmVyaWZpZXMgYSBNYXAgbWVzc2FnZS5cbiAgICAgICAgICAgICAqIEBmdW5jdGlvbiB2ZXJpZnlcbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90by5NYXBcbiAgICAgICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG1lc3NhZ2UgUGxhaW4gb2JqZWN0IHRvIHZlcmlmeVxuICAgICAgICAgICAgICogQHJldHVybnMge3N0cmluZ3xudWxsfSBgbnVsbGAgaWYgdmFsaWQsIG90aGVyd2lzZSB0aGUgcmVhc29uIHdoeSBpdCBpcyBub3RcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgTWFwLnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlICE9PSBcIm9iamVjdFwiIHx8IG1lc3NhZ2UgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIm9iamVjdCBleHBlY3RlZFwiO1xuICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLmtleVR5cGUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwia2V5VHlwZVwiKSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEkdXRpbC5pc0ludGVnZXIobWVzc2FnZS5rZXlUeXBlKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcImtleVR5cGU6IGludGVnZXIgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZS52YWx1ZVR5cGUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwidmFsdWVUeXBlXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlcnJvciA9ICRyb290Lm9ubnguVHlwZVByb3RvLnZlcmlmeShtZXNzYWdlLnZhbHVlVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcInZhbHVlVHlwZS5cIiArIGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ3JlYXRlcyBhIE1hcCBtZXNzYWdlIGZyb20gYSBwbGFpbiBvYmplY3QuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIHRoZWlyIHJlc3BlY3RpdmUgaW50ZXJuYWwgdHlwZXMuXG4gICAgICAgICAgICAgKiBAZnVuY3Rpb24gZnJvbU9iamVjdFxuICAgICAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvLk1hcFxuICAgICAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gb2JqZWN0IFBsYWluIG9iamVjdFxuICAgICAgICAgICAgICogQHJldHVybnMge29ubnguVHlwZVByb3RvLk1hcH0gTWFwXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIE1hcC5mcm9tT2JqZWN0ID0gZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgICAgICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgJHJvb3Qub25ueC5UeXBlUHJvdG8uTWFwKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlID0gbmV3ICRyb290Lm9ubnguVHlwZVByb3RvLk1hcCgpO1xuICAgICAgICAgICAgICAgIGlmIChvYmplY3Qua2V5VHlwZSAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmtleVR5cGUgPSBvYmplY3Qua2V5VHlwZSB8IDA7XG4gICAgICAgICAgICAgICAgaWYgKG9iamVjdC52YWx1ZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC52YWx1ZVR5cGUgIT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5UeXBlUHJvdG8uTWFwLnZhbHVlVHlwZTogb2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnZhbHVlVHlwZSA9ICRyb290Lm9ubnguVHlwZVByb3RvLmZyb21PYmplY3Qob2JqZWN0LnZhbHVlVHlwZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDcmVhdGVzIGEgcGxhaW4gb2JqZWN0IGZyb20gYSBNYXAgbWVzc2FnZS4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gb3RoZXIgdHlwZXMgaWYgc3BlY2lmaWVkLlxuICAgICAgICAgICAgICogQGZ1bmN0aW9uIHRvT2JqZWN0XG4gICAgICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG8uTWFwXG4gICAgICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAgICAgKiBAcGFyYW0ge29ubnguVHlwZVByb3RvLk1hcH0gbWVzc2FnZSBNYXBcbiAgICAgICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLklDb252ZXJzaW9uT3B0aW9uc30gW29wdGlvbnNdIENvbnZlcnNpb24gb3B0aW9uc1xuICAgICAgICAgICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBQbGFpbiBvYmplY3RcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgTWFwLnRvT2JqZWN0ID0gZnVuY3Rpb24gdG9PYmplY3QobWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgICAgIGlmICghb3B0aW9ucylcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgICAgICAgIHZhciBvYmplY3QgPSB7fTtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5kZWZhdWx0cykge1xuICAgICAgICAgICAgICAgICAgICBvYmplY3Qua2V5VHlwZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC52YWx1ZVR5cGUgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZS5rZXlUeXBlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImtleVR5cGVcIikpXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5rZXlUeXBlID0gbWVzc2FnZS5rZXlUeXBlO1xuICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLnZhbHVlVHlwZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJ2YWx1ZVR5cGVcIikpXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC52YWx1ZVR5cGUgPSAkcm9vdC5vbm54LlR5cGVQcm90by50b09iamVjdChtZXNzYWdlLnZhbHVlVHlwZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ29udmVydHMgdGhpcyBNYXAgdG8gSlNPTi5cbiAgICAgICAgICAgICAqIEBmdW5jdGlvbiB0b0pTT05cbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90by5NYXBcbiAgICAgICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBKU09OIG9iamVjdFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBNYXAucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLCAkcHJvdG9idWYudXRpbC50b0pTT05PcHRpb25zKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogR2V0cyB0aGUgZGVmYXVsdCB0eXBlIHVybCBmb3IgTWFwXG4gICAgICAgICAgICAgKiBAZnVuY3Rpb24gZ2V0VHlwZVVybFxuICAgICAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvLk1hcFxuICAgICAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFt0eXBlVXJsUHJlZml4XSB5b3VyIGN1c3RvbSB0eXBlVXJsUHJlZml4KGRlZmF1bHQgXCJ0eXBlLmdvb2dsZWFwaXMuY29tXCIpXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgZGVmYXVsdCB0eXBlIHVybFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBNYXAuZ2V0VHlwZVVybCA9IGZ1bmN0aW9uIGdldFR5cGVVcmwodHlwZVVybFByZWZpeCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlVXJsUHJlZml4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZVVybFByZWZpeCA9IFwidHlwZS5nb29nbGVhcGlzLmNvbVwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZVVybFByZWZpeCArIFwiL29ubnguVHlwZVByb3RvLk1hcFwiO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmV0dXJuIE1hcDtcbiAgICAgICAgfSkoKTtcblxuICAgICAgICBUeXBlUHJvdG8uT3B0aW9uYWwgPSAoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUHJvcGVydGllcyBvZiBhbiBPcHRpb25hbC5cbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90b1xuICAgICAgICAgICAgICogQGludGVyZmFjZSBJT3B0aW9uYWxcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7b25ueC5JVHlwZVByb3RvfG51bGx9IFtlbGVtVHlwZV0gT3B0aW9uYWwgZWxlbVR5cGVcbiAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIENvbnN0cnVjdHMgYSBuZXcgT3B0aW9uYWwuXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG9cbiAgICAgICAgICAgICAqIEBjbGFzc2Rlc2MgUmVwcmVzZW50cyBhbiBPcHRpb25hbC5cbiAgICAgICAgICAgICAqIEBpbXBsZW1lbnRzIElPcHRpb25hbFxuICAgICAgICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgICAgICAgKiBAcGFyYW0ge29ubnguVHlwZVByb3RvLklPcHRpb25hbD19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiBPcHRpb25hbChwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMpXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKSwgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXNba2V5c1tpXV0gIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2tleXNbaV1dID0gcHJvcGVydGllc1trZXlzW2ldXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBPcHRpb25hbCBlbGVtVHlwZS5cbiAgICAgICAgICAgICAqIEBtZW1iZXIge29ubnguSVR5cGVQcm90b3xudWxsfHVuZGVmaW5lZH0gZWxlbVR5cGVcbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90by5PcHRpb25hbFxuICAgICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIE9wdGlvbmFsLnByb3RvdHlwZS5lbGVtVHlwZSA9IG51bGw7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ3JlYXRlcyBhIG5ldyBPcHRpb25hbCBpbnN0YW5jZSB1c2luZyB0aGUgc3BlY2lmaWVkIHByb3BlcnRpZXMuXG4gICAgICAgICAgICAgKiBAZnVuY3Rpb24gY3JlYXRlXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG8uT3B0aW9uYWxcbiAgICAgICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICAgICAqIEBwYXJhbSB7b25ueC5UeXBlUHJvdG8uSU9wdGlvbmFsPX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7b25ueC5UeXBlUHJvdG8uT3B0aW9uYWx9IE9wdGlvbmFsIGluc3RhbmNlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIE9wdGlvbmFsLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBPcHRpb25hbChwcm9wZXJ0aWVzKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRW5jb2RlcyB0aGUgc3BlY2lmaWVkIE9wdGlvbmFsIG1lc3NhZ2UuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIG9ubnguVHlwZVByb3RvLk9wdGlvbmFsLnZlcmlmeXx2ZXJpZnl9IG1lc3NhZ2VzLlxuICAgICAgICAgICAgICogQGZ1bmN0aW9uIGVuY29kZVxuICAgICAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvLk9wdGlvbmFsXG4gICAgICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAgICAgKiBAcGFyYW0ge29ubnguVHlwZVByb3RvLklPcHRpb25hbH0gbWVzc2FnZSBPcHRpb25hbCBtZXNzYWdlIG9yIHBsYWluIG9iamVjdCB0byBlbmNvZGVcbiAgICAgICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLldyaXRlcn0gW3dyaXRlcl0gV3JpdGVyIHRvIGVuY29kZSB0b1xuICAgICAgICAgICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBPcHRpb25hbC5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF3cml0ZXIpXG4gICAgICAgICAgICAgICAgICAgIHdyaXRlciA9ICRXcml0ZXIuY3JlYXRlKCk7XG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZWxlbVR5cGUgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcImVsZW1UeXBlXCIpKVxuICAgICAgICAgICAgICAgICAgICAkcm9vdC5vbm54LlR5cGVQcm90by5lbmNvZGUobWVzc2FnZS5lbGVtVHlwZSwgd3JpdGVyLnVpbnQzMigvKiBpZCAxLCB3aXJlVHlwZSAyID0qLzEwKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBPcHRpb25hbCBtZXNzYWdlLCBsZW5ndGggZGVsaW1pdGVkLiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayBvbm54LlR5cGVQcm90by5PcHRpb25hbC52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cbiAgICAgICAgICAgICAqIEBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWRcbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90by5PcHRpb25hbFxuICAgICAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgICAgICogQHBhcmFtIHtvbm54LlR5cGVQcm90by5JT3B0aW9uYWx9IG1lc3NhZ2UgT3B0aW9uYWwgbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXG4gICAgICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAgICAgICAgICAgICAqIEByZXR1cm5zIHskcHJvdG9idWYuV3JpdGVyfSBXcml0ZXJcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgT3B0aW9uYWwuZW5jb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVuY29kZShtZXNzYWdlLCB3cml0ZXIpLmxkZWxpbSgpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBEZWNvZGVzIGFuIE9wdGlvbmFsIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIuXG4gICAgICAgICAgICAgKiBAZnVuY3Rpb24gZGVjb2RlXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG8uT3B0aW9uYWxcbiAgICAgICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLlJlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGUgZnJvbVxuICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGhdIE1lc3NhZ2UgbGVuZ3RoIGlmIGtub3duIGJlZm9yZWhhbmRcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtvbm54LlR5cGVQcm90by5PcHRpb25hbH0gT3B0aW9uYWxcbiAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICAgICAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgT3B0aW9uYWwuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHJlYWRlciwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgICAgICAgIHJlYWRlciA9ICRSZWFkZXIuY3JlYXRlKHJlYWRlcik7XG4gICAgICAgICAgICAgICAgdmFyIGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGgsIG1lc3NhZ2UgPSBuZXcgJHJvb3Qub25ueC5UeXBlUHJvdG8uT3B0aW9uYWwoKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmVsZW1UeXBlID0gJHJvb3Qub25ueC5UeXBlUHJvdG8uZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBEZWNvZGVzIGFuIE9wdGlvbmFsIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIsIGxlbmd0aCBkZWxpbWl0ZWQuXG4gICAgICAgICAgICAgKiBAZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG8uT3B0aW9uYWxcbiAgICAgICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLlJlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGUgZnJvbVxuICAgICAgICAgICAgICogQHJldHVybnMge29ubnguVHlwZVByb3RvLk9wdGlvbmFsfSBPcHRpb25hbFxuICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcbiAgICAgICAgICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBPcHRpb25hbC5kZWNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWQocmVhZGVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgICAgICAgIHJlYWRlciA9IG5ldyAkUmVhZGVyKHJlYWRlcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVmVyaWZpZXMgYW4gT3B0aW9uYWwgbWVzc2FnZS5cbiAgICAgICAgICAgICAqIEBmdW5jdGlvbiB2ZXJpZnlcbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90by5PcHRpb25hbFxuICAgICAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gbWVzc2FnZSBQbGFpbiBvYmplY3QgdG8gdmVyaWZ5XG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9IGBudWxsYCBpZiB2YWxpZCwgb3RoZXJ3aXNlIHRoZSByZWFzb24gd2h5IGl0IGlzIG5vdFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBPcHRpb25hbC52ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnkobWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSAhPT0gXCJvYmplY3RcIiB8fCBtZXNzYWdlID09PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJvYmplY3QgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZS5lbGVtVHlwZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJlbGVtVHlwZVwiKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXJyb3IgPSAkcm9vdC5vbm54LlR5cGVQcm90by52ZXJpZnkobWVzc2FnZS5lbGVtVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcImVsZW1UeXBlLlwiICsgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDcmVhdGVzIGFuIE9wdGlvbmFsIG1lc3NhZ2UgZnJvbSBhIHBsYWluIG9iamVjdC4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gdGhlaXIgcmVzcGVjdGl2ZSBpbnRlcm5hbCB0eXBlcy5cbiAgICAgICAgICAgICAqIEBmdW5jdGlvbiBmcm9tT2JqZWN0XG4gICAgICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG8uT3B0aW9uYWxcbiAgICAgICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG9iamVjdCBQbGFpbiBvYmplY3RcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtvbm54LlR5cGVQcm90by5PcHRpb25hbH0gT3B0aW9uYWxcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgT3B0aW9uYWwuZnJvbU9iamVjdCA9IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mICRyb290Lm9ubnguVHlwZVByb3RvLk9wdGlvbmFsKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlID0gbmV3ICRyb290Lm9ubnguVHlwZVByb3RvLk9wdGlvbmFsKCk7XG4gICAgICAgICAgICAgICAgaWYgKG9iamVjdC5lbGVtVHlwZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LmVsZW1UeXBlICE9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguVHlwZVByb3RvLk9wdGlvbmFsLmVsZW1UeXBlOiBvYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZWxlbVR5cGUgPSAkcm9vdC5vbm54LlR5cGVQcm90by5mcm9tT2JqZWN0KG9iamVjdC5lbGVtVHlwZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDcmVhdGVzIGEgcGxhaW4gb2JqZWN0IGZyb20gYW4gT3B0aW9uYWwgbWVzc2FnZS4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gb3RoZXIgdHlwZXMgaWYgc3BlY2lmaWVkLlxuICAgICAgICAgICAgICogQGZ1bmN0aW9uIHRvT2JqZWN0XG4gICAgICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG8uT3B0aW9uYWxcbiAgICAgICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICAgICAqIEBwYXJhbSB7b25ueC5UeXBlUHJvdG8uT3B0aW9uYWx9IG1lc3NhZ2UgT3B0aW9uYWxcbiAgICAgICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLklDb252ZXJzaW9uT3B0aW9uc30gW29wdGlvbnNdIENvbnZlcnNpb24gb3B0aW9uc1xuICAgICAgICAgICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBQbGFpbiBvYmplY3RcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgT3B0aW9uYWwudG9PYmplY3QgPSBmdW5jdGlvbiB0b09iamVjdChtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFvcHRpb25zKVxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgICAgICAgICAgdmFyIG9iamVjdCA9IHt9O1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmRlZmF1bHRzKVxuICAgICAgICAgICAgICAgICAgICBvYmplY3QuZWxlbVR5cGUgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLmVsZW1UeXBlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImVsZW1UeXBlXCIpKVxuICAgICAgICAgICAgICAgICAgICBvYmplY3QuZWxlbVR5cGUgPSAkcm9vdC5vbm54LlR5cGVQcm90by50b09iamVjdChtZXNzYWdlLmVsZW1UeXBlLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDb252ZXJ0cyB0aGlzIE9wdGlvbmFsIHRvIEpTT04uXG4gICAgICAgICAgICAgKiBAZnVuY3Rpb24gdG9KU09OXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG8uT3B0aW9uYWxcbiAgICAgICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBKU09OIG9iamVjdFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBPcHRpb25hbC5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsICRwcm90b2J1Zi51dGlsLnRvSlNPTk9wdGlvbnMpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZXRzIHRoZSBkZWZhdWx0IHR5cGUgdXJsIGZvciBPcHRpb25hbFxuICAgICAgICAgICAgICogQGZ1bmN0aW9uIGdldFR5cGVVcmxcbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90by5PcHRpb25hbFxuICAgICAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFt0eXBlVXJsUHJlZml4XSB5b3VyIGN1c3RvbSB0eXBlVXJsUHJlZml4KGRlZmF1bHQgXCJ0eXBlLmdvb2dsZWFwaXMuY29tXCIpXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgZGVmYXVsdCB0eXBlIHVybFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBPcHRpb25hbC5nZXRUeXBlVXJsID0gZnVuY3Rpb24gZ2V0VHlwZVVybCh0eXBlVXJsUHJlZml4KSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVVcmxQcmVmaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0eXBlVXJsUHJlZml4ID0gXCJ0eXBlLmdvb2dsZWFwaXMuY29tXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlVXJsUHJlZml4ICsgXCIvb25ueC5UeXBlUHJvdG8uT3B0aW9uYWxcIjtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJldHVybiBPcHRpb25hbDtcbiAgICAgICAgfSkoKTtcblxuICAgICAgICBUeXBlUHJvdG8uU3BhcnNlVGVuc29yID0gKGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFByb3BlcnRpZXMgb2YgYSBTcGFyc2VUZW5zb3IuXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG9cbiAgICAgICAgICAgICAqIEBpbnRlcmZhY2UgSVNwYXJzZVRlbnNvclxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ8bnVsbH0gW2VsZW1UeXBlXSBTcGFyc2VUZW5zb3IgZWxlbVR5cGVcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7b25ueC5JVGVuc29yU2hhcGVQcm90b3xudWxsfSBbc2hhcGVdIFNwYXJzZVRlbnNvciBzaGFwZVxuICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ29uc3RydWN0cyBhIG5ldyBTcGFyc2VUZW5zb3IuXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG9cbiAgICAgICAgICAgICAqIEBjbGFzc2Rlc2MgUmVwcmVzZW50cyBhIFNwYXJzZVRlbnNvci5cbiAgICAgICAgICAgICAqIEBpbXBsZW1lbnRzIElTcGFyc2VUZW5zb3JcbiAgICAgICAgICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAgICAgICAgICogQHBhcmFtIHtvbm54LlR5cGVQcm90by5JU3BhcnNlVGVuc29yPX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIFNwYXJzZVRlbnNvcihwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMpXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKSwgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXNba2V5c1tpXV0gIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2tleXNbaV1dID0gcHJvcGVydGllc1trZXlzW2ldXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBTcGFyc2VUZW5zb3IgZWxlbVR5cGUuXG4gICAgICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9IGVsZW1UeXBlXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG8uU3BhcnNlVGVuc29yXG4gICAgICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgU3BhcnNlVGVuc29yLnByb3RvdHlwZS5lbGVtVHlwZSA9IDA7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogU3BhcnNlVGVuc29yIHNoYXBlLlxuICAgICAgICAgICAgICogQG1lbWJlciB7b25ueC5JVGVuc29yU2hhcGVQcm90b3xudWxsfHVuZGVmaW5lZH0gc2hhcGVcbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90by5TcGFyc2VUZW5zb3JcbiAgICAgICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBTcGFyc2VUZW5zb3IucHJvdG90eXBlLnNoYXBlID0gbnVsbDtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDcmVhdGVzIGEgbmV3IFNwYXJzZVRlbnNvciBpbnN0YW5jZSB1c2luZyB0aGUgc3BlY2lmaWVkIHByb3BlcnRpZXMuXG4gICAgICAgICAgICAgKiBAZnVuY3Rpb24gY3JlYXRlXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG8uU3BhcnNlVGVuc29yXG4gICAgICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAgICAgKiBAcGFyYW0ge29ubnguVHlwZVByb3RvLklTcGFyc2VUZW5zb3I9fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtvbm54LlR5cGVQcm90by5TcGFyc2VUZW5zb3J9IFNwYXJzZVRlbnNvciBpbnN0YW5jZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBTcGFyc2VUZW5zb3IuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFNwYXJzZVRlbnNvcihwcm9wZXJ0aWVzKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRW5jb2RlcyB0aGUgc3BlY2lmaWVkIFNwYXJzZVRlbnNvciBtZXNzYWdlLiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayBvbm54LlR5cGVQcm90by5TcGFyc2VUZW5zb3IudmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXG4gICAgICAgICAgICAgKiBAZnVuY3Rpb24gZW5jb2RlXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG8uU3BhcnNlVGVuc29yXG4gICAgICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAgICAgKiBAcGFyYW0ge29ubnguVHlwZVByb3RvLklTcGFyc2VUZW5zb3J9IG1lc3NhZ2UgU3BhcnNlVGVuc29yIG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0IHRvIGVuY29kZVxuICAgICAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuV3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gZW5jb2RlIHRvXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFNwYXJzZVRlbnNvci5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF3cml0ZXIpXG4gICAgICAgICAgICAgICAgICAgIHdyaXRlciA9ICRXcml0ZXIuY3JlYXRlKCk7XG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZWxlbVR5cGUgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcImVsZW1UeXBlXCIpKVxuICAgICAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDEsIHdpcmVUeXBlIDAgPSovOCkuaW50MzIobWVzc2FnZS5lbGVtVHlwZSk7XG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2Uuc2hhcGUgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcInNoYXBlXCIpKVxuICAgICAgICAgICAgICAgICAgICAkcm9vdC5vbm54LlRlbnNvclNoYXBlUHJvdG8uZW5jb2RlKG1lc3NhZ2Uuc2hhcGUsIHdyaXRlci51aW50MzIoLyogaWQgMiwgd2lyZVR5cGUgMiA9Ki8xOCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgU3BhcnNlVGVuc29yIG1lc3NhZ2UsIGxlbmd0aCBkZWxpbWl0ZWQuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIG9ubnguVHlwZVByb3RvLlNwYXJzZVRlbnNvci52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cbiAgICAgICAgICAgICAqIEBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWRcbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90by5TcGFyc2VUZW5zb3JcbiAgICAgICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICAgICAqIEBwYXJhbSB7b25ueC5UeXBlUHJvdG8uSVNwYXJzZVRlbnNvcn0gbWVzc2FnZSBTcGFyc2VUZW5zb3IgbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXG4gICAgICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAgICAgICAgICAgICAqIEByZXR1cm5zIHskcHJvdG9idWYuV3JpdGVyfSBXcml0ZXJcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgU3BhcnNlVGVuc29yLmVuY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZChtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGUobWVzc2FnZSwgd3JpdGVyKS5sZGVsaW0oKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRGVjb2RlcyBhIFNwYXJzZVRlbnNvciBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLlxuICAgICAgICAgICAgICogQGZ1bmN0aW9uIGRlY29kZVxuICAgICAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvLlNwYXJzZVRlbnNvclxuICAgICAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aF0gTWVzc2FnZSBsZW5ndGggaWYga25vd24gYmVmb3JlaGFuZFxuICAgICAgICAgICAgICogQHJldHVybnMge29ubnguVHlwZVByb3RvLlNwYXJzZVRlbnNvcn0gU3BhcnNlVGVuc29yXG4gICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAgICAgICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFNwYXJzZVRlbnNvci5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUocmVhZGVyLCBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyID0gJFJlYWRlci5jcmVhdGUocmVhZGVyKTtcbiAgICAgICAgICAgICAgICB2YXIgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aCwgbWVzc2FnZSA9IG5ldyAkcm9vdC5vbm54LlR5cGVQcm90by5TcGFyc2VUZW5zb3IoKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmVsZW1UeXBlID0gcmVhZGVyLmludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc2hhcGUgPSAkcm9vdC5vbm54LlRlbnNvclNoYXBlUHJvdG8uZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBEZWNvZGVzIGEgU3BhcnNlVGVuc29yIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIsIGxlbmd0aCBkZWxpbWl0ZWQuXG4gICAgICAgICAgICAgKiBAZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG8uU3BhcnNlVGVuc29yXG4gICAgICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtvbm54LlR5cGVQcm90by5TcGFyc2VUZW5zb3J9IFNwYXJzZVRlbnNvclxuICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcbiAgICAgICAgICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBTcGFyc2VUZW5zb3IuZGVjb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkKHJlYWRlcikge1xuICAgICAgICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgICAgICAgICByZWFkZXIgPSBuZXcgJFJlYWRlcihyZWFkZXIpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFZlcmlmaWVzIGEgU3BhcnNlVGVuc29yIG1lc3NhZ2UuXG4gICAgICAgICAgICAgKiBAZnVuY3Rpb24gdmVyaWZ5XG4gICAgICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG8uU3BhcnNlVGVuc29yXG4gICAgICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBtZXNzYWdlIFBsYWluIG9iamVjdCB0byB2ZXJpZnlcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd8bnVsbH0gYG51bGxgIGlmIHZhbGlkLCBvdGhlcndpc2UgdGhlIHJlYXNvbiB3aHkgaXQgaXMgbm90XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFNwYXJzZVRlbnNvci52ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnkobWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSAhPT0gXCJvYmplY3RcIiB8fCBtZXNzYWdlID09PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJvYmplY3QgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZS5lbGVtVHlwZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJlbGVtVHlwZVwiKSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEkdXRpbC5pc0ludGVnZXIobWVzc2FnZS5lbGVtVHlwZSkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJlbGVtVHlwZTogaW50ZWdlciBleHBlY3RlZFwiO1xuICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLnNoYXBlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInNoYXBlXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlcnJvciA9ICRyb290Lm9ubnguVGVuc29yU2hhcGVQcm90by52ZXJpZnkobWVzc2FnZS5zaGFwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcInNoYXBlLlwiICsgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDcmVhdGVzIGEgU3BhcnNlVGVuc29yIG1lc3NhZ2UgZnJvbSBhIHBsYWluIG9iamVjdC4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gdGhlaXIgcmVzcGVjdGl2ZSBpbnRlcm5hbCB0eXBlcy5cbiAgICAgICAgICAgICAqIEBmdW5jdGlvbiBmcm9tT2JqZWN0XG4gICAgICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG8uU3BhcnNlVGVuc29yXG4gICAgICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBvYmplY3QgUGxhaW4gb2JqZWN0XG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7b25ueC5UeXBlUHJvdG8uU3BhcnNlVGVuc29yfSBTcGFyc2VUZW5zb3JcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgU3BhcnNlVGVuc29yLmZyb21PYmplY3QgPSBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgICAgICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiAkcm9vdC5vbm54LlR5cGVQcm90by5TcGFyc2VUZW5zb3IpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBuZXcgJHJvb3Qub25ueC5UeXBlUHJvdG8uU3BhcnNlVGVuc29yKCk7XG4gICAgICAgICAgICAgICAgaWYgKG9iamVjdC5lbGVtVHlwZSAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmVsZW1UeXBlID0gb2JqZWN0LmVsZW1UeXBlIHwgMDtcbiAgICAgICAgICAgICAgICBpZiAob2JqZWN0LnNoYXBlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3Quc2hhcGUgIT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5UeXBlUHJvdG8uU3BhcnNlVGVuc29yLnNoYXBlOiBvYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc2hhcGUgPSAkcm9vdC5vbm54LlRlbnNvclNoYXBlUHJvdG8uZnJvbU9iamVjdChvYmplY3Quc2hhcGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ3JlYXRlcyBhIHBsYWluIG9iamVjdCBmcm9tIGEgU3BhcnNlVGVuc29yIG1lc3NhZ2UuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIG90aGVyIHR5cGVzIGlmIHNwZWNpZmllZC5cbiAgICAgICAgICAgICAqIEBmdW5jdGlvbiB0b09iamVjdFxuICAgICAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvLlNwYXJzZVRlbnNvclxuICAgICAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgICAgICogQHBhcmFtIHtvbm54LlR5cGVQcm90by5TcGFyc2VUZW5zb3J9IG1lc3NhZ2UgU3BhcnNlVGVuc29yXG4gICAgICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5JQ29udmVyc2lvbk9wdGlvbnN9IFtvcHRpb25zXSBDb252ZXJzaW9uIG9wdGlvbnNcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gUGxhaW4gb2JqZWN0XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFNwYXJzZVRlbnNvci50b09iamVjdCA9IGZ1bmN0aW9uIHRvT2JqZWN0KG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIW9wdGlvbnMpXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgICAgICAgICB2YXIgb2JqZWN0ID0ge307XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGVmYXVsdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LmVsZW1UeXBlID0gMDtcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LnNoYXBlID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZWxlbVR5cGUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZWxlbVR5cGVcIikpXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5lbGVtVHlwZSA9IG1lc3NhZ2UuZWxlbVR5cGU7XG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2Uuc2hhcGUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwic2hhcGVcIikpXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5zaGFwZSA9ICRyb290Lm9ubnguVGVuc29yU2hhcGVQcm90by50b09iamVjdChtZXNzYWdlLnNoYXBlLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDb252ZXJ0cyB0aGlzIFNwYXJzZVRlbnNvciB0byBKU09OLlxuICAgICAgICAgICAgICogQGZ1bmN0aW9uIHRvSlNPTlxuICAgICAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvLlNwYXJzZVRlbnNvclxuICAgICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IEpTT04gb2JqZWN0XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFNwYXJzZVRlbnNvci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsICRwcm90b2J1Zi51dGlsLnRvSlNPTk9wdGlvbnMpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZXRzIHRoZSBkZWZhdWx0IHR5cGUgdXJsIGZvciBTcGFyc2VUZW5zb3JcbiAgICAgICAgICAgICAqIEBmdW5jdGlvbiBnZXRUeXBlVXJsXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG8uU3BhcnNlVGVuc29yXG4gICAgICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3R5cGVVcmxQcmVmaXhdIHlvdXIgY3VzdG9tIHR5cGVVcmxQcmVmaXgoZGVmYXVsdCBcInR5cGUuZ29vZ2xlYXBpcy5jb21cIilcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBkZWZhdWx0IHR5cGUgdXJsXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFNwYXJzZVRlbnNvci5nZXRUeXBlVXJsID0gZnVuY3Rpb24gZ2V0VHlwZVVybCh0eXBlVXJsUHJlZml4KSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVVcmxQcmVmaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0eXBlVXJsUHJlZml4ID0gXCJ0eXBlLmdvb2dsZWFwaXMuY29tXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlVXJsUHJlZml4ICsgXCIvb25ueC5UeXBlUHJvdG8uU3BhcnNlVGVuc29yXCI7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXR1cm4gU3BhcnNlVGVuc29yO1xuICAgICAgICB9KSgpO1xuXG4gICAgICAgIHJldHVybiBUeXBlUHJvdG87XG4gICAgfSkoKTtcblxuICAgIG9ubnguT3BlcmF0b3JTZXRJZFByb3RvID0gKGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm9wZXJ0aWVzIG9mIGFuIE9wZXJhdG9yU2V0SWRQcm90by5cbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnhcbiAgICAgICAgICogQGludGVyZmFjZSBJT3BlcmF0b3JTZXRJZFByb3RvXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfG51bGx9IFtkb21haW5dIE9wZXJhdG9yU2V0SWRQcm90byBkb21haW5cbiAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ8TG9uZ3xudWxsfSBbdmVyc2lvbl0gT3BlcmF0b3JTZXRJZFByb3RvIHZlcnNpb25cbiAgICAgICAgICovXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnN0cnVjdHMgYSBuZXcgT3BlcmF0b3JTZXRJZFByb3RvLlxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueFxuICAgICAgICAgKiBAY2xhc3NkZXNjIFJlcHJlc2VudHMgYW4gT3BlcmF0b3JTZXRJZFByb3RvLlxuICAgICAgICAgKiBAaW1wbGVtZW50cyBJT3BlcmF0b3JTZXRJZFByb3RvXG4gICAgICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAgICAgKiBAcGFyYW0ge29ubnguSU9wZXJhdG9yU2V0SWRQcm90bz19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gT3BlcmF0b3JTZXRJZFByb3RvKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzKVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKSwgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllc1trZXlzW2ldXSAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1trZXlzW2ldXSA9IHByb3BlcnRpZXNba2V5c1tpXV07XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogT3BlcmF0b3JTZXRJZFByb3RvIGRvbWFpbi5cbiAgICAgICAgICogQG1lbWJlciB7c3RyaW5nfSBkb21haW5cbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguT3BlcmF0b3JTZXRJZFByb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgT3BlcmF0b3JTZXRJZFByb3RvLnByb3RvdHlwZS5kb21haW4gPSBcIlwiO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPcGVyYXRvclNldElkUHJvdG8gdmVyc2lvbi5cbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfExvbmd9IHZlcnNpb25cbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguT3BlcmF0b3JTZXRJZFByb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgT3BlcmF0b3JTZXRJZFByb3RvLnByb3RvdHlwZS52ZXJzaW9uID0gJHV0aWwuTG9uZyA/ICR1dGlsLkxvbmcuZnJvbUJpdHMoMCwwLGZhbHNlKSA6IDA7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBuZXcgT3BlcmF0b3JTZXRJZFByb3RvIGluc3RhbmNlIHVzaW5nIHRoZSBzcGVjaWZpZWQgcHJvcGVydGllcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGNyZWF0ZVxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5PcGVyYXRvclNldElkUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge29ubnguSU9wZXJhdG9yU2V0SWRQcm90bz19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxuICAgICAgICAgKiBAcmV0dXJucyB7b25ueC5PcGVyYXRvclNldElkUHJvdG99IE9wZXJhdG9yU2V0SWRQcm90byBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgT3BlcmF0b3JTZXRJZFByb3RvLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE9wZXJhdG9yU2V0SWRQcm90byhwcm9wZXJ0aWVzKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRW5jb2RlcyB0aGUgc3BlY2lmaWVkIE9wZXJhdG9yU2V0SWRQcm90byBtZXNzYWdlLiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayBvbm54Lk9wZXJhdG9yU2V0SWRQcm90by52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGVuY29kZVxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5PcGVyYXRvclNldElkUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge29ubnguSU9wZXJhdG9yU2V0SWRQcm90b30gbWVzc2FnZSBPcGVyYXRvclNldElkUHJvdG8gbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLldyaXRlcn0gW3dyaXRlcl0gV3JpdGVyIHRvIGVuY29kZSB0b1xuICAgICAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXG4gICAgICAgICAqL1xuICAgICAgICBPcGVyYXRvclNldElkUHJvdG8uZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgICAgaWYgKCF3cml0ZXIpXG4gICAgICAgICAgICAgICAgd3JpdGVyID0gJFdyaXRlci5jcmVhdGUoKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmRvbWFpbiAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwiZG9tYWluXCIpKVxuICAgICAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMSwgd2lyZVR5cGUgMiA9Ki8xMCkuc3RyaW5nKG1lc3NhZ2UuZG9tYWluKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnZlcnNpb24gIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcInZlcnNpb25cIikpXG4gICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCAyLCB3aXJlVHlwZSAwID0qLzE2KS5pbnQ2NChtZXNzYWdlLnZlcnNpb24pO1xuICAgICAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRW5jb2RlcyB0aGUgc3BlY2lmaWVkIE9wZXJhdG9yU2V0SWRQcm90byBtZXNzYWdlLCBsZW5ndGggZGVsaW1pdGVkLiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayBvbm54Lk9wZXJhdG9yU2V0SWRQcm90by52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZFxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5PcGVyYXRvclNldElkUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge29ubnguSU9wZXJhdG9yU2V0SWRQcm90b30gbWVzc2FnZSBPcGVyYXRvclNldElkUHJvdG8gbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLldyaXRlcn0gW3dyaXRlcl0gV3JpdGVyIHRvIGVuY29kZSB0b1xuICAgICAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXG4gICAgICAgICAqL1xuICAgICAgICBPcGVyYXRvclNldElkUHJvdG8uZW5jb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikubGRlbGltKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlY29kZXMgYW4gT3BlcmF0b3JTZXRJZFByb3RvIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIuXG4gICAgICAgICAqIEBmdW5jdGlvbiBkZWNvZGVcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguT3BlcmF0b3JTZXRJZFByb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoXSBNZXNzYWdlIGxlbmd0aCBpZiBrbm93biBiZWZvcmVoYW5kXG4gICAgICAgICAqIEByZXR1cm5zIHtvbm54Lk9wZXJhdG9yU2V0SWRQcm90b30gT3BlcmF0b3JTZXRJZFByb3RvXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAgICAgKi9cbiAgICAgICAgT3BlcmF0b3JTZXRJZFByb3RvLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyZWFkZXIsIGxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgICAgcmVhZGVyID0gJFJlYWRlci5jcmVhdGUocmVhZGVyKTtcbiAgICAgICAgICAgIHZhciBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoLCBtZXNzYWdlID0gbmV3ICRyb290Lm9ubnguT3BlcmF0b3JTZXRJZFByb3RvKCk7XG4gICAgICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgICAgIHZhciB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZG9tYWluID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIDI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudmVyc2lvbiA9IHJlYWRlci5pbnQ2NCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWNvZGVzIGFuIE9wZXJhdG9yU2V0SWRQcm90byBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLCBsZW5ndGggZGVsaW1pdGVkLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54Lk9wZXJhdG9yU2V0SWRQcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLlJlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGUgZnJvbVxuICAgICAgICAgKiBAcmV0dXJucyB7b25ueC5PcGVyYXRvclNldElkUHJvdG99IE9wZXJhdG9yU2V0SWRQcm90b1xuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcbiAgICAgICAgICovXG4gICAgICAgIE9wZXJhdG9yU2V0SWRQcm90by5kZWNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWQocmVhZGVyKSB7XG4gICAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgICByZWFkZXIgPSBuZXcgJFJlYWRlcihyZWFkZXIpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVmVyaWZpZXMgYW4gT3BlcmF0b3JTZXRJZFByb3RvIG1lc3NhZ2UuXG4gICAgICAgICAqIEBmdW5jdGlvbiB2ZXJpZnlcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguT3BlcmF0b3JTZXRJZFByb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gbWVzc2FnZSBQbGFpbiBvYmplY3QgdG8gdmVyaWZ5XG4gICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd8bnVsbH0gYG51bGxgIGlmIHZhbGlkLCBvdGhlcndpc2UgdGhlIHJlYXNvbiB3aHkgaXQgaXMgbm90XG4gICAgICAgICAqL1xuICAgICAgICBPcGVyYXRvclNldElkUHJvdG8udmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5KG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSAhPT0gXCJvYmplY3RcIiB8fCBtZXNzYWdlID09PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiBcIm9iamVjdCBleHBlY3RlZFwiO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZG9tYWluICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImRvbWFpblwiKSlcbiAgICAgICAgICAgICAgICBpZiAoISR1dGlsLmlzU3RyaW5nKG1lc3NhZ2UuZG9tYWluKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiZG9tYWluOiBzdHJpbmcgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnZlcnNpb24gIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwidmVyc2lvblwiKSlcbiAgICAgICAgICAgICAgICBpZiAoISR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLnZlcnNpb24pICYmICEobWVzc2FnZS52ZXJzaW9uICYmICR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLnZlcnNpb24ubG93KSAmJiAkdXRpbC5pc0ludGVnZXIobWVzc2FnZS52ZXJzaW9uLmhpZ2gpKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwidmVyc2lvbjogaW50ZWdlcnxMb25nIGV4cGVjdGVkXCI7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhbiBPcGVyYXRvclNldElkUHJvdG8gbWVzc2FnZSBmcm9tIGEgcGxhaW4gb2JqZWN0LiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byB0aGVpciByZXNwZWN0aXZlIGludGVybmFsIHR5cGVzLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZnJvbU9iamVjdFxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5PcGVyYXRvclNldElkUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBvYmplY3QgUGxhaW4gb2JqZWN0XG4gICAgICAgICAqIEByZXR1cm5zIHtvbm54Lk9wZXJhdG9yU2V0SWRQcm90b30gT3BlcmF0b3JTZXRJZFByb3RvXG4gICAgICAgICAqL1xuICAgICAgICBPcGVyYXRvclNldElkUHJvdG8uZnJvbU9iamVjdCA9IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgJHJvb3Qub25ueC5PcGVyYXRvclNldElkUHJvdG8pXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgICAgIHZhciBtZXNzYWdlID0gbmV3ICRyb290Lm9ubnguT3BlcmF0b3JTZXRJZFByb3RvKCk7XG4gICAgICAgICAgICBpZiAob2JqZWN0LmRvbWFpbiAhPSBudWxsKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UuZG9tYWluID0gU3RyaW5nKG9iamVjdC5kb21haW4pO1xuICAgICAgICAgICAgaWYgKG9iamVjdC52ZXJzaW9uICE9IG51bGwpXG4gICAgICAgICAgICAgICAgaWYgKCR1dGlsLkxvbmcpXG4gICAgICAgICAgICAgICAgICAgIChtZXNzYWdlLnZlcnNpb24gPSAkdXRpbC5Mb25nLmZyb21WYWx1ZShvYmplY3QudmVyc2lvbikpLnVuc2lnbmVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC52ZXJzaW9uID09PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnZlcnNpb24gPSBwYXJzZUludChvYmplY3QudmVyc2lvbiwgMTApO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QudmVyc2lvbiA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS52ZXJzaW9uID0gb2JqZWN0LnZlcnNpb247XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC52ZXJzaW9uID09PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnZlcnNpb24gPSBuZXcgJHV0aWwuTG9uZ0JpdHMob2JqZWN0LnZlcnNpb24ubG93ID4+PiAwLCBvYmplY3QudmVyc2lvbi5oaWdoID4+PiAwKS50b051bWJlcigpO1xuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBwbGFpbiBvYmplY3QgZnJvbSBhbiBPcGVyYXRvclNldElkUHJvdG8gbWVzc2FnZS4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gb3RoZXIgdHlwZXMgaWYgc3BlY2lmaWVkLlxuICAgICAgICAgKiBAZnVuY3Rpb24gdG9PYmplY3RcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguT3BlcmF0b3JTZXRJZFByb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtvbm54Lk9wZXJhdG9yU2V0SWRQcm90b30gbWVzc2FnZSBPcGVyYXRvclNldElkUHJvdG9cbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuSUNvbnZlcnNpb25PcHRpb25zfSBbb3B0aW9uc10gQ29udmVyc2lvbiBvcHRpb25zXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gUGxhaW4gb2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICBPcGVyYXRvclNldElkUHJvdG8udG9PYmplY3QgPSBmdW5jdGlvbiB0b09iamVjdChtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMpXG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgICAgdmFyIG9iamVjdCA9IHt9O1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGVmYXVsdHMpIHtcbiAgICAgICAgICAgICAgICBvYmplY3QuZG9tYWluID0gXCJcIjtcbiAgICAgICAgICAgICAgICBpZiAoJHV0aWwuTG9uZykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbG9uZyA9IG5ldyAkdXRpbC5Mb25nKDAsIDAsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LnZlcnNpb24gPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyBsb25nLnRvU3RyaW5nKCkgOiBvcHRpb25zLmxvbmdzID09PSBOdW1iZXIgPyBsb25nLnRvTnVtYmVyKCkgOiBsb25nO1xuICAgICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgICAgICBvYmplY3QudmVyc2lvbiA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/IFwiMFwiIDogMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmRvbWFpbiAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJkb21haW5cIikpXG4gICAgICAgICAgICAgICAgb2JqZWN0LmRvbWFpbiA9IG1lc3NhZ2UuZG9tYWluO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UudmVyc2lvbiAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJ2ZXJzaW9uXCIpKVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZS52ZXJzaW9uID09PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICAgICAgICBvYmplY3QudmVyc2lvbiA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/IFN0cmluZyhtZXNzYWdlLnZlcnNpb24pIDogbWVzc2FnZS52ZXJzaW9uO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LnZlcnNpb24gPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyAkdXRpbC5Mb25nLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG1lc3NhZ2UudmVyc2lvbikgOiBvcHRpb25zLmxvbmdzID09PSBOdW1iZXIgPyBuZXcgJHV0aWwuTG9uZ0JpdHMobWVzc2FnZS52ZXJzaW9uLmxvdyA+Pj4gMCwgbWVzc2FnZS52ZXJzaW9uLmhpZ2ggPj4+IDApLnRvTnVtYmVyKCkgOiBtZXNzYWdlLnZlcnNpb247XG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb252ZXJ0cyB0aGlzIE9wZXJhdG9yU2V0SWRQcm90byB0byBKU09OLlxuICAgICAgICAgKiBAZnVuY3Rpb24gdG9KU09OXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54Lk9wZXJhdG9yU2V0SWRQcm90b1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBKU09OIG9iamVjdFxuICAgICAgICAgKi9cbiAgICAgICAgT3BlcmF0b3JTZXRJZFByb3RvLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLCAkcHJvdG9idWYudXRpbC50b0pTT05PcHRpb25zKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0cyB0aGUgZGVmYXVsdCB0eXBlIHVybCBmb3IgT3BlcmF0b3JTZXRJZFByb3RvXG4gICAgICAgICAqIEBmdW5jdGlvbiBnZXRUeXBlVXJsXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54Lk9wZXJhdG9yU2V0SWRQcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbdHlwZVVybFByZWZpeF0geW91ciBjdXN0b20gdHlwZVVybFByZWZpeChkZWZhdWx0IFwidHlwZS5nb29nbGVhcGlzLmNvbVwiKVxuICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgZGVmYXVsdCB0eXBlIHVybFxuICAgICAgICAgKi9cbiAgICAgICAgT3BlcmF0b3JTZXRJZFByb3RvLmdldFR5cGVVcmwgPSBmdW5jdGlvbiBnZXRUeXBlVXJsKHR5cGVVcmxQcmVmaXgpIHtcbiAgICAgICAgICAgIGlmICh0eXBlVXJsUHJlZml4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0eXBlVXJsUHJlZml4ID0gXCJ0eXBlLmdvb2dsZWFwaXMuY29tXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHlwZVVybFByZWZpeCArIFwiL29ubnguT3BlcmF0b3JTZXRJZFByb3RvXCI7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIE9wZXJhdG9yU2V0SWRQcm90bztcbiAgICB9KSgpO1xuXG4gICAgLyoqXG4gICAgICogT3BlcmF0b3JTdGF0dXMgZW51bS5cbiAgICAgKiBAbmFtZSBvbm54Lk9wZXJhdG9yU3RhdHVzXG4gICAgICogQGVudW0ge251bWJlcn1cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gRVhQRVJJTUVOVEFMPTAgRVhQRVJJTUVOVEFMIHZhbHVlXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IFNUQUJMRT0xIFNUQUJMRSB2YWx1ZVxuICAgICAqL1xuICAgIG9ubnguT3BlcmF0b3JTdGF0dXMgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2YWx1ZXNCeUlkID0ge30sIHZhbHVlcyA9IE9iamVjdC5jcmVhdGUodmFsdWVzQnlJZCk7XG4gICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzBdID0gXCJFWFBFUklNRU5UQUxcIl0gPSAwO1xuICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFsxXSA9IFwiU1RBQkxFXCJdID0gMTtcbiAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICB9KSgpO1xuXG4gICAgb25ueC5GdW5jdGlvblByb3RvID0gKGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm9wZXJ0aWVzIG9mIGEgRnVuY3Rpb25Qcm90by5cbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnhcbiAgICAgICAgICogQGludGVyZmFjZSBJRnVuY3Rpb25Qcm90b1xuICAgICAgICAgKiBAcHJvcGVydHkge3N0cmluZ3xudWxsfSBbbmFtZV0gRnVuY3Rpb25Qcm90byBuYW1lXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7QXJyYXkuPHN0cmluZz58bnVsbH0gW2lucHV0XSBGdW5jdGlvblByb3RvIGlucHV0XG4gICAgICAgICAqIEBwcm9wZXJ0eSB7QXJyYXkuPHN0cmluZz58bnVsbH0gW291dHB1dF0gRnVuY3Rpb25Qcm90byBvdXRwdXRcbiAgICAgICAgICogQHByb3BlcnR5IHtBcnJheS48c3RyaW5nPnxudWxsfSBbYXR0cmlidXRlXSBGdW5jdGlvblByb3RvIGF0dHJpYnV0ZVxuICAgICAgICAgKiBAcHJvcGVydHkge0FycmF5Ljxvbm54LklBdHRyaWJ1dGVQcm90bz58bnVsbH0gW2F0dHJpYnV0ZVByb3RvXSBGdW5jdGlvblByb3RvIGF0dHJpYnV0ZVByb3RvXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7QXJyYXkuPG9ubnguSU5vZGVQcm90bz58bnVsbH0gW25vZGVdIEZ1bmN0aW9uUHJvdG8gbm9kZVxuICAgICAgICAgKiBAcHJvcGVydHkge3N0cmluZ3xudWxsfSBbZG9jU3RyaW5nXSBGdW5jdGlvblByb3RvIGRvY1N0cmluZ1xuICAgICAgICAgKiBAcHJvcGVydHkge0FycmF5Ljxvbm54LklPcGVyYXRvclNldElkUHJvdG8+fG51bGx9IFtvcHNldEltcG9ydF0gRnVuY3Rpb25Qcm90byBvcHNldEltcG9ydFxuICAgICAgICAgKiBAcHJvcGVydHkge3N0cmluZ3xudWxsfSBbZG9tYWluXSBGdW5jdGlvblByb3RvIGRvbWFpblxuICAgICAgICAgKi9cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29uc3RydWN0cyBhIG5ldyBGdW5jdGlvblByb3RvLlxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueFxuICAgICAgICAgKiBAY2xhc3NkZXNjIFJlcHJlc2VudHMgYSBGdW5jdGlvblByb3RvLlxuICAgICAgICAgKiBAaW1wbGVtZW50cyBJRnVuY3Rpb25Qcm90b1xuICAgICAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgICAgICogQHBhcmFtIHtvbm54LklGdW5jdGlvblByb3RvPX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBGdW5jdGlvblByb3RvKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHRoaXMuaW5wdXQgPSBbXTtcbiAgICAgICAgICAgIHRoaXMub3V0cHV0ID0gW107XG4gICAgICAgICAgICB0aGlzLmF0dHJpYnV0ZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5hdHRyaWJ1dGVQcm90byA9IFtdO1xuICAgICAgICAgICAgdGhpcy5ub2RlID0gW107XG4gICAgICAgICAgICB0aGlzLm9wc2V0SW1wb3J0ID0gW107XG4gICAgICAgICAgICBpZiAocHJvcGVydGllcylcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvcGVydGllcyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXNba2V5c1tpXV0gIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNba2V5c1tpXV0gPSBwcm9wZXJ0aWVzW2tleXNbaV1dO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZ1bmN0aW9uUHJvdG8gbmFtZS5cbiAgICAgICAgICogQG1lbWJlciB7c3RyaW5nfSBuYW1lXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LkZ1bmN0aW9uUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBGdW5jdGlvblByb3RvLnByb3RvdHlwZS5uYW1lID0gXCJcIjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRnVuY3Rpb25Qcm90byBpbnB1dC5cbiAgICAgICAgICogQG1lbWJlciB7QXJyYXkuPHN0cmluZz59IGlucHV0XG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LkZ1bmN0aW9uUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBGdW5jdGlvblByb3RvLnByb3RvdHlwZS5pbnB1dCA9ICR1dGlsLmVtcHR5QXJyYXk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZ1bmN0aW9uUHJvdG8gb3V0cHV0LlxuICAgICAgICAgKiBAbWVtYmVyIHtBcnJheS48c3RyaW5nPn0gb3V0cHV0XG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LkZ1bmN0aW9uUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBGdW5jdGlvblByb3RvLnByb3RvdHlwZS5vdXRwdXQgPSAkdXRpbC5lbXB0eUFycmF5O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGdW5jdGlvblByb3RvIGF0dHJpYnV0ZS5cbiAgICAgICAgICogQG1lbWJlciB7QXJyYXkuPHN0cmluZz59IGF0dHJpYnV0ZVxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5GdW5jdGlvblByb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgRnVuY3Rpb25Qcm90by5wcm90b3R5cGUuYXR0cmlidXRlID0gJHV0aWwuZW1wdHlBcnJheTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRnVuY3Rpb25Qcm90byBhdHRyaWJ1dGVQcm90by5cbiAgICAgICAgICogQG1lbWJlciB7QXJyYXkuPG9ubnguSUF0dHJpYnV0ZVByb3RvPn0gYXR0cmlidXRlUHJvdG9cbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguRnVuY3Rpb25Qcm90b1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIEZ1bmN0aW9uUHJvdG8ucHJvdG90eXBlLmF0dHJpYnV0ZVByb3RvID0gJHV0aWwuZW1wdHlBcnJheTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRnVuY3Rpb25Qcm90byBub2RlLlxuICAgICAgICAgKiBAbWVtYmVyIHtBcnJheS48b25ueC5JTm9kZVByb3RvPn0gbm9kZVxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5GdW5jdGlvblByb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgRnVuY3Rpb25Qcm90by5wcm90b3R5cGUubm9kZSA9ICR1dGlsLmVtcHR5QXJyYXk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZ1bmN0aW9uUHJvdG8gZG9jU3RyaW5nLlxuICAgICAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IGRvY1N0cmluZ1xuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5GdW5jdGlvblByb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgRnVuY3Rpb25Qcm90by5wcm90b3R5cGUuZG9jU3RyaW5nID0gXCJcIjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRnVuY3Rpb25Qcm90byBvcHNldEltcG9ydC5cbiAgICAgICAgICogQG1lbWJlciB7QXJyYXkuPG9ubnguSU9wZXJhdG9yU2V0SWRQcm90bz59IG9wc2V0SW1wb3J0XG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LkZ1bmN0aW9uUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBGdW5jdGlvblByb3RvLnByb3RvdHlwZS5vcHNldEltcG9ydCA9ICR1dGlsLmVtcHR5QXJyYXk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZ1bmN0aW9uUHJvdG8gZG9tYWluLlxuICAgICAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IGRvbWFpblxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5GdW5jdGlvblByb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgRnVuY3Rpb25Qcm90by5wcm90b3R5cGUuZG9tYWluID0gXCJcIjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIG5ldyBGdW5jdGlvblByb3RvIGluc3RhbmNlIHVzaW5nIHRoZSBzcGVjaWZpZWQgcHJvcGVydGllcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGNyZWF0ZVxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5GdW5jdGlvblByb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtvbm54LklGdW5jdGlvblByb3RvPX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gICAgICAgICAqIEByZXR1cm5zIHtvbm54LkZ1bmN0aW9uUHJvdG99IEZ1bmN0aW9uUHJvdG8gaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIEZ1bmN0aW9uUHJvdG8uY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRnVuY3Rpb25Qcm90byhwcm9wZXJ0aWVzKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRW5jb2RlcyB0aGUgc3BlY2lmaWVkIEZ1bmN0aW9uUHJvdG8gbWVzc2FnZS4gRG9lcyBub3QgaW1wbGljaXRseSB7QGxpbmsgb25ueC5GdW5jdGlvblByb3RvLnZlcmlmeXx2ZXJpZnl9IG1lc3NhZ2VzLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZW5jb2RlXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LkZ1bmN0aW9uUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge29ubnguSUZ1bmN0aW9uUHJvdG99IG1lc3NhZ2UgRnVuY3Rpb25Qcm90byBtZXNzYWdlIG9yIHBsYWluIG9iamVjdCB0byBlbmNvZGVcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuV3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gZW5jb2RlIHRvXG4gICAgICAgICAqIEByZXR1cm5zIHskcHJvdG9idWYuV3JpdGVyfSBXcml0ZXJcbiAgICAgICAgICovXG4gICAgICAgIEZ1bmN0aW9uUHJvdG8uZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgICAgaWYgKCF3cml0ZXIpXG4gICAgICAgICAgICAgICAgd3JpdGVyID0gJFdyaXRlci5jcmVhdGUoKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm5hbWUgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcIm5hbWVcIikpXG4gICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCAxLCB3aXJlVHlwZSAyID0qLzEwKS5zdHJpbmcobWVzc2FnZS5uYW1lKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmlucHV0ICE9IG51bGwgJiYgbWVzc2FnZS5pbnB1dC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLmlucHV0Lmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDQsIHdpcmVUeXBlIDIgPSovMzQpLnN0cmluZyhtZXNzYWdlLmlucHV0W2ldKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm91dHB1dCAhPSBudWxsICYmIG1lc3NhZ2Uub3V0cHV0Lmxlbmd0aClcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2Uub3V0cHV0Lmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDUsIHdpcmVUeXBlIDIgPSovNDIpLnN0cmluZyhtZXNzYWdlLm91dHB1dFtpXSk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5hdHRyaWJ1dGUgIT0gbnVsbCAmJiBtZXNzYWdlLmF0dHJpYnV0ZS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLmF0dHJpYnV0ZS5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCA2LCB3aXJlVHlwZSAyID0qLzUwKS5zdHJpbmcobWVzc2FnZS5hdHRyaWJ1dGVbaV0pO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2Uubm9kZSAhPSBudWxsICYmIG1lc3NhZ2Uubm9kZS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLm5vZGUubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgICRyb290Lm9ubnguTm9kZVByb3RvLmVuY29kZShtZXNzYWdlLm5vZGVbaV0sIHdyaXRlci51aW50MzIoLyogaWQgNywgd2lyZVR5cGUgMiA9Ki81OCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmRvY1N0cmluZyAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwiZG9jU3RyaW5nXCIpKVxuICAgICAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgOCwgd2lyZVR5cGUgMiA9Ki82Nikuc3RyaW5nKG1lc3NhZ2UuZG9jU3RyaW5nKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm9wc2V0SW1wb3J0ICE9IG51bGwgJiYgbWVzc2FnZS5vcHNldEltcG9ydC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLm9wc2V0SW1wb3J0Lmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICAkcm9vdC5vbm54Lk9wZXJhdG9yU2V0SWRQcm90by5lbmNvZGUobWVzc2FnZS5vcHNldEltcG9ydFtpXSwgd3JpdGVyLnVpbnQzMigvKiBpZCA5LCB3aXJlVHlwZSAyID0qLzc0KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZG9tYWluICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJkb21haW5cIikpXG4gICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCAxMCwgd2lyZVR5cGUgMiA9Ki84Mikuc3RyaW5nKG1lc3NhZ2UuZG9tYWluKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmF0dHJpYnV0ZVByb3RvICE9IG51bGwgJiYgbWVzc2FnZS5hdHRyaWJ1dGVQcm90by5sZW5ndGgpXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLmF0dHJpYnV0ZVByb3RvLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICAkcm9vdC5vbm54LkF0dHJpYnV0ZVByb3RvLmVuY29kZShtZXNzYWdlLmF0dHJpYnV0ZVByb3RvW2ldLCB3cml0ZXIudWludDMyKC8qIGlkIDExLCB3aXJlVHlwZSAyID0qLzkwKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRW5jb2RlcyB0aGUgc3BlY2lmaWVkIEZ1bmN0aW9uUHJvdG8gbWVzc2FnZSwgbGVuZ3RoIGRlbGltaXRlZC4gRG9lcyBub3QgaW1wbGljaXRseSB7QGxpbmsgb25ueC5GdW5jdGlvblByb3RvLnZlcmlmeXx2ZXJpZnl9IG1lc3NhZ2VzLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LkZ1bmN0aW9uUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge29ubnguSUZ1bmN0aW9uUHJvdG99IG1lc3NhZ2UgRnVuY3Rpb25Qcm90byBtZXNzYWdlIG9yIHBsYWluIG9iamVjdCB0byBlbmNvZGVcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuV3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gZW5jb2RlIHRvXG4gICAgICAgICAqIEByZXR1cm5zIHskcHJvdG9idWYuV3JpdGVyfSBXcml0ZXJcbiAgICAgICAgICovXG4gICAgICAgIEZ1bmN0aW9uUHJvdG8uZW5jb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikubGRlbGltKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlY29kZXMgYSBGdW5jdGlvblByb3RvIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIuXG4gICAgICAgICAqIEBmdW5jdGlvbiBkZWNvZGVcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguRnVuY3Rpb25Qcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLlJlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGUgZnJvbVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aF0gTWVzc2FnZSBsZW5ndGggaWYga25vd24gYmVmb3JlaGFuZFxuICAgICAgICAgKiBAcmV0dXJucyB7b25ueC5GdW5jdGlvblByb3RvfSBGdW5jdGlvblByb3RvXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAgICAgKi9cbiAgICAgICAgRnVuY3Rpb25Qcm90by5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUocmVhZGVyLCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgICAgIHJlYWRlciA9ICRSZWFkZXIuY3JlYXRlKHJlYWRlcik7XG4gICAgICAgICAgICB2YXIgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aCwgbWVzc2FnZSA9IG5ldyAkcm9vdC5vbm54LkZ1bmN0aW9uUHJvdG8oKTtcbiAgICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMToge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5uYW1lID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIDQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKG1lc3NhZ2UuaW5wdXQgJiYgbWVzc2FnZS5pbnB1dC5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaW5wdXQgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaW5wdXQucHVzaChyZWFkZXIuc3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIDU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKG1lc3NhZ2Uub3V0cHV0ICYmIG1lc3NhZ2Uub3V0cHV0Lmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5vdXRwdXQgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uub3V0cHV0LnB1c2gocmVhZGVyLnN0cmluZygpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSA2OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShtZXNzYWdlLmF0dHJpYnV0ZSAmJiBtZXNzYWdlLmF0dHJpYnV0ZS5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuYXR0cmlidXRlID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmF0dHJpYnV0ZS5wdXNoKHJlYWRlci5zdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgMTE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKG1lc3NhZ2UuYXR0cmlidXRlUHJvdG8gJiYgbWVzc2FnZS5hdHRyaWJ1dGVQcm90by5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuYXR0cmlidXRlUHJvdG8gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuYXR0cmlidXRlUHJvdG8ucHVzaCgkcm9vdC5vbm54LkF0dHJpYnV0ZVByb3RvLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIDc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKG1lc3NhZ2Uubm9kZSAmJiBtZXNzYWdlLm5vZGUubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm5vZGUgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uubm9kZS5wdXNoKCRyb290Lm9ubnguTm9kZVByb3RvLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIDg6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZG9jU3RyaW5nID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIDk6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKG1lc3NhZ2Uub3BzZXRJbXBvcnQgJiYgbWVzc2FnZS5vcHNldEltcG9ydC5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uub3BzZXRJbXBvcnQgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uub3BzZXRJbXBvcnQucHVzaCgkcm9vdC5vbm54Lk9wZXJhdG9yU2V0SWRQcm90by5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAxMDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5kb21haW4gPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlY29kZXMgYSBGdW5jdGlvblByb3RvIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIsIGxlbmd0aCBkZWxpbWl0ZWQuXG4gICAgICAgICAqIEBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWRcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguRnVuY3Rpb25Qcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLlJlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGUgZnJvbVxuICAgICAgICAgKiBAcmV0dXJucyB7b25ueC5GdW5jdGlvblByb3RvfSBGdW5jdGlvblByb3RvXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAgICAgKi9cbiAgICAgICAgRnVuY3Rpb25Qcm90by5kZWNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWQocmVhZGVyKSB7XG4gICAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgICByZWFkZXIgPSBuZXcgJFJlYWRlcihyZWFkZXIpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVmVyaWZpZXMgYSBGdW5jdGlvblByb3RvIG1lc3NhZ2UuXG4gICAgICAgICAqIEBmdW5jdGlvbiB2ZXJpZnlcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguRnVuY3Rpb25Qcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG1lc3NhZ2UgUGxhaW4gb2JqZWN0IHRvIHZlcmlmeVxuICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9IGBudWxsYCBpZiB2YWxpZCwgb3RoZXJ3aXNlIHRoZSByZWFzb24gd2h5IGl0IGlzIG5vdFxuICAgICAgICAgKi9cbiAgICAgICAgRnVuY3Rpb25Qcm90by52ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnkobWVzc2FnZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlICE9PSBcIm9iamVjdFwiIHx8IG1lc3NhZ2UgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwib2JqZWN0IGV4cGVjdGVkXCI7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5uYW1lICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIm5hbWVcIikpXG4gICAgICAgICAgICAgICAgaWYgKCEkdXRpbC5pc1N0cmluZyhtZXNzYWdlLm5hbWUpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJuYW1lOiBzdHJpbmcgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmlucHV0ICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImlucHV0XCIpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG1lc3NhZ2UuaW5wdXQpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJpbnB1dDogYXJyYXkgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UuaW5wdXQubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIGlmICghJHV0aWwuaXNTdHJpbmcobWVzc2FnZS5pbnB1dFtpXSkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJpbnB1dDogc3RyaW5nW10gZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm91dHB1dCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJvdXRwdXRcIikpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobWVzc2FnZS5vdXRwdXQpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJvdXRwdXQ6IGFycmF5IGV4cGVjdGVkXCI7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLm91dHB1dC5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEkdXRpbC5pc1N0cmluZyhtZXNzYWdlLm91dHB1dFtpXSkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJvdXRwdXQ6IHN0cmluZ1tdIGV4cGVjdGVkXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5hdHRyaWJ1dGUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiYXR0cmlidXRlXCIpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG1lc3NhZ2UuYXR0cmlidXRlKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiYXR0cmlidXRlOiBhcnJheSBleHBlY3RlZFwiO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5hdHRyaWJ1dGUubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIGlmICghJHV0aWwuaXNTdHJpbmcobWVzc2FnZS5hdHRyaWJ1dGVbaV0pKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiYXR0cmlidXRlOiBzdHJpbmdbXSBleHBlY3RlZFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuYXR0cmlidXRlUHJvdG8gIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiYXR0cmlidXRlUHJvdG9cIikpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobWVzc2FnZS5hdHRyaWJ1dGVQcm90bykpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImF0dHJpYnV0ZVByb3RvOiBhcnJheSBleHBlY3RlZFwiO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5hdHRyaWJ1dGVQcm90by5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXJyb3IgPSAkcm9vdC5vbm54LkF0dHJpYnV0ZVByb3RvLnZlcmlmeShtZXNzYWdlLmF0dHJpYnV0ZVByb3RvW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiYXR0cmlidXRlUHJvdG8uXCIgKyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5ub2RlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIm5vZGVcIikpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobWVzc2FnZS5ub2RlKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwibm9kZTogYXJyYXkgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2Uubm9kZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXJyb3IgPSAkcm9vdC5vbm54Lk5vZGVQcm90by52ZXJpZnkobWVzc2FnZS5ub2RlW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwibm9kZS5cIiArIGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmRvY1N0cmluZyAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJkb2NTdHJpbmdcIikpXG4gICAgICAgICAgICAgICAgaWYgKCEkdXRpbC5pc1N0cmluZyhtZXNzYWdlLmRvY1N0cmluZykpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImRvY1N0cmluZzogc3RyaW5nIGV4cGVjdGVkXCI7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5vcHNldEltcG9ydCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJvcHNldEltcG9ydFwiKSkge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShtZXNzYWdlLm9wc2V0SW1wb3J0KSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwib3BzZXRJbXBvcnQ6IGFycmF5IGV4cGVjdGVkXCI7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLm9wc2V0SW1wb3J0Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlcnJvciA9ICRyb290Lm9ubnguT3BlcmF0b3JTZXRJZFByb3RvLnZlcmlmeShtZXNzYWdlLm9wc2V0SW1wb3J0W2ldKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwib3BzZXRJbXBvcnQuXCIgKyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5kb21haW4gIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZG9tYWluXCIpKVxuICAgICAgICAgICAgICAgIGlmICghJHV0aWwuaXNTdHJpbmcobWVzc2FnZS5kb21haW4pKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJkb21haW46IHN0cmluZyBleHBlY3RlZFwiO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBGdW5jdGlvblByb3RvIG1lc3NhZ2UgZnJvbSBhIHBsYWluIG9iamVjdC4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gdGhlaXIgcmVzcGVjdGl2ZSBpbnRlcm5hbCB0eXBlcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGZyb21PYmplY3RcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguRnVuY3Rpb25Qcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG9iamVjdCBQbGFpbiBvYmplY3RcbiAgICAgICAgICogQHJldHVybnMge29ubnguRnVuY3Rpb25Qcm90b30gRnVuY3Rpb25Qcm90b1xuICAgICAgICAgKi9cbiAgICAgICAgRnVuY3Rpb25Qcm90by5mcm9tT2JqZWN0ID0gZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiAkcm9vdC5vbm54LkZ1bmN0aW9uUHJvdG8pXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgICAgIHZhciBtZXNzYWdlID0gbmV3ICRyb290Lm9ubnguRnVuY3Rpb25Qcm90bygpO1xuICAgICAgICAgICAgaWYgKG9iamVjdC5uYW1lICE9IG51bGwpXG4gICAgICAgICAgICAgICAgbWVzc2FnZS5uYW1lID0gU3RyaW5nKG9iamVjdC5uYW1lKTtcbiAgICAgICAgICAgIGlmIChvYmplY3QuaW5wdXQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqZWN0LmlucHV0KSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguRnVuY3Rpb25Qcm90by5pbnB1dDogYXJyYXkgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5pbnB1dCA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0LmlucHV0Lmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmlucHV0W2ldID0gU3RyaW5nKG9iamVjdC5pbnB1dFtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2JqZWN0Lm91dHB1dCkge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvYmplY3Qub3V0cHV0KSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguRnVuY3Rpb25Qcm90by5vdXRwdXQ6IGFycmF5IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2Uub3V0cHV0ID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3Qub3V0cHV0Lmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm91dHB1dFtpXSA9IFN0cmluZyhvYmplY3Qub3V0cHV0W2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvYmplY3QuYXR0cmlidXRlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9iamVjdC5hdHRyaWJ1dGUpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5GdW5jdGlvblByb3RvLmF0dHJpYnV0ZTogYXJyYXkgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5hdHRyaWJ1dGUgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdC5hdHRyaWJ1dGUubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuYXR0cmlidXRlW2ldID0gU3RyaW5nKG9iamVjdC5hdHRyaWJ1dGVbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9iamVjdC5hdHRyaWJ1dGVQcm90bykge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvYmplY3QuYXR0cmlidXRlUHJvdG8pKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5GdW5jdGlvblByb3RvLmF0dHJpYnV0ZVByb3RvOiBhcnJheSBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmF0dHJpYnV0ZVByb3RvID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3QuYXR0cmlidXRlUHJvdG8ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QuYXR0cmlidXRlUHJvdG9baV0gIT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5GdW5jdGlvblByb3RvLmF0dHJpYnV0ZVByb3RvOiBvYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuYXR0cmlidXRlUHJvdG9baV0gPSAkcm9vdC5vbm54LkF0dHJpYnV0ZVByb3RvLmZyb21PYmplY3Qob2JqZWN0LmF0dHJpYnV0ZVByb3RvW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2JqZWN0Lm5vZGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqZWN0Lm5vZGUpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5GdW5jdGlvblByb3RvLm5vZGU6IGFycmF5IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2Uubm9kZSA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0Lm5vZGUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3Qubm9kZVtpXSAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5vbm54LkZ1bmN0aW9uUHJvdG8ubm9kZTogb2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm5vZGVbaV0gPSAkcm9vdC5vbm54Lk5vZGVQcm90by5mcm9tT2JqZWN0KG9iamVjdC5ub2RlW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2JqZWN0LmRvY1N0cmluZyAhPSBudWxsKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UuZG9jU3RyaW5nID0gU3RyaW5nKG9iamVjdC5kb2NTdHJpbmcpO1xuICAgICAgICAgICAgaWYgKG9iamVjdC5vcHNldEltcG9ydCkge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvYmplY3Qub3BzZXRJbXBvcnQpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5GdW5jdGlvblByb3RvLm9wc2V0SW1wb3J0OiBhcnJheSBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLm9wc2V0SW1wb3J0ID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3Qub3BzZXRJbXBvcnQubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3Qub3BzZXRJbXBvcnRbaV0gIT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5GdW5jdGlvblByb3RvLm9wc2V0SW1wb3J0OiBvYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uub3BzZXRJbXBvcnRbaV0gPSAkcm9vdC5vbm54Lk9wZXJhdG9yU2V0SWRQcm90by5mcm9tT2JqZWN0KG9iamVjdC5vcHNldEltcG9ydFtpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9iamVjdC5kb21haW4gIT0gbnVsbClcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmRvbWFpbiA9IFN0cmluZyhvYmplY3QuZG9tYWluKTtcbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgcGxhaW4gb2JqZWN0IGZyb20gYSBGdW5jdGlvblByb3RvIG1lc3NhZ2UuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIG90aGVyIHR5cGVzIGlmIHNwZWNpZmllZC5cbiAgICAgICAgICogQGZ1bmN0aW9uIHRvT2JqZWN0XG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LkZ1bmN0aW9uUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge29ubnguRnVuY3Rpb25Qcm90b30gbWVzc2FnZSBGdW5jdGlvblByb3RvXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLklDb252ZXJzaW9uT3B0aW9uc30gW29wdGlvbnNdIENvbnZlcnNpb24gb3B0aW9uc1xuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IFBsYWluIG9iamVjdFxuICAgICAgICAgKi9cbiAgICAgICAgRnVuY3Rpb25Qcm90by50b09iamVjdCA9IGZ1bmN0aW9uIHRvT2JqZWN0KG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucylcbiAgICAgICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgICAgICB2YXIgb2JqZWN0ID0ge307XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5hcnJheXMgfHwgb3B0aW9ucy5kZWZhdWx0cykge1xuICAgICAgICAgICAgICAgIG9iamVjdC5pbnB1dCA9IFtdO1xuICAgICAgICAgICAgICAgIG9iamVjdC5vdXRwdXQgPSBbXTtcbiAgICAgICAgICAgICAgICBvYmplY3QuYXR0cmlidXRlID0gW107XG4gICAgICAgICAgICAgICAgb2JqZWN0Lm5vZGUgPSBbXTtcbiAgICAgICAgICAgICAgICBvYmplY3Qub3BzZXRJbXBvcnQgPSBbXTtcbiAgICAgICAgICAgICAgICBvYmplY3QuYXR0cmlidXRlUHJvdG8gPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmRlZmF1bHRzKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0Lm5hbWUgPSBcIlwiO1xuICAgICAgICAgICAgICAgIG9iamVjdC5kb2NTdHJpbmcgPSBcIlwiO1xuICAgICAgICAgICAgICAgIG9iamVjdC5kb21haW4gPSBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UubmFtZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJuYW1lXCIpKVxuICAgICAgICAgICAgICAgIG9iamVjdC5uYW1lID0gbWVzc2FnZS5uYW1lO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuaW5wdXQgJiYgbWVzc2FnZS5pbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBvYmplY3QuaW5wdXQgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1lc3NhZ2UuaW5wdXQubGVuZ3RoOyArK2opXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5pbnB1dFtqXSA9IG1lc3NhZ2UuaW5wdXRbal07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5vdXRwdXQgJiYgbWVzc2FnZS5vdXRwdXQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0Lm91dHB1dCA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWVzc2FnZS5vdXRwdXQubGVuZ3RoOyArK2opXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5vdXRwdXRbal0gPSBtZXNzYWdlLm91dHB1dFtqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmF0dHJpYnV0ZSAmJiBtZXNzYWdlLmF0dHJpYnV0ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBvYmplY3QuYXR0cmlidXRlID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtZXNzYWdlLmF0dHJpYnV0ZS5sZW5ndGg7ICsrailcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LmF0dHJpYnV0ZVtqXSA9IG1lc3NhZ2UuYXR0cmlidXRlW2pdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2Uubm9kZSAmJiBtZXNzYWdlLm5vZGUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0Lm5vZGUgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1lc3NhZ2Uubm9kZS5sZW5ndGg7ICsrailcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0Lm5vZGVbal0gPSAkcm9vdC5vbm54Lk5vZGVQcm90by50b09iamVjdChtZXNzYWdlLm5vZGVbal0sIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZG9jU3RyaW5nICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImRvY1N0cmluZ1wiKSlcbiAgICAgICAgICAgICAgICBvYmplY3QuZG9jU3RyaW5nID0gbWVzc2FnZS5kb2NTdHJpbmc7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5vcHNldEltcG9ydCAmJiBtZXNzYWdlLm9wc2V0SW1wb3J0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIG9iamVjdC5vcHNldEltcG9ydCA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWVzc2FnZS5vcHNldEltcG9ydC5sZW5ndGg7ICsrailcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0Lm9wc2V0SW1wb3J0W2pdID0gJHJvb3Qub25ueC5PcGVyYXRvclNldElkUHJvdG8udG9PYmplY3QobWVzc2FnZS5vcHNldEltcG9ydFtqXSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5kb21haW4gIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZG9tYWluXCIpKVxuICAgICAgICAgICAgICAgIG9iamVjdC5kb21haW4gPSBtZXNzYWdlLmRvbWFpbjtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmF0dHJpYnV0ZVByb3RvICYmIG1lc3NhZ2UuYXR0cmlidXRlUHJvdG8ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0LmF0dHJpYnV0ZVByb3RvID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtZXNzYWdlLmF0dHJpYnV0ZVByb3RvLmxlbmd0aDsgKytqKVxuICAgICAgICAgICAgICAgICAgICBvYmplY3QuYXR0cmlidXRlUHJvdG9bal0gPSAkcm9vdC5vbm54LkF0dHJpYnV0ZVByb3RvLnRvT2JqZWN0KG1lc3NhZ2UuYXR0cmlidXRlUHJvdG9bal0sIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29udmVydHMgdGhpcyBGdW5jdGlvblByb3RvIHRvIEpTT04uXG4gICAgICAgICAqIEBmdW5jdGlvbiB0b0pTT05cbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguRnVuY3Rpb25Qcm90b1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBKU09OIG9iamVjdFxuICAgICAgICAgKi9cbiAgICAgICAgRnVuY3Rpb25Qcm90by5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcywgJHByb3RvYnVmLnV0aWwudG9KU09OT3B0aW9ucyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHMgdGhlIGRlZmF1bHQgdHlwZSB1cmwgZm9yIEZ1bmN0aW9uUHJvdG9cbiAgICAgICAgICogQGZ1bmN0aW9uIGdldFR5cGVVcmxcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguRnVuY3Rpb25Qcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbdHlwZVVybFByZWZpeF0geW91ciBjdXN0b20gdHlwZVVybFByZWZpeChkZWZhdWx0IFwidHlwZS5nb29nbGVhcGlzLmNvbVwiKVxuICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgZGVmYXVsdCB0eXBlIHVybFxuICAgICAgICAgKi9cbiAgICAgICAgRnVuY3Rpb25Qcm90by5nZXRUeXBlVXJsID0gZnVuY3Rpb24gZ2V0VHlwZVVybCh0eXBlVXJsUHJlZml4KSB7XG4gICAgICAgICAgICBpZiAodHlwZVVybFByZWZpeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdHlwZVVybFByZWZpeCA9IFwidHlwZS5nb29nbGVhcGlzLmNvbVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHR5cGVVcmxQcmVmaXggKyBcIi9vbm54LkZ1bmN0aW9uUHJvdG9cIjtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gRnVuY3Rpb25Qcm90bztcbiAgICB9KSgpO1xuXG4gICAgcmV0dXJuIG9ubng7XG59KSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9ICRyb290O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge2ZsYXRidWZmZXJzfSBmcm9tICdmbGF0YnVmZmVycyc7XG5pbXBvcnQgTG9uZyBmcm9tICdsb25nJztcblxuaW1wb3J0IHtHcmFwaH0gZnJvbSAnLi9ncmFwaCc7XG5pbXBvcnQge29ubnhydW50aW1lfSBmcm9tICcuL29ydC1zY2hlbWEvZmxhdGJ1ZmZlcnMvb3J0LWdlbmVyYXRlZCc7XG5pbXBvcnQge29ubnh9IGZyb20gJy4vb3J0LXNjaGVtYS9wcm90b2J1Zi9vbm54JztcbmltcG9ydCB7VGVuc29yfSBmcm9tICcuL3RlbnNvcic7XG5cbi8vIGNoZWNrIHRoZSBpbnB1dHMgc2hhcGUgYmVmb3JlIHJ1bm5pbmcgYW4gT1AuXG4vLyByZXR1cm4gdHJ1ZSB3aGVuIHRoZSBpbnB1dHMgcGFzcyB0aGUgY2hlY2tcbi8vIHJldHVybiBmYWxzZSB3aGVuIHRoZSBpbnB1dHMgZG8gbm90IGZpdCB0aGUgcmVxdWlyZW1lbnRcbi8vIHRocm93IGV4Y2VwdGlvbiB3aGVuIGZhdGFsIGVycm9yIG9yIG5vdCBpbXBsZW1lbnRlZFxuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrSW5wdXRzU2hhcGUoaW5wdXRzOiBUZW5zb3JbXSwgLi4uZXhwZWN0ZWREaW1lbnNpb25zOiBudW1iZXJbXSk6IGJvb2xlYW4ge1xuICBpZiAoIWlucHV0cyB8fCBpbnB1dHMubGVuZ3RoICE9PSBleHBlY3RlZERpbWVuc2lvbnMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCFpbnB1dHNbaV0uZGltcyB8fCBpbnB1dHNbaV0uZGltcy5sZW5ndGggIT09IGV4cGVjdGVkRGltZW5zaW9uc1tpXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLy8gRXZhbHVhdGVzIHRoZSBnaXZlbiBleHByZXNzaW9uIGFuZCBhc3NlcnRzIGVycm9yIG1lc3NhZ2UgaWYgY29uZGl0aW9uIGlzIHVubWV0LlxuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydChleHByOiBib29sZWFuLCBtc2c6ICgpID0+IHN0cmluZykge1xuICBpZiAoIWV4cHIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IodHlwZW9mIG1zZyA9PT0gJ3N0cmluZycgPyBtc2cgOiBtc2coKSk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEFycmF5VXRpbCB7XG4gIC8qKlxuICAgKiBWZXJpZmllcyBpZiAyIGlucHV0IGFycmF5cyBjb250YWluIHRoZSBzYW1lIGVsZW1lbnRzLlxuICAgKiBAcGFyYW0gbjEgQXJyYXkgMVxuICAgKiBAcGFyYW0gbjIgQXJyYXkgMlxuICAgKiBAcmV0dXJucyBXaGV0aGVyIHRoZXNlIDIgYXJlIGVxdWFsXG4gICAqL1xuICBzdGF0aWMgYXJyYXlzRXF1YWwoXG4gICAgICBuMTogcmVhZG9ubHkgbnVtYmVyW118SW50OEFycmF5fFVpbnQ4QXJyYXl8SW50MTZBcnJheXxVaW50MTZBcnJheXxJbnQzMkFycmF5fFVpbnQzMkFycmF5fFVpbnQ4Q2xhbXBlZEFycmF5fFxuICAgICAgRmxvYXQzMkFycmF5fEZsb2F0NjRBcnJheSxcbiAgICAgIG4yOiByZWFkb25seSBudW1iZXJbXXxJbnQ4QXJyYXl8VWludDhBcnJheXxJbnQxNkFycmF5fFVpbnQxNkFycmF5fEludDMyQXJyYXl8VWludDMyQXJyYXl8VWludDhDbGFtcGVkQXJyYXl8XG4gICAgICBGbG9hdDMyQXJyYXl8RmxvYXQ2NEFycmF5KSB7XG4gICAgaWYgKG4xLmxlbmd0aCAhPT0gbjIubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChuMVtpXSAhPT0gbjJbaV0pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgTWF0TXVsVXRpbCB7XG4gIC8qKlxuICAgKiBGaXggdGhlIGlucHV0IHNoYXBlcyBmb3IgTWF0TXVsIG9wZXJhdGlvbiBpZiB0aGV5IG5lZWQgZml4aW5nXG4gICAqIEBwYXJhbSBkaW1zQSBUaGUgc2hhcGUgb2YgdGVuc29yIEEuIFNob3VsZCBiZSBhbiBhcnJheSBvZiBwb3NpdGl2ZSBpbnRlZ2Vyc1xuICAgKiBAcGFyYW0gZGltc0IgVGhlIHNoYXBlIG9mIHRlbnNvciBCLiBTaG91bGQgYmUgYW4gYXJyYXkgb2YgcG9zaXRpdmUgaW50ZWdlcnNcbiAgICogQHJldHVybnMgQSB0dXBsZSBjb250YWluaW5nIHRoZSBwcmVwcm9jZXNzZWQgaW5wdXQgc2hhcGVzIGFzIHJlcXVpcmVkIGJ5IE9OTlggc3BlY2lmaWNhdGlvbnNcbiAgICovXG4gIHN0YXRpYyBwcmVwcm9jZXNzSW5wdXRTaGFwZXMoZGltc0E6IHJlYWRvbmx5IG51bWJlcltdLCBkaW1zQjogcmVhZG9ubHkgbnVtYmVyW10pOlxuICAgICAgW3JlYWRvbmx5IG51bWJlcltdLCByZWFkb25seSBudW1iZXJbXV0ge1xuICAgIC8vIElmIHRoZSBmaXJzdCBhcmd1bWVudCBpcyAxLUQsIGl0IGlzIHByb21vdGVkIHRvIGEgbWF0cml4IGJ5IHByZXBlbmRpbmdcbiAgICAvLyBhIDEgdG8gaXRzIGRpbWVuc2lvbnMuIEFmdGVyIG1hdHJpeCBtdWx0aXBsaWNhdGlvbiB0aGUgcHJlcGVuZGVkIDEgaXNcbiAgICAvLyByZW1vdmVkLlxuICAgIGNvbnN0IGEgPSAoZGltc0EubGVuZ3RoID09PSAxKSA/IFsxLCBkaW1zQVswXV0gOiBkaW1zQTtcblxuICAgIC8vIElmIHRoZSBzZWNvbmQgYXJndW1lbnQgaXMgMS1ELCBpdCBpcyBwcm9tb3RlZCB0byBhIG1hdHJpeCBieSBhcHBlbmRpbmdcbiAgICAvLyBhIDEgdG8gaXRzIGRpbWVuc2lvbnMuIEFmdGVyIG1hdHJpeCBtdWx0aXBsaWNhdGlvbiB0aGUgYXBwZW5kZWQgMSBpc1xuICAgIC8vIHJlbW92ZWQuXG4gICAgY29uc3QgYiA9IChkaW1zQi5sZW5ndGggPT09IDEpID8gW2RpbXNCWzBdLCAxXSA6IGRpbXNCO1xuXG4gICAgcmV0dXJuIFthLCBiXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaXggdGhlIG91dHB1dCBzaGFwZSBjb21wdXRlZCBmb3IgTWF0TXVsIG9wZXJhdGlvbiBpZiBpdCBuZWVkcyBmaXhpbmdcbiAgICogQHBhcmFtIG91dHB1dFNoYXBlIFRoZSBjb21wdXRlZCBvdXRwdXRTaGFwZS4gU2hvdWxkIGJlIGFuIGFycmF5IChhdGxlYXN0IG9mIGxlbmd0aCAyKSBvZiBwb3NpdGl2ZSBpbnRlZ2Vycy5cbiAgICogVGhpcyB3aWxsIGJlIG11dGF0ZWQuXG4gICAqIEBwYXJhbSBhUmFuayBUaGUgcmFuayBvZiB0ZW5zb3IgQS5cbiAgICogQHBhcmFtIGJSYW5rIFRoZSByYW5rIG9mIHRlbnNvciBCLlxuICAgKi9cbiAgc3RhdGljIHBvc3Rwcm9jZXNzT3V0cHV0U2hhcGUob3V0cHV0U2hhcGU6IG51bWJlcltdLCBhUmFuazogbnVtYmVyLCBiUmFuazogbnVtYmVyKSB7XG4gICAgLy8gUmVtb3ZlIHByZXBlbmRlZCBkaW1lbnNpb24gaWYgZmlyc3QgaW5wdXQgaXMgMWRcbiAgICBpZiAoYVJhbmsgPT09IDEpIHtcbiAgICAgIC8vIG91dHB1dFNoYXBlID0gb3V0cHV0U2hhcGUuc2xpY2UoMCwgb3V0cHV0U2hhcGUubGVuZ3RoIC0gMikuY29uY2F0KG91dHB1dFNoYXBlLnNsaWNlKG91dHB1dFNoYXBlLmxlbmd0aCAtIDEpKTtcbiAgICAgIG91dHB1dFNoYXBlLnNwbGljZShvdXRwdXRTaGFwZS5sZW5ndGggLSAyLCAxKTtcbiAgICB9XG4gICAgLy8gUmVtb3ZlIGFwcGVuZGVkIGRpbWVuc2lvbiBpZiBzZWNvbmQgaW5wdXQgaXMgMWRcbiAgICBpZiAoYlJhbmsgPT09IDEpIHtcbiAgICAgIG91dHB1dFNoYXBlLnBvcCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIGV4cGVjdGVkIHNoYXBlIHdoZW4gbWF0cml4IG11bHRpcGxpY2F0aW9uXG4gICAqIEBwYXJhbSBhIFRoZSBzaGFwZSBvZiB0ZW5zb3IgQS4gU2hvdWxkIGJlIGEgdHVwbGUgb2YgMiBwb3NpdGl2ZSBpbnRlZ2Vyc1xuICAgKiBAcGFyYW0gYiBUaGUgc2hhcGUgb2YgdGVuc29yIEIuIFNob3VsZCBiZSBhIHR1cGxlIG9mIDIgcG9zaXRpdmUgaW50ZWdlcnNcbiAgICogQHJldHVybnMgVGhlIGV4cGVjdGVkIHNoYXBlIG9mIHRoZSByZXN1bHQsIG9yIHVuZGVmaW5lZCBpZiBOL0FcbiAgICovXG4gIHN0YXRpYyBjYWxjTWF0TXVsU2hhcGUoYTogW251bWJlciwgbnVtYmVyXSwgYjogW251bWJlciwgbnVtYmVyXSk6IFtudW1iZXIsIG51bWJlcl18dW5kZWZpbmVkIHtcbiAgICByZXR1cm4gKGFbMV0gIT09IGJbMF0pID8gdW5kZWZpbmVkIDogW2FbMF0sIGJbMV1dO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBCcm9hZGNhc3RVdGlsIHtcbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgZXhwZWN0ZWQgc2hhcGUgd2hlbiBicm9hZGNhc3RpbmcgMiB0ZW5zb3JzXG4gICAqIEBwYXJhbSBhIFRoZSBzaGFwZSBvZiB0ZW5zb3IgQS4gU2hvdWxkIGJlIGFuIGFycmF5IG9mIHBvc2l0aXZlIGludGVnZXJzXG4gICAqIEBwYXJhbSBiIFRoZSBzaGFwZSBvZiB0ZW5zb3IgQi4gU2hvdWxkIGJlIGFuIGFycmF5IG9mIHBvc2l0aXZlIGludGVnZXJzXG4gICAqIEBwYXJhbSBpc01hdE11bCBXaGV0aGVyIHRoZSBvcGVyYXRpb24gaXMgTWF0TXVsXG4gICAqIEByZXR1cm5zIFRoZSBleHBlY3RlZCBzaGFwZSBvZiB0aGUgcmVzdWx0LCBvciB1bmRlZmluZWQgaWYgTi9BXG4gICAqL1xuICBzdGF0aWMgY2FsY1NoYXBlKGFkaW1zOiByZWFkb25seSBudW1iZXJbXSwgYmRpbXM6IHJlYWRvbmx5IG51bWJlcltdLCBpc01hdE11bCA9IGZhbHNlKTogcmVhZG9ubHkgbnVtYmVyW118dW5kZWZpbmVkIHtcbiAgICBjb25zdCBhcmFuayA9IGFkaW1zLmxlbmd0aDtcbiAgICBjb25zdCBicmFuayA9IGJkaW1zLmxlbmd0aDtcbiAgICBpZiAoYXJhbmsgPT09IDApIHtcbiAgICAgIHJldHVybiBiZGltcztcbiAgICB9XG4gICAgaWYgKGJyYW5rID09PSAwKSB7XG4gICAgICByZXR1cm4gYWRpbXM7XG4gICAgfVxuICAgIGNvbnN0IGNyYW5rID0gTWF0aC5tYXgoYWRpbXMubGVuZ3RoLCBiZGltcy5sZW5ndGgpO1xuICAgIGNvbnN0IGNkaW1zID0gbmV3IEFycmF5PG51bWJlcj4oY3JhbmspO1xuXG4gICAgLy8gY2FsY3VsYXRlIHRoZSBsYXN0IDIgZGltZW5zaW9uIGlmIGl0IGlzIE1hdE11bFxuICAgIGlmIChpc01hdE11bCkge1xuICAgICAgaWYgKGFyYW5rIDwgMiB8fCBicmFuayA8IDIpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNTaGFwZU1hdE11bCA9XG4gICAgICAgICAgTWF0TXVsVXRpbC5jYWxjTWF0TXVsU2hhcGUoW2FkaW1zW2FyYW5rIC0gMl0sIGFkaW1zW2FyYW5rIC0gMV1dLCBbYmRpbXNbYnJhbmsgLSAyXSwgYmRpbXNbYnJhbmsgLSAxXV0pO1xuICAgICAgaWYgKGNTaGFwZU1hdE11bCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBbY2RpbXNbY3JhbmsgLSAyXSwgY2RpbXNbY3JhbmsgLSAxXV0gPSBjU2hhcGVNYXRNdWw7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IGlzTWF0TXVsID8gMyA6IDE7IGkgPD0gY3Jhbms7IGkrKykge1xuICAgICAgY29uc3QgYUxlbiA9IGFyYW5rIC0gaSA8IDAgPyAxIDogYWRpbXNbYXJhbmsgLSBpXTtcbiAgICAgIGNvbnN0IGJMZW4gPSBicmFuayAtIGkgPCAwID8gMSA6IGJkaW1zW2JyYW5rIC0gaV07XG5cbiAgICAgIGlmIChhTGVuICE9PSBiTGVuICYmIGFMZW4gPiAxICYmIGJMZW4gPiAxKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBjZGltc1tjcmFuayAtIGldID0gTWF0aC5tYXgoYUxlbiwgYkxlbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNkaW1zO1xuICB9XG5cbiAgLyoqXG4gICAqIEdpdmVuIHRoZSBpbmRpY2VzIG9mIGEgYnJvYWRjYXN0ZWQgdGVuc29yLCBjYWxjdWxhdGUgdGhlIG9yaWdpbmFsIGluZGljZXNcbiAgICogQHBhcmFtIGJyb2FkY2FzdGVkSW5kaWNlcyBUaGUgZ2l2ZW4gaW5kaWNlcyBvZiB0aGUgYnJvYWRjYXN0ZWQgdGVuc29yLlxuICAgKiBAcGFyYW0gb3JpZ2luYWxTaGFwZSBUaGUgb3JpZ2luYWwgc2hhcGUgb2YgdGhlIHRlbnNvciBiZWZvcmUgYnJvYWRjYXNcbiAgICogQHJldHVybnMgVGhlIGNhbGN1bGF0ZWQgaW5kaWNlcyB0aGF0IG1hcHMgdG8gdGhlIG9yaWdpbmFsIHRlbnNvci5cbiAgICovXG4gIHN0YXRpYyBpbmRleChicm9hZGNhc3RlZEluZGljZXM6IHJlYWRvbmx5IG51bWJlcltdLCBvcmlnaW5hbFNoYXBlOiByZWFkb25seSBudW1iZXJbXSk6IG51bWJlcltdIHtcbiAgICAvLyBOT1RFIDE6IHdlIGFzc3VtZSB0aGUgcGFyYW1ldGVyIGJyb2FkY2FzdGVkSW5kaWNlcyBpcyB2YWxpZC4gaWUuIGl0IHNob3VsZCBoYXZlIHRoZSBzYW1lXG4gICAgLy8gbGVuZ3RoIGFzIHRoZSBicm9hZGNhc3RlZCBzaGFwZSwgYW5kIGZvciBlYWNoIGRpbWVuc2lvbiB0aGUgaW5kZXggc2hvdWxkXG4gICAgLy8gbm90IGJlIG91dCBvZiByYW5nZS5cbiAgICBjb25zdCBvcmlnaW5hbEluZGljZXMgPSBuZXcgQXJyYXkob3JpZ2luYWxTaGFwZS5sZW5ndGgpO1xuICAgIEJyb2FkY2FzdFV0aWwuZmlsbEluZGV4KGJyb2FkY2FzdGVkSW5kaWNlcywgb3JpZ2luYWxTaGFwZSwgb3JpZ2luYWxJbmRpY2VzKTtcbiAgICByZXR1cm4gb3JpZ2luYWxJbmRpY2VzO1xuICB9XG5cbiAgLyoqXG4gICAqIEdpdmVuIHRoZSBpbmRpY2VzIG9mIGEgYnJvYWRjYXN0ZWQgdGVuc29yLCBjYWxjdWxhdGUgdGhlIG9yaWdpbmFsIGluZGljZXNcbiAgICogQHBhcmFtIGJyb2FkY2FzdGVkSW5kaWNlcyBUaGUgZ2l2ZW4gaW5kaWNlcyBvZiB0aGUgYnJvYWRjYXN0ZWQgdGVuc29yLlxuICAgKiBAcGFyYW0gb3JpZ2luYWxTaGFwZSBUaGUgb3JpZ2luYWwgc2hhcGUgb2YgdGhlIHRlbnNvciBiZWZvcmUgYnJvYWRjYXN0XG4gICAqIEBwYXJhbSBvcmlnaW5hbEluZGljZXMgVGhlIG1hcHBpbmcgb2YgYnJvYWRjYXN0ZWRJbmRpY2VzIHRvIHRoZSBvcmlnaW5hbEluZGljZXMgKG91dHB1dCBwYXJhbWV0ZXIgLSB3aWxsIGJlXG4gICAqICAgICBtdXRhdGVkKS5cbiAgICovXG4gIHN0YXRpYyBmaWxsSW5kZXgoYnJvYWRjYXN0ZWRJbmRpY2VzOiByZWFkb25seSBudW1iZXJbXSwgb3JpZ2luYWxTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sIG9yaWdpbmFsSW5kaWNlczogbnVtYmVyW10pIHtcbiAgICAvLyBOT1RFIDE6IHdlIGFzc3VtZSB0aGUgcGFyYW1ldGVyIGJyb2FkY2FzdGVkSW5kaWNlcyBpcyB2YWxpZC4gaWUuIGl0IHNob3VsZCBoYXZlIHRoZSBzYW1lIGxlbmd0aCBhcyB0aGVcbiAgICAvLyBicm9hZGNhc3RlZCBzaGFwZSwgYW5kIGZvciBlYWNoIGRpbWVuc2lvbiB0aGUgaW5kZXggc2hvdWxkIG5vdCBiZSBvdXQgb2YgcmFuZ2UuXG4gICAgLy8gTk9URSAyOiB3ZSBhc3N1bWUgdGhlIHBhcmFtZXRlciBvcmlnaW5hbEluZGljZXMgaGFzIHRoZSBzYW1lIGxlbmd0aCBhcyB0aGUgb3JpZ2luYWxTaGFwZVxuICAgIGNvbnN0IGRpbU9mZnNldCA9IGJyb2FkY2FzdGVkSW5kaWNlcy5sZW5ndGggLSBvcmlnaW5hbFNoYXBlLmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9yaWdpbmFsU2hhcGUubGVuZ3RoOyBpKyspIHtcbiAgICAgIG9yaWdpbmFsSW5kaWNlc1tpXSA9IGJyb2FkY2FzdGVkSW5kaWNlc1tkaW1PZmZzZXQgKyBpXSAlIG9yaWdpbmFsU2hhcGVbaV07XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFBlcmZvcm0gdGhlIGJyb2FkY2FzdGluZyBvcGVyYXRpb24gb24gdGhlIHNwZWNpZmljIG9wZXJhdG9yXG4gICAqIEBwYXJhbSBhIFRoZSBpbnB1dCB0ZW5zb3IgQVxuICAgKiBAcGFyYW0gYiBUaGUgaW5wdXQgdGVuc29yIEJcbiAgICogQHBhcmFtIG9wIFRoZSBvcGVyYXRvciBsYW1iZGEgZnVuY3Rpb25cbiAgICogQHBhcmFtIGlucGxhY2UgV2hldGhlciB0byB3cml0ZSB0aGUgcmVzdWx0IGJhY2sgdG8gQS5cbiAgICogQHJldHVybnMgVGhlIHJlc3VsdCB0ZW5zb3IsIG9yIHVuZGVmaW5lZCBpZiBpbnB1dCBub3QgYnJvYWRjYXN0YWJsZS5cbiAgICovXG4gIHN0YXRpYyBjYWxjKFxuICAgICAgYTogVGVuc29yLCBiOiBUZW5zb3IsIG9wOiAoYTogc3RyaW5nfG51bWJlciwgYjogc3RyaW5nfG51bWJlcikgPT4gKHN0cmluZyB8IG51bWJlciksIGlucGxhY2U6IGJvb2xlYW4sXG4gICAgICByZXN1bHRUeXBlPzogVGVuc29yLkRhdGFUeXBlKTogVGVuc29yfHVuZGVmaW5lZCB7XG4gICAgY29uc3Qgb3V0cHV0U2hhcGUgPSBCcm9hZGNhc3RVdGlsLmNhbGNTaGFwZShhLmRpbXMsIGIuZGltcyk7XG5cbiAgICBpZiAob3V0cHV0U2hhcGUpIHtcbiAgICAgIGlmIChpbnBsYWNlICYmICFTaGFwZVV0aWwuYXJlRXF1YWwob3V0cHV0U2hhcGUsIGEuZGltcykpIHtcbiAgICAgICAgLy8gQiBpcyBub3QgYnJvYWRjYXN0YWJsZSB0byBBLCBmYWlsZWQgdG8gY2FsY3VsYXRlIGlucGxhY2UuXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHNpemUgPSBTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSk7XG4gICAgICBjb25zdCBjID0gaW5wbGFjZSA/IGEgOiBuZXcgVGVuc29yKG91dHB1dFNoYXBlLCByZXN1bHRUeXBlIHx8IGEudHlwZSk7XG5cbiAgICAgIC8vIGJvdGggaW5wdXRzIGFyZSBzY2FsYXJzXG4gICAgICBpZiAob3V0cHV0U2hhcGUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGMuc2V0KFtdLCBvcChhLmdldChbXSkgYXMgbnVtYmVyLCBiLmdldChbXSkgYXMgbnVtYmVyKSk7XG4gICAgICB9XG5cbiAgICAgIC8vIGF0bGVhc3Qgb25lIGlucHV0IGlzIGEgbm9uLXNjYWxhclxuICAgICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IG91dHB1dEluZGljZXMgPSBuZXcgQXJyYXk8bnVtYmVyPihvdXRwdXRTaGFwZS5sZW5ndGgpO1xuICAgICAgICBjb25zdCBvcmlnaW5hbEluZGljZXNBID0gbmV3IEFycmF5KGEuZGltcy5sZW5ndGgpO1xuICAgICAgICBjb25zdCBvcmlnaW5hbEluZGljZXNCID0gbmV3IEFycmF5KGIuZGltcy5sZW5ndGgpO1xuICAgICAgICBsZXQgdmFsQTogc3RyaW5nfG51bWJlciA9IDA7XG4gICAgICAgIGxldCB2YWxCOiBzdHJpbmd8bnVtYmVyID0gMDtcbiAgICAgICAgbGV0IGlzQVNjYWxhciA9IGZhbHNlO1xuICAgICAgICBsZXQgaXNCU2NhbGFyID0gZmFsc2U7XG4gICAgICAgIGlmIChhLmRpbXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdmFsQSA9IGEuZ2V0KFtdKSBhcyBudW1iZXI7XG4gICAgICAgICAgaXNBU2NhbGFyID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYi5kaW1zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHZhbEIgPSBiLmdldChbXSkgYXMgbnVtYmVyO1xuICAgICAgICAgIGlzQlNjYWxhciA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3Q6IG51bWJlcjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgICAgICAvLyB0cmF2ZXJzYWwgaW5kaWNlc1xuICAgICAgICAgIHJlc3QgPSBpO1xuICAgICAgICAgIGZvciAobGV0IGogPSBvdXRwdXRTaGFwZS5sZW5ndGggLSAxOyBqID49IDA7IGotLSkge1xuICAgICAgICAgICAgb3V0cHV0SW5kaWNlc1tqXSA9IHJlc3QgJSBvdXRwdXRTaGFwZVtqXTtcbiAgICAgICAgICAgIHJlc3QgPSBNYXRoLmZsb29yKHJlc3QgLyBvdXRwdXRTaGFwZVtqXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFpc0FTY2FsYXIpIHtcbiAgICAgICAgICAgIC8vIG1hcCBvdXRwdXRJbmRpY2VzICh3aGljaCBpcyBhY3R1YWxseSBicm9hZGNhc3RlZCkgdG8gdGhlIG9yaWdpbmFsSW5kaWNlc1xuICAgICAgICAgICAgQnJvYWRjYXN0VXRpbC5maWxsSW5kZXgob3V0cHV0SW5kaWNlcywgYS5kaW1zLCBvcmlnaW5hbEluZGljZXNBKTtcbiAgICAgICAgICAgIHZhbEEgPSBhLmdldChvcmlnaW5hbEluZGljZXNBKSBhcyBudW1iZXI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghaXNCU2NhbGFyKSB7XG4gICAgICAgICAgICBCcm9hZGNhc3RVdGlsLmZpbGxJbmRleChvdXRwdXRJbmRpY2VzLCBiLmRpbXMsIG9yaWdpbmFsSW5kaWNlc0IpO1xuICAgICAgICAgICAgdmFsQiA9IGIuZ2V0KG9yaWdpbmFsSW5kaWNlc0IpIGFzIG51bWJlcjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjLnNldChvdXRwdXRJbmRpY2VzLCBvcCh2YWxBLCB2YWxCKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgaWYgYSBzaGFwZSBpcyB1bmlkaXJlY3Rpb25hbCBicm9hZGNhc3RhYmxlIHRvIGFub3RoZXIgc2hhcGVcbiAgICogQHBhcmFtIHNoYXBlIFRoZSBpbnB1dCBzaGFwZVxuICAgKiBAcGFyYW0gZmluYWxTaGFwZSBUaGUgZGVzaXJlZCBzaGFwZSBhZnRlciBicm9hZGNhc3RpbmdcbiAgICovXG4gIHN0YXRpYyBpc1ZhbGlkQnJvYWRjYXN0KHNoYXBlOiByZWFkb25seSBudW1iZXJbXSwgZmluYWxTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10pOiBib29sZWFuIHtcbiAgICAvLyBhbGlnbiBzaGFwZSB0byB0aGUgcmlnaHRcbiAgICBjb25zdCBpbnB1dFJhbmsgPSBzaGFwZS5sZW5ndGg7XG4gICAgY29uc3QgZmluYWxSYW5rID0gZmluYWxTaGFwZS5sZW5ndGg7XG4gICAgaWYgKGlucHV0UmFuayA+IGZpbmFsUmFuaykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMTsgaSA8PSBpbnB1dFJhbms7IGkrKykge1xuICAgICAgaWYgKHNoYXBlW2lucHV0UmFuayAtIGldICE9PSAxICYmIHNoYXBlW2lucHV0UmFuayAtIGldICE9PSBmaW5hbFNoYXBlW2ZpbmFsUmFuayAtIGldKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogRGV0ZXJtaW5lIHRoZSBicm9hZGNhc3RlZCBkaW1zIGluIGlucHV0IHNoYXBlIGJhc2VkIG9uIHRoZSBnaXZlbiBvdXRwdXQgc2hhcGUuXG4gICAqIE5vdGUgdGhhdCB0aGlzIGZ1bmN0aW9uIG9ubHkgcmV0dXJucyB0aGUgYnJvYWRjYXN0ZWQgZGltcy5cbiAgICogQHBhcmFtIGlucHV0U2hhcGUgVGhlIGlucHV0IHNoYXBlXG4gICAqIEBwYXJhbSBvdXRwdXRTaGFwZSBUaGUgb3V0cHV0IHNoYXBlXG4gICAqIEByZXR1cm5zIFRoZSBicm9hZGNhc3RlZCBkaW1zIGluIGlucHV0IHNoYXBlLlxuICAgKi9cbiAgc3RhdGljIGdldEJyb2FkY2FzdERpbXMoaW5wdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sIG91dHB1dFNoYXBlOiByZWFkb25seSBudW1iZXJbXSk6IG51bWJlcltdIHtcbiAgICBjb25zdCBpblJhbmsgPSBpbnB1dFNoYXBlLmxlbmd0aDtcbiAgICBjb25zdCBkaW1zOiBudW1iZXJbXSA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5SYW5rOyBpKyspIHtcbiAgICAgIGNvbnN0IGRpbSA9IGluUmFuayAtIDEgLSBpO1xuICAgICAgY29uc3QgYSA9IGlucHV0U2hhcGVbZGltXSB8fCAxO1xuICAgICAgY29uc3QgYiA9IG91dHB1dFNoYXBlW291dHB1dFNoYXBlLmxlbmd0aCAtIDEgLSBpXSB8fCAxO1xuICAgICAgaWYgKGIgPiAxICYmIGEgPT09IDEpIHtcbiAgICAgICAgZGltcy51bnNoaWZ0KGRpbSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkaW1zO1xuICB9XG59XG5cbi8vIGNvcHkgYXJyYXkgaGVscGVyXG4vLyBtaW1pY3MgbWVtY3B5IGFzIG11Y2ggYXMgcG9zc2libGVcbmV4cG9ydCBmdW5jdGlvbiBhcnJheUNvcHlIZWxwZXIoXG4gICAgdGFyZ2V0OiBudW1iZXJbXXxUZW5zb3IuTnVtYmVyVHlwZSwgc291cmNlOiBudW1iZXJbXXxUZW5zb3IuTnVtYmVyVHlwZSwgdGFyZ2V0SW5kZXg6IG51bWJlciwgc291cmNlSW5kZXg6IG51bWJlcixcbiAgICBibG9ja1NpemU6IG51bWJlcikge1xuICBpZiAoc291cmNlSW5kZXggPCAwIHx8IHNvdXJjZUluZGV4ID49IHNvdXJjZS5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NvdXJjZUluZGV4IG91dCBvZiBib3VuZHMnKTtcbiAgfVxuICBpZiAodGFyZ2V0SW5kZXggPCAwIHx8IHRhcmdldEluZGV4ID49IHRhcmdldC5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3RhcmdldEluZGV4IG91dCBvZiBib3VuZHMnKTtcbiAgfVxuICBpZiAoc291cmNlSW5kZXggKyBibG9ja1NpemUgPiBzb3VyY2UubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzb3VyY2UgaW5kaWNlcyB0byBiZSBjb3BpZWQgYXJlIG91dHNpZGUgYm91bmRzJyk7XG4gIH1cbiAgaWYgKHRhcmdldEluZGV4ICsgYmxvY2tTaXplID4gdGFyZ2V0Lmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcigndGFyZ2V0IGFycmF5IGlzIHRvbyBzbWFsbCB0byBob2xkIHJlc3VsdCcpO1xuICB9XG5cbiAgZm9yIChsZXQgb2Zmc2V0ID0gMDsgb2Zmc2V0IDwgYmxvY2tTaXplOyBvZmZzZXQrKykge1xuICAgIHRhcmdldFt0YXJnZXRJbmRleCArIG9mZnNldF0gPSBzb3VyY2Vbc291cmNlSW5kZXggKyBvZmZzZXRdO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBHZW1tVXRpbCB7XG4gIC8vIHdpbGwgbWFrZSBzdXJlIGlucHV0IHNoYXBlcyBhcmUgY29tcGF0aWJsZSBmb3IgdGhpcyBvcFxuICAvLyBhbmQgcmV0dXJuIGJhY2sgdGhlIHNoYXBlIG9mIHRoZSBvdXRwdXQgaW4gdGhlIGZvcm0gb2YgYSB0dXBsZVxuICAvLyB3aWxsIHRocm93IGV4Y2VwdGlvbiBpZiB0aGUgaW5wdXQgc2hhcGVzIGFyZSBub3QgY29tcGF0aWJsZVxuICBzdGF0aWMgZ2V0U2hhcGVPZkdlbW1SZXN1bHQoXG4gICAgICBsZWZ0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLCB0cmFuc0xlZnQ6IGJvb2xlYW4sIHJpZ2h0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLCB0cmFuc1JpZ2h0OiBib29sZWFuLFxuICAgICAgYmlhc1NoYXBlPzogcmVhZG9ubHkgbnVtYmVyW10pOiByZWFkb25seSBudW1iZXJbXSB7XG4gICAgaWYgKGxlZnRTaGFwZS5sZW5ndGggIT09IDIgfHwgcmlnaHRTaGFwZS5sZW5ndGggIT09IDIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignc2hhcGUgbmVlZCB0byBiZSBvZiBzaXplIDInKTtcbiAgICB9XG5cbiAgICBsZXQgTTogbnVtYmVyO1xuICAgIGxldCBLOiBudW1iZXI7XG4gICAgbGV0IE46IG51bWJlcjtcblxuICAgIGlmICh0cmFuc0xlZnQpIHtcbiAgICAgIE0gPSBsZWZ0U2hhcGVbMV07XG4gICAgICBLID0gbGVmdFNoYXBlWzBdO1xuICAgIH0gZWxzZSB7XG4gICAgICBNID0gbGVmdFNoYXBlWzBdO1xuICAgICAgSyA9IGxlZnRTaGFwZVsxXTtcbiAgICB9XG5cbiAgICBsZXQga0RpbSA9IC0xO1xuXG4gICAgaWYgKHRyYW5zUmlnaHQpIHtcbiAgICAgIE4gPSByaWdodFNoYXBlWzBdO1xuICAgICAga0RpbSA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIE4gPSByaWdodFNoYXBlWzFdO1xuICAgICAga0RpbSA9IDA7XG4gICAgfVxuXG4gICAgaWYgKHJpZ2h0U2hhcGVba0RpbV0gIT09IEspIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZGltZW5zaW9uIG1pc21hdGNoJyk7XG4gICAgfVxuXG4gICAgaWYgKE0gPD0gMCB8fCBOIDw9IDAgfHwgSyA8PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgc2hhcGUgc3BlY2lmaWVkJyk7XG4gICAgfVxuXG4gICAgaWYgKGJpYXNTaGFwZSAmJiAhQnJvYWRjYXN0VXRpbC5pc1ZhbGlkQnJvYWRjYXN0KGJpYXNTaGFwZSwgW00sIE5dKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdnZW1tOiBpbnZhbGlkIGJpYXMgc2hhcGUgZm9yIGJyb2FkY2FzdCcpO1xuICAgIH1cblxuICAgIHJldHVybiBbTSwgTiwgS107XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFByb3RvVXRpbCB7XG4gIHN0YXRpYyB0ZW5zb3JEYXRhVHlwZUZyb21Qcm90byh0eXBlUHJvdG86IG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGV8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlRlbnNvckRhdGFUeXBlKTogVGVuc29yLkRhdGFUeXBlIHtcbiAgICBzd2l0Y2ggKHR5cGVQcm90bykge1xuICAgICAgY2FzZSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLklOVDg6XG4gICAgICAgIHJldHVybiAnaW50OCc7XG4gICAgICBjYXNlIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDg6XG4gICAgICAgIHJldHVybiAndWludDgnO1xuICAgICAgY2FzZSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLkJPT0w6XG4gICAgICAgIHJldHVybiAnYm9vbCc7XG4gICAgICBjYXNlIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuSU5UMTY6XG4gICAgICAgIHJldHVybiAnaW50MTYnO1xuICAgICAgY2FzZSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQxNjpcbiAgICAgICAgcmV0dXJuICd1aW50MTYnO1xuICAgICAgY2FzZSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLklOVDMyOlxuICAgICAgICByZXR1cm4gJ2ludDMyJztcbiAgICAgIGNhc2Ugb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5VSU5UMzI6XG4gICAgICAgIHJldHVybiAndWludDMyJztcbiAgICAgIGNhc2Ugb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5GTE9BVDpcbiAgICAgICAgcmV0dXJuICdmbG9hdDMyJztcbiAgICAgIGNhc2Ugb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5ET1VCTEU6XG4gICAgICAgIHJldHVybiAnZmxvYXQ2NCc7XG4gICAgICBjYXNlIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuU1RSSU5HOlxuICAgICAgICByZXR1cm4gJ3N0cmluZyc7XG5cbiAgICAgIC8vIEZvciBJTlQ2NC9VSU5UNjQsIHJlZHVjZSB0aGVpciB2YWx1ZSB0byAzMi1iaXRzLlxuICAgICAgLy8gU2hvdWxkIHRocm93IGV4Y2VwdGlvbiB3aGVuIG92ZXJmbG93XG4gICAgICBjYXNlIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuSU5UNjQ6XG4gICAgICAgIHJldHVybiAnaW50MzInO1xuICAgICAgY2FzZSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQ2NDpcbiAgICAgICAgcmV0dXJuICd1aW50MzInO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGRhdGEgdHlwZTogJHtvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlW3R5cGVQcm90b119YCk7XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIHRlbnNvckRhdGFUeXBlU3RyaW5nVG9FbnVtKHR5cGU6IHN0cmluZyk6IG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnaW50OCc6XG4gICAgICAgIHJldHVybiBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLklOVDg7XG4gICAgICBjYXNlICd1aW50OCc6XG4gICAgICAgIHJldHVybiBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQ4O1xuICAgICAgY2FzZSAnYm9vbCc6XG4gICAgICAgIHJldHVybiBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLkJPT0w7XG4gICAgICBjYXNlICdpbnQxNic6XG4gICAgICAgIHJldHVybiBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLklOVDE2O1xuICAgICAgY2FzZSAndWludDE2JzpcbiAgICAgICAgcmV0dXJuIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDE2O1xuICAgICAgY2FzZSAnaW50MzInOlxuICAgICAgICByZXR1cm4gb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5JTlQzMjtcbiAgICAgIGNhc2UgJ3VpbnQzMic6XG4gICAgICAgIHJldHVybiBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQzMjtcbiAgICAgIGNhc2UgJ2Zsb2F0MzInOlxuICAgICAgICByZXR1cm4gb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5GTE9BVDtcbiAgICAgIGNhc2UgJ2Zsb2F0NjQnOlxuICAgICAgICByZXR1cm4gb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5ET1VCTEU7XG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICByZXR1cm4gb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5TVFJJTkc7XG4gICAgICBjYXNlICdpbnQ2NCc6XG4gICAgICAgIHJldHVybiBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLklOVDY0O1xuICAgICAgY2FzZSAndWludDY0JzpcbiAgICAgICAgcmV0dXJuIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDY0O1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGRhdGEgdHlwZTogJHt0eXBlfWApO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyB0ZW5zb3JEaW1zRnJvbVByb3RvKGRpbXM6IEFycmF5PG51bWJlcnxMb25nPik6IG51bWJlcltdIHtcbiAgICAvLyBnZXQgcmlkIG9mIExvbmcgdHlwZSBmb3IgZGltc1xuICAgIHJldHVybiBkaW1zLm1hcChkID0+IExvbmcuaXNMb25nKGQpID8gZC50b051bWJlcigpIDogZCk7XG4gIH1cblxuICBzdGF0aWMgdGVuc29yVmFsdWVUeXBlRnJvbVByb3RvKHZhbHVlVHlwZTogb25ueC5UeXBlUHJvdG8uSVRlbnNvcik6IEdyYXBoLlZhbHVlVHlwZSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRlbnNvclR5cGU6IFByb3RvVXRpbC50ZW5zb3JEYXRhVHlwZUZyb21Qcm90byh2YWx1ZVR5cGUuZWxlbVR5cGUhKSxcbiAgICAgIHNoYXBlOiB7ZGltczogUHJvdG9VdGlsLnRlbnNvckRpbXNGcm9tUHJvdG8odmFsdWVUeXBlLnNoYXBlIS5kaW0hLm1hcChkID0+IGQuZGltVmFsdWUhKSl9XG4gICAgfTtcbiAgfVxuXG4gIHN0YXRpYyB0ZW5zb3JEaW1zRnJvbU9SVEZvcm1hdCh0ZW5zb3I6IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yKSB7XG4gICAgY29uc3QgZGltcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGVuc29yLmRpbXNMZW5ndGgoKTsgaSsrKSB7XG4gICAgICBkaW1zLnB1c2goTG9uZ1V0aWwubG9uZ1RvTnVtYmVyKHRlbnNvci5kaW1zKGkpISkpO1xuICAgIH1cbiAgICByZXR1cm4gZGltcztcbiAgfVxuXG4gIHN0YXRpYyB0ZW5zb3JBdHRyaWJ1dGVzRnJvbU9SVEZvcm1hdChub2RlOiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLk5vZGUpIHtcbiAgICBjb25zdCBhdHRyaWJ1dGVzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLmF0dHJpYnV0ZXNMZW5ndGgoKTsgaSsrKSB7XG4gICAgICBhdHRyaWJ1dGVzLnB1c2gobm9kZS5hdHRyaWJ1dGVzKGkpISk7XG4gICAgfVxuICAgIHJldHVybiBhdHRyaWJ1dGVzO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBMb25nVXRpbCB7XG4gIC8vIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHRvIGdldCBhIG51bWJlciBmcm9tIGxvbmcgdHlwZSBvZiBkYXRhIGZvciBhdHRyaWJ1dGUsIGRpbSwgYW5kIGlyIHZlcnNpb24sXG4gIC8vIHdoaWNoIHZhbHVlcyBhcmUgc2lnbmVkIGludGVnZXJzLlxuICAvLyBUbyBtYWtlIGl0IG1vcmUgZ2VuZXJpYywgYWRkIGFuIG9wdGlvbmFsIHBhcmFtdGVyIHRvIGNvbnZlcnQgdG8gYSB1bnNpZ25lZCBudW1iZXIuXG4gIHN0YXRpYyBsb25nVG9OdW1iZXIobjogTG9uZ3xmbGF0YnVmZmVycy5Mb25nfG51bWJlciwgdW5zaWduZWQ/OiBib29sZWFuKSB7XG4gICAgaWYgKExvbmcuaXNMb25nKG4pKSB7XG4gICAgICByZXR1cm4gbi50b051bWJlcigpO1xuICAgIH0gZWxzZSBpZiAobiBpbnN0YW5jZW9mIGZsYXRidWZmZXJzLkxvbmcpIHtcbiAgICAgIHJldHVybiBMb25nLmZyb21WYWx1ZSh7bG93OiBuLmxvdywgaGlnaDogbi5oaWdoLCB1bnNpZ25lZDogdW5zaWduZWQgPz8gZmFsc2V9KS50b051bWJlcigpO1xuICAgIH1cbiAgICByZXR1cm4gbjtcbiAgfVxuICBzdGF0aWMgaXNMb25nKG46IHVua25vd24pIHtcbiAgICByZXR1cm4gTG9uZy5pc0xvbmcobikgfHwgbiBpbnN0YW5jZW9mIGZsYXRidWZmZXJzLkxvbmc7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFNoYXBlVXRpbCB7XG4gIHN0YXRpYyBzaXplKGRpbXM6IHJlYWRvbmx5IG51bWJlcltdKTogbnVtYmVyIHtcbiAgICByZXR1cm4gU2hhcGVVdGlsLmdldFNpemVGcm9tRGltZW5zaW9uUmFuZ2UoZGltcywgMCwgZGltcy5sZW5ndGgpO1xuICB9XG5cbiAgLy8gYGF4aXNgIGluY2x1c2l2ZVxuICBzdGF0aWMgc2l6ZUZyb21EaW1lbnNpb24oZGltczogcmVhZG9ubHkgbnVtYmVyW10sIGF4aXM6IG51bWJlcik6IG51bWJlciB7XG4gICAgaWYgKGF4aXMgPCAwIHx8IGF4aXMgPiBkaW1zLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGRpbWVuc2lvbiBvZiAke2F4aXN9IGZvciBzaXplRnJvbURpbWVuc2lvbiBhcyBUZW5zb3IgaGFzICR7ZGltcy5sZW5ndGh9IGRpbWVuc2lvbnMuYCk7XG4gICAgfVxuICAgIHJldHVybiBTaGFwZVV0aWwuZ2V0U2l6ZUZyb21EaW1lbnNpb25SYW5nZShkaW1zLCBheGlzLCBkaW1zLmxlbmd0aCk7XG4gIH1cblxuICAvLyBgYXhpc2AgZXhjbHVzaXZlXG4gIHN0YXRpYyBzaXplVG9EaW1lbnNpb24oZGltczogcmVhZG9ubHkgbnVtYmVyW10sIGF4aXM6IG51bWJlcik6IG51bWJlciB7XG4gICAgaWYgKGF4aXMgPCAwIHx8IGF4aXMgPiBkaW1zLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGRpbWVuc2lvbiBvZiAke2F4aXN9IGZvciBzaXplVG9EaW1lbnNpb24gYXMgVGVuc29yIGhhcyAke2RpbXMubGVuZ3RofSBkaW1lbnNpb25zLmApO1xuICAgIH1cbiAgICByZXR1cm4gU2hhcGVVdGlsLmdldFNpemVGcm9tRGltZW5zaW9uUmFuZ2UoZGltcywgMCwgYXhpcyk7XG4gIH1cblxuICBzdGF0aWMgZ2V0U2l6ZUZyb21EaW1lbnNpb25SYW5nZShkaW1zOiByZWFkb25seSBudW1iZXJbXSwgc3RhcnQ6IG51bWJlciwgZW5kOiBudW1iZXIpOiBudW1iZXIge1xuICAgIGxldCBzaXplID0gMTtcbiAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgLy8gc2FmZXR5IGNoZWNrIGFzIHRoaXMgbWV0aG9kIGlzIGNhbGxlZCBieSBtdWx0aXBsZSBvdGhlciBtZXRob2RzIHJlcXVpcmluZyBzaXplLlxuICAgICAgLy8gc2l6ZSBjYW5ub3QgYmUgMCBvciBuZWdhdGl2ZS5cbiAgICAgIGlmIChkaW1zW2ldIDw9IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1sZW5cbiAgICAgICAgICAgICdjYW5ub3QgZ2V0IHZhbGlkIHNpemUgZnJvbSBzcGVjaWZpZWQgZGltZW5zaW9uIHJhbmdlLiBNb3N0IGxpa2VseSB0aGUgcmFuZ2UgY29udGFpbnMgMCBvciBuZWdhdGl2ZSB2YWx1ZXMgaW4gdGhlbS4nKTtcbiAgICAgIH1cbiAgICAgIHNpemUgKj0gZGltc1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIHNpemU7XG4gIH1cblxuICBzdGF0aWMgY29tcHV0ZVN0cmlkZXMoZGltczogcmVhZG9ubHkgbnVtYmVyW10pOiByZWFkb25seSBudW1iZXJbXSB7XG4gICAgY29uc3QgcmFuayA9IGRpbXMubGVuZ3RoO1xuICAgIGlmIChyYW5rID09PSAwKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfSBlbHNlIGlmIChyYW5rID09PSAxKSB7XG4gICAgICByZXR1cm4gWzFdO1xuICAgIH1cbiAgICBjb25zdCBzdHJpZGVzID0gbmV3IEFycmF5KHJhbmspO1xuICAgIHN0cmlkZXNbcmFuayAtIDFdID0gMTtcbiAgICBzdHJpZGVzW3JhbmsgLSAyXSA9IGRpbXNbcmFuayAtIDFdO1xuICAgIGZvciAobGV0IGkgPSByYW5rIC0gMzsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHN0cmlkZXNbaV0gPSBzdHJpZGVzW2kgKyAxXSAqIGRpbXNbaSArIDFdO1xuICAgIH1cbiAgICByZXR1cm4gc3RyaWRlcztcbiAgfVxuXG4gIHN0YXRpYyB0cmFuc3Bvc2UoZGltczogcmVhZG9ubHkgbnVtYmVyW10pOiByZWFkb25seSBudW1iZXJbXSB7XG4gICAgY29uc3QgY29weSA9IGRpbXMuc2xpY2UoKTtcbiAgICByZXR1cm4gY29weS5yZXZlcnNlKCk7XG4gIH1cblxuICBzdGF0aWMgaW5kaWNlc1RvT2Zmc2V0KGluZGljZXM6IHJlYWRvbmx5IG51bWJlcltdLCBzdHJpZGVzOiByZWFkb25seSBudW1iZXJbXSwgYXhpcz86IG51bWJlcik6IG51bWJlciB7XG4gICAgaWYgKGF4aXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgYXhpcyA9IGluZGljZXMubGVuZ3RoO1xuICAgIH1cbiAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGF4aXM7ICsraSkge1xuICAgICAgb2Zmc2V0ICs9IHN0cmlkZXNbaV0gKiBpbmRpY2VzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gb2Zmc2V0O1xuICB9XG5cbiAgc3RhdGljIG9mZnNldFRvSW5kaWNlcyhvZmZzZXQ6IG51bWJlciwgc3RyaWRlczogcmVhZG9ubHkgbnVtYmVyW10pOiByZWFkb25seSBudW1iZXJbXSB7XG4gICAgY29uc3QgcmFuayA9IHN0cmlkZXMubGVuZ3RoO1xuICAgIGlmIChyYW5rID09PSAwKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfSBlbHNlIGlmIChyYW5rID09PSAxKSB7XG4gICAgICByZXR1cm4gW29mZnNldCAqIHN0cmlkZXNbMF1dO1xuICAgIH1cbiAgICBjb25zdCBpbmRpY2VzOiBudW1iZXJbXSA9IG5ldyBBcnJheShzdHJpZGVzLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbmRpY2VzLmxlbmd0aCAtIDE7ICsraSkge1xuICAgICAgaW5kaWNlc1tpXSA9IE1hdGguZmxvb3Iob2Zmc2V0IC8gc3RyaWRlc1tpXSk7XG4gICAgICBvZmZzZXQgLT0gaW5kaWNlc1tpXSAqIHN0cmlkZXNbaV07XG4gICAgfVxuICAgIGluZGljZXNbaW5kaWNlcy5sZW5ndGggLSAxXSA9IG9mZnNldDtcbiAgICByZXR1cm4gaW5kaWNlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBub3JtYWlsemUgYXhpcyBvZiByYW5nZSBbLXIsIHIpIGludG8gWzAsIHIpLlxuICAgKi9cbiAgc3RhdGljIG5vcm1hbGl6ZUF4aXMoYXhpczogbnVtYmVyLCB0ZW5zb3JSYW5rOiBudW1iZXIpOiBudW1iZXIge1xuICAgIGlmIChheGlzIDwgLXRlbnNvclJhbmsgJiYgYXhpcyA+PSB0ZW5zb3JSYW5rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vuc3VwcG9ydGVkIGF4aXMgZm9yIHRoaXMgb3BlcmF0aW9uLicpO1xuICAgIH1cbiAgICByZXR1cm4gYXhpcyA8IDAgPyBheGlzICsgdGVuc29yUmFuayA6IGF4aXM7XG4gIH1cblxuICBzdGF0aWMgbm9ybWFsaXplQXhlcyhheGVzOiByZWFkb25seSBudW1iZXJbXSwgdGVuc29yUmFuazogbnVtYmVyKTogbnVtYmVyW10ge1xuICAgIHJldHVybiBheGVzLm1hcCh4ID0+IHRoaXMubm9ybWFsaXplQXhpcyh4LCB0ZW5zb3JSYW5rKSk7XG4gIH1cblxuICAvLyBJbmNyZW1lbnQgYW4gaW5kZXggaW50byBhIHRlbnNvciAoaW4gbGV4aWNvZ3JhcGhpY1xuICAvLyBvcmRlcmluZyksIHdyYXBwaW5nIGFyb3VuZCB0aGUgc3BlY2lmaWVkIHVwcGVyX2JvdW5kLlxuICAvKipcbiAgICogSW5jcmVtZW50IGFuIGluZGV4IGludG8gYSB0ZW5zb3IgKGluIGxleGljb2dyYXBoaWMgb3JkZXJpbmcpLCB3cmFwcGluZyBhcm91bmQgdGhlIHNwZWNpZmllZCB1cHBlcl9ib3VuZC5cbiAgICogQHBhcmFtIGluZGV4IEdpdmVuIGluZGV4IHRvIGluY3JlbWVudCAoV2lsbCBiZSBtdXRhdGVkKVxuICAgKiBAcGFyYW0gZGltcyBUaGUgZGltZW5zaW9ucyBvZiB0aGUgdGVuc29yIGZvciB3aGljaCB0aGUgZ2l2ZW4gaW5kZXggY29ycmVzcG9uZHMgdG9cbiAgICogQHBhcmFtIGF4aXNUb0luY3JlbWVudE9uIFRoZSAxLWluZGV4ZWQgYXhpcyB0byBpbmNyZW1lbnQgb24uIElmIHVuZGVmaW5lZCwgYXhpc1RvSW5jcmVtZW50T24gPT0gcmFua1xuICAgKi9cbiAgc3RhdGljIGluY3JlbWVudEluZGV4KGluZGV4OiBudW1iZXJbXSwgZGltczogcmVhZG9ubHkgbnVtYmVyW10sIGF4aXNUb0luY3JlbWVudE9uPzogbnVtYmVyKSB7XG4gICAgaWYgKGRpbXMubGVuZ3RoID09PSAwIHx8IGluZGV4Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbmRleCBpbmNyZW1lbnRpbmcgdW5zdXBwb3J0ZWQgZm9yIHNjYWxhciBUZW5zb3InKTtcbiAgICB9XG4gICAgaWYgKGF4aXNUb0luY3JlbWVudE9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGF4aXNUb0luY3JlbWVudE9uID0gZGltcy5sZW5ndGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChheGlzVG9JbmNyZW1lbnRPbiA8PSAwIHx8IGF4aXNUb0luY3JlbWVudE9uID4gZGltcy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbmNvcnJlY3QgYXhpcyB0byBpbmNyZW1lbnQgb24nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGxldCBrID0gYXhpc1RvSW5jcmVtZW50T24gLSAxOyBrID49IDA7IC0taykge1xuICAgICAgaW5kZXhba10rKztcbiAgICAgIGlmIChpbmRleFtrXSA8IGRpbXNba10pIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpbmRleFtrXSA9IDA7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFByb2R1Y2VzIGEgbmV3IGRpbWVuc2lvbnMgYXJyYXkgYmFzZWQgb24gdGhlIHZhbHVlcyBpbiB0aGUgJ29yaWdpbmFsRGltZW5zaW9ucycgYW5kICdzaGFwZScgYXJyYXlcbiAgICogVXNlZCBpbiBSZXNoYXBlXG4gICAqIEBwYXJhbSBvcmlnaW5hbERpbXMgT3JpZ2luYWwgU2hhcGUgYXJyYXlcbiAgICogQHBhcmFtIHNoYXBlSGludHMgYXJyYXkgY29udGFpbmluZyB2YWx1ZXMgdG8gY29tcHV0ZSB0aGUgbmV3IGRpbWVuc2lvbnNcbiAgICogRm9yIGV4YW1wbGU6XG4gICAqIG9yaWdpbmFsRGltcyA9IFsyLDJdIGFuZCBzaGFwZUhpbnRzID0gWzAsLTFdIHdpbGwgcmV0dXJuIFsyLDJdXG4gICAqIG9yaWdpbmFsRGltcyA9IFsyLDJdIGFuZCBzaGFwZUhpbnRzID0gWzRdIHdpbGwgcmV0dXJuIFs0XVxuICAgKiBvcmlnaW5hbERpbXMgPSBbMiwyXSBhbmQgc2hhcGVIaW50cyA9IFs1XSB3aWxsIHRocm93IGFuIGV4Y2VwdGlvblxuICAgKiBodHRwczovL2dpdGh1Yi5jb20vb25ueC9vbm54L2Jsb2IvbWFpbi9kb2NzL09wZXJhdG9ycy5tZCNSZXNoYXBlXG4gICAqL1xuXG4gIHN0YXRpYyBjYWxjdWxhdGVSZXNoYXBlZERpbXMob3JpZ2luYWxEaW1zOiByZWFkb25seSBudW1iZXJbXSwgc2hhcGVIaW50czogQXJyYXlMaWtlPG51bWJlcj4pOiBudW1iZXJbXSB7XG4gICAgLy8gcmVzaGFwZSB0byBhIFNjYWxhciBUZW5zb3JcbiAgICBpZiAoc2hhcGVIaW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIGlmIChvcmlnaW5hbERpbXMubGVuZ3RoID09PSAwIHx8IFNoYXBlVXRpbC5zaXplKG9yaWdpbmFsRGltcykgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3QgcmVzaGFwZSB0byBhIHNjYWxhciBUZW5zb3InKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBuRGltcyA9IHNoYXBlSGludHMubGVuZ3RoO1xuICAgIGNvbnN0IHJlc2hhcGVkRGltcyA9IG5ldyBBcnJheTxudW1iZXI+KG5EaW1zKTtcbiAgICBsZXQgdW5rbm93bkRpbWVuc2lvbiA9IC0xO1xuICAgIGxldCBuZXdUZW5zb3JTaXplID0gMTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5EaW1zOyBpKyspIHtcbiAgICAgIGlmIChzaGFwZUhpbnRzW2ldIDwgLTEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhIGRpbWVuc2lvbiBpbiBzaGFwZSBoaW50cyBjYW5ub3QgYmUgbGVzcyB0aGFuIC0xJyk7XG4gICAgICB9XG4gICAgICBpZiAoc2hhcGVIaW50c1tpXSA9PT0gLTEpIHtcbiAgICAgICAgaWYgKHVua25vd25EaW1lbnNpb24gIT09IC0xKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhdCBtb3N0IG9uZSBkaW1lbnNpb24gaW4gc2hhcGUgaGludHMgY2FuIGJlIC0xJyk7XG4gICAgICAgIH1cbiAgICAgICAgdW5rbm93bkRpbWVuc2lvbiA9IGk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoc2hhcGVIaW50c1tpXSA9PT0gMCkge1xuICAgICAgICAgIGlmIChpID49IG9yaWdpbmFsRGltcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndGhlIGRpbWVuc2lvbiB3aXRoIHZhbHVlIHplcm8gZXhjZWVkcyB0aGUgZGltZW5zaW9uIHNpemUgb2YgdGhlIGlucHV0IHRlbnNvcicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXNoYXBlZERpbXNbaV0gPSBvcmlnaW5hbERpbXNbaV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzaGFwZWREaW1zW2ldID0gc2hhcGVIaW50c1tpXTtcbiAgICAgICAgfVxuICAgICAgICBuZXdUZW5zb3JTaXplICo9IHJlc2hhcGVkRGltc1tpXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBvbGRUZW5zb3JTaXplID0gU2hhcGVVdGlsLnNpemUob3JpZ2luYWxEaW1zKTtcbiAgICBpZiAodW5rbm93bkRpbWVuc2lvbiAhPT0gLTEpIHtcbiAgICAgIGlmIChvbGRUZW5zb3JTaXplICUgbmV3VGVuc29yU2l6ZSAhPT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHRoZSBpbnB1dCB0ZW5zb3IgY2Fubm90IGJlIHJlc2hhcGVkIHRvIHRoZSByZXF1ZXN0ZWQgc2hhcGUuIElucHV0IHNoYXBlOiBbJHtcbiAgICAgICAgICAgIG9yaWdpbmFsRGltc31dIE91dHB1dCBzaGFwZTogWyR7c2hhcGVIaW50c31dYCk7XG4gICAgICB9XG4gICAgICByZXNoYXBlZERpbXNbdW5rbm93bkRpbWVuc2lvbl0gPSBvbGRUZW5zb3JTaXplIC8gbmV3VGVuc29yU2l6ZTtcbiAgICB9XG4gICAgLy8gdmFsaWRhdGUgc2l6ZXMgZnJvbSBvcmlnaW5hbERpbXMgYW5kIHJlc2hhcGVkRGltcyBtYXRjaFxuICAgIGVsc2Uge1xuICAgICAgaWYgKG5ld1RlbnNvclNpemUgIT09IG9sZFRlbnNvclNpemUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZXNoYXBlZERpbXMgYW5kIG9yaWdpbmFsRGltcyBkb25cXCd0IGhhdmUgbWF0Y2hpbmcgc2l6ZXMnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc2hhcGVkRGltcztcbiAgfVxuXG4gIC8qKlxuICAgKiBTb3J0cyBhIGdpdmVuIGFycmF5IGJhc2VkIG9uIHRoZSBpbmRpY2VzIGluIHRoZSBQZXJtIGFycmF5XG4gICAqIFVzZWQgaW4gVHJhbnNwb3NlXG4gICAqIEBwYXJhbSBhIEFycmF5IHRvIGJlIHNvcnRlZCBzdWNoIGFzIGRpbXMgb3Igc3RyaWRlc1xuICAgKiBAcGFyYW0gcGVybSBQZXJtIGdpdmVuOyBpZiBudWxsIGEgd2lsbCBiZSByZXZlcnNlZFxuICAgKi9cbiAgc3RhdGljIHNvcnRCYXNlZE9uUGVybShhOiByZWFkb25seSBudW1iZXJbXSwgcGVybT86IHJlYWRvbmx5IG51bWJlcltdKTogcmVhZG9ubHkgbnVtYmVyW10ge1xuICAgIGlmIChwZXJtKSB7XG4gICAgICByZXR1cm4gcGVybS5tYXAoKHYpID0+IGFbdl0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYS5zbGljZSgpLnJldmVyc2UoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUGFkcyBhIGdpdmVuIHNoYXBlIGFjY29yZGluZyB0byB0aGUgcGFkZGluZyB2YWx1ZXNcbiAgICogQHBhcmFtIGRpbXMgc2hhcGUgb2YgdGhlIFRlbnNvciB0byBiZSBwYWRkZWRcbiAgICogQHBhcmFtIHBhZCBwYWQgdmFsdWVzXG4gICAqL1xuICBzdGF0aWMgcGFkU2hhcGUoZGltczogcmVhZG9ubHkgbnVtYmVyW10sIHBhZDogcmVhZG9ubHkgbnVtYmVyW10pOiByZWFkb25seSBudW1iZXJbXSB7XG4gICAgY29uc3QgcmFuayA9IGRpbXMubGVuZ3RoO1xuICAgIHJldHVybiBkaW1zLm1hcCgodiwgaSkgPT4gdiArIHBhZFtpXSArIHBhZFtpICsgcmFua10pO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZXMgaWYgdGhlIHR3byBzaGFwZXMgYXJlIGlkZW50aWNhbFxuICAgKiBAcGFyYW0gc2hhcGUxXG4gICAqIEBwYXJhbSBzaGFwZTJcbiAgICovXG4gIHN0YXRpYyBhcmVFcXVhbChzaGFwZTE6IHJlYWRvbmx5IG51bWJlcltdLCBzaGFwZTI6IHJlYWRvbmx5IG51bWJlcltdKTogYm9vbGVhbiB7XG4gICAgaWYgKHNoYXBlMS5sZW5ndGggIT09IHNoYXBlMi5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHNoYXBlMS5ldmVyeSgodiwgaSkgPT4gdiA9PT0gc2hhcGUyW2ldKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZXMgaWYgdGhlIGdpdmVuIGBkaW1zYCBvciBgc2hhcGVgIGlzIHZhbGlkIGluIE9OTlguanMgY29udGV4dCBhbmQgcmV0dXJucyBkYXRhIHNpemVcbiAgICogQHBhcmFtIGRpbXMgLSBpbnB1dCBgZGltc2AgdGhhdCBuZWVkcyB0byBiZSBjaGVja2VkXG4gICAqL1xuICBzdGF0aWMgdmFsaWRhdGVEaW1zQW5kQ2FsY1NpemUoZGltczogcmVhZG9ubHkgbnVtYmVyW10pOiBudW1iZXIge1xuICAgIGlmIChkaW1zLmxlbmd0aCA+IDYpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ09ubHkgcmFuayAwIHRvIDYgaXMgc3VwcG9ydGVkIGZvciB0ZW5zb3Igc2hhcGUuJyk7XG4gICAgfVxuICAgIGxldCBzaXplID0gMTtcbiAgICBmb3IgKGNvbnN0IG4gb2YgZGltcykge1xuICAgICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKG4pKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgc2hhcGU6ICR7bn0gaXMgbm90IGFuIGludGVnZXJgKTtcbiAgICAgIH1cbiAgICAgIGlmIChuIDwgMCB8fCBuID4gMjE0NzQ4MzY0Nykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIHNoYXBlOiBsZW5ndGggJHtufSBpcyBub3QgYWxsb3dlZGApO1xuICAgICAgfVxuICAgICAgc2l6ZSAqPSBuO1xuICAgIH1cbiAgICByZXR1cm4gc2l6ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHRoZSBzaGFwZSBvZiBvdXRwdXQgdGVuc29yIHkgPSBmbGF0dGVuKHgsIGF4aXMpXG4gICAqIEBwYXJhbSBkaW1zIC0gc2hhcGUgb2YgaW5wdXQgdGVuc29yXG4gICAqIEBwYXJhbSBheGlzIC0gZmxhdHRlbiBheGlzLCBpbiB0aGUgcmFuZ2UgWy1yLCByXVxuICAgKi9cbiAgc3RhdGljIGZsYXR0ZW5TaGFwZShkaW1zOiByZWFkb25seSBudW1iZXJbXSwgYXhpczogbnVtYmVyKTogcmVhZG9ubHkgbnVtYmVyW10ge1xuICAgIGlmIChheGlzIDwgMCkge1xuICAgICAgYXhpcyArPSBkaW1zLmxlbmd0aDtcbiAgICB9XG4gICAgY29uc3QgdG90YWwgPSBkaW1zLnJlZHVjZSgoeCwgeSkgPT4geCAqIHksIDEpO1xuICAgIGNvbnN0IHJpZ2h0ID0gZGltcy5zbGljZShheGlzKS5yZWR1Y2UoKHgsIHkpID0+IHggKiB5LCAxKTtcbiAgICBjb25zdCBvdXRwdXREaW1zID0gW3RvdGFsIC8gcmlnaHQsIHJpZ2h0XTtcblxuICAgIHJldHVybiBvdXRwdXREaW1zO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZXMgdGhlIHNoYXBlIG9mIG91dHB1dCB0ZW5zb3IgeSA9IHNxdWVlemUoeCwgYXhlcylcbiAgICogQHBhcmFtIGRpbXMgLSBzaGFwZSBvZiBpbnB1dCB0ZW5zb3JcbiAgICogQHBhcmFtIGF4ZXMgLSBzcXVlZXplIGF4ZXNcbiAgICovXG4gIHN0YXRpYyBzcXVlZXplU2hhcGUoZGltczogcmVhZG9ubHkgbnVtYmVyW10sIGF4ZXM6IHJlYWRvbmx5IG51bWJlcltdKTogcmVhZG9ubHkgbnVtYmVyW10ge1xuICAgIGNvbnN0IG91dHB1dERpbXMgPSBuZXcgQXJyYXk8bnVtYmVyPigpO1xuXG4gICAgLy8gc2FuaXR5IGNoZWNrXG4gICAgYXhlcyA9IFNoYXBlVXRpbC5ub3JtYWxpemVBeGVzKGF4ZXMsIGRpbXMubGVuZ3RoKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGltcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgaW5TcXVlZXplTGlzdCA9IGF4ZXMuaW5kZXhPZihpKSA+PSAwO1xuICAgICAgaWYgKGluU3F1ZWV6ZUxpc3QgJiYgZGltc1tpXSAhPT0gMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NxdWVlemUgYW4gYXhpcyBvZiBzaXplIGRpZmZlcmVudCB0aGFuIDEnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKChheGVzLmxlbmd0aCA9PT0gMCAmJiBkaW1zW2ldID4gMSkgfHwgKGF4ZXMubGVuZ3RoID4gMCAmJiAhaW5TcXVlZXplTGlzdCkpIHtcbiAgICAgICAgb3V0cHV0RGltcy5wdXNoKGRpbXNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvdXRwdXREaW1zO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZXMgdGhlIHNoYXBlIG9mIG91dHB1dCB0ZW5zb3IgeSA9IHVuc3F1ZWV6ZSh4LCBheGVzKVxuICAgKiBAcGFyYW0gZGltcyAtIHNoYXBlIG9mIGlucHV0IHRlbnNvclxuICAgKiBAcGFyYW0gYXhlcyAtIHVuc3F1ZWV6ZSBheGVzXG4gICAqL1xuICBzdGF0aWMgdW5zcXVlZXplU2hhcGUoZGltczogcmVhZG9ubHkgbnVtYmVyW10sIGF4ZXM6IHJlYWRvbmx5IG51bWJlcltdKTogcmVhZG9ubHkgbnVtYmVyW10ge1xuICAgIGNvbnN0IG91dHB1dERpbXMgPSBuZXcgQXJyYXk8bnVtYmVyPihkaW1zLmxlbmd0aCArIGF4ZXMubGVuZ3RoKTtcblxuICAgIC8vIGluaXRpYWxpemUgdGhlIGFycmF5IGVsZW1lbnRzIHRvIDBcbiAgICBvdXRwdXREaW1zLmZpbGwoMCk7XG5cbiAgICAvLyBzZXQgYWxsIGF4ZXMgaW5kaWNlcyB0byAxIGluIG91dHB1dERpbXMgYW5kIGNoZWNrIGZvciBkdXBsaWNhdGVzXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBheGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBheGlzID0gU2hhcGVVdGlsLm5vcm1hbGl6ZUF4aXMoYXhlc1tpXSwgb3V0cHV0RGltcy5sZW5ndGgpO1xuICAgICAgaWYgKGF4aXMgPj0gb3V0cHV0RGltcy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdcXCdheGVzXFwnIGhhcyBhbiBvdXQgb2YgcmFuZ2UgYXhpcycpO1xuICAgICAgfVxuICAgICAgaWYgKG91dHB1dERpbXNbYXhpc10gIT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdcXCdheGVzXFwnIGhhcyBhIGR1cGxpY2F0ZSBheGlzJyk7XG4gICAgICB9XG5cbiAgICAgIG91dHB1dERpbXNbYXhpc10gPSAxO1xuICAgIH1cblxuICAgIC8vIGZpbGwgaW4gdGhlIHplcm8gZW50cmllcyBvZiBvdXRwdXREaW1zIHdpdGggdGhlIGlucHV0IHRlbnNvcidzIHNoYXBlXG4gICAgbGV0IGlucHV0RGltc0l0ZXJhdG9yID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dHB1dERpbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChvdXRwdXREaW1zW2ldID09PSAwKSB7XG4gICAgICAgIG91dHB1dERpbXNbaV0gPSBkaW1zW2lucHV0RGltc0l0ZXJhdG9yKytdO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHNhbml0eSBjaGVjayBhc3NlcnRpb24uICdpbnB1dERpbXNJdGVyYXRvcidcbiAgICAvLyBzaG91bGQgYmUgZXF1YWwgdG8gdGhlIGxlbmd0aCBvZiAnZGltcydcbiAgICBpZiAoaW5wdXREaW1zSXRlcmF0b3IgIT09IGRpbXMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RoZSB1bnNxdWVlemVkIGRpbWVuc2lvbiBjb3VsZCBub3QgYmUgZXN0YWJsaXNoZWQnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0cHV0RGltcztcbiAgfVxufVxuXG4vLyBidW5jaCBvZiBoZWxwZXIgbWV0aG9kcyB0aGF0IGRvIGEgdmFyaWV0eSBvZiBtYXRoIG9wZXJhdGlvbnNcbmV4cG9ydCBjbGFzcyBNYXRoVXRpbCB7XG4gIC8vIHkgPSAoeCp4KSArIHlcbiAgc3RhdGljIHNxcihcbiAgICAgIHRhcmdldDogbnVtYmVyW118VGVuc29yLk51bWJlclR5cGUsIHNvdXJjZTogbnVtYmVyW118VGVuc29yLk51bWJlclR5cGUsIHRhcmdldEluZGV4OiBudW1iZXIsIHNvdXJjZUluZGV4OiBudW1iZXIsXG4gICAgICBibG9ja1NpemU6IG51bWJlcikge1xuICAgIGlmIChzb3VyY2VJbmRleCA8IDAgfHwgc291cmNlSW5kZXggPj0gc291cmNlLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdzb3VyY2VJbmRleCBvdXQgb2YgYm91bmRzJyk7XG4gICAgfVxuICAgIGlmICh0YXJnZXRJbmRleCA8IDAgfHwgdGFyZ2V0SW5kZXggPj0gdGFyZ2V0Lmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd0YXJnZXRJbmRleCBvdXQgb2YgYm91bmRzJyk7XG4gICAgfVxuICAgIGlmIChzb3VyY2VJbmRleCArIGJsb2NrU2l6ZSA+IHNvdXJjZS5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignc291cmNlIGluZGljZXMgdG8gYmUgY29waWVkIGFyZSBvdXRzaWRlIGJvdW5kcycpO1xuICAgIH1cbiAgICBpZiAodGFyZ2V0SW5kZXggKyBibG9ja1NpemUgPiB0YXJnZXQubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RhcmdldCBhcnJheSBpcyB0b28gc21hbGwgdG8gaG9sZCByZXN1bHQnKTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBvZmZzZXQgPSAwOyBvZmZzZXQgPCBibG9ja1NpemU7IG9mZnNldCsrKSB7XG4gICAgICB0YXJnZXRbdGFyZ2V0SW5kZXggKyBvZmZzZXRdICs9IE1hdGgucG93KHNvdXJjZVtzb3VyY2VJbmRleCArIG9mZnNldF0sIDIpO1xuICAgIH1cbiAgfVxuXG4gIC8vIHkgPSBheCArIHlcbiAgc3RhdGljIGF4cHkoXG4gICAgICB0YXJnZXQ6IG51bWJlcltdfFRlbnNvci5OdW1iZXJUeXBlLCBzb3VyY2U6IG51bWJlcltdfFRlbnNvci5OdW1iZXJUeXBlLCB0YXJnZXRJbmRleDogbnVtYmVyLCBzb3VyY2VJbmRleDogbnVtYmVyLFxuICAgICAgYmxvY2tTaXplOiBudW1iZXIsIGFscGhhOiBudW1iZXIpIHtcbiAgICBpZiAoc291cmNlSW5kZXggPCAwIHx8IHNvdXJjZUluZGV4ID49IHNvdXJjZS5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignc291cmNlSW5kZXggb3V0IG9mIGJvdW5kcycpO1xuICAgIH1cbiAgICBpZiAodGFyZ2V0SW5kZXggPCAwIHx8IHRhcmdldEluZGV4ID49IHRhcmdldC5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndGFyZ2V0SW5kZXggb3V0IG9mIGJvdW5kcycpO1xuICAgIH1cbiAgICBpZiAoc291cmNlSW5kZXggKyBibG9ja1NpemUgPiBzb3VyY2UubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NvdXJjZSBpbmRpY2VzIHRvIGJlIGNvcGllZCBhcmUgb3V0c2lkZSBib3VuZHMnKTtcbiAgICB9XG4gICAgaWYgKHRhcmdldEluZGV4ICsgYmxvY2tTaXplID4gdGFyZ2V0Lmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd0YXJnZXQgYXJyYXkgaXMgdG9vIHNtYWxsIHRvIGhvbGQgcmVzdWx0Jyk7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgb2Zmc2V0ID0gMDsgb2Zmc2V0IDwgYmxvY2tTaXplOyBvZmZzZXQrKykge1xuICAgICAgdGFyZ2V0W3RhcmdldEluZGV4ICsgb2Zmc2V0XSArPSAoYWxwaGEgKiBzb3VyY2Vbc291cmNlSW5kZXggKyBvZmZzZXRdKTtcbiAgICB9XG4gIH1cblxuICAvLyB5ID0gcG93KHgsIGIpXG4gIHN0YXRpYyBwb3d4KFxuICAgICAgdGFyZ2V0OiBudW1iZXJbXXxUZW5zb3IuTnVtYmVyVHlwZSwgc291cmNlOiBudW1iZXJbXXxUZW5zb3IuTnVtYmVyVHlwZSwgdGFyZ2V0SW5kZXg6IG51bWJlciwgc291cmNlSW5kZXg6IG51bWJlcixcbiAgICAgIGJsb2NrU2l6ZTogbnVtYmVyLCBiOiBudW1iZXIpIHtcbiAgICBpZiAoc291cmNlSW5kZXggPCAwIHx8IHNvdXJjZUluZGV4ID49IHNvdXJjZS5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignc291cmNlSW5kZXggb3V0IG9mIGJvdW5kcycpO1xuICAgIH1cbiAgICBpZiAodGFyZ2V0SW5kZXggPCAwIHx8IHRhcmdldEluZGV4ID49IHRhcmdldC5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndGFyZ2V0SW5kZXggb3V0IG9mIGJvdW5kcycpO1xuICAgIH1cbiAgICBpZiAoc291cmNlSW5kZXggKyBibG9ja1NpemUgPiBzb3VyY2UubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NvdXJjZSBpbmRpY2VzIHRvIGJlIGNvcGllZCBhcmUgb3V0c2lkZSBib3VuZHMnKTtcbiAgICB9XG4gICAgaWYgKHRhcmdldEluZGV4ICsgYmxvY2tTaXplID4gdGFyZ2V0Lmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd0YXJnZXQgYXJyYXkgaXMgdG9vIHNtYWxsIHRvIGhvbGQgcmVzdWx0Jyk7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgb2Zmc2V0ID0gMDsgb2Zmc2V0IDwgYmxvY2tTaXplOyBvZmZzZXQrKykge1xuICAgICAgdGFyZ2V0W3RhcmdldEluZGV4ICsgb2Zmc2V0XSA9IE1hdGgucG93KHNvdXJjZVtzb3VyY2VJbmRleCArIG9mZnNldF0sIGIpO1xuICAgIH1cbiAgfVxuXG4gIC8vIHkgPSB4ICogeVxuICBzdGF0aWMgbXVsKFxuICAgICAgdGFyZ2V0OiBudW1iZXJbXXxUZW5zb3IuTnVtYmVyVHlwZSwgc291cmNlOiBudW1iZXJbXXxUZW5zb3IuTnVtYmVyVHlwZSwgdGFyZ2V0SW5kZXg6IG51bWJlciwgc291cmNlSW5kZXg6IG51bWJlcixcbiAgICAgIGJsb2NrU2l6ZTogbnVtYmVyKSB7XG4gICAgaWYgKHNvdXJjZUluZGV4IDwgMCB8fCBzb3VyY2VJbmRleCA+PSBzb3VyY2UubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NvdXJjZUluZGV4IG91dCBvZiBib3VuZHMnKTtcbiAgICB9XG4gICAgaWYgKHRhcmdldEluZGV4IDwgMCB8fCB0YXJnZXRJbmRleCA+PSB0YXJnZXQubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RhcmdldEluZGV4IG91dCBvZiBib3VuZHMnKTtcbiAgICB9XG4gICAgaWYgKHNvdXJjZUluZGV4ICsgYmxvY2tTaXplID4gc291cmNlLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdzb3VyY2UgaW5kaWNlcyB0byBiZSBjb3BpZWQgYXJlIG91dHNpZGUgYm91bmRzJyk7XG4gICAgfVxuICAgIGlmICh0YXJnZXRJbmRleCArIGJsb2NrU2l6ZSA+IHRhcmdldC5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndGFyZ2V0IGFycmF5IGlzIHRvbyBzbWFsbCB0byBob2xkIHJlc3VsdCcpO1xuICAgIH1cblxuICAgIGZvciAobGV0IG9mZnNldCA9IDA7IG9mZnNldCA8IGJsb2NrU2l6ZTsgb2Zmc2V0KyspIHtcbiAgICAgIHRhcmdldFt0YXJnZXRJbmRleCArIG9mZnNldF0gPSAoc291cmNlW3NvdXJjZUluZGV4ICsgb2Zmc2V0XSAqIHRhcmdldFt0YXJnZXRJbmRleCArIG9mZnNldF0pO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgU3BsaXRVdGlsIHtcbiAgLyoqXG4gICAqIENhbGN1bGF0ZXMgbmV3IFNoYXBlcyBmcm9tIGV4aXN0aW5nIG9uZSBhbmQgdGhlIHNwbGl0cyBnaXZlbiBhbG9uZyB0aGUgYXhpcyBwcm92aWRlc1xuICAgKiBAcGFyYW0gZGltcyBTaGFwZSBvZiB0aGUgVGVuc29yIHRvIGJlIHNwbGl0dGVkIGludG8gdHdvIG9yIG1vcmUgU2hhcGVzXG4gICAqIEBwYXJhbSBheGlzIFRoZSBkaW1lbnNpb24gYWxvbmcgd2hpY2ggdGhlIFRlbnNvciB3aWxsIGJlIHNwbGl0XG4gICAqIEBwYXJhbSBzcGxpdHMgT2Zmc2V0cyBmb3IgdGhlIHN0YXJ0IG9mIGVhY2ggc3BsaXRcbiAgICovXG4gIHN0YXRpYyBzcGxpdFNoYXBlKGRpbXM6IHJlYWRvbmx5IG51bWJlcltdLCBheGlzOiBudW1iZXIsIHNwbGl0OiBudW1iZXJbXSwgbnVtT3V0cHV0cz86IG51bWJlcik6XG4gICAgICBbbnVtYmVyW11bXSwgbnVtYmVyW11dIHtcbiAgICBpZiAoc3BsaXQubGVuZ3RoID09PSAwKSB7XG4gICAgICBpZiAoIW51bU91dHB1dHMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCduZWVkIHRvIGtub3cgbnVtYmVyIG9mIG91dHB1dHMgd2hlbiB0aGUgXFwnc3BsaXRcXCcgYXR0cmlidXRlIGlzIG5vdCBzcGVjaWZpZWQnKTtcbiAgICAgIH1cbiAgICAgIFNwbGl0VXRpbC5kZXRlcm1pbmVTcGxpdChkaW1zW2F4aXNdLCBudW1PdXRwdXRzLCBzcGxpdCk7XG4gICAgfVxuXG4gICAgY29uc3Qgc2hhcGVzOiBudW1iZXJbXVtdID0gW107XG4gICAgY29uc3Qgb2Zmc2V0cyA9IFswXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNwbGl0Lmxlbmd0aDsgKytpKSB7XG4gICAgICBpZiAoaSAhPT0gMCkge1xuICAgICAgICBvZmZzZXRzLnB1c2gob2Zmc2V0c1tpIC0gMV0gKyBzcGxpdFtpIC0gMV0pO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2hhcGUgPSBkaW1zLnNsaWNlKCk7XG4gICAgICBzaGFwZVtheGlzXSA9IHNwbGl0W2ldO1xuICAgICAgc2hhcGVzLnB1c2goc2hhcGUpO1xuICAgIH1cbiAgICByZXR1cm4gW3NoYXBlcywgb2Zmc2V0c107XG4gIH1cblxuICBzdGF0aWMgZGV0ZXJtaW5lU3BsaXQobnVtRWxlbWVudHNBbG9uZ0F4aXM6IG51bWJlciwgbnVtT3V0cHV0czogbnVtYmVyLCBzcGxpdDogbnVtYmVyW10pIHtcbiAgICAvLyBJZiAnc3BsaXQnIGlzIG5vdCBzcGVjaWZpZWQgYnkgdGhlIHVzZXIsIHdlIG5lZWQgdG8gcGFydGl0aW9uIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgZXF1YWxseSBhbW9uZyB0aGUgb3V0cHV0c1xuICAgIGlmIChudW1FbGVtZW50c0Fsb25nQXhpcyAlIG51bU91dHB1dHMgIT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IHNwbGl0IHRlbnNvciB0byBlcXVhbCBzaXplZCBwYXJ0cycpO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bU91dHB1dHM7ICsraSkge1xuICAgICAgc3BsaXQucHVzaChudW1FbGVtZW50c0Fsb25nQXhpcyAvIG51bU91dHB1dHMpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgUmVkdWNlVXRpbCB7XG4gIC8qKlxuICAgKiBQZXJmb3JtIHJlZHVjZSBvcGVyYXRpb25zIG9uIHRoZSBzcGVjaWZpYyBvcGVyYXRvclxuICAgKiBAcGFyYW0gYSBJbnB1dCB0ZW5zb3IgZGF0YVxuICAgKiBAcGFyYW0gYXhlcyBUaGUgZGltZW5zaW9ucyBhbG9uZyB3aGljaCB0aGUgVGVuc29yIHdpbGwgYmUgcmVkdWNlZFxuICAgKiBAcGFyYW0ga2VlcGRpbXMgSWYgc2V0IHRvIHRydWUsIHRoZSBheGVzIHdoaWNoIGFyZSByZWR1Y2VkIGFyZSBsZWZ0IGluIHRoZVxuICAgKiAgICByZXN1bHQgYXMgZGltZW5zaW9ucyB3aXRoIHNpemUgb25lLlxuICAgKiBAcGFyYW0gb3AxIFRoZSBvcGVyYXRpb24gdG8gYmUgcGVyZm9ybWVkIG9uIGVhY2ggZWxlbWVudCBpbiB0aGUgdGVuc29yXG4gICAqIEBwYXJhbSBvcDIgVGhlIG9wZXJhdGlvbiB0byBiZSBwZXJmb3JtZWQgYmV0d2VlbiBlbGVtZW50cyBpbiB0aGUgdGVuc29yXG4gICAqL1xuICBzdGF0aWMgY2FsY1JlZHVjZShcbiAgICAgIGE6IFRlbnNvciwgYXhlczogbnVtYmVyW10sIGtlZXBkaW1zOiBib29sZWFuLCBvcDE6IChiOiBudW1iZXIpID0+IG51bWJlcixcbiAgICAgIG9wMjogKGE6IG51bWJlciwgYjogbnVtYmVyKSA9PiBudW1iZXIpOiBUZW5zb3Ige1xuICAgIGNvbnN0IGRpbXMgPSBhLmRpbXMuc2xpY2UoMCk7XG4gICAgLy8gaWYgYXhlcyBpcyBub3Qgc2V0LCBwZXJmb3JtIHJlZHVjZSBvbiBhbGwgYXhlc1xuICAgIGlmIChheGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgZGltcy5mb3JFYWNoKChfZCwgaW5kKSA9PiBheGVzLnB1c2goaW5kKSk7XG4gICAgfVxuICAgIC8vIGdldCBhIHRlbXBvcmFyeSBicm9hZGNhc3RhYmxlIG91dHB1dCBzaGFwZVxuICAgIGNvbnN0IG91dHB1dERpbXMgPSBSZWR1Y2VVdGlsLmNhbGNSZWR1Y2VTaGFwZShkaW1zLCBheGVzLCB0cnVlKTtcblxuICAgIC8vIGxvb3AgdGhyb3VnaCB0aGUgb3V0cHV0IGFuZCBjYWxjdWxhdGUgcmVzdWx0IG9uZSBieSBvbmVcbiAgICBjb25zdCBzaXplID0gU2hhcGVVdGlsLnNpemUob3V0cHV0RGltcyk7XG4gICAgY29uc3QgeSA9IG5ldyBUZW5zb3Iob3V0cHV0RGltcywgYS50eXBlKTtcbiAgICBjb25zdCBzdHJpZGVzID0gU2hhcGVVdGlsLmNvbXB1dGVTdHJpZGVzKG91dHB1dERpbXMpO1xuICAgIGNvbnN0IGlucHV0U3RyaWRlcyA9IFNoYXBlVXRpbC5jb21wdXRlU3RyaWRlcyhkaW1zKTtcbiAgICBjb25zdCBpbmRpY2VzWSA9IG5ldyBBcnJheShkaW1zLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgIGNvbnN0IGluZGljZXMgPSBTaGFwZVV0aWwub2Zmc2V0VG9JbmRpY2VzKGksIHN0cmlkZXMpO1xuICAgICAgLy8gbWFwIGluZGV4XG4gICAgICBCcm9hZGNhc3RVdGlsLmZpbGxJbmRleChpbmRpY2VzLCBkaW1zLCBpbmRpY2VzWSk7XG4gICAgICB5LnNldChcbiAgICAgICAgICBpbmRpY2VzLFxuICAgICAgICAgIFJlZHVjZVV0aWwuY2FsY1JlZHVjZUJ5QXhpcyhcbiAgICAgICAgICAgICAgYS5udW1iZXJEYXRhLCBheGVzLCBkaW1zLCAwLCBTaGFwZVV0aWwuaW5kaWNlc1RvT2Zmc2V0KGluZGljZXNZLCBpbnB1dFN0cmlkZXMpLCBvcDEsIG9wMikpO1xuICAgIH1cblxuICAgIGlmIChrZWVwZGltcykge1xuICAgICAgcmV0dXJuIHk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGtlZXBkaW1zID09IDAsIGNhbGN1bGF0ZSB0aGUgZXhwZWN0ZWQgc2hhcGVcbiAgICAgIHJldHVybiBuZXcgVGVuc29yKFxuICAgICAgICAgIFJlZHVjZVV0aWwuY2FsY1JlZHVjZVNoYXBlKGRpbXMsIGF4ZXMsIGtlZXBkaW1zKSwgeS50eXBlLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgeS5kYXRhLCB5LmRhdGFJZCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFBlcmZvcm0gcmVkdWNlIG9wZXJhdGlvbnMgb24gdGhlIHNwZWNpZmljIG9wZXJhdG9yIG9uIHNwZWNpZmljIGF4ZXNcbiAgICogQHBhcmFtIGEgSW5wdXQgdGVuc29yIGRhdGFcbiAgICogQHBhcmFtIGF4ZXMgVGhlIGRpbWVuc2lvbnMgYWxvbmcgd2hpY2ggdGhlIFRlbnNvciB3aWxsIGJlIHJlZHVjZWRcbiAgICogQHBhcmFtIGRpbXMgVGhlIGlucHV0IGRpbWVuc2lvbi5cbiAgICogQHBhcmFtIGN1ckF4aXNJbmQgSW5kZXggaW4gYXhlcyBzcGVjaWZ5aW5nIHRoZSBjdXJyZW50IGRpbWVuc2lvbiBhbG9uZ1xuICAgKiAgICAgIHdoaWNoIHRoZSB0ZW5zb3Igd2lsbCBiZSByZWR1Y2VkXG4gICAqIEBwYXJhbSBwb3MgVGhlIGN1cnJlbnQgaW5kZXggb2YgZWxlbWVudCB0byBwZXJmb3JtIG9wZXJhdGlvblxuICAgKiBAcGFyYW0gb3AxIFRoZSBvcGVyYXRpb24gdG8gYmUgcGVyZm9ybWVkIG9uIGVhY2ggZWxlbWVudCBpbiB0aGUgdGVuc29yXG4gICAqIEBwYXJhbSBvcDIgVGhlIG9wZXJhdGlvbiB0byBiZSBwZXJmb3JtZWQgYmV0d2VlbiBlbGVtZW50cyBpbiB0aGUgdGVuc29yXG4gICAqL1xuICBzdGF0aWMgY2FsY1JlZHVjZUJ5QXhpcyhcbiAgICAgIGlucHV0OiBUZW5zb3IuTnVtYmVyVHlwZSwgYXhlczogbnVtYmVyW10sIGRpbXM6IG51bWJlcltdLCBjdXJBeGlzSW5kOiBudW1iZXIsIHBvczogbnVtYmVyLFxuICAgICAgb3AxOiAoYjogbnVtYmVyKSA9PiBudW1iZXIsIG9wMjogKGE6IG51bWJlciwgYjogbnVtYmVyKSA9PiBudW1iZXIpOiBudW1iZXIge1xuICAgIGxldCByZXMgPSAwO1xuICAgIGlmIChjdXJBeGlzSW5kID49IGF4ZXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gb3AxKGlucHV0W3Bvc10pO1xuICAgIH1cbiAgICBjb25zdCBheGlzID0gYXhlc1tjdXJBeGlzSW5kXTtcbiAgICBjb25zdCBzdGVwID0gYXhpcyA+PSBkaW1zLmxlbmd0aCA/IDEgOiBTaGFwZVV0aWwuc2l6ZShkaW1zLnNsaWNlKGF4aXMgKyAxKSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkaW1zW2F4aXNdOyBpKyspIHtcbiAgICAgIHJlcyA9IGkgPT09IDAgPyBSZWR1Y2VVdGlsLmNhbGNSZWR1Y2VCeUF4aXMoaW5wdXQsIGF4ZXMsIGRpbXMsIGN1ckF4aXNJbmQgKyAxLCBwb3MsIG9wMSwgb3AyKSA6XG4gICAgICAgICAgICAgICAgICAgICAgb3AyKHJlcywgUmVkdWNlVXRpbC5jYWxjUmVkdWNlQnlBeGlzKGlucHV0LCBheGVzLCBkaW1zLCBjdXJBeGlzSW5kICsgMSwgcG9zLCBvcDEsIG9wMikpO1xuICAgICAgcG9zICs9IHN0ZXA7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBleHBlY3RlZCBzaGFwZSBvZiBhIHJlZHVjZSBvcGVyYXRpb25cbiAgICogQHBhcmFtIGRpbXMgVGhlIGlucHV0IHRlbnNvciBkaW1lbnNpb25cbiAgICogQHBhcmFtIGF4ZXMgVGhlIGRpbWVuc2lvbnMgYWxvbmcgd2hpY2ggdGhlIFRlbnNvciB3aWxsIGJlIHJlZHVjZWRcbiAgICogQHBhcmFtIGtlZXBkaW1zIElmIHNldCB0byB0cnVlLCB0aGUgYXhlcyB3aGljaCBhcmUgcmVkdWNlZCBhcmUgbGVmdCBpbiB0aGVcbiAgICogICAgcmVzdWx0IGFzIGRpbWVuc2lvbnMgd2l0aCBzaXplIG9uZS5cbiAgICovXG4gIHN0YXRpYyBjYWxjUmVkdWNlU2hhcGUoZGltczogcmVhZG9ubHkgbnVtYmVyW10sIGF4ZXM6IHJlYWRvbmx5IG51bWJlcltdLCBrZWVwRGltczogYm9vbGVhbik6IG51bWJlcltdIHtcbiAgICBjb25zdCBvdXRwdXREaW1zID0gZGltcy5zbGljZSgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXhlcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGtlZXBEaW1zKSB7XG4gICAgICAgIG91dHB1dERpbXNbYXhlc1tpXV0gPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0cHV0RGltc1theGVzW2ldXSA9IDA7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXREaW1zLmZpbHRlcihkaW0gPT4gZGltICE9PSAwKTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgUG9vbENvbnZVdGlsIHtcbiAgLyoqXG4gICAqIEFkanVzdCB0aGUga2VybmVsLCBzdHJpZGVzLCBwYWRzIHRvIGNvcnJlY3QgcmFuay4gU2V0IHRvIGRlZmF1bHQgdmFsdWUgaWYgbm90IHByZXNlbnRcbiAgICogQHBhcmFtIGlzR2xvYmFsT3BlcmF0b3IgSWYgdHJ1ZSwgcGVyZm9ybSBnbG9iYWwgcG9vbGluZy5cbiAgICogQHBhcmFtIGlucHV0RGltcyBUaGUgaW5wdXQgdGVuc29yIGRpbWVuc2lvbi5cbiAgICogQHBhcmFtIGtlcm5lbFNoYXBlIFRoZSBzaXplIG9mIHRoZSBrZXJuZWwgYWxvbmcgZWFjaCBheGlzLlxuICAgKiBAcGFyYW0gc3RyaWRlcyBTdHJpZGUgYWxvbmcgZWFjaCBheGlzLlxuICAgKiBAcGFyYW0gZGlsYXRpb25zIERpbGF0aW9uIGFsb25nIGVhY2ggYXhpcy5cbiAgICogQHBhcmFtIHBhZHMgUGFkZGluZyBmb3IgdGhlIGJlZ2lubmluZyBhbmQgZW5kaW5nIGFsb25nIGVhY2ggYXhpcy5cbiAgICovXG4gIHN0YXRpYyBhZGp1c3RQb29sQXR0cmlidXRlcyhcbiAgICAgIGlzR2xvYmFsT3BlcmF0b3I6IGJvb2xlYW4sIGlucHV0RGltczogcmVhZG9ubHkgbnVtYmVyW10sIGtlcm5lbFNoYXBlOiBudW1iZXJbXSwgc3RyaWRlczogbnVtYmVyW10sXG4gICAgICBkaWxhdGlvbnM6IG51bWJlcltdLCBwYWRzOiBudW1iZXJbXSkge1xuICAgIGlmICghaXNHbG9iYWxPcGVyYXRvciAmJiBrZXJuZWxTaGFwZS5sZW5ndGggIT09IGlucHV0RGltcy5sZW5ndGggLSAyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2xlbmd0aCBvZiBzcGVjaWZpZWQga2VybmVsIHNoYXBlcyBzaG91bGQgYmUgMiBsZXNzIHRoYW4gbGVuZ3RoIG9mIGlucHV0IGRpbWVuc2lvbnMnKTtcbiAgICB9XG5cbiAgICBpZiAoaXNHbG9iYWxPcGVyYXRvcikge1xuICAgICAgLy8gYWRqdXN0IGtlcm5lbCBzaGFwZSB0byBjb3ZlciB0aGUgaW5wdXQgZGltc1xuICAgICAgZm9yIChsZXQgZGltID0gMDsgZGltIDwgaW5wdXREaW1zLmxlbmd0aCAtIDI7IGRpbSsrKSB7XG4gICAgICAgIGlmIChkaW0gPj0ga2VybmVsU2hhcGUubGVuZ3RoKSB7XG4gICAgICAgICAga2VybmVsU2hhcGUucHVzaChpbnB1dERpbXNbZGltICsgMl0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGtlcm5lbFNoYXBlW2RpbV0gPSBpbnB1dERpbXNbZGltICsgMl07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBhZGp1c3Qgc3RyaWRlcyBsZW5ndGggdG8gbWF0Y2gga2VybmVsIHNoYXBlIGxlbmd0aFxuICAgIGZvciAobGV0IGRpbSA9IDA7IGRpbSA8IGtlcm5lbFNoYXBlLmxlbmd0aDsgZGltKyspIHtcbiAgICAgIGlmIChkaW0gPCBzdHJpZGVzLmxlbmd0aCkge1xuICAgICAgICBpZiAoc3RyaWRlc1tkaW1dIDwgMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc3RyaWRlcyBzaG91bGQgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDEnKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyaWRlcy5wdXNoKDEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGFkanVzdCBkaWxhdGlvbiB2YWx1ZVxuICAgIGZvciAobGV0IGRpbSA9IDA7IGRpbSA8IGtlcm5lbFNoYXBlLmxlbmd0aDsgZGltKyspIHtcbiAgICAgIGlmIChkaW0gPCBkaWxhdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgIGlmIChkaWxhdGlvbnNbZGltXSA8IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RpbGF0aW9ucyBzaG91bGQgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDEnKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGlsYXRpb25zLnB1c2goMSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gYWRqdXN0IHBhZHMgbGVuZ3RoIHRvIG1hdGNoIDIgKiBrZXJuZWwgc2hhcGUgbGVuZ3RoXG4gICAgZm9yIChsZXQgZGltID0gMDsgZGltIDwga2VybmVsU2hhcGUubGVuZ3RoICogMjsgZGltKyspIHtcbiAgICAgIGlmIChkaW0gPCBwYWRzLmxlbmd0aCkge1xuICAgICAgICBpZiAocGFkc1tkaW1dIDwgMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncGFkIHNob3VsZCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMScpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYWRzLnB1c2goMCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gc2FuaXR5IGNoZWNrcyBmb3IgdmFsdWVzIGluIGtlcm5lbCBzaGFwZXMgYW5kIHBhZHNcbiAgICBmb3IgKGxldCBkaW0gPSAwOyBkaW0gPCBrZXJuZWxTaGFwZS5sZW5ndGg7IGRpbSsrKSB7XG4gICAgICBpZiAoa2VybmVsU2hhcGVbZGltXSA8PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigna2VybmVsIHNoYXBlcyBuZWVkIHRvIGJlIGdyZWF0ZXIgdGhhbiAwJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwYWRzW2RpbV0gPj0ga2VybmVsU2hhcGVbZGltXSB8fCBwYWRzW2RpbSArIGtlcm5lbFNoYXBlLmxlbmd0aF0gPj0ga2VybmVsU2hhcGVbZGltXSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhZHMgc2hvdWxkIGJlIHNtYWxsZXIgdGhhbiBrZXJuZWwnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBhZGp1c3QgcGFkIHZhbHVlcyBiYXNlZCBvbiAnYXV0b1BhZCcgYXR0cmlidXRlXG4gIHN0YXRpYyBhZGp1c3RQYWRzQmFzZWRPbkF1dG9QYWQoXG4gICAgICBpbnB1dERpbXM6IHJlYWRvbmx5IG51bWJlcltdLCBzdHJpZGVzOiByZWFkb25seSBudW1iZXJbXSwgZGlsYXRpb25zOiByZWFkb25seSBudW1iZXJbXSxcbiAgICAgIGtlcm5lbFNoYXBlOiByZWFkb25seSBudW1iZXJbXSwgcGFkczogbnVtYmVyW10sIGF1dG9QYWQ/OiBzdHJpbmcpIHtcbiAgICBpZiAoIWF1dG9QYWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocGFkcy5sZW5ndGggIT09IDIgKiAoaW5wdXREaW1zLmxlbmd0aCAtIDIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2xlbmd0aCBvZiBwYWRzIHNob3VsZCBiZSB0d2ljZSB0aGUgbGVuZ3RoIG9mIGRhdGEgZGltZW5zaW9ucycpO1xuICAgIH1cblxuICAgIGlmIChzdHJpZGVzLmxlbmd0aCAhPT0gKGlucHV0RGltcy5sZW5ndGggLSAyKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdsZW5ndGggb2Ygc3RyaWRlcyBzaG91bGQgYmUgdGhlIGxlbmd0aCBvZiBkYXRhIGRpbWVuc2lvbnMnKTtcbiAgICB9XG5cbiAgICBpZiAoa2VybmVsU2hhcGUubGVuZ3RoICE9PSAoaW5wdXREaW1zLmxlbmd0aCAtIDIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2xlbmd0aCBvZiBrZXJuZWwgc2hhcGVzIHNob3VsZCBiZSB0aGUgbGVuZ3RoIG9mIGRhdGEgZGltZW5zaW9ucycpO1xuICAgIH1cblxuICAgIGZvciAobGV0IGRpbSA9IDA7IGRpbSA8IGlucHV0RGltcy5sZW5ndGggLSAyOyBkaW0rKykge1xuICAgICAgUG9vbENvbnZVdGlsLmFkanVzdFBhZEFuZFJldHVyblNoYXBlKFxuICAgICAgICAgIGlucHV0RGltc1tkaW0gKyAyXSwgc3RyaWRlc1tkaW1dLCBkaWxhdGlvbnNbZGltXSwga2VybmVsU2hhcGVbZGltXSwgcGFkcywgZGltLCBkaW0gKyBpbnB1dERpbXMubGVuZ3RoIC0gMixcbiAgICAgICAgICBhdXRvUGFkKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBvdXRwdXQgc2hhcGUgZm9yIFBvb2wgb3BzIGJhc2VkIG9uIGlucHV0IGF0dHJpYnV0ZXMuIChTaG91bGQgYmUgdXNlZCBvbmx5IGZvciBQb29sIG9wcylcbiAgICogQHBhcmFtIGlzR2xvYmFsT3BlcmF0b3IgSWYgdHJ1ZSwgcGVyZm9ybSBnbG9iYWwgcG9vbGluZy5cbiAgICogQHBhcmFtIGlucHV0RGltcyBUaGUgaW5wdXQgdGVuc29yIGRpbWVuc2lvbi4gKGlucHV0c1swXS5kaW1zKVxuICAgKiBAcGFyYW0gc3RyaWRlcyBTdHJpZGUgYWxvbmcgZWFjaCBheGlzLlxuICAgKiBAcGFyYW0gZGlsYXRpb25zIERpbGF0aW9uIGFsb25nIGVhY2ggYXhpcy5cbiAgICogQHBhcmFtIGtlcm5lbFNoYXBlIFRoZSBzaXplIG9mIHRoZSBrZXJuZWwgYWxvbmcgZWFjaCBheGlzLlxuICAgKiBAcGFyYW0gcGFkcyBQYWRkaW5nIGZvciB0aGUgYmVnaW5uaW5nIGFuZCBlbmRpbmcgYWxvbmcgZWFjaCBheGlzLlxuICAgKiBAcGFyYW0gYXV0b1BhZCBERVBSRUNBVEVEIGF0dHJpYnV0ZSBzdXBwb3J0ZWQgZm9yIGxlZ2FjeSBtb2RlbHMuIFNwZWNpZmllcyBob3cgdG8gaW1wbGljaXRseSBjYWxjdWxhdGUgcGFkcyBpbiBlYWNoXG4gICAqICAgICBkaW1lbnNpb24uIENhbiB0YWtlIHZhbHVlcyBOT1RTRVQsIFNBTUVfVVBQRVIsIFNBTUVfTE9XRVIsIG9yIFZBTElELlxuICAgKi9cbiAgc3RhdGljIGNvbXB1dGVQb29sT3V0cHV0U2hhcGUoXG4gICAgICBpc0dsb2JhbE9wZXJhdG9yOiBib29sZWFuLCBpbnB1dERpbXM6IHJlYWRvbmx5IG51bWJlcltdLCBzdHJpZGVzOiBudW1iZXJbXSwgZGlsYXRpb25zOiBudW1iZXJbXSxcbiAgICAgIGtlcm5lbFNoYXBlOiBudW1iZXJbXSwgcGFkczogbnVtYmVyW10sIGF1dG9QYWQ/OiBzdHJpbmcpOiBudW1iZXJbXSB7XG4gICAgaWYgKGlucHV0RGltcy5sZW5ndGggPD0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnB1dCBzaGFwZSBtdXN0IGJlIG9mIHNpemUgZ3JlYXRlciB0aGFuIDAnKTtcbiAgICB9XG5cbiAgICAvLyBBZGQgYmF0Y2ggc2l6ZSBhbmQgbnVtYmVyIG9mIGNoYW5uZWxzIG9mIG91dHB1dFxuICAgIGNvbnN0IG91dHB1dERpbXMgPSBbaW5wdXREaW1zWzBdLCBpbnB1dERpbXNbMV1dO1xuXG4gICAgUG9vbENvbnZVdGlsLmNvbXB1dGVTaGFwZUhlbHBlcihcbiAgICAgICAgaXNHbG9iYWxPcGVyYXRvciwgaW5wdXREaW1zLCBvdXRwdXREaW1zLCBzdHJpZGVzLCBkaWxhdGlvbnMsIGtlcm5lbFNoYXBlLCBwYWRzLCBhdXRvUGFkKTtcbiAgICByZXR1cm4gb3V0cHV0RGltcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIG91dHB1dCBzaGFwZSBmb3IgQ29udiBvcCBiYXNlZCBvbiBpbnB1dCBhdHRyaWJ1dGVzLiAoU2hvdWxkIGJlIHVzZWQgb25seSBmb3IgQ29udiBvcClcbiAgICogQHBhcmFtIGlucHV0RGltcyBUaGUgaW5wdXQgdGVuc29yIGRpbWVuc2lvbi4gKGlucHV0c1swXS5kaW1zKVxuICAgKiBAcGFyYW0gZmlsdGVyRGltcyBUaGUgZmlsdGVyIHRlbnNvciBkaW1lbnNpb24uIChpbnB1dHNbMV0uZGltcylcbiAgICogQHBhcmFtIHN0cmlkZXMgU3RyaWRlIGFsb25nIGVhY2ggYXhpcy5cbiAgICogQHBhcmFtIGtlcm5lbFNoYXBlIFRoZSBzaXplIG9mIHRoZSBrZXJuZWwgYWxvbmcgZWFjaCBheGlzLlxuICAgKiBAcGFyYW0gcGFkcyBQYWRkaW5nIGZvciB0aGUgYmVnaW5uaW5nIGFuZCBlbmRpbmcgYWxvbmcgZWFjaCBheGlzLlxuICAgKiBAcGFyYW0gYXV0b1BhZCBERVBSRUNBVEVEIGF0dHJpYnV0ZSBzdXBwb3J0ZWQgZm9yIGxlZ2FjeSBtb2RlbHMuIFNwZWNpZmllcyBob3cgdG8gaW1wbGljaXRseSBjYWxjdWxhdGUgcGFkcyBpbiBlYWNoXG4gICAqICAgICBkaW1lbnNpb24uIENhbiB0YWtlIHZhbHVlcyBOT1RTRVQsIFNBTUVfVVBQRVIsIFNBTUVfTE9XRVIsIG9yIFZBTElELlxuICAgKi9cbiAgc3RhdGljIGNvbXB1dGVDb252T3V0cHV0U2hhcGUoXG4gICAgICBpbnB1dERpbXM6IHJlYWRvbmx5IG51bWJlcltdLCBmaWx0ZXJEaW1zOiByZWFkb25seSBudW1iZXJbXSwgc3RyaWRlczogbnVtYmVyW10sIGRpbGF0aW9uczogbnVtYmVyW10sXG4gICAgICBrZXJuZWxTaGFwZTogbnVtYmVyW10sIHBhZHM6IG51bWJlcltdLCBhdXRvUGFkPzogc3RyaW5nKTogbnVtYmVyW10ge1xuICAgIGlmIChpbnB1dERpbXMubGVuZ3RoIDw9IDAgfHwgZmlsdGVyRGltcy5sZW5ndGggPD0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGlucHV0IHRlbnNvciBkaW1zIG9yIGludmFsaWQgZmlsdGVyIHRlbnNvciBkaW1zJyk7XG4gICAgfVxuXG4gICAgLy8gQWRkIGJhdGNoIHNpemUgYW5kIG51bWJlciBvZiBjaGFubmVscyBvZiBvdXRwdXRcbiAgICBjb25zdCBvdXRwdXREaW1zID0gW2lucHV0RGltc1swXSwgZmlsdGVyRGltc1swXV07XG5cbiAgICBQb29sQ29udlV0aWwuY29tcHV0ZVNoYXBlSGVscGVyKGZhbHNlLCBpbnB1dERpbXMsIG91dHB1dERpbXMsIHN0cmlkZXMsIGRpbGF0aW9ucywga2VybmVsU2hhcGUsIHBhZHMsIGF1dG9QYWQpO1xuICAgIHJldHVybiBvdXRwdXREaW1zO1xuICB9XG5cbiAgLy8gd2lsbCBjb21wdXRlIG91dHB1dCBzaGFwZXMgZm9yIGRhdGEgZGltZW5zaW9ucyBPTkxZIChpLmUuKSBubyBiYXRjaCBzaXplIGFuZCBjaGFubmVsc1xuICAvLyBjYWxsZWQgYnkgY29tcHV0ZVBvb2xPdXRwdXRTaGFwZSgpIGFuZCBjb21wdXRlQ29udk91dHB1dFNoYXBlKClcbiAgLy8gYWRqdXN0IHBhZHMgYmFzZWQgb24gJ2F1dG9QYWQnIGF0dHJpYnV0ZSBwcmlvciB0byBzaGFwZSBjb21wdXRhdGlvblxuICBwcml2YXRlIHN0YXRpYyBjb21wdXRlU2hhcGVIZWxwZXIoXG4gICAgICBpc0dsb2JhbE9wZXJhdG9yOiBib29sZWFuLCBpbnB1dERpbXM6IHJlYWRvbmx5IG51bWJlcltdLCBvdXRwdXREaW1zOiBudW1iZXJbXSwgc3RyaWRlczogcmVhZG9ubHkgbnVtYmVyW10sXG4gICAgICBkaWxhdGlvbnM6IHJlYWRvbmx5IG51bWJlcltdLCBrZXJuZWxTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sIHBhZHM6IG51bWJlcltdLCBhdXRvUGFkPzogc3RyaW5nKSB7XG4gICAgaWYgKGlzR2xvYmFsT3BlcmF0b3IpIHtcbiAgICAgIGZvciAobGV0IGRpbSA9IDA7IGRpbSA8IGlucHV0RGltcy5sZW5ndGggLSAyOyBkaW0rKykge1xuICAgICAgICBvdXRwdXREaW1zLnB1c2goMSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAobGV0IGRpbSA9IDA7IGRpbSA8IGlucHV0RGltcy5sZW5ndGggLSAyOyBkaW0rKykge1xuICAgICAgICBvdXRwdXREaW1zLnB1c2goUG9vbENvbnZVdGlsLmFkanVzdFBhZEFuZFJldHVyblNoYXBlKFxuICAgICAgICAgICAgaW5wdXREaW1zW2RpbSArIDJdLCBzdHJpZGVzW2RpbV0sIGRpbGF0aW9uc1tkaW1dLCBrZXJuZWxTaGFwZVtkaW1dLCBwYWRzLCBkaW0sIGRpbSArIGlucHV0RGltcy5sZW5ndGggLSAyLFxuICAgICAgICAgICAgYXV0b1BhZCkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIGhlbHBlciBmb3IgY29tcHV0ZVNoYXBlSGVscGVyKCkgYW5kIGFkanVzdFBhZHNCYXNlZE9uQXV0b1BhZCgpXG4gIC8vIGFkanVzdHMgcGFkIHZhbHVlIGZvciBnaXZlbiAnYXV0b1BhZCcgc3RyaW5nIGFuZCBjb21wdXRlcyBvdXRwdXQgc2hhcGUgYWxvbmcgYSBwYXJ0aWN1bGFyIGRpbWVuc2lvblxuICBwcml2YXRlIHN0YXRpYyBhZGp1c3RQYWRBbmRSZXR1cm5TaGFwZShcbiAgICAgIGluU2l6ZTogbnVtYmVyLCBzdHJpZGU6IG51bWJlciwgZGlsYXRpb246IG51bWJlciwga2VybmVsOiBudW1iZXIsIHBhZHM6IG51bWJlcltdLCBwYWRIZWFkSW5kZXg6IG51bWJlcixcbiAgICAgIHBhZFRhaWxJbmRleDogbnVtYmVyLCBhdXRvUGFkPzogc3RyaW5nKTogbnVtYmVyIHtcbiAgICBjb25zdCBka2VybmVsID0gZGlsYXRpb24gKiAoa2VybmVsIC0gMSkgKyAxO1xuICAgIGlmIChhdXRvUGFkICYmIGF1dG9QYWQgIT09ICdOT1RTRVQnKSB7XG4gICAgICBzd2l0Y2ggKGF1dG9QYWQpIHtcbiAgICAgICAgY2FzZSAnVkFMSUQnOlxuICAgICAgICAgIHBhZHNbcGFkSGVhZEluZGV4XSA9IDA7XG4gICAgICAgICAgcGFkc1twYWRUYWlsSW5kZXhdID0gMDtcbiAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcigoKGluU2l6ZSAtIGRrZXJuZWwpIC8gc3RyaWRlKSArIDEpO1xuICAgICAgICBjYXNlICdTQU1FX0xPV0VSJzpcbiAgICAgICAgY2FzZSAnU0FNRV9VUFBFUic6XG4gICAgICAgICAgaWYgKGRpbGF0aW9uICE9PSAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RpbGF0aW9uIG5vdCBzdXBwb3J0ZWQgZm9yIFNBTUVfVVBQRVIgb3IgU0FNRV9MT1dFUicpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBsZWdhY3lUYXJnZXRTaXplID0gKGluU2l6ZSArIHN0cmlkZSAtIDEpIC8gc3RyaWRlO1xuICAgICAgICAgICAgY29uc3QgcGFkTmVlZGVkID0gKGxlZ2FjeVRhcmdldFNpemUgLSAxKSAqIHN0cmlkZSArIGtlcm5lbCAtIGluU2l6ZTtcbiAgICAgICAgICAgIHBhZHNbcGFkSGVhZEluZGV4XSA9XG4gICAgICAgICAgICAgICAgKGF1dG9QYWQgPT09ICdTQU1FX0xPV0VSJykgPyBNYXRoLmZsb29yKChwYWROZWVkZWQgKyAxKSAvIDIpIDogTWF0aC5mbG9vcihwYWROZWVkZWQgLyAyKTtcbiAgICAgICAgICAgIHBhZHNbcGFkVGFpbEluZGV4XSA9IHBhZE5lZWRlZCAtIHBhZHNbcGFkSGVhZEluZGV4XTtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKCgoaW5TaXplICsgcGFkTmVlZGVkIC0ga2VybmVsKSAvIHN0cmlkZSkgKyAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBBdXRvUGFkIHR5cGUnKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIE1hdGguZmxvb3IoKChpblNpemUgKyBwYWRzW3BhZEhlYWRJbmRleF0gKyBwYWRzW3BhZFRhaWxJbmRleF0gLSBka2VybmVsKSAvIHN0cmlkZSkgKyAxKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IE1JTl9DTElQID0gLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzg7XG5leHBvcnQgY29uc3QgTUFYX0NMSVAgPSAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4O1xuXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlVXRmOFN0cmluZyhidWZmZXI6IFVpbnQ4QXJyYXkpOiBzdHJpbmcge1xuICByZXR1cm4gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKGJ1ZmZlcik7XG59XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7R3VpZH0gZnJvbSAnZ3VpZC10eXBlc2NyaXB0JztcbmltcG9ydCBMb25nIGZyb20gJ2xvbmcnO1xuXG5pbXBvcnQge29ubnhydW50aW1lfSBmcm9tICcuL29ydC1zY2hlbWEvZmxhdGJ1ZmZlcnMvb3J0LWdlbmVyYXRlZCc7XG5pbXBvcnQge29ubnh9IGZyb20gJy4vb3J0LXNjaGVtYS9wcm90b2J1Zi9vbm54JztcbmltcG9ydCB7ZGVjb2RlVXRmOFN0cmluZywgUHJvdG9VdGlsLCBTaGFwZVV0aWx9IGZyb20gJy4vdXRpbCc7XG5cbmltcG9ydCBvcnRGYnMgPSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzO1xuXG5leHBvcnQgZGVjbGFyZSBuYW1lc3BhY2UgVGVuc29yIHtcbiAgZXhwb3J0IGludGVyZmFjZSBEYXRhVHlwZU1hcCB7XG4gICAgYm9vbDogVWludDhBcnJheTtcbiAgICBmbG9hdDMyOiBGbG9hdDMyQXJyYXk7XG4gICAgZmxvYXQ2NDogRmxvYXQ2NEFycmF5O1xuICAgIHN0cmluZzogc3RyaW5nW107XG4gICAgaW50ODogSW50OEFycmF5O1xuICAgIHVpbnQ4OiBVaW50OEFycmF5O1xuICAgIGludDE2OiBJbnQxNkFycmF5O1xuICAgIHVpbnQxNjogVWludDE2QXJyYXk7XG4gICAgaW50MzI6IEludDMyQXJyYXk7XG4gICAgdWludDMyOiBVaW50MzJBcnJheTtcbiAgICBpbnQ2NDogQmlnSW50NjRBcnJheTtcbiAgfVxuXG4gIGV4cG9ydCB0eXBlIERhdGFUeXBlID0ga2V5b2YgRGF0YVR5cGVNYXA7XG5cbiAgZXhwb3J0IHR5cGUgU3RyaW5nVHlwZSA9IFRlbnNvci5EYXRhVHlwZU1hcFsnc3RyaW5nJ107XG4gIGV4cG9ydCB0eXBlIEJvb2xlYW5UeXBlID0gVGVuc29yLkRhdGFUeXBlTWFwWydib29sJ107XG4gIGV4cG9ydCB0eXBlIEludGVnZXJUeXBlID0gVGVuc29yLkRhdGFUeXBlTWFwWydpbnQ4J118VGVuc29yLkRhdGFUeXBlTWFwWyd1aW50OCddfFRlbnNvci5EYXRhVHlwZU1hcFsnaW50MTYnXXxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBUZW5zb3IuRGF0YVR5cGVNYXBbJ3VpbnQxNiddfFRlbnNvci5EYXRhVHlwZU1hcFsnaW50MzInXXxUZW5zb3IuRGF0YVR5cGVNYXBbJ3VpbnQzMiddO1xuICBleHBvcnQgdHlwZSBGbG9hdFR5cGUgPSBUZW5zb3IuRGF0YVR5cGVNYXBbJ2Zsb2F0MzInXXxUZW5zb3IuRGF0YVR5cGVNYXBbJ2Zsb2F0NjQnXTtcbiAgZXhwb3J0IHR5cGUgTnVtYmVyVHlwZSA9IEJvb2xlYW5UeXBlfEludGVnZXJUeXBlfEZsb2F0VHlwZTtcblxuICBleHBvcnQgdHlwZSBJZCA9IEd1aWQ7XG59XG5cbnR5cGUgVGVuc29yRGF0YSA9IFRlbnNvci5EYXRhVHlwZU1hcFtUZW5zb3IuRGF0YVR5cGVdO1xuXG50eXBlIERhdGFQcm92aWRlciA9IChpZDogVGVuc29yLklkKSA9PiBUZW5zb3JEYXRhO1xudHlwZSBBc3luY0RhdGFQcm92aWRlciA9IChpZDogVGVuc29yLklkKSA9PiBQcm9taXNlPFRlbnNvckRhdGE+O1xuXG5leHBvcnQgY2xhc3MgVGVuc29yIHtcbiAgLyoqXG4gICAqIGdldCB0aGUgdW5kZXJseWluZyB0ZW5zb3IgZGF0YVxuICAgKi9cbiAgZ2V0IGRhdGEoKTogVGVuc29yRGF0YSB7XG4gICAgaWYgKHRoaXMuY2FjaGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgZGF0YSA9IHRoaXMuZGF0YVByb3ZpZGVyISh0aGlzLmRhdGFJZCk7XG4gICAgICBpZiAoZGF0YS5sZW5ndGggIT09IHRoaXMuc2l6ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0xlbmd0aCBvZiBkYXRhIHByb3ZpZGVkIGJ5IHRoZSBEYXRhIFByb3ZpZGVyIGlzIGluY29uc2lzdGVudCB3aXRoIHRoZSBkaW1zIG9mIHRoaXMgVGVuc29yLicpO1xuICAgICAgfVxuICAgICAgdGhpcy5jYWNoZSA9IGRhdGE7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNhY2hlO1xuICB9XG5cbiAgLyoqXG4gICAqIGdldCB0aGUgdW5kZXJseWluZyBzdHJpbmcgdGVuc29yIGRhdGEuIFNob3VsZCBvbmx5IHVzZSB3aGVuIHR5cGUgaXMgU1RSSU5HXG4gICAqL1xuICBnZXQgc3RyaW5nRGF0YSgpIHtcbiAgICBpZiAodGhpcy50eXBlICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZGF0YSB0eXBlIGlzIG5vdCBzdHJpbmcnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5kYXRhIGFzIFRlbnNvci5TdHJpbmdUeXBlO1xuICB9XG5cbiAgLyoqXG4gICAqIGdldCB0aGUgdW5kZXJseWluZyBpbnRlZ2VyIHRlbnNvciBkYXRhLiBTaG91bGQgb25seSB1c2Ugd2hlbiB0eXBlIGlzIG9uZSBvZiB0aGUgZm9sbG93aW5nOiAoVUlOVDgsIElOVDgsIFVJTlQxNixcbiAgICogSU5UMTYsIElOVDMyLCBVSU5UMzIsIEJPT0wpXG4gICAqL1xuICBnZXQgaW50ZWdlckRhdGEoKSB7XG4gICAgc3dpdGNoICh0aGlzLnR5cGUpIHtcbiAgICAgIGNhc2UgJ3VpbnQ4JzpcbiAgICAgIGNhc2UgJ2ludDgnOlxuICAgICAgY2FzZSAndWludDE2JzpcbiAgICAgIGNhc2UgJ2ludDE2JzpcbiAgICAgIGNhc2UgJ2ludDMyJzpcbiAgICAgIGNhc2UgJ3VpbnQzMic6XG4gICAgICBjYXNlICdib29sJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YSBhcyBUZW5zb3IuSW50ZWdlclR5cGU7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2RhdGEgdHlwZSBpcyBub3QgaW50ZWdlciAodWludDgsIGludDgsIHVpbnQxNiwgaW50MTYsIGludDMyLCB1aW50MzIsIGJvb2wpJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIGdldCB0aGUgdW5kZXJseWluZyBmbG9hdCB0ZW5zb3IgZGF0YS4gU2hvdWxkIG9ubHkgdXNlIHdoZW4gdHlwZSBpcyBvbmUgb2YgdGhlIGZvbGxvd2luZzogKEZMT0FULCBET1VCTEUpXG4gICAqL1xuICBnZXQgZmxvYXREYXRhKCkge1xuICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgICBjYXNlICdmbG9hdDMyJzpcbiAgICAgIGNhc2UgJ2Zsb2F0NjQnOlxuICAgICAgICByZXR1cm4gdGhpcy5kYXRhIGFzIFRlbnNvci5GbG9hdFR5cGU7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2RhdGEgdHlwZSBpcyBub3QgZmxvYXQgKGZsb2F0MzIsIGZsb2F0NjQpJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIGdldCB0aGUgdW5kZXJseWluZyBudW1iZXIgdGVuc29yIGRhdGEuIFNob3VsZCBvbmx5IHVzZSB3aGVuIHR5cGUgaXMgb25lIG9mIHRoZSBmb2xsb3dpbmc6IChVSU5UOCwgSU5UOCwgVUlOVDE2LFxuICAgKiBJTlQxNiwgSU5UMzIsIFVJTlQzMiwgQk9PTCwgRkxPQVQsIERPVUJMRSlcbiAgICovXG4gIGdldCBudW1iZXJEYXRhKCkge1xuICAgIGlmICh0aGlzLnR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gdGhpcy5kYXRhIGFzIFRlbnNvci5OdW1iZXJUeXBlO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd0eXBlIGNhbm5vdCBiZSBub24tbnVtYmVyIChzdHJpbmcpJyk7XG4gIH1cblxuICAvKipcbiAgICogZ2V0IHZhbHVlIG9mIGFuIGVsZW1lbnQgYXQgdGhlIGdpdmVuIGluZGljZXNcbiAgICovXG4gIGdldChpbmRpY2VzOiByZWFkb25seSBudW1iZXJbXSk6IFRlbnNvci5EYXRhVHlwZU1hcFtUZW5zb3IuRGF0YVR5cGVdW251bWJlcl0ge1xuICAgIHJldHVybiB0aGlzLmRhdGFbU2hhcGVVdGlsLmluZGljZXNUb09mZnNldChpbmRpY2VzLCB0aGlzLnN0cmlkZXMpXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBzZXQgdmFsdWUgb2YgYW4gZWxlbWVudCBhdCB0aGUgZ2l2ZW4gaW5kaWNlc1xuICAgKi9cbiAgc2V0KGluZGljZXM6IHJlYWRvbmx5IG51bWJlcltdLCB2YWx1ZTogVGVuc29yLkRhdGFUeXBlTWFwW1RlbnNvci5EYXRhVHlwZV1bbnVtYmVyXSkge1xuICAgIHRoaXMuZGF0YVtTaGFwZVV0aWwuaW5kaWNlc1RvT2Zmc2V0KGluZGljZXMsIHRoaXMuc3RyaWRlcyldID0gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogZ2V0IHRoZSB1bmRlcmx5aW5nIHRlbnNvciBkYXRhIGFzeW5jaHJvbm91c2x5XG4gICAqL1xuICBhc3luYyBnZXREYXRhKCk6IFByb21pc2U8VGVuc29yRGF0YT4ge1xuICAgIGlmICh0aGlzLmNhY2hlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuY2FjaGUgPSBhd2FpdCB0aGlzLmFzeW5jRGF0YVByb3ZpZGVyISh0aGlzLmRhdGFJZCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNhY2hlO1xuICB9XG5cbiAgLyoqXG4gICAqIGdldCB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSB0ZW5zb3JcbiAgICovXG4gIHB1YmxpYyByZWFkb25seSBzaXplOiBudW1iZXI7XG5cbiAgcHJpdmF0ZSBfc3RyaWRlczogcmVhZG9ubHkgbnVtYmVyW107XG4gIC8qKlxuICAgKiBnZXQgdGhlIHN0cmlkZXMgZm9yIGVhY2ggZGltZW5zaW9uXG4gICAqL1xuICBnZXQgc3RyaWRlcygpOiByZWFkb25seSBudW1iZXJbXSB7XG4gICAgaWYgKCF0aGlzLl9zdHJpZGVzKSB7XG4gICAgICB0aGlzLl9zdHJpZGVzID0gU2hhcGVVdGlsLmNvbXB1dGVTdHJpZGVzKHRoaXMuZGltcyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9zdHJpZGVzO1xuICB9XG5cbiAgY29uc3RydWN0b3IoXG4gICAgICAvKipcbiAgICAgICAqIGdldCB0aGUgZGltZW5zaW9ucyBvZiB0aGUgdGVuc29yXG4gICAgICAgKi9cbiAgICAgIHB1YmxpYyByZWFkb25seSBkaW1zOiByZWFkb25seSBudW1iZXJbXSxcbiAgICAgIC8qKlxuICAgICAgICogZ2V0IHRoZSB0eXBlIG9mIHRoZSB0ZW5zb3JcbiAgICAgICAqL1xuICAgICAgcHVibGljIHJlYWRvbmx5IHR5cGU6IFRlbnNvci5EYXRhVHlwZSwgcHJpdmF0ZSBkYXRhUHJvdmlkZXI/OiBEYXRhUHJvdmlkZXIsXG4gICAgICBwcml2YXRlIGFzeW5jRGF0YVByb3ZpZGVyPzogQXN5bmNEYXRhUHJvdmlkZXIsIHByaXZhdGUgY2FjaGU/OiBUZW5zb3JEYXRhLFxuICAgICAgLyoqXG4gICAgICAgKiBnZXQgdGhlIGRhdGEgSUQgdGhhdCB1c2VkIHRvIG1hcCB0byBhIHRlbnNvciBkYXRhXG4gICAgICAgKi9cbiAgICAgIHB1YmxpYyByZWFkb25seSBkYXRhSWQ6IEd1aWQgPSBHdWlkLmNyZWF0ZSgpKSB7XG4gICAgdGhpcy5zaXplID0gU2hhcGVVdGlsLnZhbGlkYXRlRGltc0FuZENhbGNTaXplKGRpbXMpO1xuICAgIGNvbnN0IHNpemUgPSB0aGlzLnNpemU7XG4gICAgY29uc3QgZW1wdHkgPSAoZGF0YVByb3ZpZGVyID09PSB1bmRlZmluZWQgJiYgYXN5bmNEYXRhUHJvdmlkZXIgPT09IHVuZGVmaW5lZCAmJiBjYWNoZSA9PT0gdW5kZWZpbmVkKTtcblxuICAgIGlmIChjYWNoZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoY2FjaGUubGVuZ3RoICE9PSBzaXplKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnB1dCBkaW1zIGRvZXNuXFwndCBtYXRjaCBkYXRhIGxlbmd0aC4nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmIChjYWNoZSAhPT0gdW5kZWZpbmVkICYmICghQXJyYXkuaXNBcnJheShjYWNoZSkgfHwgIWNhY2hlLmV2ZXJ5KGkgPT4gdHlwZW9mIGkgPT09ICdzdHJpbmcnKSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY2FjaGUgc2hvdWxkIGJlIGEgc3RyaW5nIGFycmF5Jyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbXB0eSkge1xuICAgICAgICB0aGlzLmNhY2hlID0gbmV3IEFycmF5PHN0cmluZz4oc2l6ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChjYWNoZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IGNvbnN0cnVjdG9yID0gZGF0YXZpZXdDb25zdHJ1Y3Rvcih0eXBlKTtcbiAgICAgICAgaWYgKCEoY2FjaGUgaW5zdGFuY2VvZiBjb25zdHJ1Y3RvcikpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBjYWNoZSBzaG91bGQgYmUgdHlwZSAke2NvbnN0cnVjdG9yLm5hbWV9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGVtcHR5KSB7XG4gICAgICAgIGNvbnN0IGJ1ZiA9IG5ldyBBcnJheUJ1ZmZlcihzaXplICogc2l6ZW9mKHR5cGUpKTtcbiAgICAgICAgdGhpcy5jYWNoZSA9IGNyZWF0ZVZpZXcoYnVmLCB0eXBlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ29uc3RydWN0IG5ldyBUZW5zb3IgZnJvbSBhIE9OTlggVGVuc29yIG9iamVjdFxuICAgKiBAcGFyYW0gdGVuc29yUHJvdG8gdGhlIE9OTlggVGVuc29yXG4gICAqL1xuICBzdGF0aWMgZnJvbVByb3RvKHRlbnNvclByb3RvOiBvbm54LklUZW5zb3JQcm90byk6IFRlbnNvciB7XG4gICAgaWYgKCF0ZW5zb3JQcm90bykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3QgY29uc3RydWN0IFZhbHVlIGZyb20gYW4gZW1wdHkgdGVuc29yJyk7XG4gICAgfVxuICAgIGNvbnN0IHR5cGUgPSBQcm90b1V0aWwudGVuc29yRGF0YVR5cGVGcm9tUHJvdG8odGVuc29yUHJvdG8uZGF0YVR5cGUhKTtcbiAgICBjb25zdCBkaW1zID0gUHJvdG9VdGlsLnRlbnNvckRpbXNGcm9tUHJvdG8odGVuc29yUHJvdG8uZGltcyEpO1xuXG4gICAgY29uc3QgdmFsdWUgPSBuZXcgVGVuc29yKGRpbXMsIHR5cGUpO1xuXG4gICAgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBXaGVuIGl0J3MgU1RSSU5HIHR5cGUsIHRoZSB2YWx1ZSBzaG91bGQgYWx3YXlzIGJlIHN0b3JlZCBpbiBmaWVsZFxuICAgICAgLy8gJ3N0cmluZ0RhdGEnXG4gICAgICB0ZW5zb3JQcm90by5zdHJpbmdEYXRhIS5mb3JFYWNoKChzdHIsIGkpID0+IHtcbiAgICAgICAgdmFsdWUuZGF0YVtpXSA9IGRlY29kZVV0ZjhTdHJpbmcoc3RyKTtcbiAgICAgIH0pO1xuXG4gICAgfSBlbHNlIGlmIChcbiAgICAgICAgdGVuc29yUHJvdG8ucmF3RGF0YSAmJiB0eXBlb2YgdGVuc29yUHJvdG8ucmF3RGF0YS5ieXRlTGVuZ3RoID09PSAnbnVtYmVyJyAmJlxuICAgICAgICB0ZW5zb3JQcm90by5yYXdEYXRhLmJ5dGVMZW5ndGggPiAwKSB7XG4gICAgICAvLyBOT1QgY29uc2lkZXJpbmcgc2VnbWVudCBmb3Igbm93IChJTVBPUlRBTlQpXG5cbiAgICAgIC8vIHBvcHVsYXRlIHZhbHVlIGZyb20gcmF3RGF0YVxuICAgICAgY29uc3QgZGF0YURlc3QgPSB2YWx1ZS5kYXRhO1xuICAgICAgY29uc3QgZGF0YVNvdXJjZSA9XG4gICAgICAgICAgbmV3IERhdGFWaWV3KHRlbnNvclByb3RvLnJhd0RhdGEuYnVmZmVyLCB0ZW5zb3JQcm90by5yYXdEYXRhLmJ5dGVPZmZzZXQsIHRlbnNvclByb3RvLnJhd0RhdGEuYnl0ZUxlbmd0aCk7XG4gICAgICBjb25zdCBlbGVtZW50U2l6ZSA9IHNpemVvZlByb3RvKHRlbnNvclByb3RvLmRhdGFUeXBlISk7XG4gICAgICBjb25zdCBsZW5ndGggPSB0ZW5zb3JQcm90by5yYXdEYXRhLmJ5dGVMZW5ndGggLyBlbGVtZW50U2l6ZTtcblxuICAgICAgaWYgKHRlbnNvclByb3RvLnJhd0RhdGEuYnl0ZUxlbmd0aCAlIGVsZW1lbnRTaXplICE9PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBidWZmZXIgbGVuZ3RoJyk7XG4gICAgICB9XG4gICAgICBpZiAoZGF0YURlc3QubGVuZ3RoICE9PSBsZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdidWZmZXIgbGVuZ3RoIG1pc21hdGNoJyk7XG4gICAgICB9XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgbiA9IHJlYWRQcm90byhkYXRhU291cmNlLCB0ZW5zb3JQcm90by5kYXRhVHlwZSEsIGkgKiBlbGVtZW50U2l6ZSk7XG4gICAgICAgIGRhdGFEZXN0W2ldID0gbjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcG9wdWxhdGUgdmFsdWUgZnJvbSBhcnJheVxuICAgICAgbGV0IGFycmF5OiBBcnJheTxudW1iZXJ8TG9uZz47XG4gICAgICBzd2l0Y2ggKHRlbnNvclByb3RvLmRhdGFUeXBlKSB7XG4gICAgICAgIGNhc2Ugb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5GTE9BVDpcbiAgICAgICAgICBhcnJheSA9IHRlbnNvclByb3RvLmZsb2F0RGF0YSE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2Ugb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5JTlQzMjpcbiAgICAgICAgY2FzZSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLklOVDE2OlxuICAgICAgICBjYXNlIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDE2OlxuICAgICAgICBjYXNlIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuSU5UODpcbiAgICAgICAgY2FzZSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQ4OlxuICAgICAgICBjYXNlIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuQk9PTDpcbiAgICAgICAgICBhcnJheSA9IHRlbnNvclByb3RvLmludDMyRGF0YSE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2Ugb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5JTlQ2NDpcbiAgICAgICAgICBhcnJheSA9IHRlbnNvclByb3RvLmludDY0RGF0YSE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2Ugb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5ET1VCTEU6XG4gICAgICAgICAgYXJyYXkgPSB0ZW5zb3JQcm90by5kb3VibGVEYXRhITtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQzMjpcbiAgICAgICAgY2FzZSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQ2NDpcbiAgICAgICAgICBhcnJheSA9IHRlbnNvclByb3RvLnVpbnQ2NERhdGEhO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIC8vIHNob3VsZCBuZXZlciBydW4gaGVyZVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndW5zcGVjaWZpYyBlcnJvcicpO1xuICAgICAgfVxuXG4gICAgICBpZiAoYXJyYXkgPT09IG51bGwgfHwgYXJyYXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZhaWxlZCB0byBwb3B1bGF0ZSBkYXRhIGZyb20gYSB0ZW5zb3Jwcm90byB2YWx1ZScpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBkYXRhID0gdmFsdWUuZGF0YTtcbiAgICAgIGlmIChkYXRhLmxlbmd0aCAhPT0gYXJyYXkubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYXJyYXkgbGVuZ3RoIG1pc21hdGNoJyk7XG4gICAgICB9XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IGFycmF5W2ldO1xuICAgICAgICBpZiAoTG9uZy5pc0xvbmcoZWxlbWVudCkpIHtcbiAgICAgICAgICBkYXRhW2ldID0gbG9uZ1RvTnVtYmVyKGVsZW1lbnQsIHRlbnNvclByb3RvLmRhdGFUeXBlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkYXRhW2ldID0gZWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgbmV3IFRlbnNvciBmcm9tIHJhdyBkYXRhXG4gICAqIEBwYXJhbSBkYXRhIHRoZSByYXcgZGF0YSBvYmplY3QuIFNob3VsZCBiZSBhIHN0cmluZyBhcnJheSBmb3IgJ3N0cmluZycgdGVuc29yLCBhbmQgdGhlIGNvcnJlc3BvbmRpbmcgdHlwZWQgYXJyYXlcbiAgICogZm9yIG90aGVyIHR5cGVzIG9mIHRlbnNvci5cbiAgICogQHBhcmFtIGRpbXMgdGhlIGRpbWVuc2lvbnMgb2YgdGhlIHRlbnNvclxuICAgKiBAcGFyYW0gdHlwZSB0aGUgdHlwZSBvZiB0aGUgdGVuc29yXG4gICAqL1xuICBzdGF0aWMgZnJvbURhdGEoZGF0YTogVGVuc29yLkRhdGFUeXBlTWFwW1RlbnNvci5EYXRhVHlwZV0sIGRpbXM6IHJlYWRvbmx5IG51bWJlcltdLCB0eXBlOiBUZW5zb3IuRGF0YVR5cGUpIHtcbiAgICByZXR1cm4gbmV3IFRlbnNvcihkaW1zLCB0eXBlLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZGF0YSk7XG4gIH1cblxuICBzdGF0aWMgZnJvbU9ydFRlbnNvcihvcnRUZW5zb3I6IG9ydEZicy5UZW5zb3IpIHtcbiAgICBpZiAoIW9ydFRlbnNvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3QgY29uc3RydWN0IFZhbHVlIGZyb20gYW4gZW1wdHkgdGVuc29yJyk7XG4gICAgfVxuICAgIGNvbnN0IGRpbXMgPSBQcm90b1V0aWwudGVuc29yRGltc0Zyb21PUlRGb3JtYXQob3J0VGVuc29yKTtcbiAgICBjb25zdCB0eXBlID0gUHJvdG9VdGlsLnRlbnNvckRhdGFUeXBlRnJvbVByb3RvKG9ydFRlbnNvci5kYXRhVHlwZSgpKTtcblxuICAgIGNvbnN0IHZhbHVlID0gbmV3IFRlbnNvcihkaW1zLCB0eXBlKTtcblxuICAgIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gV2hlbiBpdCdzIFNUUklORyB0eXBlLCB0aGUgdmFsdWUgc2hvdWxkIGFsd2F5cyBiZSBzdG9yZWQgaW4gZmllbGRcbiAgICAgIC8vICdzdHJpbmdEYXRhJ1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvcnRUZW5zb3Iuc3RyaW5nRGF0YUxlbmd0aCgpOyBpKyspIHtcbiAgICAgICAgdmFsdWUuZGF0YVtpXSA9IG9ydFRlbnNvci5zdHJpbmdEYXRhKGkpO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIGlmIChcbiAgICAgICAgb3J0VGVuc29yLnJhd0RhdGFBcnJheSgpICYmIHR5cGVvZiBvcnRUZW5zb3IucmF3RGF0YUxlbmd0aCgpID09PSAnbnVtYmVyJyAmJiBvcnRUZW5zb3IucmF3RGF0YUxlbmd0aCgpID4gMCkge1xuICAgICAgLy8gTk9UIGNvbnNpZGVyaW5nIHNlZ21lbnQgZm9yIG5vdyAoSU1QT1JUQU5UKVxuXG4gICAgICAvLyBwb3B1bGF0ZSB2YWx1ZSBmcm9tIHJhd0RhdGFcbiAgICAgIGNvbnN0IGRhdGFEZXN0ID0gdmFsdWUuZGF0YTtcbiAgICAgIGNvbnN0IGRhdGFTb3VyY2UgPSBuZXcgRGF0YVZpZXcoXG4gICAgICAgICAgb3J0VGVuc29yLnJhd0RhdGFBcnJheSgpIS5idWZmZXIsIG9ydFRlbnNvci5yYXdEYXRhQXJyYXkoKSEuYnl0ZU9mZnNldCwgb3J0VGVuc29yLnJhd0RhdGFMZW5ndGgoKSk7XG4gICAgICBjb25zdCBlbGVtZW50U2l6ZSA9IHNpemVvZlByb3RvKG9ydFRlbnNvci5kYXRhVHlwZSgpKTtcbiAgICAgIGNvbnN0IGxlbmd0aCA9IG9ydFRlbnNvci5yYXdEYXRhTGVuZ3RoKCkgLyBlbGVtZW50U2l6ZTtcblxuICAgICAgaWYgKG9ydFRlbnNvci5yYXdEYXRhTGVuZ3RoKCkgJSBlbGVtZW50U2l6ZSAhPT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYnVmZmVyIGxlbmd0aCcpO1xuICAgICAgfVxuICAgICAgaWYgKGRhdGFEZXN0Lmxlbmd0aCAhPT0gbGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYnVmZmVyIGxlbmd0aCBtaXNtYXRjaCcpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IG4gPSByZWFkUHJvdG8oZGF0YVNvdXJjZSwgb3J0VGVuc29yLmRhdGFUeXBlKCksIGkgKiBlbGVtZW50U2l6ZSk7XG4gICAgICAgIGRhdGFEZXN0W2ldID0gbjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNpemVvZih0eXBlOiBUZW5zb3IuRGF0YVR5cGUpOiBudW1iZXIge1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdib29sJzpcbiAgICBjYXNlICdpbnQ4JzpcbiAgICBjYXNlICd1aW50OCc6XG4gICAgICByZXR1cm4gMTtcbiAgICBjYXNlICdpbnQxNic6XG4gICAgY2FzZSAndWludDE2JzpcbiAgICAgIHJldHVybiAyO1xuICAgIGNhc2UgJ2ludDMyJzpcbiAgICBjYXNlICd1aW50MzInOlxuICAgIGNhc2UgJ2Zsb2F0MzInOlxuICAgICAgcmV0dXJuIDQ7XG4gICAgY2FzZSAnZmxvYXQ2NCc6XG4gICAgICByZXR1cm4gODtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBjYW5ub3QgY2FsY3VsYXRlIHNpemVvZigpIG9uIHR5cGUgJHt0eXBlfWApO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNpemVvZlByb3RvKHR5cGU6IG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGV8b3J0RmJzLlRlbnNvckRhdGFUeXBlKTogbnVtYmVyIHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQ4OlxuICAgIGNhc2Ugb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5JTlQ4OlxuICAgIGNhc2Ugb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5CT09MOlxuICAgICAgcmV0dXJuIDE7XG4gICAgY2FzZSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQxNjpcbiAgICBjYXNlIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuSU5UMTY6XG4gICAgICByZXR1cm4gMjtcbiAgICBjYXNlIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuRkxPQVQ6XG4gICAgY2FzZSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLklOVDMyOlxuICAgIGNhc2Ugb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5VSU5UMzI6XG4gICAgICByZXR1cm4gNDtcbiAgICBjYXNlIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuSU5UNjQ6XG4gICAgY2FzZSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLkRPVUJMRTpcbiAgICBjYXNlIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDY0OlxuICAgICAgcmV0dXJuIDg7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgY2Fubm90IGNhbGN1bGF0ZSBzaXplb2YoKSBvbiB0eXBlICR7b25ueC5UZW5zb3JQcm90by5EYXRhVHlwZVt0eXBlXX1gKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVWaWV3KGRhdGFCdWZmZXI6IEFycmF5QnVmZmVyLCB0eXBlOiBUZW5zb3IuRGF0YVR5cGUpIHtcbiAgcmV0dXJuIG5ldyAoZGF0YXZpZXdDb25zdHJ1Y3Rvcih0eXBlKSkoZGF0YUJ1ZmZlcik7XG59XG5cbmZ1bmN0aW9uIGRhdGF2aWV3Q29uc3RydWN0b3IodHlwZTogVGVuc29yLkRhdGFUeXBlKSB7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ2Jvb2wnOlxuICAgIGNhc2UgJ3VpbnQ4JzpcbiAgICAgIHJldHVybiBVaW50OEFycmF5O1xuICAgIGNhc2UgJ2ludDgnOlxuICAgICAgcmV0dXJuIEludDhBcnJheTtcbiAgICBjYXNlICdpbnQxNic6XG4gICAgICByZXR1cm4gSW50MTZBcnJheTtcbiAgICBjYXNlICd1aW50MTYnOlxuICAgICAgcmV0dXJuIFVpbnQxNkFycmF5O1xuICAgIGNhc2UgJ2ludDMyJzpcbiAgICAgIHJldHVybiBJbnQzMkFycmF5O1xuICAgIGNhc2UgJ3VpbnQzMic6XG4gICAgICByZXR1cm4gVWludDMyQXJyYXk7XG4gICAgY2FzZSAnaW50NjQnOlxuICAgICAgcmV0dXJuIEJpZ0ludDY0QXJyYXk7XG4gICAgY2FzZSAnZmxvYXQzMic6XG4gICAgICByZXR1cm4gRmxvYXQzMkFycmF5O1xuICAgIGNhc2UgJ2Zsb2F0NjQnOlxuICAgICAgcmV0dXJuIEZsb2F0NjRBcnJheTtcbiAgICBkZWZhdWx0OlxuICAgICAgLy8gc2hvdWxkIG5ldmVyIHJ1biB0byBoZXJlXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vuc3BlY2lmaWVkIGVycm9yJyk7XG4gIH1cbn1cblxuLy8gY29udmVydCBhIGxvbmcgbnVtYmVyIHRvIGEgMzItYml0IGludGVnZXIgKGNhc3QtZG93bilcbmZ1bmN0aW9uIGxvbmdUb051bWJlcihpOiBMb25nLCB0eXBlOiBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlfG9ydEZicy5UZW5zb3JEYXRhVHlwZSk6IG51bWJlciB7XG4gIC8vIElOVDY0LCBVSU5UMzIsIFVJTlQ2NFxuICBpZiAodHlwZSA9PT0gb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5JTlQ2NCB8fCB0eXBlID09PSBvcnRGYnMuVGVuc29yRGF0YVR5cGUuSU5UNjQpIHtcbiAgICBpZiAoaS5ncmVhdGVyVGhhbk9yRXF1YWwoMjE0NzQ4MzY0OCkgfHwgaS5sZXNzVGhhbigtMjE0NzQ4MzY0OCkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludDY0IGlzIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoXG4gICAgICB0eXBlID09PSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQzMiB8fCB0eXBlID09PSBvcnRGYnMuVGVuc29yRGF0YVR5cGUuVUlOVDMyIHx8XG4gICAgICB0eXBlID09PSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQ2NCB8fCB0eXBlID09PSBvcnRGYnMuVGVuc29yRGF0YVR5cGUuVUlOVDY0KSB7XG4gICAgaWYgKGkuZ3JlYXRlclRoYW5PckVxdWFsKDQyOTQ5NjcyOTYpIHx8IGkubGVzc1RoYW4oMCkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3VpbnQ2NCBpcyBub3Qgc3VwcG9ydGVkJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYG5vdCBhIExPTkcgdHlwZTogJHtvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlW3R5cGVdfWApO1xuICB9XG5cbiAgcmV0dXJuIGkudG9OdW1iZXIoKTtcbn1cblxuLy8gcmVhZCBvbmUgdmFsdWUgZnJvbSBUZW5zb3JQcm90b1xuZnVuY3Rpb24gcmVhZFByb3RvKHZpZXc6IERhdGFWaWV3LCB0eXBlOiBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlfG9ydEZicy5UZW5zb3JEYXRhVHlwZSwgYnl0ZU9mZnNldDogbnVtYmVyKTogbnVtYmVyIHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLkJPT0w6XG4gICAgY2FzZSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQ4OlxuICAgICAgcmV0dXJuIHZpZXcuZ2V0VWludDgoYnl0ZU9mZnNldCk7XG4gICAgY2FzZSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLklOVDg6XG4gICAgICByZXR1cm4gdmlldy5nZXRJbnQ4KGJ5dGVPZmZzZXQpO1xuICAgIGNhc2Ugb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5VSU5UMTY6XG4gICAgICByZXR1cm4gdmlldy5nZXRVaW50MTYoYnl0ZU9mZnNldCwgdHJ1ZSk7XG4gICAgY2FzZSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLklOVDE2OlxuICAgICAgcmV0dXJuIHZpZXcuZ2V0SW50MTYoYnl0ZU9mZnNldCwgdHJ1ZSk7XG4gICAgY2FzZSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLkZMT0FUOlxuICAgICAgcmV0dXJuIHZpZXcuZ2V0RmxvYXQzMihieXRlT2Zmc2V0LCB0cnVlKTtcbiAgICBjYXNlIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuSU5UMzI6XG4gICAgICByZXR1cm4gdmlldy5nZXRJbnQzMihieXRlT2Zmc2V0LCB0cnVlKTtcbiAgICBjYXNlIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDMyOlxuICAgICAgcmV0dXJuIHZpZXcuZ2V0VWludDMyKGJ5dGVPZmZzZXQsIHRydWUpO1xuICAgIGNhc2Ugb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5JTlQ2NDpcbiAgICAgIHJldHVybiBsb25nVG9OdW1iZXIoXG4gICAgICAgICAgTG9uZy5mcm9tQml0cyh2aWV3LmdldFVpbnQzMihieXRlT2Zmc2V0LCB0cnVlKSwgdmlldy5nZXRVaW50MzIoYnl0ZU9mZnNldCArIDQsIHRydWUpLCBmYWxzZSksIHR5cGUpO1xuICAgIGNhc2Ugb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5ET1VCTEU6XG4gICAgICByZXR1cm4gdmlldy5nZXRGbG9hdDY0KGJ5dGVPZmZzZXQsIHRydWUpO1xuICAgIGNhc2Ugb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5VSU5UNjQ6XG4gICAgICByZXR1cm4gbG9uZ1RvTnVtYmVyKFxuICAgICAgICAgIExvbmcuZnJvbUJpdHModmlldy5nZXRVaW50MzIoYnl0ZU9mZnNldCwgdHJ1ZSksIHZpZXcuZ2V0VWludDMyKGJ5dGVPZmZzZXQgKyA0LCB0cnVlKSwgdHJ1ZSksIHR5cGUpO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCByZWFkIGZyb20gRGF0YVZpZXcgZm9yIHR5cGUgJHtvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlW3R5cGVdfWApO1xuICB9XG59XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbi8qKlxuICogcmVwcmVzZW50IGEgdmVyc2lvbiBpcnJlbGV2YW50IGFic3RyYWN0aW9uIG9mIGZvciBHTFNMIHNvdXJjZSBjb2RlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgR2xzbCB7XG4gIHJlYWRvbmx5IHZlcnNpb246IHN0cmluZztcbiAgcmVhZG9ubHkgYXR0cmlidXRlOiBzdHJpbmc7XG4gIHJlYWRvbmx5IHZhcnlpbmdWZXJ0ZXg6IHN0cmluZztcbiAgcmVhZG9ubHkgdmFyeWluZ0ZyYWc6IHN0cmluZztcbiAgcmVhZG9ubHkgdGV4dHVyZTJEOiBzdHJpbmc7XG4gIHJlYWRvbmx5IG91dHB1dDogc3RyaW5nO1xuICByZWFkb25seSBvdXRwdXREZWNsYXJhdGlvbjogc3RyaW5nO1xufVxuXG5jb25zdCBHTFNMX0VTXzJfMDogR2xzbCA9IHtcbiAgdmVyc2lvbjogJycsXG4gIGF0dHJpYnV0ZTogJ2F0dHJpYnV0ZScsXG4gIHZhcnlpbmdWZXJ0ZXg6ICd2YXJ5aW5nJyxcbiAgdmFyeWluZ0ZyYWc6ICd2YXJ5aW5nJyxcbiAgdGV4dHVyZTJEOiAndGV4dHVyZTJEJyxcbiAgb3V0cHV0OiAnZ2xfRnJhZ0NvbG9yJyxcbiAgb3V0cHV0RGVjbGFyYXRpb246ICcnLFxufTtcbmNvbnN0IEdMU0xfRVNfM18wOiBHbHNsID0ge1xuICB2ZXJzaW9uOiAnI3ZlcnNpb24gMzAwIGVzJyxcbiAgYXR0cmlidXRlOiAnaW4nLFxuICB2YXJ5aW5nVmVydGV4OiAnb3V0JyxcbiAgdmFyeWluZ0ZyYWc6ICdpbicsXG4gIHRleHR1cmUyRDogJ3RleHR1cmUnLFxuICBvdXRwdXQ6ICdvdXRwdXRDb2xvcicsXG4gIG91dHB1dERlY2xhcmF0aW9uOiAnb3V0IHZlYzQgb3V0cHV0Q29sb3I7Jyxcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRHbHNsKHZlcnNpb246IDF8Mikge1xuICByZXR1cm4gdmVyc2lvbiA9PT0gMSA/IEdMU0xfRVNfMl8wIDogR0xTTF9FU18zXzA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRWZXJ0ZXhTaGFkZXJTb3VyY2UodmVyc2lvbjogMXwyKTogc3RyaW5nIHtcbiAgY29uc3QgZ2xzbCA9IGdldEdsc2wodmVyc2lvbik7XG4gIHJldHVybiBgJHtnbHNsLnZlcnNpb259XG4gICAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG4gICAgICAke2dsc2wuYXR0cmlidXRlfSB2ZWMzIHBvc2l0aW9uO1xuICAgICAgJHtnbHNsLmF0dHJpYnV0ZX0gdmVjMiB0ZXh0dXJlQ29vcmQ7XG5cbiAgICAgICR7Z2xzbC52YXJ5aW5nVmVydGV4fSB2ZWMyIFRleENvb3JkcztcblxuICAgICAgdm9pZCBtYWluKClcbiAgICAgIHtcbiAgICAgICAgICBnbF9Qb3NpdGlvbiA9IHZlYzQocG9zaXRpb24sIDEuMCk7XG4gICAgICAgICAgVGV4Q29vcmRzID0gdGV4dHVyZUNvb3JkO1xuICAgICAgfWA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRGcmFnU2hhZGVyUHJlYW1ibGUodmVyc2lvbjogMXwyKTogc3RyaW5nIHtcbiAgY29uc3QgZ2xzbCA9IGdldEdsc2wodmVyc2lvbik7XG4gIHJldHVybiBgJHtnbHNsLnZlcnNpb259XG4gICAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuICAgIHByZWNpc2lvbiBoaWdocCBpbnQ7XG4gICAgcHJlY2lzaW9uIGhpZ2hwIHNhbXBsZXIyRDtcbiAgICAke2dsc2wudmFyeWluZ0ZyYWd9IHZlYzIgVGV4Q29vcmRzO1xuICAgICR7Z2xzbC5vdXRwdXREZWNsYXJhdGlvbn1cbiAgICBjb25zdCB2ZWMyIGhhbGZDUiA9IHZlYzIoMC41LCAwLjUpO1xuXG4gICAgLy8gQ3VzdG9tIHZlY3RvciB0eXBlcyB0byBoYW5kbGUgaGlnaGVyIGRpbWVuYWxpdGllcy5cbiAgICBzdHJ1Y3QgaXZlYzVcbiAgICB7XG4gICAgICBpbnQgeDtcbiAgICAgIGludCB5O1xuICAgICAgaW50IHo7XG4gICAgICBpbnQgdztcbiAgICAgIGludCB1O1xuICAgIH07XG5cbiAgICBzdHJ1Y3QgaXZlYzZcbiAgICB7XG4gICAgICBpbnQgeDtcbiAgICAgIGludCB5O1xuICAgICAgaW50IHo7XG4gICAgICBpbnQgdztcbiAgICAgIGludCB1O1xuICAgICAgaW50IHY7XG4gICAgfTtcblxuICAgIGludCBpbW9kKGludCB4LCBpbnQgeSkge1xuICAgICAgcmV0dXJuIHggLSB5ICogKHggLyB5KTtcbiAgICB9XG5cbiAgICBgO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGVmYXVsdEZyYWdTaGFkZXJNYWluKHZlcnNpb246IDF8Miwgb3V0cHV0U2hhcGVMZW5ndGg6IG51bWJlcik6IHN0cmluZyB7XG4gIGNvbnN0IGdsc2wgPSBnZXRHbHNsKHZlcnNpb24pO1xuICByZXR1cm4gYFxuICB2b2lkIG1haW4oKSB7XG4gICAgaW50IGluZGljZXNbJHtvdXRwdXRTaGFwZUxlbmd0aH1dO1xuICAgIHRvVmVjKFRleENvb3JkcywgaW5kaWNlcyk7XG4gICAgdmVjNCByZXN1bHQgPSB2ZWM0KHByb2Nlc3MoaW5kaWNlcykpO1xuICAgICR7Z2xzbC5vdXRwdXR9ID0gcmVzdWx0O1xuICB9XG4gIGA7XG59XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7VGVuc29yfSBmcm9tICcuLi8uLi90ZW5zb3InO1xuXG4vKipcbiAqIExheW91dCBpbmZvIGlzIHVzZWQgZm9yIG1hcHBpbmcgbi1kaW1lbnNpb25hbCBhcnJheSB0byAyRCB0ZXh0dXJlc1xuICogVGhlIGxheW91dCBpcyBjcmVhdGVkIGJ5IHRoZSBUZXh0dXJlTGF5b3V0U3RyYXRlZ3kgYmFzZWQgb25cbiAqIHRoZSBUZW5zb3IncyBkaW1lbnNpb25zIGFuZCBzdHJpZGVzXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVGV4dHVyZUxheW91dCB7XG4gIHdpZHRoOiBudW1iZXI7XG4gIGhlaWdodDogbnVtYmVyO1xuICAvKipcbiAgICogc3BlY2lmeSB0aGUgbnVtYmVyIG9mIHZhbHVlIHRoYXQgZW5jb2RlZCBpbiBhIHNpbmdsZSBwaXhlbFxuICAgKi9cbiAgY2hhbm5lbHM6IDF8MnwzfDQ7XG4gIC8qKlxuICAgKiB3aGV0aGVyIGluIHBhY2tlZCBtb2RlIG9yIG5vdFxuICAgKi9cbiAgaXNQYWNrZWQ/OiBib29sZWFuO1xuICAvKipcbiAgICogdGhlIG5vcm1hbGl6ZWQgc2hhcGVcbiAgICovXG4gIHNoYXBlOiByZWFkb25seSBudW1iZXJbXTtcbiAgLyoqXG4gICAqIHRoZSBzdHJpZGUgb2YgZWFjaCBkaW1lbnNpb25zLCBjYWxjdWxhdGVkIGFjY29yZGluZyB0byBzaGFwZVxuICAgKi9cbiAgc3RyaWRlczogcmVhZG9ubHkgbnVtYmVyW107XG4gIC8qKlxuICAgKiB0aGUgb3JpZ2luYWwgc2hhcGUoZGltcykgb2YgdGhlIGNvcnJlc3BvbmRpbmcgdGVuc29yXG4gICAqL1xuICB1bnBhY2tlZFNoYXBlOiByZWFkb25seSBudW1iZXJbXTtcblxuICByZXZlcnNlZFdIPzogYm9vbGVhbjtcbn1cbmV4cG9ydCBpbnRlcmZhY2UgVGV4dHVyZURhdGEgZXh0ZW5kcyBUZXh0dXJlTGF5b3V0IHtcbiAgdGVuc29yOiBUZW5zb3I7XG4gIHRleHR1cmU6IFdlYkdMVGV4dHVyZTtcbn1cblxuZXhwb3J0IGVudW0gVGV4dHVyZVR5cGUge1xuICB1bnBhY2tlZCwgICAgICAgICAgICAgIC8vIDwtLSBub3JtYWwgdW5wYWNrZWQgdGV4dHVyZVxuICB1bnBhY2tlZFJldmVyc2VkLCAgICAgIC8vIDwtLSB1bnBhY2tlZCB0ZXh0dXJlIHVzZWQgaW4gb2xkIE9OTlguanMgaW1wbGVtZW50YXRpb24gKGRlcHJlY2F0ZWQpXG4gIHBhY2tlZCwgICAgICAgICAgICAgICAgLy8gPC0tIG5vcm1hbCBwYWNrZWQgdGV4dHVyZVxuICBkb3dubG9hZFVpbnQ4QXNGbG9hdCwgIC8vIDwtLSBPTkxZIHVzZWQgaW4gdGV4dHVyZSBkb3dubG9hZGluZyBmb3IgaU9TIGRldmljZXNcbiAgcGFja2VkTGFzdERpbWVuc2lvbiAgICAvLyA8LS0gT05MWSB1c2VkIGluIG9sZCBPTk5YLmpzIENvbnYgaW1wbGVtZW50YXRpb24gZm9yIGlucHV0IFcgKGRlcHJlY2F0ZWQpXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVGVuc29ySW5mbyB7XG4gIGlkPzogVGVuc29yLklkO1xuICBkaW1zOiByZWFkb25seSBudW1iZXJbXTtcbiAgdHlwZTogVGVuc29yLkRhdGFUeXBlO1xuICB0ZXh0dXJlVHlwZTogVGV4dHVyZVR5cGU7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvZ3JhbVZhcmlhYmxlIHtcbiAgdHlwZTogJ2Zsb2F0J3wnaW50JztcbiAgbmFtZTogc3RyaW5nO1xuICBhcnJheUxlbmd0aD86IG51bWJlcjtcbiAgZGF0YTogbnVtYmVyfG51bWJlcltdO1xufVxuXG4vKipcbiAqIEEgc2V0IG9mIG1ldGFkYXRhIG9mIGEgc2hhZGVyIHByb2dyYW0uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUHJvZ3JhbU1ldGFkYXRhIHtcbiAgLyoqXG4gICAqIHRoZSBuYW1lIG9mIHRoZSBwcm9ncmFtLiB1c2VkIGZvciBkZWJ1Z2dpbmcgYW5kIHByb2ZpbGluZ1xuICAgKi9cbiAgbmFtZTogc3RyaW5nO1xuICAvKipcbiAgICogdGV4dHVyZSB0eXBlcyBmb3IgZWFjaCBpbnB1dFxuICAgKi9cbiAgaW5wdXRUeXBlczogVGV4dHVyZVR5cGVbXTtcbiAgLyoqXG4gICAqIG5hbWVzIG9mIGVhY2ggaW5wdXRcbiAgICovXG4gIGlucHV0TmFtZXM6IHN0cmluZ1tdO1xuICAvKipcbiAgICogYW4gb3B0aW9uYWwgc3RyaW5nIGFzIGEgY2FjaGUgaGludCBpbiB0aGUgYXJ0aWZhY3QgY2FjaGVcbiAgICovXG4gIGNhY2hlSGludD86IHN0cmluZztcbn1cblxuLyoqXG4gKiBBIFByb2dyYW1JbmZvTG9hZGVyIGFsbG93c1xuICovXG5leHBvcnQgaW50ZXJmYWNlIFByb2dyYW1JbmZvTG9hZGVyIGV4dGVuZHMgUHJvZ3JhbU1ldGFkYXRhIHtcbiAgLyoqXG4gICAqIGEgZnVuY3Rpb24gdG8gZ2V0IHRoZSBwcm9ncmFtIGluZm9cbiAgICovXG4gIGdldCgpOiBQcm9ncmFtSW5mbztcbn1cblxuLyoqXG4gKiBBIHNldCBvZiBkYXRhIHRoYXQgcmVwcmVzZW50IGEgc2hhZGVyIHByb2dyYW1cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBQcm9ncmFtSW5mbyBleHRlbmRzIFByb2dyYW1NZXRhZGF0YSB7XG4gIC8qKlxuICAgKiBpbmZvcm1hdGlvbiBvZiB1bmlmb3JtIHZhcmlhYmxlc1xuICAgKi9cbiAgdmFyaWFibGVzPzogUHJvZ3JhbVZhcmlhYmxlW107XG4gIC8qKlxuICAgKiB0ZW5zb3IgaW5mbyBmb3Igb3V0cHV0XG4gICAqL1xuICBvdXRwdXQ6IFRlbnNvckluZm87XG4gIC8qKlxuICAgKiB0aGUgc2hhZGVyJ3MgcHJvY2Vzc2luZyBzb3VyY2UgY29kZVxuICAgKi9cbiAgc2hhZGVyU291cmNlOiBzdHJpbmc7XG4gIC8qKlxuICAgKiB3aGV0aGVyIHRoZSBzaGFkZXIgc291cmNlIGNvbnRhaW5zIGEgY3VzdG9taXplZCBtYWluIGZ1bmN0aW9uIGltcGxlbWVudGF0aW9uXG4gICAqL1xuICBoYXNNYWluPzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBWYXJpYWJsZUluZm8ge1xuICB0eXBlOiAnZmxvYXQnfCdpbnQnO1xuICBuYW1lOiBzdHJpbmc7XG4gIGFycmF5TGVuZ3RoPzogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFByb2dyYW1WYXJpYWJsZSB7XG4gIHR5cGU6ICdmbG9hdCd8J2ludCc7XG4gIG5hbWU6IHN0cmluZztcbiAgYXJyYXlMZW5ndGg/OiBudW1iZXI7XG4gIGRhdGE6IG51bWJlcnxudW1iZXJbXTtcbn1cblxuLyoqXG4gKiBJbmZvcm1hdGlvbiBvZiB1bmlmb3JtcyB0aGF0IHNoYWRlciB1c2VzXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVW5pZm9ybUluZm8ge1xuICB0eXBlOiAnc2FtcGxlcjJEJ3xWYXJpYWJsZUluZm9bJ3R5cGUnXTtcbiAgbmFtZTogc3RyaW5nO1xuICBhcnJheUxlbmd0aD86IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVbmlmb3JtTG9jYXRpb24gZXh0ZW5kcyBVbmlmb3JtSW5mbyB7XG4gIGxvY2F0aW9uOiBXZWJHTFVuaWZvcm1Mb2NhdGlvbjtcbn1cblxuLyoqXG4gKiBBcnRpZmFjdCBpcyB0aGUgcmVzdWx0IG9mIGNvbXBpbGF0aW9uXG4gKiBJdCBkb2VzIG5vdCBjb250YWluIGlucHV0IG9mIG91dHB1dCBkYXRhXG4gKiBIb3dldmVyIGFueXRoaW5nIHRoYXQgY291bGQgYmUgcnVuIGFzIGEgXCJwcm9ncmFtXCJcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBBcnRpZmFjdCB7XG4gIHByb2dyYW1JbmZvOiBQcm9ncmFtSW5mbztcbiAgcHJvZ3JhbTogV2ViR0xQcm9ncmFtO1xuICB1bmlmb3JtTG9jYXRpb25zOiBVbmlmb3JtTG9jYXRpb25bXTtcbiAgYXR0cmliTG9jYXRpb25zOiB7cG9zaXRpb246IG51bWJlcjsgdGV4dHVyZUNvb3JkOiBudW1iZXJ9O1xufVxuZXhwb3J0IGRlY2xhcmUgbmFtZXNwYWNlIEFydGlmYWN0IHtcbiAgdHlwZSBVbmlmb3JtTG9jYXRpb25zID0gQXJ0aWZhY3RbJ3VuaWZvcm1Mb2NhdGlvbnMnXTtcbiAgdHlwZSBBdHRyaWJMb2NhdGlvbnMgPSBBcnRpZmFjdFsnYXR0cmliTG9jYXRpb25zJ107XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVW5pZm9ybURhdGEge1xuICBbbmFtZTogc3RyaW5nXTogbnVtYmVyfG51bWJlcltdO1xufVxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge2Fzc2VydH0gZnJvbSAnLi4vLi4vdXRpbCc7XG4vKipcbiAqIEdpdmVuIGEgbm9uIFJHQkEgc2hhcGUgY2FsY3VsYXRlIHRoZSBSIHZlcnNpb25cbiAqIEl0IGlzIGFzc3VtZWQgdGhhdCB0aGUgZGltZW5zaW9ucyBhcmUgbXVsdGlwbGVzIG9mIGdpdmVuIGNoYW5uZWxzXG4gKiBOT1RFOiBpdCBpcyBhbHdheXMgdGhlIGxhc3QgZGltIHRoYXQgZ2V0cyBwYWNrZWQuXG4gKiBAcGFyYW0gdW5wYWNrZWRTaGFwZSBvcmlnaW5hbCBzaGFwZSB0byBjcmVhdGUgYSBwYWNrZWQgdmVyc2lvbiBmcm9tXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRQYWNrZWRTaGFwZSh1bnBhY2tlZFNoYXBlOiByZWFkb25seSBudW1iZXJbXSk6IHJlYWRvbmx5IG51bWJlcltdIHtcbiAgY29uc3QgbGVuID0gdW5wYWNrZWRTaGFwZS5sZW5ndGg7XG4gIHJldHVybiB1bnBhY2tlZFNoYXBlLnNsaWNlKDAsIGxlbiAtIDEpLmNvbmNhdCh1bnBhY2tlZFNoYXBlW2xlbiAtIDFdIC8gNCk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZXBlYXRlZFRyeShcbiAgICBjaGVja0ZuOiAoKSA9PiBib29sZWFuLCBkZWxheUZuID0gKF9jb3VudGVyOiBudW1iZXIpID0+IDAsIG1heENvdW50ZXI/OiBudW1iZXIpOiBQcm9taXNlPHZvaWQ+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlPHZvaWQ+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBsZXQgdHJ5Q291bnQgPSAwO1xuXG4gICAgY29uc3QgdHJ5Rm4gPSAoKSA9PiB7XG4gICAgICBpZiAoY2hlY2tGbigpKSB7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0cnlDb3VudCsrO1xuXG4gICAgICBjb25zdCBuZXh0QmFja29mZiA9IGRlbGF5Rm4odHJ5Q291bnQpO1xuXG4gICAgICBpZiAobWF4Q291bnRlciAhPSBudWxsICYmIHRyeUNvdW50ID49IG1heENvdW50ZXIpIHtcbiAgICAgICAgcmVqZWN0KCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHNldFRpbWVvdXQodHJ5Rm4sIG5leHRCYWNrb2ZmKTtcbiAgICB9O1xuXG4gICAgdHJ5Rm4oKTtcbiAgfSk7XG59XG5cbi8qKlxuICogR2VuZXJhdGVzIHRoZSBmdW5jdGlvbiBuYW1lIGZyb20gYW4gaW5wdXQgc2FtcGxlciBuYW1lLlxuICogQHBhcmFtIHNhbXBsZXJOYW1lIE5hbWUgb2YgdGhlIHNhbXBsZXIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZVNoYWRlckZ1bmNOYW1lRnJvbUlucHV0U2FtcGxlck5hbWUoc2FtcGxlck5hbWU6IHN0cmluZyk6IHN0cmluZyB7XG4gIGFzc2VydCh0eXBlb2Ygc2FtcGxlck5hbWUgIT09ICd1bmRlZmluZWQnICYmIHNhbXBsZXJOYW1lLmxlbmd0aCAhPT0gMCwgKCkgPT4gJ2VtcHR5IHN0cmluZyBmb3VuZCBmb3Igc2FtcGxlciBuYW1lJyk7XG4gIHJldHVybiAnZ2V0JyArIHNhbXBsZXJOYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc2FtcGxlck5hbWUuc2xpY2UoMSk7XG59XG5cbi8qKlxuICogR2VuZXJhdGVzIHRoZSBmdW5jdGlvbiBuYW1lIGZyb20gYW4gaW5wdXQgc2FtcGxlciBuYW1lIGF0IG91dHB1dCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSBzYW1wbGVyTmFtZSBOYW1lIG9mIHRoZSBzYW1wbGVyLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVTaGFkZXJGdW5jTmFtZUZyb21JbnB1dFNhbXBsZXJOYW1lQXRPdXRDb29yZHMoc2FtcGxlck5hbWU6IHN0cmluZyk6IHN0cmluZyB7XG4gIGFzc2VydCh0eXBlb2Ygc2FtcGxlck5hbWUgIT09ICd1bmRlZmluZWQnICYmIHNhbXBsZXJOYW1lLmxlbmd0aCAhPT0gMCwgKCkgPT4gJ2VtcHR5IHN0cmluZyBmb3VuZCBmb3Igc2FtcGxlciBuYW1lJyk7XG4gIHJldHVybiAnZ2V0JyArIHNhbXBsZXJOYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc2FtcGxlck5hbWUuc2xpY2UoMSkgKyAnQXRPdXRDb29yZHMnO1xufVxuXG4vKiogUmV0dXJucyBhIG5ldyBpbnB1dCBzaGFwZSAoYSBjb3B5KSB0aGF0IGhhcyBhIHNxdWVlemVkIGxvZ2ljYWwgc2hhcGUuICovXG5leHBvcnQgZnVuY3Rpb24gc3F1ZWV6ZUlucHV0U2hhcGUoaW5wdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sIHNxdWVlemVkU2hhcGU6IG51bWJlcltdKTogbnVtYmVyW10ge1xuICAvLyBEZWVwIGNvcHkuXG4gIGxldCBuZXdJbnB1dFNoYXBlOiBudW1iZXJbXSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoaW5wdXRTaGFwZSkpO1xuICBuZXdJbnB1dFNoYXBlID0gc3F1ZWV6ZWRTaGFwZTtcbiAgcmV0dXJuIG5ld0lucHV0U2hhcGU7XG59XG5cbi8qKiBSZXR1cm5zIGEgbGlzdCBvZiBzcXVlZXplZCBwYXJhbWV0ZXJzIGZvciBzaGFkZXIgZnVuY3Rpb25zICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3F1ZWV6ZWRQYXJhbXMocGFyYW1zOiBzdHJpbmdbXSwga2VwdERpbXM6IG51bWJlcltdKTogc3RyaW5nIHtcbiAgcmV0dXJuIGtlcHREaW1zLm1hcChkID0+IHBhcmFtc1tkXSkuam9pbignLCAnKTtcbn1cblxuLyoqIFJldHVybnMgdGhlIGRhdGEgdHlwZSBmb3IgZGlmZmVyZW50IHJhbmtzLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldENvb3Jkc0RhdGFUeXBlKHJhbms6IG51bWJlcik6IHN0cmluZyB7XG4gIGlmIChyYW5rIDw9IDEpIHtcbiAgICByZXR1cm4gJ2ludCc7XG4gIH0gZWxzZSBpZiAocmFuayA9PT0gMikge1xuICAgIHJldHVybiAnaXZlYzInO1xuICB9IGVsc2UgaWYgKHJhbmsgPT09IDMpIHtcbiAgICByZXR1cm4gJ2l2ZWMzJztcbiAgfSBlbHNlIGlmIChyYW5rID09PSA0KSB7XG4gICAgcmV0dXJuICdpdmVjNCc7XG4gIH0gZWxzZSBpZiAocmFuayA9PT0gNSkge1xuICAgIHJldHVybiAnaXZlYzUnO1xuICB9IGVsc2UgaWYgKHJhbmsgPT09IDYpIHtcbiAgICByZXR1cm4gJ2l2ZWM2JztcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBFcnJvcihgR1BVIGZvciByYW5rICR7cmFua30gaXMgbm90IHlldCBzdXBwb3J0ZWRgKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0R2xDaGFubmVscyhyYW5rID0gNik6IHN0cmluZ1tdIHtcbiAgcmV0dXJuIFsneCcsICd5JywgJ3onLCAndycsICd1JywgJ3YnXS5zbGljZSgwLCByYW5rKTtcbn1cbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtnZXRHbENoYW5uZWxzfSBmcm9tICcuLi91dGlscyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRWZWNDaGFubmVscyhuYW1lOiBzdHJpbmcsIHJhbms6IG51bWJlcik6IHN0cmluZ1tdIHtcbiAgcmV0dXJuIGdldEdsQ2hhbm5lbHMocmFuaykubWFwKGQgPT4gYCR7bmFtZX0uJHtkfWApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q2hhbm5lbHMobmFtZTogc3RyaW5nLCByYW5rOiBudW1iZXIpOiBzdHJpbmdbXSB7XG4gIGlmIChyYW5rID09PSAxKSB7XG4gICAgcmV0dXJuIFtuYW1lXTtcbiAgfVxuICByZXR1cm4gZ2V0VmVjQ2hhbm5lbHMobmFtZSwgcmFuayk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1bnBhY2tGcm9tQ2hhbm5lbCgpOiBzdHJpbmcge1xuICByZXR1cm4gYFxuICAgIGZsb2F0IGdldENoYW5uZWwodmVjNCBmcmFnLCBpbnQgZGltKSB7XG4gICAgICBpbnQgbW9kQ29vcmQgPSBpbW9kKGRpbSwgMik7XG4gICAgICByZXR1cm4gbW9kQ29vcmQgPT0gMCA/IGZyYWcuciA6IGZyYWcuZztcbiAgICB9XG5cbiAgICBmbG9hdCBnZXRDaGFubmVsKHZlYzQgZnJhZywgdmVjMiBpbm5lckRpbXMpIHtcbiAgICAgIHZlYzIgbW9kQ29vcmQgPSBtb2QoaW5uZXJEaW1zLCAyLik7XG4gICAgICByZXR1cm4gbW9kQ29vcmQueCA9PSAwLiA/XG4gICAgICAgIChtb2RDb29yZC55ID09IDAuID8gZnJhZy5yIDogZnJhZy5nKSA6XG4gICAgICAgIChtb2RDb29yZC55ID09IDAuID8gZnJhZy5iIDogZnJhZy5hKTtcbiAgICB9XG4gIGA7XG59XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7VGVuc29yfSBmcm9tICcuLi8uLi8uLi90ZW5zb3InO1xuaW1wb3J0IHtnZXRHbHNsfSBmcm9tICcuLi9nbHNsLXNvdXJjZSc7XG5pbXBvcnQge1dlYkdMSW5mZXJlbmNlSGFuZGxlcn0gZnJvbSAnLi4vaW5mZXJlbmNlLWhhbmRsZXInO1xuaW1wb3J0IHtQcm9ncmFtSW5mbywgUHJvZ3JhbUluZm9Mb2FkZXIsIFRleHR1cmVUeXBlfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQge2dldENvb3Jkc0RhdGFUeXBlfSBmcm9tICcuLi91dGlscyc7XG5cbmltcG9ydCB7Z2V0Q2hhbm5lbHN9IGZyb20gJy4vcGFja2luZy11dGlscyc7XG5cbmNvbnN0IHBhY2tQcm9ncmFtTWV0YWRhdGEgPSB7XG4gIG5hbWU6ICdwYWNrJyxcbiAgaW5wdXROYW1lczogWydBJ10sXG4gIGlucHV0VHlwZXM6IFtUZXh0dXJlVHlwZS51bnBhY2tlZFJldmVyc2VkXVxufTtcblxuY29uc3QgY3JlYXRlUGFja1Byb2dyYW1JbmZvID0gKGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXQ6IFRlbnNvcik6IFByb2dyYW1JbmZvID0+IHtcbiAgY29uc3QgZ2xzbCA9IGdldEdsc2woaGFuZGxlci5zZXNzaW9uLmJhY2tlbmQuZ2xDb250ZXh0LnZlcnNpb24pO1xuICBjb25zdCBpbnB1dFNoYXBlID0gaW5wdXQuZGltcztcblxuICBjb25zdCBpbnB1dFJhbmsgPSBpbnB1dFNoYXBlLmxlbmd0aDtcbiAgLy8gY3JlYXRlVGV4dHVyZUxheW91dEZyb21TaGFwZSB3b24ndCBjaGFuZ2Ugb3V0cHV0IHJhbmsuIE5lZWQgdG8gdmVyaWZ5IGJ5IHJ1bm5pbmcgdGVzdHNcbiAgY29uc3Qgb3V0cHV0UmFuayA9IGlucHV0LmRpbXMubGVuZ3RoO1xuXG4gIGNvbnN0IGNvb3Jkc0RhdGFUeXBlID0gZ2V0Q29vcmRzRGF0YVR5cGUob3V0cHV0UmFuayk7XG4gIGNvbnN0IGNoYW5uZWxzID0gZ2V0Q2hhbm5lbHMoJ3JjJywgb3V0cHV0UmFuayk7XG4gIGNvbnN0IHNldHVwID0gZ2V0U2V0dXAob3V0cHV0UmFuaywgY2hhbm5lbHMsIGlucHV0U2hhcGVbaW5wdXRTaGFwZS5sZW5ndGggLSAyXSwgaW5wdXRTaGFwZVtpbnB1dFNoYXBlLmxlbmd0aCAtIDFdKTtcblxuICBsZXQgcmV2ZXJzZWRJbnB1dFdIO1xuICBpZiAoaW5wdXRSYW5rID09PSAwKSB7XG4gICAgcmV2ZXJzZWRJbnB1dFdIID0gWzEsIDFdO1xuICB9IGVsc2UgaWYgKGlucHV0UmFuayA9PT0gMSkge1xuICAgIHJldmVyc2VkSW5wdXRXSCA9IFtpbnB1dFNoYXBlWzBdLCAxXTtcbiAgfSBlbHNlIHtcbiAgICByZXZlcnNlZElucHV0V0ggPSBbaW5wdXRTaGFwZVtvdXRwdXRSYW5rIC0gMV0sIGlucHV0U2hhcGVbb3V0cHV0UmFuayAtIDJdXTtcbiAgfVxuICBjb25zdCBvdXRPZkJvdW5kc0NvbmRpdGlvbiA9IGdldE91dE9mQm91bmRzQ29uZGl0aW9uKG91dHB1dFJhbmssIHJldmVyc2VkSW5wdXRXSCwgY2hhbm5lbHMpO1xuICBjb25zdCBvdXRwdXQgPSBnZXRPdXRwdXQoaW5wdXRTaGFwZSwgY2hhbm5lbHMpO1xuXG4gIGNvbnN0IHNoYWRlclNvdXJjZSA9IGBcbiAgICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICAgICR7Y29vcmRzRGF0YVR5cGV9IHJjID0gZ2V0T3V0cHV0Q29vcmRzKCk7XG5cbiAgICAgICAgICBpZigke291dE9mQm91bmRzQ29uZGl0aW9ufSkge1xuICAgICAgICAgICAgJHtnbHNsLm91dHB1dH0gPSB2ZWM0KDApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAke3NldHVwfVxuXG4gICAgICAgICAgICAke2dsc2wub3V0cHV0fSA9IHZlYzQoJHtvdXRwdXR9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIGA7XG4gIHJldHVybiB7XG4gICAgLi4ucGFja1Byb2dyYW1NZXRhZGF0YSxcbiAgICBoYXNNYWluOiB0cnVlLFxuICAgIG91dHB1dDoge2RpbXM6IGlucHV0LmRpbXMsIHR5cGU6IGlucHV0LnR5cGUsIHRleHR1cmVUeXBlOiBUZXh0dXJlVHlwZS5wYWNrZWR9LFxuICAgIHNoYWRlclNvdXJjZVxuICB9O1xufTtcblxuZXhwb3J0IGNvbnN0IGNyZWF0ZVBhY2tQcm9ncmFtSW5mb0xvYWRlciA9IChoYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0OiBUZW5zb3IpOiBQcm9ncmFtSW5mb0xvYWRlciA9PlxuICAgICh7Li4ucGFja1Byb2dyYW1NZXRhZGF0YSwgZ2V0OiAoKSA9PiBjcmVhdGVQYWNrUHJvZ3JhbUluZm8oaGFuZGxlciwgaW5wdXQpfSk7XG5cbi8qKlxuICogY2hlY2sgb3V0cHV0IGNvb3JkaW5hdGUgbG9jYXRpb24gYW5kIHJldHVybiBmYWxzZSBpZiBpdCBpcyBvdXRzaWRlIGlucHV0J3Mgd2lkdGgvaGVpZ2h0IGJvdW5kYXJ5XG4gKi9cbmZ1bmN0aW9uIGdldE91dE9mQm91bmRzQ29uZGl0aW9uKHJhbms6IG51bWJlciwgc2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLCBkaW1zOiBzdHJpbmdbXSk6IHN0cmluZyB7XG4gIGlmIChyYW5rID09PSAwKSB7XG4gICAgcmV0dXJuICdmYWxzZSc7XG4gIH1cbiAgaWYgKHJhbmsgPT09IDEpIHtcbiAgICByZXR1cm4gYHJjID4gJHtzaGFwZVswXX1gO1xuICB9XG5cbiAgbGV0IGNvbmQgPSAnJztcbiAgZm9yIChsZXQgaSA9IHJhbmsgLSAyOyBpIDwgcmFuazsgaSsrKSB7XG4gICAgY29uZCArPSBgJHtkaW1zW2ldfSA+PSAke3NoYXBlW2kgLSByYW5rICsgMl19YDtcbiAgICBpZiAoaSA8IHJhbmsgLSAxKSB7XG4gICAgICBjb25kICs9ICd8fCc7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNvbmQ7XG59XG5cbi8qKlxuICogY29kZSBzbmlwcGV0IHRvIHNhbXBsZSBpbnB1dCB0ZXh0dXJlIHdpdGggb3V0cHV0IGNvb3JkaWFudGVzXG4gKi9cbmZ1bmN0aW9uIGdldE91dHB1dChzaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sIGRpbXM6IHN0cmluZ1tdKTogc3RyaW5nIHtcbiAgY29uc3QgcmFuayA9IHNoYXBlLmxlbmd0aDtcblxuICBpZiAocmFuayA9PT0gMCkge1xuICAgIHJldHVybiAnZ2V0QSgpLCAwLCAwLCAwJztcbiAgfVxuXG4gIGlmIChyYW5rID09PSAxKSB7XG4gICAgcmV0dXJuIGBnZXRBKHJjKSxcbiAgICAgICAgICAgIHJjICsgMSA+PSAke3NoYXBlWzBdfSA/IDAuIDogZ2V0QShyYyArIDEpLFxuICAgICAgICAgICAgMCwgMGA7XG4gIH1cblxuICBjb25zdCBjb29yZDAwID0gJ3IsIGMnO1xuICBjb25zdCBjb29yZDAxID0gJ3IsIGNwMSc7XG4gIGNvbnN0IGNvb3JkMTAgPSAncnAxLCBjJztcbiAgY29uc3QgY29vcmQxMSA9ICdycDEsIGNwMSc7XG4gIGxldCBEID0gJyc7XG4gIGlmIChyYW5rID4gMikge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuayAtIDI7ICsraSkge1xuICAgICAgRCA9IEQgKyBgJHtkaW1zW2ldfSxgO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYGdldEEoJHtEfSR7Y29vcmQwMH0pLFxuICAgICAgICAgIHJFZGdlID8gMC4gOiBnZXRBKCR7RH0ke2Nvb3JkMTB9KSxcbiAgICAgICAgICBjRWRnZSA/IDAuIDogZ2V0QSgke0R9JHtjb29yZDAxfSksXG4gICAgICAgICAgckVkZ2UgfHwgY0VkZ2UgPyAwLiA6IGdldEEoJHtEfSR7Y29vcmQxMX0pYDtcbn1cblxuLyoqXG4gKiBjb2RlIHNuaXBwZXQgdG8gc2V0dXAgNCBjb29yZGluYXRlcyBhbmQgZWRnZSBjb25kaXRpb25zXG4gKi9cbmZ1bmN0aW9uIGdldFNldHVwKHJhbms6IG51bWJlciwgZGltczogc3RyaW5nW10sIHJvd3M6IG51bWJlciwgY29sczogbnVtYmVyKTogc3RyaW5nIHtcbiAgaWYgKHJhbmsgPT09IDAgfHwgcmFuayA9PT0gMSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuICAvLyByYW5rID49IDIgZm9yIHdpZHRoK2hlaWdodCBwYWNrLlxuICBlbHNlIHtcbiAgICBjb25zdCBzZXR1cCA9IGBcbiAgICBpbnQgciA9ICR7ZGltc1tyYW5rIC0gMl19O1xuICAgIGludCBjID0gJHtkaW1zW3JhbmsgLSAxXX07XG4gICAgaW50IHJwMSA9ICR7ZGltc1tyYW5rIC0gMl19ICsgMTtcbiAgICBpbnQgY3AxID0gJHtkaW1zW3JhbmsgLSAxXX0gKyAxO1xuICAgIGJvb2wgckVkZ2UgPSBycDEgPj0gJHtjb2xzfTtcbiAgICBib29sIGNFZGdlID0gY3AxID49ICR7cm93c307XG4gICAgYDtcbiAgICByZXR1cm4gc2V0dXA7XG4gIH1cbn1cbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4uLy4uLy4uL3RlbnNvcic7XG5pbXBvcnQge1NoYXBlVXRpbH0gZnJvbSAnLi4vLi4vLi4vdXRpbCc7XG5pbXBvcnQge2dldEdsc2x9IGZyb20gJy4uL2dsc2wtc291cmNlJztcbmltcG9ydCB7V2ViR0xJbmZlcmVuY2VIYW5kbGVyfSBmcm9tICcuLi9pbmZlcmVuY2UtaGFuZGxlcic7XG5pbXBvcnQge1Byb2dyYW1JbmZvLCBQcm9ncmFtSW5mb0xvYWRlciwgUHJvZ3JhbU1ldGFkYXRhLCBUZXh0dXJlVHlwZX0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQge3VucGFja0Zyb21DaGFubmVsfSBmcm9tICcuL3BhY2tpbmctdXRpbHMnO1xuXG5jb25zdCBjcmVhdGVQYWNrZWRSZXNoYXBlM0RQcm9ncmFtTWV0YWRhdGEgPSAob3V0cHV0U2hhcGUzRDogcmVhZG9ubHkgbnVtYmVyW10pID0+XG4gICAgKHtuYW1lOiAnUmVzaGFwZSAocGFja2VkKScsIGlucHV0VHlwZXM6IFtUZXh0dXJlVHlwZS5wYWNrZWRdLCBpbnB1dE5hbWVzOiBbJ0EnXSwgY2FjaGVIaW50OiBgJHtvdXRwdXRTaGFwZTNEfWB9KTtcblxuY29uc3QgY3JlYXRlUGFja2VkUmVzaGFwZTNEUHJvZ3JhbUluZm8gPVxuICAgIChoYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0M0Q6IFRlbnNvciwgbWV0YWRhdGE6IFByb2dyYW1NZXRhZGF0YSwgb3V0cHV0U2hhcGUzRDogcmVhZG9ubHkgbnVtYmVyW10pOlxuICAgICAgICBQcm9ncmFtSW5mbyA9PiB7XG4gICAgICAgICAgY29uc3QgaW5wdXRTaGFwZTNEID0gaW5wdXQzRC5kaW1zIGFzIFtudW1iZXIsIG51bWJlciwgbnVtYmVyXTtcbiAgICAgICAgICBjb25zdCBzcXVlZXplZE91dHB1dFNoYXBlID0gb3V0cHV0U2hhcGUzRCBhcyBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl07XG5cbiAgICAgICAgICBsZXQgbWFpbkxvb3AgPSAnJztcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICAgICAgbGV0IG91dHB1dENvb3JkcyA9ICcnO1xuICAgICAgICAgICAgc3dpdGNoIChpKSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBvdXRwdXRDb29yZHMgPSAnb3V0cHV0Q29vcmRzID0gcmM7JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIG91dHB1dENvb3JkcyA9ICdvdXRwdXRDb29yZHMgPSBpdmVjMyhyYy54LCByYy55KzEsIHJjLnopOyc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBvdXRwdXRDb29yZHMgPSAnb3V0cHV0Q29vcmRzID0gaXZlYzMocmMueCwgcmMueSwgcmMueisxKTsnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgb3V0cHV0Q29vcmRzID0gJ291dHB1dENvb3JkcyA9IGl2ZWMzKHJjLngsIHJjLnkrMSwgcmMueisxKTsnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtYWluTG9vcCArPSBgXG4gICAgICAgICR7b3V0cHV0Q29vcmRzfVxuICAgICAgICAke2kgPiAwID8gJ2lmKG91dHB1dENvb3Jkcy55IDwgcm93cyAmJiBvdXRwdXRDb29yZHMueiA8IGNvbHMpeycgOiAnJ31cbiAgICAgICAgICBpbnQgZmxhdHRlbmVkSW5kZXggPSBnZXRGbGF0dGVuZWRJbmRleChvdXRwdXRDb29yZHMpO1xuXG4gICAgICAgICAgaXZlYzMgaW5wdXRSQyA9IGlucHV0Q29vcmRzRnJvbVJlc2hhcGVkT3V0Q29vcmRzKGZsYXR0ZW5lZEluZGV4KTtcbiAgICAgICAgICB2ZWMyIGlubmVyRGltcyA9IHZlYzIoZmxvYXQoaW5wdXRSQy55KSxmbG9hdChpbnB1dFJDLnopKTtcblxuICAgICAgICAgIHJlc3VsdFske2l9XSA9IGdldENoYW5uZWwoZ2V0QShpbnB1dFJDLngsIGlucHV0UkMueSwgaW5wdXRSQy56KSwgaW5uZXJEaW1zKTtcblxuICAgICAgICAke2kgPiAwID8gJ30nIDogJyd9XG4gICAgICBgO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBnbHNsID0gZ2V0R2xzbChoYW5kbGVyLnNlc3Npb24uYmFja2VuZC5nbENvbnRleHQudmVyc2lvbik7XG5cbiAgICAgICAgICBjb25zdCBzaGFkZXJTb3VyY2UgPSBgXG4gICAgICAke2dldFJlc2hhcGVkSW5wdXRDb29yZHMoaW5wdXRTaGFwZTNEKX1cbiAgICAgICR7Z2V0RmxhdHRlbmVkSW5kZXhGcm9tM0Qoc3F1ZWV6ZWRPdXRwdXRTaGFwZSl9XG4gICAgICAke3VucGFja0Zyb21DaGFubmVsKCl9XG5cbiAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgaXZlYzMgcmMgPSBnZXRPdXRwdXRDb29yZHMoKTtcblxuICAgICAgICB2ZWM0IHJlc3VsdCA9IHZlYzQoMC4wKTtcblxuICAgICAgICBpdmVjMyBvdXRwdXRDb29yZHM7XG4gICAgICAgIGludCByb3dzID0gJHtzcXVlZXplZE91dHB1dFNoYXBlWzJdfTtcbiAgICAgICAgaW50IGNvbHMgPSAke3NxdWVlemVkT3V0cHV0U2hhcGVbMV19O1xuXG4gICAgICAgICR7bWFpbkxvb3B9XG4gICAgICAgICR7Z2xzbC5vdXRwdXR9ID0gcmVzdWx0O1xuICAgICAgfVxuICAgIGA7XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4ubWV0YWRhdGEsXG4gICAgICAgICAgICBvdXRwdXQ6IHtkaW1zOiBzcXVlZXplZE91dHB1dFNoYXBlLCB0eXBlOiBpbnB1dDNELnR5cGUsIHRleHR1cmVUeXBlOiBUZXh0dXJlVHlwZS5wYWNrZWR9LFxuICAgICAgICAgICAgc2hhZGVyU291cmNlLFxuICAgICAgICAgICAgaGFzTWFpbjogdHJ1ZVxuICAgICAgICAgIH07XG4gICAgICAgIH07XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVQYWNrZWRSZXNoYXBlM0RQcm9ncmFtSW5mb0xvYWRlciA9XG4gICAgKGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXQzRDogVGVuc29yLCBvdXRwdXRTaGFwZTNEOiByZWFkb25seSBudW1iZXJbXSk6IFByb2dyYW1JbmZvTG9hZGVyID0+IHtcbiAgICAgIGNvbnN0IG1ldGFkYXRhID0gY3JlYXRlUGFja2VkUmVzaGFwZTNEUHJvZ3JhbU1ldGFkYXRhKG91dHB1dFNoYXBlM0QpO1xuICAgICAgcmV0dXJuIHsuLi5tZXRhZGF0YSwgZ2V0OiAoKSA9PiBjcmVhdGVQYWNrZWRSZXNoYXBlM0RQcm9ncmFtSW5mbyhoYW5kbGVyLCBpbnB1dDNELCBtZXRhZGF0YSwgb3V0cHV0U2hhcGUzRCl9O1xuICAgIH07XG5cbmV4cG9ydCBmdW5jdGlvbiBwcm9jZXNzRGltczNEKHNoYXBlOiBBcnJheUxpa2U8bnVtYmVyPik6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSB7XG4gIGlmIChzaGFwZS5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gWzEsIDEsIDFdO1xuICB9XG4gIC8vIFRPRE86IHNxdWVlemUgb3RoZXIgc2hhcGVzIHRvIDJEIGNhc2VcbiAgbGV0IGJhdGNoID0gMTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaGFwZS5sZW5ndGggLSAyOyArK2kpIHtcbiAgICBiYXRjaCAqPSBzaGFwZVtpXTtcbiAgfVxuICByZXR1cm4gW2JhdGNoLCBzaGFwZS5sZW5ndGggPiAxID8gc2hhcGVbc2hhcGUubGVuZ3RoIC0gMl0gOiAxLCBzaGFwZVtzaGFwZS5sZW5ndGggLSAxXV07XG59XG5cbi8vIEZvciBwYWNrZWQgcmVzaGFwZSwgd2UgbmVlZCB0byByZS1hcnJhbmdlIHRleGVsIGRhdGEgZm9yIG91dHB1dCBzaGFwZS5cbi8vIE91ciBwYWNrIGlzIGRlc2lnbmVkIHRvIHBhY2sgYSAyeDIgdGlsZSBpbiBsYXN0IGggYW5kIHcgZGltZW5zaW9uLCBzb1xuLy8gZm9yIHRoZSByZXNoYXBlZCBuZXcgdGVuc29yLCB3ZSBqdXN0IG5lZWQgdG8gcmUtYXJyYW5nZSB0aGUgbGFzdCBoIGFuZFxuLy8gdyBkaW1lbnNpb24uIEZvciBhbnkgc2hhcGUgdGhhdCBpcyBub3QgaW4gM0QsIGkuZS4gW2JhdGNoLCBXLCBIXSwgd2Vcbi8vIGZpcnN0IGNvbnZlcnQgaXQgdG8gM0QgYnkgY29sbGFwc2luZyBvdGhlciBkaW1lbnNpb24gdG8gYmF0Y2ggZGltLCB0aGVuXG4vLyBwcm9jZXNzIHdpdGggdGhlIGxhc3QgdHdvIGRpbWVuc2lvbnMuXG4vLyBOb3RlOiB3ZSBvbmx5IG5lZWQgdGhlIHNoYXBlIHRlbnNvciB0byBjYWxjdWxhdGUgb3V0cHV0IHNoYXBlLCBzbyB0aGVcbi8vIGNvbnRlbnQgaW4gc2hhcGUgdGVuc29yIGlzIG5ldmVyIHVwbG9hZGVkIHRvIEdQVS4gSXQgaXMgYWx3YXlzIGtlcHQgaW4gQ1BVLlxuLy8gVE9ETzogb3B0aW1pemUgdGhlIGFsZ29yaXRobSAtLSBpbiBzb21lIGNhc2VzLCBpZiB0aGUgbGFzdCB0d28gZGltcyBhcmVcbi8vIHRoZSBzYW1lIGJldHdlZW4gaW5wdXQgc2hhcGUgYW5kIG91dHB1dCBzaGFwZSwgdGhlIHBhY2tlZCByZXNoYXBlIGNhbiBiZVxuLy8gdHJlYXRlZCBhcyBuby1vcC5cbmV4cG9ydCBmdW5jdGlvbiBpc1Jlc2hhcGVDaGVhcChkaW1zOiByZWFkb25seSBudW1iZXJbXSwgcmVzaGFwZWREaW1zOiByZWFkb25seSBudW1iZXJbXSkge1xuICBsZXQgaXNDaGVhcFJlc2hhcGUgPSBmYWxzZTtcbiAgaWYgKGRpbXMubGVuZ3RoID09PSAwIHx8IHJlc2hhcGVkRGltcy5sZW5ndGggPT09IDApIHsgIC8vIHNjYWxhclxuICAgIGlzQ2hlYXBSZXNoYXBlID0gdHJ1ZTtcbiAgfSBlbHNlIGlmIChkaW1zLmxlbmd0aCA8IDIgfHwgcmVzaGFwZWREaW1zLmxlbmd0aCA8IDIpIHsgIC8vIDFEXG4gICAgaXNDaGVhcFJlc2hhcGUgPSBkaW1zW2RpbXMubGVuZ3RoIC0gMV0gPT09IHJlc2hhcGVkRGltc1tyZXNoYXBlZERpbXMubGVuZ3RoIC0gMV07XG4gIH0gZWxzZSB7ICAvLyAyRCArXG4gICAgaXNDaGVhcFJlc2hhcGUgPSBkaW1zW2RpbXMubGVuZ3RoIC0gMV0gPT09IHJlc2hhcGVkRGltc1tyZXNoYXBlZERpbXMubGVuZ3RoIC0gMV0gJiZcbiAgICAgICAgZGltc1tkaW1zLmxlbmd0aCAtIDJdID09PSByZXNoYXBlZERpbXNbcmVzaGFwZWREaW1zLmxlbmd0aCAtIDJdO1xuICB9XG5cbiAgcmV0dXJuIGlzQ2hlYXBSZXNoYXBlO1xufVxuXG5mdW5jdGlvbiBnZXRSZXNoYXBlZElucHV0Q29vcmRzKHNoYXBlOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0pOiBzdHJpbmcge1xuICBjb25zdCBzdHJpZGVzID0gU2hhcGVVdGlsLmNvbXB1dGVTdHJpZGVzKHNoYXBlKTtcbiAgY29uc3QgY29vcmRzID0gWydiJywgJ3InLCAnYyddO1xuICBjb25zdCBpbmRleCA9ICdpbmRleCc7XG4gIGNvbnN0IGNvb3Jkc0Zyb21JbmRleFNuaXBwZXQgPSBzdHJpZGVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLm1hcCgoc3RyaWRlLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsaW5lMSA9IGBpbnQgJHtjb29yZHNbaV19ID0gJHtpbmRleH0gLyAke3N0cmlkZX1gO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbGluZTIgPSBpID09PSBzdHJpZGVzLmxlbmd0aCAtIDEgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBpbnQgJHtjb29yZHNbaSArIDFdfSA9ICR7aW5kZXh9IC0gJHtjb29yZHNbaV19ICogJHtzdHJpZGV9YCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYGluZGV4IC09ICR7Y29vcmRzW2ldfSAqICR7c3RyaWRlfWA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYCR7bGluZTF9OyAke2xpbmUyfTtgO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmpvaW4oJycpO1xuXG4gIHJldHVybiBgXG4gICAgaXZlYzMgaW5wdXRDb29yZHNGcm9tUmVzaGFwZWRPdXRDb29yZHMoaW50IGluZGV4KSB7XG4gICAgICAke2Nvb3Jkc0Zyb21JbmRleFNuaXBwZXR9XG4gICAgICByZXR1cm4gaXZlYzMoYiwgciwgYyk7XG4gICAgfVxuICBgO1xufVxuXG5mdW5jdGlvbiBnZXRGbGF0dGVuZWRJbmRleEZyb20zRChzaGFwZTogW251bWJlciwgbnVtYmVyLCBudW1iZXJdKTogc3RyaW5nIHtcbiAgY29uc3Qgc3RyaWRlcyA9IFNoYXBlVXRpbC5jb21wdXRlU3RyaWRlcyhzaGFwZSk7XG5cbiAgcmV0dXJuIGBcbiAgaW50IGdldEZsYXR0ZW5lZEluZGV4KGl2ZWMzIGNvb3Jkcykge1xuICAgIC8vIHJldmVyc2UgeSwgeiBvcmRlclxuICAgIHJldHVybiBjb29yZHMueCAqICR7c3RyaWRlc1swXX0gKyBjb29yZHMueiAqICR7c3RyaWRlc1sxXX0gKyBjb29yZHMueTtcbiAgfVxuYDtcbn1cbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtnZXRHbHNsfSBmcm9tICcuLi9nbHNsLXNvdXJjZSc7XG5pbXBvcnQge1dlYkdMSW5mZXJlbmNlSGFuZGxlcn0gZnJvbSAnLi4vaW5mZXJlbmNlLWhhbmRsZXInO1xuaW1wb3J0IHtUZXh0dXJlRGF0YSwgVGV4dHVyZVR5cGV9IGZyb20gJy4uL3R5cGVzJztcblxuZXhwb3J0IGNvbnN0IGVuY29kZUFzVWludDggPSAoaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dDogVGV4dHVyZURhdGEpOiBUZXh0dXJlRGF0YSA9PiB7XG4gIGNvbnN0IG91dHB1dFNoYXBlID0gaW5wdXQuc2hhcGU7XG4gIGNvbnN0IGdsc2wgPSBnZXRHbHNsKGluZmVyZW5jZUhhbmRsZXIuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC52ZXJzaW9uKTtcbiAgLyoqXG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS90ZW5zb3JmbG93L3RmanMtY29yZS9ibG9iL21hc3Rlci9zcmMva2VybmVscy93ZWJnbC9lbmNvZGVfZmxvYXRfZ3B1LnRzXG4gICAqL1xuICBjb25zdCBzaGFkZXJTb3VyY2UgPSBgXG4gICAgY29uc3QgZmxvYXQgRkxPQVRfTUFYID0gMS43MDE0MTE4NGUzODtcbiAgICBjb25zdCBmbG9hdCBGTE9BVF9NSU4gPSAxLjE3NTQ5NDM1ZS0zODtcblxuICAgIGJvb2wgaXNOYU4oZmxvYXQgdmFsKSB7XG4gICAgICByZXR1cm4gKHZhbCA8IDEuMCB8fCAwLjAgPCB2YWwgfHwgdmFsID09IDAuMCkgPyBmYWxzZSA6IHRydWU7XG4gICAgfVxuXG4gICAgaGlnaHAgdmVjNCBlbmNvZGVBc1VpbnQ4KGhpZ2hwIGZsb2F0IHYpIHtcbiAgICAgIGlmIChpc05hTih2KSkge1xuICAgICAgICByZXR1cm4gdmVjNCgyNTUsIDI1NSwgMjU1LCAyNTUpO1xuICAgICAgfVxuXG4gICAgICBoaWdocCBmbG9hdCBhdiA9IGFicyh2KTtcblxuICAgICAgaWYoYXYgPCBGTE9BVF9NSU4pIHtcbiAgICAgICAgcmV0dXJuIHZlYzQoMC4wLCAwLjAsIDAuMCwgMC4wKTtcbiAgICAgIH0gZWxzZSBpZih2ID4gRkxPQVRfTUFYKSB7XG4gICAgICAgIHJldHVybiB2ZWM0KDAuMCwgMC4wLCAxMjguMCwgMTI3LjApIC8gMjU1LjA7XG4gICAgICB9IGVsc2UgaWYodiA8IC1GTE9BVF9NQVgpIHtcbiAgICAgICAgcmV0dXJuIHZlYzQoMC4wLCAwLjAsICAxMjguMCwgMjU1LjApIC8gMjU1LjA7XG4gICAgICB9XG5cbiAgICAgIGhpZ2hwIHZlYzQgYyA9IHZlYzQoMCwwLDAsMCk7XG5cbiAgICAgIGhpZ2hwIGZsb2F0IGUgPSBmbG9vcihsb2cyKGF2KSk7XG4gICAgICBoaWdocCBmbG9hdCBtID0gZXhwMihmcmFjdChsb2cyKGF2KSkpIC0gMS4wO1xuXG4gICAgICBjWzJdID0gZmxvb3IoMTI4LjAgKiBtKTtcbiAgICAgIG0gLT0gY1syXSAvIDEyOC4wO1xuICAgICAgY1sxXSA9IGZsb29yKDMyNzY4LjAgKiBtKTtcbiAgICAgIG0gLT0gY1sxXSAvIDMyNzY4LjA7XG4gICAgICBjWzBdID0gZmxvb3IoODM4ODYwOC4wICogbSk7XG5cbiAgICAgIGhpZ2hwIGZsb2F0IGViaWFzID0gZSArIDEyNy4wO1xuICAgICAgY1szXSA9IGZsb29yKGViaWFzIC8gMi4wKTtcbiAgICAgIGViaWFzIC09IGNbM10gKiAyLjA7XG4gICAgICBjWzJdICs9IGZsb29yKGViaWFzKSAqIDEyOC4wO1xuXG4gICAgICBjWzNdICs9IDEyOC4wICogc3RlcCgwLjAsIC12KTtcblxuICAgICAgcmV0dXJuIGMgLyAyNTUuMDtcbiAgICB9XG5cbiAgICB2b2lkIG1haW4oKSB7XG4gICAgICBmbG9hdCB2YWx1ZSA9ICR7Z2xzbC50ZXh0dXJlMkR9KFgsVGV4Q29vcmRzKS5yO1xuICAgICAgJHtnbHNsLm91dHB1dH0gPSBlbmNvZGVBc1VpbnQ4KHZhbHVlKTtcbiAgICB9YDtcbiAgY29uc3QgcHJvZ3JhbUluZm8gPSB7XG4gICAgbmFtZTogJ1VpbnQ4RW5jb2RlJyxcbiAgICBpbnB1dFR5cGVzOiBbVGV4dHVyZVR5cGUudW5wYWNrZWRdLFxuICAgIGlucHV0TmFtZXM6IFsnWCddLFxuICAgIG91dHB1dDoge2RpbXM6IG91dHB1dFNoYXBlLCB0eXBlOiBpbnB1dC50ZW5zb3IudHlwZSwgdGV4dHVyZVR5cGU6IFRleHR1cmVUeXBlLmRvd25sb2FkVWludDhBc0Zsb2F0fSxcbiAgICBzaGFkZXJTb3VyY2UsXG4gICAgaGFzTWFpbjogdHJ1ZVxuICB9O1xuICByZXR1cm4gaW5mZXJlbmNlSGFuZGxlci5leGVjdXRlUHJvZ3JhbShwcm9ncmFtSW5mbywgW2lucHV0LnRlbnNvcl0pO1xufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4uLy4uLy4uL3RlbnNvcic7XG5pbXBvcnQge2dldEdsc2x9IGZyb20gJy4uL2dsc2wtc291cmNlJztcbmltcG9ydCB7V2ViR0xJbmZlcmVuY2VIYW5kbGVyfSBmcm9tICcuLi9pbmZlcmVuY2UtaGFuZGxlcic7XG5pbXBvcnQge1Byb2dyYW1JbmZvLCBQcm9ncmFtSW5mb0xvYWRlciwgVGV4dHVyZVR5cGV9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7Z2V0Q29vcmRzRGF0YVR5cGV9IGZyb20gJy4uL3V0aWxzJztcblxuaW1wb3J0IHtnZXRDaGFubmVscywgdW5wYWNrRnJvbUNoYW5uZWx9IGZyb20gJy4vcGFja2luZy11dGlscyc7XG5cbmNvbnN0IHVucGFja1Byb2dyYW1NZXRhZGF0YSA9IHtcbiAgbmFtZTogJ3VucGFjaycsXG4gIGlucHV0TmFtZXM6IFsnQSddLFxuICBpbnB1dFR5cGVzOiBbVGV4dHVyZVR5cGUucGFja2VkXVxufTtcblxuZXhwb3J0IGNvbnN0IGNyZWF0ZVVucGFja1Byb2dyYW1JbmZvID0gKGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXQ6IFRlbnNvcik6IFByb2dyYW1JbmZvID0+IHtcbiAgY29uc3QgcmFuayA9IGlucHV0LmRpbXMubGVuZ3RoO1xuXG4gIGNvbnN0IGNoYW5uZWxzID0gZ2V0Q2hhbm5lbHMoJ3JjJywgcmFuayk7XG4gIGNvbnN0IGlubmVyRGltcyA9IGNoYW5uZWxzLnNsaWNlKC0yKTtcbiAgY29uc3QgY29vcmRzRGF0YVR5cGUgPSBnZXRDb29yZHNEYXRhVHlwZShyYW5rKTtcbiAgY29uc3QgdW5wYWNrQ2hhbm5lbCA9IHVucGFja0Zyb21DaGFubmVsKCk7XG4gIGNvbnN0IGlzU2NhbGFyID0gKGlucHV0LmRpbXMubGVuZ3RoID09PSAwKTtcbiAgY29uc3Qgc291cmNlQ29vcmRzID0gaXNTY2FsYXIgPyAnJyA6IGdldFNvdXJjZUNvb3JkcyhyYW5rLCBjaGFubmVscyk7XG4gIGNvbnN0IGNvb3JkcyA9IHJhbmsgPD0gMSA/ICdyYycgOiBgdmVjMigke2lubmVyRGltcy5qb2luKCcsJyl9KWA7XG4gIGNvbnN0IGdsc2wgPSBnZXRHbHNsKGhhbmRsZXIuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC52ZXJzaW9uKTtcbiAgY29uc3Qgc2hhZGVyU291cmNlID0gYFxuICAgICR7dW5wYWNrQ2hhbm5lbH1cbiAgICB2b2lkIG1haW4oKSB7XG4gICAgICAke2Nvb3Jkc0RhdGFUeXBlfSByYyA9IGdldE91dHB1dENvb3JkcygpO1xuXG4gICAgICAgLy8gU2FtcGxlIHRoZSB0ZXh0dXJlIHdpdGggdGhlIGNvb3JkcyB0byBnZXQgdGhlIHJnYmEgY2hhbm5lbCB2YWx1ZS5cbiAgICAgICB2ZWM0IHBhY2tlZElucHV0ID0gZ2V0QSgke3NvdXJjZUNvb3Jkc30pO1xuXG4gICAgICAgJHtnbHNsLm91dHB1dH0gPSB2ZWM0KGdldENoYW5uZWwocGFja2VkSW5wdXQsICR7Y29vcmRzfSksIDAsIDAsIDApO1xuICAgICB9XG4gICBgO1xuXG4gIHJldHVybiB7XG4gICAgLi4udW5wYWNrUHJvZ3JhbU1ldGFkYXRhLFxuICAgIGhhc01haW46IHRydWUsXG4gICAgb3V0cHV0OiB7ZGltczogaW5wdXQuZGltcywgdHlwZTogaW5wdXQudHlwZSwgdGV4dHVyZVR5cGU6IFRleHR1cmVUeXBlLnVucGFja2VkfSxcbiAgICBzaGFkZXJTb3VyY2VcbiAgfTtcbn07XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVVbnBhY2tQcm9ncmFtSW5mb0xvYWRlciA9IChoYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0OiBUZW5zb3IpOiBQcm9ncmFtSW5mb0xvYWRlciA9PlxuICAgICh7Li4udW5wYWNrUHJvZ3JhbU1ldGFkYXRhLCBnZXQ6ICgpID0+IGNyZWF0ZVVucGFja1Byb2dyYW1JbmZvKGhhbmRsZXIsIGlucHV0KX0pO1xuXG5mdW5jdGlvbiBnZXRTb3VyY2VDb29yZHMocmFuazogbnVtYmVyLCBkaW1zOiBzdHJpbmdbXSk6IHN0cmluZyB7XG4gIGlmIChyYW5rID09PSAxKSB7XG4gICAgcmV0dXJuICdyYyc7XG4gIH1cblxuICBsZXQgY29vcmRzID0gJyc7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuazsgaSsrKSB7XG4gICAgY29vcmRzICs9IGRpbXNbaV07XG4gICAgaWYgKGkgPCByYW5rIC0gMSkge1xuICAgICAgY29vcmRzICs9ICcsJztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvb3Jkcztcbn1cbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtMb2dnZXJ9IGZyb20gJy4uLy4uL2luc3RydW1lbnQnO1xuXG5leHBvcnQgZGVjbGFyZSBuYW1lc3BhY2UgRW5jb2RlciB7XG4gIGV4cG9ydCBpbnRlcmZhY2UgRGF0YVR5cGVNYXAge1xuICAgIGZsb2F0OiBGbG9hdDMyQXJyYXk7XG4gICAgYnl0ZTogVWludDhBcnJheTtcbiAgICBpbnQ6IFVpbnQzMkFycmF5O1xuICB9XG4gIGV4cG9ydCB0eXBlIERhdGFUeXBlID0ga2V5b2YgRGF0YVR5cGVNYXA7XG4gIHR5cGUgRGF0YUFycmF5VHlwZSA9IERhdGFUeXBlTWFwW0RhdGFUeXBlXTtcbn1cblxuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uICovXG5leHBvcnQgY29uc3QgZW51bSBFbmNvZGVyVXNhZ2Uge1xuICBEZWZhdWx0ID0gMCxcbiAgVXBsb2FkT25seSxcbiAgRG93bmxvYWQ0Qnl0ZXNBc0Zsb2F0MzIsXG59XG4vKiBlc2xpbnQtZW5hYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvbiAqL1xuXG4vKipcbiAqIEFic3RyYWN0aW9uIGZvciBtYXBwaW5nIGRhdGEgdHlwZXMgdG8gdGV4dHVyZSB0ZXhsZXRzXG4gKiBFbmNvZGluZyBtZWFucyBob3cgYSBGbG9hdDMyIGlzIG1hcHBlZCB0byAxIG9yIDQgY2hhbm5lbHMgZm9yIGVhY2ggdGV4bGV0XG4gKiBEZWNvZGluZyBtZWFucyBob3cgYSB0ZXhsZXQncyBjaGFubmVscyBhcmUgbWFwcGVkIHRvIGEgcmVzdWx0aW5nIEZsb2F0MzJcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBEYXRhRW5jb2RlciB7XG4gIGludGVybmFsRm9ybWF0OiBudW1iZXI7XG4gIGZvcm1hdDogbnVtYmVyO1xuICB0ZXh0dXJlVHlwZTogbnVtYmVyO1xuICBjaGFubmVsU2l6ZTogbnVtYmVyO1xuICBlbmNvZGUoc3JjOiBFbmNvZGVyLkRhdGFBcnJheVR5cGUsIHRleHR1cmVTaXplOiBudW1iZXIpOiBFbmNvZGVyLkRhdGFBcnJheVR5cGU7XG4gIGFsbG9jYXRlKHNpemU6IG51bWJlcik6IEVuY29kZXIuRGF0YUFycmF5VHlwZTtcbiAgZGVjb2RlKGJ1ZmZlcjogRW5jb2Rlci5EYXRhQXJyYXlUeXBlLCBkYXRhU2l6ZTogbnVtYmVyKTogRW5jb2Rlci5EYXRhQXJyYXlUeXBlO1xufVxuLyoqXG4gKiBXZWJHTDIgZGF0YSBlbmNvZGVyXG4gKiBVc2VzIFIzMkYgYXMgdGhlIGZvcm1hdCBmb3IgdGV4bGV0XG4gKi9cbmV4cG9ydCBjbGFzcyBSZWRGbG9hdDMyRGF0YUVuY29kZXIgaW1wbGVtZW50cyBEYXRhRW5jb2RlciB7XG4gIGludGVybmFsRm9ybWF0OiBudW1iZXI7XG4gIGZvcm1hdDogbnVtYmVyO1xuICB0ZXh0dXJlVHlwZTogbnVtYmVyO1xuICBjaGFubmVsU2l6ZTogbnVtYmVyO1xuICBjb25zdHJ1Y3RvcihnbDogV2ViR0wyUmVuZGVyaW5nQ29udGV4dCwgY2hhbm5lbHMgPSAxKSB7XG4gICAgaWYgKGNoYW5uZWxzID09PSAxKSB7XG4gICAgICB0aGlzLmludGVybmFsRm9ybWF0ID0gZ2wuUjMyRjtcbiAgICAgIHRoaXMuZm9ybWF0ID0gZ2wuUkVEO1xuICAgICAgdGhpcy50ZXh0dXJlVHlwZSA9IGdsLkZMT0FUO1xuICAgICAgdGhpcy5jaGFubmVsU2l6ZSA9IGNoYW5uZWxzO1xuICAgIH0gZWxzZSBpZiAoY2hhbm5lbHMgPT09IDQpIHtcbiAgICAgIHRoaXMuaW50ZXJuYWxGb3JtYXQgPSBnbC5SR0JBMzJGO1xuICAgICAgdGhpcy5mb3JtYXQgPSBnbC5SR0JBO1xuICAgICAgdGhpcy50ZXh0dXJlVHlwZSA9IGdsLkZMT0FUO1xuICAgICAgdGhpcy5jaGFubmVsU2l6ZSA9IGNoYW5uZWxzO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgbnVtYmVyIG9mIGNoYW5uZWxzOiAke2NoYW5uZWxzfWApO1xuICAgIH1cbiAgfVxuICBlbmNvZGUoc3JjOiBFbmNvZGVyLkRhdGFBcnJheVR5cGUsIHRleHR1cmVTaXplOiBudW1iZXIpOiBFbmNvZGVyLkRhdGFBcnJheVR5cGUge1xuICAgIGxldCByZXN1bHQ6IEZsb2F0MzJBcnJheTtcbiAgICBsZXQgc291cmNlOiBGbG9hdDMyQXJyYXk7XG4gICAgaWYgKHNyYy5jb25zdHJ1Y3RvciAhPT0gRmxvYXQzMkFycmF5KSB7XG4gICAgICBMb2dnZXIud2FybmluZygnRW5jb2RlcicsICdkYXRhIHdhcyBub3Qgb2YgdHlwZSBGbG9hdDMyOyBjcmVhdGluZyBuZXcgRmxvYXQzMkFycmF5Jyk7XG4gICAgICBzb3VyY2UgPSBuZXcgRmxvYXQzMkFycmF5KHNyYyk7XG4gICAgfVxuICAgIGlmICh0ZXh0dXJlU2l6ZSAqIHRoaXMuY2hhbm5lbFNpemUgPiBzcmMubGVuZ3RoKSB7XG4gICAgICBMb2dnZXIud2FybmluZygnRW5jb2RlcicsICdTb3VyY2UgZGF0YSB0b28gc21hbGwuIEFsbG9jYXRpbmcgbGFyZ2VyIGFycmF5Jyk7XG4gICAgICBzb3VyY2UgPSBzcmMgYXMgRmxvYXQzMkFycmF5O1xuICAgICAgcmVzdWx0ID0gdGhpcy5hbGxvY2F0ZSh0ZXh0dXJlU2l6ZSAqIHRoaXMuY2hhbm5lbFNpemUpIGFzIEZsb2F0MzJBcnJheTtcbiAgICAgIHNvdXJjZS5mb3JFYWNoKCh2LCBpKSA9PiByZXN1bHRbaV0gPSB2KTtcbiAgICB9IGVsc2Uge1xuICAgICAgc291cmNlID0gc3JjIGFzIEZsb2F0MzJBcnJheTtcbiAgICAgIHJlc3VsdCA9IHNvdXJjZTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBhbGxvY2F0ZShzaXplOiBudW1iZXIpOiBFbmNvZGVyLkRhdGFBcnJheVR5cGUge1xuICAgIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KHNpemUgKiA0KTtcbiAgfVxuICBkZWNvZGUoYnVmZmVyOiBFbmNvZGVyLkRhdGFBcnJheVR5cGUsIGRhdGFTaXplOiBudW1iZXIpOiBGbG9hdDMyQXJyYXkge1xuICAgIGlmICh0aGlzLmNoYW5uZWxTaXplID09PSAxKSB7XG4gICAgICBjb25zdCBmaWx0ZXJlZERhdGEgPSAoYnVmZmVyIGFzIEZsb2F0MzJBcnJheSkuZmlsdGVyKChfdmFsdWUsIGluZGV4KSA9PiBpbmRleCAlIDQgPT09IDApLnN1YmFycmF5KDAsIGRhdGFTaXplKTtcbiAgICAgIHJldHVybiBmaWx0ZXJlZERhdGE7XG4gICAgfVxuICAgIHJldHVybiBidWZmZXIuc3ViYXJyYXkoMCwgZGF0YVNpemUpIGFzIEZsb2F0MzJBcnJheTtcbiAgfVxufVxuLyoqXG4gKiBEYXRhIGVuY29kZXIgZm9yIFdlYkdMIDEgd2l0aCBzdXBwb3J0IGZvciBmbG9hdGluZyBwb2ludCB0ZXh0dXJlXG4gKi9cbmV4cG9ydCBjbGFzcyBSR0JBRmxvYXREYXRhRW5jb2RlciBpbXBsZW1lbnRzIERhdGFFbmNvZGVyIHtcbiAgaW50ZXJuYWxGb3JtYXQ6IG51bWJlcjtcbiAgZm9ybWF0OiBudW1iZXI7XG4gIHRleHR1cmVUeXBlOiBudW1iZXI7XG4gIGNoYW5uZWxTaXplOiBudW1iZXI7XG4gIGNvbnN0cnVjdG9yKGdsOiBXZWJHTFJlbmRlcmluZ0NvbnRleHQsIGNoYW5uZWxzID0gMSwgdGV4dHVyZVR5cGU/OiBudW1iZXIpIHtcbiAgICBpZiAoY2hhbm5lbHMgIT09IDEgJiYgY2hhbm5lbHMgIT09IDQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBudW1iZXIgb2YgY2hhbm5lbHM6ICR7Y2hhbm5lbHN9YCk7XG4gICAgfVxuICAgIHRoaXMuaW50ZXJuYWxGb3JtYXQgPSBnbC5SR0JBO1xuICAgIHRoaXMuZm9ybWF0ID0gZ2wuUkdCQTtcbiAgICB0aGlzLmNoYW5uZWxTaXplID0gY2hhbm5lbHM7XG4gICAgdGhpcy50ZXh0dXJlVHlwZSA9IHRleHR1cmVUeXBlIHx8IGdsLkZMT0FUO1xuICB9XG4gIGVuY29kZShzcmM6IEZsb2F0MzJBcnJheSwgdGV4dHVyZVNpemU6IG51bWJlcik6IEVuY29kZXIuRGF0YUFycmF5VHlwZSB7XG4gICAgbGV0IGRlc3QgPSBzcmM7XG4gICAgaWYgKHRoaXMuY2hhbm5lbFNpemUgPT09IDEpIHtcbiAgICAgIExvZ2dlci52ZXJib3NlKCdFbmNvZGVyJywgJ0V4cGxvZGluZyBpbnRvIGEgbGFyZ2VyIGFycmF5Jyk7XG4gICAgICBkZXN0ID0gdGhpcy5hbGxvY2F0ZSh0ZXh0dXJlU2l6ZSkgYXMgRmxvYXQzMkFycmF5O1xuICAgICAgc3JjLmZvckVhY2goKHYsIGkpID0+IGRlc3RbaSAqIDRdID0gdik7XG4gICAgfVxuICAgIHJldHVybiBkZXN0O1xuICB9XG4gIGFsbG9jYXRlKHNpemU6IG51bWJlcik6IEVuY29kZXIuRGF0YUFycmF5VHlwZSB7XG4gICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoc2l6ZSAqIDQpO1xuICB9XG4gIGRlY29kZShidWZmZXI6IEVuY29kZXIuRGF0YUFycmF5VHlwZSwgZGF0YVNpemU6IG51bWJlcik6IEZsb2F0MzJBcnJheSB7XG4gICAgaWYgKHRoaXMuY2hhbm5lbFNpemUgPT09IDEpIHtcbiAgICAgIGNvbnN0IGZpbHRlcmVkRGF0YSA9IChidWZmZXIgYXMgRmxvYXQzMkFycmF5KS5maWx0ZXIoKF92YWx1ZSwgaW5kZXgpID0+IGluZGV4ICUgNCA9PT0gMCkuc3ViYXJyYXkoMCwgZGF0YVNpemUpO1xuICAgICAgcmV0dXJuIGZpbHRlcmVkRGF0YTtcbiAgICB9XG4gICAgcmV0dXJuIGJ1ZmZlci5zdWJhcnJheSgwLCBkYXRhU2l6ZSkgYXMgRmxvYXQzMkFycmF5O1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBVaW50OERhdGFFbmNvZGVyIGltcGxlbWVudHMgRGF0YUVuY29kZXIge1xuICBpbnRlcm5hbEZvcm1hdDogbnVtYmVyO1xuICBmb3JtYXQ6IG51bWJlcjtcbiAgdGV4dHVyZVR5cGU6IG51bWJlcjtcbiAgY2hhbm5lbFNpemUgPSA0O1xuICBjb25zdHJ1Y3RvcihnbDogV2ViR0xSZW5kZXJpbmdDb250ZXh0LCBjaGFubmVscyA9IDEpIHtcbiAgICBpZiAoY2hhbm5lbHMgPT09IDEpIHtcbiAgICAgIHRoaXMuaW50ZXJuYWxGb3JtYXQgPSBnbC5BTFBIQTtcbiAgICAgIHRoaXMuZm9ybWF0ID0gZ2wuQUxQSEE7ICAvLyBub3QgdGVzdGVkXG4gICAgICB0aGlzLnRleHR1cmVUeXBlID0gZ2wuVU5TSUdORURfQllURTtcbiAgICAgIHRoaXMuY2hhbm5lbFNpemUgPSBjaGFubmVscztcbiAgICB9IGVsc2UgaWYgKGNoYW5uZWxzID09PSA0KSB7XG4gICAgICB0aGlzLmludGVybmFsRm9ybWF0ID0gZ2wuUkdCQTtcbiAgICAgIHRoaXMuZm9ybWF0ID0gZ2wuUkdCQTtcbiAgICAgIHRoaXMudGV4dHVyZVR5cGUgPSBnbC5VTlNJR05FRF9CWVRFO1xuICAgICAgdGhpcy5jaGFubmVsU2l6ZSA9IGNoYW5uZWxzO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgbnVtYmVyIG9mIGNoYW5uZWxzOiAke2NoYW5uZWxzfWApO1xuICAgIH1cbiAgfVxuICBlbmNvZGUoc3JjOiBVaW50OEFycmF5LCBfdGV4dHVyZVNpemU6IG51bWJlcik6IEVuY29kZXIuRGF0YUFycmF5VHlwZSB7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHNyYy5idWZmZXIsIHNyYy5ieXRlT2Zmc2V0LCBzcmMuYnl0ZUxlbmd0aCk7XG4gIH1cbiAgYWxsb2NhdGUoc2l6ZTogbnVtYmVyKTogRW5jb2Rlci5EYXRhQXJyYXlUeXBlIHtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoc2l6ZSAqIHRoaXMuY2hhbm5lbFNpemUpO1xuICB9XG4gIGRlY29kZShidWZmZXI6IEVuY29kZXIuRGF0YUFycmF5VHlwZSwgZGF0YVNpemU6IG51bWJlcik6IFVpbnQ4QXJyYXkge1xuICAgIGlmIChidWZmZXIgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICByZXR1cm4gYnVmZmVyLnN1YmFycmF5KDAsIGRhdGFTaXplKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGFycmF5IHR5cGU6ICR7YnVmZmVyLmNvbnN0cnVjdG9yfWApO1xuICB9XG59XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7U2hhcGVVdGlsfSBmcm9tICcuLi8uLi91dGlsJztcblxuaW1wb3J0IHtUZXh0dXJlTGF5b3V0U3RyYXRlZ3ksIFdpZHRoSGVpZ2h0UHJlZnN9IGZyb20gJy4vdGV4dHVyZS1sYXlvdXQtc3RyYXRlZ3knO1xuaW1wb3J0IHtUZXh0dXJlTGF5b3V0LCBUZXh0dXJlVHlwZX0gZnJvbSAnLi90eXBlcyc7XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVUZXh0dXJlTGF5b3V0RnJvbVRleHR1cmVUeXBlID1cbiAgICAodGV4dHVyZUxheW91dFN0cmF0ZWd5OiBUZXh0dXJlTGF5b3V0U3RyYXRlZ3ksIHNoYXBlOiByZWFkb25seSBudW1iZXJbXSxcbiAgICAgdGV4dHVyZVR5cGU6IFRleHR1cmVUeXBlKTogVGV4dHVyZUxheW91dCA9PiB7XG4gICAgICBjb25zdCBjaGFubmVsID0gKHRleHR1cmVUeXBlID09PSBUZXh0dXJlVHlwZS51bnBhY2tlZCB8fCB0ZXh0dXJlVHlwZSA9PT0gVGV4dHVyZVR5cGUudW5wYWNrZWRSZXZlcnNlZCkgPyAxIDogNDtcbiAgICAgIGNvbnN0IGlzUGFja2VkID0gdGV4dHVyZVR5cGUgPT09IFRleHR1cmVUeXBlLnBhY2tlZDtcbiAgICAgIGNvbnN0IHJldmVyc2VXSCA9ICh0ZXh0dXJlVHlwZSA9PT0gVGV4dHVyZVR5cGUudW5wYWNrZWRSZXZlcnNlZCB8fCB0ZXh0dXJlVHlwZSA9PT0gVGV4dHVyZVR5cGUucGFja2VkKTtcbiAgICAgIGNvbnN0IGJyZWFrQXhpcyA9IHRleHR1cmVUeXBlID09PSBUZXh0dXJlVHlwZS5wYWNrZWRMYXN0RGltZW5zaW9uID8gc2hhcGUubGVuZ3RoIC0gMSA6IHVuZGVmaW5lZDtcbiAgICAgIGNvbnN0IHVucGFja2VkU2hhcGUgPSB0ZXh0dXJlVHlwZSA9PT0gVGV4dHVyZVR5cGUucGFja2VkTGFzdERpbWVuc2lvbiA/XG4gICAgICAgICAgc2hhcGUubWFwKChkLCBpKSA9PiBpID09PSBzaGFwZS5sZW5ndGggLSAxID8gZCAqIDQgOiBkKSA6XG4gICAgICAgICAgdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIGNyZWF0ZVRleHR1cmVMYXlvdXRGcm9tU2hhcGUoXG4gICAgICAgICAgdGV4dHVyZUxheW91dFN0cmF0ZWd5LCBzaGFwZSwgY2hhbm5lbCwgdW5wYWNrZWRTaGFwZSwge2lzUGFja2VkLCByZXZlcnNlV0gsIGJyZWFrQXhpc30pO1xuICAgIH07XG5cbmV4cG9ydCBjb25zdCBjYWxjdWxhdGVUZXh0dXJlV2lkdGhBbmRIZWlnaHQgPVxuICAgICh0ZXh0dXJlTGF5b3V0U3RyYXRlZ3k6IFRleHR1cmVMYXlvdXRTdHJhdGVneSwgc2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLCB0ZXh0dXJlVHlwZTogVGV4dHVyZVR5cGUpOlxuICAgICAgICBbbnVtYmVyLCBudW1iZXJdID0+IHtcbiAgICAgICAgICBjb25zdCBsYXlvdXQgPSBjcmVhdGVUZXh0dXJlTGF5b3V0RnJvbVRleHR1cmVUeXBlKHRleHR1cmVMYXlvdXRTdHJhdGVneSwgc2hhcGUsIHRleHR1cmVUeXBlKTtcbiAgICAgICAgICByZXR1cm4gW2xheW91dC53aWR0aCwgbGF5b3V0LmhlaWdodF07XG4gICAgICAgIH07XG5cbi8qKlxuICogQ3JlYXRlIGEgVGV4dHVyZUxheW91dCBvYmplY3QgZnJvbSBzaGFwZS5cbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZVRleHR1cmVMYXlvdXRGcm9tU2hhcGUgPVxuICAgICh0ZXh0dXJlTGF5b3V0U3RyYXRlZ3k6IFRleHR1cmVMYXlvdXRTdHJhdGVneSwgc2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLCBjaGFubmVsczogMXw0ID0gMSxcbiAgICAgdW5wYWNrZWRTaGFwZT86IHJlYWRvbmx5IG51bWJlcltdLCBwcmVmcz86IFdpZHRoSGVpZ2h0UHJlZnMpOiBUZXh0dXJlTGF5b3V0ID0+IHtcbiAgICAgIGNvbnN0IGlzUGFja2VkID0gISEocHJlZnMgJiYgcHJlZnMuaXNQYWNrZWQpO1xuICAgICAgY29uc3QgW3dpZHRoLCBoZWlnaHRdID0gdGV4dHVyZUxheW91dFN0cmF0ZWd5LmNvbXB1dGVUZXh0dXJlV0goaXNQYWNrZWQgPyB1bnBhY2tlZFNoYXBlIHx8IHNoYXBlIDogc2hhcGUsIHByZWZzKTtcbiAgICAgIGNvbnN0IHJhbmsgPSBzaGFwZS5sZW5ndGg7XG4gICAgICBsZXQgaW5mZXJyZWREaW1zID0gc2hhcGUuc2xpY2UoMCk7XG4gICAgICBpZiAocmFuayA9PT0gMCkge1xuICAgICAgICBpbmZlcnJlZERpbXMgPSBbMV07XG4gICAgICB9XG4gICAgICBpZiAoY2hhbm5lbHMgPT09IDEpIHtcbiAgICAgICAgLy8gdW5wYWNrZWRTaGFwZSB3aWxsIHRha2UgYHNoYXBlYCBhbmQgbm90IGBpbmZlcnJlZERpbXNgIHNvIGFzIHRvIGNyZWF0ZSBhIHNjYWxhciBUZW5zb3IgaWYgbmVlZCBiZVxuICAgICAgICB1bnBhY2tlZFNoYXBlID0gc2hhcGU7XG4gICAgICB9IGVsc2UgaWYgKGlzUGFja2VkKSB7XG4gICAgICAgIGlmIChjaGFubmVscyAhPT0gNCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYSBwYWNrZWQgdGV4dHVyZSBtdXN0IGJlIDQtY2hhbm5lbCcpO1xuICAgICAgICB9XG4gICAgICAgIHVucGFja2VkU2hhcGUgPSBzaGFwZTtcbiAgICAgICAgaWYgKHJhbmsgPiAwKSB7XG4gICAgICAgICAgaW5mZXJyZWREaW1zW3JhbmsgLSAxXSA9IE1hdGguY2VpbChpbmZlcnJlZERpbXNbcmFuayAtIDFdIC8gMik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJhbmsgPiAxKSB7XG4gICAgICAgICAgaW5mZXJyZWREaW1zW3JhbmsgLSAyXSA9IE1hdGguY2VpbChpbmZlcnJlZERpbXNbcmFuayAtIDJdIC8gMik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIXVucGFja2VkU2hhcGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnBhY2tlZCBzaGFwZSBpcyBuZWVkZWQgd2hlbiB1c2luZyBjaGFubmVscyA+IDEnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHQsXG4gICAgICAgIGNoYW5uZWxzLFxuICAgICAgICBpc1BhY2tlZCxcbiAgICAgICAgc2hhcGU6IGluZmVycmVkRGltcyxcbiAgICAgICAgc3RyaWRlczogU2hhcGVVdGlsLmNvbXB1dGVTdHJpZGVzKGluZmVycmVkRGltcyksXG4gICAgICAgIHVucGFja2VkU2hhcGUsXG4gICAgICAgIHJldmVyc2VkV0g6IChwcmVmcyAmJiBwcmVmcy5yZXZlcnNlV0gpXG4gICAgICB9O1xuICAgIH07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7SW5mZXJlbmNlSGFuZGxlcn0gZnJvbSAnLi4vLi4vYmFja2VuZCc7XG5pbXBvcnQge0xvZ2dlcn0gZnJvbSAnLi4vLi4vaW5zdHJ1bWVudCc7XG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi4vLi4vdGVuc29yJztcbmltcG9ydCB7U2hhcGVVdGlsfSBmcm9tICcuLi8uLi91dGlsJztcblxuaW1wb3J0IHtjcmVhdGVQYWNrUHJvZ3JhbUluZm9Mb2FkZXJ9IGZyb20gJy4vb3BzL3BhY2snO1xuaW1wb3J0IHtjcmVhdGVQYWNrZWRSZXNoYXBlM0RQcm9ncmFtSW5mb0xvYWRlciwgaXNSZXNoYXBlQ2hlYXAsIHByb2Nlc3NEaW1zM0R9IGZyb20gJy4vb3BzL3Jlc2hhcGUtcGFja2VkJztcbmltcG9ydCB7ZW5jb2RlQXNVaW50OH0gZnJvbSAnLi9vcHMvdWludDgtZW5jb2RlJztcbmltcG9ydCB7Y3JlYXRlVW5wYWNrUHJvZ3JhbUluZm9Mb2FkZXJ9IGZyb20gJy4vb3BzL3VucGFjayc7XG5pbXBvcnQge1dlYkdMU2Vzc2lvbkhhbmRsZXJ9IGZyb20gJy4vc2Vzc2lvbi1oYW5kbGVyJztcbmltcG9ydCB7RW5jb2RlclVzYWdlfSBmcm9tICcuL3RleHR1cmUtZGF0YS1lbmNvZGVyJztcbmltcG9ydCB7Y2FsY3VsYXRlVGV4dHVyZVdpZHRoQW5kSGVpZ2h0LCBjcmVhdGVUZXh0dXJlTGF5b3V0RnJvbVNoYXBlLCBjcmVhdGVUZXh0dXJlTGF5b3V0RnJvbVRleHR1cmVUeXBlfSBmcm9tICcuL3RleHR1cmUtbGF5b3V0JztcbmltcG9ydCB7QXJ0aWZhY3QsIFByb2dyYW1JbmZvLCBQcm9ncmFtSW5mb0xvYWRlciwgVGV4dHVyZURhdGEsIFRleHR1cmVMYXlvdXQsIFRleHR1cmVUeXBlfSBmcm9tICcuL3R5cGVzJztcblxuY29uc3QgZ2V0UHJvZ3JhbUluZm9VbmlxdWVLZXkgPVxuICAgIChwcm9ncmFtSW5mbzogUHJvZ3JhbUluZm98UHJvZ3JhbUluZm9Mb2FkZXIsIGlucHV0VGV4dHVyZURhdGFzOiBUZXh0dXJlRGF0YVtdKTogc3RyaW5nID0+IHtcbiAgICAgIGNvbnN0IGlucHV0cyA9XG4gICAgICAgICAgaW5wdXRUZXh0dXJlRGF0YXMubWFwKHRleHR1cmUgPT4gYCR7dGV4dHVyZS51bnBhY2tlZFNoYXBlLmpvaW4oJywnKX07JHt0ZXh0dXJlLndpZHRofXgke3RleHR1cmUuaGVpZ2h0fWApXG4gICAgICAgICAgICAgIC5qb2luKCdfJyk7XG4gICAgICBsZXQga2V5ID0gcHJvZ3JhbUluZm8ubmFtZTtcbiAgICAgIGlmIChwcm9ncmFtSW5mby5jYWNoZUhpbnQpIHtcbiAgICAgICAga2V5ICs9ICdbJyArIHByb2dyYW1JbmZvLmNhY2hlSGludCArICddJztcbiAgICAgIH1cbiAgICAgIGtleSArPSAnOicgKyBpbnB1dHM7XG4gICAgICByZXR1cm4ga2V5O1xuICAgIH07XG5cbmV4cG9ydCBjbGFzcyBXZWJHTEluZmVyZW5jZUhhbmRsZXIgaW1wbGVtZW50cyBJbmZlcmVuY2VIYW5kbGVyIHtcbiAgcHJpdmF0ZSBwYWNrZWRUZXh0dXJlRGF0YUNhY2hlOiBNYXA8VGVuc29yLklkLCBUZXh0dXJlRGF0YT47XG4gIHByaXZhdGUgdW5wYWNrZWRUZXh0dXJlRGF0YUNhY2hlOiBNYXA8VGVuc29yLklkLCBUZXh0dXJlRGF0YT47XG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBzZXNzaW9uOiBXZWJHTFNlc3Npb25IYW5kbGVyKSB7XG4gICAgdGhpcy5wYWNrZWRUZXh0dXJlRGF0YUNhY2hlID0gbmV3IE1hcCgpO1xuICAgIHRoaXMudW5wYWNrZWRUZXh0dXJlRGF0YUNhY2hlID0gbmV3IE1hcCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIFt3aWR0aCwgaGVpZ2h0XVxuICAgKi9cbiAgY2FsY3VsYXRlVGV4dHVyZVdpZHRoQW5kSGVpZ2h0KHNoYXBlOiByZWFkb25seSBudW1iZXJbXSwgdGV4dHVyZVR5cGU6IFRleHR1cmVUeXBlKTogW251bWJlciwgbnVtYmVyXSB7XG4gICAgcmV0dXJuIGNhbGN1bGF0ZVRleHR1cmVXaWR0aEFuZEhlaWdodCh0aGlzLnNlc3Npb24ubGF5b3V0U3RyYXRlZ3ksIHNoYXBlLCB0ZXh0dXJlVHlwZSk7XG4gIH1cblxuICBleGVjdXRlUHJvZ3JhbShwcm9ncmFtOiBQcm9ncmFtSW5mb3xQcm9ncmFtSW5mb0xvYWRlciwgaW5wdXRzOiByZWFkb25seSBUZW5zb3JbXSk6IFRleHR1cmVEYXRhIHtcbiAgICBpZiAoaW5wdXRzLmxlbmd0aCA8IHByb2dyYW0uaW5wdXROYW1lcy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW5wdXQgc2l6ZSBtdXN0bid0IGJlIGxlc3MgdGhhbiAke3Byb2dyYW0uaW5wdXROYW1lcy5sZW5ndGh9LmApO1xuICAgIH1cbiAgICBpZiAocHJvZ3JhbS5pbnB1dE5hbWVzLmxlbmd0aCAhPT0gcHJvZ3JhbS5pbnB1dFR5cGVzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnB1dCBuYW1lcyBzaXplIGRvZXMgbm90IG1hdGNoIGlucHV0IHR5cGVzJyk7XG4gICAgfVxuXG4gICAgLy8gY3JlYXRlIHRleHR1cmUgaW5mbyBmb3IgaW5wdXRcbiAgICBjb25zdCBpbnB1dFRleHR1cmVEYXRhczogVGV4dHVyZURhdGFbXSA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvZ3JhbS5pbnB1dE5hbWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICBpbnB1dFRleHR1cmVEYXRhc1tpXSA9IHRoaXMuZ2V0T3JDcmVhdGVUZXh0dXJlRGF0YShpbnB1dHNbaV0sIHByb2dyYW0uaW5wdXRUeXBlc1tpXSk7XG4gICAgfVxuXG4gICAgY29uc3Qga2V5ID0gZ2V0UHJvZ3JhbUluZm9VbmlxdWVLZXkocHJvZ3JhbSwgaW5wdXRUZXh0dXJlRGF0YXMpO1xuICAgIGxldCBhcnRpZmFjdCA9IHRoaXMuc2Vzc2lvbi5wcm9ncmFtTWFuYWdlci5nZXRBcnRpZmFjdChrZXkpO1xuICAgIGNvbnN0IHByb2dyYW1JbmZvID0gYXJ0aWZhY3QgP1xuICAgICAgICBhcnRpZmFjdC5wcm9ncmFtSW5mbyA6XG4gICAgICAgICh0eXBlb2YgKHByb2dyYW0gYXMgUHJvZ3JhbUluZm9Mb2FkZXIpLmdldCA9PT0gJ2Z1bmN0aW9uJyA/IChwcm9ncmFtIGFzIFByb2dyYW1JbmZvTG9hZGVyKS5nZXQoKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChwcm9ncmFtIGFzIFByb2dyYW1JbmZvKSk7XG5cbiAgICAvLyBjcmVhdGUgdGV4dHVyZSBpbmZvIGZvciBvdXRwdXRcbiAgICBjb25zdCBvdXRwdXRUZXh0dXJlTGF5b3V0ID0gY3JlYXRlVGV4dHVyZUxheW91dEZyb21UZXh0dXJlVHlwZShcbiAgICAgICAgdGhpcy5zZXNzaW9uLmxheW91dFN0cmF0ZWd5LCBwcm9ncmFtSW5mby5vdXRwdXQuZGltcywgcHJvZ3JhbUluZm8ub3V0cHV0LnRleHR1cmVUeXBlKTtcbiAgICBjb25zdCBvdXRwdXRUZXh0dXJlRGF0YSA9IHRoaXMuY3JlYXRlVGV4dHVyZURhdGEob3V0cHV0VGV4dHVyZUxheW91dCwgcHJvZ3JhbUluZm8ub3V0cHV0LnR5cGUpO1xuXG4gICAgaWYgKCFhcnRpZmFjdCkge1xuICAgICAgYXJ0aWZhY3QgPSB0aGlzLnNlc3Npb24ucHJvZ3JhbU1hbmFnZXIuYnVpbGQocHJvZ3JhbUluZm8sIGlucHV0VGV4dHVyZURhdGFzLCBvdXRwdXRUZXh0dXJlRGF0YSk7XG4gICAgICB0aGlzLnNlc3Npb24ucHJvZ3JhbU1hbmFnZXIuc2V0QXJ0aWZhY3Qoa2V5LCBhcnRpZmFjdCk7XG4gICAgfVxuXG4gICAgdGhpcy5ydW5Qcm9ncmFtKGFydGlmYWN0LCBpbnB1dFRleHR1cmVEYXRhcywgb3V0cHV0VGV4dHVyZURhdGEpO1xuICAgIHJldHVybiBvdXRwdXRUZXh0dXJlRGF0YTtcbiAgfVxuXG4gIHJ1bihwcm9ncmFtOiBQcm9ncmFtSW5mb0xvYWRlciwgaW5wdXRzOiByZWFkb25seSBUZW5zb3JbXSk6IFRlbnNvciB7XG4gICAgY29uc3Qgb3V0cHV0VGV4dHVyZURhdGEgPSB0aGlzLmV4ZWN1dGVQcm9ncmFtKHByb2dyYW0sIGlucHV0cyk7XG4gICAgcmV0dXJuIG91dHB1dFRleHR1cmVEYXRhLnRlbnNvcjtcbiAgfVxuXG4gIHByaXZhdGUgcnVuUHJvZ3JhbShhcnRpZmFjdDogQXJ0aWZhY3QsIGlucHV0czogVGV4dHVyZURhdGFbXSwgb3V0cHV0OiBUZXh0dXJlRGF0YSk6IHZvaWQge1xuICAgIC8vIGlucHV0IHNob3VsZCBtYXRjaFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXRzLmxlbmd0aDsgKytpKSB7XG4gICAgICBpZiAoISFpbnB1dHNbaV0uaXNQYWNrZWQgIT09IChhcnRpZmFjdC5wcm9ncmFtSW5mby5pbnB1dFR5cGVzW2ldID09PSBUZXh0dXJlVHlwZS5wYWNrZWQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW5wdXRbJHtpfV0gcHJvcGVydHkgcGFja2VkIGluY29uc2lzdGVudGApO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIG91dHB1dCBzaG91bGQgbWF0Y2hcbiAgICBpZiAoISFvdXRwdXQuaXNQYWNrZWQgIT09IChhcnRpZmFjdC5wcm9ncmFtSW5mby5vdXRwdXQudGV4dHVyZVR5cGUgPT09IFRleHR1cmVUeXBlLnBhY2tlZCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignb3V0cHV0IHByb3BlcnR5IHBhY2tlZCBpbmNvbnNpc3RlbnQnKTtcbiAgICB9XG5cbiAgICB0aGlzLnNlc3Npb24ucHJvZ3JhbU1hbmFnZXIucnVuKGFydGlmYWN0LCBpbnB1dHMsIG91dHB1dCk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgVGV4dHVyZURhdGEgb2JqZWN0IGZyb20gYSB0ZW5zb3IuXG4gICAqIFVzYWdlID0gRW5jb2RlclVzYWdlLlVwbG9hZE9ubHkuXG4gICAqIElmIGEgcmVsYXRlZCB0ZXh0dXJlIGRhdGEgaXMgZm91bmQgaW4gY2FjaGUsIHJldHVybnMgaXQ7XG4gICAqIE90aGVyd2lzZTpcbiAgICogICBDcmVhdGVzIGEgbmV3IHRleHR1cmUgbGF5b3V0IGlmIG5vdCBwcm92aWRlZDtcbiAgICogICBDcmVhdGVzIFdlYkdMVGV4dHVyZSB3aXRoIHRoZSBsYXlvdXQ7XG4gICAqICAgVXBsb2FkIHRlbnNvciBkYXRhIHRvIHRoZSB0ZXh0dXJlO1xuICAgKiAgIENyZWF0ZXMgYSB0ZXh0dXJlIGRhdGEgb2JqZWN0IGFzc29jaWF0ZWQgd2l0aCB0aGUgZ2l2ZW4gdGVuc29yLlxuICAgKiBAcGFyYW0gdGVuc29yIHRoZSB0ZW5zb3Igd2l0aCBkYXRhIHRvIHVwbG9hZFxuICAgKi9cbiAgcHJpdmF0ZSBnZXRPckNyZWF0ZVRleHR1cmVEYXRhKHRlbnNvcjogVGVuc29yLCB0ZXh0dXJlVHlwZTogVGV4dHVyZVR5cGUpIHtcbiAgICBsZXQgdGQgPSB0aGlzLmdldFRleHR1cmVEYXRhKHRlbnNvci5kYXRhSWQsIHRleHR1cmVUeXBlID09PSBUZXh0dXJlVHlwZS5wYWNrZWQpO1xuXG4gICAgaWYgKCF0ZCkge1xuICAgICAgLy8gY2hlY2sgaWYgd2UgaGF2ZSB0ZXh0dXJlIGRhdGEgaW4gZGlmZmVyZW50IHR5cGVcbiAgICAgIHRkID0gdGhpcy5nZXRUZXh0dXJlRGF0YSh0ZW5zb3IuZGF0YUlkLCB0ZXh0dXJlVHlwZSAhPT0gVGV4dHVyZVR5cGUucGFja2VkKTtcbiAgICAgIGlmICh0ZCkge1xuICAgICAgICBpZiAodGV4dHVyZVR5cGUgPT09IFRleHR1cmVUeXBlLnBhY2tlZCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnBhY2sodGQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0aGlzLnVucGFjayh0ZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXRkKSB7XG4gICAgICBjb25zdCBsYXlvdXQgPSBjcmVhdGVUZXh0dXJlTGF5b3V0RnJvbVRleHR1cmVUeXBlKHRoaXMuc2Vzc2lvbi5sYXlvdXRTdHJhdGVneSwgdGVuc29yLmRpbXMsIHRleHR1cmVUeXBlKTtcblxuICAgICAgaWYgKHRleHR1cmVUeXBlID09PSBUZXh0dXJlVHlwZS5wYWNrZWRMYXN0RGltZW5zaW9uKSB7XG4gICAgICAgIGNvbnN0IGdyb3VwID0gMTtcbiAgICAgICAgY29uc3QgY2hhbm5lbHMgPSA0O1xuICAgICAgICBjb25zdCBzaGFwZSA9IHRlbnNvci5kaW1zO1xuICAgICAgICBpZiAoc2hhcGUubGVuZ3RoID09PSA0KSB7XG4gICAgICAgICAgLy8gcHJlLXByb2Nlc3NpbmcgZm9yIGtlcm5lbCBkYXRhIG9mIENvbnYuXG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyBUT0RPOiBjdXJyZW50bHkgdGhpcyBpcyBhIGhhY2tpbmcgdG8gb3ZlcndyaXRlIENvbnYncyB3ZWlnaHQuIFRoZSBjb3JyZWN0IHdheSB0byBkbyB0aGlzIHNob3VsZCBiZTpcbiAgICAgICAgICAvLyAxLiBpbXBsZW1lbnQgdGV4dHVyZSBiYXNlZCBjb25zdC1mb2xkaW5nXG4gICAgICAgICAgLy8gMi4gY3JlYXRlIGEgV2ViR0wgcHJvZ3JhbSBcInByZXByb2Nlc3NDb252V2VpZ2h0XCIgdG8gZG8gdGhlIHNhbWUgd29yayBhcyBiZWxvd1xuICAgICAgICAgIC8vIDMuIHJ1biB0aGUgcHJvZ3JhbSBiZWZvcmUgZG90UHJvZHVjdC5cbiAgICAgICAgICAvL1xuICAgICAgICAgIGNvbnN0IGFkanVzdGVkS2VybmVsU2hhcGUgPSBbc2hhcGVbMF0sIE1hdGguY2VpbCgoc2hhcGVbMV0gKiBzaGFwZVsyXSAqIHNoYXBlWzNdKSAvIGNoYW5uZWxzKV07XG4gICAgICAgICAgY29uc3QgYWRqdXN0ZWRMYXlvdXQgPVxuICAgICAgICAgICAgICBjcmVhdGVUZXh0dXJlTGF5b3V0RnJvbVRleHR1cmVUeXBlKHRoaXMuc2Vzc2lvbi5sYXlvdXRTdHJhdGVneSwgYWRqdXN0ZWRLZXJuZWxTaGFwZSwgdGV4dHVyZVR5cGUpO1xuICAgICAgICAgIGxldCBidWZmZXIgPSB0ZW5zb3IubnVtYmVyRGF0YTtcbiAgICAgICAgICBpZiAoc2hhcGVbMV0gKiBzaGFwZVsyXSAqIHNoYXBlWzNdICUgY2hhbm5lbHMgIT09IDApIHtcbiAgICAgICAgICAgIGNvbnN0IG51bUZlYXR1cmVNYXBzID0gc2hhcGVbMF07XG4gICAgICAgICAgICBjb25zdCBvbGRSb3dTaXplID0gc2hhcGVbMV0gKiBzaGFwZVsyXSAqIHNoYXBlWzNdO1xuICAgICAgICAgICAgY29uc3QgbmV3Um93U2l6ZSA9IE1hdGguY2VpbChvbGRSb3dTaXplICogZ3JvdXAgLyBjaGFubmVscykgKiBjaGFubmVscztcbiAgICAgICAgICAgIGNvbnN0IG5ld1NpemUgPSBudW1GZWF0dXJlTWFwcyAqIG5ld1Jvd1NpemU7XG4gICAgICAgICAgICBidWZmZXIgPSBuZXcgRmxvYXQzMkFycmF5KG5ld1NpemUpO1xuICAgICAgICAgICAgZm9yIChsZXQgZiA9IDA7IGYgPCBudW1GZWF0dXJlTWFwczsgKytmKSB7XG4gICAgICAgICAgICAgIGNvbnN0IG9sZE9mZnNldCA9IGYgKiBvbGRSb3dTaXplO1xuICAgICAgICAgICAgICBjb25zdCBuZXdPZmZzZXQgPSBmICogbmV3Um93U2l6ZSArIGYgJSBncm91cCAqIG9sZFJvd1NpemU7XG4gICAgICAgICAgICAgIGJ1ZmZlci5zZXQodGVuc29yLm51bWJlckRhdGEuc3ViYXJyYXkob2xkT2Zmc2V0LCBvbGRPZmZzZXQgKyBvbGRSb3dTaXplKSwgbmV3T2Zmc2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlVGV4dHVyZURhdGEoYWRqdXN0ZWRMYXlvdXQsIHRlbnNvci50eXBlLCBidWZmZXIsIHRlbnNvciwgRW5jb2RlclVzYWdlLlVwbG9hZE9ubHkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0ZXh0dXJlVHlwZSA9PT0gVGV4dHVyZVR5cGUucGFja2VkKSB7XG4gICAgICAgIGNvbnN0IHVucGFja2VkVGV4dHVyZUxheW91dCA9XG4gICAgICAgICAgICBjcmVhdGVUZXh0dXJlTGF5b3V0RnJvbVNoYXBlKHRoaXMuc2Vzc2lvbi5sYXlvdXRTdHJhdGVneSwgdGVuc29yLmRpbXMsIDEsIFtdLCB7cmV2ZXJzZVdIOiB0cnVlfSk7XG4gICAgICAgIGNvbnN0IHVucGFja2VkVGV4dHVyZURhdGEgPSB0aGlzLmNyZWF0ZVRleHR1cmVEYXRhKFxuICAgICAgICAgICAgdW5wYWNrZWRUZXh0dXJlTGF5b3V0LCB0ZW5zb3IudHlwZSwgdGVuc29yLm51bWJlckRhdGEsIHRlbnNvciwgRW5jb2RlclVzYWdlLlVwbG9hZE9ubHkpO1xuICAgICAgICB0ZCA9IHRoaXMucGFjayh1bnBhY2tlZFRleHR1cmVEYXRhKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRkID0gdGhpcy5jcmVhdGVUZXh0dXJlRGF0YShsYXlvdXQsIHRlbnNvci50eXBlLCB0ZW5zb3IubnVtYmVyRGF0YSwgdGVuc29yLCBFbmNvZGVyVXNhZ2UuVXBsb2FkT25seSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0ZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBUZXh0dXJlRGF0YSBvYmplY3QgdXNpbmcgdGhlIGdpdmVuIGRhdGEgYW5kIGJpbmQgdG8gdGhlIGdpdmVuIHRlbnNvci5cbiAgICogVXNhZ2UgPSBFbmNvZGVyVXNhZ2UuVXBsb2FkT25seS5cbiAgICogTk9URTogdGhpcyBmdW5jdGlvbiBpcyBhIGhhY2sgZm9yIENvbnYgaW1wbGVtZW50YXRpb24uIHNob3VsZCByZW1vdmUgdGhpcyBmdW5jdGlvbiwgYWZ0ZXIgcmV3cml0aW5nIENvbnZcbiAgICogaW1wbGVtZW50YXRpb24gYnkgR3JhcGguVHJhbnNmb3JtZXJcbiAgICogQHBhcmFtIGRhdGFUeXBlIHRoZSB0ZW5zb3IgZGF0YSB0eXBlXG4gICAqIEBwYXJhbSBkYXRhIHRoZSBhY3R1YWwgZGF0YSB0byB1cGxvYWRcbiAgICogQHBhcmFtIHRlbnNvciB0aGUgdGVuc29yIHRvIGJpbmQuIHRlbnNvcidzIGRhdGEgaXMgaWdub3JlZC5cbiAgICovXG4gIGNyZWF0ZVRleHR1cmVEYXRhRnJvbUxheW91dEJpbmRUZW5zb3IoXG4gICAgICBsYXlvdXQ6IFRleHR1cmVMYXlvdXQsIGRhdGFUeXBlOiBUZW5zb3IuRGF0YVR5cGUsIGRhdGE6IFRlbnNvci5OdW1iZXJUeXBlLCB0ZW5zb3I6IFRlbnNvcik6IFRleHR1cmVEYXRhIHtcbiAgICByZXR1cm4gdGhpcy5jcmVhdGVUZXh0dXJlRGF0YShsYXlvdXQsIGRhdGFUeXBlLCBkYXRhLCB0ZW5zb3IsIEVuY29kZXJVc2FnZS5VcGxvYWRPbmx5KTtcbiAgfVxuXG4gIHByaXZhdGUgY3JlYXRlVGV4dHVyZURhdGEoXG4gICAgICBsYXlvdXQ6IFRleHR1cmVMYXlvdXQsIGRhdGFUeXBlOiBUZW5zb3IuRGF0YVR5cGUsIGRhdGE/OiBUZW5zb3IuTnVtYmVyVHlwZSwgdGVuc29yPzogVGVuc29yLFxuICAgICAgdXNhZ2U/OiBFbmNvZGVyVXNhZ2UpOiBUZXh0dXJlRGF0YSB7XG4gICAgTG9nZ2VyLnZlcmJvc2UoJ0luZmVyZW5jZUhhbmRsZXInLCBgQ3JlYXRpbmcgVGV4dHVyZURhdGE6IGxheW91dDpbJHtKU09OLnN0cmluZ2lmeShsYXlvdXQpfV1gKTtcbiAgICBjb25zdCB0ZXh0dXJlID0gdGhpcy5zZXNzaW9uLnRleHR1cmVNYW5hZ2VyLmNyZWF0ZVRleHR1cmVGcm9tTGF5b3V0KGRhdGFUeXBlLCBsYXlvdXQsIGRhdGEsIHVzYWdlKTtcbiAgICByZXR1cm4gdGhpcy5jcmVhdGVUZXh0dXJlRGF0YUZyb21UZXh0dXJlKGxheW91dCwgZGF0YVR5cGUsIHRleHR1cmUsIHRlbnNvcik7XG4gIH1cblxuICByZXNoYXBlVW5wYWNrZWQoaW5wdXQ6IFRlbnNvciwgcmVzaGFwZWREaW1zOiByZWFkb25seSBudW1iZXJbXSk6IFRlbnNvciB7XG4gICAgY29uc3QgaW5wdXRURCA9IHRoaXMuZ2V0T3JDcmVhdGVUZXh0dXJlRGF0YShpbnB1dCwgVGV4dHVyZVR5cGUudW5wYWNrZWQpO1xuICAgIGNvbnN0IG5ld1RleHR1cmVMYXlvdXQ6IFRleHR1cmVMYXlvdXQgPSB7XG4gICAgICBjaGFubmVsczogaW5wdXRURC5jaGFubmVscyxcbiAgICAgIGhlaWdodDogaW5wdXRURC5oZWlnaHQsXG4gICAgICB3aWR0aDogaW5wdXRURC53aWR0aCxcbiAgICAgIC8vIGhhbmRsZSByZXNoYXBpbmcgaW50byBzY2FsYXIgVGVuc29yc1xuICAgICAgc2hhcGU6IHJlc2hhcGVkRGltcy5sZW5ndGggIT09IDAgPyByZXNoYXBlZERpbXMgOiBbMV0sXG4gICAgICBzdHJpZGVzOiBTaGFwZVV0aWwuY29tcHV0ZVN0cmlkZXMocmVzaGFwZWREaW1zKSxcbiAgICAgIHVucGFja2VkU2hhcGU6IHJlc2hhcGVkRGltcyxcbiAgICB9O1xuICAgIGNvbnN0IG5ld1RleHR1cmVEYXRhID0gdGhpcy5jcmVhdGVUZXh0dXJlRGF0YUZyb21UZXh0dXJlKG5ld1RleHR1cmVMYXlvdXQsIGlucHV0LnR5cGUsIGlucHV0VEQudGV4dHVyZSk7XG4gICAgcmV0dXJuIG5ld1RleHR1cmVEYXRhLnRlbnNvcjtcbiAgfVxuXG4gIHJlc2hhcGVQYWNrZWQoaW5wdXQ6IFRlbnNvciwgcmVzaGFwZWREaW1zOiByZWFkb25seSBudW1iZXJbXSk6IFRlbnNvciB7XG4gICAgY29uc3QgaW5wdXRURCA9IHRoaXMuZ2V0T3JDcmVhdGVUZXh0dXJlRGF0YShpbnB1dCwgVGV4dHVyZVR5cGUucGFja2VkKTtcblxuICAgIC8vIGNoZWNrIGlmIHRoZSByZXNoYXBlIGlzICdjaGVhcCdcbiAgICBpZiAoaXNSZXNoYXBlQ2hlYXAoaW5wdXQuZGltcywgcmVzaGFwZWREaW1zKSkge1xuICAgICAgY29uc3QgbmV3VGV4dHVyZUxheW91dDogVGV4dHVyZUxheW91dCA9IHtcbiAgICAgICAgY2hhbm5lbHM6IGlucHV0VEQuY2hhbm5lbHMsXG4gICAgICAgIGhlaWdodDogaW5wdXRURC5oZWlnaHQsXG4gICAgICAgIHdpZHRoOiBpbnB1dFRELndpZHRoLFxuICAgICAgICAvLyBoYW5kbGUgcmVzaGFwaW5nIGludG8gc2NhbGFyIFRlbnNvcnNcbiAgICAgICAgc2hhcGU6IHJlc2hhcGVkRGltcy5sZW5ndGggIT09IDAgPyByZXNoYXBlZERpbXMgOiBbMV0sXG4gICAgICAgIHN0cmlkZXM6IFNoYXBlVXRpbC5jb21wdXRlU3RyaWRlcyhyZXNoYXBlZERpbXMpLFxuICAgICAgICB1bnBhY2tlZFNoYXBlOiByZXNoYXBlZERpbXMsXG4gICAgICAgIGlzUGFja2VkOiB0cnVlXG4gICAgICB9O1xuICAgICAgY29uc3QgbmV3VGV4dHVyZURhdGEgPSB0aGlzLmNyZWF0ZVRleHR1cmVEYXRhRnJvbVRleHR1cmUobmV3VGV4dHVyZUxheW91dCwgaW5wdXQudHlwZSwgaW5wdXRURC50ZXh0dXJlKTtcbiAgICAgIHJldHVybiBuZXdUZXh0dXJlRGF0YS50ZW5zb3I7XG4gICAgfVxuXG4gICAgY29uc3Qgc3F1ZWV6ZWRJbnB1dFNoYXBlID0gcHJvY2Vzc0RpbXMzRChpbnB1dC5kaW1zKTtcbiAgICBjb25zdCBzcXVlZXplZE91dHB1dFNoYXBlID0gcHJvY2Vzc0RpbXMzRChyZXNoYXBlZERpbXMpO1xuXG4gICAgY29uc3Qgc3F1ZWV6ZWRJbnB1dFRlbnNvciA9IHRoaXMucmVzaGFwZVBhY2tlZChpbnB1dCwgc3F1ZWV6ZWRJbnB1dFNoYXBlKTtcbiAgICBjb25zdCBzcXVlZXplZE91dHB1dFRlbnNvciA9IHRoaXMucnVuKFxuICAgICAgICBjcmVhdGVQYWNrZWRSZXNoYXBlM0RQcm9ncmFtSW5mb0xvYWRlcih0aGlzLCBzcXVlZXplZElucHV0VGVuc29yLCBzcXVlZXplZE91dHB1dFNoYXBlKSwgW3NxdWVlemVkSW5wdXRUZW5zb3JdKTtcbiAgICBjb25zdCBvdXRwdXRUZW5zb3IgPSB0aGlzLnJlc2hhcGVQYWNrZWQoc3F1ZWV6ZWRPdXRwdXRUZW5zb3IsIHJlc2hhcGVkRGltcyk7XG4gICAgcmV0dXJuIG91dHB1dFRlbnNvcjtcbiAgfVxuXG4gIGNhc3QoaW5wdXQ6IFRlbnNvciwgdHlwZTogVGVuc29yLkRhdGFUeXBlKTogVGVuc29yIHtcbiAgICBjb25zdCBpbnB1dFREID0gdGhpcy5nZXRPckNyZWF0ZVRleHR1cmVEYXRhKGlucHV0LCBUZXh0dXJlVHlwZS51bnBhY2tlZCk7XG4gICAgY29uc3QgbmV3VGV4dHVyZURhdGEgPSB0aGlzLmNyZWF0ZVRleHR1cmVEYXRhRnJvbVRleHR1cmUoaW5wdXRURCBhcyBUZXh0dXJlTGF5b3V0LCB0eXBlLCBpbnB1dFRELnRleHR1cmUpO1xuICAgIHJldHVybiBuZXdUZXh0dXJlRGF0YS50ZW5zb3I7XG4gIH1cblxuICBwcml2YXRlIGNyZWF0ZVRleHR1cmVEYXRhRnJvbVRleHR1cmUoXG4gICAgICBsYXlvdXQ6IFRleHR1cmVMYXlvdXQsIGRhdGFUeXBlOiBUZW5zb3IuRGF0YVR5cGUsIHRleHR1cmU6IFdlYkdMVGV4dHVyZSwgdGVuc29yPzogVGVuc29yLCB0ZW5zb3JJZD86IFRlbnNvci5JZCkge1xuICAgIGNvbnN0IHRleHR1cmVEYXRhOiBUZXh0dXJlRGF0YSA9IHtcbiAgICAgIC4uLmxheW91dCxcbiAgICAgIHRlbnNvcjogdGVuc29yIHx8XG4gICAgICAgICAgbmV3IFRlbnNvcihcbiAgICAgICAgICAgICAgICAgIGxheW91dC51bnBhY2tlZFNoYXBlLCBkYXRhVHlwZSwgKF9pZDogVGVuc29yLklkKSA9PiB0aGlzLnJlYWRUZXh0dXJlKHRleHR1cmVEYXRhKSxcbiAgICAgICAgICAgICAgICAgIGFzeW5jIChfaWQ6IFRlbnNvci5JZCkgPT4gdGhpcy5yZWFkVGV4dHVyZUFzeW5jKHRleHR1cmVEYXRhKSwgdW5kZWZpbmVkLCB0ZW5zb3JJZCksXG4gICAgICB0ZXh0dXJlXG4gICAgfTtcbiAgICB0aGlzLnNldFRleHR1cmVEYXRhKHRleHR1cmVEYXRhLnRlbnNvci5kYXRhSWQsIHRleHR1cmVEYXRhLCBsYXlvdXQuaXNQYWNrZWQpO1xuICAgIHJldHVybiB0ZXh0dXJlRGF0YTtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0VGV4dHVyZURhdGEodGVuc29ySWQ6IFRlbnNvci5JZCwgaXNQYWNrZWQgPSBmYWxzZSk6IFRleHR1cmVEYXRhfHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMuc2Vzc2lvbi5pc0luaXRpYWxpemVyKHRlbnNvcklkKSA/IHRoaXMuc2Vzc2lvbi5nZXRUZXh0dXJlRGF0YSh0ZW5zb3JJZCwgaXNQYWNrZWQpIDpcbiAgICAgICAgaXNQYWNrZWQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gdGhpcy5wYWNrZWRUZXh0dXJlRGF0YUNhY2hlLmdldCh0ZW5zb3JJZCkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVucGFja2VkVGV4dHVyZURhdGFDYWNoZS5nZXQodGVuc29ySWQpO1xuICB9XG4gIHNldFRleHR1cmVEYXRhKHRlbnNvcklkOiBUZW5zb3IuSWQsIHRkOiBUZXh0dXJlRGF0YSwgaXNQYWNrZWQgPSBmYWxzZSk6IHZvaWQge1xuICAgIGlmICh0aGlzLnNlc3Npb24uaXNJbml0aWFsaXplcih0ZW5zb3JJZCkpIHtcbiAgICAgIHRoaXMuc2Vzc2lvbi5zZXRUZXh0dXJlRGF0YSh0ZW5zb3JJZCwgdGQsIGlzUGFja2VkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgKGlzUGFja2VkID8gdGhpcy5wYWNrZWRUZXh0dXJlRGF0YUNhY2hlIDogdGhpcy51bnBhY2tlZFRleHR1cmVEYXRhQ2FjaGUpLnNldCh0ZW5zb3JJZCwgdGQpO1xuICAgIH1cbiAgfVxuICBpc1RleHR1cmVMYXlvdXRDYWNoZWQodGVuc29yOiBUZW5zb3IsIGlzUGFja2VkID0gZmFsc2UpOiBib29sZWFuIHtcbiAgICByZXR1cm4gISF0aGlzLmdldFRleHR1cmVEYXRhKHRlbnNvci5kYXRhSWQsIGlzUGFja2VkKTtcbiAgfVxuXG4gIGRpc3Bvc2UoKTogdm9pZCB7XG4gICAgdGhpcy5zZXNzaW9uLnRleHR1cmVNYW5hZ2VyLmNsZWFyQWN0aXZlVGV4dHVyZXMoKTtcbiAgICB0aGlzLnBhY2tlZFRleHR1cmVEYXRhQ2FjaGUuZm9yRWFjaCh0ZCA9PiB0aGlzLnNlc3Npb24udGV4dHVyZU1hbmFnZXIucmVsZWFzZVRleHR1cmUodGQpKTtcbiAgICB0aGlzLnBhY2tlZFRleHR1cmVEYXRhQ2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy51bnBhY2tlZFRleHR1cmVEYXRhQ2FjaGUuZm9yRWFjaCh0ZCA9PiB0aGlzLnNlc3Npb24udGV4dHVyZU1hbmFnZXIucmVsZWFzZVRleHR1cmUodGQpKTtcbiAgICB0aGlzLnVucGFja2VkVGV4dHVyZURhdGFDYWNoZSA9IG5ldyBNYXAoKTtcbiAgfVxuXG4gIHJlYWRUZXh0dXJlKHRleHR1cmVEYXRhOiBUZXh0dXJlRGF0YSk6IFRlbnNvci5OdW1iZXJUeXBlIHtcbiAgICBpZiAodGV4dHVyZURhdGEuaXNQYWNrZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlYWRUZXh0dXJlKHRoaXMudW5wYWNrKHRleHR1cmVEYXRhKSk7XG4gICAgfVxuICAgIGlmICghdGhpcy5zZXNzaW9uLmJhY2tlbmQuZ2xDb250ZXh0LmlzRmxvYXQzMkRvd25sb2FkU3VwcG9ydGVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXNzaW9uLnRleHR1cmVNYW5hZ2VyLnJlYWRVaW50OFRleHR1cmVBc0Zsb2F0KGVuY29kZUFzVWludDgodGhpcywgdGV4dHVyZURhdGEpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuc2Vzc2lvbi50ZXh0dXJlTWFuYWdlci5yZWFkVGV4dHVyZSh0ZXh0dXJlRGF0YSwgdGV4dHVyZURhdGEudGVuc29yLnR5cGUsIHRleHR1cmVEYXRhLmNoYW5uZWxzKTtcbiAgfVxuXG4gIGFzeW5jIHJlYWRUZXh0dXJlQXN5bmModGV4dHVyZURhdGE6IFRleHR1cmVEYXRhKTogUHJvbWlzZTxUZW5zb3IuTnVtYmVyVHlwZT4ge1xuICAgIGlmICh0ZXh0dXJlRGF0YS5pc1BhY2tlZCkge1xuICAgICAgcmV0dXJuIHRoaXMucmVhZFRleHR1cmVBc3luYyh0aGlzLnVucGFjayh0ZXh0dXJlRGF0YSkpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC5pc0Zsb2F0MzJEb3dubG9hZFN1cHBvcnRlZCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2Vzc2lvbi50ZXh0dXJlTWFuYWdlci5yZWFkVWludDhUZXh0dXJlQXNGbG9hdChlbmNvZGVBc1VpbnQ4KHRoaXMsIHRleHR1cmVEYXRhKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnNlc3Npb24udGV4dHVyZU1hbmFnZXIucmVhZFRleHR1cmVBc3luYyh0ZXh0dXJlRGF0YSwgdGV4dHVyZURhdGEudGVuc29yLnR5cGUsIHRleHR1cmVEYXRhLmNoYW5uZWxzKTtcbiAgfVxuXG4gIHBhY2soaW5wdXQ6IFRleHR1cmVEYXRhKTogVGV4dHVyZURhdGEge1xuICAgIGNvbnN0IG91dHB1dFRleHR1cmVEYXRhID0gdGhpcy5leGVjdXRlUHJvZ3JhbShjcmVhdGVQYWNrUHJvZ3JhbUluZm9Mb2FkZXIodGhpcywgaW5wdXQudGVuc29yKSwgW2lucHV0LnRlbnNvcl0pO1xuICAgIHJldHVybiBvdXRwdXRUZXh0dXJlRGF0YTtcbiAgfVxuXG4gIHVucGFjayhpbnB1dDogVGV4dHVyZURhdGEpOiBUZXh0dXJlRGF0YSB7XG4gICAgY29uc3Qgb3V0cHV0VGV4dHVyZURhdGEgPSB0aGlzLmV4ZWN1dGVQcm9ncmFtKGNyZWF0ZVVucGFja1Byb2dyYW1JbmZvTG9hZGVyKHRoaXMsIGlucHV0LnRlbnNvciksIFtpbnB1dC50ZW5zb3JdKTtcbiAgICByZXR1cm4gb3V0cHV0VGV4dHVyZURhdGE7XG4gIH1cbn1cbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuY2xhc3MgQXR0cmlidXRlV2l0aENhY2hlS2V5SW1wbCB7XG4gIGNvbnN0cnVjdG9yKGF0dHJpYnV0ZTogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pIHtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIGF0dHJpYnV0ZSk7XG4gIH1cblxuICBwcml2YXRlIGtleTogc3RyaW5nO1xuICBwdWJsaWMgZ2V0IGNhY2hlS2V5KCk6IHN0cmluZyB7XG4gICAgaWYgKCF0aGlzLmtleSkge1xuICAgICAgdGhpcy5rZXkgPVxuICAgICAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRoaXMpLnNvcnQoKS5tYXAobmFtZSA9PiBgJHsodGhpcyBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPilbbmFtZV19YCkuam9pbignOycpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5rZXk7XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkge1xuICByZWFkb25seSBjYWNoZUtleTogc3RyaW5nO1xufVxuXG5leHBvcnQgY29uc3QgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5ID0gPFQgZXh0ZW5kcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPj4oYXR0cmlidXRlOiBUKTogVCZBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkgPT5cbiAgICBuZXcgQXR0cmlidXRlV2l0aENhY2hlS2V5SW1wbChhdHRyaWJ1dGUpIGFzIHVua25vd24gYXMgVCAmIEF0dHJpYnV0ZVdpdGhDYWNoZUtleTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtBdHRyaWJ1dGVXaXRoQ2FjaGVLZXksIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleX0gZnJvbSAnLi4vLi4vLi4vYXR0cmlidXRlLXdpdGgtY2FjaGUta2V5JztcbmltcG9ydCB7R3JhcGh9IGZyb20gJy4uLy4uLy4uL2dyYXBoJztcbmltcG9ydCB7T3BlcmF0b3JJbXBsZW1lbnRhdGlvbiwgT3BlcmF0b3JJbml0aWFsaXphdGlvbn0gZnJvbSAnLi4vLi4vLi4vb3BlcmF0b3JzJztcbmltcG9ydCB7VGVuc29yfSBmcm9tICcuLi8uLi8uLi90ZW5zb3InO1xuaW1wb3J0IHtnZXRHbHNsfSBmcm9tICcuLi9nbHNsLXNvdXJjZSc7XG5pbXBvcnQge1dlYkdMSW5mZXJlbmNlSGFuZGxlcn0gZnJvbSAnLi4vaW5mZXJlbmNlLWhhbmRsZXInO1xuaW1wb3J0IHtQcm9ncmFtSW5mbywgVGV4dHVyZVR5cGV9IGZyb20gJy4uL3R5cGVzJztcblxuZXhwb3J0IGludGVyZmFjZSBCYXRjaE5vcm1hbGl6YXRpb25BdHRyaWJ1dGVzIGV4dGVuZHMgQXR0cmlidXRlV2l0aENhY2hlS2V5IHtcbiAgZXBzaWxvbjogbnVtYmVyO1xuICBtb21lbnR1bTogbnVtYmVyO1xuICBzcGF0aWFsOiBudW1iZXI7XG59XG5cbmNvbnN0IGJhdGNoTm9ybWFsaXphdGlvblByb2dyYW1NZXRhZGF0YSA9IHtcbiAgbmFtZTogJ0JhdGNoTm9ybWFsaXphdGlvbicsXG4gIGlucHV0TmFtZXM6IFsnQScsICdTY2FsZScsICdCJywgJ01lYW4nLCAnVmFyaWFuY2UnXSxcbiAgaW5wdXRUeXBlczpcbiAgICAgIFtUZXh0dXJlVHlwZS51bnBhY2tlZCwgVGV4dHVyZVR5cGUudW5wYWNrZWQsIFRleHR1cmVUeXBlLnVucGFja2VkLCBUZXh0dXJlVHlwZS51bnBhY2tlZCwgVGV4dHVyZVR5cGUudW5wYWNrZWRdXG59O1xuXG5leHBvcnQgY29uc3QgYmF0Y2hOb3JtYWxpemF0aW9uOiBPcGVyYXRvckltcGxlbWVudGF0aW9uPEJhdGNoTm9ybWFsaXphdGlvbkF0dHJpYnV0ZXM+ID1cbiAgICAoaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdLCBhdHRyaWJ1dGVzOiBCYXRjaE5vcm1hbGl6YXRpb25BdHRyaWJ1dGVzKTogVGVuc29yW10gPT4ge1xuICAgICAgdmFsaWRhdGVJbnB1dHMoaW5wdXRzKTtcbiAgICAgIGNvbnN0IG91dHB1dCA9IGluZmVyZW5jZUhhbmRsZXIucnVuKFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIC4uLmJhdGNoTm9ybWFsaXphdGlvblByb2dyYW1NZXRhZGF0YSxcbiAgICAgICAgICAgIGNhY2hlSGludDogYXR0cmlidXRlcy5jYWNoZUtleSxcbiAgICAgICAgICAgIGdldDogKCkgPT4gY3JlYXRlQmF0Y2hOb3JtYWxpemF0aW9uUHJvZ3JhbUluZm8oaW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzLCBhdHRyaWJ1dGVzKVxuICAgICAgICAgIH0sXG4gICAgICAgICAgaW5wdXRzKTtcbiAgICAgIHJldHVybiBbb3V0cHV0XTtcbiAgICB9O1xuXG5leHBvcnQgY29uc3QgcGFyc2VCYXRjaE5vcm1hbGl6YXRpb25BdHRyaWJ1dGVzOiBPcGVyYXRvckluaXRpYWxpemF0aW9uPEJhdGNoTm9ybWFsaXphdGlvbkF0dHJpYnV0ZXM+ID1cbiAgICAobm9kZTogR3JhcGguTm9kZSk6IEJhdGNoTm9ybWFsaXphdGlvbkF0dHJpYnV0ZXMgPT4ge1xuICAgICAgY29uc3QgZXBzaWxvbiA9IG5vZGUuYXR0cmlidXRlcy5nZXRGbG9hdCgnZXBzaWxvbicsIDFlLTUpO1xuICAgICAgY29uc3QgbW9tZW50dW0gPSBub2RlLmF0dHJpYnV0ZXMuZ2V0RmxvYXQoJ21vbWVudHVtJywgMC45KTtcbiAgICAgIGNvbnN0IHNwYXRpYWwgPSBub2RlLmF0dHJpYnV0ZXMuZ2V0SW50KCdzcGF0aWFsJywgMSk7XG4gICAgICByZXR1cm4gY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KHtlcHNpbG9uLCBtb21lbnR1bSwgc3BhdGlhbH0pO1xuICAgIH07XG5cbmNvbnN0IGNyZWF0ZUJhdGNoTm9ybWFsaXphdGlvblByb2dyYW1JbmZvID1cbiAgICAoaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdLCBhdHRyaWJ1dGVzOiBCYXRjaE5vcm1hbGl6YXRpb25BdHRyaWJ1dGVzKTpcbiAgICAgICAgUHJvZ3JhbUluZm8gPT4ge1xuICAgICAgICAgIGNvbnN0IGdsc2wgPSBnZXRHbHNsKGluZmVyZW5jZUhhbmRsZXIuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC52ZXJzaW9uKTtcbiAgICAgICAgICBjb25zdCByYW5rID0gaW5wdXRzWzBdLmRpbXMubGVuZ3RoO1xuICAgICAgICAgIGNvbnN0IFtzY2FsZVdpZHRoLCBzY2FsZUhlaWdodF0gPVxuICAgICAgICAgICAgICBpbmZlcmVuY2VIYW5kbGVyLmNhbGN1bGF0ZVRleHR1cmVXaWR0aEFuZEhlaWdodChpbnB1dHNbMV0uZGltcywgVGV4dHVyZVR5cGUudW5wYWNrZWQpO1xuICAgICAgICAgIGNvbnN0IHNoYWRlclNvdXJjZSA9IGBcbiAgZmxvYXQgcHJvY2VzcyhpbnRbJHtyYW5rfV0gaW5kaWNlcykge1xuICAgIHZlYzIgcG9zaXRpb24gPSBvZmZzZXRUb0Nvb3JkcyhpbmRpY2VzWzFdLCAke3NjYWxlV2lkdGh9LCAke3NjYWxlSGVpZ2h0fSk7XG4gICAgZmxvYXQgc2NhbGUgPSBnZXRDb2xvckFzRmxvYXQoJHtnbHNsLnRleHR1cmUyRH0oU2NhbGUsIHBvc2l0aW9uKSk7XG4gICAgZmxvYXQgbWVhbiA9IGdldENvbG9yQXNGbG9hdCgke2dsc2wudGV4dHVyZTJEfShNZWFuLCBwb3NpdGlvbikpO1xuICAgIGZsb2F0IHZhcmlhbmNlID0gZ2V0Q29sb3JBc0Zsb2F0KCR7Z2xzbC50ZXh0dXJlMkR9KFZhcmlhbmNlLCBwb3NpdGlvbikpO1xuICAgIGZsb2F0IGIgPSBnZXRDb2xvckFzRmxvYXQoJHtnbHNsLnRleHR1cmUyRH0oQiwgcG9zaXRpb24pKTtcblxuICAgIHJldHVybiBzY2FsZSAqICggKF9BKGluZGljZXMpIC0gbWVhbikgLyBzcXJ0KHZhcmlhbmNlICsgZmxvYXQoJHthdHRyaWJ1dGVzLmVwc2lsb259KSkgKSArIGI7XG4gIH1gO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5iYXRjaE5vcm1hbGl6YXRpb25Qcm9ncmFtTWV0YWRhdGEsXG4gICAgICAgICAgICBvdXRwdXQ6IHtkaW1zOiBpbnB1dHNbMF0uZGltcywgdHlwZTogaW5wdXRzWzBdLnR5cGUsIHRleHR1cmVUeXBlOiBUZXh0dXJlVHlwZS51bnBhY2tlZH0sXG4gICAgICAgICAgICBzaGFkZXJTb3VyY2VcbiAgICAgICAgICB9O1xuICAgICAgICB9O1xuXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IFRlbnNvcltdKTogdm9pZCA9PiB7XG4gIGlmICghaW5wdXRzIHx8IGlucHV0cy5sZW5ndGggIT09IDUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0JhdGNoTm9ybWFsaXphdGlvbiByZXF1aXJlcyA1IGlucHV0cy4nKTtcbiAgfVxuXG4gIGNvbnN0IFggPSBpbnB1dHNbMF07XG4gIGNvbnN0IHNjYWxlID0gaW5wdXRzWzFdO1xuICBjb25zdCBCID0gaW5wdXRzWzJdO1xuICBjb25zdCBtZWFuID0gaW5wdXRzWzNdO1xuICBjb25zdCB2YXJfID0gaW5wdXRzWzRdO1xuXG4gIC8vIGlucHV0IHNob3VsZCBhdGxlYXN0IGhhdmUgdGhyZWUgZGltZW5zaW9ucyAtIE4sQyxkaW0xLC4uLixkaW1uXG4gIC8vIG90aGVyIGlucHV0cyBjYW4gaGF2ZSBvbmx5IG9uZSBkaW1lbnNpb25zXG4gIGlmIChYLmRpbXMubGVuZ3RoIDwgMyB8fCBzY2FsZS5kaW1zLmxlbmd0aCAhPT0gMSB8fCBCLmRpbXMubGVuZ3RoICE9PSAxIHx8IG1lYW4uZGltcy5sZW5ndGggIT09IDEgfHxcbiAgICAgIHZhcl8uZGltcy5sZW5ndGggIT09IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgaW5wdXQgc2hhcGUuJyk7XG4gIH1cbiAgaWYgKHNjYWxlLmRpbXNbMF0gIT09IFguZGltc1sxXSB8fCBCLmRpbXNbMF0gIT09IFguZGltc1sxXSB8fCBtZWFuLmRpbXNbMF0gIT09IFguZGltc1sxXSB8fFxuICAgICAgdmFyXy5kaW1zWzBdICE9PSBYLmRpbXNbMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgaW5wdXQgc2hhcGUuJyk7XG4gIH1cbiAgaWYgKChYLnR5cGUgIT09ICdmbG9hdDMyJyAmJiBYLnR5cGUgIT09ICdmbG9hdDY0JykgfHwgKHNjYWxlLnR5cGUgIT09ICdmbG9hdDMyJyAmJiBzY2FsZS50eXBlICE9PSAnZmxvYXQ2NCcpIHx8XG4gICAgICAoQi50eXBlICE9PSAnZmxvYXQzMicgJiYgQi50eXBlICE9PSAnZmxvYXQ2NCcpIHx8IChtZWFuLnR5cGUgIT09ICdmbG9hdDMyJyAmJiBtZWFuLnR5cGUgIT09ICdmbG9hdDY0JykgfHxcbiAgICAgICh2YXJfLnR5cGUgIT09ICdmbG9hdDMyJyAmJiB2YXJfLnR5cGUgIT09ICdmbG9hdDY0JykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgaW5wdXQgdGVuc29yIHR5cGVzLicpO1xuICB9XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge1Byb2dyYW1JbmZvLCBUZXh0dXJlTGF5b3V0fSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7V2ViR0xDb250ZXh0fSBmcm9tICcuL3dlYmdsLWNvbnRleHQnO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb24gKi9cbmV4cG9ydCBlbnVtIEZ1bmN0aW9uVHlwZSB7XG4gIFZhbHVlQmFzZWQsXG4gIFBvc2l0aW9uYWxcbn1cbmV4cG9ydCBpbnRlcmZhY2UgR2xzbEZ1bmN0aW9uPFQgZXh0ZW5kcyBGdW5jdGlvblR5cGU+IHtcbiAgYm9keTogc3RyaW5nO1xuICBuYW1lOiBzdHJpbmc7XG4gIHR5cGU6IFQ7XG59XG5leHBvcnQgdHlwZSBHbHNsVmFsdWVGdW5jdGlvbiA9IEdsc2xGdW5jdGlvbjxGdW5jdGlvblR5cGUuVmFsdWVCYXNlZD47XG5leHBvcnQgaW50ZXJmYWNlIEdsc2xQb3NpdGlvbmFsRnVuY3Rpb24gZXh0ZW5kcyBHbHNsRnVuY3Rpb248RnVuY3Rpb25UeXBlLlBvc2l0aW9uYWw+IHtcbiAgaW5wdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW107XG4gIG91dHB1dFNoYXBlOiByZWFkb25seSBudW1iZXJbXTtcbn1cblxuZXhwb3J0IGNsYXNzIEdsc2xDb250ZXh0IHtcbiAgY29uc3RydWN0b3IoXG4gICAgICBwdWJsaWMgZ2xDb250ZXh0OiBXZWJHTENvbnRleHQsIHB1YmxpYyBwcm9ncmFtSW5mbzogUHJvZ3JhbUluZm8sIHB1YmxpYyBpbnB1dFRleHR1cmVMYXlvdXRzOiBUZXh0dXJlTGF5b3V0W10sXG4gICAgICBwdWJsaWMgb3V0cHV0VGV4dHVyZUxheW91dDogVGV4dHVyZUxheW91dCkge31cbn1cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBHbHNsTGliIHtcbiAgY29uc3RydWN0b3IocHVibGljIGNvbnRleHQ6IEdsc2xDb250ZXh0KSB7fVxuICBhYnN0cmFjdCBnZXRGdW5jdGlvbnMoKToge1tuYW1lOiBzdHJpbmddOiBHbHNsTGliUm91dGluZX07XG4gIGFic3RyYWN0IGdldEN1c3RvbVR5cGVzKCk6IHtbbmFtZTogc3RyaW5nXTogc3RyaW5nfTtcbn1cblxuLy8gYWJzdHJhY3Rpb24gdG8gcmVwcmVzZW50IGEgR0xTTCBsaWJyYXJ5IHJvdXRpbmUgYW5kIGl0J3MgZGVwZW5kZW5jaWVzXG5leHBvcnQgY2xhc3MgR2xzbExpYlJvdXRpbmUge1xuICBjb25zdHJ1Y3RvcihwdWJsaWMgcm91dGluZUJvZHk6IHN0cmluZywgcHVibGljIGRlcGVuZGVuY2llcz86IHN0cmluZ1tdKSB7fVxufVxuXG4vLyBhYnN0cmFjdGlvbiB0byByZXByZXNlbnQgYSBHTFNMIGxpYnJhcnkgcm91dGluZSBhbmQgaXQncyBkZXBlbmRlbmNpZXMgQVMgR1JBUEggTm9kZXNcbi8vIHRoaXMgbGV2ZWwgb2YgYWJzdHJhY3Rpb24gaXMgdXNlZCB0byB0b3BvbG9naWNhbGx5IHNvcnQgcm91dGluZXMgYmVmb3JlIGZyYWdtZW50IHNoYWRlIGluY2x1c2lvblxuZXhwb3J0IGNsYXNzIEdsc2xMaWJSb3V0aW5lTm9kZSB7XG4gIGRlcGVuZGVuY2llczogR2xzbExpYlJvdXRpbmVOb2RlW107XG4gIHJvdXRpbmVCb2R5OiBzdHJpbmc7XG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBuYW1lOiBzdHJpbmcsIHJvdXRpbmVCb2R5Pzogc3RyaW5nLCBkZXBlbmRlbmNpZXM/OiBHbHNsTGliUm91dGluZU5vZGVbXSkge1xuICAgIGlmIChkZXBlbmRlbmNpZXMpIHtcbiAgICAgIHRoaXMuZGVwZW5kZW5jaWVzID0gZGVwZW5kZW5jaWVzO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRlcGVuZGVuY2llcyA9IFtdO1xuICAgIH1cblxuICAgIGlmIChyb3V0aW5lQm9keSkge1xuICAgICAgdGhpcy5yb3V0aW5lQm9keSA9IHJvdXRpbmVCb2R5O1xuICAgIH1cbiAgfVxuICBhZGREZXBlbmRlbmN5KG5vZGU6IEdsc2xMaWJSb3V0aW5lTm9kZSkge1xuICAgIGlmIChub2RlKSB7XG4gICAgICB0aGlzLmRlcGVuZGVuY2llcy5wdXNoKG5vZGUpO1xuICAgIH1cbiAgfVxufVxuXG4vLyB0b3BvbG9naWNhbGx5IHNvcnQgR0xTTCBsaWJyYXJ5IHJvdXRpbmVzIChncmFwaCBub2RlcyBhYnN0cmFjdGlvbikgYmVmb3JlIHNoYWRlciBzY3JpcHQgaW5jbHVzaW9uXG5leHBvcnQgY2xhc3MgVG9wb2xvZ2ljYWxTb3J0R2xzbFJvdXRpbmVzIHtcbiAgc3RhdGljIHJldHVybk9yZGVyZWROb2Rlcyhub2RlczogR2xzbExpYlJvdXRpbmVOb2RlW10pOiBHbHNsTGliUm91dGluZU5vZGVbXSB7XG4gICAgaWYgKCFub2RlcyB8fCBub2Rlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICBpZiAobm9kZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4gbm9kZXM7XG4gICAgfVxuXG4gICAgY29uc3QgY3ljbGVDaGVjayA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICAgIGNvbnN0IGFscmVhZHlUcmF2ZXJzZWQgPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgQXJyYXk8R2xzbExpYlJvdXRpbmVOb2RlPigpO1xuXG4gICAgdGhpcy5jcmVhdGVPcmRlcmVkTm9kZXMobm9kZXMsIGN5Y2xlQ2hlY2ssIGFscmVhZHlUcmF2ZXJzZWQsIHJlc3VsdCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHByaXZhdGUgc3RhdGljIGNyZWF0ZU9yZGVyZWROb2RlcyhcbiAgICAgIGdyYXBoTm9kZXM6IEdsc2xMaWJSb3V0aW5lTm9kZVtdLCBjeWNsZUNoZWNrOiBTZXQ8c3RyaW5nPiwgYWxyZWFkeVRyYXZlcnNlZDogU2V0PHN0cmluZz4sXG4gICAgICByZXN1bHQ6IEdsc2xMaWJSb3V0aW5lTm9kZVtdKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBncmFwaE5vZGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICB0aGlzLmRmc1RyYXZlcnNlKGdyYXBoTm9kZXNbaV0sIGN5Y2xlQ2hlY2ssIGFscmVhZHlUcmF2ZXJzZWQsIHJlc3VsdCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBzdGF0aWMgZGZzVHJhdmVyc2UoXG4gICAgICByb290OiBHbHNsTGliUm91dGluZU5vZGUsIGN5Y2xlQ2hlY2s6IFNldDxzdHJpbmc+LCBhbHJlYWR5VHJhdmVyc2VkOiBTZXQ8c3RyaW5nPiwgcmVzdWx0OiBHbHNsTGliUm91dGluZU5vZGVbXSkge1xuICAgIC8vIGlmIHRoaXMgcm9vdCBoYXMgYWxyZWFkeSBiZWVuIHRyYXZlcnNlZCByZXR1cm5cbiAgICBpZiAoIXJvb3QgfHwgYWxyZWFkeVRyYXZlcnNlZC5oYXMocm9vdC5uYW1lKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGN5Y2xpYyBkZXBlbmRlbmN5IGhhcyBiZWVuIGRldGVjdGVkXG4gICAgaWYgKGN5Y2xlQ2hlY2suaGFzKHJvb3QubmFtZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ3ljbGljIGRlcGVuZGVuY3kgZGV0ZWN0ZWQuIENhblxcJ3QgdG9wb2xvZ2ljYWxseSBzb3J0IHJvdXRpbmVzIG5lZWRlZCBmb3Igc2hhZGVyLicpO1xuICAgIH1cblxuICAgIC8vIGhvbGQgdGhpcyBub2RlIHRvIGRldGVjdCBjeWNsZXMgaWYgYW55XG4gICAgY3ljbGVDaGVjay5hZGQocm9vdC5uYW1lKTtcblxuICAgIC8vIHRyYXZlcnNlIGNoaWxkcmVuIGluIGEgZGZzIGZhc2hpb25cbiAgICBjb25zdCBkZXBlbmRlbmNpZXMgPSByb290LmRlcGVuZGVuY2llcztcbiAgICBpZiAoZGVwZW5kZW5jaWVzICYmIGRlcGVuZGVuY2llcy5sZW5ndGggPiAwKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlcGVuZGVuY2llcy5sZW5ndGg7ICsraSkge1xuICAgICAgICB0aGlzLmRmc1RyYXZlcnNlKGRlcGVuZGVuY2llc1tpXSwgY3ljbGVDaGVjaywgYWxyZWFkeVRyYXZlcnNlZCwgcmVzdWx0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBhZGQgdG8gcmVzdWx0IGhvbGRlclxuICAgIHJlc3VsdC5wdXNoKHJvb3QpO1xuXG4gICAgLy8gbWFyayB0aGlzIG5vZGUgYXMgdHJhdmVyc2VkIHNvIHRoYXQgd2UgZG9uJ3QgdHJhdmVyc2UgZnJvbSB0aGlzIGFnYWluXG4gICAgYWxyZWFkeVRyYXZlcnNlZC5hZGQocm9vdC5uYW1lKTtcblxuICAgIC8vIHJlbGVhc2UgdGhlIGhvbGRcbiAgICBjeWNsZUNoZWNrLmRlbGV0ZShyb290Lm5hbWUpO1xuICB9XG59XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7VGVuc29yfSBmcm9tICcuLi8uLi8uLi90ZW5zb3InO1xuaW1wb3J0IHtCcm9hZGNhc3RVdGlsLCBTaGFwZVV0aWx9IGZyb20gJy4uLy4uLy4uL3V0aWwnO1xuaW1wb3J0IHtGdW5jdGlvblR5cGUsIEdsc2xWYWx1ZUZ1bmN0aW9ufSBmcm9tICcuLi9nbHNsLWRlZmluaXRpb25zJztcbmltcG9ydCB7Z2V0R2xzbH0gZnJvbSAnLi4vZ2xzbC1zb3VyY2UnO1xuaW1wb3J0IHtXZWJHTEluZmVyZW5jZUhhbmRsZXJ9IGZyb20gJy4uL2luZmVyZW5jZS1oYW5kbGVyJztcbmltcG9ydCB7UHJvZ3JhbUluZm8sIFByb2dyYW1JbmZvTG9hZGVyLCBUZXh0dXJlVHlwZX0gZnJvbSAnLi4vdHlwZXMnO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2xzbEFkZCgpOiBHbHNsVmFsdWVGdW5jdGlvbiB7XG4gIGNvbnN0IG5hbWUgPSAnYWRkXyc7XG4gIGNvbnN0IGJvZHkgPSBgXG4gIGZsb2F0ICR7bmFtZX0oZmxvYXQgYSwgZmxvYXQgYikge1xuICAgIHJldHVybiBhICsgYjtcbiAgfVxuICB2ZWM0ICR7bmFtZX0odmVjNCB2MSwgdmVjNCB2Mikge1xuICAgIHJldHVybiB2MSArIHYyO1xuICB9XG4gIGA7XG4gIHJldHVybiB7Ym9keSwgbmFtZSwgdHlwZTogRnVuY3Rpb25UeXBlLlZhbHVlQmFzZWR9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdsc2xEaXYoKTogR2xzbFZhbHVlRnVuY3Rpb24ge1xuICBjb25zdCBuYW1lID0gJ2Rpdl8nO1xuICBjb25zdCBib2R5ID0gYFxuICBmbG9hdCAke25hbWV9KGZsb2F0IGEsIGZsb2F0IGIpIHtcbiAgICByZXR1cm4gYSAvIGI7XG4gIH1cbiAgdmVjNCAke25hbWV9KHZlYzQgdjEsIHZlYzQgdjIpIHtcbiAgICByZXR1cm4gdjEgLyB2MjtcbiAgfVxuICBgO1xuICByZXR1cm4ge2JvZHksIG5hbWUsIHR5cGU6IEZ1bmN0aW9uVHlwZS5WYWx1ZUJhc2VkfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnbHNsTXVsKCk6IEdsc2xWYWx1ZUZ1bmN0aW9uIHtcbiAgY29uc3QgbmFtZSA9ICdtdWxfJztcbiAgY29uc3QgYm9keSA9IGBcbiAgZmxvYXQgJHtuYW1lfShmbG9hdCBhLCBmbG9hdCBiKSB7XG4gICAgcmV0dXJuIGEgKiBiO1xuICB9XG4gIHZlYzQgJHtuYW1lfSh2ZWM0IHYxLCB2ZWM0IHYyKSB7XG4gICAgcmV0dXJuIHYxICogdjI7XG4gIH1cbiAgYDtcbiAgcmV0dXJuIHtib2R5LCBuYW1lLCB0eXBlOiBGdW5jdGlvblR5cGUuVmFsdWVCYXNlZH07XG59XG5leHBvcnQgZnVuY3Rpb24gZ2xzbFN1YigpOiBHbHNsVmFsdWVGdW5jdGlvbiB7XG4gIGNvbnN0IG5hbWUgPSAnc3ViXyc7XG4gIGNvbnN0IGJvZHkgPSBgXG4gIGZsb2F0ICR7bmFtZX0oZmxvYXQgYSwgZmxvYXQgYikge1xuICAgIHJldHVybiBhIC0gYjtcbiAgfVxuICB2ZWM0ICR7bmFtZX0odmVjNCB2MSwgdmVjNCB2Mikge1xuICAgIHJldHVybiB2MSAtIHYyO1xuICB9XG4gIGA7XG4gIHJldHVybiB7Ym9keSwgbmFtZSwgdHlwZTogRnVuY3Rpb25UeXBlLlZhbHVlQmFzZWR9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdsc2xFcXVhbCgpOiBHbHNsVmFsdWVGdW5jdGlvbiB7XG4gIGNvbnN0IG5hbWUgPSAnZXF1YWxfJztcbiAgY29uc3QgYm9keSA9IGBcbiAgZmxvYXQgJHtuYW1lfShmbG9hdCBhLCBmbG9hdCBiKSB7XG4gICAgcmV0dXJuIGZsb2F0KGEgPT0gYik7XG4gIH1cbiAgdmVjNCAke25hbWV9KHZlYzQgdjEsIHZlYzQgdjIpIHtcbiAgICByZXR1cm4gdmVjNChlcXVhbCh2MSwgdjIpKTtcbiAgfVxuICBgO1xuICByZXR1cm4ge2JvZHksIG5hbWUsIHR5cGU6IEZ1bmN0aW9uVHlwZS5WYWx1ZUJhc2VkfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnbHNsR3JlYXRlcigpOiBHbHNsVmFsdWVGdW5jdGlvbiB7XG4gIGNvbnN0IG5hbWUgPSAnZ3JlYXRlcl8nO1xuICBjb25zdCBib2R5ID0gYFxuICBmbG9hdCAke25hbWV9KGZsb2F0IGEsIGZsb2F0IGIpIHtcbiAgICByZXR1cm4gZmxvYXQoYSA+IGIpO1xuICB9XG4gIHZlYzQgJHtuYW1lfSh2ZWM0IHYxLCB2ZWM0IHYyKSB7XG4gICAgcmV0dXJuIHZlYzQoIHYxLnIgPiB2Mi5yICxcbiAgICAgIHYxLmcgPiB2Mi5nLFxuICAgICAgdjEuYiA+IHYyLmIsXG4gICAgICB2MS5hID4gdjIuYSApO1xuICB9XG4gIGA7XG4gIHJldHVybiB7Ym9keSwgbmFtZSwgdHlwZTogRnVuY3Rpb25UeXBlLlZhbHVlQmFzZWR9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdsc2xMZXNzKCk6IEdsc2xWYWx1ZUZ1bmN0aW9uIHtcbiAgY29uc3QgbmFtZSA9ICdsZXNzXyc7XG4gIGNvbnN0IGJvZHkgPSBgXG4gIGZsb2F0ICR7bmFtZX0oZmxvYXQgYSwgZmxvYXQgYikge1xuICAgIHJldHVybiBmbG9hdChhIDwgYik7XG4gIH1cbiAgdmVjNCAke25hbWV9KHZlYzQgdjEsIHZlYzQgdjIpIHtcbiAgICByZXR1cm4gdmVjNCggdjEuciA8IHYyLnIgLFxuICAgICAgICAgICAgICAgIHYxLmcgPCB2Mi5nLFxuICAgICAgICAgICAgICAgIHYxLmIgPCB2Mi5iLFxuICAgICAgICAgICAgICAgIHYxLmEgPCB2Mi5hICk7XG4gIH1cbiAgYDtcbiAgcmV0dXJuIHtib2R5LCBuYW1lLCB0eXBlOiBGdW5jdGlvblR5cGUuVmFsdWVCYXNlZH07XG59XG5leHBvcnQgZnVuY3Rpb24gZ2xzbEFuZCgpOiBHbHNsVmFsdWVGdW5jdGlvbiB7XG4gIGNvbnN0IG5hbWUgPSAnYW5kXyc7XG4gIGNvbnN0IGJvZHkgPSBgXG4gIGZsb2F0ICR7bmFtZX0oZmxvYXQgYSwgZmxvYXQgYikge1xuICAgIHJldHVybiBmbG9hdCggYm9vbChhKSAmJiBib29sKGIpICk7XG4gIH1cbiAgdmVjNCAke25hbWV9KHZlYzQgdjEsIHZlYzQgdjIpIHtcbiAgICBidmVjNCBiMSA9IGJ2ZWM0KHYxKTtcbiAgICBidmVjNCBiMiA9IGJ2ZWM0KHYyKTtcbiAgICByZXR1cm4gdmVjNCggYjEuciAmJiBiMi5yICxcbiAgICAgICAgICAgICAgICBiMS5nICYmIGIyLmcsXG4gICAgICAgICAgICAgICAgYjEuYiAmJiBiMi5iLFxuICAgICAgICAgICAgICAgIGIxLmEgJiYgYjIuYSApO1xuICB9XG4gIGA7XG4gIHJldHVybiB7Ym9keSwgbmFtZSwgdHlwZTogRnVuY3Rpb25UeXBlLlZhbHVlQmFzZWR9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdsc2xPcigpOiBHbHNsVmFsdWVGdW5jdGlvbiB7XG4gIGNvbnN0IG5hbWUgPSAnb3JfJztcbiAgY29uc3QgYm9keSA9IGBcbiAgZmxvYXQgJHtuYW1lfShmbG9hdCBhLCBmbG9hdCBiKSB7XG4gICAgcmV0dXJuIGZsb2F0KCBib29sKGEpIHx8IGJvb2woYikgKTtcbiAgfVxuICB2ZWM0ICR7bmFtZX0odmVjNCB2MSwgdmVjNCB2Mikge1xuICAgIGJ2ZWM0IGIxID0gYnZlYzQodjEpO1xuICAgIGJ2ZWM0IGIyID0gYnZlYzQodjIpO1xuICAgIHJldHVybiB2ZWM0KCBiMS5yIHx8IGIyLnIgLFxuICAgICAgICAgICAgICAgIGIxLmcgfHwgYjIuZyxcbiAgICAgICAgICAgICAgICBiMS5iIHx8IGIyLmIsXG4gICAgICAgICAgICAgICAgYjEuYSB8fCBiMi5hICk7XG4gIH1cbiAgYDtcbiAgcmV0dXJuIHtib2R5LCBuYW1lLCB0eXBlOiBGdW5jdGlvblR5cGUuVmFsdWVCYXNlZH07XG59XG5leHBvcnQgZnVuY3Rpb24gZ2xzbFhvcigpOiBHbHNsVmFsdWVGdW5jdGlvbiB7XG4gIGNvbnN0IG5hbWUgPSAneG9yXyc7XG4gIGNvbnN0IGJvZHkgPSBgXG4gIGZsb2F0ICR7bmFtZX0oZmxvYXQgYSwgZmxvYXQgYikge1xuICAgIHJldHVybiBmbG9hdCggYm9vbChhKSBeXiBib29sKGIpICk7XG4gIH1cbiAgdmVjNCAke25hbWV9KHZlYzQgdjEsIHZlYzQgdjIpIHtcbiAgICBidmVjNCBiMSA9IGJ2ZWM0KHYxKTtcbiAgICBidmVjNCBiMiA9IGJ2ZWM0KHYyKTtcbiAgICByZXR1cm4gdmVjNCggYjEuciBeXiBiMi5yICxcbiAgICAgICAgICAgICAgICBiMS5nIF5eIGIyLmcsXG4gICAgICAgICAgICAgICAgYjEuYiBeXiBiMi5iLFxuICAgICAgICAgICAgICAgIGIxLmEgXl4gYjIuYSApO1xuICB9XG4gIGA7XG4gIHJldHVybiB7Ym9keSwgbmFtZSwgdHlwZTogRnVuY3Rpb25UeXBlLlZhbHVlQmFzZWR9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdsc2xQb3coKTogR2xzbFZhbHVlRnVuY3Rpb24ge1xuICByZXR1cm4gZ2xzbEJ1aWx0aW5CaW5hcnkoJ3BvdycpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdsc2xQUmVsdSgpOiBHbHNsVmFsdWVGdW5jdGlvbiB7XG4gIGNvbnN0IG5hbWUgPSAncHJlbHVfJztcbiAgY29uc3QgYm9keSA9IGBcbiAgZmxvYXQgJHtuYW1lfShmbG9hdCBhLCBmbG9hdCBiKSB7XG4gICAgcmV0dXJuIGEgPCAwLjAgPyBhICogYjogYTtcbiAgfVxuICB2ZWM0ICR7bmFtZX0odmVjNCB2MSwgdmVjNCB2Mikge1xuICAgIHJldHVybiB2ZWM0KFxuICAgICAgdjEuciA8IDAuMCA/IHYxLnIgKiB2Mi5yOiB2MS5yLFxuICAgICAgdjEuZyA8IDAuMCA/IHYxLmcgKiB2Mi5nOiB2MS5nLFxuICAgICAgdjEuYiA8IDAuMCA/IHYxLmIgKiB2Mi5iOiB2MS5iLFxuICAgICAgdjEuYSA8IDAuMCA/IHYxLmEgKiB2Mi5hOiB2MS5hXG4gICAgICApO1xuICB9XG4gIGA7XG4gIHJldHVybiB7Ym9keSwgbmFtZSwgdHlwZTogRnVuY3Rpb25UeXBlLlZhbHVlQmFzZWR9O1xufVxuXG5mdW5jdGlvbiBnbHNsQnVpbHRpbkJpbmFyeShmbmFtZTogc3RyaW5nKTogR2xzbFZhbHVlRnVuY3Rpb24ge1xuICBjb25zdCBuYW1lID0gYCR7Zm5hbWV9X2A7XG4gIGNvbnN0IGJvZHkgPSBgXG4gIGZsb2F0ICR7bmFtZX0oZmxvYXQgYSwgZmxvYXQgYikge1xuICAgIHJldHVybiAke2ZuYW1lfShhLCBiKTtcbiAgfVxuICB2ZWM0ICR7bmFtZX0odmVjNCB2MSwgdmVjNCB2Mikge1xuICAgIHJldHVybiAke2ZuYW1lfSh2MSwgdjIpO1xuICB9XG4gIGA7XG4gIHJldHVybiB7Ym9keSwgbmFtZSwgdHlwZTogRnVuY3Rpb25UeXBlLlZhbHVlQmFzZWR9O1xufVxuXG5jb25zdCBjcmVhdGVCaW5hcnlQcm9ncmFtSW5mb0xvYWRlciA9XG4gICAgKGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSwgZ2xzbEZ1bmM6IEdsc2xWYWx1ZUZ1bmN0aW9uLFxuICAgICBvdXRwdXRUZW5zb3JUeXBlOiBUZW5zb3IuRGF0YVR5cGUgPSBpbnB1dHNbMF0udHlwZSwgY2FjaGVLZXk/OiBzdHJpbmcpOiBQcm9ncmFtSW5mb0xvYWRlciA9PiB7XG4gICAgICBjb25zdCB0ZXh0dXJlVHlwZSA9IGhhbmRsZXIuc2Vzc2lvbi5wYWNrID8gVGV4dHVyZVR5cGUucGFja2VkIDogVGV4dHVyZVR5cGUudW5wYWNrZWQ7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiBnbHNsRnVuYy5uYW1lLFxuICAgICAgICBpbnB1dE5hbWVzOiBbJ0EnLCAnQiddLFxuICAgICAgICBpbnB1dFR5cGVzOiBbdGV4dHVyZVR5cGUsIHRleHR1cmVUeXBlXSxcbiAgICAgICAgY2FjaGVIaW50OiBjYWNoZUtleSxcbiAgICAgICAgZ2V0OiAoKSA9PiBjcmVhdGVCaW5hcnlQcm9ncmFtSW5mbyhoYW5kbGVyLCBpbnB1dHMsIGdsc2xGdW5jLCBvdXRwdXRUZW5zb3JUeXBlKVxuICAgICAgfTtcbiAgICB9O1xuXG5jb25zdCBjcmVhdGVCaW5hcnlQcm9ncmFtSW5mbyA9XG4gICAgKGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSwgZ2xzbEZ1bmM6IEdsc2xWYWx1ZUZ1bmN0aW9uLFxuICAgICBvdXRwdXRUZW5zb3JUeXBlOiBUZW5zb3IuRGF0YVR5cGUgPSBpbnB1dHNbMF0udHlwZSk6IFByb2dyYW1JbmZvID0+IHtcbiAgICAgIGNvbnN0IHRleHR1cmVUeXBlID0gaGFuZGxlci5zZXNzaW9uLnBhY2sgPyBUZXh0dXJlVHlwZS5wYWNrZWQgOiBUZXh0dXJlVHlwZS51bnBhY2tlZDtcbiAgICAgIGNvbnN0IGlzQnJvYWRjYXN0ID0gIVNoYXBlVXRpbC5hcmVFcXVhbChpbnB1dHNbMF0uZGltcywgaW5wdXRzWzFdLmRpbXMpO1xuICAgICAgbGV0IG91dHB1dFNoYXBlID0gaW5wdXRzWzBdLmRpbXM7XG5cbiAgICAgIGNvbnN0IHVzZVBhY2tlZFRleHR1cmUgPSBoYW5kbGVyLnNlc3Npb24ucGFjaztcblxuICAgICAgaWYgKGlzQnJvYWRjYXN0KSB7XG4gICAgICAgIGNvbnN0IGNhbGN1bGF0ZWRTaGFwZSA9IEJyb2FkY2FzdFV0aWwuY2FsY1NoYXBlKGlucHV0c1swXS5kaW1zLCBpbnB1dHNbMV0uZGltcywgZmFsc2UpO1xuICAgICAgICBpZiAoIWNhbGN1bGF0ZWRTaGFwZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuXFwndCBwZXJmb3JtIGJpbmFyeSBvcCBvbiB0aGUgZ2l2ZW4gdGVuc29ycycpO1xuICAgICAgICB9XG4gICAgICAgIG91dHB1dFNoYXBlID0gY2FsY3VsYXRlZFNoYXBlO1xuICAgICAgICBjb25zdCBvdXRwdXRSYW5rID0gb3V0cHV0U2hhcGUubGVuZ3RoO1xuICAgICAgICBjb25zdCBhUmFuayA9IGlucHV0c1swXS5kaW1zLmxlbmd0aCAhPT0gMCA/IGlucHV0c1swXS5kaW1zLmxlbmd0aCA6IDE7XG4gICAgICAgIGNvbnN0IGJSYW5rID0gaW5wdXRzWzFdLmRpbXMubGVuZ3RoICE9PSAwID8gaW5wdXRzWzFdLmRpbXMubGVuZ3RoIDogMTtcbiAgICAgICAgY29uc3QgYUJjYXN0ID0gaW5wdXRzWzBdLmRpbXMubGVuZ3RoICE9PSAwID8gJ2JjYXN0SW5kaWNlc19BKGluZGljZXMsIGFpbmRpY2VzKTsnIDogJ2FpbmRpY2VzWzBdID0gMDsnO1xuICAgICAgICBjb25zdCBiQmNhc3QgPSBpbnB1dHNbMV0uZGltcy5sZW5ndGggIT09IDAgPyAnYmNhc3RJbmRpY2VzX0IoaW5kaWNlcywgYmluZGljZXMpOycgOiAnYmluZGljZXNbMF0gPSAwOyc7XG5cbiAgICAgICAgY29uc3QgZ2xzbCA9IGdldEdsc2woaGFuZGxlci5zZXNzaW9uLmJhY2tlbmQuZ2xDb250ZXh0LnZlcnNpb24pO1xuICAgICAgICBjb25zdCBzaGFkZXJTb3VyY2UgPSB1c2VQYWNrZWRUZXh0dXJlID8gYFxuICAgICAgJHtnbHNsRnVuYy5ib2R5fVxuICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICB2ZWM0IGEgPSBnZXRBQXRPdXRDb29yZHMoKTtcbiAgICAgICAgdmVjNCBiID0gZ2V0QkF0T3V0Q29vcmRzKCk7XG4gICAgICAgIHZlYzQgcmVzdWx0ID0gJHtnbHNsRnVuYy5uYW1lfShhLCBiKTtcbiAgICAgICAgJHtnbHNsLm91dHB1dH0gPSByZXN1bHQ7XG4gICAgICB9YCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgXG4gICAgICAke2dsc2xGdW5jLmJvZHl9XG4gICAgICBmbG9hdCBwcm9jZXNzKGludCBpbmRpY2VzWyR7b3V0cHV0UmFua31dKSB7XG4gICAgICAgIGludCBhaW5kaWNlc1ske2FSYW5rfV07XG4gICAgICAgIGludCBiaW5kaWNlc1ske2JSYW5rfV07XG4gICAgICAgICR7YUJjYXN0fVxuICAgICAgICAke2JCY2FzdH1cbiAgICAgICAgcmV0dXJuICR7Z2xzbEZ1bmMubmFtZX0oX0EoYWluZGljZXMpLCBfQihiaW5kaWNlcykpO1xuICAgICAgfWA7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBuYW1lOiBnbHNsRnVuYy5uYW1lLFxuICAgICAgICAgIGlucHV0TmFtZXM6IFsnQScsICdCJ10sXG4gICAgICAgICAgaW5wdXRUeXBlczogW3RleHR1cmVUeXBlLCB0ZXh0dXJlVHlwZV0sXG4gICAgICAgICAgb3V0cHV0OiB7ZGltczogb3V0cHV0U2hhcGUsIHR5cGU6IG91dHB1dFRlbnNvclR5cGUsIHRleHR1cmVUeXBlfSxcbiAgICAgICAgICBzaGFkZXJTb3VyY2UsXG4gICAgICAgICAgaGFzTWFpbjogdXNlUGFja2VkVGV4dHVyZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY29uc3QgZ2xzbCA9IGdldEdsc2woaGFuZGxlci5zZXNzaW9uLmJhY2tlbmQuZ2xDb250ZXh0LnZlcnNpb24pO1xuICAgICAgY29uc3Qgc2hhZGVyU291cmNlID0gYFxuICAgICR7Z2xzbEZ1bmMuYm9keX1cbiAgICB2b2lkIG1haW4oKSB7XG4gICAgICB2ZWM0IHYxID0gJHtnbHNsLnRleHR1cmUyRH0oQSwgVGV4Q29vcmRzKTtcbiAgICAgIHZlYzQgdjIgPSAke2dsc2wudGV4dHVyZTJEfShCLCBUZXhDb29yZHMpO1xuICAgICAgdmVjNCByZXN1bHQgPSAke2dsc2xGdW5jLm5hbWV9KHYxLCB2Mik7XG4gICAgICAke2dsc2wub3V0cHV0fSA9IHJlc3VsdDtcbiAgICB9XG4gICAgYDtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogZ2xzbEZ1bmMubmFtZSxcbiAgICAgICAgaW5wdXROYW1lczogWydBJywgJ0InXSxcbiAgICAgICAgaW5wdXRUeXBlczogW3RleHR1cmVUeXBlLCB0ZXh0dXJlVHlwZV0sXG4gICAgICAgIG91dHB1dDoge2RpbXM6IGlucHV0c1swXS5kaW1zLCB0eXBlOiBvdXRwdXRUZW5zb3JUeXBlLCB0ZXh0dXJlVHlwZX0sXG4gICAgICAgIHNoYWRlclNvdXJjZSxcbiAgICAgICAgaGFzTWFpbjogdHJ1ZVxuICAgICAgfTtcbiAgICB9O1xuXG5leHBvcnQgY29uc3QgYWRkID0gKGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6XG4gICAgVGVuc29yW10gPT4gW2hhbmRsZXIucnVuKGNyZWF0ZUJpbmFyeVByb2dyYW1JbmZvTG9hZGVyKGhhbmRsZXIsIGlucHV0cywgZ2xzbEFkZCgpKSwgaW5wdXRzKV07XG5cbmV4cG9ydCBjb25zdCBhbmQgPSAoaGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTpcbiAgICBUZW5zb3JbXSA9PiBbaGFuZGxlci5ydW4oY3JlYXRlQmluYXJ5UHJvZ3JhbUluZm9Mb2FkZXIoaGFuZGxlciwgaW5wdXRzLCBnbHNsQW5kKCksICdib29sJyksIGlucHV0cyldO1xuXG5leHBvcnQgY29uc3QgZGl2ID0gKGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6XG4gICAgVGVuc29yW10gPT4gW2hhbmRsZXIucnVuKGNyZWF0ZUJpbmFyeVByb2dyYW1JbmZvTG9hZGVyKGhhbmRsZXIsIGlucHV0cywgZ2xzbERpdigpKSwgaW5wdXRzKV07XG5cbmV4cG9ydCBjb25zdCBlcXVhbCA9IChoYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOlxuICAgIFRlbnNvcltdID0+IFtoYW5kbGVyLnJ1bihjcmVhdGVCaW5hcnlQcm9ncmFtSW5mb0xvYWRlcihoYW5kbGVyLCBpbnB1dHMsIGdsc2xFcXVhbCgpLCAnYm9vbCcpLCBpbnB1dHMpXTtcblxuZXhwb3J0IGNvbnN0IGdyZWF0ZXIgPSAoaGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTpcbiAgICBUZW5zb3JbXSA9PiBbaGFuZGxlci5ydW4oY3JlYXRlQmluYXJ5UHJvZ3JhbUluZm9Mb2FkZXIoaGFuZGxlciwgaW5wdXRzLCBnbHNsR3JlYXRlcigpLCAnYm9vbCcpLCBpbnB1dHMpXTtcblxuZXhwb3J0IGNvbnN0IGxlc3MgPSAoaGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTpcbiAgICBUZW5zb3JbXSA9PiBbaGFuZGxlci5ydW4oY3JlYXRlQmluYXJ5UHJvZ3JhbUluZm9Mb2FkZXIoaGFuZGxlciwgaW5wdXRzLCBnbHNsTGVzcygpLCAnYm9vbCcpLCBpbnB1dHMpXTtcblxuZXhwb3J0IGNvbnN0IG11bCA9IChoYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOlxuICAgIFRlbnNvcltdID0+IFtoYW5kbGVyLnJ1bihjcmVhdGVCaW5hcnlQcm9ncmFtSW5mb0xvYWRlcihoYW5kbGVyLCBpbnB1dHMsIGdsc2xNdWwoKSksIGlucHV0cyldO1xuXG5leHBvcnQgY29uc3Qgb3IgPSAoaGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTpcbiAgICBUZW5zb3JbXSA9PiBbaGFuZGxlci5ydW4oY3JlYXRlQmluYXJ5UHJvZ3JhbUluZm9Mb2FkZXIoaGFuZGxlciwgaW5wdXRzLCBnbHNsT3IoKSwgJ2Jvb2wnKSwgaW5wdXRzKV07XG5cbmV4cG9ydCBjb25zdCBwb3cgPSAoaGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTpcbiAgICBUZW5zb3JbXSA9PiBbaGFuZGxlci5ydW4oY3JlYXRlQmluYXJ5UHJvZ3JhbUluZm9Mb2FkZXIoaGFuZGxlciwgaW5wdXRzLCBnbHNsUG93KCkpLCBpbnB1dHMpXTtcblxuZXhwb3J0IGNvbnN0IHBSZWx1ID0gKGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6XG4gICAgVGVuc29yW10gPT4gW2hhbmRsZXIucnVuKGNyZWF0ZUJpbmFyeVByb2dyYW1JbmZvTG9hZGVyKGhhbmRsZXIsIGlucHV0cywgZ2xzbFBSZWx1KCkpLCBpbnB1dHMpXTtcblxuZXhwb3J0IGNvbnN0IHN1YiA9IChoYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOlxuICAgIFRlbnNvcltdID0+IFtoYW5kbGVyLnJ1bihjcmVhdGVCaW5hcnlQcm9ncmFtSW5mb0xvYWRlcihoYW5kbGVyLCBpbnB1dHMsIGdsc2xTdWIoKSksIGlucHV0cyldO1xuXG5leHBvcnQgY29uc3QgeG9yID0gKGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6XG4gICAgVGVuc29yW10gPT4gW2hhbmRsZXIucnVuKGNyZWF0ZUJpbmFyeVByb2dyYW1JbmZvTG9hZGVyKGhhbmRsZXIsIGlucHV0cywgZ2xzbFhvcigpLCAnYm9vbCcpLCBpbnB1dHMpXTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtHcmFwaH0gZnJvbSAnLi4vLi4vLi4vZ3JhcGgnO1xuaW1wb3J0IHtPcGVyYXRvckltcGxlbWVudGF0aW9uLCBPcGVyYXRvckluaXRpYWxpemF0aW9ufSBmcm9tICcuLi8uLi8uLi9vcGVyYXRvcnMnO1xuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4uLy4uLy4uL3RlbnNvcic7XG5pbXBvcnQge1Byb3RvVXRpbH0gZnJvbSAnLi4vLi4vLi4vdXRpbCc7XG5pbXBvcnQge1dlYkdMSW5mZXJlbmNlSGFuZGxlcn0gZnJvbSAnLi4vaW5mZXJlbmNlLWhhbmRsZXInO1xuXG5leHBvcnQgY29uc3QgY2FzdDogT3BlcmF0b3JJbXBsZW1lbnRhdGlvbjxUZW5zb3IuRGF0YVR5cGU+ID1cbiAgICAoaGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdLCB0bzogVGVuc29yLkRhdGFUeXBlKTogVGVuc29yW10gPT4ge1xuICAgICAgdmFsaWRhdGVJbnB1dHMoaW5wdXRzKTtcbiAgICAgIHJldHVybiBbaGFuZGxlci5jYXN0KGlucHV0c1swXSwgdG8pXTtcbiAgICB9O1xuXG5leHBvcnQgY29uc3QgcGFyc2VDYXN0QXR0cmlidXRlczogT3BlcmF0b3JJbml0aWFsaXphdGlvbjxUZW5zb3IuRGF0YVR5cGU+ID0gKG5vZGU6IEdyYXBoLk5vZGUpOiBUZW5zb3IuRGF0YVR5cGUgPT5cbiAgICBQcm90b1V0aWwudGVuc29yRGF0YVR5cGVGcm9tUHJvdG8obm9kZS5hdHRyaWJ1dGVzLmdldEludCgndG8nKSk7XG5cbmNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogVGVuc29yW10pOiB2b2lkID0+IHtcbiAgaWYgKCFpbnB1dHMgfHwgaW5wdXRzLmxlbmd0aCAhPT0gMSkge1xuICAgIHRocm93IG5ldyBFcnJvcignQ2FzdCByZXF1aXJlcyAxIGlucHV0LicpO1xuICB9XG5cbiAgaWYgKGlucHV0c1swXS50eXBlID09PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpbnB1dCB0eXBlLicpO1xuICB9XG59OyIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4uLy4uLy4uL3RlbnNvcic7XG5pbXBvcnQge2dldEdsc2x9IGZyb20gJy4uL2dsc2wtc291cmNlJztcbmltcG9ydCB7V2ViR0xJbmZlcmVuY2VIYW5kbGVyfSBmcm9tICcuLi9pbmZlcmVuY2UtaGFuZGxlcic7XG5pbXBvcnQge1Byb2dyYW1JbmZvLCBQcm9ncmFtSW5mb0xvYWRlciwgUHJvZ3JhbU1ldGFkYXRhLCBUZXh0dXJlVHlwZX0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHtnZXRDb29yZHNEYXRhVHlwZSwgZ2V0R2xDaGFubmVsc30gZnJvbSAnLi4vdXRpbHMnO1xuXG5pbXBvcnQge0NvbmNhdEF0dHJpYnV0ZXN9IGZyb20gJy4vY29uY2F0JztcbmltcG9ydCB7Z2V0Q2hhbm5lbHMsIHVucGFja0Zyb21DaGFubmVsfSBmcm9tICcuL3BhY2tpbmctdXRpbHMnO1xuXG5jb25zdCBjcmVhdGVQYWNrZWRDb25jYXRQcm9ncmFtTWV0YWRhdGEgPSAoaW5wdXRDb3VudDogbnVtYmVyLCBjYWNoZUhpbnQ6IHN0cmluZykgPT4gKHtcbiAgbmFtZTogJ0NvbmNhdCAocGFja2VkKScsXG4gIGlucHV0TmFtZXM6IEFycmF5LmZyb20oe2xlbmd0aDogaW5wdXRDb3VudH0sIChfdiwgaSkgPT4gYFgke2l9YCksXG4gIGlucHV0VHlwZXM6IEFycmF5KGlucHV0Q291bnQpLmZpbGwoVGV4dHVyZVR5cGUucGFja2VkKSxcbiAgY2FjaGVIaW50XG59KTtcblxuY29uc3QgY3JlYXRlUGFja2VkQ29uY2F0UHJvZ3JhbUluZm8gPVxuICAgIChoYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIG1ldGFkYXRhOiBQcm9ncmFtTWV0YWRhdGEsIGlucHV0czogVGVuc29yW10sIGF4aXM6IG51bWJlcik6IFByb2dyYW1JbmZvID0+IHtcbiAgICAgIGNvbnN0IGlucHV0U2hhcGUgPSBpbnB1dHNbMF0uZGltcy5zbGljZSgpO1xuICAgICAgaWYgKGF4aXMgPj0gaW5wdXRTaGFwZS5sZW5ndGggfHwgYXhpcyA8ICgtMSAqIGlucHV0U2hhcGUubGVuZ3RoKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2F4aXMgc3BlY2lmaWVkIGZvciBjb25jYXQgZG9lc25cXCd0IG1hdGNoIGlucHV0IGRpbWVuc2lvbmFsaXR5Jyk7XG4gICAgICB9XG4gICAgICBpZiAoYXhpcyA8IDApIHtcbiAgICAgICAgYXhpcyA9IGlucHV0U2hhcGUubGVuZ3RoICsgYXhpcztcbiAgICAgIH1cbiAgICAgIC8vIGVuc3VyZSBhbGwgb2YgdGhlIG5vbi1jb25jYXRlbmF0ZWQgYXhlcyBtYXRjaCBlYWNoIG90aGVyXG4gICAgICAvLyBjYWxjdWxhdGUgdGhlIHNoYXBlIG9mIHRoZSBvdXRwdXQgdGVuc29yIHdoaWxlIHdlIGRvIHRoYXRcbiAgICAgIGNvbnN0IG91dHB1dFNoYXBlID0gaW5wdXRTaGFwZS5zbGljZSgwKTtcbiAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgaW5wdXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGRhdGFOU2hhcGUgPSBpbnB1dHNbaV0uZGltcy5zbGljZSgpO1xuICAgICAgICBmb3IgKGxldCBheGlzSW5kZXggPSAwOyBheGlzSW5kZXggPCBpbnB1dFNoYXBlLmxlbmd0aDsgYXhpc0luZGV4KyspIHtcbiAgICAgICAgICAvLyBhZGQgdG8gdGhlIHBsYWNlaG9sZGVyIGZvciBjb21wdXRpbmcgb3V0cHV0IHNoYXBlXG4gICAgICAgICAgaWYgKGF4aXNJbmRleCA9PT0gYXhpcykge1xuICAgICAgICAgICAgb3V0cHV0U2hhcGVbYXhpc10gKz0gZGF0YU5TaGFwZVtheGlzSW5kZXhdO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBlbnN1cmUgYWxsIG5vbi1jYW5jYXRlbmF0ZWQgYXhlcyBtYXRjaCBlYWNoIG90aGVyXG4gICAgICAgICAgZWxzZSBpZiAoaW5wdXRTaGFwZVtheGlzSW5kZXhdICE9PSBkYXRhTlNoYXBlW2F4aXNJbmRleF0pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbm9uIGNvbmNhdCBkaW1lbnNpb25zIG11c3QgbWF0Y2gnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgcmFuayA9IG91dHB1dFNoYXBlLmxlbmd0aDtcbiAgICAgIGNvbnN0IGNvb3JkcyA9IGdldENoYW5uZWxzKCdjb29yZHMnLCByYW5rKTtcbiAgICAgIGNvbnN0IGR0eXBlID0gZ2V0Q29vcmRzRGF0YVR5cGUocmFuayk7XG4gICAgICBjb25zdCB1bnBhY2tDaGFubmVsID0gdW5wYWNrRnJvbUNoYW5uZWwoKTtcblxuICAgICAgY29uc3Qgc2hhcGVzID0gaW5wdXRzLm1hcChpID0+IGkuZGltcyk7XG4gICAgICBjb25zdCBjaGFubmVscyA9IGdldEdsQ2hhbm5lbHMocmFuayk7XG4gICAgICBjb25zdCBvZmZzZXRzOiBudW1iZXJbXSA9IG5ldyBBcnJheShzaGFwZXMubGVuZ3RoIC0gMSk7XG5cbiAgICAgIG9mZnNldHNbMF0gPSBzaGFwZXNbMF1bYXhpc107XG4gICAgICBmb3IgKGxldCBpID0gMTsgaSA8IG9mZnNldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgb2Zmc2V0c1tpXSA9IG9mZnNldHNbaSAtIDFdICsgc2hhcGVzW2ldW2F4aXNdO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBjaGFubmVsID0gY2hhbm5lbHNbYXhpc107XG4gICAgICBjb25zdCBsYXN0Q2hhbm5lbHMgPSBjaGFubmVscy5zbGljZSgtMik7XG4gICAgICBjb25zdCBhbGxDaGFubmVscyA9IGNoYW5uZWxzLmpvaW4oKTtcblxuICAgICAgbGV0IGdldFZhbHVlU25pcHBldCA9IGBpZiAoJHtjaGFubmVsfSA8ICR7b2Zmc2V0c1swXX0pIHtcbiAgICAgICAgcmV0dXJuIGdldENoYW5uZWwoXG4gICAgICAgICAgICBnZXRYMCgke2FsbENoYW5uZWxzfSksIHZlYzIoJHtsYXN0Q2hhbm5lbHMuam9pbigpfSkpO1xuICAgICAgICB9YDtcbiAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgb2Zmc2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBzaGlmdCA9IG9mZnNldHNbaSAtIDFdO1xuICAgICAgICBnZXRWYWx1ZVNuaXBwZXQgKz0gYFxuICAgICAgICAgICAgaWYgKCR7Y2hhbm5lbH0gPCAke29mZnNldHNbaV19ICAmJiAke2NoYW5uZWx9ID49ICR7b2Zmc2V0c1tpIC0gMV19KSB7XG4gICAgICAgICAgICAgIHJldHVybiBnZXRDaGFubmVsKFxuICAgICAgICAgICAgICAgIGdldFgke2l9KCR7Z2V0U2hpZnRlZENoYW5uZWxzU25pcHBldChjaGFubmVscywgY2hhbm5lbCwgc2hpZnQpfSksXG4gICAgICAgICAgICAgICAgdmVjMigke2dldFNoaWZ0ZWRDaGFubmVsc1NuaXBwZXQobGFzdENoYW5uZWxzLCBjaGFubmVsLCBzaGlmdCl9KSk7XG4gICAgICAgICAgICB9YDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxhc3RJbmRleCA9IG9mZnNldHMubGVuZ3RoO1xuICAgICAgY29uc3Qgc2hpZnQgPSBvZmZzZXRzW29mZnNldHMubGVuZ3RoIC0gMV07XG4gICAgICBnZXRWYWx1ZVNuaXBwZXQgKz0gYFxuICAgICAgICAgICAgcmV0dXJuIGdldENoYW5uZWwoXG4gICAgICAgICAgICAgIGdldFgke2xhc3RJbmRleH0oJHtnZXRTaGlmdGVkQ2hhbm5lbHNTbmlwcGV0KGNoYW5uZWxzLCBjaGFubmVsLCBzaGlmdCl9KSxcbiAgICAgICAgICAgICAgdmVjMigke2dldFNoaWZ0ZWRDaGFubmVsc1NuaXBwZXQobGFzdENoYW5uZWxzLCBjaGFubmVsLCBzaGlmdCl9KSk7YDtcblxuICAgICAgY29uc3QgZ2xzbCA9IGdldEdsc2woaGFuZGxlci5zZXNzaW9uLmJhY2tlbmQuZ2xDb250ZXh0LnZlcnNpb24pO1xuXG4gICAgICBjb25zdCBzaGFkZXJTb3VyY2UgPSBgXG4gICAgICAgICAgJHt1bnBhY2tDaGFubmVsfVxuICAgICAgICAgIGZsb2F0IGdldFZhbHVlKCR7Y2hhbm5lbHMubWFwKHggPT4gJ2ludCAnICsgeCl9KSB7XG4gICAgICAgICAgICAke2dldFZhbHVlU25pcHBldH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgICAgICAke2R0eXBlfSBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcbiAgICAgICAgICAgIGludCBsYXN0RGltID0gY29vcmRzLiR7Y2hhbm5lbHNbcmFuayAtIDFdfTtcbiAgICAgICAgICAgIGNvb3Jkcy4ke2NoYW5uZWxzW3JhbmsgLSAxXX0gPSBjb29yZHMuJHtjaGFubmVsc1tyYW5rIC0gMl19O1xuICAgICAgICAgICAgY29vcmRzLiR7Y2hhbm5lbHNbcmFuayAtIDJdfSA9IGxhc3REaW07XG5cbiAgICAgICAgICAgIHZlYzQgcmVzdWx0ID0gdmVjNChnZXRWYWx1ZSgke2Nvb3Jkc30pLCAwLiwgMC4sIDAuKTtcblxuICAgICAgICAgICAgJHtjb29yZHNbcmFuayAtIDFdfSA9ICR7Y29vcmRzW3JhbmsgLSAxXX0gKyAxO1xuICAgICAgICAgICAgaWYgKCR7Y29vcmRzW3JhbmsgLSAxXX0gPCAke291dHB1dFNoYXBlW3JhbmsgLSAxXX0pIHtcbiAgICAgICAgICAgICAgcmVzdWx0LmcgPSBnZXRWYWx1ZSgke2Nvb3Jkc30pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAke2Nvb3Jkc1tyYW5rIC0gMl19ID0gJHtjb29yZHNbcmFuayAtIDJdfSArIDE7XG4gICAgICAgICAgICBpZiAoJHtjb29yZHNbcmFuayAtIDJdfSA8ICR7b3V0cHV0U2hhcGVbcmFuayAtIDJdfSkge1xuICAgICAgICAgICAgICByZXN1bHQuYSA9IGdldFZhbHVlKCR7Y29vcmRzfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICR7Y29vcmRzW3JhbmsgLSAxXX0gPSAke2Nvb3Jkc1tyYW5rIC0gMV19IC0gMTtcbiAgICAgICAgICAgIGlmICgke2Nvb3Jkc1tyYW5rIC0gMl19IDwgJHtvdXRwdXRTaGFwZVtyYW5rIC0gMl19ICYmXG4gICAgICAgICAgICAgICAgJHtjb29yZHNbcmFuayAtIDFdfSA8ICR7b3V0cHV0U2hhcGVbcmFuayAtIDFdfSkge1xuICAgICAgICAgICAgICByZXN1bHQuYiA9IGdldFZhbHVlKCR7Y29vcmRzfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAke2dsc2wub3V0cHV0fSA9IHJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIGA7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLm1ldGFkYXRhLFxuICAgICAgICBvdXRwdXQ6IHtkaW1zOiBvdXRwdXRTaGFwZSwgdHlwZTogaW5wdXRzWzBdLnR5cGUsIHRleHR1cmVUeXBlOiBUZXh0dXJlVHlwZS5wYWNrZWR9LFxuICAgICAgICBzaGFkZXJTb3VyY2UsXG4gICAgICAgIGhhc01haW46IHRydWUsXG4gICAgICB9O1xuICAgIH07XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVQYWNrZWRDb25jYXRQcm9ncmFtSW5mb0xvYWRlciA9XG4gICAgKGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSwgYXR0cmlidXRlczogQ29uY2F0QXR0cmlidXRlcyk6IFByb2dyYW1JbmZvTG9hZGVyID0+IHtcbiAgICAgIGNvbnN0IG1ldGFkYXRhID0gY3JlYXRlUGFja2VkQ29uY2F0UHJvZ3JhbU1ldGFkYXRhKGlucHV0cy5sZW5ndGgsIGF0dHJpYnV0ZXMuY2FjaGVLZXkpO1xuICAgICAgcmV0dXJuIHsuLi5tZXRhZGF0YSwgZ2V0OiAoKSA9PiBjcmVhdGVQYWNrZWRDb25jYXRQcm9ncmFtSW5mbyhoYW5kbGVyLCBtZXRhZGF0YSwgaW5wdXRzLCBhdHRyaWJ1dGVzLmF4aXMpfTtcbiAgICB9O1xuXG5jb25zdCBnZXRTaGlmdGVkQ2hhbm5lbHNTbmlwcGV0ID0gKGNoYW5uZWxzOiBzdHJpbmdbXSwgY2hhbm5lbDogc3RyaW5nLCBzaGlmdDogbnVtYmVyKTogc3RyaW5nID0+IHtcbiAgY29uc3QgY2hhbm5lbElkeCA9IGNoYW5uZWxzLmluZGV4T2YoY2hhbm5lbCk7XG4gIGNvbnN0IHJlcyA9IGNoYW5uZWxzLm1hcCgoYywgaWR4KSA9PiB7XG4gICAgaWYgKGlkeCA9PT0gY2hhbm5lbElkeCkge1xuICAgICAgcmV0dXJuIGAke2N9IC0gJHtzaGlmdH1gO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYztcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzLmpvaW4oKTtcbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7QXR0cmlidXRlV2l0aENhY2hlS2V5LCBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXl9IGZyb20gJy4uLy4uLy4uL2F0dHJpYnV0ZS13aXRoLWNhY2hlLWtleSc7XG5pbXBvcnQge0dyYXBofSBmcm9tICcuLi8uLi8uLi9ncmFwaCc7XG5pbXBvcnQge09wZXJhdG9ySW1wbGVtZW50YXRpb24sIE9wZXJhdG9ySW5pdGlhbGl6YXRpb259IGZyb20gJy4uLy4uLy4uL29wZXJhdG9ycyc7XG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi4vLi4vLi4vdGVuc29yJztcbmltcG9ydCB7V2ViR0xJbmZlcmVuY2VIYW5kbGVyfSBmcm9tICcuLi9pbmZlcmVuY2UtaGFuZGxlcic7XG5pbXBvcnQge1Byb2dyYW1JbmZvLCBQcm9ncmFtSW5mb0xvYWRlciwgUHJvZ3JhbU1ldGFkYXRhLCBUZXh0dXJlVHlwZX0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQge2NyZWF0ZVBhY2tlZENvbmNhdFByb2dyYW1JbmZvTG9hZGVyfSBmcm9tICcuL2NvbmNhdC1wYWNrZWQnO1xuXG5leHBvcnQgaW50ZXJmYWNlIENvbmNhdEF0dHJpYnV0ZXMgZXh0ZW5kcyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkge1xuICByZWFkb25seSBheGlzOiBudW1iZXI7XG59XG5cbmV4cG9ydCBjb25zdCBjb25jYXQ6IE9wZXJhdG9ySW1wbGVtZW50YXRpb248Q29uY2F0QXR0cmlidXRlcz4gPVxuICAgIChpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10sIGF0dHJpYnV0ZXM6IENvbmNhdEF0dHJpYnV0ZXMpOiBUZW5zb3JbXSA9PiB7XG4gICAgICB2YWxpZGF0ZUlucHV0cyhpbnB1dHMpO1xuICAgICAgaWYgKGluZmVyZW5jZUhhbmRsZXIuc2Vzc2lvbi5wYWNrICYmIGlucHV0c1swXS5kaW1zLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgY29uc3Qgb3V0cHV0ID1cbiAgICAgICAgICAgIGluZmVyZW5jZUhhbmRsZXIucnVuKGNyZWF0ZVBhY2tlZENvbmNhdFByb2dyYW1JbmZvTG9hZGVyKGluZmVyZW5jZUhhbmRsZXIsIGlucHV0cywgYXR0cmlidXRlcyksIGlucHV0cyk7XG4gICAgICAgIHJldHVybiBbb3V0cHV0XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IG91dHB1dCA9XG4gICAgICAgICAgICBpbmZlcmVuY2VIYW5kbGVyLnJ1bihjcmVhdGVVbnBhY2tlZENvbmNhdFByb2dyYW1JbmZvTG9hZGVyKGluZmVyZW5jZUhhbmRsZXIsIGlucHV0cywgYXR0cmlidXRlcyksIGlucHV0cyk7XG4gICAgICAgIHJldHVybiBbb3V0cHV0XTtcbiAgICAgIH1cbiAgICB9O1xuXG5jb25zdCBjcmVhdGVVbnBhY2tlZENvbmNhdFByb2dyYW1NZXRhZGF0YSA9IChpbnB1dENvdW50OiBudW1iZXIsIGNhY2hlSGludDogc3RyaW5nKSA9PiAoe1xuICBuYW1lOiAnQ29uY2F0JyxcbiAgaW5wdXROYW1lczogQXJyYXkuZnJvbSh7bGVuZ3RoOiBpbnB1dENvdW50fSwgKF92LCBpKSA9PiBgWCR7aX1gKSxcbiAgaW5wdXRUeXBlczogQXJyYXkoaW5wdXRDb3VudCkuZmlsbChUZXh0dXJlVHlwZS51bnBhY2tlZCksXG4gIGNhY2hlSGludFxufSk7XG5cbmNvbnN0IGNyZWF0ZVVucGFja2VkQ29uY2F0UHJvZ3JhbUluZm8gPVxuICAgIChfaGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBtZXRhZGF0YTogUHJvZ3JhbU1ldGFkYXRhLCBpbnB1dHM6IFRlbnNvcltdLCBheGlzOiBudW1iZXIpOiBQcm9ncmFtSW5mbyA9PiB7XG4gICAgICBjb25zdCBpbnB1dFNoYXBlID0gaW5wdXRzWzBdLmRpbXMuc2xpY2UoKTtcbiAgICAgIGlmIChheGlzID49IGlucHV0U2hhcGUubGVuZ3RoIHx8IGF4aXMgPCAoLTEgKiBpbnB1dFNoYXBlLmxlbmd0aCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdheGlzIHNwZWNpZmllZCBmb3IgY29uY2F0IGRvZXNuXFwndCBtYXRjaCBpbnB1dCBkaW1lbnNpb25hbGl0eScpO1xuICAgICAgfVxuICAgICAgaWYgKGF4aXMgPCAwKSB7XG4gICAgICAgIGF4aXMgPSBpbnB1dFNoYXBlLmxlbmd0aCArIGF4aXM7XG4gICAgICB9XG4gICAgICAvLyBlbnN1cmUgYWxsIG9mIHRoZSBub24tY29uY2F0ZW5hdGVkIGF4ZXMgbWF0Y2ggZWFjaCBvdGhlclxuICAgICAgLy8gY2FsY3VsYXRlIHRoZSBzaGFwZSBvZiB0aGUgb3V0cHV0IHRlbnNvciB3aGlsZSB3ZSBkbyB0aGF0XG4gICAgICBjb25zdCBvdXRwdXRTaGFwZSA9IGlucHV0U2hhcGUuc2xpY2UoMCk7XG4gICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGlucHV0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBkYXRhTlNoYXBlID0gaW5wdXRzW2ldLmRpbXMuc2xpY2UoKTtcbiAgICAgICAgZm9yIChsZXQgYXhpc0luZGV4ID0gMDsgYXhpc0luZGV4IDwgaW5wdXRTaGFwZS5sZW5ndGg7IGF4aXNJbmRleCsrKSB7XG4gICAgICAgICAgLy8gYWRkIHRvIHRoZSBwbGFjZWhvbGRlciBmb3IgY29tcHV0aW5nIG91dHB1dCBzaGFwZVxuICAgICAgICAgIGlmIChheGlzSW5kZXggPT09IGF4aXMpIHtcbiAgICAgICAgICAgIG91dHB1dFNoYXBlW2F4aXNdICs9IGRhdGFOU2hhcGVbYXhpc0luZGV4XTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gZW5zdXJlIGFsbCBub24tY2FuY2F0ZW5hdGVkIGF4ZXMgbWF0Y2ggZWFjaCBvdGhlclxuICAgICAgICAgIGVsc2UgaWYgKGlucHV0U2hhcGVbYXhpc0luZGV4XSAhPT0gZGF0YU5TaGFwZVtheGlzSW5kZXhdKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vbiBjb25jYXQgZGltZW5zaW9ucyBtdXN0IG1hdGNoJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJhbmsgPSBvdXRwdXRTaGFwZS5sZW5ndGg7XG5cbiAgICAgIGNvbnN0IHNpemVJbkNvbmNhdEF4aXMgPSBuZXcgQXJyYXk8bnVtYmVyPihpbnB1dHMubGVuZ3RoKTtcbiAgICAgIGxldCBwcmV2aW91c1N1bSA9IDA7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpemVJbkNvbmNhdEF4aXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgcHJldmlvdXNTdW0gKz0gaW5wdXRzW2ldLmRpbXNbYXhpc107XG4gICAgICAgIHNpemVJbkNvbmNhdEF4aXNbaV0gPSBwcmV2aW91c1N1bTtcbiAgICAgIH1cblxuICAgICAgbGV0IGdldFRleHR1cmVJbmRleFdoZXJlRGF0YVJlc2lkZXNNZXRob2QgPSAnJztcbiAgICAgIC8vIGluIG1vc3QgY2FzZXMgbGluZWFyIHNlYXJjaCBpcyBzdWZmaWNpZW50LCBhcyBpbiBtb3N0IHNjZW5hcmlvcywgb25seSAyIHRlbnNvcnMgYXJlIGNvbmNhdGVuYXRlZFxuICAgICAgaWYgKGlucHV0cy5sZW5ndGggPCA1KSB7XG4gICAgICAgIGdldFRleHR1cmVJbmRleFdoZXJlRGF0YVJlc2lkZXNNZXRob2QgPSBnZXRUZXh0dXJlSW5kZXhXaGVyZURhdGFSZXNpZGVzTGluZWFyU2VhcmNoKHNpemVJbkNvbmNhdEF4aXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ2V0VGV4dHVyZUluZGV4V2hlcmVEYXRhUmVzaWRlc01ldGhvZCA9IGdldFRleHR1cmVJbmRleFdoZXJlRGF0YVJlc2lkZXNCaW5hcnlTZWFyY2goc2l6ZUluQ29uY2F0QXhpcyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGZldGNoRGF0YUZyb21Db3JyZWN0VGV4dHVyZU1ldGhvZCA9IGdldEZldGNoRGF0YUZyb21Db3JyZWN0VGV4dHVyZU1ldGhvZChpbnB1dHMubGVuZ3RoLCByYW5rKTtcbiAgICAgIGNvbnN0IGdldFNpemVJbkNvbmNhdEF4aXNWYWx1ZUZyb21JbmRleE1ldGhvZCA9IGdldEdldFNpemVJbkNvbmNhdEF4aXNWYWx1ZUZyb21JbmRleE1ldGhvZChzaXplSW5Db25jYXRBeGlzKTtcbiAgICAgIGNvbnN0IHNoYWRlclNvdXJjZSA9IGBcbiAgICAgICAgJHtmZXRjaERhdGFGcm9tQ29ycmVjdFRleHR1cmVNZXRob2R9XG4gICAgICAgICR7Z2V0U2l6ZUluQ29uY2F0QXhpc1ZhbHVlRnJvbUluZGV4TWV0aG9kfVxuICAgICAgICAke2dldFRleHR1cmVJbmRleFdoZXJlRGF0YVJlc2lkZXNNZXRob2R9XG4gICAgICAgIGZsb2F0IHByb2Nlc3MoaW50IGluZGljZXNbJHtyYW5rfV0pIHtcbiAgICAgICAgICBpbnQgdGV4dHVyZUluZGV4ID0gZ2V0VGV4dHVyZVdoZXJlRGF0YVJlc2lkZXMgKGluZGljZXNbJHtheGlzfV0pO1xuXG4gICAgICAgICAgaWYodGV4dHVyZUluZGV4ICE9IDApIHtcbiAgICAgICAgICAgIGluZGljZXNbJHtheGlzfV0gPSBpbmRpY2VzWyR7YXhpc31dIC0gaW50KGdldFNpemVJbkNvbmNhdEF4aXNWYWx1ZUZyb21JbmRleCh0ZXh0dXJlSW5kZXgtaW50KDEpKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGZldGNoRGF0YUZyb21Db3JyZWN0VGV4dHVyZSh0ZXh0dXJlSW5kZXgsIGluZGljZXMpO1xuICAgICAgICB9YDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLm1ldGFkYXRhLFxuICAgICAgICBvdXRwdXQ6IHtkaW1zOiBvdXRwdXRTaGFwZSwgdHlwZTogaW5wdXRzWzBdLnR5cGUsIHRleHR1cmVUeXBlOiBUZXh0dXJlVHlwZS51bnBhY2tlZH0sXG4gICAgICAgIHNoYWRlclNvdXJjZSxcbiAgICAgIH07XG4gICAgfTtcblxuY29uc3QgY3JlYXRlVW5wYWNrZWRDb25jYXRQcm9ncmFtSW5mb0xvYWRlciA9XG4gICAgKGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSwgYXR0cmlidXRlczogQ29uY2F0QXR0cmlidXRlcyk6IFByb2dyYW1JbmZvTG9hZGVyID0+IHtcbiAgICAgIGNvbnN0IG1ldGFkYXRhID0gY3JlYXRlVW5wYWNrZWRDb25jYXRQcm9ncmFtTWV0YWRhdGEoaW5wdXRzLmxlbmd0aCwgYXR0cmlidXRlcy5jYWNoZUtleSk7XG4gICAgICByZXR1cm4gey4uLm1ldGFkYXRhLCBnZXQ6ICgpID0+IGNyZWF0ZVVucGFja2VkQ29uY2F0UHJvZ3JhbUluZm8oaGFuZGxlciwgbWV0YWRhdGEsIGlucHV0cywgYXR0cmlidXRlcy5heGlzKX07XG4gICAgfTtcblxuY29uc3QgZ2V0VGV4dHVyZUluZGV4V2hlcmVEYXRhUmVzaWRlc0xpbmVhclNlYXJjaCA9IChzaXplSW5Db25jYXRBeGlzOiBudW1iZXJbXSk6IHN0cmluZyA9PiB7XG4gIGNvbnN0IHNlYXJjaEF4aXMgPSBzaXplSW5Db25jYXRBeGlzLm1hcCgoc2l6ZSwgaSkgPT4gYGlmKGluZGV4PCR7c2l6ZX0pIHtyZXR1cm4gJHtpfTt9XG5gKTtcbiAgcmV0dXJuIGBpbnQgZ2V0VGV4dHVyZVdoZXJlRGF0YVJlc2lkZXMoaW50IGluZGV4KSB7XG4gICAgICAke3NlYXJjaEF4aXMuam9pbignJyl9XG4gICAgfWA7XG59O1xuXG4vLyBUT0RPOiBJbXBsZW1lbnQgQmluYXJ5U2VhcmNoIGluIEdMU0xcbmNvbnN0IGdldFRleHR1cmVJbmRleFdoZXJlRGF0YVJlc2lkZXNCaW5hcnlTZWFyY2ggPSAoc2l6ZUluQ29uY2F0QXhpczogbnVtYmVyW10pOiBzdHJpbmcgPT5cbiAgICBnZXRUZXh0dXJlSW5kZXhXaGVyZURhdGFSZXNpZGVzTGluZWFyU2VhcmNoKHNpemVJbkNvbmNhdEF4aXMpO1xuXG5jb25zdCBnZXRGZXRjaERhdGFGcm9tQ29ycmVjdFRleHR1cmVNZXRob2QgPSAobnVtYmVyT2ZUZW5zb3JzOiBudW1iZXIsIHRlbnNvclJhbms6IG51bWJlcikgPT4ge1xuICBjb25zdCBjb2RlTGluZXM6IHN0cmluZ1tdID0gW2BmbG9hdCBmZXRjaERhdGFGcm9tQ29ycmVjdFRleHR1cmUoaW50IHRleHR1cmVJbmRleCwgaW50IGluZGljZXNbJHt0ZW5zb3JSYW5rfV0pIHtgXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1iZXJPZlRlbnNvcnM7ICsraSkge1xuICAgIGlmIChpID09PSAwKSB7XG4gICAgICBjb2RlTGluZXMucHVzaChcbiAgICAgICAgICAnXFx0JyArXG4gICAgICAgICAgYGlmICh0ZXh0dXJlSW5kZXggPT0gJHtpfSkgeyByZXR1cm4gX1gke2l9KGluZGljZXMpOyB9YCk7XG4gICAgfSBlbHNlIGlmIChpID09PSBudW1iZXJPZlRlbnNvcnMgLSAxKSB7XG4gICAgICBjb2RlTGluZXMucHVzaChcbiAgICAgICAgICAnXFx0JyArXG4gICAgICAgICAgYGVsc2UgeyByZXR1cm4gX1gke2l9KGluZGljZXMpOyB9YCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvZGVMaW5lcy5wdXNoKFxuICAgICAgICAgICdcXHQnICtcbiAgICAgICAgICBgZWxzZSBpZiAodGV4dHVyZUluZGV4ID09ICR7aX0pIHsgcmV0dXJuIF9YJHtpfShpbmRpY2VzKTsgfWApO1xuICAgIH1cbiAgfVxuICBjb2RlTGluZXMucHVzaChcbiAgICAgICdcXHQnICtcbiAgICAgICd9Jyk7XG4gIHJldHVybiBjb2RlTGluZXMuam9pbignXFxuJyk7XG59O1xuXG5jb25zdCBnZXRHZXRTaXplSW5Db25jYXRBeGlzVmFsdWVGcm9tSW5kZXhNZXRob2QgPSAoc2l6ZUluQ29uY2F0QXhpczogbnVtYmVyW10pOiBzdHJpbmcgPT4ge1xuICBjb25zdCBjb2RlTGluZXM6IHN0cmluZ1tdID0gWydpbnQgZ2V0U2l6ZUluQ29uY2F0QXhpc1ZhbHVlRnJvbUluZGV4KGludCBpbmRleCkgeyddO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNpemVJbkNvbmNhdEF4aXMubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgY29kZUxpbmVzLnB1c2goXG4gICAgICAgICAgJ1xcdCcgK1xuICAgICAgICAgIGBpZiAoaW5kZXggPT0gJHtpfSkgeyByZXR1cm4gJHtzaXplSW5Db25jYXRBeGlzW2ldfTsgfWApO1xuICAgIH0gZWxzZSBpZiAoaSA9PT0gc2l6ZUluQ29uY2F0QXhpcy5sZW5ndGggLSAxKSB7XG4gICAgICBjb2RlTGluZXMucHVzaChcbiAgICAgICAgICAnXFx0JyArXG4gICAgICAgICAgYGVsc2UgeyByZXR1cm4gJHtzaXplSW5Db25jYXRBeGlzW2ldfTsgfWApO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb2RlTGluZXMucHVzaChcbiAgICAgICAgICAnXFx0JyArXG4gICAgICAgICAgYGVsc2UgaWYgKGluZGV4ID09ICR7aX0pIHsgcmV0dXJuICR7c2l6ZUluQ29uY2F0QXhpc1tpXX07IH1gKTtcbiAgICB9XG4gIH1cbiAgY29kZUxpbmVzLnB1c2goXG4gICAgICAnXFx0JyArXG4gICAgICAnfScpO1xuXG4gIHJldHVybiBjb2RlTGluZXMuam9pbignXFxuJyk7XG59O1xuXG5leHBvcnQgY29uc3QgcGFyc2VDb25jYXRBdHRyaWJ1dGVzOiBPcGVyYXRvckluaXRpYWxpemF0aW9uPENvbmNhdEF0dHJpYnV0ZXM+ID0gKG5vZGU6IEdyYXBoLk5vZGUpOiBDb25jYXRBdHRyaWJ1dGVzID0+XG4gICAgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KHtheGlzOiBub2RlLmF0dHJpYnV0ZXMuZ2V0SW50KCdheGlzJyl9KTtcblxuY29uc3QgdmFsaWRhdGVJbnB1dHMgPSAoaW5wdXRzOiBUZW5zb3JbXSk6IHZvaWQgPT4ge1xuICBpZiAoIWlucHV0cyB8fCBpbnB1dHMubGVuZ3RoIDwgMSkge1xuICAgIHRocm93IG5ldyBFcnJvcigndG9vIGZldyBpbnB1dHMnKTtcbiAgfVxuXG4gIGNvbnN0IGlucHV0VHlwZSA9IGlucHV0c1swXS50eXBlO1xuICBjb25zdCBpbnB1dERpbWVuc2lvbmFsaXR5ID0gaW5wdXRzWzBdLmRpbXMubGVuZ3RoO1xuXG4gIC8vIFRPRE86IFN1cHBvcnQgc3RyaW5nIGNvbmNhdFxuICBpZiAoaW5wdXRUeXBlID09PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBFcnJvcignc3RyaW5nIHRlbnNvciBpcyBub3Qgc3VwcG9ydGVkIHlldCcpO1xuICB9XG5cbiAgZm9yIChjb25zdCBpbnB1dCBvZiBpbnB1dHMpIHtcbiAgICAvLyBtYWtlIHN1cmUgdHlwZXMgb2YgYWxsIGlucHV0cyBtYXRjaFxuICAgIGlmIChpbnB1dC50eXBlICE9PSBpbnB1dFR5cGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW5wdXQgdGVuc29ycyBzaG91bGQgYmUgb25lIHR5cGUnKTtcbiAgICB9XG5cbiAgICAvLyBtYWtlIHN1cmUgdGhlIGRpbWVuc2lvbmFsaXR5IG9mIGFsbCBpbnB1dHMgYXJlIHRoZSBzYW1lXG4gICAgaWYgKGlucHV0LmRpbXMubGVuZ3RoICE9PSBpbnB1dERpbWVuc2lvbmFsaXR5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lucHV0IHRlbnNvcnMgc2hvdWxkIGhhdmUgdGhlIHNhbWUgc2hhcGUnKTtcbiAgICB9XG4gIH1cbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7QXR0cmlidXRlV2l0aENhY2hlS2V5LCBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXl9IGZyb20gJy4uLy4uLy4uL2F0dHJpYnV0ZS13aXRoLWNhY2hlLWtleSc7XG5pbXBvcnQge0dyYXBofSBmcm9tICcuLi8uLi8uLi9ncmFwaCc7XG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi4vLi4vLi4vdGVuc29yJztcbmltcG9ydCB7TUFYX0NMSVAsIE1JTl9DTElQfSBmcm9tICcuLi8uLi8uLi91dGlsJztcbmltcG9ydCB7RnVuY3Rpb25UeXBlLCBHbHNsVmFsdWVGdW5jdGlvbn0gZnJvbSAnLi4vZ2xzbC1kZWZpbml0aW9ucyc7XG5pbXBvcnQge2dldEdsc2x9IGZyb20gJy4uL2dsc2wtc291cmNlJztcbmltcG9ydCB7V2ViR0xJbmZlcmVuY2VIYW5kbGVyfSBmcm9tICcuLi9pbmZlcmVuY2UtaGFuZGxlcic7XG5pbXBvcnQge1Byb2dyYW1JbmZvLCBQcm9ncmFtSW5mb0xvYWRlciwgUHJvZ3JhbU1ldGFkYXRhLCBUZXh0dXJlVHlwZX0gZnJvbSAnLi4vdHlwZXMnO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2xzbEFicygpOiBHbHNsVmFsdWVGdW5jdGlvbiB7XG4gIHJldHVybiBnbHNsQnVpbHRpblVuYXJ5KCdhYnMnKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnbHNsQWNvcygpOiBHbHNsVmFsdWVGdW5jdGlvbiB7XG4gIHJldHVybiBnbHNsQnVpbHRpblVuYXJ5KCdhY29zJyk7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2xzbEFzaW4oKTogR2xzbFZhbHVlRnVuY3Rpb24ge1xuICByZXR1cm4gZ2xzbEJ1aWx0aW5VbmFyeSgnYXNpbicpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdsc2xBdGFuKCk6IEdsc2xWYWx1ZUZ1bmN0aW9uIHtcbiAgcmV0dXJuIGdsc2xCdWlsdGluVW5hcnkoJ2F0YW4nKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnbHNsQ2VpbCgpOiBHbHNsVmFsdWVGdW5jdGlvbiB7XG4gIHJldHVybiBnbHNsQnVpbHRpblVuYXJ5KCdjZWlsJyk7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2xzbENvcygpOiBHbHNsVmFsdWVGdW5jdGlvbiB7XG4gIHJldHVybiBnbHNsQnVpbHRpblVuYXJ5KCdjb3MnKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnbHNsRWx1KGFscGhhOiBudW1iZXIpOiBHbHNsVmFsdWVGdW5jdGlvbiB7XG4gIGNvbnN0IG5hbWUgPSAnZWx1JztcbiAgY29uc3QgYm9keSA9IGBcbiAgY29uc3QgZmxvYXQgYWxwaGEgPSBmbG9hdCgke2FscGhhfSk7XG5cbiAgZmxvYXQgJHtuYW1lfV8oZmxvYXQgYSkge1xuICAgIHJldHVybiBhID49IDAuMCA/IGE6IChleHAoYSkgLSAxLjApICogYWxwaGE7XG4gIH1cbiAgdmVjNCAke25hbWV9Xyh2ZWM0IHYpIHtcbiAgICByZXR1cm4gdmVjNCgke25hbWV9Xyh2LngpLCAke25hbWV9Xyh2LnkpLCAke25hbWV9Xyh2LnopLCAke25hbWV9Xyh2LncpKTtcbiAgfVxuICBgO1xuICByZXR1cm4ge2JvZHksIG5hbWUsIHR5cGU6IEZ1bmN0aW9uVHlwZS5WYWx1ZUJhc2VkfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnbHNsRXhwKCk6IEdsc2xWYWx1ZUZ1bmN0aW9uIHtcbiAgcmV0dXJuIGdsc2xCdWlsdGluVW5hcnkoJ2V4cCcpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdsc2xGbG9vcigpOiBHbHNsVmFsdWVGdW5jdGlvbiB7XG4gIHJldHVybiBnbHNsQnVpbHRpblVuYXJ5KCdmbG9vcicpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdsc2xDbGlwKG1pbjogbnVtYmVyLCBtYXg6IG51bWJlcik6IEdsc2xWYWx1ZUZ1bmN0aW9uIHtcbiAgY29uc3QgbmFtZSA9ICdjbGlwJztcbiAgY29uc3QgYm9keSA9IGBcbiAgY29uc3QgZmxvYXQgbWluID0gZmxvYXQoJHttaW59KTtcbiAgY29uc3QgZmxvYXQgbWF4ID0gZmxvYXQoJHttYXh9KTtcblxuICBmbG9hdCAke25hbWV9XyhmbG9hdCBhKSB7XG4gICAgcmV0dXJuIGNsYW1wKGEsIG1pbiwgbWF4KTtcbiAgfVxuICB2ZWM0ICR7bmFtZX1fKHZlYzQgdikge1xuICAgIHJldHVybiBjbGFtcCh2LCBtaW4sIG1heCk7XG4gIH1cbiAgYDtcbiAgcmV0dXJuIHtib2R5LCBuYW1lLCB0eXBlOiBGdW5jdGlvblR5cGUuVmFsdWVCYXNlZH07XG59XG5leHBvcnQgZnVuY3Rpb24gZ2xzbElkZW50aXR5KCk6IEdsc2xWYWx1ZUZ1bmN0aW9uIHtcbiAgY29uc3QgbmFtZSA9ICdpbmRlbnRpdHknO1xuICBjb25zdCBib2R5ID0gYFxuICBmbG9hdCAke25hbWV9XyhmbG9hdCBhKSB7XG4gICAgcmV0dXJuIGE7XG4gIH1cbiAgdmVjNCAke25hbWV9Xyh2ZWM0IHYpIHtcbiAgICByZXR1cm4gdjtcbiAgfVxuICBgO1xuICByZXR1cm4ge2JvZHksIG5hbWUsIHR5cGU6IEZ1bmN0aW9uVHlwZS5WYWx1ZUJhc2VkfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnbHNsTGVha3lSZWx1KGFscGhhOiBudW1iZXIpOiBHbHNsVmFsdWVGdW5jdGlvbiB7XG4gIGNvbnN0IG5hbWUgPSAnbGVha3lSZWx1JztcbiAgY29uc3QgYm9keSA9IGBcbiAgY29uc3QgZmxvYXQgYWxwaGEgPSBmbG9hdCgke2FscGhhfSk7XG5cbiAgZmxvYXQgJHtuYW1lfV8oZmxvYXQgYSkge1xuICAgIHJldHVybiBhIDwgMC4wID8gYSAqIGFscGhhIDogYTtcbiAgfVxuICB2ZWM0ICR7bmFtZX1fKHZlYzQgdikge1xuICAgIHJldHVybiB2ZWM0KCR7bmFtZX1fKHYueCksICR7bmFtZX1fKHYueSksICR7bmFtZX1fKHYueiksICR7bmFtZX1fKHYudykpO1xuICB9XG4gIGA7XG4gIHJldHVybiB7Ym9keSwgbmFtZSwgdHlwZTogRnVuY3Rpb25UeXBlLlZhbHVlQmFzZWR9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdsc2xMb2coKTogR2xzbFZhbHVlRnVuY3Rpb24ge1xuICByZXR1cm4gZ2xzbEJ1aWx0aW5VbmFyeSgnbG9nJyk7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2xzbE5lZygpOiBHbHNsVmFsdWVGdW5jdGlvbiB7XG4gIGNvbnN0IG5hbWUgPSAnbmVnJztcbiAgY29uc3QgYm9keSA9IGBcbiAgZmxvYXQgJHtuYW1lfV8oZmxvYXQgYSkge1xuICAgIHJldHVybiAtYTtcbiAgfVxuICB2ZWM0ICR7bmFtZX1fKHZlYzQgdikge1xuICAgIHJldHVybiAtdjtcbiAgfVxuICBgO1xuICByZXR1cm4ge2JvZHksIG5hbWUsIHR5cGU6IEZ1bmN0aW9uVHlwZS5WYWx1ZUJhc2VkfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnbHNsTm90KCk6IEdsc2xWYWx1ZUZ1bmN0aW9uIHtcbiAgY29uc3QgbmFtZSA9ICdub3QnO1xuICBjb25zdCBib2R5ID0gYFxuICBmbG9hdCAke25hbWV9XyhmbG9hdCBhKSB7XG4gICAgcmV0dXJuIGZsb2F0KCAhIGJvb2woYSkgKTtcbiAgfVxuICBib29sICR7bmFtZX1fKGJvb2wgYSkge1xuICAgIHJldHVybiAhYTtcbiAgfVxuICB2ZWM0ICR7bmFtZX1fKHZlYzQgdikge1xuICAgIHJldHVybiB2ZWM0KCFib29sKHYueCksICFib29sKHYueSksICFib29sKHYueiksICFib29sKHYudykpO1xuICB9XG4gIGJ2ZWM0ICR7bmFtZX1fKGJ2ZWM0IHYpIHtcbiAgICByZXR1cm4gYnZlYzQoIXYueCwgIXYueSwgIXYueiwgIXYudyk7XG4gIH1cbiAgYDtcbiAgcmV0dXJuIHtib2R5LCBuYW1lLCB0eXBlOiBGdW5jdGlvblR5cGUuVmFsdWVCYXNlZH07XG59XG5leHBvcnQgZnVuY3Rpb24gZ2xzbFNpbigpOiBHbHNsVmFsdWVGdW5jdGlvbiB7XG4gIHJldHVybiBnbHNsQnVpbHRpblVuYXJ5KCdzaW4nKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnbHNsUmVsdSgpOiBHbHNsVmFsdWVGdW5jdGlvbiB7XG4gIGNvbnN0IG5hbWUgPSAncmVsdSc7XG4gIGNvbnN0IGJvZHkgPSBgXG4gIGZsb2F0ICR7bmFtZX1fKGZsb2F0IGEpIHtcbiAgICByZXR1cm4gbWF4KCBhLCAwLjAgKTtcbiAgfVxuICB2ZWM0ICR7bmFtZX1fKHZlYzQgdikge1xuICAgIHJldHVybiBtYXgoIHYsIDAuMCApO1xuICB9XG4gIGA7XG4gIHJldHVybiB7Ym9keSwgbmFtZSwgdHlwZTogRnVuY3Rpb25UeXBlLlZhbHVlQmFzZWR9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdsc2xTaWdtb2lkKCk6IEdsc2xWYWx1ZUZ1bmN0aW9uIHtcbiAgY29uc3QgbmFtZSA9ICdzaWdtb2lkJztcbiAgY29uc3QgYm9keSA9IGBcbiAgZmxvYXQgJHtuYW1lfV8oZmxvYXQgYSkge1xuICAgIHJldHVybiAxLjAgLyAoMS4wICsgZXhwKC1hKSk7XG4gIH1cbiAgdmVjNCAke25hbWV9Xyh2ZWM0IHYpIHtcbiAgICByZXR1cm4gMS4wIC8gKDEuMCArIGV4cCgtdikpO1xuICB9XG4gIGA7XG4gIHJldHVybiB7Ym9keSwgbmFtZSwgdHlwZTogRnVuY3Rpb25UeXBlLlZhbHVlQmFzZWR9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdsc2xTcXJ0KCk6IEdsc2xWYWx1ZUZ1bmN0aW9uIHtcbiAgcmV0dXJuIGdsc2xCdWlsdGluVW5hcnkoJ3NxcnQnKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnbHNsVGFuKCk6IEdsc2xWYWx1ZUZ1bmN0aW9uIHtcbiAgcmV0dXJuIGdsc2xCdWlsdGluVW5hcnkoJ3RhbicpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdsc2xUYW5oKCk6IEdsc2xWYWx1ZUZ1bmN0aW9uIHtcbiAgY29uc3QgbmFtZSA9ICd0YW5oJztcbiAgY29uc3QgYm9keSA9IGBcbiAgZmxvYXQgJHtuYW1lfV8oZmxvYXQgYSkge1xuICAgIGEgPSBjbGFtcChhLCAtMTAuLCAxMC4pO1xuICAgIGEgPSBleHAoMi4qYSk7XG4gICAgcmV0dXJuIChhIC0gMS4pIC8gKGEgKyAxLik7XG4gIH1cbiAgdmVjNCAke25hbWV9Xyh2ZWM0IHYpIHtcbiAgICB2ID0gY2xhbXAodiwgLTEwLiwgMTAuKTtcbiAgICB2ID0gZXhwKDIuKnYpO1xuICAgIHJldHVybiAodiAtIDEuKSAvICh2ICsgMS4pO1xuICB9XG4gIGA7XG4gIHJldHVybiB7Ym9keSwgbmFtZSwgdHlwZTogRnVuY3Rpb25UeXBlLlZhbHVlQmFzZWR9O1xufVxuZnVuY3Rpb24gZ2xzbEJ1aWx0aW5VbmFyeShuYW1lOiBzdHJpbmcpOiBHbHNsVmFsdWVGdW5jdGlvbiB7XG4gIGNvbnN0IGJvZHkgPSBgXG4gIGZsb2F0ICR7bmFtZX1fKGZsb2F0IGEpIHtcbiAgICByZXR1cm4gJHtuYW1lfShhKTtcbiAgfVxuICB2ZWM0ICR7bmFtZX1fKHZlYzQgdikge1xuICAgIHJldHVybiAke25hbWV9KHYpO1xuICB9XG4gIGA7XG4gIHJldHVybiB7Ym9keSwgbmFtZSwgdHlwZTogRnVuY3Rpb25UeXBlLlZhbHVlQmFzZWR9O1xufVxuXG4vLy8vL1xuLy8vLy9cbi8vLy8vXG5cbmNvbnN0IGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm8gPVxuICAgIChoYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIG1ldGFkYXRhOiBQcm9ncmFtTWV0YWRhdGEsIGlucHV0OiBUZW5zb3IsIGdsc2xGdW5jOiBHbHNsVmFsdWVGdW5jdGlvbik6XG4gICAgICAgIFByb2dyYW1JbmZvID0+IHtcbiAgICAgICAgICBjb25zdCB0ZXh0dXJlVHlwZSA9IGhhbmRsZXIuc2Vzc2lvbi5wYWNrID8gVGV4dHVyZVR5cGUucGFja2VkIDogVGV4dHVyZVR5cGUudW5wYWNrZWQ7XG4gICAgICAgICAgY29uc3QgZ2xzbCA9IGdldEdsc2woaGFuZGxlci5zZXNzaW9uLmJhY2tlbmQuZ2xDb250ZXh0LnZlcnNpb24pO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5tZXRhZGF0YSxcbiAgICAgICAgICAgIG91dHB1dDoge2RpbXM6IGlucHV0LmRpbXMsIHR5cGU6IGlucHV0LnR5cGUsIHRleHR1cmVUeXBlfSxcbiAgICAgICAgICAgIHNoYWRlclNvdXJjZTogYFxuICAgICAke2dsc2xGdW5jLmJvZHl9XG4gICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICB2ZWM0IHYgPSAke2dsc2wudGV4dHVyZTJEfShBLCBUZXhDb29yZHMpO1xuICAgICAgIHYgPSAke2dsc2xGdW5jLm5hbWV9Xyh2KTtcbiAgICAgICAke2dsc2wub3V0cHV0fSA9IHY7XG4gICAgIH1cbiAgICAgYCxcbiAgICAgICAgICAgIGhhc01haW46IHRydWVcbiAgICAgICAgICB9O1xuICAgICAgICB9O1xuXG5jb25zdCBjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvTG9hZGVyID1cbiAgICAoaGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dDogVGVuc29yLCBnbHNsRnVuYzogR2xzbFZhbHVlRnVuY3Rpb24sIGNhY2hlS2V5Pzogc3RyaW5nKTpcbiAgICAgICAgUHJvZ3JhbUluZm9Mb2FkZXIgPT4ge1xuICAgICAgICAgIGNvbnN0IHRleHR1cmVUeXBlID0gaGFuZGxlci5zZXNzaW9uLnBhY2sgPyBUZXh0dXJlVHlwZS5wYWNrZWQgOiBUZXh0dXJlVHlwZS51bnBhY2tlZDtcbiAgICAgICAgICBjb25zdCBtZXRhZGF0YSA9IHtuYW1lOiBnbHNsRnVuYy5uYW1lLCBpbnB1dFR5cGVzOiBbdGV4dHVyZVR5cGVdLCBpbnB1dE5hbWVzOiBbJ0EnXSwgY2FjaGVIaW50OiBjYWNoZUtleX07XG4gICAgICAgICAgcmV0dXJuIHsuLi5tZXRhZGF0YSwgZ2V0OiAoKSA9PiBjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvKGhhbmRsZXIsIG1ldGFkYXRhLCBpbnB1dCwgZ2xzbEZ1bmMpfTtcbiAgICAgICAgfTtcblxuZXhwb3J0IGNvbnN0IGFicyA9IChoYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOlxuICAgIFRlbnNvcltdID0+IFtoYW5kbGVyLnJ1bihjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvTG9hZGVyKGhhbmRsZXIsIGlucHV0c1swXSwgZ2xzbEFicygpKSwgaW5wdXRzKV07XG5cbmV4cG9ydCBjb25zdCBhY29zID0gKGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6XG4gICAgVGVuc29yW10gPT4gW2hhbmRsZXIucnVuKGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm9Mb2FkZXIoaGFuZGxlciwgaW5wdXRzWzBdLCBnbHNsQWNvcygpKSwgaW5wdXRzKV07XG5cbmV4cG9ydCBjb25zdCBhc2luID0gKGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6XG4gICAgVGVuc29yW10gPT4gW2hhbmRsZXIucnVuKGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm9Mb2FkZXIoaGFuZGxlciwgaW5wdXRzWzBdLCBnbHNsQXNpbigpKSwgaW5wdXRzKV07XG5cbmV4cG9ydCBjb25zdCBhdGFuID0gKGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6XG4gICAgVGVuc29yW10gPT4gW2hhbmRsZXIucnVuKGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm9Mb2FkZXIoaGFuZGxlciwgaW5wdXRzWzBdLCBnbHNsQXRhbigpKSwgaW5wdXRzKV07XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2xpcEF0dHJpYnV0ZXMgZXh0ZW5kcyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkge1xuICByZWFkb25seSBtaW46IG51bWJlcjtcbiAgcmVhZG9ubHkgbWF4OiBudW1iZXI7XG59XG5cbmV4cG9ydCBjb25zdCBjbGlwID1cbiAgICAoaGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdLCBhdHRyaWJ1dGVzOiBDbGlwQXR0cmlidXRlcyk6IFRlbnNvcltdID0+IFtoYW5kbGVyLnJ1bihcbiAgICAgICAgY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mb0xvYWRlcihcbiAgICAgICAgICAgIGhhbmRsZXIsIGlucHV0c1swXSwgZ2xzbENsaXAoYXR0cmlidXRlcy5taW4sIGF0dHJpYnV0ZXMubWF4KSwgYXR0cmlidXRlcy5jYWNoZUtleSksXG4gICAgICAgIGlucHV0cyldO1xuXG5leHBvcnQgY29uc3QgcGFyc2VDbGlwQXR0cmlidXRlcyA9IChub2RlOiBHcmFwaC5Ob2RlKTogQ2xpcEF0dHJpYnV0ZXMgPT4gY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KFxuICAgIHttaW46IG5vZGUuYXR0cmlidXRlcy5nZXRGbG9hdCgnbWluJywgTUlOX0NMSVApLCBtYXg6IG5vZGUuYXR0cmlidXRlcy5nZXRGbG9hdCgnbWF4JywgTUFYX0NMSVApfSk7XG5cbmV4cG9ydCBjb25zdCBjbGlwVjExID0gKGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IFRlbnNvcltdID0+IHtcbiAgY29uc3QgYXR0cmlidXRlcyA9IGdlbmVyYXRlQ2xpcEF0dHJpYnV0ZXNGcm9tSW5wdXRzKGhhbmRsZXIsIGlucHV0cyk7XG4gIHJldHVybiBjbGlwKGhhbmRsZXIsIFtpbnB1dHNbMF1dLCBhdHRyaWJ1dGVzKTtcbn07XG5cbmNvbnN0IGdlbmVyYXRlQ2xpcEF0dHJpYnV0ZXNGcm9tSW5wdXRzID0gKGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IENsaXBBdHRyaWJ1dGVzID0+IHtcbiAgaWYgKGlucHV0cy5sZW5ndGggPj0gMyAmJlxuICAgICAgKCFoYW5kbGVyLnNlc3Npb24uaXNJbml0aWFsaXplcihpbnB1dHNbMV0uZGF0YUlkKSB8fCAhaGFuZGxlci5zZXNzaW9uLmlzSW5pdGlhbGl6ZXIoaW5wdXRzWzJdLmRhdGFJZCkpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdkeW5hbWljIGNsaXAgYXR0cmlidXRlcyBhcmUgbm90IGFsbG93ZWQnKTtcbiAgfVxuXG4gIGNvbnN0IG1pbiA9IChpbnB1dHMubGVuZ3RoID49IDMpID8gaW5wdXRzWzFdLm51bWJlckRhdGFbMF0gOiBNSU5fQ0xJUDtcbiAgY29uc3QgbWF4ID0gKGlucHV0cy5sZW5ndGggPj0gMykgPyBpbnB1dHNbMl0ubnVtYmVyRGF0YVswXSA6IE1BWF9DTElQO1xuICByZXR1cm4gY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KHttaW4sIG1heH0pO1xufTtcblxuZXhwb3J0IGNvbnN0IGNlaWwgPSAoaGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTpcbiAgICBUZW5zb3JbXSA9PiBbaGFuZGxlci5ydW4oY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mb0xvYWRlcihoYW5kbGVyLCBpbnB1dHNbMF0sIGdsc2xDZWlsKCkpLCBpbnB1dHMpXTtcblxuZXhwb3J0IGNvbnN0IGNvcyA9IChoYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOlxuICAgIFRlbnNvcltdID0+IFtoYW5kbGVyLnJ1bihjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvTG9hZGVyKGhhbmRsZXIsIGlucHV0c1swXSwgZ2xzbENvcygpKSwgaW5wdXRzKV07XG5cbmV4cG9ydCBpbnRlcmZhY2UgRWx1QXR0cmlidXRlcyBleHRlbmRzIEF0dHJpYnV0ZVdpdGhDYWNoZUtleSB7XG4gIHJlYWRvbmx5IGFscGhhOiBudW1iZXI7XG59XG5cbmV4cG9ydCBjb25zdCBlbHUgPVxuICAgIChoYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10sIGF0dHJpYnV0ZXM6IEVsdUF0dHJpYnV0ZXMpOiBUZW5zb3JbXSA9PiBbaGFuZGxlci5ydW4oXG4gICAgICAgIGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm9Mb2FkZXIoaGFuZGxlciwgaW5wdXRzWzBdLCBnbHNsRWx1KGF0dHJpYnV0ZXMuYWxwaGEpLCBhdHRyaWJ1dGVzLmNhY2hlS2V5KSxcbiAgICAgICAgaW5wdXRzKV07XG5cbmV4cG9ydCBjb25zdCBwYXJzZUVsdUF0dHJpYnV0ZXMgPSAobm9kZTogR3JhcGguTm9kZSk6IEVsdUF0dHJpYnV0ZXMgPT5cbiAgICBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkoe2FscGhhOiBub2RlLmF0dHJpYnV0ZXMuZ2V0RmxvYXQoJ2FscGhhJywgMS4wKX0pO1xuXG5leHBvcnQgY29uc3QgZXhwID0gKGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6XG4gICAgVGVuc29yW10gPT4gW2hhbmRsZXIucnVuKGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm9Mb2FkZXIoaGFuZGxlciwgaW5wdXRzWzBdLCBnbHNsRXhwKCkpLCBpbnB1dHMpXTtcblxuZXhwb3J0IGNvbnN0IGZsb29yID0gKGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6XG4gICAgVGVuc29yW10gPT4gW2hhbmRsZXIucnVuKGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm9Mb2FkZXIoaGFuZGxlciwgaW5wdXRzWzBdLCBnbHNsRmxvb3IoKSksIGlucHV0cyldO1xuXG5leHBvcnQgY29uc3QgaWRlbnRpdHkgPSAoaGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTpcbiAgICBUZW5zb3JbXSA9PiBbaGFuZGxlci5ydW4oY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mb0xvYWRlcihoYW5kbGVyLCBpbnB1dHNbMF0sIGdsc2xJZGVudGl0eSgpKSwgaW5wdXRzKV07XG5cbmV4cG9ydCBpbnRlcmZhY2UgTGVha3lSZWx1QXR0cmlidXRlcyBleHRlbmRzIEF0dHJpYnV0ZVdpdGhDYWNoZUtleSB7XG4gIHJlYWRvbmx5IGFscGhhOiBudW1iZXI7XG59XG5cbmV4cG9ydCBjb25zdCBsZWFreVJlbHUgPVxuICAgIChoYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10sIGF0dHJpYnV0ZXM6IExlYWt5UmVsdUF0dHJpYnV0ZXMpOiBUZW5zb3JbXSA9PiBbaGFuZGxlci5ydW4oXG4gICAgICAgIGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm9Mb2FkZXIoaGFuZGxlciwgaW5wdXRzWzBdLCBnbHNsTGVha3lSZWx1KGF0dHJpYnV0ZXMuYWxwaGEpLCBhdHRyaWJ1dGVzLmNhY2hlS2V5KSxcbiAgICAgICAgaW5wdXRzKV07XG5cbmV4cG9ydCBjb25zdCBwYXJzZUxlYWt5UmVsdUF0dHJpYnV0ZXMgPSAobm9kZTogR3JhcGguTm9kZSk6IExlYWt5UmVsdUF0dHJpYnV0ZXMgPT5cbiAgICBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkoe2FscGhhOiBub2RlLmF0dHJpYnV0ZXMuZ2V0RmxvYXQoJ2FscGhhJywgMC4wMSl9KTtcblxuZXhwb3J0IGNvbnN0IGxvZyA9IChoYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOlxuICAgIFRlbnNvcltdID0+IFtoYW5kbGVyLnJ1bihjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvTG9hZGVyKGhhbmRsZXIsIGlucHV0c1swXSwgZ2xzbExvZygpKSwgaW5wdXRzKV07XG5cbmV4cG9ydCBjb25zdCBuZWcgPSAoaGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTpcbiAgICBUZW5zb3JbXSA9PiBbaGFuZGxlci5ydW4oY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mb0xvYWRlcihoYW5kbGVyLCBpbnB1dHNbMF0sIGdsc2xOZWcoKSksIGlucHV0cyldO1xuXG5leHBvcnQgY29uc3Qgbm90ID0gKGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6XG4gICAgVGVuc29yW10gPT4gW2hhbmRsZXIucnVuKGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm9Mb2FkZXIoaGFuZGxlciwgaW5wdXRzWzBdLCBnbHNsTm90KCkpLCBpbnB1dHMpXTtcblxuZXhwb3J0IGNvbnN0IHJlbHUgPSAoaGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTpcbiAgICBUZW5zb3JbXSA9PiBbaGFuZGxlci5ydW4oY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mb0xvYWRlcihoYW5kbGVyLCBpbnB1dHNbMF0sIGdsc2xSZWx1KCkpLCBpbnB1dHMpXTtcblxuZXhwb3J0IGNvbnN0IHNpZ21vaWQgPSAoaGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTpcbiAgICBUZW5zb3JbXSA9PiBbaGFuZGxlci5ydW4oY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mb0xvYWRlcihoYW5kbGVyLCBpbnB1dHNbMF0sIGdsc2xTaWdtb2lkKCkpLCBpbnB1dHMpXTtcblxuZXhwb3J0IGNvbnN0IHNpbiA9IChoYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOlxuICAgIFRlbnNvcltdID0+IFtoYW5kbGVyLnJ1bihjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvTG9hZGVyKGhhbmRsZXIsIGlucHV0c1swXSwgZ2xzbFNpbigpKSwgaW5wdXRzKV07XG5cbmV4cG9ydCBjb25zdCBzcXJ0ID0gKGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6XG4gICAgVGVuc29yW10gPT4gW2hhbmRsZXIucnVuKGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm9Mb2FkZXIoaGFuZGxlciwgaW5wdXRzWzBdLCBnbHNsU3FydCgpKSwgaW5wdXRzKV07XG5cbmV4cG9ydCBjb25zdCB0YW4gPSAoaGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTpcbiAgICBUZW5zb3JbXSA9PiBbaGFuZGxlci5ydW4oY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mb0xvYWRlcihoYW5kbGVyLCBpbnB1dHNbMF0sIGdsc2xUYW4oKSksIGlucHV0cyldO1xuXG5leHBvcnQgY29uc3QgdGFuaCA9IChoYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOlxuICAgIFRlbnNvcltdID0+IFtoYW5kbGVyLnJ1bihjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvTG9hZGVyKGhhbmRsZXIsIGlucHV0c1swXSwgZ2xzbFRhbmgoKSksIGlucHV0cyldO1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0F0dHJpYnV0ZX0gZnJvbSAnLi4vLi4vLi4vYXR0cmlidXRlJztcbmltcG9ydCB7TUFYX0NMSVAsIE1JTl9DTElQfSBmcm9tICcuLi8uLi8uLi91dGlsJztcbmltcG9ydCB7R2xzbFZhbHVlRnVuY3Rpb259IGZyb20gJy4uL2dsc2wtZGVmaW5pdGlvbnMnO1xuXG5pbXBvcnQge2dsc2xDbGlwLCBnbHNsUmVsdSwgZ2xzbFNpZ21vaWR9IGZyb20gJy4vdW5hcnktb3AnO1xuXG5leHBvcnQgaW50ZXJmYWNlIEludGVybmFsQWN0aXZhdGlvbkF0dHJpYnV0ZXMge1xuICByZWFkb25seSBhY3RpdmF0aW9uOiBzdHJpbmc7XG4gIHJlYWRvbmx5IGNsaXBNaW4/OiBudW1iZXI7XG4gIHJlYWRvbmx5IGNsaXBNYXg/OiBudW1iZXI7XG4gIHJlYWRvbmx5IGFjdGl2YXRpb25DYWNoZUtleTogc3RyaW5nO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0QWN0aXZhdGlvblNuaXBwZXQoYXR0cmlidXRlczogSW50ZXJuYWxBY3RpdmF0aW9uQXR0cmlidXRlcykge1xuICBsZXQgZnVuYzogR2xzbFZhbHVlRnVuY3Rpb247XG4gIHN3aXRjaCAoYXR0cmlidXRlcy5hY3RpdmF0aW9uKSB7XG4gICAgY2FzZSAnUmVsdSc6XG4gICAgICBmdW5jID0gZ2xzbFJlbHUoKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ1NpZ21vaWQnOlxuICAgICAgZnVuYyA9IGdsc2xTaWdtb2lkKCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdDbGlwJzpcbiAgICAgIGZ1bmMgPSBnbHNsQ2xpcChhdHRyaWJ1dGVzLmNsaXBNaW4hLCBhdHRyaWJ1dGVzLmNsaXBNYXghKTtcbiAgICAgIGJyZWFrO1xuICAgIC8vIFRPRE86IGFkZGluZyBvdGhlciBhY3RpdmF0aW9ucyB0aGF0IGNhbiBiZSBmdXNlZC5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHthY3RpdmF0aW9uRnVuY3Rpb246ICcnLCBhcHBseUFjdGl2YXRpb246ICcnfTtcbiAgfVxuXG4gIGNvbnN0IGFjdGl2YXRpb25OYW1lID0gZnVuYy5uYW1lO1xuICBjb25zdCBhY3RpdmF0aW9uRnVuY3Rpb24gPSBmdW5jLmJvZHk7XG4gIGNvbnN0IGFwcGx5QWN0aXZhdGlvbiA9IGB2YWx1ZSA9ICR7YWN0aXZhdGlvbk5hbWV9Xyh2YWx1ZSk7YDtcbiAgcmV0dXJuIHthY3RpdmF0aW9uRnVuY3Rpb24sIGFwcGx5QWN0aXZhdGlvbn07XG59XG5cbmV4cG9ydCBjb25zdCBwYXJzZUludGVybmFsQWN0aXZhdGlvbkF0dHJpYnV0ZXMgPSAoYXR0cmlidXRlczogQXR0cmlidXRlKTogSW50ZXJuYWxBY3RpdmF0aW9uQXR0cmlidXRlcyA9PiB7XG4gIGNvbnN0IGFjdGl2YXRpb24gPSBhdHRyaWJ1dGVzLmdldFN0cmluZygnYWN0aXZhdGlvbicsICcnKTtcblxuICBpZiAoYWN0aXZhdGlvbiA9PT0gJ0NsaXAnKSB7XG4gICAgY29uc3QgW2NsaXBNaW4sIGNsaXBNYXhdID0gYXR0cmlidXRlcy5nZXRGbG9hdHMoJ2FjdGl2YXRpb25fcGFyYW1zJywgW01JTl9DTElQLCBNQVhfQ0xJUF0pO1xuICAgIHJldHVybiB7YWN0aXZhdGlvbiwgY2xpcE1heCwgY2xpcE1pbiwgYWN0aXZhdGlvbkNhY2hlS2V5OiBgJHthY3RpdmF0aW9ufToke2NsaXBNaW59LCR7Y2xpcE1heH1gfTtcbiAgfVxuICByZXR1cm4ge2FjdGl2YXRpb24sIGFjdGl2YXRpb25DYWNoZUtleTogYWN0aXZhdGlvbn07XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0xvZ2dlcn0gZnJvbSAnLi4vLi4vLi4vaW5zdHJ1bWVudCc7XG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi4vLi4vLi4vdGVuc29yJztcbmltcG9ydCB7Z2V0R2xzbH0gZnJvbSAnLi4vZ2xzbC1zb3VyY2UnO1xuaW1wb3J0IHtXZWJHTEluZmVyZW5jZUhhbmRsZXJ9IGZyb20gJy4uL2luZmVyZW5jZS1oYW5kbGVyJztcbmltcG9ydCB7UHJvZ3JhbUluZm8sIFByb2dyYW1JbmZvTG9hZGVyLCBQcm9ncmFtTWV0YWRhdGEsIFRleHR1cmVUeXBlfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7Y2FsY3VsYXRlT3V0cHV0U2hhcGUsIENvbnZBdHRyaWJ1dGVzfSBmcm9tICcuL2NvbnYnO1xuaW1wb3J0IHtnZXRBY3RpdmF0aW9uU25pcHBldH0gZnJvbSAnLi9mdXNlLXV0aWxzJztcblxuY29uc3QgY3JlYXRlVW5wYWNrZWRHcm91cGVkQ29udlByb2dyYW1NZXRhZGF0YSA9IChoYXNCaWFzOiBib29sZWFuLCBjYWNoZUhpbnQ6IHN0cmluZyk6IFByb2dyYW1NZXRhZGF0YSA9PiAoe1xuICBuYW1lOiAnR3JvdXBlZENvbnYnLFxuICBpbnB1dE5hbWVzOiBoYXNCaWFzID8gWydYJywgJ1cnLCAnQmlhcyddIDogWydYJywgJ1cnXSxcbiAgaW5wdXRUeXBlczogaGFzQmlhcyA/IFtUZXh0dXJlVHlwZS51bnBhY2tlZCwgVGV4dHVyZVR5cGUudW5wYWNrZWQsIFRleHR1cmVUeXBlLnVucGFja2VkXSA6XG4gICAgICAgICAgICAgICAgICAgICAgICBbVGV4dHVyZVR5cGUudW5wYWNrZWQsIFRleHR1cmVUeXBlLnVucGFja2VkXSxcbiAgY2FjaGVIaW50XG59KTtcblxuY29uc3QgY3JlYXRlVW5wYWNrZWRHcm91cGVkQ29udlByb2dyYW1JbmZvID1cbiAgICAoaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IHJlYWRvbmx5IFRlbnNvcltdLCBtZXRhZGF0YTogUHJvZ3JhbU1ldGFkYXRhLFxuICAgICBhdHRyaWJ1dGVzOiBDb252QXR0cmlidXRlcyk6IFByb2dyYW1JbmZvID0+IHtcbiAgICAgIGNvbnN0IGhhc0JpYXMgPSBpbnB1dHMubGVuZ3RoID4gMjtcbiAgICAgIGNvbnN0IHByb2Nlc3NCaWFzID0gaGFzQmlhcyA/ICd2YWx1ZSArPSBnZXRCaWFzKG91dHB1dF9jaGFubmVsKTsnIDogJyc7XG4gICAgICBjb25zdCB4U2hhcGUgPSBpbnB1dHNbMF0uZGltcy5zbGljZSgpO1xuICAgICAgY29uc3Qgd1NoYXBlID0gaW5wdXRzWzFdLmRpbXMuc2xpY2UoKTtcbiAgICAgIGNvbnN0IG91dHB1dENoYW5uZWxzUGVyR3JvdXAgPSB3U2hhcGVbMF0gLyBhdHRyaWJ1dGVzLmdyb3VwO1xuICAgICAgTG9nZ2VyLnZlcmJvc2UoXG4gICAgICAgICAgJ0dyb3VwZWRDb252JyxcbiAgICAgICAgICBgYXV0cFBhZDoke2F0dHJpYnV0ZXMuYXV0b1BhZH0sIGRpbGF0aW9uczoke2F0dHJpYnV0ZXMuZGlsYXRpb25zfSwgZ3JvdXA6JHthdHRyaWJ1dGVzLmdyb3VwfSwga2VybmVsU2hhcGU6JHtcbiAgICAgICAgICAgICAgYXR0cmlidXRlcy5rZXJuZWxTaGFwZX0sIHBhZHM6JHthdHRyaWJ1dGVzLnBhZHN9LCBzdHJpZGVzOiR7YXR0cmlidXRlcy5zdHJpZGVzfWApO1xuICAgICAgY29uc3Qgb3V0cHV0U2hhcGUgPVxuICAgICAgICAgIGNhbGN1bGF0ZU91dHB1dFNoYXBlKHhTaGFwZSwgd1NoYXBlLCBhdHRyaWJ1dGVzLmRpbGF0aW9ucywgYXR0cmlidXRlcy5wYWRzLCBhdHRyaWJ1dGVzLnN0cmlkZXMpO1xuICAgICAgY29uc3QgZ2xzbCA9IGdldEdsc2woaW5mZXJlbmNlSGFuZGxlci5zZXNzaW9uLmJhY2tlbmQuZ2xDb250ZXh0LnZlcnNpb24pO1xuICAgICAgY29uc3Qge2FjdGl2YXRpb25GdW5jdGlvbiwgYXBwbHlBY3RpdmF0aW9ufSA9IGdldEFjdGl2YXRpb25TbmlwcGV0KGF0dHJpYnV0ZXMpO1xuXG4gICAgICBjb25zdCBzaGFkZXJTb3VyY2UgPSBgXG4gIGNvbnN0IGl2ZWMyIHN0cmlkZXMgPSBpdmVjMigke2F0dHJpYnV0ZXMuc3RyaWRlc1swXX0sICR7YXR0cmlidXRlcy5zdHJpZGVzWzFdfSk7XG4gIGNvbnN0IGl2ZWMyIHBhZHMgPSBpdmVjMigke2F0dHJpYnV0ZXMucGFkc1swXX0sICR7YXR0cmlidXRlcy5wYWRzWzFdfSk7XG4gICR7YWN0aXZhdGlvbkZ1bmN0aW9ufVxuICB2b2lkIG1haW4oKSB7XG4gICAgaXZlYzQgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XG4gICAgaW50IGJhdGNoID0gY29vcmRzLng7XG4gICAgaW50IG91dHB1dF9jaGFubmVsID0gY29vcmRzLnk7XG4gICAgaXZlYzIgeFJDQ29ybmVyID0gY29vcmRzLnp3ICogc3RyaWRlcyAtIHBhZHM7XG4gICAgaW50IGdyb3VwX2lkID0gb3V0cHV0X2NoYW5uZWwgLyAke291dHB1dENoYW5uZWxzUGVyR3JvdXB9O1xuXG4gICAgZmxvYXQgdmFsdWUgPSAwLjA7XG4gICAgZm9yIChpbnQgd0luQ2hhbm5lbCA9IDA7IHdJbkNoYW5uZWwgPCAke3dTaGFwZVsxXX07IHdJbkNoYW5uZWwrKykge1xuICAgICAgaW50IGlucHV0X2NoYW5uZWwgPSBncm91cF9pZCAqICR7d1NoYXBlWzFdfSArIHdJbkNoYW5uZWw7XG4gICAgICBmb3IgKGludCB3SGVpZ2h0ID0gMDsgd0hlaWdodCA8ICR7d1NoYXBlWzJdfTsgd0hlaWdodCsrKSB7XG4gICAgICAgIGludCB4SGVpZ2h0ID0geFJDQ29ybmVyLnggKyB3SGVpZ2h0ICogJHthdHRyaWJ1dGVzLmRpbGF0aW9uc1swXX07XG5cbiAgICAgICAgaWYgKHhIZWlnaHQgPCAwIHx8IHhIZWlnaHQgPj0gJHt4U2hhcGVbMl19KSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGludCB3V2lkdGggPSAwOyB3V2lkdGggPCAke3dTaGFwZVszXX07IHdXaWR0aCsrKSB7XG4gICAgICAgICAgaW50IHhXaWR0aCA9IHhSQ0Nvcm5lci55ICsgd1dpZHRoICogJHthdHRyaWJ1dGVzLmRpbGF0aW9uc1sxXX07XG4gICAgICAgICAgaWYgKHhXaWR0aCA8IDAgfHwgeFdpZHRoID49ICR7eFNoYXBlWzNdfSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZmxvYXQgeFZhbCA9IGdldFgoYmF0Y2gsIGlucHV0X2NoYW5uZWwsIHhXaWR0aCwgeEhlaWdodCk7XG4gICAgICAgICAgZmxvYXQgd1ZhbCA9IGdldFcob3V0cHV0X2NoYW5uZWwsIHdJbkNoYW5uZWwsIHdXaWR0aCwgd0hlaWdodCk7XG4gICAgICAgICAgdmFsdWUgKz0geFZhbCp3VmFsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgICR7cHJvY2Vzc0JpYXN9XG4gICAgJHthcHBseUFjdGl2YXRpb259XG4gICAgJHtnbHNsLm91dHB1dH0gPSB2ZWM0KHZhbHVlLCAuMCwgLjAsIC4wKTtcbiAgfVxuYDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLm1ldGFkYXRhLFxuICAgICAgICBvdXRwdXQ6IHtkaW1zOiBvdXRwdXRTaGFwZSwgdHlwZTogaW5wdXRzWzBdLnR5cGUsIHRleHR1cmVUeXBlOiBUZXh0dXJlVHlwZS51bnBhY2tlZH0sXG4gICAgICAgIHNoYWRlclNvdXJjZSxcbiAgICAgICAgaGFzTWFpbjogdHJ1ZSxcbiAgICAgIH07XG4gICAgfTtcblxuZXhwb3J0IGNvbnN0IGNyZWF0ZVVucGFja2VkR3JvdXBlZENvbnZQcm9ncmFtSW5mb0xvYWRlciA9XG4gICAgKGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiByZWFkb25seSBUZW5zb3JbXSwgYXR0cmlidXRlczogQ29udkF0dHJpYnV0ZXMpOlxuICAgICAgICBQcm9ncmFtSW5mb0xvYWRlciA9PiB7XG4gICAgICAgICAgY29uc3QgbWV0YWRhdGEgPSBjcmVhdGVVbnBhY2tlZEdyb3VwZWRDb252UHJvZ3JhbU1ldGFkYXRhKGlucHV0cy5sZW5ndGggPiAyLCBhdHRyaWJ1dGVzLmNhY2hlS2V5KTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4ubWV0YWRhdGEsXG4gICAgICAgICAgICBnZXQ6ICgpID0+IGNyZWF0ZVVucGFja2VkR3JvdXBlZENvbnZQcm9ncmFtSW5mbyhpbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHMsIG1ldGFkYXRhLCBhdHRyaWJ1dGVzKVxuICAgICAgICAgIH07XG4gICAgICAgIH07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7VGVuc29yfSBmcm9tICcuLi8uLi8uLi90ZW5zb3InO1xuaW1wb3J0IHtnZXRHbHNsfSBmcm9tICcuLi9nbHNsLXNvdXJjZSc7XG5pbXBvcnQge1dlYkdMSW5mZXJlbmNlSGFuZGxlcn0gZnJvbSAnLi4vaW5mZXJlbmNlLWhhbmRsZXInO1xuaW1wb3J0IHtQcm9ncmFtSW5mbywgUHJvZ3JhbUluZm9Mb2FkZXIsIFByb2dyYW1NZXRhZGF0YSwgVGV4dHVyZVR5cGV9IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHtDb252QXR0cmlidXRlc30gZnJvbSAnLi9jb252JztcbmltcG9ydCB7dW5wYWNrRnJvbUNoYW5uZWx9IGZyb20gJy4vcGFja2luZy11dGlscyc7XG5cbmNvbnN0IGNyZWF0ZVBhY2tlZEltMkNvbFByb2dyYW1NZXRhZGF0YSA9IChjYWNoZUhpbnQ6IHN0cmluZykgPT4gKHtcbiAgbmFtZTogJ0ltMkNvbCAocGFja2VkKScsXG4gIGlucHV0TmFtZXM6IFsnQSddLFxuICBpbnB1dFR5cGVzOiBbVGV4dHVyZVR5cGUucGFja2VkXSxcbiAgY2FjaGVIaW50LFxufSk7XG5cbmNvbnN0IGNyZWF0ZVBhY2tlZEltMkNvbFByb2dyYW1JbmZvID1cbiAgICAoaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBtZXRhZGF0YTogUHJvZ3JhbU1ldGFkYXRhLCB4OiBUZW5zb3IsIHc6IFRlbnNvcixcbiAgICAgb3V0cHV0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLCBhdHRyaWJ1dGVzOiBDb252QXR0cmlidXRlcyk6IFByb2dyYW1JbmZvID0+IHtcbiAgICAgIGNvbnN0IHhzaGFwZSA9IHguZGltcztcbiAgICAgIGNvbnN0IHdzaGFwZSA9IHcuZGltcztcbiAgICAgIGNvbnN0IHJvd0RpbSA9IDI7XG4gICAgICBjb25zdCBjb2xEaW0gPSAzO1xuICAgICAgY29uc3QgcmFuayA9IG91dHB1dFNoYXBlLmxlbmd0aDtcbiAgICAgIGNvbnN0IGltMmNvbFNoYXBlID0gW3dzaGFwZVsxXSAqIHdzaGFwZVsyXSAqIHdzaGFwZVszXSwgb3V0cHV0U2hhcGVbMl0gKiBvdXRwdXRTaGFwZVszXV07XG4gICAgICBjb25zdCBrZXJuZWxTaXplID0gd3NoYXBlWzJdICogd3NoYXBlWzNdO1xuICAgICAgY29uc3QgdW5wYWNrQ2hhbm5lbCA9IHVucGFja0Zyb21DaGFubmVsKCk7XG4gICAgICBjb25zdCBnbHNsID0gZ2V0R2xzbChpbmZlcmVuY2VIYW5kbGVyLnNlc3Npb24uYmFja2VuZC5nbENvbnRleHQudmVyc2lvbik7XG4gICAgICBsZXQgdW5yb2xsZWQgPSAnJztcblxuICAgICAgZm9yIChsZXQgcm93ID0gMDsgcm93IDw9IDE7IHJvdysrKSB7XG4gICAgICAgIGZvciAobGV0IGNvbCA9IDA7IGNvbCA8PSAxOyBjb2wrKykge1xuICAgICAgICAgIHVucm9sbGVkICs9IGBcbiAgICAgICAgICAgIGJsb2NrSW5kZXggPSByYy54ICsgJHtjb2x9O1xuICAgICAgICAgICAgcG9zID0gcmMueSArICR7cm93fTtcblxuICAgICAgICAgICAgaWYoYmxvY2tJbmRleCA8ICR7aW0yY29sU2hhcGVbMV19ICYmIHBvcyA8ICR7aW0yY29sU2hhcGVbMF19KSB7XG4gICAgICAgICAgICAgIG9mZnNldFkgPSBpbnQoYmxvY2tJbmRleCAvICgke291dHB1dFNoYXBlW3JhbmsgLSAxXX0pKSAqICR7YXR0cmlidXRlcy5zdHJpZGVzWzBdfSAtXG4gICAgICAgICAgICAgICAgJHthdHRyaWJ1dGVzLnBhZHNbMF19O1xuICAgICAgICAgICAgICBkMCA9IG9mZnNldFkgKyAke2F0dHJpYnV0ZXMuZGlsYXRpb25zWzBdfSAqIChpbW9kKHBvcywgJHtrZXJuZWxTaXplfSkgLyAke3dzaGFwZVsyXX0pO1xuXG4gICAgICAgICAgICAgIGlmKGQwIDwgJHt4c2hhcGVbcm93RGltXX0gJiYgZDAgPj0gMCkge1xuICAgICAgICAgICAgICAgIG9mZnNldFggPSBpbW9kKGJsb2NrSW5kZXgsICR7b3V0cHV0U2hhcGVbcmFuayAtIDFdfSkgKiAke2F0dHJpYnV0ZXMuc3RyaWRlc1sxXX0gLVxuICAgICAgICAgICAgICAgICAgJHthdHRyaWJ1dGVzLnBhZHNbMV19O1xuICAgICAgICAgICAgICAgIGQxID0gb2Zmc2V0WCArICR7YXR0cmlidXRlcy5kaWxhdGlvbnNbMV19ICogaW1vZChpbW9kKHBvcywgJHtrZXJuZWxTaXplfSksICR7d3NoYXBlWzJdfSk7XG5cbiAgICAgICAgICAgICAgICBpZihkMSA8ICR7eHNoYXBlW2NvbERpbV19ICYmIGQxID49IDApIHtcblxuICAgICAgICAgICAgICAgICAgY2ggPSBpbnQoZmxvYXQocG9zKS8gJHtrZXJuZWxTaXplfS4pO1xuICAgICAgICAgICAgICAgICAgICBpbm5lckRpbXMgPSB2ZWMyKGQwLCBkMSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFske3JvdyAqIDIgKyBjb2x9XSA9IGdldENoYW5uZWwoXG4gICAgICAgICAgICAgICAgICAgICAgZ2V0QSgwLCBjaCwgaW50KGlubmVyRGltcy54KSxcbiAgICAgICAgICAgICAgICAgICAgICBpbnQoaW5uZXJEaW1zLnkpKSwgaW5uZXJEaW1zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGA7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3Qgc2hhZGVyU291cmNlID0gYFxuICAgICAgJHt1bnBhY2tDaGFubmVsfVxuXG4gICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgIGl2ZWMyIHJjID0gZ2V0T3V0cHV0Q29vcmRzKCk7XG4gICAgICAgICAgdmVjNCByZXN1bHQgPSB2ZWM0KDAuMCk7XG4gICAgICAgICAgaW50IGJsb2NrSW5kZXgsIHBvcywgb2Zmc2V0WSwgZDAsIG9mZnNldFgsIGQxLCBjaDtcbiAgICAgICAgICB2ZWMyIGlubmVyRGltcztcbiAgICAgICAgICAke3Vucm9sbGVkfVxuICAgICAgICAgICR7Z2xzbC5vdXRwdXR9ID0gcmVzdWx0O1xuICAgICAgfVxuICAgICAgICAgICAgYDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLm1ldGFkYXRhLFxuICAgICAgICBvdXRwdXQ6IHtkaW1zOiBpbTJjb2xTaGFwZSwgdHlwZTogeC50eXBlLCB0ZXh0dXJlVHlwZTogVGV4dHVyZVR5cGUucGFja2VkfSxcbiAgICAgICAgc2hhZGVyU291cmNlLFxuICAgICAgICBoYXNNYWluOiB0cnVlXG4gICAgICB9O1xuICAgIH07XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVQYWNrZWRJbTJDb2xQcm9ncmFtSW5mb0xvYWRlciA9XG4gICAgKGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgeDogVGVuc29yLCB3OiBUZW5zb3IsIG91dHB1dFNoYXBlOiByZWFkb25seSBudW1iZXJbXSxcbiAgICAgYXR0cmlidXRlczogQ29udkF0dHJpYnV0ZXMpOiBQcm9ncmFtSW5mb0xvYWRlciA9PiB7XG4gICAgICBjb25zdCBtZXRhZGF0YSA9IGNyZWF0ZVBhY2tlZEltMkNvbFByb2dyYW1NZXRhZGF0YShhdHRyaWJ1dGVzLmNhY2hlS2V5KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLm1ldGFkYXRhLFxuICAgICAgICBnZXQ6ICgpID0+IGNyZWF0ZVBhY2tlZEltMkNvbFByb2dyYW1JbmZvKGluZmVyZW5jZUhhbmRsZXIsIG1ldGFkYXRhLCB4LCB3LCBvdXRwdXRTaGFwZSwgYXR0cmlidXRlcylcbiAgICAgIH07XG4gICAgfTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtHcmFwaH0gZnJvbSAnLi4vLi4vLi4vZ3JhcGgnO1xuaW1wb3J0IHtPcGVyYXRvckltcGxlbWVudGF0aW9uLCBPcGVyYXRvckluaXRpYWxpemF0aW9ufSBmcm9tICcuLi8uLi8uLi9vcGVyYXRvcnMnO1xuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4uLy4uLy4uL3RlbnNvcic7XG5pbXBvcnQge0Jyb2FkY2FzdFV0aWwsIFNoYXBlVXRpbH0gZnJvbSAnLi4vLi4vLi4vdXRpbCc7XG5pbXBvcnQge1dlYkdMSW5mZXJlbmNlSGFuZGxlcn0gZnJvbSAnLi4vaW5mZXJlbmNlLWhhbmRsZXInO1xuaW1wb3J0IHtQcm9ncmFtSW5mbywgUHJvZ3JhbUluZm9Mb2FkZXIsIFByb2dyYW1NZXRhZGF0YSwgVGV4dHVyZVR5cGV9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7Z2V0Q29vcmRzRGF0YVR5cGUsIGdldEdsQ2hhbm5lbHN9IGZyb20gJy4uL3V0aWxzJztcblxuaW1wb3J0IHtnZXRBY3RpdmF0aW9uU25pcHBldCwgSW50ZXJuYWxBY3RpdmF0aW9uQXR0cmlidXRlcywgcGFyc2VJbnRlcm5hbEFjdGl2YXRpb25BdHRyaWJ1dGVzfSBmcm9tICcuL2Z1c2UtdXRpbHMnO1xuaW1wb3J0IHtjcmVhdGVQYWNrZWRNYXRtdWxQcm9ncmFtSW5mb0xvYWRlcn0gZnJvbSAnLi9tYXRtdWwtcGFjayc7XG5cbmV4cG9ydCBjb25zdCBtYXRNdWw6IE9wZXJhdG9ySW1wbGVtZW50YXRpb248SW50ZXJuYWxBY3RpdmF0aW9uQXR0cmlidXRlcz4gPVxuICAgIChpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10sIGF0dHJpYnV0ZXM6IEludGVybmFsQWN0aXZhdGlvbkF0dHJpYnV0ZXMpOiBUZW5zb3JbXSA9PiB7XG4gICAgICB2YWxpZGF0ZUlucHV0cyhpbnB1dHMpO1xuXG4gICAgICBpZiAoaW5mZXJlbmNlSGFuZGxlci5zZXNzaW9uLnBhY2spIHtcbiAgICAgICAgcmV0dXJuIFtpbmZlcmVuY2VIYW5kbGVyLnJ1bihcbiAgICAgICAgICAgIGNyZWF0ZVBhY2tlZE1hdG11bFByb2dyYW1JbmZvTG9hZGVyKGluZmVyZW5jZUhhbmRsZXIsIGlucHV0cywgYXR0cmlidXRlcyksIGlucHV0cyldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFtpbmZlcmVuY2VIYW5kbGVyLnJ1bihjcmVhdGVNYXRtdWxQcm9ncmFtSW5mb0xvYWRlcihpbnB1dHMsIGF0dHJpYnV0ZXMpLCBpbnB1dHMpXTtcbiAgICAgIH1cbiAgICB9O1xuXG5leHBvcnQgY29uc3QgcGFyc2VNYXRNdWxBdHRyaWJ1dGVzOiBPcGVyYXRvckluaXRpYWxpemF0aW9uPEludGVybmFsQWN0aXZhdGlvbkF0dHJpYnV0ZXM+ID1cbiAgICAobm9kZTogR3JhcGguTm9kZSk6IEludGVybmFsQWN0aXZhdGlvbkF0dHJpYnV0ZXMgPT4gcGFyc2VJbnRlcm5hbEFjdGl2YXRpb25BdHRyaWJ1dGVzKG5vZGUuYXR0cmlidXRlcyk7XG5cbmNvbnN0IGNyZWF0ZU1hdG11bFByb2dyYW1NZXRhZGF0YSA9IChoYXNCaWFzOiBib29sZWFuLCBjYWNoZUhpbnQ6IHN0cmluZykgPT4gKHtcbiAgbmFtZTogJ01hdE11bCcsXG4gIGlucHV0TmFtZXM6IGhhc0JpYXMgPyBbJ0EnLCAnQicsICdCaWFzJ10gOiBbJ0EnLCAnQiddLFxuICBpbnB1dFR5cGVzOiBoYXNCaWFzID8gW1RleHR1cmVUeXBlLnVucGFja2VkLCBUZXh0dXJlVHlwZS51bnBhY2tlZCwgVGV4dHVyZVR5cGUudW5wYWNrZWRdIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIFtUZXh0dXJlVHlwZS51bnBhY2tlZCwgVGV4dHVyZVR5cGUudW5wYWNrZWRdLFxuICBjYWNoZUhpbnRcbn0pO1xuXG5mdW5jdGlvbiBjcmVhdGVNYXRtdWxQcm9ncmFtSW5mbyhcbiAgICBtZXRhZGF0YTogUHJvZ3JhbU1ldGFkYXRhLCBpbnB1dHM6IFRlbnNvcltdLCBhY3RpdmF0aW9uQXR0cmlidXRlczogSW50ZXJuYWxBY3RpdmF0aW9uQXR0cmlidXRlcyk6IFByb2dyYW1JbmZvIHtcbiAgY29uc3QgYVNoYXBlID0gaW5wdXRzWzBdLmRpbXM7XG4gIGNvbnN0IGJTaGFwZSA9IGlucHV0c1sxXS5kaW1zO1xuICBjb25zdCBvdXRwdXRTaGFwZSA9IEJyb2FkY2FzdFV0aWwuY2FsY1NoYXBlKGFTaGFwZSwgYlNoYXBlLCB0cnVlKTtcbiAgaWYgKCFvdXRwdXRTaGFwZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignQ2FuXFwndCB1c2UgbWF0bXVsIG9uIHRoZSBnaXZlbiB0ZW5zb3JzJyk7XG4gIH1cbiAgY29uc3QgY29vcmRzRGF0YVR5cGUgPSBnZXRDb29yZHNEYXRhVHlwZShvdXRwdXRTaGFwZS5sZW5ndGgpO1xuICBjb25zdCBhbGxHbENoYW5uZWxzID0gZ2V0R2xDaGFubmVscygpO1xuICBjb25zdCB7YWN0aXZhdGlvbkZ1bmN0aW9uLCBhcHBseUFjdGl2YXRpb259ID0gZ2V0QWN0aXZhdGlvblNuaXBwZXQoYWN0aXZhdGlvbkF0dHJpYnV0ZXMpO1xuXG4gIGNvbnN0IGhhc0JpYXMgPSBpbnB1dHMubGVuZ3RoID4gMjtcbiAgY29uc3QgcHJvY2Vzc0JpYXMgPSBoYXNCaWFzID8gJ3ZhbHVlICs9IGdldEJpYXNGb3JNYXRtdWwoKTsnIDogJyc7XG4gIGNvbnN0IGdldEJpYXNGb3JNYXRtdWxTbmlwcGV0ID1cbiAgICAgIGhhc0JpYXMgPyBgJHtnZXRCaWFzRm9yTWF0bXVsKGNvb3Jkc0RhdGFUeXBlLCBhbGxHbENoYW5uZWxzLCBpbnB1dHNbMl0uZGltcywgb3V0cHV0U2hhcGUsIGZhbHNlKX1gIDogJyc7XG5cbiAgY29uc3QgcmFuayA9IG91dHB1dFNoYXBlLmxlbmd0aDtcbiAgY29uc3QgYXJhbmsgPSBhU2hhcGUubGVuZ3RoO1xuICBjb25zdCBicmFuayA9IGJTaGFwZS5sZW5ndGg7XG4gIGNvbnN0IHNoYXJlZERpbSA9IGFTaGFwZVthU2hhcGUubGVuZ3RoIC0gMV07XG4gIGNvbnN0IHNoYWRlclNvdXJjZSA9IGBcbiAgICAke2FjdGl2YXRpb25GdW5jdGlvbn1cbiAgICAke2dldEJpYXNGb3JNYXRtdWxTbmlwcGV0fVxuICAgIGZsb2F0IHByb2Nlc3MoaW50IGluZGljZXNbJHtyYW5rfV0pIHtcbiAgICAgICAgaW50IGFbJHthcmFua31dO1xuICAgICAgICBpbnQgYlske2JyYW5rfV07XG4gICAgICAgIGJjYXN0TWF0bXVsSW5kaWNlc19BKGluZGljZXMsIGEpO1xuICAgICAgICBiY2FzdE1hdG11bEluZGljZXNfQihpbmRpY2VzLCBiKTtcblxuICAgICAgICBmbG9hdCB2YWx1ZTtcbiAgICAgICAgZm9yIChpbnQgaz0wOyBrPCR7c2hhcmVkRGltfTsgKytrKSB7XG4gICAgICAgICAgICBhWyR7YXJhbmsgLSAxfV0gPSBrO1xuICAgICAgICAgICAgYlske2JyYW5rIC0gMn1dID0gaztcbiAgICAgICAgICAgIHZhbHVlICs9IF9BKGEpICogX0IoYik7XG4gICAgICAgIH1cbiAgICAgICAgJHtwcm9jZXNzQmlhc31cbiAgICAgICAgJHthcHBseUFjdGl2YXRpb259XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9YDtcbiAgcmV0dXJuIHtcbiAgICAuLi5tZXRhZGF0YSxcbiAgICBvdXRwdXQ6IHtkaW1zOiBvdXRwdXRTaGFwZSwgdHlwZTogaW5wdXRzWzBdLnR5cGUsIHRleHR1cmVUeXBlOiBUZXh0dXJlVHlwZS51bnBhY2tlZH0sXG4gICAgc2hhZGVyU291cmNlLFxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTWF0bXVsUHJvZ3JhbUluZm9Mb2FkZXIoXG4gICAgaW5wdXRzOiBUZW5zb3JbXSwgYWN0aXZhdGlvbkF0dHJpYnV0ZXM6IEludGVybmFsQWN0aXZhdGlvbkF0dHJpYnV0ZXMpOiBQcm9ncmFtSW5mb0xvYWRlciB7XG4gIGNvbnN0IG1ldGFkYXRhID0gY3JlYXRlTWF0bXVsUHJvZ3JhbU1ldGFkYXRhKGlucHV0cy5sZW5ndGggPiAyLCBhY3RpdmF0aW9uQXR0cmlidXRlcy5hY3RpdmF0aW9uQ2FjaGVLZXkpO1xuICByZXR1cm4gey4uLm1ldGFkYXRhLCBnZXQ6ICgpID0+IGNyZWF0ZU1hdG11bFByb2dyYW1JbmZvKG1ldGFkYXRhLCBpbnB1dHMsIGFjdGl2YXRpb25BdHRyaWJ1dGVzKX07XG59XG5cbmNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogVGVuc29yW10pOiB2b2lkID0+IHtcbiAgaWYgKCFpbnB1dHMgfHwgaW5wdXRzLmxlbmd0aCAhPT0gMikge1xuICAgIHRocm93IG5ldyBFcnJvcignTWF0TXVsIHJlcXVpcmVzIDIgaW5wdXRzLicpO1xuICB9XG5cbiAgaWYgKGlucHV0c1swXS5kaW1zW2lucHV0c1swXS5kaW1zLmxlbmd0aCAtIDFdICE9PSBpbnB1dHNbMV0uZGltc1tpbnB1dHNbMV0uZGltcy5sZW5ndGggLSAyXSkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2hhcmVkIGRpbWVuc2lvbiBkb2VzIG5vdCBtYXRjaC4nKTtcbiAgfVxuXG4gIGlmICgoaW5wdXRzWzBdLnR5cGUgIT09ICdmbG9hdDMyJyAmJiBpbnB1dHNbMF0udHlwZSAhPT0gJ2Zsb2F0NjQnKSB8fFxuICAgICAgKGlucHV0c1sxXS50eXBlICE9PSAnZmxvYXQzMicgJiYgaW5wdXRzWzFdLnR5cGUgIT09ICdmbG9hdDY0JykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2lucHV0cyBzaG91bGQgYmUgZmxvYXQgdHlwZScpO1xuICB9XG5cbiAgaWYgKGlucHV0c1swXS50eXBlICE9PSBpbnB1dHNbMV0udHlwZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignaW5wdXRzIHR5cGVzIHNob3VsZCBtYXRjaCcpO1xuICB9XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Qmlhc0Zvck1hdG11bChcbiAgICBjb29yZHNEYXRhVHlwZTogc3RyaW5nLCBhbGxHbENoYW5uZWxzOiByZWFkb25seSBzdHJpbmdbXSwgaW5TaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sIG91dFNoYXBlOiByZWFkb25seSBudW1iZXJbXSxcbiAgICBpc1BhY2tlZDogYm9vbGVhbik6IHN0cmluZyB7XG4gIGxldCB1bnBhY2tlZENvb3Jkc1NuaXBwZXQgPSAnJztcbiAgY29uc3QgaW5SYW5rID0gaW5TaGFwZS5sZW5ndGg7XG4gIGNvbnN0IG91dFJhbmsgPSBvdXRTaGFwZS5sZW5ndGg7XG4gIGNvbnN0IHJhbmtEaWZmID0gb3V0UmFuayAtIGluUmFuaztcbiAgaWYgKG91dFJhbmsgPCAyICYmIGluUmFuayA+IDApIHtcbiAgICB1bnBhY2tlZENvb3Jkc1NuaXBwZXQgPSAnY29vcmRzJztcbiAgfSBlbHNlIHtcbiAgICB1bnBhY2tlZENvb3Jkc1NuaXBwZXQgPSBpblNoYXBlLm1hcCgoX3MsIGkpID0+IGBjb29yZHMuJHthbGxHbENoYW5uZWxzW2kgKyByYW5rRGlmZl19YCkuam9pbignLCAnKTtcbiAgfVxuICBjb25zdCBicm9hZGNhc3REaW1zID0gQnJvYWRjYXN0VXRpbC5nZXRCcm9hZGNhc3REaW1zKGluU2hhcGUsIG91dFNoYXBlKTtcbiAgY29uc3QgY29vcmRzU25pcHBldCA9IGJyb2FkY2FzdERpbXMubWFwKGQgPT4gYGNvb3Jkcy4ke2FsbEdsQ2hhbm5lbHNbZCArIHJhbmtEaWZmXX0gPSAwO2ApLmpvaW4oJ1xcbicpO1xuICBjb25zdCBpblNpemUgPSBTaGFwZVV0aWwuc2l6ZShpblNoYXBlKTtcbiAgY29uc3QgaXNJbnB1dFNjYWxhciA9IGluU2l6ZSA9PT0gMTtcbiAgbGV0IG91dHB1dCA9ICd2ZWM0KG91dHB1dFZhbHVlLnh4LCBvdXRwdXRWYWx1ZS55eSknO1xuICBpZiAoaXNJbnB1dFNjYWxhcikge1xuICAgIG91dHB1dCA9ICd2ZWM0KG91dHB1dFZhbHVlLngpJztcbiAgfVxuICBjb25zdCBnZXRCaWFzRm9yTWF0bXVsU291cmNlID0gaXNQYWNrZWQgPyBgXG52ZWM0IGdldEJpYXNGb3JNYXRtdWwoKSB7XG4gICR7Y29vcmRzRGF0YVR5cGV9IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xuICAke2Nvb3Jkc1NuaXBwZXR9XG4gIHZlYzQgb3V0cHV0VmFsdWUgPSBnZXRCaWFzKCR7dW5wYWNrZWRDb29yZHNTbmlwcGV0fSk7XG4gIHJldHVybiAke291dHB1dH07XG59YCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBcbmZsb2F0IGdldEJpYXNGb3JNYXRtdWwoKSB7XG4gICR7Y29vcmRzRGF0YVR5cGV9IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xuICAke2Nvb3Jkc1NuaXBwZXR9XG4gIHJldHVybiBnZXRCaWFzKGNvb3Jkcy54KTtcbn1gO1xuXG4gIHJldHVybiBnZXRCaWFzRm9yTWF0bXVsU291cmNlO1xufVxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi4vLi4vLi4vdGVuc29yJztcbmltcG9ydCB7QnJvYWRjYXN0VXRpbCwgU2hhcGVVdGlsfSBmcm9tICcuLi8uLi8uLi91dGlsJztcbmltcG9ydCB7Z2V0R2xzbH0gZnJvbSAnLi4vZ2xzbC1zb3VyY2UnO1xuaW1wb3J0IHtXZWJHTEluZmVyZW5jZUhhbmRsZXJ9IGZyb20gJy4uL2luZmVyZW5jZS1oYW5kbGVyJztcbmltcG9ydCB7UHJvZ3JhbUluZm8sIFByb2dyYW1JbmZvTG9hZGVyLCBQcm9ncmFtTWV0YWRhdGEsIFRleHR1cmVUeXBlfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQge2dldENvb3Jkc0RhdGFUeXBlLCBnZXRHbENoYW5uZWxzfSBmcm9tICcuLi91dGlscyc7XG5cbmltcG9ydCB7Z2V0QWN0aXZhdGlvblNuaXBwZXQsIEludGVybmFsQWN0aXZhdGlvbkF0dHJpYnV0ZXN9IGZyb20gJy4vZnVzZS11dGlscyc7XG5pbXBvcnQge2dldEJpYXNGb3JNYXRtdWx9IGZyb20gJy4vbWF0bXVsJztcblxuY29uc3QgY3JlYXRlUGFja2VkTWF0bXVsUHJvZ3JhbU1ldGFkYXRhID0gKGhhc0JpYXM6IGJvb2xlYW4sIGNhY2hlSGludDogc3RyaW5nKSA9PiAoe1xuICBuYW1lOiAnTWF0TXVsIChwYWNrZWQpJyxcbiAgaW5wdXROYW1lczogaGFzQmlhcyA/IFsnQScsICdCJywgJ0JpYXMnXSA6IFsnQScsICdCJ10sXG4gIGlucHV0VHlwZXM6IGhhc0JpYXMgPyBbVGV4dHVyZVR5cGUucGFja2VkLCBUZXh0dXJlVHlwZS5wYWNrZWQsIFRleHR1cmVUeXBlLnBhY2tlZF0gOlxuICAgICAgICAgICAgICAgICAgICAgICAgW1RleHR1cmVUeXBlLnBhY2tlZCwgVGV4dHVyZVR5cGUucGFja2VkXSxcbiAgY2FjaGVIaW50XG59KTtcblxuY29uc3QgY3JlYXRlUGFja2VkTWF0bXVsUHJvZ3JhbUluZm8gPVxuICAgIChpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIG1ldGFkYXRhOiBQcm9ncmFtTWV0YWRhdGEsIGlucHV0czogVGVuc29yW10sXG4gICAgIGFjdGl2YXRpb25BdHRyaWJ1dGVzOiBJbnRlcm5hbEFjdGl2YXRpb25BdHRyaWJ1dGVzKTogUHJvZ3JhbUluZm8gPT4ge1xuICAgICAgY29uc3QgaGFzQmlhcyA9IGlucHV0cy5sZW5ndGggPiAyO1xuICAgICAgY29uc3QgcHJvY2Vzc0JpYXMgPSBoYXNCaWFzID8gJ3ZhbHVlICs9IGdldEJpYXNGb3JNYXRtdWwoKTsnIDogJyc7XG4gICAgICBjb25zdCBhU2hhcGUgPSBpbnB1dHNbMF0uZGltcztcbiAgICAgIGNvbnN0IGJTaGFwZSA9IGlucHV0c1sxXS5kaW1zO1xuICAgICAgY29uc3Qgb3V0cHV0U2hhcGUgPSBCcm9hZGNhc3RVdGlsLmNhbGNTaGFwZShhU2hhcGUsIGJTaGFwZSwgdHJ1ZSk7XG4gICAgICBjb25zdCBpc0Jyb2FkY2FzdCA9ICFTaGFwZVV0aWwuYXJlRXF1YWwoaW5wdXRzWzBdLmRpbXMsIGlucHV0c1sxXS5kaW1zKTtcblxuICAgICAgaWYgKCFvdXRwdXRTaGFwZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhblxcJ3QgdXNlIG1hdG11bCBvbiB0aGUgZ2l2ZW4gdGVuc29ycycpO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2hhcmVkRGltID0gYVNoYXBlW2FTaGFwZS5sZW5ndGggLSAxXTtcbiAgICAgIGNvbnN0IHNoYXJlZERpbUluZGV4ID0gTWF0aC5jZWlsKHNoYXJlZERpbSAvIDIpO1xuICAgICAgY29uc3QgYVJhbmsgPSBhU2hhcGUubGVuZ3RoO1xuICAgICAgY29uc3QgYlJhbmsgPSBiU2hhcGUubGVuZ3RoO1xuXG4gICAgICBjb25zdCBnbHNsID0gZ2V0R2xzbChpbmZlcmVuY2VIYW5kbGVyLnNlc3Npb24uYmFja2VuZC5nbENvbnRleHQudmVyc2lvbik7XG4gICAgICBjb25zdCBjb29yZHNEYXRhVHlwZSA9IGdldENvb3Jkc0RhdGFUeXBlKG91dHB1dFNoYXBlLmxlbmd0aCk7XG4gICAgICBjb25zdCBvdXRSYW5rID0gb3V0cHV0U2hhcGUubGVuZ3RoO1xuICAgICAgY29uc3QgYWxsR2xDaGFubmVscyA9IGdldEdsQ2hhbm5lbHMoKTtcbiAgICAgIGNvbnN0IHthY3RpdmF0aW9uRnVuY3Rpb24sIGFwcGx5QWN0aXZhdGlvbn0gPSBnZXRBY3RpdmF0aW9uU25pcHBldChhY3RpdmF0aW9uQXR0cmlidXRlcyk7XG5cbiAgICAgIGNvbnN0IGdldEJpYXNGb3JNYXRtdWxTbmlwcGV0ID1cbiAgICAgICAgICBoYXNCaWFzID8gYCR7Z2V0Qmlhc0Zvck1hdG11bChjb29yZHNEYXRhVHlwZSwgYWxsR2xDaGFubmVscywgaW5wdXRzWzJdLmRpbXMsIG91dHB1dFNoYXBlLCB0cnVlKX1gIDogJyc7XG5cbiAgICAgIGNvbnN0IGdldEJjYXN0ZWRTYW1wbGVyRm9yTWF0bXVsU25pcHBldCA9XG4gICAgICAgICAgaXNCcm9hZGNhc3QgPyBgJHtnZXRCY2FzdFNhbXBsZXJGb3JNYXRtdWwoY29vcmRzRGF0YVR5cGUsIGFsbEdsQ2hhbm5lbHMsIGlucHV0cywgb3V0cHV0U2hhcGUpfWAgOiAnJztcblxuICAgICAgY29uc3QgZ2V0U2FtcGxlckFJbkxvb3BTbmlwcGV0ID0gaXNCcm9hZGNhc3QgPyAnZ2V0QUF0T3V0Q29vcmRzTWF0bXVsKGkpJyA6IGBnZXRBKCR7Z2V0QShhbGxHbENoYW5uZWxzLCBhUmFuayl9KWA7XG4gICAgICBjb25zdCBnZXRTYW1wbGVyQkluTG9vcFNuaXBwZXQgPSBpc0Jyb2FkY2FzdCA/ICdnZXRCQXRPdXRDb29yZHNNYXRtdWwoaSknIDogYGdldEIoJHtnZXRCKGFsbEdsQ2hhbm5lbHMsIGJSYW5rKX0pYDtcbiAgICAgIGNvbnN0IGdldE91dHB1dENvb3Jkc1NuaXBwZXQgPSBpc0Jyb2FkY2FzdCA/ICcnIDogYCR7Y29vcmRzRGF0YVR5cGV9IHJjID1cbiAgICAgICAgICBnZXRPdXRwdXRDb29yZHMoKTsgaW50IGxhc3REaW0gPSByYy4ke2FsbEdsQ2hhbm5lbHNbb3V0UmFuayAtIDFdfTsgcmMuJHthbGxHbENoYW5uZWxzW291dFJhbmsgLSAxXX0gPVxuICAgICAgICAgIHJjLiR7YWxsR2xDaGFubmVsc1tvdXRSYW5rIC0gMl19OyByYy4ke2FsbEdsQ2hhbm5lbHNbb3V0UmFuayAtIDJdfSA9IGxhc3REaW07XG4gICAgICBgO1xuICAgICAgY29uc3Qgc2hhZGVyU291cmNlID0gYFxuICAgICAgICAgICAgJHtnZXRCY2FzdGVkU2FtcGxlckZvck1hdG11bFNuaXBwZXR9XG4gICAgICAgICAgICAke2dldEJpYXNGb3JNYXRtdWxTbmlwcGV0fVxuICAgICAgICAgICAgJHthY3RpdmF0aW9uRnVuY3Rpb259XG4gICAgICAgICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgICAgICAgICR7Z2V0T3V0cHV0Q29vcmRzU25pcHBldH1cblxuICAgICAgICAgICAgICB2ZWM0IHZhbHVlID0gdmVjNCgwKTtcbiAgICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCAke3NoYXJlZERpbUluZGV4fTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmVjNCBhID0gJHtnZXRTYW1wbGVyQUluTG9vcFNuaXBwZXR9O1xuICAgICAgICAgICAgICAgIHZlYzQgYiA9ICR7Z2V0U2FtcGxlckJJbkxvb3BTbmlwcGV0fTtcblxuICAgICAgICAgICAgICAgIHZhbHVlICs9IChhLnJyYmIgKiBiLnJncmcpO1xuICAgICAgICAgICAgICAgIHZhbHVlICs9IChhLmdnYWEgKiBiLmJhYmEpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICR7cHJvY2Vzc0JpYXN9XG4gICAgICAgICAgICAgICR7YXBwbHlBY3RpdmF0aW9ufVxuICAgICAgICAgICAgICAke2dsc2wub3V0cHV0fSA9IHZhbHVlO1xuICAgICAgICAgICAgfWA7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5tZXRhZGF0YSxcbiAgICAgICAgb3V0cHV0OiB7ZGltczogb3V0cHV0U2hhcGUsIHR5cGU6IGlucHV0c1swXS50eXBlLCB0ZXh0dXJlVHlwZTogVGV4dHVyZVR5cGUucGFja2VkfSxcbiAgICAgICAgc2hhZGVyU291cmNlLFxuICAgICAgICBoYXNNYWluOiB0cnVlXG4gICAgICB9O1xuICAgIH07XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVQYWNrZWRNYXRtdWxQcm9ncmFtSW5mb0xvYWRlciA9XG4gICAgKGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSxcbiAgICAgYWN0aXZhdGlvbkF0dHJpYnV0ZXM6IEludGVybmFsQWN0aXZhdGlvbkF0dHJpYnV0ZXMpOiBQcm9ncmFtSW5mb0xvYWRlciA9PiB7XG4gICAgICBjb25zdCBtZXRhZGF0YSA9IGNyZWF0ZVBhY2tlZE1hdG11bFByb2dyYW1NZXRhZGF0YShpbnB1dHMubGVuZ3RoID4gMiwgYWN0aXZhdGlvbkF0dHJpYnV0ZXMuYWN0aXZhdGlvbkNhY2hlS2V5KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLm1ldGFkYXRhLFxuICAgICAgICBnZXQ6ICgpID0+IGNyZWF0ZVBhY2tlZE1hdG11bFByb2dyYW1JbmZvKGluZmVyZW5jZUhhbmRsZXIsIG1ldGFkYXRhLCBpbnB1dHMsIGFjdGl2YXRpb25BdHRyaWJ1dGVzKVxuICAgICAgfTtcbiAgICB9O1xuXG5mdW5jdGlvbiBnZXRCY2FzdFNhbXBsZXJGb3JNYXRtdWwoXG4gICAgY29vcmRzRGF0YVR5cGU6IHN0cmluZywgYWxsR2xDaGFubmVsczogcmVhZG9ubHkgc3RyaW5nW10sIGlucHV0czogVGVuc29yW10sIG91dFNoYXBlOiByZWFkb25seSBudW1iZXJbXSk6IHN0cmluZyB7XG4gIGxldCB1bnBhY2tlZEFDb29yZHNTbmlwcGV0ID0gW107XG4gIGxldCB1bnBhY2tlZEJDb29yZHNTbmlwcGV0ID0gW107XG5cbiAgY29uc3QgaW5BU2hhcGUgPSBpbnB1dHNbMF0uZGltcztcbiAgY29uc3QgaW5CU2hhcGUgPSBpbnB1dHNbMV0uZGltcztcblxuICBjb25zdCBpbkFSYW5rID0gaW5BU2hhcGUubGVuZ3RoO1xuICBjb25zdCBpbkJSYW5rID0gaW5CU2hhcGUubGVuZ3RoO1xuXG4gIGNvbnN0IG91dFJhbmsgPSBvdXRTaGFwZS5sZW5ndGg7XG4gIGNvbnN0IHJhbmtBRGlmZiA9IG91dFJhbmsgLSBpbkFSYW5rO1xuICBjb25zdCByYW5rQkRpZmYgPSBvdXRSYW5rIC0gaW5CUmFuaztcblxuICB1bnBhY2tlZEFDb29yZHNTbmlwcGV0ID0gaW5BU2hhcGUubWFwKChfcywgaSkgPT4gYGNvb3Jkcy4ke2FsbEdsQ2hhbm5lbHNbaSArIHJhbmtBRGlmZl19YCk7XG4gIHVucGFja2VkQUNvb3Jkc1NuaXBwZXRbaW5BUmFuayAtIDFdID0gJ2kqMic7XG4gIHVucGFja2VkQUNvb3Jkc1NuaXBwZXQuam9pbignLCAnKTtcbiAgdW5wYWNrZWRCQ29vcmRzU25pcHBldCA9IGluQlNoYXBlLm1hcCgoX3MsIGkpID0+IGBjb29yZHMuJHthbGxHbENoYW5uZWxzW2kgKyByYW5rQkRpZmZdfWApO1xuICB1bnBhY2tlZEJDb29yZHNTbmlwcGV0W2luQlJhbmsgLSAyXSA9ICdpKjInO1xuICB1bnBhY2tlZEJDb29yZHNTbmlwcGV0LmpvaW4oJywgJyk7XG5cbiAgY29uc3QgYnJvYWRjYXN0QURpbXMgPSBCcm9hZGNhc3RVdGlsLmdldEJyb2FkY2FzdERpbXMoaW5BU2hhcGUsIG91dFNoYXBlKTtcbiAgY29uc3QgYnJvYWRjYXN0QkRpbXMgPSBCcm9hZGNhc3RVdGlsLmdldEJyb2FkY2FzdERpbXMoaW5CU2hhcGUsIG91dFNoYXBlKTtcblxuICBjb25zdCBjb29yZHNBU25pcHBldCA9IGJyb2FkY2FzdEFEaW1zLm1hcChkID0+IGBjb29yZHMuJHthbGxHbENoYW5uZWxzW2QgKyByYW5rQURpZmZdfSA9IDA7YCkuam9pbignXFxuJyk7XG4gIGNvbnN0IGNvb3Jkc0JTbmlwcGV0ID0gYnJvYWRjYXN0QkRpbXMubWFwKGQgPT4gYGNvb3Jkcy4ke2FsbEdsQ2hhbm5lbHNbZCArIHJhbmtCRGlmZl19ID0gMDtgKS5qb2luKCdcXG4nKTtcbiAgY29uc3Qgc3dhcERpbVNuaXBwZXQgPSBgaW50IGxhc3REaW0gPSBjb29yZHMuJHthbGxHbENoYW5uZWxzW291dFJhbmsgLSAxXX07XG4gIGNvb3Jkcy4ke2FsbEdsQ2hhbm5lbHNbb3V0UmFuayAtIDFdfSA9IGNvb3Jkcy4ke2FsbEdsQ2hhbm5lbHNbb3V0UmFuayAtIDJdfTtcbiAgY29vcmRzLiR7YWxsR2xDaGFubmVsc1tvdXRSYW5rIC0gMl19ID0gbGFzdERpbTtgO1xuXG4gIGNvbnN0IGdldEJjYXN0U2FtcGxlck1hdG11bFNvdXJjZSA9IGBcbnZlYzQgZ2V0QUF0T3V0Q29vcmRzTWF0bXVsKGludCBpKSB7XG4gICR7Y29vcmRzRGF0YVR5cGV9IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xuICAke3N3YXBEaW1TbmlwcGV0fVxuICAke2Nvb3Jkc0FTbmlwcGV0fVxuICB2ZWM0IG91dHB1dFZhbHVlID0gZ2V0QSgke3VucGFja2VkQUNvb3Jkc1NuaXBwZXR9KTtcbiAgcmV0dXJuIG91dHB1dFZhbHVlO1xufVxuXG52ZWM0IGdldEJBdE91dENvb3Jkc01hdG11bChpbnQgaSkge1xuICAke2Nvb3Jkc0RhdGFUeXBlfSBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcbiAgJHtzd2FwRGltU25pcHBldH1cbiAgJHtjb29yZHNCU25pcHBldH1cbiAgdmVjNCBvdXRwdXRWYWx1ZSA9IGdldEIoJHt1bnBhY2tlZEJDb29yZHNTbmlwcGV0fSk7XG4gIHJldHVybiBvdXRwdXRWYWx1ZTtcbn1gO1xuXG4gIHJldHVybiBnZXRCY2FzdFNhbXBsZXJNYXRtdWxTb3VyY2U7XG59XG5cbmZ1bmN0aW9uIGdldEEoYWxsR2xDaGFubmVsczogc3RyaW5nW10sIHJhbms6IG51bWJlcik6IHN0cmluZyB7XG4gIGxldCByZXMgPSAnJztcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5rIC0gMjsgaSsrKSB7XG4gICAgcmVzICs9IGByYy4ke2FsbEdsQ2hhbm5lbHNbaV19LCBgO1xuICB9XG4gIHJlcyArPSBgcmMuJHthbGxHbENoYW5uZWxzW3JhbmsgLSAyXX0sIGAgK1xuICAgICAgJ2kqMic7XG4gIHJldHVybiByZXM7XG59XG5cbmZ1bmN0aW9uIGdldEIoYWxsR2xDaGFubmVsczogc3RyaW5nW10sIHJhbms6IG51bWJlcik6IHN0cmluZyB7XG4gIGxldCByZXMgPSAnJztcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5rIC0gMjsgaSsrKSB7XG4gICAgcmVzICs9IGByYy4ke2FsbEdsQ2hhbm5lbHNbaV19LCBgO1xuICB9XG4gIHJlcyArPSAnaSoyLCAnICtcbiAgICAgIGByYy4ke2FsbEdsQ2hhbm5lbHNbcmFuayAtIDFdfWA7XG4gIHJldHVybiByZXM7XG59XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7VGVuc29yfSBmcm9tICcuLi8uLi8uLi90ZW5zb3InO1xuaW1wb3J0IHtXZWJHTEluZmVyZW5jZUhhbmRsZXJ9IGZyb20gJy4uL2luZmVyZW5jZS1oYW5kbGVyJztcblxuaW1wb3J0IHtjYWxjdWxhdGVPdXRwdXRTaGFwZSwgQ29udkF0dHJpYnV0ZXN9IGZyb20gJy4vY29udic7XG5pbXBvcnQge2NyZWF0ZVBhY2tlZEltMkNvbFByb2dyYW1JbmZvTG9hZGVyfSBmcm9tICcuL2ltMmNvbC1wYWNrJztcbmltcG9ydCB7Y3JlYXRlUGFja2VkTWF0bXVsUHJvZ3JhbUluZm9Mb2FkZXJ9IGZyb20gJy4vbWF0bXVsLXBhY2snO1xuXG5leHBvcnQgY29uc3QgY29udjJEUGFja2VkUG9pbnR3aXNlID1cbiAgICAoaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IHJlYWRvbmx5IFRlbnNvcltdLCBhdHRyaWJ1dGVzOiBDb252QXR0cmlidXRlcyk6IFRlbnNvciA9PiB7XG4gICAgICBjb25zdCB4c2hhcGUgPSBpbnB1dHNbMF0uZGltcztcbiAgICAgIGNvbnN0IGtzaGFwZSA9IGlucHV0c1sxXS5kaW1zO1xuICAgICAgY29uc3Qgb3V0cHV0U2hhcGUgPVxuICAgICAgICAgIGNhbGN1bGF0ZU91dHB1dFNoYXBlKHhzaGFwZSwga3NoYXBlLCBhdHRyaWJ1dGVzLmRpbGF0aW9ucywgYXR0cmlidXRlcy5wYWRzLCBhdHRyaWJ1dGVzLnN0cmlkZXMpO1xuICAgICAgY29uc3QgcmVzaGFwZWRYID0gaW5mZXJlbmNlSGFuZGxlci5yZXNoYXBlUGFja2VkKGlucHV0c1swXSwgW3hzaGFwZVsxXSwgeHNoYXBlWzJdICogeHNoYXBlWzNdXSk7XG4gICAgICBjb25zdCByZXNoYXBlZEsgPSBpbmZlcmVuY2VIYW5kbGVyLnJlc2hhcGVQYWNrZWQoaW5wdXRzWzFdLCBba3NoYXBlWzBdLCBrc2hhcGVbMV1dKTtcblxuICAgICAgY29uc3QgbWF0bXVsSW5wdXRzID0gaW5wdXRzLmxlbmd0aCA+IDIgPyBbcmVzaGFwZWRLLCByZXNoYXBlZFgsIGlucHV0c1syXV0gOiBbcmVzaGFwZWRLLCByZXNoYXBlZFhdO1xuICAgICAgY29uc3QgbWF0bXVsT3V0cHV0ID0gaW5mZXJlbmNlSGFuZGxlci5ydW4oXG4gICAgICAgICAgY3JlYXRlUGFja2VkTWF0bXVsUHJvZ3JhbUluZm9Mb2FkZXIoaW5mZXJlbmNlSGFuZGxlciwgbWF0bXVsSW5wdXRzLCBhdHRyaWJ1dGVzKSwgbWF0bXVsSW5wdXRzKTtcbiAgICAgIHJldHVybiBpbmZlcmVuY2VIYW5kbGVyLnJlc2hhcGVQYWNrZWQobWF0bXVsT3V0cHV0LCBvdXRwdXRTaGFwZSk7XG4gICAgfTtcblxuZXhwb3J0IGNvbnN0IGNvbnYyRFBhY2tlZCA9XG4gICAgKGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiByZWFkb25seSBUZW5zb3JbXSwgYXR0cmlidXRlczogQ29udkF0dHJpYnV0ZXMpOiBUZW5zb3IgPT4ge1xuICAgICAgY29uc3QgeHNoYXBlID0gaW5wdXRzWzBdLmRpbXM7XG4gICAgICBjb25zdCBrc2hhcGUgPSBpbnB1dHNbMV0uZGltcztcbiAgICAgIGNvbnN0IG91dHB1dFNoYXBlID1cbiAgICAgICAgICBjYWxjdWxhdGVPdXRwdXRTaGFwZSh4c2hhcGUsIGtzaGFwZSwgYXR0cmlidXRlcy5kaWxhdGlvbnMsIGF0dHJpYnV0ZXMucGFkcywgYXR0cmlidXRlcy5zdHJpZGVzKTtcblxuICAgICAgLy8gcnVuIGltMmNvbFxuICAgICAgY29uc3QgaW0yY29sT3V0cHV0ID0gaW5mZXJlbmNlSGFuZGxlci5ydW4oXG4gICAgICAgICAgY3JlYXRlUGFja2VkSW0yQ29sUHJvZ3JhbUluZm9Mb2FkZXIoaW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzWzBdLCBpbnB1dHNbMV0sIG91dHB1dFNoYXBlLCBhdHRyaWJ1dGVzKSxcbiAgICAgICAgICBbaW5wdXRzWzBdXSk7XG5cbiAgICAgIC8vIHJlc2hhcGUga2VybmVsXG4gICAgICBjb25zdCBrZXJuZWxSZXNoYXBlZCA9IGluZmVyZW5jZUhhbmRsZXIucmVzaGFwZVBhY2tlZChpbnB1dHNbMV0sIFtrc2hhcGVbMF0sIGtzaGFwZVsxXSAqIGtzaGFwZVsyXSAqIGtzaGFwZVszXV0pO1xuXG4gICAgICAvLyBydW4gbWF0bXVsXG4gICAgICBjb25zdCBtYXRtdWxJbnB1dHMgPVxuICAgICAgICAgIChpbnB1dHMubGVuZ3RoID09PSAzKSA/IFtrZXJuZWxSZXNoYXBlZCwgaW0yY29sT3V0cHV0LCBpbnB1dHNbMl1dIDogW2tlcm5lbFJlc2hhcGVkLCBpbTJjb2xPdXRwdXRdO1xuICAgICAgY29uc3QgbWF0bXVsT3V0cHV0ID0gaW5mZXJlbmNlSGFuZGxlci5ydW4oXG4gICAgICAgICAgY3JlYXRlUGFja2VkTWF0bXVsUHJvZ3JhbUluZm9Mb2FkZXIoaW5mZXJlbmNlSGFuZGxlciwgbWF0bXVsSW5wdXRzLCBhdHRyaWJ1dGVzKSwgbWF0bXVsSW5wdXRzKTtcblxuICAgICAgLy8gcmVzaGFwZSBvdXRwdXRcbiAgICAgIGNvbnN0IG91dHB1dFJlc2hhcGVkID0gaW5mZXJlbmNlSGFuZGxlci5yZXNoYXBlUGFja2VkKG1hdG11bE91dHB1dCwgb3V0cHV0U2hhcGUpO1xuICAgICAgcmV0dXJuIG91dHB1dFJlc2hhcGVkO1xuICAgIH07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7VGVuc29yfSBmcm9tICcuLi8uLi8uLi90ZW5zb3InO1xuaW1wb3J0IHtXZWJHTEluZmVyZW5jZUhhbmRsZXJ9IGZyb20gJy4uL2luZmVyZW5jZS1oYW5kbGVyJztcbmltcG9ydCB7UHJvZ3JhbUluZm8sIFByb2dyYW1JbmZvTG9hZGVyLCBQcm9ncmFtTWV0YWRhdGEsIFRleHR1cmVUeXBlfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7Q29udkF0dHJpYnV0ZXN9IGZyb20gJy4vY29udic7XG5cbmNvbnN0IGNyZWF0ZUltMkNvbFByb2dyYW1NZXRhZGF0YSA9IChjYWNoZUhpbnQ6IHN0cmluZykgPT4gKHtcbiAgbmFtZTogJ0ltMkNvbCcsXG4gIGlucHV0TmFtZXM6IFsnWCddLFxuICBpbnB1dFR5cGVzOiBbVGV4dHVyZVR5cGUudW5wYWNrZWRdLFxuICBjYWNoZUhpbnQsXG59KTtcblxuY29uc3QgY3JlYXRlSW0yQ29sUHJvZ3JhbUluZm8gPVxuICAgIChfaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBtZXRhZGF0YTogUHJvZ3JhbU1ldGFkYXRhLCB4OiBUZW5zb3IsIHc6IFRlbnNvcixcbiAgICAgb3V0cHV0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLCBhdHRyaWJ1dGVzOiBDb252QXR0cmlidXRlcyk6IFByb2dyYW1JbmZvID0+IHtcbiAgICAgIGNvbnN0IHhzaGFwZSA9IHguZGltcztcbiAgICAgIGNvbnN0IHdzaGFwZSA9IHcuZGltcztcblxuICAgICAgY29uc3QgcmFuayA9IG91dHB1dFNoYXBlLmxlbmd0aDtcbiAgICAgIGNvbnN0IGltMmNvbERpbXMgPSBjYWxjdWxhdGVJbTJDb2xEaW1zKHhzaGFwZSwgd3NoYXBlLCBvdXRwdXRTaGFwZSwgNCk7XG5cbiAgICAgIGNvbnN0IHNoYWRlclNvdXJjZSA9IGBcbiAgICAgICAgY29uc3QgaW50IFhDID0gJHt4c2hhcGVbMV19O1xuICAgICAgICBjb25zdCBpbnQgWEggPSAke3hzaGFwZVsyXX07XG4gICAgICAgIGNvbnN0IGludCBYVyA9ICR7eHNoYXBlWzNdfTtcbiAgICAgICAgY29uc3QgaW50IEtIID0gJHthdHRyaWJ1dGVzLmtlcm5lbFNoYXBlWzBdfTtcbiAgICAgICAgY29uc3QgaW50IEtXID0gJHthdHRyaWJ1dGVzLmtlcm5lbFNoYXBlWzFdfTtcbiAgICAgICAgY29uc3QgaW50IGRpbGF0aW9uSCA9ICR7YXR0cmlidXRlcy5kaWxhdGlvbnNbMF19O1xuICAgICAgICBjb25zdCBpbnQgZGlsYXRpb25XID0gJHthdHRyaWJ1dGVzLmRpbGF0aW9uc1sxXX07XG4gICAgICAgIGNvbnN0IGludCBzdHJpZGVIID0gJHthdHRyaWJ1dGVzLnN0cmlkZXNbMF19O1xuICAgICAgICBjb25zdCBpbnQgc3RyaWRlVyA9ICR7YXR0cmlidXRlcy5zdHJpZGVzWzFdfTtcbiAgICAgICAgY29uc3QgaW50IHBhZEggPSAke2F0dHJpYnV0ZXMucGFkc1swXX07XG4gICAgICAgIGNvbnN0IGludCBwYWRXID0gJHthdHRyaWJ1dGVzLnBhZHNbMV19O1xuICAgICAgICBjb25zdCBpbnQgS0hLVyA9IEtIKktXO1xuICAgICAgICBjb25zdCBpbnQgWENLSEtXID0gWEMgKiBLSEtXO1xuICAgICAgICBjb25zdCBpbnQgb3V0cHV0Q2hhbm5lbHMgPSA0O1xuICAgICAgICB2ZWM0IHByb2Nlc3MoaW50IGluZGljZXNbJHtyYW5rfV0pIHtcbiAgICAgICAgICBpbnQgYiAgPSBpbmRpY2VzWzBdOyAvLyBiYXRjaCBzaXplXG4gICAgICAgICAgaW50IG9oID0gaW5kaWNlc1sxXSAqIHN0cmlkZUggLSBwYWRIOyAvL291dHB1dCBoZWlnaHRcbiAgICAgICAgICBpbnQgb3cgPSBpbmRpY2VzWzJdICogc3RyaWRlVyAtIHBhZFc7IC8vb3V0cHV0IHdpZHRoXG4gICAgICAgICAgaW50IHAgPSBpbmRpY2VzWzNdICogb3V0cHV0Q2hhbm5lbHM7IC8vcGF0Y2hcbiAgICAgICAgICB2ZWM0IHZhbHVlID0gdmVjNCgwLjApO1xuICAgICAgICAgIGZvcihpbnQgaT0wOyBpIDwgb3V0cHV0Q2hhbm5lbHM7ICsraSkge1xuICAgICAgICAgICAgaWYocCA8IFhDS0hLVykge1xuICAgICAgICAgICAgICBpbnQgcGF0Y2hDID0gcCAvIEtIS1c7XG4gICAgICAgICAgICAgIGludCBwYXRjaEggPSAocCAtIHBhdGNoQypLSEtXKSAvIEtXO1xuICAgICAgICAgICAgICBpbnQgcGF0Y2hXID0gKHAgLSBwYXRjaEMqS0hLVykgLSBwYXRjaEggKiBLVztcbiAgICAgICAgICAgICAgaW50IHhoMiA9IG9oICsgcGF0Y2hIICogZGlsYXRpb25IO1xuICAgICAgICAgICAgICBpbnQgeHcyID0gb3cgKyBwYXRjaFcgKiBkaWxhdGlvblc7XG4gICAgICAgICAgICAgIGludCB4WyR7eHNoYXBlLmxlbmd0aH1dO1xuICAgICAgICAgICAgICB4WzBdID0gYjtcbiAgICAgICAgICAgICAgeFsxXSA9IHBhdGNoQztcbiAgICAgICAgICAgICAgeFsyXSA9IHhoMjtcbiAgICAgICAgICAgICAgeFszXSA9IHh3MjtcbiAgICAgICAgICAgICAgaWYoeGgyID49IDAgJiZcbiAgICAgICAgICAgICAgICAgIHhoMiA8IFhIICYmXG4gICAgICAgICAgICAgICAgICB4dzIgPj0gMCAmJlxuICAgICAgICAgICAgICAgICAgeHcyIDwgWFcpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZVtpXSA9IF9YKHgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICArK3A7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBgO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4ubWV0YWRhdGEsXG4gICAgICAgIG91dHB1dDoge2RpbXM6IGltMmNvbERpbXMsIHR5cGU6IHgudHlwZSwgdGV4dHVyZVR5cGU6IFRleHR1cmVUeXBlLnBhY2tlZExhc3REaW1lbnNpb259LFxuICAgICAgICBzaGFkZXJTb3VyY2VcbiAgICAgIH07XG4gICAgfTtcblxuZXhwb3J0IGNvbnN0IGNyZWF0ZUltMkNvbFByb2dyYW1JbmZvTG9hZGVyID1cbiAgICAoaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCB4OiBUZW5zb3IsIHc6IFRlbnNvciwgb3V0cHV0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLFxuICAgICBhdHRyaWJ1dGVzOiBDb252QXR0cmlidXRlcyk6IFByb2dyYW1JbmZvTG9hZGVyID0+IHtcbiAgICAgIGNvbnN0IG1ldGFkYXRhID0gY3JlYXRlSW0yQ29sUHJvZ3JhbU1ldGFkYXRhKGF0dHJpYnV0ZXMuY2FjaGVLZXkpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4ubWV0YWRhdGEsXG4gICAgICAgIGdldDogKCkgPT4gY3JlYXRlSW0yQ29sUHJvZ3JhbUluZm8oaW5mZXJlbmNlSGFuZGxlciwgbWV0YWRhdGEsIHgsIHcsIG91dHB1dFNoYXBlLCBhdHRyaWJ1dGVzKVxuICAgICAgfTtcbiAgICB9O1xuXG5cbmV4cG9ydCBjb25zdCBjYWxjdWxhdGVJbTJDb2xEaW1zID1cbiAgICAoaW5wdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sIGtlcm5lbFNoYXBlOiByZWFkb25seSBudW1iZXJbXSwgb3V0cHV0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLCBjaGFubmVscyA9IDQpOlxuICAgICAgICBudW1iZXJbXSA9PlxuICAgICAgICAgICAgW291dHB1dFNoYXBlWzBdLCBvdXRwdXRTaGFwZVsyXSwgb3V0cHV0U2hhcGVbM10sXG4gICAgICAgICAgICAgTWF0aC5jZWlsKGlucHV0U2hhcGVbMV0gKiBrZXJuZWxTaGFwZVsyXSAqIGtlcm5lbFNoYXBlWzNdIC8gY2hhbm5lbHMpXTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4uLy4uLy4uL3RlbnNvcic7XG5pbXBvcnQge1NoYXBlVXRpbH0gZnJvbSAnLi4vLi4vLi4vdXRpbCc7XG5pbXBvcnQge2dldEdsc2x9IGZyb20gJy4uL2dsc2wtc291cmNlJztcbmltcG9ydCB7V2ViR0xJbmZlcmVuY2VIYW5kbGVyfSBmcm9tICcuLi9pbmZlcmVuY2UtaGFuZGxlcic7XG5pbXBvcnQge1Byb2dyYW1JbmZvLCBQcm9ncmFtSW5mb0xvYWRlciwgUHJvZ3JhbU1ldGFkYXRhLCBUZXh0dXJlVHlwZX0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQge2dldEFjdGl2YXRpb25TbmlwcGV0LCBJbnRlcm5hbEFjdGl2YXRpb25BdHRyaWJ1dGVzfSBmcm9tICcuL2Z1c2UtdXRpbHMnO1xuaW1wb3J0IHtjYWxjdWxhdGVJbTJDb2xEaW1zfSBmcm9tICcuL2ltMmNvbCc7XG5cbmNvbnN0IGNyZWF0ZURvdFByb2R1Y3RQcm9ncmFtTWV0YWRhdGEgPSAoaGFzQmlhczogYm9vbGVhbiwgYXR0cmlidXRlczogSW50ZXJuYWxBY3RpdmF0aW9uQXR0cmlidXRlcykgPT4gKHtcbiAgbmFtZTogJ0NvbnZEb3RQcm9kdWN0JyxcbiAgaW5wdXROYW1lczogaGFzQmlhcyA/IFsnSW0yQ29sJywgJ0snLCAnQiddIDogWydJbTJDb2wnLCAnSyddLFxuICBpbnB1dFR5cGVzOiBoYXNCaWFzID8gW1RleHR1cmVUeXBlLnVucGFja2VkLCBUZXh0dXJlVHlwZS5wYWNrZWRMYXN0RGltZW5zaW9uLCBUZXh0dXJlVHlwZS51bnBhY2tlZF0gOlxuICAgICAgICAgICAgICAgICAgICAgICAgW1RleHR1cmVUeXBlLnVucGFja2VkLCBUZXh0dXJlVHlwZS5wYWNrZWRMYXN0RGltZW5zaW9uXSxcbiAgY2FjaGVLZXk6IGF0dHJpYnV0ZXMuYWN0aXZhdGlvbkNhY2hlS2V5XG59KTtcblxuY29uc3QgY3JlYXRlRG90UHJvZHVjdFByb2dyYW1JbmZvID1cbiAgICAoaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBtZXRhZGF0YTogUHJvZ3JhbU1ldGFkYXRhLCBpbnB1dHM6IHJlYWRvbmx5IFRlbnNvcltdLFxuICAgICBvdXRwdXRTaGFwZTogbnVtYmVyW10sIGF0dHJpYnV0ZXM6IEludGVybmFsQWN0aXZhdGlvbkF0dHJpYnV0ZXMpOiBQcm9ncmFtSW5mbyA9PiB7XG4gICAgICBjb25zdCB4c2hhcGUgPSBpbnB1dHNbMF0uZGltcztcbiAgICAgIGNvbnN0IGtzaGFwZSA9IGlucHV0c1sxXS5kaW1zO1xuICAgICAgY29uc3QgYWRqdXN0ZWRLZXJuZWxTaGFwZSA9IFtrc2hhcGVbMF0sIE1hdGguY2VpbCgoeHNoYXBlWzFdICoga3NoYXBlWzJdICoga3NoYXBlWzNdKSAvIDQpXTtcbiAgICAgIGNvbnN0IGltMmNvbFNoYXBlID0gY2FsY3VsYXRlSW0yQ29sRGltcyh4c2hhcGUsIGtzaGFwZSwgb3V0cHV0U2hhcGUpO1xuICAgICAgY29uc3QgW2tXaWR0aCwga0hlaWdodF0gPVxuICAgICAgICAgIGluZmVyZW5jZUhhbmRsZXIuY2FsY3VsYXRlVGV4dHVyZVdpZHRoQW5kSGVpZ2h0KGFkanVzdGVkS2VybmVsU2hhcGUsIFRleHR1cmVUeXBlLnBhY2tlZExhc3REaW1lbnNpb24pO1xuXG4gICAgICBjb25zdCBpbTJjb2xTdHJpZGVzID0gU2hhcGVVdGlsLmNvbXB1dGVTdHJpZGVzKGltMmNvbFNoYXBlKTtcbiAgICAgIGNvbnN0IFtpbTJjb2xXaWR0aCwgaW0yY29sSGVpZ2h0XSA9XG4gICAgICAgICAgaW5mZXJlbmNlSGFuZGxlci5jYWxjdWxhdGVUZXh0dXJlV2lkdGhBbmRIZWlnaHQoaW0yY29sU2hhcGUsIFRleHR1cmVUeXBlLnBhY2tlZExhc3REaW1lbnNpb24pO1xuICAgICAgY29uc3QgcmFuayA9IG91dHB1dFNoYXBlLmxlbmd0aDtcblxuICAgICAgY29uc3QgaW5pdFZhbHVlID0gKGlucHV0cy5sZW5ndGggPCAzKSA/ICcwLjAnIDogJ19CKGIpJztcbiAgICAgIGNvbnN0IHNoYXJlZERpbSA9IE1hdGguY2VpbCh4c2hhcGVbMV0gKiBrc2hhcGVbMl0gKiBrc2hhcGVbM10gLyA0KTtcbiAgICAgIGNvbnN0IHthY3RpdmF0aW9uRnVuY3Rpb24sIGFwcGx5QWN0aXZhdGlvbn0gPSBnZXRBY3RpdmF0aW9uU25pcHBldChhdHRyaWJ1dGVzKTtcbiAgICAgIGNvbnN0IGdsc2wgPSBnZXRHbHNsKGluZmVyZW5jZUhhbmRsZXIuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC52ZXJzaW9uKTtcbiAgICAgIGNvbnN0IHNoYWRlclNvdXJjZSA9IGBcbiR7YWN0aXZhdGlvbkZ1bmN0aW9ufVxuZmxvYXQgcHJvY2VzcyhpbnQgaW5kaWNlc1ske3Jhbmt9XSkge1xuICBpbnQgYlsxXTtcbiAgYlswXSA9IGluZGljZXNbMV07XG4gIGludCBpbTJjb2xbNF07XG4gIGltMmNvbFswXSA9IGluZGljZXNbMF07XG4gIGltMmNvbFsxXSA9IGluZGljZXNbMl07XG4gIGltMmNvbFsyXSA9IGluZGljZXNbM107XG4gIGludCBpbTJjb2xPZmZzZXQgPSBpbTJjb2xbMF0gKiAke2ltMmNvbFN0cmlkZXNbMF19ICsgaW0yY29sWzFdICogJHtpbTJjb2xTdHJpZGVzWzFdfSArIGltMmNvbFsyXSAqICR7XG4gICAgICAgICAgaW0yY29sU3RyaWRlc1syXX07XG4gIGludCBrZXJuZWxPZmZzZXQgPSBpbmRpY2VzWzFdICogJHthZGp1c3RlZEtlcm5lbFNoYXBlWzFdfTtcbiAgZmxvYXQgdmFsdWUgPSAke2luaXRWYWx1ZX07XG4gIGZvciAoaW50IGkgPSAwOyBpIDwgJHtzaGFyZWREaW19OyArK2kpIHtcbiAgICB2ZWMyIGltMmNvbENvb3JkcyA9IG9mZnNldFRvQ29vcmRzKGltMmNvbE9mZnNldCwgJHtpbTJjb2xXaWR0aH0sICR7aW0yY29sSGVpZ2h0fSk7XG4gICAgdmVjMiBrZXJuZWxDb29yZHMgPSBvZmZzZXRUb0Nvb3JkcyhrZXJuZWxPZmZzZXQsICR7a1dpZHRofSwgJHtrSGVpZ2h0fSk7XG4gICAgdmFsdWUgKz0gZG90KCR7Z2xzbC50ZXh0dXJlMkR9KEltMkNvbCwgaW0yY29sQ29vcmRzKSwgJHtnbHNsLnRleHR1cmUyRH0oSywga2VybmVsQ29vcmRzKSk7XG4gICAgKytpbTJjb2xPZmZzZXQ7XG4gICAgKytrZXJuZWxPZmZzZXQ7XG4gIH1cbiAgJHthcHBseUFjdGl2YXRpb259XG4gIHJldHVybiB2YWx1ZTtcbn1gO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4ubWV0YWRhdGEsXG4gICAgICAgIG91dHB1dDoge2RpbXM6IG91dHB1dFNoYXBlLCB0eXBlOiBpbnB1dHNbMF0udHlwZSwgdGV4dHVyZVR5cGU6IFRleHR1cmVUeXBlLnVucGFja2VkfSxcbiAgICAgICAgc2hhZGVyU291cmNlXG4gICAgICB9O1xuICAgIH07XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVEb3RQcm9kdWN0UHJvZ3JhbUluZm9Mb2FkZXIgPVxuICAgIChpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogcmVhZG9ubHkgVGVuc29yW10sIG91dHB1dFNoYXBlOiBudW1iZXJbXSxcbiAgICAgYXR0cmlidXRlczogSW50ZXJuYWxBY3RpdmF0aW9uQXR0cmlidXRlcyk6IFByb2dyYW1JbmZvTG9hZGVyID0+IHtcbiAgICAgIGNvbnN0IG1ldGFkYXRhID0gY3JlYXRlRG90UHJvZHVjdFByb2dyYW1NZXRhZGF0YShpbnB1dHMubGVuZ3RoID4gMiwgYXR0cmlidXRlcyk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5tZXRhZGF0YSxcbiAgICAgICAgZ2V0OiAoKSA9PiBjcmVhdGVEb3RQcm9kdWN0UHJvZ3JhbUluZm8oaW5mZXJlbmNlSGFuZGxlciwgbWV0YWRhdGEsIGlucHV0cywgb3V0cHV0U2hhcGUsIGF0dHJpYnV0ZXMpXG4gICAgICB9O1xuICAgIH07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7QXR0cmlidXRlV2l0aENhY2hlS2V5LCBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXl9IGZyb20gJy4uLy4uLy4uL2F0dHJpYnV0ZS13aXRoLWNhY2hlLWtleSc7XG5pbXBvcnQge0luZmVyZW5jZUhhbmRsZXJ9IGZyb20gJy4uLy4uLy4uL2JhY2tlbmQnO1xuaW1wb3J0IHtHcmFwaH0gZnJvbSAnLi4vLi4vLi4vZ3JhcGgnO1xuaW1wb3J0IHtPcGVyYXRvckltcGxlbWVudGF0aW9uLCBPcGVyYXRvckluaXRpYWxpemF0aW9ufSBmcm9tICcuLi8uLi8uLi9vcGVyYXRvcnMnO1xuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4uLy4uLy4uL3RlbnNvcic7XG5pbXBvcnQge1Bvb2xDb252VXRpbH0gZnJvbSAnLi4vLi4vLi4vdXRpbCc7XG5pbXBvcnQge1dlYkdMSW5mZXJlbmNlSGFuZGxlcn0gZnJvbSAnLi4vaW5mZXJlbmNlLWhhbmRsZXInO1xuXG5pbXBvcnQge2NyZWF0ZVVucGFja2VkR3JvdXBlZENvbnZQcm9ncmFtSW5mb0xvYWRlcn0gZnJvbSAnLi9jb252LWdyb3VwZWQnO1xuaW1wb3J0IHtjb252MkRQYWNrZWR9IGZyb20gJy4vY29udi1wYWNrJztcbmltcG9ydCB7Y3JlYXRlRG90UHJvZHVjdFByb2dyYW1JbmZvTG9hZGVyfSBmcm9tICcuL2RvdC1wcm9kdWN0JztcbmltcG9ydCB7SW50ZXJuYWxBY3RpdmF0aW9uQXR0cmlidXRlcywgcGFyc2VJbnRlcm5hbEFjdGl2YXRpb25BdHRyaWJ1dGVzfSBmcm9tICcuL2Z1c2UtdXRpbHMnO1xuaW1wb3J0IHtjcmVhdGVJbTJDb2xQcm9ncmFtSW5mb0xvYWRlcn0gZnJvbSAnLi9pbTJjb2wnO1xuaW1wb3J0IHtjcmVhdGVNYXRtdWxQcm9ncmFtSW5mb0xvYWRlcn0gZnJvbSAnLi9tYXRtdWwnO1xuXG5cbmV4cG9ydCBjb25zdCBjYWxjdWxhdGVPdXRwdXRTaGFwZSA9XG4gICAgKGlucHV0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLCBrZXJuZWxTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sIGRpbGF0aW9uczogcmVhZG9ubHkgbnVtYmVyW10sXG4gICAgIGFkanVzdFBhZHM6IHJlYWRvbmx5IG51bWJlcltdLCBzdHJpZGVzOiByZWFkb25seSBudW1iZXJbXSk6IG51bWJlcltdID0+IHtcbiAgICAgIGNvbnN0IGJhdGNoU2l6ZSA9IGlucHV0U2hhcGVbMF07XG4gICAgICBjb25zdCBpbnB1dFNwYXRpYWxTaGFwZSA9IGlucHV0U2hhcGUuc2xpY2UoMik7XG4gICAgICBjb25zdCBzcGF0aWFsUmFuayA9IGlucHV0U3BhdGlhbFNoYXBlLmxlbmd0aDtcbiAgICAgIGNvbnN0IG91dENoYW5uZWxzID0ga2VybmVsU2hhcGVbMF07XG4gICAgICBjb25zdCBrZXJuZWxTcGF0aWFsU2hhcGUgPSBrZXJuZWxTaGFwZS5zbGljZSgyKTtcbiAgICAgIGNvbnN0IGRpbGF0ZWRLZXJuZWxTaGFwZSA9IGtlcm5lbFNwYXRpYWxTaGFwZS5tYXAoKHYsIGkpID0+IHYgKyAodiAtIDEpICogKGRpbGF0aW9uc1tpXSAtIDEpKTtcbiAgICAgIGNvbnN0IGlucHV0U3BhdGlhbFNoYXBlV2l0aFBhZCA9IGlucHV0U3BhdGlhbFNoYXBlLm1hcCgodiwgaSkgPT4gdiArIGFkanVzdFBhZHNbaV0gKyBhZGp1c3RQYWRzW2kgKyBzcGF0aWFsUmFua10pO1xuICAgICAgY29uc3Qgb3V0cHV0U3BhdGlhbFNoYXBlID1cbiAgICAgICAgICBpbnB1dFNwYXRpYWxTaGFwZVdpdGhQYWQubWFwKCh2LCBpKSA9PiBNYXRoLmZsb29yKCh2IC0gZGlsYXRlZEtlcm5lbFNoYXBlW2ldICsgc3RyaWRlc1tpXSkgLyBzdHJpZGVzW2ldKSk7XG4gICAgICBjb25zdCBvdXRwdXRTaGFwZSA9IFtiYXRjaFNpemUsIG91dENoYW5uZWxzXS5jb25jYXQoLi4ub3V0cHV0U3BhdGlhbFNoYXBlKTtcbiAgICAgIHJldHVybiBvdXRwdXRTaGFwZTtcbiAgICB9O1xuXG5leHBvcnQgaW50ZXJmYWNlIENvbnZBdHRyaWJ1dGVzIGV4dGVuZHMgSW50ZXJuYWxBY3RpdmF0aW9uQXR0cmlidXRlcywgQXR0cmlidXRlV2l0aENhY2hlS2V5IHtcbiAgcmVhZG9ubHkgYXV0b1BhZDogc3RyaW5nO1xuICByZWFkb25seSBkaWxhdGlvbnM6IHJlYWRvbmx5IG51bWJlcltdO1xuICByZWFkb25seSBncm91cDogbnVtYmVyO1xuICByZWFkb25seSBrZXJuZWxTaGFwZTogcmVhZG9ubHkgbnVtYmVyW107XG4gIHJlYWRvbmx5IHBhZHM6IHJlYWRvbmx5IG51bWJlcltdO1xuICByZWFkb25seSBzdHJpZGVzOiByZWFkb25seSBudW1iZXJbXTtcbn1cblxuZXhwb3J0IGNvbnN0IGNvbnY6IE9wZXJhdG9ySW1wbGVtZW50YXRpb248Q29udkF0dHJpYnV0ZXM+ID1cbiAgICAoaW5mZXJlbmNlSGFuZGxlcjogSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSwgYXR0cmlidXRlczogQ29udkF0dHJpYnV0ZXMpOiBUZW5zb3JbXSA9PiB7XG4gICAgICB2YWxpZGF0ZUlucHV0cyhpbnB1dHMsIGF0dHJpYnV0ZXMpOyAgLy8gY3VycmVudGx5IHdpbGwgZmFpbCBpZiBub3QgY29udjJEXG4gICAgICByZXR1cm4gY29udjJkKGluZmVyZW5jZUhhbmRsZXIsIGlucHV0cywgYXR0cmlidXRlcyk7XG4gICAgfTtcblxuY29uc3QgY29udjJkOiBPcGVyYXRvckltcGxlbWVudGF0aW9uPENvbnZBdHRyaWJ1dGVzPiA9XG4gICAgKGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSwgYXR0cmlidXRlczogQ29udkF0dHJpYnV0ZXMpOiBUZW5zb3JbXSA9PiB7XG4gICAgICBjb25zdCBhZGp1c3RlZEF0dHJpYnV0ZXMgPSBnZXRBZGp1c3RlZENvbnZBdHRyaWJ1dGVzKGF0dHJpYnV0ZXMsIGlucHV0cyk7XG4gICAgICBjb25zdCBwYWNrTW9kZSA9IGluZmVyZW5jZUhhbmRsZXIuc2Vzc2lvbi5wYWNrO1xuICAgICAgY29uc3QgaXNQb2ludHdpc2UgPSBhZGp1c3RlZEF0dHJpYnV0ZXMua2VybmVsU2hhcGVbMF0gPT09IDEgJiYgYWRqdXN0ZWRBdHRyaWJ1dGVzLmtlcm5lbFNoYXBlWzFdID09PSAxO1xuICAgICAgaWYgKGFkanVzdGVkQXR0cmlidXRlcy5ncm91cCA+IDEpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gaW5mZXJlbmNlSGFuZGxlci5ydW4oXG4gICAgICAgICAgICBjcmVhdGVVbnBhY2tlZEdyb3VwZWRDb252UHJvZ3JhbUluZm9Mb2FkZXIoaW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzLCBhZGp1c3RlZEF0dHJpYnV0ZXMpLCBpbnB1dHMpO1xuICAgICAgICByZXR1cm4gW3Jlc3VsdF07XG4gICAgICB9IGVsc2UgaWYgKGlzUG9pbnR3aXNlICYmIHBhY2tNb2RlKSB7XG4gICAgICAgIHJldHVybiBbY29udjJEVW5wYWNrZWRQb2ludHdpc2UoaW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzLCBhZGp1c3RlZEF0dHJpYnV0ZXMpXTtcbiAgICAgIH0gZWxzZSBpZiAocGFja01vZGUgJiYgaW5wdXRzWzBdLmRpbXMubGVuZ3RoID09PSA0ICYmIGlucHV0c1swXS5kaW1zWzBdID09PSAxICYmICFpc1BvaW50d2lzZSkge1xuICAgICAgICByZXR1cm4gW2NvbnYyRFBhY2tlZChpbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHMsIGFkanVzdGVkQXR0cmlidXRlcyldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFtjb252MkRVbnBhY2tlZChpbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHMsIGFkanVzdGVkQXR0cmlidXRlcyldO1xuICAgICAgfVxuICAgIH07XG5cbmNvbnN0IGNvbnYyRFVucGFja2VkUG9pbnR3aXNlID1cbiAgICAoaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IHJlYWRvbmx5IFRlbnNvcltdLCBhdHRyaWJ1dGVzOiBDb252QXR0cmlidXRlcyk6IFRlbnNvciA9PiB7XG4gICAgICBjb25zdCB4c2hhcGUgPSBpbnB1dHNbMF0uZGltcztcbiAgICAgIGNvbnN0IGtzaGFwZSA9IGlucHV0c1sxXS5kaW1zO1xuICAgICAgY29uc3Qgb3V0cHV0U2hhcGUgPVxuICAgICAgICAgIGNhbGN1bGF0ZU91dHB1dFNoYXBlKHhzaGFwZSwga3NoYXBlLCBhdHRyaWJ1dGVzLmRpbGF0aW9ucywgYXR0cmlidXRlcy5wYWRzLCBhdHRyaWJ1dGVzLnN0cmlkZXMpO1xuICAgICAgY29uc3QgcmVzaGFwZWRYID0gaW5mZXJlbmNlSGFuZGxlci5yZXNoYXBlVW5wYWNrZWQoaW5wdXRzWzBdLCBbeHNoYXBlWzFdLCB4c2hhcGVbMl0gKiB4c2hhcGVbM11dKTtcbiAgICAgIGNvbnN0IHJlc2hhcGVkSyA9IGluZmVyZW5jZUhhbmRsZXIucmVzaGFwZVVucGFja2VkKGlucHV0c1sxXSwgW2tzaGFwZVswXSwga3NoYXBlWzFdXSk7XG5cbiAgICAgIGNvbnN0IG1hdG11bElucHV0cyA9IGlucHV0cy5sZW5ndGggPiAyID8gW3Jlc2hhcGVkSywgcmVzaGFwZWRYLCBpbnB1dHNbMl1dIDogW3Jlc2hhcGVkSywgcmVzaGFwZWRYXTtcbiAgICAgIGNvbnN0IG1hdG11bE91dHB1dCA9IGluZmVyZW5jZUhhbmRsZXIucnVuKGNyZWF0ZU1hdG11bFByb2dyYW1JbmZvTG9hZGVyKG1hdG11bElucHV0cywgYXR0cmlidXRlcyksIG1hdG11bElucHV0cyk7XG4gICAgICByZXR1cm4gaW5mZXJlbmNlSGFuZGxlci5yZXNoYXBlVW5wYWNrZWQobWF0bXVsT3V0cHV0LCBvdXRwdXRTaGFwZSk7XG4gICAgfTtcblxuY29uc3QgY29udjJEVW5wYWNrZWQgPVxuICAgIChpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogcmVhZG9ubHkgVGVuc29yW10sIGF0dHJpYnV0ZXM6IENvbnZBdHRyaWJ1dGVzKTogVGVuc29yID0+IHtcbiAgICAgIGNvbnN0IHhzaGFwZSA9IGlucHV0c1swXS5kaW1zO1xuICAgICAgY29uc3Qga3NoYXBlID0gaW5wdXRzWzFdLmRpbXM7XG4gICAgICBjb25zdCBvdXRwdXRTaGFwZSA9XG4gICAgICAgICAgY2FsY3VsYXRlT3V0cHV0U2hhcGUoeHNoYXBlLCBrc2hhcGUsIGF0dHJpYnV0ZXMuZGlsYXRpb25zLCBhdHRyaWJ1dGVzLnBhZHMsIGF0dHJpYnV0ZXMuc3RyaWRlcyk7XG4gICAgICBjb25zdCB4SW0yQ29sID0gaW5mZXJlbmNlSGFuZGxlci5ydW4oXG4gICAgICAgICAgY3JlYXRlSW0yQ29sUHJvZ3JhbUluZm9Mb2FkZXIoaW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzWzBdLCBpbnB1dHNbMV0sIG91dHB1dFNoYXBlLCBhdHRyaWJ1dGVzKSwgW2lucHV0c1swXV0pO1xuXG4gICAgICBjb25zdCBkb3RQcm9kdWN0SW5wdXRzID0gaW5wdXRzLmxlbmd0aCA9PT0gMyA/IFt4SW0yQ29sLCBpbnB1dHNbMV0sIGlucHV0c1syXV0gOiBbeEltMkNvbCwgaW5wdXRzWzFdXTtcbiAgICAgIGNvbnN0IG91dHB1dCA9IGluZmVyZW5jZUhhbmRsZXIucnVuKFxuICAgICAgICAgIGNyZWF0ZURvdFByb2R1Y3RQcm9ncmFtSW5mb0xvYWRlcihpbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHMsIG91dHB1dFNoYXBlLCBhdHRyaWJ1dGVzKSwgZG90UHJvZHVjdElucHV0cyk7XG4gICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH07XG5cbmNvbnN0IGdldEFkanVzdGVkQ29udkF0dHJpYnV0ZXMgPSA8VCBleHRlbmRzIENvbnZBdHRyaWJ1dGVzPihhdHRyaWJ1dGVzOiBULCBpbnB1dHM6IFRlbnNvcltdKTogVCA9PiB7XG4gIGNvbnN0IGtlcm5lbFNoYXBlID0gYXR0cmlidXRlcy5rZXJuZWxTaGFwZS5zbGljZSgpO1xuICAvLyBpZiBrZXJuZWxTaGFwZSBpcyBub3Qgc3BlY2lmaWVkIGluIHRoZSBhdHRyaWJ1dGVzIG9mIHRoaXMgb3AsIGluZmVyIGl0IGZyb20gdGhlIHdlaWdodCB0ZW5zb3IgZGltc1xuICBpZiAoYXR0cmlidXRlcy5rZXJuZWxTaGFwZS5sZW5ndGggPT09IDApIHtcbiAgICBmb3IgKGxldCBpID0gMjsgaSA8IGlucHV0c1sxXS5kaW1zLmxlbmd0aDsgKytpKSB7XG4gICAgICBrZXJuZWxTaGFwZS5wdXNoKGlucHV0c1sxXS5kaW1zW2ldKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgcGFkcyA9IGF0dHJpYnV0ZXMucGFkcy5zbGljZSgpO1xuICBQb29sQ29udlV0aWwuYWRqdXN0UGFkc0Jhc2VkT25BdXRvUGFkKFxuICAgICAgaW5wdXRzWzBdLmRpbXMsIGF0dHJpYnV0ZXMuc3RyaWRlcywgYXR0cmlidXRlcy5kaWxhdGlvbnMsIGtlcm5lbFNoYXBlLCBwYWRzLCBhdHRyaWJ1dGVzLmF1dG9QYWQpO1xuXG4gIC8vIGFsd2F5cyByZXR1cm4gYSBuZXcgb2JqZWN0IHNvIGRvZXMgbm90IG1vZGlmeSB0aGUgb3JpZ2luYWwgYXR0cmlidXRlc1xuICBjb25zdCBuZXdBdHRyaWJ1dGVzOiBUID0gT2JqZWN0LmFzc2lnbih7fSwgYXR0cmlidXRlcyk7XG4gIE9iamVjdC5hc3NpZ24obmV3QXR0cmlidXRlcywge2tlcm5lbFNoYXBlLCBwYWRzLCBjYWNoZUtleTogYXR0cmlidXRlcy5jYWNoZUtleX0pO1xuICByZXR1cm4gbmV3QXR0cmlidXRlcztcbn07XG5cbmV4cG9ydCBjb25zdCBwYXJzZUNvbnZBdHRyaWJ1dGVzOiBPcGVyYXRvckluaXRpYWxpemF0aW9uPENvbnZBdHRyaWJ1dGVzPiA9IChub2RlOiBHcmFwaC5Ob2RlKTogQ29udkF0dHJpYnV0ZXMgPT4ge1xuICBjb25zdCBhdHRyaWJ1dGVzID0gbm9kZS5hdHRyaWJ1dGVzO1xuICBjb25zdCBhY3RpdmF0aW9uQXR0cmlidXRlcyA9IHBhcnNlSW50ZXJuYWxBY3RpdmF0aW9uQXR0cmlidXRlcyhhdHRyaWJ1dGVzKTtcbiAgLy8gVE9ETyA6IE1ha2UgdGhpcyBnZW5lcmljIGVub3VnaCB0byBjb21wdXRlIGRlZmF1bHQgYXR0cmlidXRlcyBmb3IgbXVsdGktZGltZW5zaW9uYWwgY29udlxuICBjb25zdCBhdXRvUGFkID0gYXR0cmlidXRlcy5nZXRTdHJpbmcoJ2F1dG9fcGFkJywgJ05PVFNFVCcpO1xuICBjb25zdCBkaWxhdGlvbnMgPSBhdHRyaWJ1dGVzLmdldEludHMoJ2RpbGF0aW9ucycsIFsxLCAxXSk7XG4gIGNvbnN0IGdyb3VwID0gYXR0cmlidXRlcy5nZXRJbnQoJ2dyb3VwJywgMSk7XG4gIGNvbnN0IGtlcm5lbFNoYXBlID0gYXR0cmlidXRlcy5nZXRJbnRzKCdrZXJuZWxfc2hhcGUnLCBbXSk7XG4gIGNvbnN0IHBhZHMgPSBhdHRyaWJ1dGVzLmdldEludHMoJ3BhZHMnLCBbMCwgMCwgMCwgMF0pO1xuICBjb25zdCBzdHJpZGVzID0gYXR0cmlidXRlcy5nZXRJbnRzKCdzdHJpZGVzJywgWzEsIDFdKTtcblxuICByZXR1cm4gY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KHthdXRvUGFkLCBkaWxhdGlvbnMsIGdyb3VwLCBrZXJuZWxTaGFwZSwgcGFkcywgc3RyaWRlcywgLi4uYWN0aXZhdGlvbkF0dHJpYnV0ZXN9KTtcbn07XG5cbmNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogVGVuc29yW10sIGF0dHJpYnV0ZXM6IENvbnZBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIC8vIFJlZmVyIHRvIHRoZSBiZWxvdyBsaW5rIGZvciBhbGwgaW5wdXQgY2hlY2tzXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9vbm54L29ubngvYmxvYi9tYWluL2RvY3MvT3BlcmF0b3JzLm1kI0NvbnZcbiAgaWYgKCFpbnB1dHMgfHwgKGlucHV0cy5sZW5ndGggIT09IDIgJiYgaW5wdXRzLmxlbmd0aCAhPT0gMykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbnYgcmVxdWlyZXMgMiBvciAzIGlucHV0cycpO1xuICB9XG5cbiAgLy8gVE9ETyA6IE5lZWQgdG8gYWRkIHN1cHBvcnQgZm9yIG11bHRpLWRpbWVuc2lvbmFsIGNvbnZcbiAgaWYgKGlucHV0c1swXS5kaW1zLmxlbmd0aCAhPT0gNCB8fCBpbnB1dHNbMV0uZGltcy5sZW5ndGggIT09IDQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2N1cnJlbnRseSBvbmx5IHN1cHBvcnQgMi1kaW1lbnNpb25hbCBjb252Jyk7XG4gIH1cblxuICAvLyBGSUxURVJfSU5fQ0hBTk5FTCBzaG91bGQgYmUgZXF1YWwgdG8gREFUQV9DSEFOTkVMXG4gIGNvbnN0IGRhdGFDaGFubmVsID0gaW5wdXRzWzBdLmRpbXNbMV07XG4gIGNvbnN0IGZpbHRlckluQ2hhbm5lbCA9IGlucHV0c1sxXS5kaW1zWzFdICogYXR0cmlidXRlcy5ncm91cDtcbiAgaWYgKGRhdGFDaGFubmVsICE9PSBmaWx0ZXJJbkNoYW5uZWwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZJTFRFUl9JTl9DSEFOTkVMIHNob3VsZCBiZSBlcXVhbCB0byBEQVRBX0NIQU5ORUwnKTtcbiAgfVxuXG4gIC8vIGlmIGJpYXMgaXMgcHJvdmlkZWQgaXQgc2hvdWxkIGJlIDFEIGFuZCB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIHNob3VsZCBiZSBlcXVhbCB0byB0aGUgbnVtYmVyIG9mIGZlYXR1cmUgbWFwc1xuICBpZiAoaW5wdXRzLmxlbmd0aCA9PT0gMyAmJiAoaW5wdXRzWzJdLmRpbXMubGVuZ3RoICE9PSAxIHx8IGlucHV0c1sxXS5kaW1zWzBdICE9PSBpbnB1dHNbMl0uZGltc1swXSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYmlhcycpO1xuICB9XG5cbiAgY29uc3Qgc3BhdGlhbFJhbmsgPSBpbnB1dHNbMF0uZGltcy5sZW5ndGggLSAyO1xuICAvLyB3cm9uZyBkaWxhdGlvbnMgZGltZW5zaW9uXG4gIGlmIChhdHRyaWJ1dGVzLmRpbGF0aW9ucy5sZW5ndGggIT09IHNwYXRpYWxSYW5rKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBkaWxhdGlvbnMgc2hvdWxkIGJlICR7c3BhdGlhbFJhbmt9RGApO1xuICB9XG5cbiAgLy8gV3Jvbmcgc3RyaWRlcyBkaW1lbnNpb25cbiAgaWYgKGF0dHJpYnV0ZXMuc3RyaWRlcy5sZW5ndGggIT09IHNwYXRpYWxSYW5rKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBzdHJpZGVzIHNob3VsZCBiZSAke3NwYXRpYWxSYW5rfURgKTtcbiAgfVxuXG4gIC8vIFdyb25nIHBhZHMgZGltZW5zaW9uXG4gIGlmIChhdHRyaWJ1dGVzLnBhZHMubGVuZ3RoICE9PSBzcGF0aWFsUmFuayAqIDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYHBhZHMgc2hvdWxkIGJlICR7c3BhdGlhbFJhbmsgKiAyfURgKTtcbiAgfVxuXG4gIC8vIGlmIGtlcm5lbFNoYXBlIGlzIHNwZWNpZmllZCwgaXQncyBkYXRhIGxlbmd0aCBtdXN0IGJlIDIgbGVzcyB0aGFuIGRpbXMgbGVuZ3RoIG9mIHRoZSB3ZWlnaHRzIHRlbnNvclxuICAvLyAodGhlIGZpcnN0IDIgZGltcyBhcmUgYmF0Y2hfc2l6ZSBhbmQgY2hhbm5lbHMpXG4gIGlmIChhdHRyaWJ1dGVzLmtlcm5lbFNoYXBlLmxlbmd0aCAhPT0gMCAmJiBhdHRyaWJ1dGVzLmtlcm5lbFNoYXBlLmxlbmd0aCAhPT0gaW5wdXRzWzFdLmRpbXMubGVuZ3RoIC0gMikge1xuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBrZXJuZWwgc2hhcGUnKTtcbiAgfVxuXG4gIC8vIFRPRE8gOiBOZWVkIHRvIGFkZCBzdXBwb3J0IGZvciBmbG9hdDY0XG4gIGlmIChpbnB1dHNbMF0udHlwZSAhPT0gJ2Zsb2F0MzInIHx8IGlucHV0c1sxXS50eXBlICE9PSAnZmxvYXQzMicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbnYgaW5wdXQoWCxXKSBzaG91bGQgYmUgZmxvYXQgdGVuc29yJyk7XG4gIH1cblxuICBpZiAoaW5wdXRzLmxlbmd0aCA9PT0gMyAmJiBpbnB1dHNbMl0udHlwZSAhPT0gJ2Zsb2F0MzInKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDb252IGlucHV0KGJpYXMpIHNob3VsZCBiZSBmbG9hdCB0ZW5zb3InKTtcbiAgfVxufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXl9IGZyb20gJy4uLy4uLy4uL2F0dHJpYnV0ZS13aXRoLWNhY2hlLWtleSc7XG5pbXBvcnQge0luZmVyZW5jZUhhbmRsZXJ9IGZyb20gJy4uLy4uLy4uL2JhY2tlbmQnO1xuaW1wb3J0IHtHcmFwaH0gZnJvbSAnLi4vLi4vLi4vZ3JhcGgnO1xuaW1wb3J0IHtPcGVyYXRvckltcGxlbWVudGF0aW9uLCBPcGVyYXRvckluaXRpYWxpemF0aW9ufSBmcm9tICcuLi8uLi8uLi9vcGVyYXRvcnMnO1xuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4uLy4uLy4uL3RlbnNvcic7XG5pbXBvcnQge2dldEdsc2x9IGZyb20gJy4uL2dsc2wtc291cmNlJztcbmltcG9ydCB7V2ViR0xJbmZlcmVuY2VIYW5kbGVyfSBmcm9tICcuLi9pbmZlcmVuY2UtaGFuZGxlcic7XG5pbXBvcnQge1Byb2dyYW1JbmZvLCBQcm9ncmFtSW5mb0xvYWRlciwgUHJvZ3JhbU1ldGFkYXRhLCBUZXh0dXJlVHlwZX0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQge0NvbnZBdHRyaWJ1dGVzfSBmcm9tICcuL2NvbnYnO1xuaW1wb3J0IHtnZXRBY3RpdmF0aW9uU25pcHBldCwgcGFyc2VJbnRlcm5hbEFjdGl2YXRpb25BdHRyaWJ1dGVzfSBmcm9tICcuL2Z1c2UtdXRpbHMnO1xuXG5jb25zdCBjb21wdXRlVG90YWxQYWQgPVxuICAgIChpbkRpbTogbnVtYmVyLCBzdHJpZGU6IG51bWJlciwgYWRqOiBudW1iZXIsIGtlcm5lbDogbnVtYmVyLCBkaWxhdGlvbjogbnVtYmVyLCBvdXRTaXplOiBudW1iZXIpID0+XG4gICAgICAgIChpbkRpbSAtIDEpICogc3RyaWRlICsgYWRqICsgKGtlcm5lbCAtIDEpICogZGlsYXRpb24gKyAxIC0gb3V0U2l6ZTtcblxuY29uc3QgZGlzdHJpYnV0ZVBhZGRpbmcgPSAodG90YWxQYWQ6IG51bWJlciwgYXV0b1BhZDogc3RyaW5nLCBwYWRzOiBudW1iZXJbXSwgaGVhZDogbnVtYmVyLCB0YWlsOiBudW1iZXIpID0+IHtcbiAgY29uc3Qgc21hbGxQYWQgPSBNYXRoLmZsb29yKHRvdGFsUGFkIC8gMik7XG4gIGlmIChhdXRvUGFkID09PSAnU0FNRV9VUFBFUicpIHtcbiAgICBwYWRzW2hlYWRdID0gc21hbGxQYWQ7XG4gICAgcGFkc1t0YWlsXSA9IHRvdGFsUGFkIC0gc21hbGxQYWQ7XG4gIH0gZWxzZSBpZiAoYXV0b1BhZCA9PT0gJ1NBTUVfTE9XRVInKSB7XG4gICAgcGFkc1toZWFkXSA9IHRvdGFsUGFkIC0gc21hbGxQYWQ7XG4gICAgcGFkc1t0YWlsXSA9IHNtYWxsUGFkO1xuICB9XG59O1xuXG5jb25zdCBjYWxjdWxhdGVPdXRwdXRTaGFwZUFuZFBhZHMgPVxuICAgIChpbnB1dFNoYXBlOiByZWFkb25seSBudW1iZXJbXSwga2VybmVsU2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLCBkaWxhdGlvbnM6IHJlYWRvbmx5IG51bWJlcltdLCBhdXRvUGFkOiBzdHJpbmcsXG4gICAgIHBhZHM6IG51bWJlcltdLCBzdHJpZGVzOiByZWFkb25seSBudW1iZXJbXSwgb3V0cHV0UGFkZGluZzogcmVhZG9ubHkgbnVtYmVyW10sIG91dHB1dFNoYXBlOiBudW1iZXJbXSkgPT4ge1xuICAgICAgY29uc3Qgc3BhdGlhbFJhbmsgPSBpbnB1dFNoYXBlLmxlbmd0aCAtIDI7XG4gICAgICBjb25zdCB1cGRhdGVTaGFwZSA9IG91dHB1dFNoYXBlLmxlbmd0aCA9PT0gMDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3BhdGlhbFJhbms7ICsraSkge1xuICAgICAgICBjb25zdCBvdXRTaXplID0gdXBkYXRlU2hhcGUgPyBpbnB1dFNoYXBlW2kgKyAyXSAqIHN0cmlkZXNbaV0gOiBvdXRwdXRTaGFwZVtpXTtcbiAgICAgICAgY29uc3QgdG90YWxQYWQgPSBjb21wdXRlVG90YWxQYWQoaW5wdXRTaGFwZVtpICsgMl0sIHN0cmlkZXNbaV0sIHBhZHNbaV0sIGtlcm5lbFNoYXBlW2ldLCBkaWxhdGlvbnNbaV0sIG91dFNpemUpO1xuICAgICAgICBkaXN0cmlidXRlUGFkZGluZyh0b3RhbFBhZCwgYXV0b1BhZCwgcGFkcywgaSwgaSArIHNwYXRpYWxSYW5rKTtcbiAgICAgICAgaWYgKHVwZGF0ZVNoYXBlKSB7XG4gICAgICAgICAgb3V0cHV0U2hhcGUucHVzaChcbiAgICAgICAgICAgICAgc3RyaWRlc1tpXSAqIChpbnB1dFNoYXBlW2kgKyAyXSAtIDEpICsgb3V0cHV0UGFkZGluZ1tpXSArIChrZXJuZWxTaGFwZVtpXSAtIDEpICogZGlsYXRpb25zW2ldICsgMSAtXG4gICAgICAgICAgICAgIHBhZHNbaV0gLSBwYWRzW2kgKyBzcGF0aWFsUmFua10pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuZXhwb3J0IGludGVyZmFjZSBDb252VHJhbnNwb3NlQXR0cmlidXRlcyBleHRlbmRzIENvbnZBdHRyaWJ1dGVzIHtcbiAgcmVhZG9ubHkgb3V0cHV0UGFkZGluZzogcmVhZG9ubHkgbnVtYmVyW107XG4gIHJlYWRvbmx5IG91dHB1dFNoYXBlOiByZWFkb25seSBudW1iZXJbXTtcbn1cblxuZXhwb3J0IGNvbnN0IGNvbnZUcmFuc3Bvc2U6IE9wZXJhdG9ySW1wbGVtZW50YXRpb248Q29udlRyYW5zcG9zZUF0dHJpYnV0ZXM+ID1cbiAgICAoaW5mZXJlbmNlSGFuZGxlcjogSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSwgYXR0cmlidXRlczogQ29udlRyYW5zcG9zZUF0dHJpYnV0ZXMpOiBUZW5zb3JbXSA9PiB7XG4gICAgICB2YWxpZGF0ZUlucHV0cyhpbnB1dHMsIGF0dHJpYnV0ZXMpOyAgLy8gY3VycmVudGx5IHdpbGwgZmFpbCBpZiBub3QgY29udlRyYW5zcG9zZTJEXG4gICAgICByZXR1cm4gY29udlRyYW5zcG9zZTJkKGluZmVyZW5jZUhhbmRsZXIsIGlucHV0cywgYXR0cmlidXRlcyk7XG4gICAgfTtcblxuY29uc3QgY29udlRyYW5zcG9zZTJkOiBPcGVyYXRvckltcGxlbWVudGF0aW9uPENvbnZUcmFuc3Bvc2VBdHRyaWJ1dGVzPiA9XG4gICAgKGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSwgYXR0cmlidXRlczogQ29udlRyYW5zcG9zZUF0dHJpYnV0ZXMpOiBUZW5zb3JbXSA9PiB7XG4gICAgICBjb25zdCBhZGp1c3RlZEF0dHJpYnV0ZXMgPSBnZXRBZGp1c3RlZENvbnZUcmFuc3Bvc2VBdHRyaWJ1dGVzKGF0dHJpYnV0ZXMsIGlucHV0cyk7XG4gICAgICByZXR1cm4gW2NvbnZUcmFuc3Bvc2UyRFVucGFja2VkKGluZmVyZW5jZUhhbmRsZXIsIGlucHV0cywgYWRqdXN0ZWRBdHRyaWJ1dGVzKV07XG4gICAgfTtcblxuY29uc3QgY3JlYXRlQ29udlRyYW5zcG9zZVByb2dyYW1NZXRhZGF0YSA9IChoYXNCaWFzOiBib29sZWFuLCBjYWNoZUhpbnQ6IHN0cmluZykgPT4gKHtcbiAgbmFtZTogJ0NvbnZUcmFuc3Bvc2UnLFxuICBpbnB1dE5hbWVzOiBoYXNCaWFzID8gWydYJywgJ1cnLCAnQiddIDogWydYJywgJ1cnXSxcbiAgaW5wdXRUeXBlczogaGFzQmlhcyA/IFtUZXh0dXJlVHlwZS51bnBhY2tlZCwgVGV4dHVyZVR5cGUudW5wYWNrZWQsIFRleHR1cmVUeXBlLnVucGFja2VkXSA6XG4gICAgICAgICAgICAgICAgICAgICAgICBbVGV4dHVyZVR5cGUudW5wYWNrZWQsIFRleHR1cmVUeXBlLnVucGFja2VkXSxcbiAgY2FjaGVIaW50XG59KTtcblxuY29uc3QgY3JlYXRlVW5wYWNrZWRDb252VHJhbnNwb3NlUHJvZ3JhbUluZm8gPVxuICAgIChpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogcmVhZG9ubHkgVGVuc29yW10sIG1ldGFkYXRhOiBQcm9ncmFtTWV0YWRhdGEsXG4gICAgIGF0dHJpYnV0ZXM6IENvbnZUcmFuc3Bvc2VBdHRyaWJ1dGVzKTogUHJvZ3JhbUluZm8gPT4ge1xuICAgICAgY29uc3QgaGFzQmlhcyA9IGlucHV0cy5sZW5ndGggPiAyO1xuICAgICAgY29uc3QgdmFsdWVJbml0ID0gaGFzQmlhcyA/ICdnZXRCKG91dHB1dF9jaGFubmVsKScgOiAnMC4wJztcbiAgICAgIGNvbnN0IHhTaGFwZSA9IGlucHV0c1swXS5kaW1zO1xuICAgICAgY29uc3Qgd1NoYXBlID0gaW5wdXRzWzFdLmRpbXM7XG4gICAgICBjb25zdCBvdXRwdXRDaGFubmVsc1Blckdyb3VwID0gd1NoYXBlWzFdO1xuICAgICAgY29uc3QgaW5wdXRDaGFubmVsc1Blckdyb3VwID0gd1NoYXBlWzBdIC8gYXR0cmlidXRlcy5ncm91cDtcbiAgICAgIGNvbnN0IG91dHB1dFNoYXBlID0gW2lucHV0c1swXS5kaW1zWzBdLCBpbnB1dHNbMV0uZGltc1sxXSAqIGF0dHJpYnV0ZXMuZ3JvdXAsIC4uLmF0dHJpYnV0ZXMub3V0cHV0U2hhcGVdO1xuICAgICAgY29uc3QgZ2xzbCA9IGdldEdsc2woaW5mZXJlbmNlSGFuZGxlci5zZXNzaW9uLmJhY2tlbmQuZ2xDb250ZXh0LnZlcnNpb24pO1xuICAgICAgY29uc3Qge2FjdGl2YXRpb25GdW5jdGlvbiwgYXBwbHlBY3RpdmF0aW9ufSA9IGdldEFjdGl2YXRpb25TbmlwcGV0KGF0dHJpYnV0ZXMpO1xuXG4gICAgICBjb25zdCBzaGFkZXJTb3VyY2UgPSBgXG4gIGNvbnN0IGl2ZWMyIHN0cmlkZXMgPSBpdmVjMigke2F0dHJpYnV0ZXMuc3RyaWRlc1swXX0sICR7YXR0cmlidXRlcy5zdHJpZGVzWzFdfSk7XG4gIGNvbnN0IGl2ZWMyIHBhZHMgPSBpdmVjMigke2F0dHJpYnV0ZXMucGFkc1swXX0sICR7YXR0cmlidXRlcy5wYWRzWzFdfSk7XG4gICR7YWN0aXZhdGlvbkZ1bmN0aW9ufVxuICB2b2lkIG1haW4oKSB7XG4gICAgaXZlYzQgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XG4gICAgaW50IGJhdGNoID0gY29vcmRzLng7XG4gICAgaW50IG91dHB1dF9jaGFubmVsID0gY29vcmRzLnk7XG5cbiAgICBpdmVjMiBsb2MgPSBjb29yZHMuencgKyBwYWRzO1xuXG4gICAgaW50IGdyb3VwX2lkID0gb3V0cHV0X2NoYW5uZWwgLyAke291dHB1dENoYW5uZWxzUGVyR3JvdXB9O1xuICAgIGludCB3T3V0Q2hhbm5lbCA9IG91dHB1dF9jaGFubmVsIC0gZ3JvdXBfaWQgKiAke291dHB1dENoYW5uZWxzUGVyR3JvdXB9O1xuXG4gICAgZmxvYXQgdmFsdWUgPSAke3ZhbHVlSW5pdH07XG4gICAgZm9yIChpbnQgaW5DaGFubmVsT2Zmc2V0ID0gMDsgaW5DaGFubmVsT2Zmc2V0IDwgJHtpbnB1dENoYW5uZWxzUGVyR3JvdXB9OyBpbkNoYW5uZWxPZmZzZXQrKykge1xuICAgICAgaW50IGlucHV0X2NoYW5uZWwgPSBncm91cF9pZCAqICR7aW5wdXRDaGFubmVsc1Blckdyb3VwfSArIGluQ2hhbm5lbE9mZnNldDtcbiAgICAgIGZvciAoaW50IHdXT2ZmID0gMDsgd1dPZmYgPCAke3dTaGFwZVsyXX07IHdXT2ZmKyspIHtcbiAgICAgICAgZm9yIChpbnQgd0hPZmYgPSAwOyB3SE9mZiA8ICR7d1NoYXBlWzNdfTsgd0hPZmYrKykge1xuICAgICAgICAgIGl2ZWMyIHdPZmYgPSBpdmVjMih3V09mZiAqICR7YXR0cmlidXRlcy5kaWxhdGlvbnNbMF19LCB3SE9mZiAqICR7YXR0cmlidXRlcy5kaWxhdGlvbnNbMV19KTtcbiAgICAgICAgICBpdmVjMiB3TG9jID0gbG9jIC0gd09mZjtcbiAgICAgICAgICBpdmVjMiB3TG9jSW4gPSB3TG9jIC8gc3RyaWRlcztcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICB3TG9jSW4gKiBzdHJpZGVzID09IHdMb2MgJiZcbiAgICAgICAgICAgIHdMb2NJbi54ID49IDAgJiYgd0xvY0luLnggPCAke3hTaGFwZVsyXX0gJiZcbiAgICAgICAgICAgIHdMb2NJbi55ID49IDAgJiYgd0xvY0luLnkgPCAke3hTaGFwZVszXX1cbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGZsb2F0IHhWYWwgPSBnZXRYKGJhdGNoLCBpbnB1dF9jaGFubmVsLCB3TG9jSW4ueSwgd0xvY0luLngpO1xuICAgICAgICAgICAgZmxvYXQgd1ZhbCA9IGdldFcoaW5wdXRfY2hhbm5lbCwgd091dENoYW5uZWwsIHdIT2ZmLCB3V09mZik7XG4gICAgICAgICAgICB2YWx1ZSArPSB4VmFsICogd1ZhbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgJHthcHBseUFjdGl2YXRpb259XG4gICAgJHtnbHNsLm91dHB1dH0gPSB2ZWM0KHZhbHVlLCAuMCwgLjAsIC4wKTtcbiAgfVxuYDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLm1ldGFkYXRhLFxuICAgICAgICBvdXRwdXQ6IHtkaW1zOiBvdXRwdXRTaGFwZSwgdHlwZTogaW5wdXRzWzBdLnR5cGUsIHRleHR1cmVUeXBlOiBUZXh0dXJlVHlwZS51bnBhY2tlZH0sXG4gICAgICAgIHNoYWRlclNvdXJjZSxcbiAgICAgICAgaGFzTWFpbjogdHJ1ZSxcbiAgICAgIH07XG4gICAgfTtcblxuY29uc3QgY3JlYXRlVW5wYWNrZWRDb252VHJhbnNwb3NlUHJvZ3JhbUluZm9Mb2FkZXIgPVxuICAgIChpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogcmVhZG9ubHkgVGVuc29yW10sIGF0dHJpYnV0ZXM6IENvbnZUcmFuc3Bvc2VBdHRyaWJ1dGVzKTpcbiAgICAgICAgUHJvZ3JhbUluZm9Mb2FkZXIgPT4ge1xuICAgICAgICAgIGNvbnN0IG1ldGFkYXRhID0gY3JlYXRlQ29udlRyYW5zcG9zZVByb2dyYW1NZXRhZGF0YShpbnB1dHMubGVuZ3RoID4gMiwgYXR0cmlidXRlcy5jYWNoZUtleSk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLm1ldGFkYXRhLFxuICAgICAgICAgICAgZ2V0OiAoKSA9PiBjcmVhdGVVbnBhY2tlZENvbnZUcmFuc3Bvc2VQcm9ncmFtSW5mbyhpbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHMsIG1ldGFkYXRhLCBhdHRyaWJ1dGVzKVxuICAgICAgICAgIH07XG4gICAgICAgIH07XG5cblxuY29uc3QgY29udlRyYW5zcG9zZTJEVW5wYWNrZWQgPVxuICAgIChpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogcmVhZG9ubHkgVGVuc29yW10sIGF0dHJpYnV0ZXM6IENvbnZUcmFuc3Bvc2VBdHRyaWJ1dGVzKTpcbiAgICAgICAgVGVuc29yID0+IHtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBpbmZlcmVuY2VIYW5kbGVyLnJ1bihcbiAgICAgICAgICAgICAgY3JlYXRlVW5wYWNrZWRDb252VHJhbnNwb3NlUHJvZ3JhbUluZm9Mb2FkZXIoaW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzLCBhdHRyaWJ1dGVzKSwgaW5wdXRzKTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuXG5jb25zdCBnZXRBZGp1c3RlZENvbnZUcmFuc3Bvc2VBdHRyaWJ1dGVzID0gPFQgZXh0ZW5kcyBDb252VHJhbnNwb3NlQXR0cmlidXRlcz4oYXR0cmlidXRlczogVCwgaW5wdXRzOiBUZW5zb3JbXSk6IFQgPT4ge1xuICBjb25zdCBrZXJuZWxTaGFwZSA9IGF0dHJpYnV0ZXMua2VybmVsU2hhcGUuc2xpY2UoKTtcbiAgLy8gaWYga2VybmVsU2hhcGUgaXMgbm90IHNwZWNpZmllZCBpbiB0aGUgYXR0cmlidXRlcyBvZiB0aGlzIG9wLCBpbmZlciBpdCBmcm9tIHRoZSB3ZWlnaHQgdGVuc29yIGRpbXNcbiAgaWYgKGF0dHJpYnV0ZXMua2VybmVsU2hhcGUubGVuZ3RoID09PSAwKSB7XG4gICAgZm9yIChsZXQgaSA9IDI7IGkgPCBpbnB1dHNbMV0uZGltcy5sZW5ndGg7ICsraSkge1xuICAgICAga2VybmVsU2hhcGUucHVzaChpbnB1dHNbMV0uZGltc1tpXSk7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgcGFkcyA9IGF0dHJpYnV0ZXMucGFkcy5zbGljZSgpO1xuICBjb25zdCBvdXRwdXRTaGFwZSA9IGF0dHJpYnV0ZXMub3V0cHV0U2hhcGUuc2xpY2UoKTtcbiAgY29uc3QgaW5wdXRTaGFwZSA9IGlucHV0c1swXS5kaW1zO1xuICAvLyBJZiBvdXRwdXRTaGFwZSBpcyBub3Qgc3BlY2lmaWVkIGluIHRoZSBhdHRyaWJ1dGVzIG9mIHRoaXMgb3AsIGluZmVyIGl0IGZyb20gdGhlIHBhcmFtZXRlcnNcbiAgLy8gU2ltaWxhcmx5LCBhdXRvbWF0aWNhbGx5IGluZmVyIHBhZHMgaWYgbm90IHNwZWNpZmllZFxuICBjYWxjdWxhdGVPdXRwdXRTaGFwZUFuZFBhZHMoXG4gICAgICBpbnB1dFNoYXBlLCBrZXJuZWxTaGFwZSwgYXR0cmlidXRlcy5kaWxhdGlvbnMsIGF0dHJpYnV0ZXMuYXV0b1BhZCwgcGFkcywgYXR0cmlidXRlcy5zdHJpZGVzLFxuICAgICAgYXR0cmlidXRlcy5vdXRwdXRQYWRkaW5nLCBvdXRwdXRTaGFwZSk7XG5cbiAgLy8gYWx3YXlzIHJldHVybiBhIG5ldyBvYmplY3Qgc28gZG9lcyBub3QgbW9kaWZ5IHRoZSBvcmlnaW5hbCBhdHRyaWJ1dGVzXG4gIGNvbnN0IG5ld0F0dHJpYnV0ZXM6IFQgPSBPYmplY3QuYXNzaWduKHt9LCBhdHRyaWJ1dGVzKTtcbiAgT2JqZWN0LmFzc2lnbihuZXdBdHRyaWJ1dGVzLCB7a2VybmVsU2hhcGUsIHBhZHMsIG91dHB1dFNoYXBlLCBjYWNoZUtleTogYXR0cmlidXRlcy5jYWNoZUtleX0pO1xuICByZXR1cm4gbmV3QXR0cmlidXRlcztcbn07XG5cbmV4cG9ydCBjb25zdCBwYXJzZUNvbnZUcmFuc3Bvc2VBdHRyaWJ1dGVzOiBPcGVyYXRvckluaXRpYWxpemF0aW9uPENvbnZUcmFuc3Bvc2VBdHRyaWJ1dGVzPiA9XG4gICAgKG5vZGU6IEdyYXBoLk5vZGUpOiBDb252VHJhbnNwb3NlQXR0cmlidXRlcyA9PiB7XG4gICAgICBjb25zdCBhdHRyaWJ1dGVzID0gbm9kZS5hdHRyaWJ1dGVzO1xuICAgICAgY29uc3QgYWN0aXZhdGlvbkF0dHJpYnV0ZXMgPSBwYXJzZUludGVybmFsQWN0aXZhdGlvbkF0dHJpYnV0ZXMoYXR0cmlidXRlcyk7XG4gICAgICAvLyBUT0RPIDogTWFrZSB0aGlzIGdlbmVyaWMgZW5vdWdoIHRvIGNvbXB1dGUgZGVmYXVsdCBhdHRyaWJ1dGVzIGZvciBtdWx0aS1kaW1lbnNpb25hbCBjb252XG4gICAgICBjb25zdCBhdXRvUGFkID0gYXR0cmlidXRlcy5nZXRTdHJpbmcoJ2F1dG9fcGFkJywgJ05PVFNFVCcpO1xuICAgICAgY29uc3QgZGlsYXRpb25zID0gYXR0cmlidXRlcy5nZXRJbnRzKCdkaWxhdGlvbnMnLCBbMSwgMV0pO1xuICAgICAgY29uc3QgZ3JvdXAgPSBhdHRyaWJ1dGVzLmdldEludCgnZ3JvdXAnLCAxKTtcbiAgICAgIGNvbnN0IGtlcm5lbFNoYXBlID0gYXR0cmlidXRlcy5nZXRJbnRzKCdrZXJuZWxfc2hhcGUnLCBbXSk7XG4gICAgICBjb25zdCBvdXRwdXRQYWRkaW5nID0gYXR0cmlidXRlcy5nZXRJbnRzKCdvdXRwdXRfcGFkZGluZycsIFswLCAwXSk7XG4gICAgICBjb25zdCBvdXRwdXRTaGFwZSA9IGF0dHJpYnV0ZXMuZ2V0SW50cygnb3V0cHV0X3NoYXBlJywgW10pO1xuICAgICAgY29uc3QgcGFkcyA9IGF0dHJpYnV0ZXMuZ2V0SW50cygncGFkcycsIFswLCAwLCAwLCAwXSk7XG4gICAgICBjb25zdCBzdHJpZGVzID0gYXR0cmlidXRlcy5nZXRJbnRzKCdzdHJpZGVzJywgWzEsIDFdKTtcblxuICAgICAgcmV0dXJuIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleShcbiAgICAgICAgICB7YXV0b1BhZCwgZGlsYXRpb25zLCBncm91cCwga2VybmVsU2hhcGUsIG91dHB1dFBhZGRpbmcsIG91dHB1dFNoYXBlLCBwYWRzLCBzdHJpZGVzLCAuLi5hY3RpdmF0aW9uQXR0cmlidXRlc30pO1xuICAgIH07XG5cbmNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogVGVuc29yW10sIGF0dHJpYnV0ZXM6IENvbnZUcmFuc3Bvc2VBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIC8vIFJlZmVyIHRvIHRoZSBiZWxvdyBsaW5rIGZvciBhbGwgaW5wdXQgY2hlY2tzXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9vbm54L29ubngvYmxvYi9tYWluL2RvY3MvT3BlcmF0b3JzLm1kI0NvbnZcbiAgaWYgKCFpbnB1dHMgfHwgKGlucHV0cy5sZW5ndGggIT09IDIgJiYgaW5wdXRzLmxlbmd0aCAhPT0gMykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbnYgcmVxdWlyZXMgMiBvciAzIGlucHV0cycpO1xuICB9XG5cbiAgLy8gVE9ETyA6IE5lZWQgdG8gYWRkIHN1cHBvcnQgZm9yIG11bHRpLWRpbWVuc2lvbmFsIGNvbnZcbiAgaWYgKGlucHV0c1swXS5kaW1zLmxlbmd0aCAhPT0gNCB8fCBpbnB1dHNbMV0uZGltcy5sZW5ndGggIT09IDQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2N1cnJlbnRseSBvbmx5IHN1cHBvcnQgMi1kaW1lbnNpb25hbCBjb252Jyk7XG4gIH1cblxuICAvLyBGSUxURVJfSU5fQ0hBTk5FTCBzaG91bGQgYmUgZXF1YWwgdG8gREFUQV9DSEFOTkVMXG4gIGNvbnN0IGRhdGFDaGFubmVsID0gaW5wdXRzWzBdLmRpbXNbMV07XG4gIGNvbnN0IGZpbHRlckluQ2hhbm5lbCA9IGlucHV0c1sxXS5kaW1zWzBdO1xuICBpZiAoZGF0YUNoYW5uZWwgIT09IGZpbHRlckluQ2hhbm5lbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignRklMVEVSX0lOX0NIQU5ORUwgc2hvdWxkIGJlIGVxdWFsIHRvIERBVEFfQ0hBTk5FTCcpO1xuICB9XG5cbiAgY29uc3QgZmVhdHVyZU1hcHMgPSBpbnB1dHNbMV0uZGltc1sxXSAqIGF0dHJpYnV0ZXMuZ3JvdXA7XG5cbiAgLy8gaWYgYmlhcyBpcyBwcm92aWRlZCBpdCBzaG91bGQgYmUgMUQgYW5kIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgc2hvdWxkIGJlIGVxdWFsIHRvIHRoZSBudW1iZXIgb2YgZmVhdHVyZSBtYXBzXG4gIGlmIChpbnB1dHMubGVuZ3RoID09PSAzICYmIChpbnB1dHNbMl0uZGltcy5sZW5ndGggIT09IDEgfHwgaW5wdXRzWzJdLmRpbXNbMF0gIT09IGZlYXR1cmVNYXBzKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBiaWFzJyk7XG4gIH1cblxuICBjb25zdCBzcGF0aWFsUmFuayA9IGlucHV0c1swXS5kaW1zLmxlbmd0aCAtIDI7XG4gIC8vIHdyb25nIGRpbGF0aW9ucyBkaW1lbnNpb25cbiAgaWYgKGF0dHJpYnV0ZXMuZGlsYXRpb25zLmxlbmd0aCAhPT0gc3BhdGlhbFJhbmspIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGRpbGF0aW9ucyBzaG91bGQgYmUgJHtzcGF0aWFsUmFua31EYCk7XG4gIH1cblxuICAvLyBXcm9uZyBzdHJpZGVzIGRpbWVuc2lvblxuICBpZiAoYXR0cmlidXRlcy5zdHJpZGVzLmxlbmd0aCAhPT0gc3BhdGlhbFJhbmspIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYHN0cmlkZXMgc2hvdWxkIGJlICR7c3BhdGlhbFJhbmt9RGApO1xuICB9XG5cbiAgLy8gV3JvbmcgcGFkcyBkaW1lbnNpb25cbiAgaWYgKGF0dHJpYnV0ZXMucGFkcy5sZW5ndGggIT09IHNwYXRpYWxSYW5rICogMikge1xuICAgIHRocm93IG5ldyBFcnJvcihgcGFkcyBzaG91bGQgYmUgJHtzcGF0aWFsUmFuayAqIDJ9RGApO1xuICB9XG5cbiAgLy8gV3Jvbmcgb3V0cHV0IHBhZGRpbmcgZGltZW5zaW9uXG4gIGlmIChhdHRyaWJ1dGVzLm91dHB1dFBhZGRpbmcubGVuZ3RoICE9PSBzcGF0aWFsUmFuaykge1xuICAgIHRocm93IG5ldyBFcnJvcihgb3V0cHV0X3BhZGRpbmcgc2hvdWxkIGJlICR7c3BhdGlhbFJhbmt9RGApO1xuICB9XG5cbiAgLy8gaWYga2VybmVsU2hhcGUgaXMgc3BlY2lmaWVkLCBpdCdzIGRhdGEgbGVuZ3RoIG11c3QgYmUgMiBsZXNzIHRoYW4gZGltcyBsZW5ndGggb2YgdGhlIHdlaWdodHMgdGVuc29yXG4gIC8vICh0aGUgZmlyc3QgMiBkaW1zIGFyZSBiYXRjaF9zaXplIGFuZCBjaGFubmVscylcbiAgaWYgKGF0dHJpYnV0ZXMua2VybmVsU2hhcGUubGVuZ3RoICE9PSAwICYmIGF0dHJpYnV0ZXMua2VybmVsU2hhcGUubGVuZ3RoICE9PSBpbnB1dHNbMV0uZGltcy5sZW5ndGggLSAyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGtlcm5lbCBzaGFwZScpO1xuICB9XG5cbiAgLy8gYXMgd2l0aCBrZXJuZWxTaGFwZSwgbXVzdCBoYXZlIHNhbWUgbnVtYmVyIG9mIHNwYXRpYWwgZGltcyBhcyBpbnB1dFxuICBpZiAoYXR0cmlidXRlcy5vdXRwdXRTaGFwZS5sZW5ndGggIT09IDAgJiYgYXR0cmlidXRlcy5vdXRwdXRTaGFwZS5sZW5ndGggIT09IGlucHV0c1swXS5kaW1zLmxlbmd0aCAtIDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgb3V0cHV0IHNoYXBlJyk7XG4gIH1cblxuICAvLyBUT0RPIDogTmVlZCB0byBhZGQgc3VwcG9ydCBmb3IgZmxvYXQ2NFxuICBpZiAoaW5wdXRzWzBdLnR5cGUgIT09ICdmbG9hdDMyJyB8fCBpbnB1dHNbMV0udHlwZSAhPT0gJ2Zsb2F0MzInKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDb252VHJhbnNwb3NlIGlucHV0KFgsVykgc2hvdWxkIGJlIGZsb2F0IHRlbnNvcicpO1xuICB9XG5cbiAgaWYgKGlucHV0cy5sZW5ndGggPT09IDMgJiYgaW5wdXRzWzJdLnR5cGUgIT09ICdmbG9hdDMyJykge1xuICAgIHRocm93IG5ldyBFcnJvcignQ29udlRyYW5zcG9zZSBpbnB1dChiaWFzKSBzaG91bGQgYmUgZmxvYXQgdGVuc29yJyk7XG4gIH1cbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7QXR0cmlidXRlV2l0aENhY2hlS2V5LCBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXl9IGZyb20gJy4uLy4uLy4uL2F0dHJpYnV0ZS13aXRoLWNhY2hlLWtleSc7XG5pbXBvcnQge0dyYXBofSBmcm9tICcuLi8uLi8uLi9ncmFwaCc7XG5pbXBvcnQge09wZXJhdG9ySW1wbGVtZW50YXRpb24sIE9wZXJhdG9ySW5pdGlhbGl6YXRpb259IGZyb20gJy4uLy4uLy4uL29wZXJhdG9ycyc7XG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi4vLi4vLi4vdGVuc29yJztcbmltcG9ydCB7U2hhcGVVdGlsfSBmcm9tICcuLi8uLi8uLi91dGlsJztcbmltcG9ydCB7V2ViR0xJbmZlcmVuY2VIYW5kbGVyfSBmcm9tICcuLi9pbmZlcmVuY2UtaGFuZGxlcic7XG5pbXBvcnQge1Byb2dyYW1JbmZvLCBUZXh0dXJlVHlwZX0gZnJvbSAnLi4vdHlwZXMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFRyYW5zcG9zZUF0dHJpYnV0ZXMgZXh0ZW5kcyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkge1xuICByZWFkb25seSBwZXJtOiBudW1iZXJbXTtcbn1cblxuY29uc3QgdHJhbnNwb3NlUHJvZ3JhbU1ldGFkYXRhID0ge1xuICBuYW1lOiAnVHJhbnNwb3NlJyxcbiAgaW5wdXROYW1lczogWydBJ10sXG4gIGlucHV0VHlwZXM6IFtUZXh0dXJlVHlwZS51bnBhY2tlZF1cbn07XG5cbmV4cG9ydCBjb25zdCB0cmFuc3Bvc2U6IE9wZXJhdG9ySW1wbGVtZW50YXRpb248VHJhbnNwb3NlQXR0cmlidXRlcz4gPVxuICAgIChpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10sIGF0dHJpYnV0ZXM6IFRyYW5zcG9zZUF0dHJpYnV0ZXMpOiBUZW5zb3JbXSA9PiB7XG4gICAgICB2YWxpZGF0ZUlucHV0cyhpbnB1dHMpO1xuICAgICAgY29uc3Qgb3V0cHV0ID0gaW5mZXJlbmNlSGFuZGxlci5ydW4oXG4gICAgICAgICAge1xuICAgICAgICAgICAgLi4udHJhbnNwb3NlUHJvZ3JhbU1ldGFkYXRhLFxuICAgICAgICAgICAgY2FjaGVIaW50OiBhdHRyaWJ1dGVzLmNhY2hlS2V5LFxuICAgICAgICAgICAgZ2V0OiAoKSA9PiBjcmVhdGVUcmFuc3Bvc2VQcm9ncmFtSW5mbyhpbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHNbMF0sIGF0dHJpYnV0ZXMucGVybSlcbiAgICAgICAgICB9LFxuICAgICAgICAgIGlucHV0cyk7XG4gICAgICByZXR1cm4gW291dHB1dF07XG4gICAgfTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlVHJhbnNwb3NlQXR0cmlidXRlczogT3BlcmF0b3JJbml0aWFsaXphdGlvbjxUcmFuc3Bvc2VBdHRyaWJ1dGVzPiA9XG4gICAgKG5vZGU6IEdyYXBoLk5vZGUpOiBUcmFuc3Bvc2VBdHRyaWJ1dGVzID0+IGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSh7cGVybTogbm9kZS5hdHRyaWJ1dGVzLmdldEludHMoJ3Blcm0nLCBbXSl9KTtcblxuY29uc3QgY3JlYXRlVHJhbnNwb3NlUHJvZ3JhbUluZm8gPVxuICAgIChfaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dDogVGVuc29yLCBwZXJtOiBudW1iZXJbXSk6IFByb2dyYW1JbmZvID0+IHtcbiAgICAgIGNvbnN0IGlucHV0U2hhcGUgPSBpbnB1dC5kaW1zO1xuICAgICAgcGVybSA9IGdldEFkanVzdGVkUGVybShpbnB1dFNoYXBlLCBwZXJtKTtcbiAgICAgIGNvbnN0IHVucGFja2VkT3V0cHV0U2hhcGUgPSBnZXRPdXRwdXRTaGFwZShpbnB1dFNoYXBlLCBwZXJtKTtcbiAgICAgIGNvbnN0IHJhbmsgPSBpbnB1dFNoYXBlLmxlbmd0aDtcbiAgICAgIC8vIEEgZGltcz1bJHtpbnB1dHNbMF0uZGltcy50b1N0cmluZygpfV1cbiAgICAgIC8vIG91dCBEaW1zPVske3VucGFja2VkT3V0cHV0U2hhcGUudG9TdHJpbmcoKX1dXG4gICAgICAvLyBiYXNlZCBvbiBwZXJtPVske3Blcm0udG9TdHJpbmcoKX1dXG4gICAgICBjb25zdCBzaGFkZXJTb3VyY2UgPSBgXG4gICAgICAke2dldFBlcm1GdW5jdGlvbkJvZHkoJ3Blcm0nLCBwZXJtLCByYW5rKX1cbiAgICAgIGZsb2F0IHByb2Nlc3MoaW50IGluZGljZXNbJHtyYW5rfV0pIHtcbiAgICAgICAgaW50IGFbJHtyYW5rfV07XG4gICAgICAgIHBlcm0oYSwgaW5kaWNlcyk7XG4gICAgICAgIHJldHVybiBfQShhKTtcbiAgICAgIH1gO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4udHJhbnNwb3NlUHJvZ3JhbU1ldGFkYXRhLFxuICAgICAgICBvdXRwdXQ6IHtkaW1zOiB1bnBhY2tlZE91dHB1dFNoYXBlLCB0eXBlOiBpbnB1dC50eXBlLCB0ZXh0dXJlVHlwZTogVGV4dHVyZVR5cGUudW5wYWNrZWR9LFxuICAgICAgICBzaGFkZXJTb3VyY2VcbiAgICAgIH07XG4gICAgfTtcblxuY29uc3QgZ2V0QWRqdXN0ZWRQZXJtID0gKGlucHV0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLCBwZXJtOiBudW1iZXJbXSk6IG51bWJlcltdID0+IHtcbiAgaWYgKHBlcm0gJiYgcGVybS5sZW5ndGggIT09IGlucHV0U2hhcGUubGVuZ3RoKSB7XG4gICAgcGVybSA9IFsuLi4oaW5wdXRTaGFwZS5rZXlzKCkpXS5yZXZlcnNlKCk7XG4gIH1cbiAgcmV0dXJuIHBlcm07XG59O1xuXG5jb25zdCBnZXRPdXRwdXRTaGFwZSA9IChpbnB1dFNoYXBlOiByZWFkb25seSBudW1iZXJbXSwgcGVybTogbnVtYmVyW10pOiByZWFkb25seSBudW1iZXJbXSA9PiB7XG4gIHBlcm0gPSBnZXRBZGp1c3RlZFBlcm0oaW5wdXRTaGFwZSwgcGVybSk7XG4gIHJldHVybiBTaGFwZVV0aWwuc29ydEJhc2VkT25QZXJtKGlucHV0U2hhcGUsIHBlcm0pO1xufTtcblxuY29uc3QgZ2V0UGVybUZ1bmN0aW9uQm9keSA9IChuYW1lOiBzdHJpbmcsIHBlcm06IG51bWJlcltdLCByYW5rOiBudW1iZXIpOiBzdHJpbmcgPT4ge1xuICBjb25zdCByZXZlcnNlRnVuYyA9IFtdO1xuICByZXZlcnNlRnVuYy5wdXNoKGB2b2lkICR7bmFtZX0ob3V0IGludCBhWyR7cmFua31dLCBpbnQgc3JjWyR7cmFua31dKSB7YCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuazsgKytpKSB7XG4gICAgcmV2ZXJzZUZ1bmMucHVzaChgXFx0YVske3Blcm1baV19XT1zcmNbJHtpfV07YCk7XG4gIH1cbiAgcmV2ZXJzZUZ1bmMucHVzaCgnXFx0fScpO1xuICByZXR1cm4gcmV2ZXJzZUZ1bmMuam9pbignXFxuJyk7XG59O1xuXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IFRlbnNvcltdKTogdm9pZCA9PiB7XG4gIGlmICghaW5wdXRzIHx8IGlucHV0cy5sZW5ndGggIT09IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zcG9zZSByZXF1aXJlcyAxIGlucHV0LicpO1xuICB9XG5cbiAgaWYgKGlucHV0c1swXS50eXBlICE9PSAnZmxvYXQzMicgJiYgaW5wdXRzWzBdLnR5cGUgIT09ICdmbG9hdDY0Jykge1xuICAgIHRocm93IG5ldyBFcnJvcignaW5wdXQgc2hvdWxkIGJlIGZsb2F0IHRlbnNvcicpO1xuICB9XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0dyYXBofSBmcm9tICcuLi8uLi8uLi9ncmFwaCc7XG5pbXBvcnQge09wZXJhdG9ySW1wbGVtZW50YXRpb24sIE9wZXJhdG9ySW5pdGlhbGl6YXRpb259IGZyb20gJy4uLy4uLy4uL29wZXJhdG9ycyc7XG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi4vLi4vLi4vdGVuc29yJztcbmltcG9ydCB7V2ViR0xJbmZlcmVuY2VIYW5kbGVyfSBmcm9tICcuLi9pbmZlcmVuY2UtaGFuZGxlcic7XG5cbmltcG9ydCB7dHJhbnNwb3NlLCBUcmFuc3Bvc2VBdHRyaWJ1dGVzfSBmcm9tICcuL3RyYW5zcG9zZSc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgRGVwdGhUb1NwYWNlQXR0cmlidXRlcyB7XG4gIG1vZGU6ICdEQ1InfCdDUkQnO1xuICBibG9ja3NpemU6IG51bWJlcjtcbn1cblxuZXhwb3J0IGNvbnN0IGRlcHRoVG9TcGFjZTogT3BlcmF0b3JJbXBsZW1lbnRhdGlvbjxEZXB0aFRvU3BhY2VBdHRyaWJ1dGVzPiA9XG4gICAgKGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSwgYXR0cmlidXRlczogRGVwdGhUb1NwYWNlQXR0cmlidXRlcyk6IFRlbnNvcltdID0+IHtcbiAgICAgIHZhbGlkYXRlSW5wdXRzKGlucHV0cyk7XG4gICAgICBjb25zdCBibG9ja3NpemUgPSBhdHRyaWJ1dGVzLmJsb2Nrc2l6ZTtcbiAgICAgIGNvbnN0IGJsb2Nrc2l6ZVNxciA9IGJsb2Nrc2l6ZSAqIGJsb2Nrc2l6ZTtcbiAgICAgIGNvbnN0IHRyYW5zcG9zZVBlcm0gPSBhdHRyaWJ1dGVzLm1vZGUgPT09ICdEQ1InID8gWzAsIDMsIDQsIDEsIDUsIDJdIDogWzAsIDEsIDQsIDIsIDUsIDNdO1xuICAgICAgY29uc3QgZmlyc3RSZXNoYXBlU2hhcGUgPSBhdHRyaWJ1dGVzLm1vZGUgPT09ICdEQ1InID9cbiAgICAgICAgICBbXG4gICAgICAgICAgICBpbnB1dHNbMF0uZGltc1swXSwgYmxvY2tzaXplLCBibG9ja3NpemUsIGlucHV0c1swXS5kaW1zWzFdIC8gYmxvY2tzaXplU3FyLCBpbnB1dHNbMF0uZGltc1syXSxcbiAgICAgICAgICAgIGlucHV0c1swXS5kaW1zWzNdXG4gICAgICAgICAgXSA6XG4gICAgICAgICAgW1xuICAgICAgICAgICAgaW5wdXRzWzBdLmRpbXNbMF0sIGlucHV0c1swXS5kaW1zWzFdIC8gYmxvY2tzaXplU3FyLCBibG9ja3NpemUsIGJsb2Nrc2l6ZSwgaW5wdXRzWzBdLmRpbXNbMl0sXG4gICAgICAgICAgICBpbnB1dHNbMF0uZGltc1szXVxuICAgICAgICAgIF07XG5cbiAgICAgIC8vIGNvbnN0IHRyYW5zcG9zZSA9IG5ldyBXZWJHTFRyYW5zcG9zZSgpO1xuICAgICAgLy8gY29uc3QgYXR0cmlidXRlcyA9IG5ldyBBdHRyaWJ1dGUodW5kZWZpbmVkKTtcbiAgICAgIC8vIGF0dHJpYnV0ZXMuc2V0KCdwZXJtJywgJ2ludHMnLCB0cmFuc3Bvc2VQZXJtKTtcbiAgICAgIC8vIHRyYW5zcG9zZS5pbml0aWFsaXplKGF0dHJpYnV0ZXMpO1xuXG4gICAgICAvLyBGaXJzdCByZXNoYXBlXG4gICAgICBjb25zdCBmaXJzdFJlc2hhcGVkVGVuc29yID0gaW5mZXJlbmNlSGFuZGxlci5yZXNoYXBlVW5wYWNrZWQoaW5wdXRzWzBdLCBmaXJzdFJlc2hhcGVTaGFwZSk7XG5cbiAgICAgIC8vIHRyYW5zcG9zZVxuICAgICAgY29uc3QgdHJhbnNwb3NlQXR0cmlidXRlczogVHJhbnNwb3NlQXR0cmlidXRlcyA9IHtwZXJtOiB0cmFuc3Bvc2VQZXJtLCBjYWNoZUtleTogYCR7dHJhbnNwb3NlUGVybX1gfTtcbiAgICAgIGNvbnN0IFt0cmFuc3Bvc2VPdXRwdXRdID0gdHJhbnNwb3NlKGluZmVyZW5jZUhhbmRsZXIsIFtmaXJzdFJlc2hhcGVkVGVuc29yXSwgdHJhbnNwb3NlQXR0cmlidXRlcyk7XG5cbiAgICAgIC8vIFNlY29uZCByZXNoYXBlXG4gICAgICBjb25zdCBzZWNvbmRSZXNoYXBlU2hhcGUgPSBbXG4gICAgICAgIGlucHV0c1swXS5kaW1zWzBdLCBpbnB1dHNbMF0uZGltc1sxXSAvIGJsb2Nrc2l6ZVNxciwgaW5wdXRzWzBdLmRpbXNbMl0gKiBibG9ja3NpemUsXG4gICAgICAgIGlucHV0c1swXS5kaW1zWzNdICogYmxvY2tzaXplXG4gICAgICBdO1xuICAgICAgY29uc3QgcmVzdWx0ID0gaW5mZXJlbmNlSGFuZGxlci5yZXNoYXBlVW5wYWNrZWQodHJhbnNwb3NlT3V0cHV0LCBzZWNvbmRSZXNoYXBlU2hhcGUpO1xuICAgICAgcmV0dXJuIFtyZXN1bHRdO1xuICAgIH07XG5cbmV4cG9ydCBjb25zdCBwYXJzZURlcHRoVG9TcGFjZUF0dHJpYnV0ZXM6IE9wZXJhdG9ySW5pdGlhbGl6YXRpb248RGVwdGhUb1NwYWNlQXR0cmlidXRlcz4gPVxuICAgIChub2RlOiBHcmFwaC5Ob2RlKTogRGVwdGhUb1NwYWNlQXR0cmlidXRlcyA9PiB7XG4gICAgICAvLyBwcm9jZXNzaW5nIG5vZGUgYXR0cmlidXRlc1xuICAgICAgY29uc3QgYmxvY2tzaXplID0gbm9kZS5hdHRyaWJ1dGVzLmdldEludCgnYmxvY2tzaXplJyk7XG4gICAgICBpZiAoYmxvY2tzaXplIDwgMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGJsb2Nrc2l6ZSBtdXN0IGJlID49IDEsIGJ1dCBnb3QgOiAke2Jsb2Nrc2l6ZX0gZm9yIERlcHRoVG9TcGFjZWApO1xuICAgICAgfVxuICAgICAgY29uc3QgbW9kZSA9IG5vZGUuYXR0cmlidXRlcy5nZXRTdHJpbmcoJ21vZGUnLCAnRENSJyk7XG4gICAgICBpZiAobW9kZSAhPT0gJ0RDUicgJiYgbW9kZSAhPT0gJ0NSRCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bnJlY29nbml6ZWQgbW9kZTogJHttb2RlfSBmb3IgRGVwdGhUb1NwYWNlYCk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge21vZGUsIGJsb2Nrc2l6ZX07XG4gICAgfTtcblxuY29uc3QgdmFsaWRhdGVJbnB1dHMgPSAoaW5wdXRzOiBUZW5zb3JbXSk6IHZvaWQgPT4ge1xuICBpZiAoaW5wdXRzLmxlbmd0aCAhPT0gMSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgRGVwdGhUb1NwYWNlIGV4cGVjdCAxIGlucHV0cywgYnV0IGdvdCAke2lucHV0cy5sZW5ndGh9YCk7XG4gIH1cblxuICAvLyBJbnB1dCBoYXMgdG8gYmUgYSA0LUQgdGVuc29yXG4gIC8vIFRPRE86IFN1cHBvcnQgc3RyaW5nIGRlcHRoLXRvLXNwYWNlLlxuICBpZiAoaW5wdXRzWzBdLnR5cGUgPT09ICdzdHJpbmcnIHx8IGlucHV0c1swXS5kaW1zLmxlbmd0aCAhPT0gNCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0RlcHRoVG9TcGFjZSBpbnB1dCBzaG91bGQgYmUgYSA0LUQgbnVtZXJpYyB0ZW5zb3InKTtcbiAgfVxufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtHcmFwaH0gZnJvbSAnLi4vLi4vLi4vZ3JhcGgnO1xuaW1wb3J0IHtPcGVyYXRvckltcGxlbWVudGF0aW9uLCBPcGVyYXRvckluaXRpYWxpemF0aW9ufSBmcm9tICcuLi8uLi8uLi9vcGVyYXRvcnMnO1xuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4uLy4uLy4uL3RlbnNvcic7XG5pbXBvcnQge1NoYXBlVXRpbH0gZnJvbSAnLi4vLi4vLi4vdXRpbCc7XG5pbXBvcnQge1dlYkdMSW5mZXJlbmNlSGFuZGxlcn0gZnJvbSAnLi4vaW5mZXJlbmNlLWhhbmRsZXInO1xuXG5leHBvcnQgY29uc3QgZmxhdHRlbjogT3BlcmF0b3JJbXBsZW1lbnRhdGlvbjxudW1iZXI+ID1cbiAgICAoaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdLCBheGlzOiBudW1iZXIpOiBUZW5zb3JbXSA9PiB7XG4gICAgICB2YWxpZGF0ZUlucHV0cyhpbnB1dHMsIGF4aXMpO1xuXG4gICAgICBjb25zdCBvdXRwdXREaW1zID0gU2hhcGVVdGlsLmZsYXR0ZW5TaGFwZShpbnB1dHNbMF0uZGltcywgYXhpcyk7XG4gICAgICByZXR1cm4gW2luZmVyZW5jZUhhbmRsZXIucmVzaGFwZVVucGFja2VkKGlucHV0c1swXSwgb3V0cHV0RGltcyldO1xuICAgIH07XG5cbmV4cG9ydCBjb25zdCBwYXJzZUZsYXR0ZW5BdHRyaWJ1dGVzOiBPcGVyYXRvckluaXRpYWxpemF0aW9uPG51bWJlcj4gPSAobm9kZTogR3JhcGguTm9kZSk6IG51bWJlciA9PlxuICAgIG5vZGUuYXR0cmlidXRlcy5nZXRJbnQoJ2F4aXMnLCAxKTsgIC8vIGRlZmF1bHQgYXhpcyBpcyAxXG5cbmNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogVGVuc29yW10sIGF4aXM6IG51bWJlcik6IHZvaWQgPT4ge1xuICBpZiAoIWlucHV0cyB8fCBpbnB1dHMubGVuZ3RoICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGbGF0dGVuIHJlcXVpcmVzIDEgaW5wdXQuJyk7XG4gIH1cblxuICBjb25zdCByID0gaW5wdXRzWzBdLmRpbXMubGVuZ3RoO1xuICBpZiAociA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2NhbGFyIHRlbnNvciBpcyBub3Qgc3VwcG9ydGVkLicpO1xuICB9XG5cbiAgaWYgKGF4aXMgPCAtciB8fCBheGlzID4gcikge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBheGlzJyk7XG4gIH1cblxuICAvLyBUT0RPOiBTdXBwb3J0IHN0cmluZyB0eXBlXG4gIGlmIChpbnB1dHNbMF0udHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3N0cmluZyB0ZW5zb3IgaXMgbm90IHN1cHBvcnRlZC4nKTtcbiAgfVxufTsiLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7SW5mZXJlbmNlSGFuZGxlcn0gZnJvbSAnLi9iYWNrZW5kJztcbmltcG9ydCB7R3JhcGh9IGZyb20gJy4vZ3JhcGgnO1xuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4vdGVuc29yJztcblxuZXhwb3J0IHR5cGUgT3BlcmF0b3JJbXBsZW1lbnRhdGlvbjxUPiA9IChpbmZlcmVuY2VIYW5kbGVyOiBJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdLCBjb250ZXh0OiBUKSA9PiBUZW5zb3JbXTtcbmV4cG9ydCB0eXBlIE9wZXJhdG9ySW5pdGlhbGl6YXRpb248VD4gPSAobm9kZTogR3JhcGguTm9kZSwgZ3JhcGg6IEdyYXBoKSA9PiBUO1xuXG5leHBvcnQgaW50ZXJmYWNlIE9wZXJhdG9yIHtcbiAgcmVhZG9ubHkgaW1wbDogT3BlcmF0b3JJbXBsZW1lbnRhdGlvbjx1bmtub3duPjtcbiAgcmVhZG9ubHkgY29udGV4dDogR3JhcGguTm9kZXx1bmtub3duO1xufVxuXG5leHBvcnQgY29uc3QgTlVNQkVSX1RZUEVTOiByZWFkb25seSBUZW5zb3IuRGF0YVR5cGVbXSA9XG4gICAgWydmbG9hdDMyJywgJ2Zsb2F0NjQnLCAnaW50MzInLCAnaW50MTYnLCAnaW50OCcsICd1aW50MTYnLCAndWludDMyJywgJ3VpbnQ4J107XG5leHBvcnQgY29uc3QgSU5UX1RZUEVTOiByZWFkb25seSBUZW5zb3IuRGF0YVR5cGVbXSA9IFsnaW50MzInLCAnaW50MTYnLCAnaW50OCcsICd1aW50MTYnLCAndWludDMyJywgJ3VpbnQ4J107XG5leHBvcnQgY29uc3QgRkxPQVRfVFlQRVM6IHJlYWRvbmx5IFRlbnNvci5EYXRhVHlwZVtdID0gWydmbG9hdDMyJywgJ2Zsb2F0NjQnXTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtBdHRyaWJ1dGVXaXRoQ2FjaGVLZXksIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleX0gZnJvbSAnLi4vLi4vLi4vYXR0cmlidXRlLXdpdGgtY2FjaGUta2V5JztcbmltcG9ydCB7R3JhcGh9IGZyb20gJy4uLy4uLy4uL2dyYXBoJztcbmltcG9ydCB7TlVNQkVSX1RZUEVTLCBPcGVyYXRvckltcGxlbWVudGF0aW9uLCBPcGVyYXRvckluaXRpYWxpemF0aW9ufSBmcm9tICcuLi8uLi8uLi9vcGVyYXRvcnMnO1xuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4uLy4uLy4uL3RlbnNvcic7XG5pbXBvcnQge1NoYXBlVXRpbH0gZnJvbSAnLi4vLi4vLi4vdXRpbCc7XG5pbXBvcnQge1dlYkdMSW5mZXJlbmNlSGFuZGxlcn0gZnJvbSAnLi4vaW5mZXJlbmNlLWhhbmRsZXInO1xuaW1wb3J0IHtQcm9ncmFtSW5mbywgUHJvZ3JhbUluZm9Mb2FkZXIsIFByb2dyYW1NZXRhZGF0YSwgVGV4dHVyZVR5cGV9IGZyb20gJy4uL3R5cGVzJztcblxuaW50ZXJmYWNlIEdhdGhlckF0dHJpYnV0ZXMgZXh0ZW5kcyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkge1xuICByZWFkb25seSBheGlzOiBudW1iZXI7XG59XG5cbmV4cG9ydCBjb25zdCBnYXRoZXI6IE9wZXJhdG9ySW1wbGVtZW50YXRpb248R2F0aGVyQXR0cmlidXRlcz4gPVxuICAgIChpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10sIGF0dHJpYnV0ZXM6IEdhdGhlckF0dHJpYnV0ZXMpOiBUZW5zb3JbXSA9PiB7XG4gICAgICB2YWxpZGF0ZUlucHV0cyhpbnB1dHMsIGF0dHJpYnV0ZXMuYXhpcyk7XG4gICAgICBjb25zdCBvdXRwdXQgPSBpbmZlcmVuY2VIYW5kbGVyLnJ1bihjcmVhdGVHYXRoZXJQcm9ncmFtSW5mb0xvYWRlcihpbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHMsIGF0dHJpYnV0ZXMpLCBpbnB1dHMpO1xuICAgICAgcmV0dXJuIFtvdXRwdXRdO1xuICAgIH07XG5cbmV4cG9ydCBjb25zdCBwYXJzZUdhdGhlckF0dHJpYnV0ZXM6IE9wZXJhdG9ySW5pdGlhbGl6YXRpb248R2F0aGVyQXR0cmlidXRlcz4gPSAobm9kZTogR3JhcGguTm9kZSk6IEdhdGhlckF0dHJpYnV0ZXMgPT5cbiAgICBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkoe2F4aXM6IG5vZGUuYXR0cmlidXRlcy5nZXRJbnQoJ2F4aXMnLCAwKX0pO1xuXG5jb25zdCBnYXRoZXJQcm9ncmFtTWV0YWRhdGEgPSB7XG4gIG5hbWU6ICdHYXRoZXInLFxuICBpbnB1dE5hbWVzOiBbJ0EnLCAnQiddLFxuICBpbnB1dFR5cGVzOiBbVGV4dHVyZVR5cGUudW5wYWNrZWQsIFRleHR1cmVUeXBlLnVucGFja2VkXSxcbn07XG5cbmNvbnN0IGNyZWF0ZUdhdGhlclByb2dyYW1JbmZvID1cbiAgICAoX2hhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgbWV0YWRhdGE6IFByb2dyYW1NZXRhZGF0YSwgaW5wdXRzOiBUZW5zb3JbXSwgYXhpczogbnVtYmVyKTogUHJvZ3JhbUluZm8gPT4ge1xuICAgICAgY29uc3QgaW5wdXRTaGFwZSA9IGlucHV0c1swXS5kaW1zLnNsaWNlKCk7XG4gICAgICBjb25zdCBpbmRleERhdGFTaGFwZSA9IGlucHV0c1sxXS5kaW1zLnNsaWNlKCk7XG4gICAgICBjb25zdCBvdXRwdXRTaGFwZSA9IG5ldyBBcnJheShpbnB1dFNoYXBlLmxlbmd0aCArIGluZGV4RGF0YVNoYXBlLmxlbmd0aCAtIDEpO1xuXG4gICAgICBheGlzID0gU2hhcGVVdGlsLm5vcm1hbGl6ZUF4aXMoYXhpcywgaW5wdXRTaGFwZS5sZW5ndGgpO1xuICAgICAgY29uc3QgaW5kZXhDb3B5T3BzOiBzdHJpbmdbXSA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRwdXRTaGFwZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBvdXRwdXRTaGFwZSBpcyBkaXZpZGVkIGludG8gdGhyZWUgcGFydHM6IEEsIEIsIENcbiAgICAgICAgLy8gfDAgICAgICAgIGF4aXN8ICBheGlzICsgaW5kZXhEYXRhU2hhcGUubGVuZ3RoIHwgICAgICAgICAgZW5kfFxuICAgICAgICAvLyB8ICAgICBBICAgICAgIHwgICAgICAgICAgICAgQiAgICAgICAgICAgICAgICAgfCAgICAgIEMgICAgICB8XG4gICAgICAgIC8vXG4gICAgICAgIC8vIGlucHV0SWR4OiBbQSwgaW5wdXRzWzFdW0JdLCBDXVxuICAgICAgICBpZiAoaSA8IGF4aXMpIHsgIC8vIEFcbiAgICAgICAgICBvdXRwdXRTaGFwZVtpXSA9IGlucHV0U2hhcGVbaV07XG4gICAgICAgICAgaW5kZXhDb3B5T3BzLnB1c2goYGlucHV0SWR4WyR7aX1dID0gb3V0cHV0SWR4WyR7aX1dO2ApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChpIDwgYXhpcyArIGluZGV4RGF0YVNoYXBlLmxlbmd0aCkgeyAgLy8gQlxuICAgICAgICAgICAgb3V0cHV0U2hhcGVbaV0gPSBpbmRleERhdGFTaGFwZVtpIC0gYXhpc107XG4gICAgICAgICAgICBpbmRleENvcHlPcHMucHVzaChgaW5kZXhEYXRhSWR4WyR7aSAtIGF4aXN9XSA9IG91dHB1dElkeFske2l9XTtgKTtcbiAgICAgICAgICB9IGVsc2UgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDXG4gICAgICAgICAgICBvdXRwdXRTaGFwZVtpXSA9IGlucHV0U2hhcGVbaSAtIGluZGV4RGF0YVNoYXBlLmxlbmd0aCArIDFdOyAgLy8gc2tpcCAxIGZvciBheGlzXG4gICAgICAgICAgICBpbmRleENvcHlPcHMucHVzaChgaW5wdXRJZHhbJHtpIC0gaW5kZXhEYXRhU2hhcGUubGVuZ3RoICsgMX1dID0gb3V0cHV0SWR4WyR7aX1dO2ApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCBvcmFuayA9IG91dHB1dFNoYXBlLmxlbmd0aCB8fCAxO1xuICAgICAgY29uc3QgaXJhbmsgPSBpbnB1dFNoYXBlLmxlbmd0aDtcbiAgICAgIGNvbnN0IGlEcmFuayA9IGluZGV4RGF0YVNoYXBlLmxlbmd0aCB8fCAxO1xuICAgICAgY29uc3Qgc2hhZGVyU291cmNlID0gYFxuICAgICAgZmxvYXQgcHJvY2VzcyhpbnQgb3V0cHV0SWR4WyR7b3Jhbmt9XSkge1xuICAgICAgICBpbnQgaW5wdXRJZHhbJHtpcmFua31dO1xuICAgICAgICBpbnQgaW5kZXhEYXRhSWR4WyR7aURyYW5rfV07XG4gICAgICAgIGluZGV4RGF0YUlkeFswXSA9IDA7XG4gICAgICAgICR7aW5kZXhDb3B5T3BzLmpvaW4oJ1xcbiAgICAgICAgJyl9XG4gICAgICAgIGludCBpZHggPSBpbnQoX0IoaW5kZXhEYXRhSWR4KSk7XG4gICAgICAgIGlucHV0SWR4WyR7YXhpc31dID0gaWR4IDwgMCA/IGlkeCArICR7aW5wdXRTaGFwZVtheGlzXX0gOiBpZHg7XG4gICAgICAgIHJldHVybiBfQShpbnB1dElkeCk7XG4gICAgICB9YDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLm1ldGFkYXRhLFxuICAgICAgICBvdXRwdXQ6IHtkaW1zOiBvdXRwdXRTaGFwZSwgdHlwZTogaW5wdXRzWzBdLnR5cGUsIHRleHR1cmVUeXBlOiBUZXh0dXJlVHlwZS51bnBhY2tlZH0sXG4gICAgICAgIHNoYWRlclNvdXJjZVxuICAgICAgfTtcbiAgICB9O1xuXG5jb25zdCBjcmVhdGVHYXRoZXJQcm9ncmFtSW5mb0xvYWRlciA9XG4gICAgKGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSwgYXR0cmlidXRlczogR2F0aGVyQXR0cmlidXRlcyk6IFByb2dyYW1JbmZvTG9hZGVyID0+IHtcbiAgICAgIGNvbnN0IG1ldGFkYXRhID0gey4uLmdhdGhlclByb2dyYW1NZXRhZGF0YSwgY2FjaGVIaW50OiBhdHRyaWJ1dGVzLmNhY2hlS2V5fTtcbiAgICAgIHJldHVybiB7Li4ubWV0YWRhdGEsIGdldDogKCkgPT4gY3JlYXRlR2F0aGVyUHJvZ3JhbUluZm8oaGFuZGxlciwgbWV0YWRhdGEsIGlucHV0cywgYXR0cmlidXRlcy5heGlzKX07XG4gICAgfTtcblxuY29uc3QgdmFsaWRhdGVJbnB1dHMgPSAoaW5wdXRzOiBUZW5zb3JbXSwgYXhpczogbnVtYmVyKTogdm9pZCA9PiB7XG4gIGlmICghaW5wdXRzIHx8IGlucHV0cy5sZW5ndGggIT09IDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0dhdGhlciByZXF1aXJlcyAyIGlucHV0cy4nKTtcbiAgfVxuICBjb25zdCB0ZW5zb3JSYW5rID0gaW5wdXRzWzBdLmRpbXMubGVuZ3RoO1xuICBpZiAodGVuc29yUmFuayA8IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW5wdXQgc2hhcGUuJyk7XG4gIH1cbiAgaWYgKGF4aXMgPCAtdGVuc29yUmFuayB8fCBheGlzID4gdGVuc29yUmFuayAtIDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYXhpcy4nKTtcbiAgfVxuICBpZiAoTlVNQkVSX1RZUEVTLmluZGV4T2YoaW5wdXRzWzBdLnR5cGUpID09PSAtMSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWlkIGlucHV0IHR5cGUuJyk7XG4gIH1cbiAgaWYgKGlucHV0c1sxXS50eXBlICE9PSAnaW50MzInICYmIGlucHV0c1sxXS50eXBlICE9PSAnaW50MTYnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhaWQgaW5wdXQgdHlwZS4nKTtcbiAgfVxufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtBdHRyaWJ1dGVXaXRoQ2FjaGVLZXksIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleX0gZnJvbSAnLi4vLi4vLi4vYXR0cmlidXRlLXdpdGgtY2FjaGUta2V5JztcbmltcG9ydCB7R3JhcGh9IGZyb20gJy4uLy4uLy4uL2dyYXBoJztcbmltcG9ydCB7T3BlcmF0b3JJbXBsZW1lbnRhdGlvbiwgT3BlcmF0b3JJbml0aWFsaXphdGlvbn0gZnJvbSAnLi4vLi4vLi4vb3BlcmF0b3JzJztcbmltcG9ydCB7VGVuc29yfSBmcm9tICcuLi8uLi8uLi90ZW5zb3InO1xuaW1wb3J0IHtHZW1tVXRpbH0gZnJvbSAnLi4vLi4vLi4vdXRpbCc7XG5pbXBvcnQge1dlYkdMSW5mZXJlbmNlSGFuZGxlcn0gZnJvbSAnLi4vaW5mZXJlbmNlLWhhbmRsZXInO1xuaW1wb3J0IHtQcm9ncmFtSW5mbywgUHJvZ3JhbUluZm9Mb2FkZXIsIFByb2dyYW1NZXRhZGF0YSwgVGV4dHVyZVR5cGV9IGZyb20gJy4uL3R5cGVzJztcblxuZXhwb3J0IGludGVyZmFjZSBHZW1tQXR0cmlidXRlcyBleHRlbmRzIEF0dHJpYnV0ZVdpdGhDYWNoZUtleSB7XG4gIHRyYW5zQTogYm9vbGVhbjtcbiAgdHJhbnNCOiBib29sZWFuO1xuICBhbHBoYTogbnVtYmVyO1xuICBiZXRhOiBudW1iZXI7XG4gIGlzT3B0aW9uYWxDOiBib29sZWFuOyAgLy8gaW4gb3BzZXQgMTEsIEMgYmVjb21lcyBvcHRpb25hbFxufVxuXG5leHBvcnQgY29uc3QgZ2VtbTogT3BlcmF0b3JJbXBsZW1lbnRhdGlvbjxHZW1tQXR0cmlidXRlcz4gPVxuICAgIChpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10sIGF0dHJpYnV0ZXM6IEdlbW1BdHRyaWJ1dGVzKTogVGVuc29yW10gPT4ge1xuICAgICAgdmFsaWRhdGVJbnB1dHMoaW5wdXRzLCBhdHRyaWJ1dGVzKTtcbiAgICAgIGNvbnN0IG91dHB1dCA9IGluZmVyZW5jZUhhbmRsZXIucnVuKGNyZWF0ZUdlbW1Qcm9ncmFtSW5mb0xvYWRlcihpbnB1dHMsIGF0dHJpYnV0ZXMpLCBpbnB1dHMpO1xuICAgICAgcmV0dXJuIFtvdXRwdXRdO1xuICAgIH07XG5cbmNvbnN0IHBhcnNlR2VtbUF0dHJpYnV0ZXMgPSAobm9kZTogR3JhcGguTm9kZSwgaXNPcHRpb25hbEM6IGJvb2xlYW4pOiBHZW1tQXR0cmlidXRlcyA9PiB7XG4gIGNvbnN0IHRyYW5zQSA9IG5vZGUuYXR0cmlidXRlcy5nZXRJbnQoJ3RyYW5zQScsIDApICE9PSAwO1xuICBjb25zdCB0cmFuc0IgPSBub2RlLmF0dHJpYnV0ZXMuZ2V0SW50KCd0cmFuc0InLCAwKSAhPT0gMDtcbiAgY29uc3QgYWxwaGEgPSBub2RlLmF0dHJpYnV0ZXMuZ2V0RmxvYXQoJ2FscGhhJywgMS4wKTtcbiAgY29uc3QgYmV0YSA9IG5vZGUuYXR0cmlidXRlcy5nZXRGbG9hdCgnYmV0YScsIDEuMCk7XG4gIHJldHVybiBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkoe3RyYW5zQSwgdHJhbnNCLCBhbHBoYSwgYmV0YSwgaXNPcHRpb25hbEN9KTtcbn07XG5cbmV4cG9ydCBjb25zdCBwYXJzZUdlbW1BdHRyaWJ1dGVzVjc6IE9wZXJhdG9ySW5pdGlhbGl6YXRpb248R2VtbUF0dHJpYnV0ZXM+ID0gKG5vZGU6IEdyYXBoLk5vZGUpOiBHZW1tQXR0cmlidXRlcyA9PlxuICAgIHBhcnNlR2VtbUF0dHJpYnV0ZXMobm9kZSwgZmFsc2UpO1xuXG5leHBvcnQgY29uc3QgcGFyc2VHZW1tQXR0cmlidXRlc1YxMTogT3BlcmF0b3JJbml0aWFsaXphdGlvbjxHZW1tQXR0cmlidXRlcz4gPSAobm9kZTogR3JhcGguTm9kZSk6IEdlbW1BdHRyaWJ1dGVzID0+XG4gICAgcGFyc2VHZW1tQXR0cmlidXRlcyhub2RlLCB0cnVlKTtcblxuY29uc3QgY3JlYXRlR2VtbVByb2dyYW1JbmZvTG9hZGVyID0gKGlucHV0czogVGVuc29yW10sIGF0dHJpYnV0ZXM6IEdlbW1BdHRyaWJ1dGVzKTogUHJvZ3JhbUluZm9Mb2FkZXIgPT4ge1xuICBjb25zdCBtZXRhZGF0YSA9IHtcbiAgICBuYW1lOiAnR2VtbScsXG4gICAgaW5wdXROYW1lczogaW5wdXRzLmxlbmd0aCA9PT0gMyA/IFsnQScsICdCJywgJ0MnXSA6IFsnQScsICdCJ10sXG4gICAgaW5wdXRUeXBlczogaW5wdXRzLmxlbmd0aCA9PT0gMyA/IFtUZXh0dXJlVHlwZS51bnBhY2tlZCwgVGV4dHVyZVR5cGUudW5wYWNrZWQsIFRleHR1cmVUeXBlLnVucGFja2VkXSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtUZXh0dXJlVHlwZS51bnBhY2tlZCwgVGV4dHVyZVR5cGUudW5wYWNrZWRdLFxuICAgIGtleTogYXR0cmlidXRlcy5jYWNoZUtleVxuICB9O1xuXG4gIHJldHVybiB7Li4ubWV0YWRhdGEsIGdldDogKCkgPT4gY3JlYXRlR2VtbVByb2dyYW1JbmZvKG1ldGFkYXRhLCBpbnB1dHMsIGF0dHJpYnV0ZXMpfTtcbn07XG5cbmNvbnN0IGNyZWF0ZUdlbW1Qcm9ncmFtSW5mbyA9XG4gICAgKG1ldGFkYXRhOiBQcm9ncmFtTWV0YWRhdGEsIGlucHV0czogVGVuc29yW10sIGF0dHJpYnV0ZXM6IEdlbW1BdHRyaWJ1dGVzKTogUHJvZ3JhbUluZm8gPT4ge1xuICAgICAgY29uc3QgYVNoYXBlID0gaW5wdXRzWzBdLmRpbXMuc2xpY2UoKTtcbiAgICAgIGNvbnN0IGJTaGFwZSA9IGlucHV0c1sxXS5kaW1zLnNsaWNlKCk7XG4gICAgICBjb25zdCBbTSwgTl0gPSBHZW1tVXRpbC5nZXRTaGFwZU9mR2VtbVJlc3VsdChcbiAgICAgICAgICBhU2hhcGUsIGF0dHJpYnV0ZXMudHJhbnNBLCBiU2hhcGUsIGF0dHJpYnV0ZXMudHJhbnNCLCBpbnB1dHMubGVuZ3RoID09PSAzID8gaW5wdXRzWzJdLmRpbXMgOiB1bmRlZmluZWQpO1xuICAgICAgY29uc3Qgb3V0cHV0U2hhcGUgPSBbTSwgTl07XG4gICAgICBpZiAoIW91dHB1dFNoYXBlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuXFwndCB1c2UgZ2VtbSBvbiB0aGUgZ2l2ZW4gdGVuc29ycycpO1xuICAgICAgfVxuICAgICAgbGV0IHNoYXJlZERpbSA9IGFTaGFwZVthU2hhcGUubGVuZ3RoIC0gMV07XG4gICAgICBsZXQgbGluZSA9ICcnO1xuICAgICAgaWYgKGF0dHJpYnV0ZXMudHJhbnNBKSB7XG4gICAgICAgIHNoYXJlZERpbSA9IGFTaGFwZVswXTtcbiAgICAgIH1cbiAgICAgIGlmIChhdHRyaWJ1dGVzLnRyYW5zQSAmJiBhdHRyaWJ1dGVzLnRyYW5zQikge1xuICAgICAgICBsaW5lID0gJ3ZhbHVlICs9IF9BX1QoYSkgKiBfQl9UKGIpOyc7XG4gICAgICB9IGVsc2UgaWYgKGF0dHJpYnV0ZXMudHJhbnNBICYmICFhdHRyaWJ1dGVzLnRyYW5zQikge1xuICAgICAgICBsaW5lID0gJ3ZhbHVlICs9IF9BX1QoYSkgKiBfQihiKTsnO1xuICAgICAgfSBlbHNlIGlmICghYXR0cmlidXRlcy50cmFuc0EgJiYgYXR0cmlidXRlcy50cmFuc0IpIHtcbiAgICAgICAgbGluZSA9ICd2YWx1ZSArPSBfQShhKSAqIF9CX1QoYik7JztcbiAgICAgIH0gZWxzZSBpZiAoIWF0dHJpYnV0ZXMudHJhbnNBICYmICFhdHRyaWJ1dGVzLnRyYW5zQikge1xuICAgICAgICBsaW5lID0gJ3ZhbHVlICs9IF9BKGEpICogX0IoYik7JztcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJhbmsgPSBvdXRwdXRTaGFwZS5sZW5ndGg7XG4gICAgICBjb25zdCBkZWNsYXJlQyA9IGlucHV0cy5sZW5ndGggPT09IDMgPyBgaW50IGNbJHtpbnB1dHNbMl0uZGltcy5sZW5ndGh9XTtgIDogJyc7XG4gICAgICBjb25zdCBicm9hZGNhc3RDID0gaW5wdXRzLmxlbmd0aCA9PT0gMyA/ICdiY2FzdEluZGljZXNfQyhpbmRpY2VzLCBjKTsnIDogJyc7XG4gICAgICBjb25zdCBjYWxjdWxhdGVDID0gaW5wdXRzLmxlbmd0aCA9PT0gMyA/ICd2YWx1ZSArPSBiZXRhICogX0MoYyk7JyA6ICcnO1xuICAgICAgY29uc3Qgc2hhZGVyU291cmNlID0gYFxuICAgICAgZmxvYXQgcHJvY2VzcyhpbnQgaW5kaWNlc1ske3Jhbmt9XSkge1xuICAgICAgICAgIGludCBhWyR7cmFua31dO1xuICAgICAgICAgIGludCBiWyR7cmFua31dO1xuICAgICAgICAgICR7ZGVjbGFyZUN9XG5cbiAgICAgICAgICBjb3B5VmVjKGluZGljZXMsIGEpO1xuICAgICAgICAgIGNvcHlWZWMoaW5kaWNlcywgYik7XG4gICAgICAgICAgJHticm9hZGNhc3RDfVxuXG4gICAgICAgICAgZmxvYXQgdmFsdWUgPSAwLjA7XG4gICAgICAgICAgZm9yIChpbnQgaz0wOyBrPCR7c2hhcmVkRGltfTsgKytrKSB7XG4gICAgICAgICAgICAgIGFbJHtyYW5rIC0gMX1dID0gaztcbiAgICAgICAgICAgICAgYlske3JhbmsgLSAyfV0gPSBrO1xuICAgICAgICAgICAgICAke2xpbmV9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZSAqIGFscGhhO1xuICAgICAgICAgICR7Y2FsY3VsYXRlQ31cbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9YDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLm1ldGFkYXRhLFxuICAgICAgICBvdXRwdXQ6IHtkaW1zOiBvdXRwdXRTaGFwZSwgdHlwZTogaW5wdXRzWzBdLnR5cGUsIHRleHR1cmVUeXBlOiBUZXh0dXJlVHlwZS51bnBhY2tlZH0sXG4gICAgICAgIHZhcmlhYmxlczogW1xuICAgICAgICAgIHtuYW1lOiAnYWxwaGEnLCB0eXBlOiAnZmxvYXQnLCBkYXRhOiBhdHRyaWJ1dGVzLmFscGhhfSwge25hbWU6ICdiZXRhJywgdHlwZTogJ2Zsb2F0JywgZGF0YTogYXR0cmlidXRlcy5iZXRhfVxuICAgICAgICBdLFxuICAgICAgICBzaGFkZXJTb3VyY2VcbiAgICAgIH07XG4gICAgfTtcblxuY29uc3QgdmFsaWRhdGVJbnB1dHMgPSAoaW5wdXRzOiBUZW5zb3JbXSwgYXR0cmlidXRlczogR2VtbUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgaWYgKCFpbnB1dHMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IGlzIG1pc3NpbmcnKTtcbiAgfVxuICBpZiAoYXR0cmlidXRlcy5pc09wdGlvbmFsQyAmJiAoaW5wdXRzLmxlbmd0aCA8IDIgfHwgaW5wdXRzLmxlbmd0aCA+IDMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhaWQgaW5wdXQgc2hhcGUuJyk7XG4gIH1cbiAgaWYgKCFhdHRyaWJ1dGVzLmlzT3B0aW9uYWxDICYmIGlucHV0cy5sZW5ndGggIT09IDMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0dlbW0gcmVxdWlyZXMgMyBpbnB1dHMnKTtcbiAgfVxuXG4gIC8vICdDJyBjYW4gYmUgb2YgZGltZW5zaW9uYWxpdHkgMSBvciAyIG9ubHlcbiAgaWYgKGlucHV0cy5sZW5ndGggPT09IDMgJiYgaW5wdXRzWzJdLmRpbXMubGVuZ3RoICE9PSAxICYmIGlucHV0c1syXS5kaW1zLmxlbmd0aCAhPT0gMikge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpbnB1dCBzaGFwZSBvZiBDJyk7XG4gIH1cblxuICBpZiAoKGlucHV0c1swXS50eXBlICE9PSAnZmxvYXQzMicgJiYgaW5wdXRzWzBdLnR5cGUgIT09ICdmbG9hdDY0JykgfHxcbiAgICAgIChpbnB1dHNbMV0udHlwZSAhPT0gJ2Zsb2F0MzInICYmIGlucHV0c1sxXS50eXBlICE9PSAnZmxvYXQ2NCcpIHx8XG4gICAgICAoaW5wdXRzLmxlbmd0aCA9PT0gMyAmJiBpbnB1dHNbMl0udHlwZSAhPT0gJ2Zsb2F0MzInICYmIGlucHV0c1syXS50eXBlICE9PSAnZmxvYXQ2NCcpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGlucHV0IHR5cGUuJyk7XG4gIH1cblxuICBpZiAoKGlucHV0c1swXS50eXBlICE9PSBpbnB1dHNbMV0udHlwZSkgfHwgKGlucHV0cy5sZW5ndGggPT09IDMgJiYgaW5wdXRzWzBdLnR5cGUgIT09IGlucHV0c1syXS50eXBlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgdHlwZXMgYXJlIG1pc21hdGNoZWQnKTtcbiAgfVxufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtBdHRyaWJ1dGVXaXRoQ2FjaGVLZXksIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleX0gZnJvbSAnLi4vLi4vLi4vYXR0cmlidXRlLXdpdGgtY2FjaGUta2V5JztcbmltcG9ydCB7R3JhcGh9IGZyb20gJy4uLy4uLy4uL2dyYXBoJztcbmltcG9ydCB7T3BlcmF0b3JJbXBsZW1lbnRhdGlvbiwgT3BlcmF0b3JJbml0aWFsaXphdGlvbn0gZnJvbSAnLi4vLi4vLi4vb3BlcmF0b3JzJztcbmltcG9ydCB7VGVuc29yfSBmcm9tICcuLi8uLi8uLi90ZW5zb3InO1xuaW1wb3J0IHtXZWJHTEluZmVyZW5jZUhhbmRsZXJ9IGZyb20gJy4uL2luZmVyZW5jZS1oYW5kbGVyJztcbmltcG9ydCB7UHJvZ3JhbUluZm8sIFByb2dyYW1JbmZvTG9hZGVyLCBQcm9ncmFtTWV0YWRhdGEsIFRleHR1cmVUeXBlfSBmcm9tICcuLi90eXBlcyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgSW1hZ2VTY2FsZXJBdHRyaWJ1dGVzIGV4dGVuZHMgQXR0cmlidXRlV2l0aENhY2hlS2V5IHtcbiAgc2NhbGU6IG51bWJlcjtcbiAgYmlhczogbnVtYmVyW107XG59XG5cbmV4cG9ydCBjb25zdCBpbWFnZVNjYWxlcjogT3BlcmF0b3JJbXBsZW1lbnRhdGlvbjxJbWFnZVNjYWxlckF0dHJpYnV0ZXM+ID1cbiAgICAoaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdLCBhdHRyaWJ1dGVzOiBJbWFnZVNjYWxlckF0dHJpYnV0ZXMpOiBUZW5zb3JbXSA9PiB7XG4gICAgICB2YWxpZGF0ZUlucHV0cyhpbnB1dHMpO1xuICAgICAgY29uc3Qgb3V0cHV0ID1cbiAgICAgICAgICBpbmZlcmVuY2VIYW5kbGVyLnJ1bihjcmVhdGVJbWFnZVNjYWxlclByb2dyYW1JbmZvTG9hZGVyKGluZmVyZW5jZUhhbmRsZXIsIGlucHV0cywgYXR0cmlidXRlcyksIGlucHV0cyk7XG4gICAgICByZXR1cm4gW291dHB1dF07XG4gICAgfTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlSW1hZ2VTY2FsZXJBdHRyaWJ1dGVzOiBPcGVyYXRvckluaXRpYWxpemF0aW9uPEltYWdlU2NhbGVyQXR0cmlidXRlcz4gPVxuICAgIChub2RlOiBHcmFwaC5Ob2RlKTogSW1hZ2VTY2FsZXJBdHRyaWJ1dGVzID0+IHtcbiAgICAgIGNvbnN0IHNjYWxlID0gbm9kZS5hdHRyaWJ1dGVzLmdldEZsb2F0KCdzY2FsZScpO1xuICAgICAgY29uc3QgYmlhcyA9IG5vZGUuYXR0cmlidXRlcy5nZXRGbG9hdHMoJ2JpYXMnKTtcbiAgICAgIHJldHVybiBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkoe3NjYWxlLCBiaWFzfSk7XG4gICAgfTtcblxuY29uc3QgaW1hZ2VTY2FsZXJQcm9ncmFtTWV0YWRhdGEgPSB7XG4gIG5hbWU6ICdJbWFnZVNjYWxlcicsXG4gIGlucHV0TmFtZXM6IFsnWCddLFxuICBpbnB1dFR5cGVzOiBbVGV4dHVyZVR5cGUudW5wYWNrZWRdLFxufTtcblxuY29uc3QgY3JlYXRlSW1hZ2VTY2FsZXJQcm9ncmFtSW5mbyA9XG4gICAgKF9oYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIG1ldGFkYXRhOiBQcm9ncmFtTWV0YWRhdGEsIGlucHV0czogVGVuc29yW10sIGF0dHJpYnV0ZXM6IEltYWdlU2NhbGVyQXR0cmlidXRlcyk6XG4gICAgICAgIFByb2dyYW1JbmZvID0+IHtcbiAgICAgICAgICBjb25zdCBvdXRwdXRTaGFwZSA9IGlucHV0c1swXS5kaW1zLnNsaWNlKCk7XG4gICAgICAgICAgY29uc3QgcmFuayA9IG91dHB1dFNoYXBlLmxlbmd0aDtcbiAgICAgICAgICBjb25zdCBnZXRCaWFzTWV0aG9kID0gY3JlYXRlR2V0Qmlhc01ldGhvZChhdHRyaWJ1dGVzLmJpYXMubGVuZ3RoKTtcbiAgICAgICAgICBjb25zdCBzaGFkZXJTb3VyY2UgPSBgXG4gICAgICAke2dldEJpYXNNZXRob2R9XG4gICAgICBmbG9hdCBwcm9jZXNzKGludCBpbmRpY2VzWyR7cmFua31dKSB7XG4gICAgICAgIHJldHVybiBfWChpbmRpY2VzKSAqIHNjYWxlICsgZ2V0QmlhcyhiaWFzLCBpbmRpY2VzWzFdKTtcbiAgICAgIH1gO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5tZXRhZGF0YSxcbiAgICAgICAgICAgIG91dHB1dDoge2RpbXM6IG91dHB1dFNoYXBlLCB0eXBlOiBpbnB1dHNbMF0udHlwZSwgdGV4dHVyZVR5cGU6IFRleHR1cmVUeXBlLnVucGFja2VkfSxcbiAgICAgICAgICAgIHZhcmlhYmxlczogW1xuICAgICAgICAgICAgICB7bmFtZTogJ2JpYXMnLCB0eXBlOiAnZmxvYXQnLCBhcnJheUxlbmd0aDogYXR0cmlidXRlcy5iaWFzLmxlbmd0aCwgZGF0YTogYXR0cmlidXRlcy5iaWFzfSxcbiAgICAgICAgICAgICAge25hbWU6ICdzY2FsZScsIHR5cGU6ICdmbG9hdCcsIGRhdGE6IGF0dHJpYnV0ZXMuc2NhbGV9XG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgc2hhZGVyU291cmNlXG4gICAgICAgICAgfTtcbiAgICAgICAgfTtcblxuY29uc3QgY3JlYXRlSW1hZ2VTY2FsZXJQcm9ncmFtSW5mb0xvYWRlciA9XG4gICAgKGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSwgYXR0cmlidXRlczogSW1hZ2VTY2FsZXJBdHRyaWJ1dGVzKTogUHJvZ3JhbUluZm9Mb2FkZXIgPT4ge1xuICAgICAgY29uc3QgbWV0YWRhdGEgPSB7Li4uaW1hZ2VTY2FsZXJQcm9ncmFtTWV0YWRhdGEsIGNhY2hlSGludDogYXR0cmlidXRlcy5jYWNoZUtleX07XG4gICAgICByZXR1cm4gey4uLm1ldGFkYXRhLCBnZXQ6ICgpID0+IGNyZWF0ZUltYWdlU2NhbGVyUHJvZ3JhbUluZm8oaGFuZGxlciwgbWV0YWRhdGEsIGlucHV0cywgYXR0cmlidXRlcyl9O1xuICAgIH07XG5cbmNvbnN0IGNyZWF0ZUdldEJpYXNNZXRob2QgPSAobnVtQ2hhbm5lbHM6IG51bWJlcik6IHN0cmluZyA9PiB7XG4gIGNvbnN0IGNvZGVMaW5lczogc3RyaW5nW10gPSBbYGZsb2F0IGdldEJpYXMoZmxvYXQgYmlhc1ske251bUNoYW5uZWxzfV0sIGludCBjaGFubmVsKSB7YF07XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtQ2hhbm5lbHM7ICsraSkge1xuICAgIGlmIChpID09PSAwKSB7XG4gICAgICBjb2RlTGluZXMucHVzaChcbiAgICAgICAgICAnXFx0JyArXG4gICAgICAgICAgYGlmIChjaGFubmVsID09ICR7aX0pIHsgcmV0dXJuIGJpYXNbJHtpfV07IH1gKTtcbiAgICB9IGVsc2UgaWYgKGkgPT09IG51bUNoYW5uZWxzIC0gMSkge1xuICAgICAgY29kZUxpbmVzLnB1c2goXG4gICAgICAgICAgJ1xcdCcgK1xuICAgICAgICAgIGBlbHNlIHsgcmV0dXJuIGJpYXNbJHtpfV07IH1gKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29kZUxpbmVzLnB1c2goXG4gICAgICAgICAgJ1xcdCcgK1xuICAgICAgICAgIGBlbHNlIGlmIChjaGFubmVsID09ICR7aX0pIHsgcmV0dXJuIGJpYXNbJHtpfV07IH1gKTtcbiAgICB9XG4gIH1cbiAgY29kZUxpbmVzLnB1c2goXG4gICAgICAnXFx0JyArXG4gICAgICAnfScpO1xuICByZXR1cm4gY29kZUxpbmVzLmpvaW4oJ1xcbicpO1xufTtcblxuY29uc3QgdmFsaWRhdGVJbnB1dHMgPSAoaW5wdXRzOiBUZW5zb3JbXSk6IHZvaWQgPT4ge1xuICBpZiAoIWlucHV0cyB8fCBpbnB1dHMubGVuZ3RoICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbWFnZVNjYWxlciByZXF1aXJlcyAxIGlucHV0LicpO1xuICB9XG4gIGlmIChpbnB1dHNbMF0uZGltcy5sZW5ndGggIT09IDQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW5wdXQgc2hhcGUuJyk7XG4gIH1cbiAgaWYgKGlucHV0c1swXS50eXBlICE9PSAnZmxvYXQzMicgJiYgaW5wdXRzWzBdLnR5cGUgIT09ICdmbG9hdDY0Jykge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpbnB1dCB0eXBlLicpO1xuICB9XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0dyYXBofSBmcm9tICcuLi8uLi8uLi9ncmFwaCc7XG5pbXBvcnQge09wZXJhdG9ySW1wbGVtZW50YXRpb24sIE9wZXJhdG9ySW5pdGlhbGl6YXRpb259IGZyb20gJy4uLy4uLy4uL29wZXJhdG9ycyc7XG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi4vLi4vLi4vdGVuc29yJztcbmltcG9ydCB7Z2V0R2xzbH0gZnJvbSAnLi4vZ2xzbC1zb3VyY2UnO1xuaW1wb3J0IHtXZWJHTEluZmVyZW5jZUhhbmRsZXJ9IGZyb20gJy4uL2luZmVyZW5jZS1oYW5kbGVyJztcbmltcG9ydCB7UHJvZ3JhbUluZm8sIFByb2dyYW1JbmZvTG9hZGVyLCBQcm9ncmFtTWV0YWRhdGEsIFRleHR1cmVUeXBlfSBmcm9tICcuLi90eXBlcyc7XG5cbmV4cG9ydCBjb25zdCBpbnN0YW5jZU5vcm1hbGl6YXRpb246IE9wZXJhdG9ySW1wbGVtZW50YXRpb248bnVtYmVyPiA9XG4gICAgKGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSwgZXBzaWxvbjogbnVtYmVyKTogVGVuc29yW10gPT4ge1xuICAgICAgdmFsaWRhdGVJbnB1dHMoaW5wdXRzKTtcblxuICAgICAgY29uc3QgbWVhbkFuZFZhcmlhbmNlID0gaW5mZXJlbmNlSGFuZGxlci5ydW4oY3JlYXRlTWVhbkFuZFZhcmlhbmNlUHJvZ3JhbUluZm9Mb2FkZXIoaW5wdXRzWzBdKSwgaW5wdXRzKTtcbiAgICAgIGNvbnN0IG91dHB1dCA9IGluZmVyZW5jZUhhbmRsZXIucnVuKFxuICAgICAgICAgIGNyZWF0ZUNvbXB1dGVPdXRwdXRQcm9ncmFtSW5mb0xvYWRlcihpbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHNbMF0sIGVwc2lsb24sIG1lYW5BbmRWYXJpYW5jZS5kaW1zKSxcbiAgICAgICAgICBbaW5wdXRzWzBdLCBtZWFuQW5kVmFyaWFuY2UsIGlucHV0c1sxXSwgaW5wdXRzWzJdXSk7XG4gICAgICByZXR1cm4gW291dHB1dF07XG4gICAgfTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlSW5zdGFuY2VOb3JtYWxpemF0aW9uQXR0cmlidXRlczogT3BlcmF0b3JJbml0aWFsaXphdGlvbjxudW1iZXI+ID0gKG5vZGU6IEdyYXBoLk5vZGUpOiBudW1iZXIgPT5cbiAgICBub2RlLmF0dHJpYnV0ZXMuZ2V0RmxvYXQoJ2Vwc2lsb24nLCAxZS01KTtcblxuY29uc3QgbWVhbkFuZFZhcmlhbmNlUHJvZ3JhbU1ldGFkYXRhID0ge1xuICBuYW1lOiAnSW5zdGFuY2VOb3JtYWxpemF0aW9uX01lYW5BbmRWYXJpYW5jZScsXG4gIGlucHV0TmFtZXM6IFsnWCddLFxuICBpbnB1dFR5cGVzOiBbVGV4dHVyZVR5cGUudW5wYWNrZWRdLFxufTtcblxuY29uc3QgY3JlYXRlTWVhbkFuZFZhcmlhbmNlUHJvZ3JhbUluZm8gPSAobWV0YWRhdGE6IFByb2dyYW1NZXRhZGF0YSwgaW5wdXQ6IFRlbnNvcik6IFByb2dyYW1JbmZvID0+IHtcbiAgY29uc3QgeERpbXMgPSBpbnB1dC5kaW1zLnNsaWNlKCk7XG4gIGNvbnN0IGNoYW5uZWwgPSB4RGltc1sxXTtcbiAgY29uc3QgY2hhbm5lbFNpemUgPSB4RGltc1syXSAqIHhEaW1zWzNdO1xuICBjb25zdCBvdXRwdXRTaGFwZSA9IFt4RGltc1swXSwgY2hhbm5lbF07XG5cbiAgY29uc3Qgc2hhZGVyU291cmNlID0gYFxuICAgICAgdmVjNCBwcm9jZXNzKGludFsyXSBpbmRpY2VzKSB7XG4gICAgICAgIHZlYzQgdiA9IHZlYzQoMC4wKTtcbiAgICAgICAgaW50IGFbNF07XG4gICAgICAgIGFbMF0gPSBpbmRpY2VzWzBdO1xuICAgICAgICBhWzFdID0gaW5kaWNlc1sxXTtcbiAgICAgICAgZmxvYXQgdGVtcCA9IDAuMDtcbiAgICAgICAgZm9yKGludCBhMj0wOyBhMjwke3hEaW1zWzJdfTsgYTIrKykge1xuICAgICAgICAgIGFbMl0gPSBhMjtcbiAgICAgICAgICBmb3IoaW50IGEzPTA7IGEzPCR7eERpbXNbM119OyBhMysrKSB7XG4gICAgICAgICAgICBhWzNdID0gYTM7XG4gICAgICAgICAgICBmbG9hdCB4ID0gX1goYSk7XG4gICAgICAgICAgICB0ZW1wICs9IHg7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZsb2F0IG1lYW4gPSB0ZW1wIC8gZmxvYXQoJHtjaGFubmVsU2l6ZX0pO1xuICAgICAgICB0ZW1wID0gMC4wO1xuICAgICAgICBmb3IoaW50IGEyPTA7IGEyPCR7eERpbXNbMl19OyBhMisrKSB7XG4gICAgICAgICAgYVsyXSA9IGEyO1xuICAgICAgICAgIGZvcihpbnQgYTM9MDsgYTM8JHt4RGltc1szXX07IGEzKyspIHtcbiAgICAgICAgICAgIGFbM10gPSBhMztcbiAgICAgICAgICAgIGZsb2F0IHggPSBfWChhKTtcbiAgICAgICAgICAgIHRlbXAgKz0gKHggLSBtZWFuKSAqICh4IC0gbWVhbik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHYuciA9IG1lYW47XG4gICAgICAgIHYuZyA9IHRlbXAgLyBmbG9hdCgke2NoYW5uZWxTaXplfSk7XG5cbiAgICAgICAgcmV0dXJuIHY7XG4gICAgICB9YDtcbiAgcmV0dXJuIHtcbiAgICAuLi5tZXRhZGF0YSxcbiAgICBvdXRwdXQ6IHtkaW1zOiBvdXRwdXRTaGFwZSwgdHlwZTogaW5wdXQudHlwZSwgdGV4dHVyZVR5cGU6IFRleHR1cmVUeXBlLnBhY2tlZExhc3REaW1lbnNpb259LFxuICAgIHNoYWRlclNvdXJjZVxuICB9O1xufTtcblxuY29uc3QgY3JlYXRlTWVhbkFuZFZhcmlhbmNlUHJvZ3JhbUluZm9Mb2FkZXIgPSAoaW5wdXQ6IFRlbnNvcik6IFByb2dyYW1JbmZvTG9hZGVyID0+ICh7XG4gIC4uLm1lYW5BbmRWYXJpYW5jZVByb2dyYW1NZXRhZGF0YSxcbiAgZ2V0OiAoKSA9PiBjcmVhdGVNZWFuQW5kVmFyaWFuY2VQcm9ncmFtSW5mbyhtZWFuQW5kVmFyaWFuY2VQcm9ncmFtTWV0YWRhdGEsIGlucHV0KVxufSk7XG5cbmNvbnN0IGNvbXB1dGVPdXRwdXRQcm9ncmFtTWV0YWRhdGEgPSB7XG4gIG5hbWU6ICdJbnN0YW5jZU5vcm1hbGl6YXRpb25fQ29tcHV0ZU91dHB1dCcsXG4gIGlucHV0TmFtZXM6IFsnWCcsICdNZWFuQW5kVmFyaWFuY2UnLCAnU2NhbGUnLCAnQiddLFxuICBpbnB1dFR5cGVzOiBbVGV4dHVyZVR5cGUudW5wYWNrZWQsIFRleHR1cmVUeXBlLnBhY2tlZExhc3REaW1lbnNpb24sIFRleHR1cmVUeXBlLnVucGFja2VkLCBUZXh0dXJlVHlwZS51bnBhY2tlZF0sXG59O1xuXG5jb25zdCBjcmVhdGVDb21wdXRlT3V0cHV0UHJvZ3JhbUluZm8gPVxuICAgIChpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIG1ldGFkYXRhOiBQcm9ncmFtTWV0YWRhdGEsIGlucHV0OiBUZW5zb3IsIGVwc2lsb246IG51bWJlcixcbiAgICAgbWVhbkFuZFZhcmlhbmNlU2hhcGU6IHJlYWRvbmx5IG51bWJlcltdKTogUHJvZ3JhbUluZm8gPT4ge1xuICAgICAgY29uc3QgZ2xzbCA9IGdldEdsc2woaW5mZXJlbmNlSGFuZGxlci5zZXNzaW9uLmJhY2tlbmQuZ2xDb250ZXh0LnZlcnNpb24pO1xuICAgICAgY29uc3QgW3RleHR1cmVXaWR0aCwgdGV4dHVyZUhlaWdodF0gPVxuICAgICAgICAgIGluZmVyZW5jZUhhbmRsZXIuY2FsY3VsYXRlVGV4dHVyZVdpZHRoQW5kSGVpZ2h0KG1lYW5BbmRWYXJpYW5jZVNoYXBlLCBUZXh0dXJlVHlwZS5wYWNrZWRMYXN0RGltZW5zaW9uKTtcbiAgICAgIGNvbnN0IFttZWFuQW5kVmFyaWFuY2VXaWR0aCwgbWVhbkFuZFZhcmlhbmNlSGVpZ2h0XSA9IFt0ZXh0dXJlV2lkdGggLyA0LCB0ZXh0dXJlSGVpZ2h0XTtcbiAgICAgIGNvbnN0IHNoYWRlclNvdXJjZSA9IGBcbiAgICAgIHZlYzQgZ2V0X01lYW5BbmRWYXJpYW5jZShpbnRbMl0gbXYpIHtcbiAgICAgICAgaW50IG9mZnNldCA9IGluZGljZXNUb09mZnNldF9NZWFuQW5kVmFyaWFuY2UobXYpO1xuICAgICAgICB2ZWMyIGNvb3JkcyA9IG9mZnNldFRvQ29vcmRzKG9mZnNldCwgJHttZWFuQW5kVmFyaWFuY2VXaWR0aH0sICR7bWVhbkFuZFZhcmlhbmNlSGVpZ2h0fSk7XG4gICAgICAgIHJldHVybiAke2dsc2wudGV4dHVyZTJEfShNZWFuQW5kVmFyaWFuY2UsIGNvb3Jkcyk7XG4gICAgICB9XG5cbiAgICAgIGZsb2F0IHByb2Nlc3MoaW50WzRdIGluZGljZXMpIHtcbiAgICAgICAgaW50IG12WzJdO1xuICAgICAgICBtdlswXSA9IGluZGljZXNbMF07XG4gICAgICAgIG12WzFdID0gaW5kaWNlc1sxXTtcbiAgICAgICAgdmVjNCBtZWFuX2FuZF92YXJpYW5jZSA9IGdldF9NZWFuQW5kVmFyaWFuY2UobXYpO1xuICAgICAgICBmbG9hdCBtZWFuID0gbWVhbl9hbmRfdmFyaWFuY2UucjtcbiAgICAgICAgZmxvYXQgdmFyaWFuY2UgPSBtZWFuX2FuZF92YXJpYW5jZS5nO1xuXG4gICAgICAgIGludCBzYlsxXTtcbiAgICAgICAgc2JbMF0gPSBpbmRpY2VzWzFdO1xuICAgICAgICBmbG9hdCBzY2FsZSA9IF9TY2FsZShzYik7XG4gICAgICAgIGZsb2F0IGIgPSBfQihzYik7XG5cbiAgICAgICAgcmV0dXJuIHNjYWxlICogKF9YKGluZGljZXMpIC0gbWVhbikgLyBzcXJ0KHZhcmlhbmNlICsgZXBzaWxvbikgKyBiO1xuICAgICAgfWA7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5tZXRhZGF0YSxcbiAgICAgICAgb3V0cHV0OiB7ZGltczogaW5wdXQuZGltcywgdHlwZTogaW5wdXQudHlwZSwgdGV4dHVyZVR5cGU6IFRleHR1cmVUeXBlLnVucGFja2VkfSxcbiAgICAgICAgdmFyaWFibGVzOiBbe25hbWU6ICdlcHNpbG9uJywgdHlwZTogJ2Zsb2F0JywgZGF0YTogZXBzaWxvbn1dLFxuICAgICAgICBzaGFkZXJTb3VyY2VcbiAgICAgIH07XG4gICAgfTtcblxuY29uc3QgY3JlYXRlQ29tcHV0ZU91dHB1dFByb2dyYW1JbmZvTG9hZGVyID1cbiAgICAoaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dDogVGVuc29yLCBlcHNpbG9uOiBudW1iZXIsIG1lYW5BbmRWYXJpYW5jZVNoYXBlOiByZWFkb25seSBudW1iZXJbXSk6XG4gICAgICAgIFByb2dyYW1JbmZvTG9hZGVyID0+IHtcbiAgICAgICAgICBjb25zdCBtZXRhZGF0YSA9IHsuLi5jb21wdXRlT3V0cHV0UHJvZ3JhbU1ldGFkYXRhLCBjYWNoZUhpbnQ6IGAke2Vwc2lsb259YH07XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLm1ldGFkYXRhLFxuICAgICAgICAgICAgZ2V0OiAoKSA9PiBjcmVhdGVDb21wdXRlT3V0cHV0UHJvZ3JhbUluZm8oaW5mZXJlbmNlSGFuZGxlciwgbWV0YWRhdGEsIGlucHV0LCBlcHNpbG9uLCBtZWFuQW5kVmFyaWFuY2VTaGFwZSlcbiAgICAgICAgICB9O1xuICAgICAgICB9O1xuXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IFRlbnNvcltdKTogdm9pZCA9PiB7XG4gIGlmICghaW5wdXRzIHx8IGlucHV0cy5sZW5ndGggIT09IDMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0luc3RhbmNlTm9ybWFsaXphdGlvbiByZXF1aXJlcyAzIGlucHV0cy4nKTtcbiAgfVxuXG4gIGNvbnN0IFggPSBpbnB1dHNbMF07XG4gIGNvbnN0IHNjYWxlID0gaW5wdXRzWzFdO1xuICBjb25zdCBCID0gaW5wdXRzWzJdO1xuXG4gIC8vIGlucHV0IHNob3VsZCBhdCBsZWFzdCBoYXZlIHRocmVlIGRpbWVuc2lvbnMgLSBOLEMsZGltMSwuLi4sZGltblxuICAvLyBvdGhlciBpbnB1dHMgY2FuIGhhdmUgb25seSBvbmUgZGltZW5zaW9uc1xuICBpZiAoWC5kaW1zLmxlbmd0aCA8IDMgfHwgc2NhbGUuZGltcy5sZW5ndGggIT09IDEgfHwgQi5kaW1zLmxlbmd0aCAhPT0gMSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpbnB1dCBzaGFwZS4nKTtcbiAgfVxuICBpZiAoc2NhbGUuZGltc1swXSAhPT0gWC5kaW1zWzFdIHx8IEIuZGltc1swXSAhPT0gWC5kaW1zWzFdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBzaGFwZXMgYXJlIG1pc21hdGNoZWQuJyk7XG4gIH1cbiAgaWYgKChYLnR5cGUgIT09ICdmbG9hdDMyJyAmJiBYLnR5cGUgIT09ICdmbG9hdDY0JykgfHwgKHNjYWxlLnR5cGUgIT09ICdmbG9hdDMyJyAmJiBzY2FsZS50eXBlICE9PSAnZmxvYXQ2NCcpIHx8XG4gICAgICAoQi50eXBlICE9PSAnZmxvYXQzMicgJiYgQi50eXBlICE9PSAnZmxvYXQ2NCcpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGlucHV0IHR5cGUuJyk7XG4gIH1cbiAgaWYgKGlucHV0c1swXS5kaW1zLmxlbmd0aCAhPT0gNCkge1xuICAgIHRocm93IG5ldyBFcnJvcignT25seSBzdXBwb3J0IDQtRCBpbnB1dCBzaGFwZS4nKTtcbiAgfVxufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtBdHRyaWJ1dGVXaXRoQ2FjaGVLZXksIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleX0gZnJvbSAnLi4vLi4vLi4vYXR0cmlidXRlLXdpdGgtY2FjaGUta2V5JztcbmltcG9ydCB7R3JhcGh9IGZyb20gJy4uLy4uLy4uL2dyYXBoJztcbmltcG9ydCB7T3BlcmF0b3JJbXBsZW1lbnRhdGlvbiwgT3BlcmF0b3JJbml0aWFsaXphdGlvbn0gZnJvbSAnLi4vLi4vLi4vb3BlcmF0b3JzJztcbmltcG9ydCB7VGVuc29yfSBmcm9tICcuLi8uLi8uLi90ZW5zb3InO1xuaW1wb3J0IHtXZWJHTEluZmVyZW5jZUhhbmRsZXJ9IGZyb20gJy4uL2luZmVyZW5jZS1oYW5kbGVyJztcbmltcG9ydCB7UHJvZ3JhbUluZm8sIFByb2dyYW1JbmZvTG9hZGVyLCBUZXh0dXJlVHlwZX0gZnJvbSAnLi4vdHlwZXMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIExybkF0dHJpYnV0ZXMgZXh0ZW5kcyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkge1xuICBhbHBoYTogbnVtYmVyO1xuICBiZXRhOiBudW1iZXI7XG4gIGJpYXM6IG51bWJlcjtcbiAgc2l6ZTogbnVtYmVyO1xufVxuXG5leHBvcnQgY29uc3QgbHJuOiBPcGVyYXRvckltcGxlbWVudGF0aW9uPExybkF0dHJpYnV0ZXM+ID1cbiAgICAoaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdLCBhdHRyaWJ1dGVzOiBMcm5BdHRyaWJ1dGVzKTogVGVuc29yW10gPT4ge1xuICAgICAgdmFsaWRhdGVJbnB1dHMoaW5wdXRzKTtcblxuICAgICAgLy8gaWYgKGluZmVyZW5jZUhhbmRsZXIuc2Vzc2lvbi5wYWNrKSB7XG4gICAgICAvLyAgIHJldHVybiBbaW5mZXJlbmNlSGFuZGxlci5ydW4oY3JlYXRlUGFja2VkTHJuUHJvZ3JhbUluZm9Mb2FkZXIoaW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzLCBhdHRyaWJ1dGVzKSxcbiAgICAgIC8vICAgaW5wdXRzKV07XG4gICAgICAvLyB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFtpbmZlcmVuY2VIYW5kbGVyLnJ1bihjcmVhdGVMcm5Qcm9ncmFtSW5mb0xvYWRlcihpbnB1dHMsIGF0dHJpYnV0ZXMpLCBpbnB1dHMpXTtcbiAgICAgIC8vfVxuICAgIH07XG5cbmV4cG9ydCBjb25zdCBwYXJzZUxybkF0dHJpYnV0ZXM6IE9wZXJhdG9ySW5pdGlhbGl6YXRpb248THJuQXR0cmlidXRlcz4gPSAobm9kZTogR3JhcGguTm9kZSk6IExybkF0dHJpYnV0ZXMgPT4ge1xuICBjb25zdCBhbHBoYSA9IG5vZGUuYXR0cmlidXRlcy5nZXRGbG9hdCgnYWxwaGEnLCAwLjAwMDEpO1xuICBjb25zdCBiZXRhID0gbm9kZS5hdHRyaWJ1dGVzLmdldEZsb2F0KCdiZXRhJywgMC43NSk7XG4gIGNvbnN0IGJpYXMgPSBub2RlLmF0dHJpYnV0ZXMuZ2V0RmxvYXQoJ2JpYXMnLCAxLjApO1xuICBjb25zdCBzaXplID0gbm9kZS5hdHRyaWJ1dGVzLmdldEludCgnc2l6ZScpO1xuXG4gIHJldHVybiBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkoe2FscGhhLCBiZXRhLCBiaWFzLCBzaXplfSk7XG59O1xuXG5jb25zdCBscm5Qcm9ncmFtTWV0YWRhdGEgPSB7XG4gIG5hbWU6ICdMUk4nLFxuICBpbnB1dE5hbWVzOiBbJ1gnXSxcbiAgaW5wdXRUeXBlczogW1RleHR1cmVUeXBlLnVucGFja2VkXVxufTtcblxuZnVuY3Rpb24gY3JlYXRlTHJuUHJvZ3JhbUluZm8oaW5wdXRzOiBUZW5zb3JbXSwgYXR0cmlidXRlczogTHJuQXR0cmlidXRlcyk6IFByb2dyYW1JbmZvIHtcbiAgY29uc3QgQyA9IGlucHV0c1swXS5kaW1zWzFdO1xuICBjb25zdCByYW5rID0gaW5wdXRzWzBdLmRpbXMubGVuZ3RoO1xuICBjb25zdCBmcm9tID0gLU1hdGguZmxvb3IoKGF0dHJpYnV0ZXMuc2l6ZSAtIDEpIC8gMik7XG4gIGNvbnN0IHRvID0gTWF0aC5jZWlsKChhdHRyaWJ1dGVzLnNpemUgLSAxKSAvIDIpO1xuICBjb25zdCBhbHBoYSA9IGBmbG9hdCgke2F0dHJpYnV0ZXMuYWxwaGF9KSAvIGZsb2F0KCR7YXR0cmlidXRlcy5zaXplfSlgO1xuICBjb25zdCBiaWFzID0gYGZsb2F0KCR7YXR0cmlidXRlcy5iaWFzfSlgO1xuICBjb25zdCBiZXRhID0gYGZsb2F0KCR7YXR0cmlidXRlcy5iZXRhfSlgO1xuXG4gIGNvbnN0IHNoYWRlclNvdXJjZSA9IGBcbiAgICBmbG9hdCBwcm9jZXNzKGludCBpbmRpY2VzWyR7cmFua31dKSB7XG4gICAgICAgIGludCBjID0gaW5kaWNlc1sxXTtcbiAgICAgICAgZmxvYXQgeCA9IF9YKGluZGljZXMpO1xuICAgICAgICBmbG9hdCBzcXVhcmVfc3VtID0gMC4wO1xuXG4gICAgICAgIGZvciAoaW50IGkgPSAke2Zyb219OyBpIDw9ICR7dG99OyBpKyspIHtcbiAgICAgICAgICBpbnQgaWR4ID0gYyArIGk7XG4gICAgICAgICAgaWYgKGMgPj0gMCAmJiBjIDwgJHtDfSkge1xuICAgICAgICAgICAgaW5kaWNlc1sxXSA9IGlkeDtcbiAgICAgICAgICAgIGZsb2F0IGogPSBfWChpbmRpY2VzKTtcbiAgICAgICAgICAgIHNxdWFyZV9zdW0gKz0gaiAqIGo7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB4IC8gcG93KCR7Ymlhc30gKyAke2FscGhhfSAqIHNxdWFyZV9zdW0sICR7YmV0YX0pO1xuICAgIH1gO1xuICByZXR1cm4ge1xuICAgIC4uLmxyblByb2dyYW1NZXRhZGF0YSxcbiAgICBjYWNoZUhpbnQ6IGF0dHJpYnV0ZXMuY2FjaGVLZXksXG4gICAgb3V0cHV0OiB7ZGltczogaW5wdXRzWzBdLmRpbXMsIHR5cGU6IGlucHV0c1swXS50eXBlLCB0ZXh0dXJlVHlwZTogVGV4dHVyZVR5cGUudW5wYWNrZWR9LFxuICAgIHNoYWRlclNvdXJjZSxcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUxyblByb2dyYW1JbmZvTG9hZGVyKGlucHV0czogVGVuc29yW10sIGF0dHJpYnV0ZXM6IExybkF0dHJpYnV0ZXMpOiBQcm9ncmFtSW5mb0xvYWRlciB7XG4gIHJldHVybiB7Li4ubHJuUHJvZ3JhbU1ldGFkYXRhLCBjYWNoZUhpbnQ6IGF0dHJpYnV0ZXMuY2FjaGVLZXksIGdldDogKCkgPT4gY3JlYXRlTHJuUHJvZ3JhbUluZm8oaW5wdXRzLCBhdHRyaWJ1dGVzKX07XG59XG5cbmNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogVGVuc29yW10pOiB2b2lkID0+IHtcbiAgaWYgKCFpbnB1dHMgfHwgaW5wdXRzLmxlbmd0aCAhPT0gMSkge1xuICAgIHRocm93IG5ldyBFcnJvcignTFJOIHJlcXVpcmVzIDEgaW5wdXQuJyk7XG4gIH1cbiAgaWYgKGlucHV0c1swXS5kaW1zLmxlbmd0aCAhPT0gNCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY3VycmVudGx5IG9ubHkgc3VwcG9ydCBMUk4gZm9yIGlucHV0IHdpdGggXCJOQ0hXXCIgZm9ybWF0Jyk7XG4gIH1cbiAgaWYgKGlucHV0c1swXS50eXBlICE9PSAnZmxvYXQzMicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2lucHV0IHNob3VsZCBiZSBmbG9hdCB0eXBlJyk7XG4gIH1cbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7QXR0cmlidXRlV2l0aENhY2hlS2V5LCBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXl9IGZyb20gJy4uLy4uLy4uL2F0dHJpYnV0ZS13aXRoLWNhY2hlLWtleSc7XG5pbXBvcnQge0dyYXBofSBmcm9tICcuLi8uLi8uLi9ncmFwaCc7XG5pbXBvcnQge09wZXJhdG9ySW1wbGVtZW50YXRpb24sIE9wZXJhdG9ySW5pdGlhbGl6YXRpb259IGZyb20gJy4uLy4uLy4uL29wZXJhdG9ycyc7XG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi4vLi4vLi4vdGVuc29yJztcbmltcG9ydCB7U2hhcGVVdGlsfSBmcm9tICcuLi8uLi8uLi91dGlsJztcbmltcG9ydCB7Z2V0R2xzbCwgR2xzbH0gZnJvbSAnLi4vZ2xzbC1zb3VyY2UnO1xuaW1wb3J0IHtXZWJHTEluZmVyZW5jZUhhbmRsZXJ9IGZyb20gJy4uL2luZmVyZW5jZS1oYW5kbGVyJztcbmltcG9ydCB7UHJvZ3JhbUluZm8sIFRleHR1cmVUeXBlfSBmcm9tICcuLi90eXBlcyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUGFkQXR0cmlidXRlcyBleHRlbmRzIEF0dHJpYnV0ZVdpdGhDYWNoZUtleSB7XG4gIHJlYWRvbmx5IG1vZGU6IHN0cmluZztcbiAgcmVhZG9ubHkgcGFkczogbnVtYmVyW107XG4gIHJlYWRvbmx5IHZhbHVlOiBudW1iZXI7XG59XG5cbmNvbnN0IHBhZFByb2dyYW1NZXRhZGF0YSA9IHtcbiAgbmFtZTogJ1BhZCcsXG4gIGlucHV0TmFtZXM6IFsnQSddLFxuICBpbnB1dFR5cGVzOiBbVGV4dHVyZVR5cGUudW5wYWNrZWRdLFxufTtcblxuZXhwb3J0IGNvbnN0IHBhZFYyOiBPcGVyYXRvckltcGxlbWVudGF0aW9uPFBhZEF0dHJpYnV0ZXM+ID1cbiAgICAoaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdLCBhdHRyaWJ1dGVzOiBQYWRBdHRyaWJ1dGVzKTogVGVuc29yW10gPT4ge1xuICAgICAgdmFsaWRhdGVJbnB1dHNWMihpbnB1dHMpO1xuICAgICAgY29uc3Qgb3V0cHV0ID0gaW5mZXJlbmNlSGFuZGxlci5ydW4oXG4gICAgICAgICAge1xuICAgICAgICAgICAgLi4ucGFkUHJvZ3JhbU1ldGFkYXRhLFxuICAgICAgICAgICAgY2FjaGVIaW50OiBhdHRyaWJ1dGVzLmNhY2hlS2V5LFxuICAgICAgICAgICAgZ2V0OiAoKSA9PiBjcmVhdGVQYWRQcm9ncmFtSW5mbyhpbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHNbMF0sIGF0dHJpYnV0ZXMpXG4gICAgICAgICAgfSxcbiAgICAgICAgICBpbnB1dHMpO1xuICAgICAgcmV0dXJuIFtvdXRwdXRdO1xuICAgIH07XG5cbmV4cG9ydCBjb25zdCBwYXJzZVBhZEF0dHJpYnV0ZXNWMjogT3BlcmF0b3JJbml0aWFsaXphdGlvbjxQYWRBdHRyaWJ1dGVzPiA9IChub2RlOiBHcmFwaC5Ob2RlKTogUGFkQXR0cmlidXRlcyA9PiB7XG4gIGNvbnN0IG1vZGUgPSBub2RlLmF0dHJpYnV0ZXMuZ2V0U3RyaW5nKCdtb2RlJywgJ2NvbnN0YW50Jyk7XG4gIGNvbnN0IHZhbHVlID0gbm9kZS5hdHRyaWJ1dGVzLmdldEZsb2F0KCd2YWx1ZScsIDAuMCk7XG4gIGNvbnN0IHBhZHMgPSBub2RlLmF0dHJpYnV0ZXMuZ2V0SW50cygncGFkcycpO1xuICByZXR1cm4gY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KHttb2RlLCB2YWx1ZSwgcGFkc30pO1xufTtcblxuZXhwb3J0IGNvbnN0IHBhZFYxMTogT3BlcmF0b3JJbXBsZW1lbnRhdGlvbjxzdHJpbmc+ID1cbiAgICAoaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdLCBtb2RlOiBzdHJpbmcpOiBUZW5zb3JbXSA9PiB7XG4gICAgICB2YWxpZGF0ZUlucHV0c1YxMShpbnB1dHMpO1xuICAgICAgY29uc3QgYXR0cnVidXRlcyA9IGdlbmVyYXRlUGFkQXR0cmlidXRlc0Zyb21JbnB1dHMoaW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzLCBtb2RlKTtcbiAgICAgIHJldHVybiBwYWRWMihpbmZlcmVuY2VIYW5kbGVyLCBbaW5wdXRzWzBdXSwgYXR0cnVidXRlcyk7XG4gICAgfTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlUGFkQXR0cmlidXRlc1YxMTogT3BlcmF0b3JJbml0aWFsaXphdGlvbjxzdHJpbmc+ID0gKG5vZGU6IEdyYXBoLk5vZGUpOiBzdHJpbmcgPT5cbiAgICBub2RlLmF0dHJpYnV0ZXMuZ2V0U3RyaW5nKCdtb2RlJywgJ2NvbnN0YW50Jyk7XG5cbmNvbnN0IGdlbmVyYXRlUGFkQXR0cmlidXRlc0Zyb21JbnB1dHMgPVxuICAgIChpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10sIG1vZGU6IHN0cmluZyk6IFBhZEF0dHJpYnV0ZXMgPT4ge1xuICAgICAgaWYgKCFpbmZlcmVuY2VIYW5kbGVyLnNlc3Npb24uaXNJbml0aWFsaXplcihpbnB1dHNbMV0uZGF0YUlkKSB8fFxuICAgICAgICAgIChpbnB1dHMubGVuZ3RoID49IDMgJiYgIWluZmVyZW5jZUhhbmRsZXIuc2Vzc2lvbi5pc0luaXRpYWxpemVyKGlucHV0c1syXS5kYXRhSWQpKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2R5bmFtaWMgcGFkIGF0dHJpYnV0ZXMgYXJlIG5vdCBhbGxvd2VkJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHBhZHMgPSBBcnJheS5mcm9tKGlucHV0c1sxXS5pbnRlZ2VyRGF0YSk7XG4gICAgICBjb25zdCB2YWx1ZSA9IChpbnB1dHMubGVuZ3RoID49IDMpID8gaW5wdXRzWzJdLmZsb2F0RGF0YVswXSA6IDAuMDtcblxuICAgICAgcmV0dXJuIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSh7bW9kZSwgcGFkcywgdmFsdWV9KTtcbiAgICB9O1xuXG5jb25zdCBjcmVhdGVQYWRQcm9ncmFtSW5mbyA9XG4gICAgKGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXQ6IFRlbnNvciwgYXR0cmlidXRlczogUGFkQXR0cmlidXRlcyk6IFByb2dyYW1JbmZvID0+IHtcbiAgICAgIGNvbnN0IG91dHB1dFNoYXBlID0gU2hhcGVVdGlsLnBhZFNoYXBlKGlucHV0LmRpbXMuc2xpY2UoKSwgYXR0cmlidXRlcy5wYWRzKTtcbiAgICAgIGNvbnN0IHJhbmsgPSBvdXRwdXRTaGFwZS5sZW5ndGg7XG4gICAgICBjb25zdCBwYWRGdW5jdGlvbiA9IGdldFBhZEZ1bmN0aW9uKGluZmVyZW5jZUhhbmRsZXIsIGlucHV0LCBhdHRyaWJ1dGVzKTtcbiAgICAgIGNvbnN0IHNoYWRlclNvdXJjZSA9IGBcbiAgICAgICR7cGFkRnVuY3Rpb259XG4gICAgICBmbG9hdCBwcm9jZXNzKGludFske3Jhbmt9XSBpbmRpY2VzKSB7XG4gICAgICAgICAgcmV0dXJuIHBhZEEoaW5kaWNlcyk7XG4gICAgICB9YDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6ICdQYWQnLFxuICAgICAgICBpbnB1dE5hbWVzOiBbJ0EnXSxcbiAgICAgICAgaW5wdXRUeXBlczogW1RleHR1cmVUeXBlLnVucGFja2VkXSxcbiAgICAgICAgb3V0cHV0OiB7ZGltczogb3V0cHV0U2hhcGUsIHR5cGU6IGlucHV0LnR5cGUsIHRleHR1cmVUeXBlOiBUZXh0dXJlVHlwZS51bnBhY2tlZH0sXG4gICAgICAgIHNoYWRlclNvdXJjZVxuICAgICAgfTtcbiAgICB9O1xuXG5jb25zdCB2YWxpZGF0ZUlucHV0c1YyID0gKGlucHV0czogVGVuc29yW10pOiB2b2lkID0+IHtcbiAgaWYgKCFpbnB1dHMgfHwgaW5wdXRzLmxlbmd0aCAhPT0gMSkge1xuICAgIHRocm93IG5ldyBFcnJvcignUGFkIHJlcXVpcmVzIDEgaW5wdXQnKTtcbiAgfVxuICBpZiAoaW5wdXRzWzBdLnR5cGUgIT09ICdmbG9hdDMyJyAmJiBpbnB1dHNbMF0udHlwZSAhPT0gJ2Zsb2F0NjQnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGlucHV0IHR5cGUuJyk7XG4gIH1cbn07XG5cbmNvbnN0IHZhbGlkYXRlSW5wdXRzVjExID0gKGlucHV0czogVGVuc29yW10pOiB2b2lkID0+IHtcbiAgaWYgKCFpbnB1dHMgfHwgKGlucHV0cy5sZW5ndGggIT09IDIgJiYgaW5wdXRzLmxlbmd0aCAhPT0gMykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhZCByZXF1aXJlcyAyIG9yIDMgaW5wdXRzJyk7XG4gIH1cbiAgaWYgKGlucHV0c1sxXS50eXBlICE9PSAnaW50MzInKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGlucHV0IHR5cGUuJyk7XG4gIH1cbiAgaWYgKGlucHV0cy5sZW5ndGggPj0gMyAmJiBpbnB1dHNbMl0udHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW5wdXQgdHlwZS4nKTtcbiAgfVxufTtcblxuY29uc3QgZ2V0UGFkRnVuY3Rpb24gPSAoaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dDogVGVuc29yLCBhdHRyaWJ1dGVzOiBQYWRBdHRyaWJ1dGVzKTogc3RyaW5nID0+IHtcbiAgY29uc3QgZ2xzbCA9IGdldEdsc2woaW5mZXJlbmNlSGFuZGxlci5zZXNzaW9uLmJhY2tlbmQuZ2xDb250ZXh0LnZlcnNpb24pO1xuICBjb25zdCBbd2lkdGgsIGhlaWdodF0gPSBpbmZlcmVuY2VIYW5kbGVyLmNhbGN1bGF0ZVRleHR1cmVXaWR0aEFuZEhlaWdodChpbnB1dC5kaW1zLCBUZXh0dXJlVHlwZS51bnBhY2tlZCk7XG4gIGNvbnN0IHN0cmlkZXMgPSBTaGFwZVV0aWwuY29tcHV0ZVN0cmlkZXMoaW5wdXQuZGltcyk7XG5cbiAgc3dpdGNoIChhdHRyaWJ1dGVzLm1vZGUpIHtcbiAgICBjYXNlICdjb25zdGFudCc6XG4gICAgICByZXR1cm4gZ2V0UGFkQ29uc3RhbnQoZ2xzbCwgaW5wdXQuZGltcywgc3RyaWRlcywgd2lkdGgsIGhlaWdodCwgYXR0cmlidXRlcy5wYWRzLCBhdHRyaWJ1dGVzLnZhbHVlKTtcbiAgICBjYXNlICdyZWZsZWN0JzpcbiAgICAgIHJldHVybiBnZXRQYWRSZWZsZWN0KGdsc2wsIGlucHV0LmRpbXMsIHN0cmlkZXMsIHdpZHRoLCBoZWlnaHQsIGF0dHJpYnV0ZXMucGFkcyk7XG4gICAgY2FzZSAnZWRnZSc6XG4gICAgICByZXR1cm4gZ2V0UGFkRWRnZShnbHNsLCBpbnB1dC5kaW1zLCBzdHJpZGVzLCB3aWR0aCwgaGVpZ2h0LCBhdHRyaWJ1dGVzLnBhZHMpO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbW9kZScpO1xuICB9XG59O1xuXG5jb25zdCBnZXRQYWRDb25zdGFudCA9XG4gICAgKGdsc2w6IEdsc2wsIHNoYXBlOiByZWFkb25seSBudW1iZXJbXSwgc3RyaWRlczogcmVhZG9ubHkgbnVtYmVyW10sIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyLCBwYWRzOiBudW1iZXJbXSxcbiAgICAgdmFsdWU6IG51bWJlcik6IHN0cmluZyA9PiB7XG4gICAgICBjb25zdCByYW5rID0gc2hhcGUubGVuZ3RoO1xuICAgICAgbGV0IGJsb2NrID0gJyc7XG4gICAgICBmb3IgKGxldCBpID0gcmFuayAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIGJsb2NrICs9IGBcbiAgICAgICAgayA9IG1bJHtpfV0gLSAke3BhZHNbaV19O1xuICAgICAgICBpZiAoayA8IDApICByZXR1cm4gY29uc3RhbnQ7XG4gICAgICAgIGlmIChrID49ICR7c2hhcGVbaV19KSByZXR1cm4gY29uc3RhbnQ7XG4gICAgICAgIG9mZnNldCArPSBrICogJHtzdHJpZGVzW2ldfTtcbiAgICAgICAgYDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBgXG4gICAgICBmbG9hdCBwYWRBKGludCBtWyR7cmFua31dKSB7XG4gICAgICAgIGNvbnN0IGZsb2F0IGNvbnN0YW50ID0gZmxvYXQoJHt2YWx1ZX0pO1xuICAgICAgICBpbnQgb2Zmc2V0ID0gMDtcbiAgICAgICAgaW50IGsgPSAwO1xuICAgICAgICAke2Jsb2NrfVxuICAgICAgICB2ZWMyIGNvb3JkcyA9IG9mZnNldFRvQ29vcmRzKG9mZnNldCwgJHt3aWR0aH0sICR7aGVpZ2h0fSk7XG4gICAgICAgIGZsb2F0IHZhbHVlID0gZ2V0Q29sb3JBc0Zsb2F0KCR7Z2xzbC50ZXh0dXJlMkR9KEEsIGNvb3JkcykpO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICBgO1xuICAgIH07XG5cbmNvbnN0IGdldFBhZFJlZmxlY3QgPVxuICAgIChnbHNsOiBHbHNsLCBzaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sIHN0cmlkZXM6IHJlYWRvbmx5IG51bWJlcltdLCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlciwgcGFkczogbnVtYmVyW10pOlxuICAgICAgICBzdHJpbmcgPT4ge1xuICAgICAgICAgIGNvbnN0IHJhbmsgPSBzaGFwZS5sZW5ndGg7XG5cbiAgICAgICAgICBsZXQgYmxvY2sgPSAnJztcbiAgICAgICAgICBmb3IgKGxldCBpID0gcmFuayAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgICBibG9jayArPSBgXG4gICAgICAgIGsgPSBtWyR7aX1dIC0gJHtwYWRzW2ldfTtcbiAgICAgICAgaWYgKGsgPCAwKSB7IGsgPSAtazsgfVxuICAgICAgICB7XG4gICAgICAgICAgY29uc3QgaW50IF8ybl8xID0gJHsyICogKHNoYXBlW2ldIC0gMSl9O1xuICAgICAgICAgIGsgPSBpbnQoIG1vZCggZmxvYXQoayksIGZsb2F0KF8ybl8xKSApICkgO1xuICAgICAgICAgIGlmKGsgPj0gJHtzaGFwZVtpXX0pIHsgayA9IF8ybl8xIC0gazsgfVxuICAgICAgICB9XG4gICAgICAgIG9mZnNldCArPSBrICogJHtzdHJpZGVzW2ldfTtcbiAgICAgICAgYDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGBcbiAgICAgIGZsb2F0IHBhZEEoaW50IG1bJHtyYW5rfV0pIHtcbiAgICAgICAgaW50IG9mZnNldCA9IDA7XG4gICAgICAgIGludCBrID0gMDtcbiAgICAgICAgJHtibG9ja31cbiAgICAgICAgdmVjMiBjb29yZHMgPSBvZmZzZXRUb0Nvb3JkcyhvZmZzZXQsICR7d2lkdGh9LCAke2hlaWdodH0pO1xuICAgICAgICBmbG9hdCB2YWx1ZSA9IGdldENvbG9yQXNGbG9hdCgke2dsc2wudGV4dHVyZTJEfShBLCBjb29yZHMpKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgYDtcbiAgICAgICAgfTtcblxuY29uc3QgZ2V0UGFkRWRnZSA9XG4gICAgKGdsc2w6IEdsc2wsIHNoYXBlOiByZWFkb25seSBudW1iZXJbXSwgc3RyaWRlczogcmVhZG9ubHkgbnVtYmVyW10sIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyLCBwYWRzOiBudW1iZXJbXSk6XG4gICAgICAgIHN0cmluZyA9PiB7XG4gICAgICAgICAgY29uc3QgcmFuayA9IHNoYXBlLmxlbmd0aDtcblxuICAgICAgICAgIGxldCBibG9jayA9ICcnO1xuICAgICAgICAgIGZvciAobGV0IGkgPSByYW5rIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICAgIGJsb2NrICs9IGBcbiAgICAgICAgayA9IG1bJHtpfV0gLSAke3BhZHNbaV19O1xuICAgICAgICBpZiAoayA8IDApICBrID0gMDtcbiAgICAgICAgaWYgKGsgPj0gJHtzaGFwZVtpXX0pIGsgPSAke3NoYXBlW2ldIC0gMX07XG4gICAgICAgIG9mZnNldCArPSBrICogJHtzdHJpZGVzW2ldfTtcbiAgICAgIGA7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBgXG4gICAgICBmbG9hdCBwYWRBKGludCBtWyR7cmFua31dKSB7XG4gICAgICAgIGludCBvZmZzZXQgPSAwO1xuICAgICAgICBpbnQgayA9IDA7XG4gICAgICAgICR7YmxvY2t9XG4gICAgICAgIHZlYzIgY29vcmRzID0gb2Zmc2V0VG9Db29yZHMob2Zmc2V0LCAke3dpZHRofSwgJHtoZWlnaHR9KTtcbiAgICAgICAgZmxvYXQgdmFsdWUgPSBnZXRDb2xvckFzRmxvYXQoJHtnbHNsLnRleHR1cmUyRH0oQSwgY29vcmRzKSk7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGA7XG4gICAgICAgIH07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7QXR0cmlidXRlV2l0aENhY2hlS2V5LCBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXl9IGZyb20gJy4uLy4uLy4uL2F0dHJpYnV0ZS13aXRoLWNhY2hlLWtleSc7XG5pbXBvcnQge0dyYXBofSBmcm9tICcuLi8uLi8uLi9ncmFwaCc7XG5pbXBvcnQge09wZXJhdG9ySW1wbGVtZW50YXRpb24sIE9wZXJhdG9ySW5pdGlhbGl6YXRpb259IGZyb20gJy4uLy4uLy4uL29wZXJhdG9ycyc7XG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi4vLi4vLi4vdGVuc29yJztcbmltcG9ydCB7UG9vbENvbnZVdGlsLCBTaGFwZVV0aWx9IGZyb20gJy4uLy4uLy4uL3V0aWwnO1xuaW1wb3J0IHtXZWJHTEluZmVyZW5jZUhhbmRsZXJ9IGZyb20gJy4uL2luZmVyZW5jZS1oYW5kbGVyJztcbmltcG9ydCB7UHJvZ3JhbUluZm8sIFByb2dyYW1NZXRhZGF0YSwgVGV4dHVyZVR5cGV9IGZyb20gJy4uL3R5cGVzJztcblxuZXhwb3J0IGludGVyZmFjZSBBdmVyYWdlUG9vbEF0dHJpYnV0ZXMgZXh0ZW5kcyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkge1xuICByZWFkb25seSBhdXRvUGFkOiBzdHJpbmc7XG4gIHJlYWRvbmx5IGNlaWxNb2RlOiBudW1iZXI7XG4gIHJlYWRvbmx5IGNvdW50SW5jbHVkZVBhZDogYm9vbGVhbjtcbiAgcmVhZG9ubHkga2VybmVsU2hhcGU6IHJlYWRvbmx5IG51bWJlcltdO1xuICByZWFkb25seSBzdHJpZGVzOiByZWFkb25seSBudW1iZXJbXTtcbiAgcmVhZG9ubHkgcGFkczogcmVhZG9ubHkgbnVtYmVyW107XG59XG5cbmV4cG9ydCBjb25zdCBhdmVyYWdlUG9vbDogT3BlcmF0b3JJbXBsZW1lbnRhdGlvbjxBdmVyYWdlUG9vbEF0dHJpYnV0ZXM+ID1cbiAgICAoaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdLCBhdHRyaWJ1dGVzOiBBdmVyYWdlUG9vbEF0dHJpYnV0ZXMpOiBUZW5zb3JbXSA9PiB7XG4gICAgICB2YWxpZGF0ZUlucHV0cyhpbnB1dHMpO1xuICAgICAgY29uc3QgbWV0YWRhdGEgPVxuICAgICAgICAgIHtuYW1lOiAnQXZlcmFnZVBvb2wnLCBpbnB1dE5hbWVzOiBbJ1gnXSwgaW5wdXRUeXBlczogW1RleHR1cmVUeXBlLnVucGFja2VkXSwgY2FjaGVIaW50OiBhdHRyaWJ1dGVzLmNhY2hlS2V5fTtcbiAgICAgIGNvbnN0IG91dHB1dCA9IGluZmVyZW5jZUhhbmRsZXIucnVuKFxuICAgICAgICAgIHsuLi5tZXRhZGF0YSwgZ2V0OiAoKSA9PiBjcmVhdGVBdmVyYWdlUG9vbFByb2dyYW1JbmZvKGlucHV0cywgbWV0YWRhdGEsIGZhbHNlLCBhdHRyaWJ1dGVzKX0sIGlucHV0cyk7XG4gICAgICByZXR1cm4gW291dHB1dF07XG4gICAgfTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlQXZlcmFnZVBvb2xBdHRyaWJ1dGVzOiBPcGVyYXRvckluaXRpYWxpemF0aW9uPEF2ZXJhZ2VQb29sQXR0cmlidXRlcz4gPVxuICAgIChub2RlOiBHcmFwaC5Ob2RlKTogQXZlcmFnZVBvb2xBdHRyaWJ1dGVzID0+IHtcbiAgICAgIGNvbnN0IGF1dG9QYWQgPSBub2RlLmF0dHJpYnV0ZXMuZ2V0U3RyaW5nKCdhdXRvX3BhZCcsICdOT1RTRVQnKTtcbiAgICAgIGNvbnN0IGNlaWxNb2RlID0gbm9kZS5hdHRyaWJ1dGVzLmdldEludCgnY2VpbF9tb2RlJywgMCk7XG4gICAgICBjb25zdCBjb3VudEluY2x1ZGVQYWQgPSAobm9kZS5hdHRyaWJ1dGVzLmdldEludCgnY291bnRfaW5jbHVkZV9wYWQnLCAwKSA9PT0gMCA/IGZhbHNlIDogdHJ1ZSk7XG4gICAgICBjb25zdCBrZXJuZWxTaGFwZSA9IG5vZGUuYXR0cmlidXRlcy5nZXRJbnRzKCdrZXJuZWxfc2hhcGUnKTtcbiAgICAgIGNvbnN0IHN0cmlkZXMgPSBub2RlLmF0dHJpYnV0ZXMuZ2V0SW50cygnc3RyaWRlcycsIFtdKTtcbiAgICAgIGNvbnN0IHBhZHMgPSBub2RlLmF0dHJpYnV0ZXMuZ2V0SW50cygncGFkcycsIFtdKTtcblxuICAgICAgLy8gVE9ETzogc3VwcG9ydCBhdHRyaWJ1dGUgJ2NlaWxfbW9kZSdcbiAgICAgIGlmIChjZWlsTW9kZSAhPT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VzaW5nIGNlaWwoKSBpbiBzaGFwZSBjb21wdXRhdGlvbiBpcyBub3QgeWV0IHN1cHBvcnRlZCBmb3IgQXZlcmFnZVBvb2wnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSh7YXV0b1BhZCwgY2VpbE1vZGUsIGNvdW50SW5jbHVkZVBhZCwga2VybmVsU2hhcGUsIHN0cmlkZXMsIHBhZHN9KTtcbiAgICB9O1xuXG5jb25zdCBjcmVhdGVBdmVyYWdlUG9vbFByb2dyYW1JbmZvID1cbiAgICAoaW5wdXRzOiBUZW5zb3JbXSwgbWV0YWRhdGE6IFByb2dyYW1NZXRhZGF0YSwgaXNHbG9iYWxPcGVyYXRvcjogYm9vbGVhbiwgYXR0cmlidXRlczogQXZlcmFnZVBvb2xBdHRyaWJ1dGVzKTpcbiAgICAgICAgUHJvZ3JhbUluZm8gPT4ge1xuICAgICAgICAgIGNvbnN0IFthZGp1c3RlZEF0dHJpYnV0ZXMsIG91dHB1dFNoYXBlXSA9XG4gICAgICAgICAgICAgIGdldEFkanVzdGVkUG9vbEF0dHJpYnV0ZXNBbmRPdXRwdXRTaGFwZShpbnB1dHMsIGF0dHJpYnV0ZXMsIGlzR2xvYmFsT3BlcmF0b3IpO1xuICAgICAgICAgIGNvbnN0IGtlcm5lbFNpemUgPSBTaGFwZVV0aWwuc2l6ZShhZGp1c3RlZEF0dHJpYnV0ZXMua2VybmVsU2hhcGUpO1xuICAgICAgICAgIGNvbnN0IG9wMSA9ICd2YWx1ZSArPSBfWCh4KTsnO1xuICAgICAgICAgIGxldCBvcDIgPSAnJztcbiAgICAgICAgICBpZiAoYWRqdXN0ZWRBdHRyaWJ1dGVzLmNvdW50SW5jbHVkZVBhZCkge1xuICAgICAgICAgICAgb3AyICs9IGB2YWx1ZSAvPSBmbG9hdCgke2tlcm5lbFNpemV9KTtgO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvcDIgKz0gYHZhbHVlIC89IGZsb2F0KCR7a2VybmVsU2l6ZX0gLSBwYWQpO2A7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHBvb2xpbmdDb2RlID0gZ2VuZXJhdGVQb29saW5nQ29kZShpbnB1dHNbMF0uZGltcywgYWRqdXN0ZWRBdHRyaWJ1dGVzLCBvcDEsIG9wMiwgJzAuMCcpO1xuICAgICAgICAgIGNvbnN0IHNoYWRlclNvdXJjZSA9IGBcbiAgICAgICAgJHtwb29saW5nQ29kZX1cbiAgICAgIGA7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLm1ldGFkYXRhLFxuICAgICAgICAgICAgb3V0cHV0OiB7ZGltczogb3V0cHV0U2hhcGUsIHR5cGU6IGlucHV0c1swXS50eXBlLCB0ZXh0dXJlVHlwZTogVGV4dHVyZVR5cGUudW5wYWNrZWR9LFxuICAgICAgICAgICAgc2hhZGVyU291cmNlXG4gICAgICAgICAgfTtcbiAgICAgICAgfTtcblxuZXhwb3J0IGNvbnN0IGdsb2JhbEF2ZXJhZ2VQb29sOiBPcGVyYXRvckltcGxlbWVudGF0aW9uPEF2ZXJhZ2VQb29sQXR0cmlidXRlcz4gPVxuICAgIChpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10sIGF0dHJpYnV0ZXM6IEF2ZXJhZ2VQb29sQXR0cmlidXRlcyk6IFRlbnNvcltdID0+IHtcbiAgICAgIHZhbGlkYXRlSW5wdXRzKGlucHV0cyk7XG4gICAgICBjb25zdCBtZXRhZGF0YSA9IHtcbiAgICAgICAgbmFtZTogJ0dsb2JhbEF2ZXJhZ2VQb29sJyxcbiAgICAgICAgaW5wdXROYW1lczogWydYJ10sXG4gICAgICAgIGlucHV0VHlwZXM6IFtUZXh0dXJlVHlwZS51bnBhY2tlZF0sXG4gICAgICAgIGNhY2hlSGludDogYCR7YXR0cmlidXRlcy5jb3VudEluY2x1ZGVQYWR9YFxuICAgICAgfTtcbiAgICAgIGNvbnN0IG91dHB1dCA9IGluZmVyZW5jZUhhbmRsZXIucnVuKFxuICAgICAgICAgIHsuLi5tZXRhZGF0YSwgZ2V0OiAoKSA9PiBjcmVhdGVBdmVyYWdlUG9vbFByb2dyYW1JbmZvKGlucHV0cywgbWV0YWRhdGEsIHRydWUsIGF0dHJpYnV0ZXMpfSwgaW5wdXRzKTtcbiAgICAgIHJldHVybiBbb3V0cHV0XTtcbiAgICB9O1xuXG5leHBvcnQgY29uc3QgcGFyc2VHbG9iYWxBdmVyYWdlUG9vbEF0dHJpYnV0ZXM6IE9wZXJhdG9ySW5pdGlhbGl6YXRpb248QXZlcmFnZVBvb2xBdHRyaWJ1dGVzPiA9XG4gICAgKG5vZGU6IEdyYXBoLk5vZGUpOiBBdmVyYWdlUG9vbEF0dHJpYnV0ZXMgPT4ge1xuICAgICAgY29uc3QgY291bnRJbmNsdWRlUGFkID0gKG5vZGUuYXR0cmlidXRlcy5nZXRJbnQoJ2NvdW50X2luY2x1ZGVfcGFkJywgMCkgPT09IDAgPyBmYWxzZSA6IHRydWUpO1xuICAgICAgcmV0dXJuIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleShcbiAgICAgICAgICB7YXV0b1BhZDogJycsIGNlaWxNb2RlOiAwLCBjb3VudEluY2x1ZGVQYWQsIGtlcm5lbFNoYXBlOiBbXSwgc3RyaWRlczogW10sIHBhZHM6IFtdfSk7XG4gICAgfTtcblxuZXhwb3J0IGludGVyZmFjZSBNYXhQb29sQXR0cmlidXRlcyBleHRlbmRzIEF2ZXJhZ2VQb29sQXR0cmlidXRlcyB7XG4gIHJlYWRvbmx5IHN0b3JhZ2VPcmRlcjogbnVtYmVyO1xuICByZWFkb25seSBkaWxhdGlvbnM6IG51bWJlcltdO1xufVxuXG5leHBvcnQgY29uc3QgbWF4UG9vbDogT3BlcmF0b3JJbXBsZW1lbnRhdGlvbjxNYXhQb29sQXR0cmlidXRlcz4gPVxuICAgIChpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10sIGF0dHJpYnV0ZXM6IE1heFBvb2xBdHRyaWJ1dGVzKTogVGVuc29yW10gPT4ge1xuICAgICAgdmFsaWRhdGVJbnB1dHMoaW5wdXRzKTtcbiAgICAgIGNvbnN0IG1ldGFkYXRhID1cbiAgICAgICAgICB7bmFtZTogJ01heFBvb2wnLCBpbnB1dE5hbWVzOiBbJ1gnXSwgaW5wdXRUeXBlczogW1RleHR1cmVUeXBlLnVucGFja2VkXSwgY2FjaGVIaW50OiBhdHRyaWJ1dGVzLmNhY2hlS2V5fTtcbiAgICAgIGNvbnN0IG91dHB1dCA9IGluZmVyZW5jZUhhbmRsZXIucnVuKFxuICAgICAgICAgIHsuLi5tZXRhZGF0YSwgZ2V0OiAoKSA9PiBjcmVhdGVNYXhQb29sUHJvZ3JhbUluZm8oaW5wdXRzLCBtZXRhZGF0YSwgZmFsc2UsIGF0dHJpYnV0ZXMpfSwgaW5wdXRzKTtcbiAgICAgIHJldHVybiBbb3V0cHV0XTtcbiAgICB9O1xuXG5leHBvcnQgY29uc3QgcGFyc2VNYXhQb29sQXR0cmlidXRlczogT3BlcmF0b3JJbml0aWFsaXphdGlvbjxNYXhQb29sQXR0cmlidXRlcz4gPVxuICAgIChub2RlOiBHcmFwaC5Ob2RlKTogTWF4UG9vbEF0dHJpYnV0ZXMgPT4ge1xuICAgICAgY29uc3QgYXV0b1BhZCA9IG5vZGUuYXR0cmlidXRlcy5nZXRTdHJpbmcoJ2F1dG9fcGFkJywgJ05PVFNFVCcpO1xuICAgICAgY29uc3QgY2VpbE1vZGUgPSBub2RlLmF0dHJpYnV0ZXMuZ2V0SW50KCdjZWlsX21vZGUnLCAwKTtcbiAgICAgIGNvbnN0IGtlcm5lbFNoYXBlID0gbm9kZS5hdHRyaWJ1dGVzLmdldEludHMoJ2tlcm5lbF9zaGFwZScpO1xuICAgICAgY29uc3Qgc3RyaWRlcyA9IG5vZGUuYXR0cmlidXRlcy5nZXRJbnRzKCdzdHJpZGVzJywgW10pO1xuICAgICAgY29uc3QgcGFkcyA9IG5vZGUuYXR0cmlidXRlcy5nZXRJbnRzKCdwYWRzJywgW10pO1xuICAgICAgY29uc3Qgc3RvcmFnZU9yZGVyID0gbm9kZS5hdHRyaWJ1dGVzLmdldEludCgnc3RvcmFnZV9vcmRlcicsIDApO1xuICAgICAgY29uc3QgZGlsYXRpb25zID0gbm9kZS5hdHRyaWJ1dGVzLmdldEludHMoJ2RpbGF0aW9ucycsIFtdKTtcblxuICAgICAgLy8gVE9ETzogc3VwcG9ydCBhdHRyaWJ1dGUgJ2NlaWxfbW9kZScgYW5kICdzdG9yYWdlX29yZGVyJ1xuICAgICAgaWYgKHN0b3JhZ2VPcmRlciAhPT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvbHVtbiBtYWpvciBzdG9yYWdlIG9yZGVyIGlzIG5vdCB5ZXQgc3VwcG9ydGVkIGZvciBNYXhQb29sJyk7XG4gICAgICB9XG4gICAgICBpZiAoY2VpbE1vZGUgIT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1c2luZyBjZWlsKCkgaW4gc2hhcGUgY29tcHV0YXRpb24gaXMgbm90IHlldCBzdXBwb3J0ZWQgZm9yIE1heFBvb2wnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleShcbiAgICAgICAgICB7YXV0b1BhZCwgY2VpbE1vZGUsIGNvdW50SW5jbHVkZVBhZDogZmFsc2UsIGtlcm5lbFNoYXBlLCBzdHJpZGVzLCBwYWRzLCBzdG9yYWdlT3JkZXIsIGRpbGF0aW9uc30pO1xuICAgIH07XG5cbmNvbnN0IGNyZWF0ZU1heFBvb2xQcm9ncmFtSW5mbyA9XG4gICAgKGlucHV0czogVGVuc29yW10sIG1ldGFkYXRhOiBQcm9ncmFtTWV0YWRhdGEsIGlzR2xvYmFsT3BlcmF0b3I6IGJvb2xlYW4sIGF0dHJpYnV0ZXM6IE1heFBvb2xBdHRyaWJ1dGVzKTpcbiAgICAgICAgUHJvZ3JhbUluZm8gPT4ge1xuICAgICAgICAgIGNvbnN0IFthZGp1c3RlZEF0dHJpYnV0ZXMsIG91dHB1dFNoYXBlXSA9XG4gICAgICAgICAgICAgIGdldEFkanVzdGVkUG9vbEF0dHJpYnV0ZXNBbmRPdXRwdXRTaGFwZShpbnB1dHMsIGF0dHJpYnV0ZXMsIGlzR2xvYmFsT3BlcmF0b3IpO1xuICAgICAgICAgIGNvbnN0IG9wMSA9IGBcbiAgICAgIHZhbHVlID0gbWF4KF9YKHgpLCB2YWx1ZSk7XG4gICAgYDtcbiAgICAgICAgICBjb25zdCBvcDIgPSAnJztcbiAgICAgICAgICBjb25zdCBwb29saW5nQ29kZSA9IGdlbmVyYXRlUG9vbGluZ0NvZGUoaW5wdXRzWzBdLmRpbXMsIGFkanVzdGVkQXR0cmlidXRlcywgb3AxLCBvcDIsICctMWU1Jyk7XG4gICAgICAgICAgY29uc3Qgc2hhZGVyU291cmNlID0gYFxuICAgICAgJHtwb29saW5nQ29kZX1cbiAgICBgO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5tZXRhZGF0YSxcbiAgICAgICAgICAgIG91dHB1dDoge2RpbXM6IG91dHB1dFNoYXBlLCB0eXBlOiBpbnB1dHNbMF0udHlwZSwgdGV4dHVyZVR5cGU6IFRleHR1cmVUeXBlLnVucGFja2VkfSxcbiAgICAgICAgICAgIHNoYWRlclNvdXJjZVxuICAgICAgICAgIH07XG4gICAgICAgIH07XG5cbmNvbnN0IGdldEFkanVzdGVkUG9vbEF0dHJpYnV0ZXNBbmRPdXRwdXRTaGFwZSA9XG4gICAgKGlucHV0czogVGVuc29yW10sIGF0dHJpYnV0ZXM6IEF2ZXJhZ2VQb29sQXR0cmlidXRlc3xNYXhQb29sQXR0cmlidXRlcywgaXNHbG9iYWxPcGVyYXRvcjogYm9vbGVhbik6XG4gICAgICAgIFtBdmVyYWdlUG9vbEF0dHJpYnV0ZXN8TWF4UG9vbEF0dHJpYnV0ZXMsIG51bWJlcltdXSA9PiB7XG4gICAgICAgICAgY29uc3QgaW5wdXRTaGFwZSA9IGlucHV0c1swXS5kaW1zLnNsaWNlKCk7XG4gICAgICAgICAgY29uc3QgaGFzRGlsYXRpb25zID0gT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoYXR0cmlidXRlcywgJ2RpbGF0aW9ucycpO1xuICAgICAgICAgIGNvbnN0IGtlcm5lbFNoYXBlID0gYXR0cmlidXRlcy5rZXJuZWxTaGFwZS5zbGljZSgpO1xuICAgICAgICAgIGNvbnN0IHN0cmlkZXMgPSBhdHRyaWJ1dGVzLnN0cmlkZXMuc2xpY2UoKTtcbiAgICAgICAgICBjb25zdCBkaWxhdGlvbnM6IG51bWJlcltdID0gaGFzRGlsYXRpb25zID8gKGF0dHJpYnV0ZXMgYXMgTWF4UG9vbEF0dHJpYnV0ZXMpLmRpbGF0aW9ucy5zbGljZSgpIDogW107XG4gICAgICAgICAgY29uc3QgcGFkcyA9IGF0dHJpYnV0ZXMucGFkcy5zbGljZSgpO1xuICAgICAgICAgIFBvb2xDb252VXRpbC5hZGp1c3RQb29sQXR0cmlidXRlcyhpc0dsb2JhbE9wZXJhdG9yLCBpbnB1dFNoYXBlLCBrZXJuZWxTaGFwZSwgc3RyaWRlcywgZGlsYXRpb25zLCBwYWRzKTtcblxuICAgICAgICAgIGNvbnN0IG91dHB1dFNoYXBlID0gUG9vbENvbnZVdGlsLmNvbXB1dGVQb29sT3V0cHV0U2hhcGUoXG4gICAgICAgICAgICAgIGlzR2xvYmFsT3BlcmF0b3IsIGlucHV0U2hhcGUsIHN0cmlkZXMsIGRpbGF0aW9ucywga2VybmVsU2hhcGUsIHBhZHMsIGF0dHJpYnV0ZXMuYXV0b1BhZCk7XG5cbiAgICAgICAgICBjb25zdCBuZXdBdHRyaWJ1dGVzID0gT2JqZWN0LmFzc2lnbih7fSwgYXR0cmlidXRlcyk7XG4gICAgICAgICAgaWYgKGhhc0RpbGF0aW9ucykge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihuZXdBdHRyaWJ1dGVzLCB7a2VybmVsU2hhcGUsIHN0cmlkZXMsIHBhZHMsIGRpbGF0aW9ucywgY2FjaGVLZXk6IGF0dHJpYnV0ZXMuY2FjaGVLZXl9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihuZXdBdHRyaWJ1dGVzLCB7a2VybmVsU2hhcGUsIHN0cmlkZXMsIHBhZHMsIGNhY2hlS2V5OiBhdHRyaWJ1dGVzLmNhY2hlS2V5fSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBbbmV3QXR0cmlidXRlcywgb3V0cHV0U2hhcGVdO1xuICAgICAgICB9O1xuXG5jb25zdCBnbG9iYWxNYXhQb29sQXR0cmlidXRlcyA9IHtcbiAgYXV0b1BhZDogJycsXG4gIGNlaWxNb2RlOiAwLFxuICBjb3VudEluY2x1ZGVQYWQ6IGZhbHNlLFxuICBrZXJuZWxTaGFwZTogW10sXG4gIHN0cmlkZXM6IFtdLFxuICBwYWRzOiBbXSxcbiAgc3RvcmFnZU9yZGVyOiAwLFxuICBkaWxhdGlvbnM6IFtdLFxuICBjYWNoZUtleTogJydcbn07XG5cbmNvbnN0IGdsb2JhbE1heFBvb2xNZXRhZGF0YSA9IHtcbiAgbmFtZTogJ0dsb2JhbE1heFBvb2wnLFxuICBpbnB1dE5hbWVzOiBbJ1gnXSxcbiAgaW5wdXRUeXBlczogW1RleHR1cmVUeXBlLnVucGFja2VkXVxufTtcblxuZXhwb3J0IGNvbnN0IGdsb2JhbE1heFBvb2wgPSAoaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTogVGVuc29yW10gPT4ge1xuICB2YWxpZGF0ZUlucHV0cyhpbnB1dHMpO1xuICBjb25zdCBvdXRwdXQgPSBpbmZlcmVuY2VIYW5kbGVyLnJ1bihcbiAgICAgIHtcbiAgICAgICAgLi4uZ2xvYmFsTWF4UG9vbE1ldGFkYXRhLFxuICAgICAgICBnZXQ6ICgpID0+IGNyZWF0ZU1heFBvb2xQcm9ncmFtSW5mbyhpbnB1dHMsIGdsb2JhbE1heFBvb2xNZXRhZGF0YSwgdHJ1ZSwgZ2xvYmFsTWF4UG9vbEF0dHJpYnV0ZXMpXG4gICAgICB9LFxuICAgICAgaW5wdXRzKTtcbiAgcmV0dXJuIFtvdXRwdXRdO1xufTtcblxuY29uc3QgdmFsaWRhdGVJbnB1dHMgPSAoaW5wdXRzOiBUZW5zb3JbXSk6IHZvaWQgPT4ge1xuICBpZiAoIWlucHV0cyB8fCBpbnB1dHMubGVuZ3RoICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdQb29sIG9wcyByZXF1aXJlcyAxIGlucHV0LicpO1xuICB9XG4gIGlmIChpbnB1dHNbMF0udHlwZSAhPT0gJ2Zsb2F0MzInICYmIGlucHV0c1swXS50eXBlICE9PSAnZmxvYXQ2NCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW5wdXQgdHlwZS4nKTtcbiAgfVxufTtcblxuY29uc3QgZ2VuZXJhdGVQb29saW5nQ29kZSA9XG4gICAgKGlucHV0RGltczogcmVhZG9ubHkgbnVtYmVyW10sIGF0dHJpYnV0ZXM6IEF2ZXJhZ2VQb29sQXR0cmlidXRlcywgb3AxOiBzdHJpbmcsIG9wMjogc3RyaW5nLCBzdGFydDogc3RyaW5nKTpcbiAgICAgICAgc3RyaW5nID0+IHtcbiAgICAgICAgICBjb25zdCByYW5rID0gaW5wdXREaW1zLmxlbmd0aDtcbiAgICAgICAgICBpZiAoYXR0cmlidXRlcy5rZXJuZWxTaGFwZS5sZW5ndGggPD0gMikge1xuICAgICAgICAgICAgY29uc3Qga3cgPSBhdHRyaWJ1dGVzLmtlcm5lbFNoYXBlW2F0dHJpYnV0ZXMua2VybmVsU2hhcGUubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBjb25zdCBzdyA9IGF0dHJpYnV0ZXMuc3RyaWRlc1thdHRyaWJ1dGVzLnN0cmlkZXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBjb25zdCBwd1N0YXJ0ID0gYXR0cmlidXRlcy5wYWRzW2F0dHJpYnV0ZXMucGFkcy5sZW5ndGggLyAyIC0gMV07XG4gICAgICAgICAgICBjb25zdCBwd0VuZCA9IGF0dHJpYnV0ZXMucGFkc1thdHRyaWJ1dGVzLnBhZHMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBjb25zdCBkaW1XID0gaW5wdXREaW1zW3JhbmsgLSAxXTtcbiAgICAgICAgICAgIGxldCBjb2RlVyA9ICcnO1xuICAgICAgICAgICAgbGV0IGNvZGVIID0gJyc7XG4gICAgICAgICAgICBsZXQgY29kZUhFbmQgPSAnJztcbiAgICAgICAgICAgIGlmIChwd1N0YXJ0ICsgcHdFbmQgIT09IDApIHtcbiAgICAgICAgICAgICAgY29kZVcgPSBgXG4gICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCAke2t3fTsgaSsrKSB7XG4gICAgICAgICAgICB4WyR7cmFua30gLSAxXSA9IGluZGljZXNbJHtyYW5rfSAtIDFdICogJHtzd30gLSAke3B3U3RhcnR9ICsgaTtcbiAgICAgICAgICAgIGlmICh4WyR7cmFua30gLSAxXSA8IDAgfHwgeFske3Jhbmt9IC0gMV0gPj0gJHtkaW1XfSkge1xuICAgICAgICAgICAgICBwYWQrKztcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAke29wMX1cbiAgICAgICAgICB9YDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvZGVXID0gYFxuICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgJHtrd307IGkrKykge1xuICAgICAgICAgICAgeFske3Jhbmt9IC0gMV0gPSBpbmRpY2VzWyR7cmFua30gLSAxXSAqICR7c3d9IC0gJHtwd1N0YXJ0fSArIGk7XG4gICAgICAgICAgICAke29wMX1cbiAgICAgICAgICB9YDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZXMua2VybmVsU2hhcGUubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGtoID0gYXR0cmlidXRlcy5rZXJuZWxTaGFwZVthdHRyaWJ1dGVzLmtlcm5lbFNoYXBlLmxlbmd0aCAtIDJdO1xuICAgICAgICAgICAgICBjb25zdCBzaCA9IGF0dHJpYnV0ZXMuc3RyaWRlc1thdHRyaWJ1dGVzLnN0cmlkZXMubGVuZ3RoIC0gMl07XG4gICAgICAgICAgICAgIGNvbnN0IHBoU3RhcnQgPSBhdHRyaWJ1dGVzLnBhZHNbYXR0cmlidXRlcy5wYWRzLmxlbmd0aCAvIDIgLSAyXTtcbiAgICAgICAgICAgICAgY29uc3QgcGhFbmQgPSBhdHRyaWJ1dGVzLnBhZHNbYXR0cmlidXRlcy5wYWRzLmxlbmd0aCAtIDJdO1xuICAgICAgICAgICAgICBjb25zdCBkaW1IID0gaW5wdXREaW1zW3JhbmsgLSAyXTtcbiAgICAgICAgICAgICAgaWYgKHBoU3RhcnQgKyBwaEVuZCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIGNvZGVIID0gYFxuICAgICAgICAgICAgZm9yIChpbnQgaiA9IDA7IGogPCAke2tofTsgaisrKSB7XG4gICAgICAgICAgICAgIHhbJHtyYW5rfSAtIDJdID0gaW5kaWNlc1ske3Jhbmt9IC0gMl0gKiAke3NofSAtICR7cGhTdGFydH0gKyBqO1xuICAgICAgICAgICAgICBpZiAoeFske3Jhbmt9IC0gMl0gPCAwIHx8IHhbJHtyYW5rfSAtIDJdID49ICR7ZGltSH0pIHtcbiAgICAgICAgICAgICAgICBwYWQrPSAke2t3fTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIGA7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29kZUggPSBgXG4gICAgICAgICAgICBmb3IgKGludCBqID0gMDsgaiA8ICR7a2h9OyBqKyspIHtcbiAgICAgICAgICAgICAgeFske3Jhbmt9IC0gMl0gPSBpbmRpY2VzWyR7cmFua30gLSAyXSAqICR7c2h9IC0gJHtwaFN0YXJ0fSArIGo7XG4gICAgICAgICAgICBgO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvZGVIRW5kID0gYFxuICAgICAgICAgIH1cbiAgICAgICAgYDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgcG9vbGluZ0NvZGUgPSBgXG4gICAgICAgIGZsb2F0IHByb2Nlc3MoaW50IGluZGljZXNbJHtyYW5rfV0pIHtcbiAgICAgICAgICBpbnQgeFske3Jhbmt9XTtcbiAgICAgICAgICBjb3B5VmVjKGluZGljZXMsIHgpO1xuXG4gICAgICAgICAgZmxvYXQgdmFsdWUgPSAke3N0YXJ0fTtcbiAgICAgICAgICBpbnQgcGFkID0gMDtcbiAgICAgICAgICAke2NvZGVIfVxuICAgICAgICAgICR7Y29kZVd9XG4gICAgICAgICAgJHtjb2RlSEVuZH1cbiAgICAgICAgICAke29wMn1cbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIGA7XG4gICAgICAgICAgICByZXR1cm4gcG9vbGluZ0NvZGU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGtlcm5lbFNpemUgPSBTaGFwZVV0aWwuc2l6ZShhdHRyaWJ1dGVzLmtlcm5lbFNoYXBlKTtcbiAgICAgICAgICAgIGNvbnN0IGtlcm5lbFN0cmlkZXMgPSBTaGFwZVV0aWwuY29tcHV0ZVN0cmlkZXMoYXR0cmlidXRlcy5rZXJuZWxTaGFwZSk7XG4gICAgICAgICAgICBjb25zdCBzdHJpZGVzUmFuayA9IGtlcm5lbFN0cmlkZXMubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgcGFkc1JhbmsgPSBhdHRyaWJ1dGVzLnBhZHMubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0VG9JbmRpY2VzRnVuY3Rpb24gPSBvZmZzZXRUb0luZGljZXMoc3RyaWRlc1JhbmspO1xuICAgICAgICAgICAgY29uc3QgY29weUlucHV0RGltcyA9IGNvcHlBcnJheShpbnB1dERpbXMsICdpbnB1dERpbXMnKTtcbiAgICAgICAgICAgIGNvbnN0IGNvcHlQYWRzID0gY29weUFycmF5KGF0dHJpYnV0ZXMucGFkcywgJ3BhZHMnKTtcbiAgICAgICAgICAgIGNvbnN0IGNvcHlLZXJuZWxTdHJpZGVzID0gY29weUFycmF5KGtlcm5lbFN0cmlkZXMsICdrZXJuZWxTdHJpZGVzJyk7XG4gICAgICAgICAgICBjb25zdCBjb3B5U3RyaWRlcyA9IGNvcHlBcnJheShhdHRyaWJ1dGVzLnN0cmlkZXMsICdzdHJpZGVzJyk7XG4gICAgICAgICAgICBjb25zdCBoYXNQYWRzID0gYXR0cmlidXRlcy5wYWRzLnJlZHVjZSgoc3VtLCBjdXIpID0+IHN1bSArIGN1cik7XG4gICAgICAgICAgICBsZXQgcGFkQ29kZSA9ICcnO1xuICAgICAgICAgICAgaWYgKGhhc1BhZHMpIHtcbiAgICAgICAgICAgICAgcGFkQ29kZSA9IGBcbiAgICAgICAgICAgIGlmICh4W2pdID49IGlucHV0RGltc1tqXSB8fCB4W2pdIDwgMCkge1xuICAgICAgICAgICAgICBwYWQrKztcbiAgICAgICAgICAgICAgaXNQYWQgPSB0cnVlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFpc1BhZCkge1xuICAgICAgICAgICAgJHtvcDF9XG4gICAgICAgICAgfWA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwYWRDb2RlID0gYFxuICAgICAgICAgIH1cbiAgICAgICAgICAke29wMX1cbiAgICAgICAgYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBvb2xpbmdDb2RlID0gYFxuICAgICAgICAke29mZnNldFRvSW5kaWNlc0Z1bmN0aW9ufVxuICAgICAgICBmbG9hdCBwcm9jZXNzKGludCBpbmRpY2VzWyR7cmFua31dKSB7XG4gICAgICAgICAgaW50IHhbJHtyYW5rfV07XG4gICAgICAgICAgY29weVZlYyhpbmRpY2VzLCB4KTtcbiAgICAgICAgICBpbnQgb2Zmc2V0WyR7c3RyaWRlc1Jhbmt9XTtcbiAgICAgICAgICBpbnQgcGFkc1ske3BhZHNSYW5rfV07XG4gICAgICAgICAgaW50IGlucHV0RGltc1ske3Jhbmt9XTtcbiAgICAgICAgICBpbnQga2VybmVsU3RyaWRlc1ske3N0cmlkZXNSYW5rfV07XG4gICAgICAgICAgaW50IHN0cmlkZXNbJHtzdHJpZGVzUmFua31dO1xuICAgICAgICAgICR7Y29weVBhZHN9XG4gICAgICAgICAgJHtjb3B5SW5wdXREaW1zfVxuICAgICAgICAgICR7Y29weVN0cmlkZXN9XG4gICAgICAgICAgJHtjb3B5S2VybmVsU3RyaWRlc31cblxuICAgICAgICAgIGZsb2F0IHZhbHVlID0gJHtzdGFydH07XG4gICAgICAgICAgaW50IHBhZCA9IDA7XG4gICAgICAgICAgYm9vbCBpc1BhZCA9IGZhbHNlO1xuICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgJHtrZXJuZWxTaXplfTsgaSsrKSB7XG4gICAgICAgICAgICBvZmZzZXRUb0luZGljZXMoaSwga2VybmVsU3RyaWRlcywgb2Zmc2V0KTtcbiAgICAgICAgICAgIGlzUGFkID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKGludCBqID0gJHtyYW5rfSAtICR7c3RyaWRlc1Jhbmt9OyBqIDwgJHtyYW5rfTsgaisrKSB7XG4gICAgICAgICAgICAgIHhbal0gPSBpbmRpY2VzW2pdICogc3RyaWRlc1tqIC0gJHtyYW5rfSArICR7c3RyaWRlc1Jhbmt9XVxuICAgICAgICAgICAgICAgICsgb2Zmc2V0W2ogLSAke3Jhbmt9ICsgJHtzdHJpZGVzUmFua31dIC0gcGFkc1tqIC0gMl07XG4gICAgICAgICAgICAgICR7cGFkQ29kZX1cbiAgICAgICAgICB9XG4gICAgICAgICAgJHtvcDJ9XG5cbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIGA7XG4gICAgICAgICAgICByZXR1cm4gcG9vbGluZ0NvZGU7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG5jb25zdCBjb3B5QXJyYXkgPSAoYXJyYXk6IHJlYWRvbmx5IG51bWJlcltdLCBhcnJheU5hbWU6IHN0cmluZyk6IHN0cmluZyA9PiB7XG4gIGxldCBibG9jayA9ICcnO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgYmxvY2sgKz0gYFxuICAgICAgJHthcnJheU5hbWV9WyR7aX1dID0gJHthcnJheVtpXX07XG4gICAgYDtcbiAgfVxuICByZXR1cm4gYmxvY2s7XG59O1xuXG5jb25zdCBvZmZzZXRUb0luZGljZXMgPSAocmFuazogbnVtYmVyKTogc3RyaW5nID0+IGBcbiAgdm9pZCBvZmZzZXRUb0luZGljZXMoaW50IG9mZnNldCwgaW50WyR7cmFua31dIHN0cmlkZXMsIG91dCBpbnRbJHtyYW5rfV0gaW5kaWNlcykge1xuICAgIGlmICgke3Jhbmt9ID09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChpbnQgaSA9IDA7IGkgPCAke3Jhbmt9IC0gMTsgKytpKSB7XG4gICAgICBpbmRpY2VzW2ldID0gb2Zmc2V0IC8gc3RyaWRlc1tpXTtcbiAgICAgIG9mZnNldCAtPSBpbmRpY2VzW2ldICogc3RyaWRlc1tpXTtcbiAgICB9XG4gICAgaW5kaWNlc1ske3Jhbmt9IC0gMV0gPSBvZmZzZXQ7XG4gIH1gO1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0F0dHJpYnV0ZVdpdGhDYWNoZUtleSwgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5fSBmcm9tICcuLi8uLi8uLi9hdHRyaWJ1dGUtd2l0aC1jYWNoZS1rZXknO1xuaW1wb3J0IHtHcmFwaH0gZnJvbSAnLi4vLi4vLi4vZ3JhcGgnO1xuaW1wb3J0IHtOVU1CRVJfVFlQRVMsIE9wZXJhdG9ySW1wbGVtZW50YXRpb24sIE9wZXJhdG9ySW5pdGlhbGl6YXRpb259IGZyb20gJy4uLy4uLy4uL29wZXJhdG9ycyc7XG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi4vLi4vLi4vdGVuc29yJztcbmltcG9ydCB7U2hhcGVVdGlsfSBmcm9tICcuLi8uLi8uLi91dGlsJztcbmltcG9ydCB7V2ViR0xJbmZlcmVuY2VIYW5kbGVyfSBmcm9tICcuLi9pbmZlcmVuY2UtaGFuZGxlcic7XG5pbXBvcnQge1Byb2dyYW1JbmZvLCBQcm9ncmFtTWV0YWRhdGEsIFRleHR1cmVUeXBlfSBmcm9tICcuLi90eXBlcyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVkdWNlQXR0cmlidXRlcyBleHRlbmRzIEF0dHJpYnV0ZVdpdGhDYWNoZUtleSB7XG4gIHJlYWRvbmx5IGF4ZXM6IG51bWJlcltdO1xuICByZWFkb25seSBrZWVwRGltczogYm9vbGVhbjtcbn1cblxuLy8gcmV0dXJuIFtpbml0IG9wcywgcmVkdWNlIG9wcywgZmluYWwgb3BzXVxudHlwZSBSZWR1Y2VPcCA9IChpbnB1dHM6IFRlbnNvcltdLCBheGVzOiBudW1iZXJbXSkgPT4gc3RyaW5nW107XG5cbmNvbnN0IHJlZHVjZSA9XG4gICAgKGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSwgYXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcywgbmFtZTogc3RyaW5nLFxuICAgICByZWR1Y2VPcDogUmVkdWNlT3ApOiBUZW5zb3JbXSA9PiB7XG4gICAgICB2YWxpZGF0ZUlucHV0cyhpbnB1dHMpO1xuXG4gICAgICBjb25zdCByZWR1Y2VQcm9ncmFtTWV0YWRhdGEgPSB7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIGlucHV0TmFtZXM6IFsnQSddLFxuICAgICAgICBpbnB1dFR5cGVzOiBbVGV4dHVyZVR5cGUudW5wYWNrZWRdLFxuICAgICAgfTtcblxuICAgICAgY29uc3Qgb3V0cHV0ID0gaW5mZXJlbmNlSGFuZGxlci5ydW4oXG4gICAgICAgICAge1xuICAgICAgICAgICAgLi4ucmVkdWNlUHJvZ3JhbU1ldGFkYXRhLFxuICAgICAgICAgICAgY2FjaGVIaW50OiBhdHRyaWJ1dGVzLmNhY2hlS2V5LFxuICAgICAgICAgICAgZ2V0OiAoKSA9PlxuICAgICAgICAgICAgICAgIGNyZWF0ZVJlZHVjZVByb2dyYW1JbmZvKGluZmVyZW5jZUhhbmRsZXIsIGlucHV0cywgYXR0cmlidXRlcywgbmFtZSwgcmVkdWNlT3AsIHJlZHVjZVByb2dyYW1NZXRhZGF0YSlcbiAgICAgICAgICB9LFxuICAgICAgICAgIGlucHV0cyk7XG4gICAgICByZXR1cm4gW291dHB1dF07XG4gICAgfTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlUmVkdWNlQXR0cmlidXRlczogT3BlcmF0b3JJbml0aWFsaXphdGlvbjxSZWR1Y2VBdHRyaWJ1dGVzPiA9IChub2RlOiBHcmFwaC5Ob2RlKTogUmVkdWNlQXR0cmlidXRlcyA9PiB7XG4gIGNvbnN0IGF4ZXMgPSBub2RlLmF0dHJpYnV0ZXMuZ2V0SW50cygnYXhlcycsIFtdKTtcbiAgY29uc3Qga2VlcERpbXMgPSBub2RlLmF0dHJpYnV0ZXMuZ2V0SW50KCdrZWVwZGltcycsIDEpID09PSAxO1xuICByZXR1cm4gY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KHtheGVzLCBrZWVwRGltc30pO1xufTtcblxuY29uc3QgY3JlYXRlUmVkdWNlUHJvZ3JhbUluZm8gPVxuICAgIChfaGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdLCBhdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzLCBfbmFtZTogc3RyaW5nLCByZWR1Y2VPcDogUmVkdWNlT3AsXG4gICAgIHJlZHVjZVByb2dyYW1NZXRhZGF0YTogUHJvZ3JhbU1ldGFkYXRhKTogUHJvZ3JhbUluZm8gPT4ge1xuICAgICAgY29uc3Qgb3V0cHV0U2hhcGU6IG51bWJlcltdID0gW107XG4gICAgICBjb25zdCBpUmFuayA9IGlucHV0c1swXS5kaW1zLmxlbmd0aCB8fCAxO1xuXG4gICAgICBjb25zdCBpZHhDb3B5ID0gW107ICAvLyBjb3B5IG91dHB1dCBpbmRleGVzIHRvIGlucHV0IGluZGV4ZXNcblxuICAgICAgY29uc3QgYXhlcyA9IFNoYXBlVXRpbC5ub3JtYWxpemVBeGVzKGF0dHJpYnV0ZXMuYXhlcywgaW5wdXRzWzBdLmRpbXMubGVuZ3RoKTtcbiAgICAgIGNvbnN0IG9wcyA9IHJlZHVjZU9wKGlucHV0cywgYXhlcyk7XG4gICAgICBsZXQgcmVkdWNlT3BzID0gb3BzWzFdO1xuXG4gICAgICBmb3IgKGxldCBrID0gMDsgayA8IGlucHV0c1swXS5kaW1zLmxlbmd0aDsgaysrKSB7XG4gICAgICAgIC8vIGlmIHRoaXMgYXhpcyBpcyByZWR1Y2VkXG4gICAgICAgIGlmIChheGVzLmluZGV4T2YoaykgPj0gMCB8fCBheGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGlmIChhdHRyaWJ1dGVzLmtlZXBEaW1zKSB7XG4gICAgICAgICAgICBvdXRwdXRTaGFwZS5wdXNoKDEpO1xuICAgICAgICAgIH0gIC8vIGVsc2UgeyByZW1vdmUgdGhlIGF4aXMgZnJvbSBvdXRwdXRTaGFwZTsgfVxuXG4gICAgICAgICAgLy8gbG9vcCBvdmVyIHRoZSBkLXRoIGF4aXNcbiAgICAgICAgICByZWR1Y2VPcHMgPSBgXG4gICAgICAgICAgZm9yKGludCBqJHtrfSA9IDA7IGoke2t9IDwgJHtpbnB1dHNbMF0uZGltc1trXX07IGoke2t9KyspIHtcbiAgICAgICAgICAgIGlucHV0SWR4WyR7a31dID0gaiR7a307XG4gICAgICAgICAgICAke3JlZHVjZU9wc31cbiAgICAgICAgICB9YDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZHhDb3B5LnB1c2goYGlucHV0SWR4WyR7a31dID0gb3V0cHV0SWR4WyR7b3V0cHV0U2hhcGUubGVuZ3RofV07YCk7XG5cbiAgICAgICAgICBvdXRwdXRTaGFwZS5wdXNoKGlucHV0c1swXS5kaW1zW2tdKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCBvUmFuayA9IG91dHB1dFNoYXBlLmxlbmd0aCB8fCAxO1xuXG4gICAgICBjb25zdCBzaGFkZXJTb3VyY2UgPSBgXG4gICAgICBmbG9hdCBwcm9jZXNzKGludCBvdXRwdXRJZHhbJHtvUmFua31dKSB7XG4gICAgICAgIGZsb2F0IHZhbHVlOyAgICAgICAgICAgICAgICAgLy8gZmluYWwgcmVzdWx0XG4gICAgICAgIGludCBpbnB1dElkeFske2lSYW5rfV07ICAgICAgLy8gYWRkcmVzc2luZyBpbnB1dCBkYXRhXG4gICAgICAgICR7aWR4Q29weS5qb2luKCdcXG4nKX1cbiAgICAgICAgJHtvcHNbMF19ICAgICAgIC8vIGluaXQgb3BzIGZvciByZWR1Y2UgbWF4L21pblxuICAgICAgICAke3JlZHVjZU9wc31cbiAgICAgICAgJHtvcHNbMl19ICAgICAgIC8vIGZpbmFsIGNvbXB1dGF0aW9uIGZvciByZWR1Y2UgbWVhblxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9YDtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4ucmVkdWNlUHJvZ3JhbU1ldGFkYXRhLFxuICAgICAgICBvdXRwdXQ6IHtkaW1zOiBvdXRwdXRTaGFwZSwgdHlwZTogaW5wdXRzWzBdLnR5cGUsIHRleHR1cmVUeXBlOiBUZXh0dXJlVHlwZS51bnBhY2tlZH0sXG4gICAgICAgIHNoYWRlclNvdXJjZVxuICAgICAgfTtcbiAgICB9O1xuXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IFRlbnNvcltdKTogdm9pZCA9PiB7XG4gIC8vIFRPRE86IHN1cHBvcnQgUmVkdWNlKiBvcGVyYXRvcnMgd2l0aCAyIGlucHV0cy5cbiAgaWYgKCFpbnB1dHMgfHwgaW5wdXRzLmxlbmd0aCAhPT0gMSkge1xuICAgIHRocm93IG5ldyBFcnJvcignUmVkdWNlIG9wIHJlcXVpcmVzIDEgaW5wdXQuJyk7XG4gIH1cblxuICBpZiAoTlVNQkVSX1RZUEVTLmluZGV4T2YoaW5wdXRzWzBdLnR5cGUpID09PSAtMSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpbnB1dCB0eXBlLicpO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgcmVkdWNlU3VtOiBPcGVyYXRvckltcGxlbWVudGF0aW9uPFJlZHVjZUF0dHJpYnV0ZXM+ID1cbiAgICAoaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdLCBhdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzKTogVGVuc29yW10gPT4ge1xuICAgICAgY29uc3QgcmVkdWNlT3A6IFJlZHVjZU9wID0gKCk6IHN0cmluZ1tdID0+IFsndmFsdWUgPSAwLjA7JywgJ3ZhbHVlICs9IF9BKGlucHV0SWR4KTsnLCAnJ107XG4gICAgICByZXR1cm4gcmVkdWNlKGluZmVyZW5jZUhhbmRsZXIsIGlucHV0cywgYXR0cmlidXRlcywgJ1JlZHVjZVN1bScsIHJlZHVjZU9wKTtcbiAgICB9O1xuXG5leHBvcnQgY29uc3QgcmVkdWNlTWVhbjogT3BlcmF0b3JJbXBsZW1lbnRhdGlvbjxSZWR1Y2VBdHRyaWJ1dGVzPiA9XG4gICAgKGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSwgYXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcyk6IFRlbnNvcltdID0+IHtcbiAgICAgIGNvbnN0IHJlZHVjZU9wOiBSZWR1Y2VPcCA9IChpbnB1dHM6IFRlbnNvcltdLCBheGVzOiBudW1iZXJbXSk6IHN0cmluZ1tdID0+IHtcbiAgICAgICAgbGV0IHNpemUgPSAxLjA7XG4gICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgaW5wdXRzWzBdLmRpbXMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICBpZiAoYXhlcy5pbmRleE9mKGspID49IDAgfHwgYXhlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHNpemUgKj0gaW5wdXRzWzBdLmRpbXNba107XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFsndmFsdWUgPSAwLjA7JywgJ3ZhbHVlICs9IF9BKGlucHV0SWR4KTsnLCBgdmFsdWUgLz0gJHtzaXplfS47YF07ICAvLyBlbnN1cmUgcmVhbCBudW1iZXIgd2l0aCBgLmBcbiAgICAgIH07XG4gICAgICByZXR1cm4gcmVkdWNlKGluZmVyZW5jZUhhbmRsZXIsIGlucHV0cywgYXR0cmlidXRlcywgJ1JlZHVjZU1lYW4nLCByZWR1Y2VPcCk7XG4gICAgfTtcblxuZXhwb3J0IGNvbnN0IHJlZHVjZU1heDogT3BlcmF0b3JJbXBsZW1lbnRhdGlvbjxSZWR1Y2VBdHRyaWJ1dGVzPiA9XG4gICAgKGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSwgYXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcyk6IFRlbnNvcltdID0+IHtcbiAgICAgIGNvbnN0IHJlZHVjZU9wOiBSZWR1Y2VPcCA9IChpbnB1dHM6IFRlbnNvcltdLCBheGVzOiBudW1iZXJbXSk6IHN0cmluZ1tdID0+IHtcbiAgICAgICAgY29uc3QgaWR4WmVybyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IGlucHV0c1swXS5kaW1zLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgaWYgKGF4ZXMuaW5kZXhPZihrKSA+PSAwIHx8IGF4ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBpZHhaZXJvLnB1c2goYGlucHV0SWR4WyR7a31dID0gMDtgKTsgIC8vIGZpcnN0IGVsZW1lbnRcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gW2Ake2lkeFplcm8uam9pbignXFxuJyl9XFxudmFsdWUgPSBfQShpbnB1dElkeCk7YCwgJ3ZhbHVlID0gbWF4KHZhbHVlLCBfQShpbnB1dElkeCkpOycsICcnXTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gcmVkdWNlKGluZmVyZW5jZUhhbmRsZXIsIGlucHV0cywgYXR0cmlidXRlcywgJ1JlZHVjZU1heCcsIHJlZHVjZU9wKTtcbiAgICB9O1xuXG5leHBvcnQgY29uc3QgcmVkdWNlTWluOiBPcGVyYXRvckltcGxlbWVudGF0aW9uPFJlZHVjZUF0dHJpYnV0ZXM+ID1cbiAgICAoaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdLCBhdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzKTogVGVuc29yW10gPT4ge1xuICAgICAgY29uc3QgcmVkdWNlT3A6IFJlZHVjZU9wID0gKGlucHV0czogVGVuc29yW10sIGF4ZXM6IG51bWJlcltdKTogc3RyaW5nW10gPT4ge1xuICAgICAgICBjb25zdCBpZHhaZXJvID0gW107XG4gICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgaW5wdXRzWzBdLmRpbXMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICBpZiAoYXhlcy5pbmRleE9mKGspID49IDAgfHwgYXhlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGlkeFplcm8ucHVzaChgaW5wdXRJZHhbJHtrfV0gPSAwO2ApOyAgLy8gZmlyc3QgZWxlbWVudFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbYCR7aWR4WmVyby5qb2luKCdcXG4nKX1cXG52YWx1ZSA9IF9BKGlucHV0SWR4KTtgLCAndmFsdWUgPSBtaW4odmFsdWUsIF9BKGlucHV0SWR4KSk7JywgJyddO1xuICAgICAgfTtcbiAgICAgIHJldHVybiByZWR1Y2UoaW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzLCBhdHRyaWJ1dGVzLCAnUmVkdWNlTWluJywgcmVkdWNlT3ApO1xuICAgIH07XG5cbmV4cG9ydCBjb25zdCByZWR1Y2VQcm9kOiBPcGVyYXRvckltcGxlbWVudGF0aW9uPFJlZHVjZUF0dHJpYnV0ZXM+ID1cbiAgICAoaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdLCBhdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzKTogVGVuc29yW10gPT4ge1xuICAgICAgY29uc3QgcmVkdWNlT3A6IFJlZHVjZU9wID0gKCk6IHN0cmluZ1tdID0+IFsndmFsdWUgPSAxLjA7JywgJ3ZhbHVlICo9IF9BKGlucHV0SWR4KTsnLCAnJ107XG4gICAgICByZXR1cm4gcmVkdWNlKGluZmVyZW5jZUhhbmRsZXIsIGlucHV0cywgYXR0cmlidXRlcywgJ1JlZHVjZVByb2QnLCByZWR1Y2VPcCk7XG4gICAgfTtcblxuZXhwb3J0IGNvbnN0IHJlZHVjZUxvZ1N1bTogT3BlcmF0b3JJbXBsZW1lbnRhdGlvbjxSZWR1Y2VBdHRyaWJ1dGVzPiA9XG4gICAgKGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSwgYXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcyk6IFRlbnNvcltdID0+IHtcbiAgICAgIGNvbnN0IHJlZHVjZU9wOiBSZWR1Y2VPcCA9ICgpOiBzdHJpbmdbXSA9PiBbJ3ZhbHVlID0gMC4wOycsICd2YWx1ZSArPSBfQShpbnB1dElkeCk7JywgJ3ZhbHVlID0gbG9nKHZhbHVlKTsnXTtcbiAgICAgIHJldHVybiByZWR1Y2UoaW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzLCBhdHRyaWJ1dGVzLCAnUmVkdWNlTG9nU3VtJywgcmVkdWNlT3ApO1xuICAgIH07XG5cbmV4cG9ydCBjb25zdCByZWR1Y2VMb2dTdW1TcXVhcmU6IE9wZXJhdG9ySW1wbGVtZW50YXRpb248UmVkdWNlQXR0cmlidXRlcz4gPVxuICAgIChpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10sIGF0dHJpYnV0ZXM6IFJlZHVjZUF0dHJpYnV0ZXMpOiBUZW5zb3JbXSA9PiB7XG4gICAgICBjb25zdCByZWR1Y2VPcDogUmVkdWNlT3AgPSAoKTogc3RyaW5nW10gPT4gWydmbG9hdCB0OyB2YWx1ZSA9IDAuMDsnLCAndCA9IF9BKGlucHV0SWR4KTsgdmFsdWUgKz0gdCAqIHQ7JywgJyddO1xuICAgICAgcmV0dXJuIHJlZHVjZShpbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHMsIGF0dHJpYnV0ZXMsICdSZWR1Y2VMb2dTdW1TcXVhcmUnLCByZWR1Y2VPcCk7XG4gICAgfTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4uLy4uLy4uL3RlbnNvcic7XG5pbXBvcnQge1NoYXBlVXRpbH0gZnJvbSAnLi4vLi4vLi4vdXRpbCc7XG5pbXBvcnQge1dlYkdMSW5mZXJlbmNlSGFuZGxlcn0gZnJvbSAnLi4vaW5mZXJlbmNlLWhhbmRsZXInO1xuXG5leHBvcnQgY29uc3QgcmVzaGFwZSA9IChoYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOiBUZW5zb3JbXSA9PiB7XG4gIGNvbnN0IHJlc2hhcGVkRGltcyA9IFNoYXBlVXRpbC5jYWxjdWxhdGVSZXNoYXBlZERpbXMoaW5wdXRzWzBdLmRpbXMsIGlucHV0c1sxXS5pbnRlZ2VyRGF0YSk7XG4gIGlmIChoYW5kbGVyLnNlc3Npb24ucGFjaykge1xuICAgIHJldHVybiBbaGFuZGxlci5yZXNoYXBlUGFja2VkKGlucHV0c1swXSwgcmVzaGFwZWREaW1zKV07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFtoYW5kbGVyLnJlc2hhcGVVbnBhY2tlZChpbnB1dHNbMF0sIHJlc2hhcGVkRGltcyldO1xuICB9XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0F0dHJpYnV0ZVdpdGhDYWNoZUtleSwgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5fSBmcm9tICcuLi8uLi8uLi9hdHRyaWJ1dGUtd2l0aC1jYWNoZS1rZXknO1xuaW1wb3J0IHtHcmFwaH0gZnJvbSAnLi4vLi4vLi4vZ3JhcGgnO1xuaW1wb3J0IHtPcGVyYXRvckltcGxlbWVudGF0aW9uLCBPcGVyYXRvckluaXRpYWxpemF0aW9ufSBmcm9tICcuLi8uLi8uLi9vcGVyYXRvcnMnO1xuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4uLy4uLy4uL3RlbnNvcic7XG5pbXBvcnQge2dldEdsc2x9IGZyb20gJy4uL2dsc2wtc291cmNlJztcbmltcG9ydCB7V2ViR0xJbmZlcmVuY2VIYW5kbGVyfSBmcm9tICcuLi9pbmZlcmVuY2UtaGFuZGxlcic7XG5pbXBvcnQge1Byb2dyYW1JbmZvLCBUZXh0dXJlVHlwZX0gZnJvbSAnLi4vdHlwZXMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFVwc2FtcGxlQXR0cmlidXRlcyBleHRlbmRzIEF0dHJpYnV0ZVdpdGhDYWNoZUtleSB7XG4gIHJlYWRvbmx5IG9wc2V0OiBudW1iZXI7XG4gIHJlYWRvbmx5IGlzUmVzaXplOiBib29sZWFuO1xuICByZWFkb25seSBtb2RlOiBzdHJpbmc7XG4gIHJlYWRvbmx5IHNjYWxlczogbnVtYmVyW107XG4gIHJlYWRvbmx5IGV4dHJhcG9sYXRpb25WYWx1ZTogbnVtYmVyO1xuICByZWFkb25seSBjb29yZGluYXRlVHJhbnNmb3JtTW9kZTogc3RyaW5nO1xuICByZWFkb25seSB1c2VFeHRyYXBvbGF0aW9uOiBib29sZWFuO1xuICByZWFkb25seSBuZWVkUm9pSW5wdXQ6IGJvb2xlYW47XG4gIHJlYWRvbmx5IG5lYXJlc3RNb2RlOiBzdHJpbmc7XG4gIHJlYWRvbmx5IGN1YmljQ29lZmZpY2llbnRBOiBudW1iZXI7XG4gIHJlYWRvbmx5IGV4Y2x1ZGVPdXRzaWRlOiBib29sZWFuO1xuICByZWFkb25seSB1c2VOZWFyZXN0MnhPcHRpbWl6YXRpb246IGJvb2xlYW47XG4gIHJlYWRvbmx5IHJvaUlucHV0SWR4OiBudW1iZXI7XG4gIHJlYWRvbmx5IHNjYWxlc0lucHV0SWR4OiBudW1iZXI7XG4gIHJlYWRvbmx5IHNpemVzSW5wdXRJZHg6IG51bWJlcjtcbn1cblxuY29uc3QgdXBzYW1wbGVQcm9ncmFtTWV0YWRhdGEgPSB7XG4gIG5hbWU6ICdVcHNhbXBsZScsXG4gIGlucHV0TmFtZXM6IFsnWCddLFxuICBpbnB1dFR5cGVzOiBbVGV4dHVyZVR5cGUudW5wYWNrZWRdLFxufTtcblxuZXhwb3J0IGNvbnN0IHVwc2FtcGxlOiBPcGVyYXRvckltcGxlbWVudGF0aW9uPFVwc2FtcGxlQXR0cmlidXRlcz4gPVxuICAgIChpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10sIGF0dHJpYnV0ZXM6IFVwc2FtcGxlQXR0cmlidXRlcyk6IFRlbnNvcltdID0+IHtcbiAgICAgIHZhbGlkYXRlSW5wdXRzKGlucHV0cywgYXR0cmlidXRlcyk7XG4gICAgICBjb25zdCBvdXRwdXQgPSBpbmZlcmVuY2VIYW5kbGVyLnJ1bihcbiAgICAgICAgICB7XG4gICAgICAgICAgICAuLi51cHNhbXBsZVByb2dyYW1NZXRhZGF0YSxcbiAgICAgICAgICAgIGNhY2hlSGludDogYXR0cmlidXRlcy5jYWNoZUtleSxcbiAgICAgICAgICAgIGdldDogKCkgPT4gY3JlYXRlVXBzYW1wbGVQcm9ncmFtSW5mbyhpbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHMsIGF0dHJpYnV0ZXMpXG4gICAgICAgICAgfSxcbiAgICAgICAgICBpbnB1dHMpO1xuICAgICAgcmV0dXJuIFtvdXRwdXRdO1xuICAgIH07XG5cbmV4cG9ydCBjb25zdCBwYXJzZVVwc2FtcGxlQXR0cmlidXRlc1Y3OiBPcGVyYXRvckluaXRpYWxpemF0aW9uPFVwc2FtcGxlQXR0cmlidXRlcz4gPVxuICAgIChub2RlOiBHcmFwaC5Ob2RlKTogVXBzYW1wbGVBdHRyaWJ1dGVzID0+IHBhcnNlVXBzYW1wbGVBdHRyaWJ1dGVzKG5vZGUsIDcpO1xuXG5leHBvcnQgY29uc3QgcGFyc2VVcHNhbXBsZUF0dHJpYnV0ZXNWOTogT3BlcmF0b3JJbml0aWFsaXphdGlvbjxVcHNhbXBsZUF0dHJpYnV0ZXM+ID1cbiAgICAobm9kZTogR3JhcGguTm9kZSk6IFVwc2FtcGxlQXR0cmlidXRlcyA9PiBwYXJzZVVwc2FtcGxlQXR0cmlidXRlcyhub2RlLCA5KTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlVXBzYW1wbGVBdHRyaWJ1dGVzID0gKG5vZGU6IEdyYXBoLk5vZGUsIG9wc2V0OiBudW1iZXIpOiBVcHNhbXBsZUF0dHJpYnV0ZXMgPT4ge1xuICBjb25zdCBpc1Jlc2l6ZSA9IChvcHNldCA+PSAxMCk7XG5cbiAgLy8gcHJvY2Vzc2luZyBub2RlIGF0dHJpYnV0ZXNcbiAgY29uc3QgbW9kZSA9IG5vZGUuYXR0cmlidXRlcy5nZXRTdHJpbmcoJ21vZGUnLCAnbmVhcmVzdCcpO1xuICBpZiAobW9kZSAhPT0gJ25lYXJlc3QnICYmIG1vZGUgIT09ICdsaW5lYXInICYmIChvcHNldCA8IDExIHx8IG1vZGUgIT09ICdjdWJpYycpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGB1bnJlY29nbml6ZWQgbW9kZTogJHttb2RlfWApO1xuICB9XG5cbiAgbGV0IHNjYWxlczogbnVtYmVyW10gPSBbXTtcbiAgaWYgKG9wc2V0IDwgOSkge1xuICAgIHNjYWxlcyA9IG5vZGUuYXR0cmlidXRlcy5nZXRGbG9hdHMoJ3NjYWxlcycpO1xuICAgIHNjYWxlc1ZhbGlkYXRpb24oc2NhbGVzLCBtb2RlLCBpc1Jlc2l6ZSk7XG4gIH1cblxuICBjb25zdCBleHRyYXBvbGF0aW9uVmFsdWUgPSBub2RlLmF0dHJpYnV0ZXMuZ2V0RmxvYXQoJ2V4dHJhcG9sYXRpb25fdmFsdWUnLCAwLjApO1xuXG4gIGNvbnN0IGNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlID1cbiAgICAgIG9wc2V0ID4gMTAgPyBub2RlLmF0dHJpYnV0ZXMuZ2V0U3RyaW5nKCdjb29yZGluYXRlX3RyYW5zZm9ybWF0aW9uX21vZGUnLCAnaGFsZl9waXhlbCcpIDogJ2FzeW1tZXRyaWMnO1xuICBpZiAoW1xuICAgICAgICAnYXN5bW1ldHJpYycsICdweXRvcmNoX2hhbGZfcGl4ZWwnLCAndGZfaGFsZl9waXhlbF9mb3Jfbm4nLCAnYWxpZ25fY29ybmVycycsICd0Zl9jcm9wX2FuZF9yZXNpemUnLCAnaGFsZl9waXhlbCdcbiAgICAgIF0uaW5kZXhPZihjb29yZGluYXRlVHJhbnNmb3JtTW9kZSkgPT09IC0xKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBjb29yZGluYXRlX3RyYW5zZm9ybV9tb2RlICcke2Nvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlfScgaXMgbm90IHN1cHBvcnRlZGApO1xuICB9XG4gIGNvbnN0IG5lZWRSb2lJbnB1dCA9IChjb29yZGluYXRlVHJhbnNmb3JtTW9kZSA9PT0gJ3RmX2Nyb3BfYW5kX3Jlc2l6ZScpO1xuICBjb25zdCB1c2VFeHRyYXBvbGF0aW9uID0gbmVlZFJvaUlucHV0O1xuXG4gIGNvbnN0IG5lYXJlc3RNb2RlID1cbiAgICAgIChtb2RlID09PSAnbmVhcmVzdCcgJiYgb3BzZXQgPj0gMTEpID8gbm9kZS5hdHRyaWJ1dGVzLmdldFN0cmluZygnbmVhcmVzdF9tb2RlJywgJ3JvdW5kX3ByZWZlcl9mbG9vcicpIDogJyc7XG4gIGlmIChbJ3JvdW5kX3ByZWZlcl9mbG9vcicsICdyb3VuZF9wcmVmZXJfY2VpbCcsICdmbG9vcicsICdjZWlsJywgJyddLmluZGV4T2YobmVhcmVzdE1vZGUpID09PSAtMSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgbmVhcmVzdF9tb2RlICcke25lYXJlc3RNb2RlfScgaXMgbm90IHN1cHBvcnRlZGApO1xuICB9XG5cbiAgY29uc3QgY3ViaWNDb2VmZmljaWVudEEgPSBub2RlLmF0dHJpYnV0ZXMuZ2V0RmxvYXQoJ2N1YmljX2NvZWZmX2EnLCAtMC43NSk7XG4gIGNvbnN0IGV4Y2x1ZGVPdXRzaWRlID0gbm9kZS5hdHRyaWJ1dGVzLmdldEludCgnZXhjbHVkZV9vdXRzaWRlJywgMCkgIT09IDA7XG4gIGlmIChleGNsdWRlT3V0c2lkZSAmJiBtb2RlICE9PSAnY3ViaWMnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdleGNsdWRlX291dHNpZGUgY2FuIGJlIHNldCB0byAxIG9ubHkgd2hlbiBtb2RlIGlzIENVQklDLicpO1xuICB9XG5cbiAgY29uc3QgdXNlTmVhcmVzdDJ4T3B0aW1pemF0aW9uID1cbiAgICAgIChvcHNldCA8IDExKSA/IHRydWUgOiAobW9kZSA9PT0gJ25lYXJlc3QnICYmIGNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlID09PSAnYXN5bW1ldHJpYycgJiYgbmVhcmVzdE1vZGUgPT09ICdmbG9vcicpO1xuXG4gIGxldCByb2lJbnB1dElkeCA9IDA7XG4gIGxldCBzY2FsZXNJbnB1dElkeCA9IDA7XG4gIGxldCBzaXplc0lucHV0SWR4ID0gMDtcblxuICBpZiAob3BzZXQgPiAxMCkge1xuICAgIC8vIGhhbmRsZSB3aGVuIHJvaUlucHV0IGlzIG5vdCBnaXZlblxuICAgIGlmIChub2RlLmlucHV0cy5sZW5ndGggPiAyKSB7XG4gICAgICByb2lJbnB1dElkeCA9IDE7XG4gICAgICBzY2FsZXNJbnB1dElkeCA9IDI7XG4gICAgICBzaXplc0lucHV0SWR4ID0gMztcbiAgICB9IGVsc2Uge1xuICAgICAgc2NhbGVzSW5wdXRJZHggPSAxO1xuICAgICAgc2l6ZXNJbnB1dElkeCA9IDI7XG4gICAgfVxuICB9IGVsc2UgaWYgKG9wc2V0ID09PSA5KSB7XG4gICAgc2NhbGVzSW5wdXRJZHggPSAxO1xuICB9XG5cbiAgcmV0dXJuIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSh7XG4gICAgb3BzZXQsXG4gICAgaXNSZXNpemUsXG4gICAgbW9kZSxcbiAgICBzY2FsZXMsXG4gICAgZXh0cmFwb2xhdGlvblZhbHVlLFxuICAgIGNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlLFxuICAgIHVzZUV4dHJhcG9sYXRpb24sXG4gICAgbmVlZFJvaUlucHV0LFxuICAgIG5lYXJlc3RNb2RlLFxuICAgIGN1YmljQ29lZmZpY2llbnRBLFxuICAgIGV4Y2x1ZGVPdXRzaWRlLFxuICAgIHVzZU5lYXJlc3QyeE9wdGltaXphdGlvbixcbiAgICByb2lJbnB1dElkeCxcbiAgICBzY2FsZXNJbnB1dElkeCxcbiAgICBzaXplc0lucHV0SWR4XG4gIH0pO1xufTtcblxuY29uc3QgY3JlYXRlVXBzYW1wbGVQcm9ncmFtSW5mbyA9XG4gICAgKGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSwgYXR0cmlidXRlczogVXBzYW1wbGVBdHRyaWJ1dGVzKTogUHJvZ3JhbUluZm8gPT4ge1xuICAgICAgY29uc3QgZ2xzbCA9IGdldEdsc2woaW5mZXJlbmNlSGFuZGxlci5zZXNzaW9uLmJhY2tlbmQuZ2xDb250ZXh0LnZlcnNpb24pO1xuICAgICAgY29uc3QgW2lucHV0V2lkdGgsIGlucHV0SGVpZ2h0XSA9XG4gICAgICAgICAgaW5mZXJlbmNlSGFuZGxlci5jYWxjdWxhdGVUZXh0dXJlV2lkdGhBbmRIZWlnaHQoaW5wdXRzWzBdLmRpbXMsIFRleHR1cmVUeXBlLnVucGFja2VkKTtcblxuICAgICAgY29uc3Qgb3V0cHV0U2hhcGUgPSBpbnB1dHNbMF0uZGltcy5tYXAoKGRpbSwgaSkgPT4gTWF0aC5mbG9vcihkaW0gKiBhdHRyaWJ1dGVzLnNjYWxlc1tpXSkpO1xuICAgICAgY29uc3QgW291dHB1dFdpZHRoLCBvdXRwdXRIZWlnaHRdID1cbiAgICAgICAgICBpbmZlcmVuY2VIYW5kbGVyLmNhbGN1bGF0ZVRleHR1cmVXaWR0aEFuZEhlaWdodChvdXRwdXRTaGFwZSwgVGV4dHVyZVR5cGUudW5wYWNrZWQpO1xuICAgICAgY29uc3QgZGltID0gb3V0cHV0U2hhcGUubGVuZ3RoO1xuXG4gICAgICBjb25zdCBvdXRwdXRQaXRjaGVzID0gbmV3IEFycmF5PG51bWJlcj4oZGltKTtcbiAgICAgIGNvbnN0IGlucHV0UGl0Y2hlcyA9IG5ldyBBcnJheTxudW1iZXI+KGRpbSk7XG4gICAgICBsZXQgcHJlY2FsY3VsYXRlZFBpdGNoZXMgPSBgXG4gICAgICBpbnQgb3V0cHV0X3BpdGNoZXNbJHtkaW19XTtcbiAgICAgIGludCBpbnB1dF9waXRjaGVzWyR7ZGltfV07XG4gICAgICBgO1xuICAgICAgZm9yIChsZXQgZCA9IGRpbSAtIDE7IGQgPj0gMDsgZC0tKSB7XG4gICAgICAgIG91dHB1dFBpdGNoZXNbZF0gPSAoZCA9PT0gZGltIC0gMSkgPyAxIDogb3V0cHV0UGl0Y2hlc1tkICsgMV0gKiBvdXRwdXRTaGFwZVtkICsgMV07XG4gICAgICAgIGlucHV0UGl0Y2hlc1tkXSA9IChkID09PSBkaW0gLSAxKSA/IDEgOiBpbnB1dFBpdGNoZXNbZCArIDFdICogaW5wdXRzWzBdLmRpbXNbZCArIDFdO1xuXG4gICAgICAgIHByZWNhbGN1bGF0ZWRQaXRjaGVzICs9IGBcbiAgICAgICAgb3V0cHV0X3BpdGNoZXNbJHtkfV0gPSAke291dHB1dFBpdGNoZXNbZF19O1xuICAgICAgICBpbnB1dF9waXRjaGVzWyR7ZH1dID0gJHtpbnB1dFBpdGNoZXNbZF19O1xuICAgICAgICBgO1xuICAgICAgfVxuICAgICAgY29uc3QgZ2V0SW5wdXRGbG9hdEZ1bmN0aW9uID0gYFxuICAgICAgZmxvYXQgZ2V0SW5wdXRGbG9hdChpbnQgaW5kZXgpIHtcbiAgICAgICAgdmVjMiBjb29yZHMgPSBvZmZzZXRUb0Nvb3JkcyhpbmRleCwgJHtpbnB1dFdpZHRofSwgJHtpbnB1dEhlaWdodH0pO1xuICAgICAgICBmbG9hdCB2YWx1ZSA9IGdldENvbG9yQXNGbG9hdCgke2dsc2wudGV4dHVyZTJEfShYLCBjb29yZHMpKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgYDtcblxuICAgICAgY29uc3Qgc2hhZGVyU291cmNlID0gYXR0cmlidXRlcy5tb2RlID09PSAnbmVhcmVzdCcgP1xuICAgICAgICAgIC8vIG5lYXJlc3RcbiAgICAgICAgICBgXG4gICAgJHtnZXRJbnB1dEZsb2F0RnVuY3Rpb259XG4gICAgZmxvYXQgcHJvY2VzcyhpbnQgaW5kaWNlc1ske2RpbX1dKSB7XG4gICAgICBpbnQgaW5wdXRfaW5kZXggPSAwO1xuICAgICAgaW50IG91dHB1dF9pbmRleCA9IGNvb3Jkc1RvT2Zmc2V0KFRleENvb3JkcywgJHtvdXRwdXRXaWR0aH0sICR7b3V0cHV0SGVpZ2h0fSk7XG5cbiAgICAgICR7cHJlY2FsY3VsYXRlZFBpdGNoZXN9XG5cbiAgICAgIGludCBkLCBtO1xuICAgICAgZm9yIChpbnQgZGltID0gMDsgZGltIDwgJHtkaW19OyArK2RpbSkge1xuICAgICAgICBkID0gb3V0cHV0X2luZGV4IC8gb3V0cHV0X3BpdGNoZXNbZGltXTtcbiAgICAgICAgbSA9IG91dHB1dF9pbmRleCAtIGQgKiBvdXRwdXRfcGl0Y2hlc1tkaW1dO1xuICAgICAgICBvdXRwdXRfaW5kZXggPSBtO1xuXG4gICAgICAgIGlmIChzY2FsZXNbZGltXSAhPSAxICYmIGQgPiAwKSB7XG4gICAgICAgICAgaW50IGQyID0gZCAvIHNjYWxlc1tkaW1dO1xuICAgICAgICAgIG0gPSBkIC0gZDIgKiBzY2FsZXNbZGltXTtcbiAgICAgICAgICBkID0gZDI7XG4gICAgICAgIH1cbiAgICAgICAgaW5wdXRfaW5kZXggKz0gaW5wdXRfcGl0Y2hlc1tkaW1dICogZDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGdldElucHV0RmxvYXQoaW5wdXRfaW5kZXgpO1xuICAgIH1gIDpcbiAgICAgICAgICBkaW0gPT09IDQgP1xuICAgICAgICAgIC8vIGJpbGluZWFyIDREXG4gICAgICAgICAgICAgIGBcbiAgICAke2dldElucHV0RmxvYXRGdW5jdGlvbn1cbiAgICBmbG9hdCBwcm9jZXNzKGludCBpbmRpY2VzWzRdKSB7XG4gICAgICBpbnQgaW5wdXRfaW5kZXggPSAwO1xuICAgICAgaW50IG91dHB1dF9pbmRleCA9IGNvb3Jkc1RvT2Zmc2V0KFRleENvb3JkcywgJHtvdXRwdXRXaWR0aH0sICR7b3V0cHV0SGVpZ2h0fSk7XG5cbiAgICAgICR7cHJlY2FsY3VsYXRlZFBpdGNoZXN9XG5cbiAgICAgIGludCBtO1xuICAgICAgaW50IGluZGV4X29mX2RpbTAsIGluZGV4X29mX2RpbTEsIGluZGV4X29mX2RpbTIsIGluZGV4X29mX2RpbTM7XG4gICAgICBpbmRleF9vZl9kaW0wID0gb3V0cHV0X2luZGV4IC8gb3V0cHV0X3BpdGNoZXNbMF07XG4gICAgICBtID0gb3V0cHV0X2luZGV4IC0gaW5kZXhfb2ZfZGltMCAqIG91dHB1dF9waXRjaGVzWzBdO1xuICAgICAgaW5kZXhfb2ZfZGltMSA9IG0gLyBvdXRwdXRfcGl0Y2hlc1sxXTtcbiAgICAgIG0gPSBtIC0gaW5kZXhfb2ZfZGltMSAqIG91dHB1dF9waXRjaGVzWzFdO1xuICAgICAgaW5kZXhfb2ZfZGltMiA9IG0gLyBvdXRwdXRfcGl0Y2hlc1syXTtcbiAgICAgIG0gPSBtIC0gaW5kZXhfb2ZfZGltMiAqIG91dHB1dF9waXRjaGVzWzJdO1xuICAgICAgaW5kZXhfb2ZfZGltMyA9IG07XG5cbiAgICAgIGludCBpbmRleF9vZl9pbnB1dF9kaW0yLCBpbmRleF9vZl9pbnB1dF9kaW0zLCB4X29mZnNldCwgeV9vZmZzZXQ7XG4gICAgICBpbmRleF9vZl9pbnB1dF9kaW0yID0gaW5kZXhfb2ZfZGltMiAvIHNjYWxlc1syXTtcbiAgICAgIHlfb2Zmc2V0ID0gaW5kZXhfb2ZfZGltMiAtIGluZGV4X29mX2lucHV0X2RpbTIgKiBzY2FsZXNbMl07XG4gICAgICBpbmRleF9vZl9pbnB1dF9kaW0zID0gaW5kZXhfb2ZfZGltMyAvIHNjYWxlc1szXTtcbiAgICAgIHhfb2Zmc2V0ID0gaW5kZXhfb2ZfZGltMyAtIGluZGV4X29mX2lucHV0X2RpbTMgKiBzY2FsZXNbM107XG5cbiAgICAgIGlucHV0X2luZGV4ID0gaW5kZXhfb2ZfZGltMCAqIGlucHV0X3BpdGNoZXNbMF0gK1xuICAgICAgICAgICAgaW5kZXhfb2ZfZGltMSAqIGlucHV0X3BpdGNoZXNbMV0gK1xuICAgICAgICAgICAgaW5kZXhfb2ZfaW5wdXRfZGltMiAqIGlucHV0X3BpdGNoZXNbMl0gK1xuICAgICAgICAgICAgaW5kZXhfb2ZfaW5wdXRfZGltMztcblxuICAgICAgZmxvYXQgeDAwID0gZ2V0SW5wdXRGbG9hdChpbnB1dF9pbmRleCk7XG4gICAgICBmbG9hdCB4MTAsIHgwMSwgeDExO1xuXG4gICAgICBib29sIGVuZF9vZl9kaW0yID0gZmFsc2U7XG4gICAgICBpZiAoaW5kZXhfb2ZfaW5wdXRfZGltMiA9PSAoJHtpbnB1dHNbMF0uZGltc1syXX0gLSAxKSkge1xuICAgICAgICAvLyBJdCdzIHRoZSBlbmQgaW4gZGltZW5zaW9uIDJcbiAgICAgICAgeDAxID0geDAwO1xuICAgICAgICBlbmRfb2ZfZGltMiA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4MDEgPSBnZXRJbnB1dEZsb2F0KGlucHV0X2luZGV4ICsgaW5wdXRfcGl0Y2hlc1syXSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpbmRleF9vZl9pbnB1dF9kaW0zID09IChpbnB1dF9waXRjaGVzWzJdIC0gMSkpIHtcbiAgICAgICAgLy8gSXQncyB0aGUgZW5kIGluIGRpbWVuc2lvbiAzXG4gICAgICAgIHgxMCA9IHgwMDtcbiAgICAgICAgeDExID0geDAxO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHgxMCA9IGdldElucHV0RmxvYXQoaW5wdXRfaW5kZXggKyAxKTtcbiAgICAgICAgeDExID0gZW5kX29mX2RpbTIgPyB4MTAgOiBnZXRJbnB1dEZsb2F0KGlucHV0X2luZGV4ICsgaW5wdXRfcGl0Y2hlc1syXSArIDEpO1xuICAgICAgfVxuXG4gICAgICBmbG9hdCB5MCA9IHgwMCArIGZsb2F0KHlfb2Zmc2V0KSAqICh4MDEgLSB4MDApIC8gZmxvYXQoc2NhbGVzWzJdKTtcbiAgICAgIGZsb2F0IHkxID0geDEwICsgZmxvYXQoeV9vZmZzZXQpICogKHgxMSAtIHgxMCkgLyBmbG9hdChzY2FsZXNbMl0pO1xuICAgICAgcmV0dXJuIHkwICsgZmxvYXQoeF9vZmZzZXQpICogKHkxIC0geTApIC8gZmxvYXQoc2NhbGVzWzNdKTtcbiAgICB9YCA6XG4gICAgICAgICAgICAgIC8vIGJpbGluZWFyIDJEXG4gICAgICAgICAgICAgIGBcbiAgICAke2dldElucHV0RmxvYXRGdW5jdGlvbn1cbiAgICBmbG9hdCBwcm9jZXNzKGludCBpbmRpY2VzWzJdKSB7XG4gICAgICBpbnQgaW5wdXRfaW5kZXggPSAwO1xuICAgICAgaW50IG91dHB1dF9pbmRleCA9IGNvb3Jkc1RvT2Zmc2V0KFRleENvb3JkcywgJHtvdXRwdXRXaWR0aH0sICR7b3V0cHV0SGVpZ2h0fSk7XG5cbiAgICAgICR7cHJlY2FsY3VsYXRlZFBpdGNoZXN9XG5cbiAgICAgIGludCBtO1xuICAgICAgaW50IGluZGV4X29mX2RpbTAsIGluZGV4X29mX2RpbTE7XG4gICAgICBpbmRleF9vZl9kaW0wID0gb3V0cHV0X2luZGV4IC8gb3V0cHV0X3BpdGNoZXNbMF07XG4gICAgICBtID0gb3V0cHV0X2luZGV4IC0gaW5kZXhfb2ZfZGltMCAqIG91dHB1dF9waXRjaGVzWzBdO1xuICAgICAgaW5kZXhfb2ZfZGltMSA9IG07XG5cbiAgICAgIGludCBpbmRleF9vZl9pbnB1dF9kaW0wLCBpbmRleF9vZl9pbnB1dF9kaW0xLCB4X29mZnNldCwgeV9vZmZzZXQ7XG4gICAgICBpbmRleF9vZl9pbnB1dF9kaW0wID0gaW5kZXhfb2ZfZGltMCAvIHNjYWxlc1swXTtcbiAgICAgIHlfb2Zmc2V0ID0gaW5kZXhfb2ZfZGltMCAtIGluZGV4X29mX2lucHV0X2RpbTAgKiBzY2FsZXNbMF07XG4gICAgICBpbmRleF9vZl9pbnB1dF9kaW0xID0gaW5kZXhfb2ZfZGltMSAvIHNjYWxlc1sxXTtcbiAgICAgIHhfb2Zmc2V0ID0gaW5kZXhfb2ZfZGltMSAtIGluZGV4X29mX2lucHV0X2RpbTEgKiBzY2FsZXNbMV07XG5cbiAgICAgIGlucHV0X2luZGV4ID0gaW5kZXhfb2ZfaW5wdXRfZGltMCAqIGlucHV0X3BpdGNoZXNbMF0gKyBpbmRleF9vZl9pbnB1dF9kaW0xO1xuXG4gICAgICBmbG9hdCB4MDAgPSBnZXRJbnB1dEZsb2F0KGlucHV0X2luZGV4KTtcbiAgICAgIGZsb2F0IHgxMCwgeDAxLCB4MTE7XG5cbiAgICAgIGJvb2wgZW5kX29mX2RpbTAgPSBmYWxzZTtcbiAgICAgIGlmIChpbmRleF9vZl9pbnB1dF9kaW0wID09ICgke2lucHV0c1swXS5kaW1zWzBdfSAtIDEpKSB7XG4gICAgICAgIC8vIEl0J3MgdGhlIGVuZCBpbiBkaW1lbnNpb24gMFxuICAgICAgICB4MDEgPSB4MDA7XG4gICAgICAgIGVuZF9vZl9kaW0wID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHgwMSA9IGdldElucHV0RmxvYXQoaW5wdXRfaW5kZXggKyBpbnB1dF9waXRjaGVzWzBdKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGluZGV4X29mX2lucHV0X2RpbTEgPT0gKGlucHV0X3BpdGNoZXNbMF0gLSAxKSkge1xuICAgICAgICAvLyBJdCdzIHRoZSBlbmQgaW4gZGltZW5zaW9uIDFcbiAgICAgICAgeDEwID0geDAwO1xuICAgICAgICB4MTEgPSB4MDE7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgeDEwID0gZ2V0SW5wdXRGbG9hdChpbnB1dF9pbmRleCArIDEpO1xuICAgICAgICB4MTEgPSBlbmRfb2ZfZGltMCA/IHgxMCA6IGdldElucHV0RmxvYXQoaW5wdXRfaW5kZXggKyBpbnB1dF9waXRjaGVzWzBdICsgMSk7XG4gICAgICB9XG5cbiAgICAgIGZsb2F0IHkwID0geDAwICsgZmxvYXQoeV9vZmZzZXQpICogKHgwMSAtIHgwMCkgLyBmbG9hdChzY2FsZXNbMF0pO1xuICAgICAgZmxvYXQgeTEgPSB4MTAgKyBmbG9hdCh5X29mZnNldCkgKiAoeDExIC0geDEwKSAvIGZsb2F0KHNjYWxlc1swXSk7XG4gICAgICByZXR1cm4geTAgKyBmbG9hdCh4X29mZnNldCkgKiAoeTEgLSB5MCkgLyBmbG9hdChzY2FsZXNbMV0pO1xuICAgIH1gO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4udXBzYW1wbGVQcm9ncmFtTWV0YWRhdGEsXG4gICAgICAgIG91dHB1dDoge2RpbXM6IG91dHB1dFNoYXBlLCB0eXBlOiBpbnB1dHNbMF0udHlwZSwgdGV4dHVyZVR5cGU6IFRleHR1cmVUeXBlLnVucGFja2VkfSxcbiAgICAgICAgc2hhZGVyU291cmNlLFxuICAgICAgICB2YXJpYWJsZXM6IFt7XG4gICAgICAgICAgbmFtZTogJ3NjYWxlcycsXG4gICAgICAgICAgdHlwZTogJ2ludCcsXG4gICAgICAgICAgYXJyYXlMZW5ndGg6IGF0dHJpYnV0ZXMuc2NhbGVzLmxlbmd0aCxcbiAgICAgICAgICBkYXRhOiBhdHRyaWJ1dGVzLnNjYWxlcy5tYXAoeCA9PiBNYXRoLmNlaWwoeCkpXG4gICAgICAgIH1dXG4gICAgICB9O1xuICAgIH07XG5cbmV4cG9ydCBjb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IFRlbnNvcltdLCBhdHRyaWJ1dGU6IFVwc2FtcGxlQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICBpZiAoIWlucHV0cyB8fCAoYXR0cmlidXRlLm9wc2V0IDwgOSAmJiBpbnB1dHMubGVuZ3RoICE9PSAxKSB8fFxuICAgICAgKGF0dHJpYnV0ZS5vcHNldCA+PSA5ICYmIGF0dHJpYnV0ZS5vcHNldCA8IDExICYmIGlucHV0cy5sZW5ndGggIT09IDIpIHx8XG4gICAgICAoYXR0cmlidXRlLm9wc2V0ID49IDExICYmIGlucHV0cy5sZW5ndGggPCAyKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBpbnB1dHMuJyk7XG4gIH1cblxuICBpZiAoYXR0cmlidXRlLnNjYWxlcy5sZW5ndGggPiAwICYmIGlucHV0c1swXS5kaW1zLmxlbmd0aCAhPT0gYXR0cmlidXRlLnNjYWxlcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW5wdXQgc2hhcGUuJyk7XG4gIH1cblxuICBpZiAoaW5wdXRzWzBdLnR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGlucHV0IHRlbnNvciB0eXBlcy4nKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IHNjYWxlc1ZhbGlkYXRpb24gPSAoc2NhbGVzOiBudW1iZXJbXSwgbW9kZTogc3RyaW5nLCBpc1Jlc2l6ZTogYm9vbGVhbik6IHZvaWQgPT4ge1xuICBpZiAoIWlzUmVzaXplKSB7XG4gICAgZm9yIChjb25zdCBzY2FsZSBvZiBzY2FsZXMpIHtcbiAgICAgIGlmIChzY2FsZSA8IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTY2FsZSB2YWx1ZSBzaG91bGQgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDEuJyk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAoY29uc3Qgc2NhbGUgb2Ygc2NhbGVzKSB7XG4gICAgICBpZiAoc2NhbGUgPD0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NjYWxlIHZhbHVlIHNob3VsZCBiZSBncmVhdGVyIHRoYW4gMC4nKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKG1vZGUgPT09ICdsaW5lYXInIHx8IG1vZGUgPT09ICdjdWJpYycpIHtcbiAgICBpZiAoc2NhbGVzLmxlbmd0aCAhPT0gMiAmJiAoc2NhbGVzLmxlbmd0aCAhPT0gNCB8fCBzY2FsZXNbMF0gIT09IDEgfHwgc2NhbGVzWzFdICE9PSAxKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAnTGluZWFyJyBtb2RlIGFuZCAnQ3ViaWMnIG1vZGUgb25seSBzdXBwb3J0IDItRCBpbnB1dHMgKCdCaWxpbmVhcicsICdCaWN1YmljJykgXFxcbiAgICAgICAgb3IgNC1EIGlucHV0cyB3aXRoIHRoZSBjb3JyZXNwb25kaW5nIG91dGVybW9zdCAyIHNjYWxlIHZhbHVlcyBiZWluZyAxIFxcXG4gICAgICAgIGluIHRoZSAke2lzUmVzaXplID8gJ1Jlc2l6ZScgOiAnVXBzYW1wbGUnfSBvcGVhcnRvci5gKTtcbiAgICB9XG4gIH1cbn07IiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0dyYXBofSBmcm9tICcuLi8uLi8uLi9ncmFwaCc7XG5pbXBvcnQge09wZXJhdG9ySW1wbGVtZW50YXRpb24sIE9wZXJhdG9ySW5pdGlhbGl6YXRpb259IGZyb20gJy4uLy4uLy4uL29wZXJhdG9ycyc7XG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi4vLi4vLi4vdGVuc29yJztcbmltcG9ydCB7Z2V0R2xzbH0gZnJvbSAnLi4vZ2xzbC1zb3VyY2UnO1xuaW1wb3J0IHtXZWJHTEluZmVyZW5jZUhhbmRsZXJ9IGZyb20gJy4uL2luZmVyZW5jZS1oYW5kbGVyJztcbmltcG9ydCB7UHJvZ3JhbUluZm8sIFRleHR1cmVUeXBlfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQge2dldENvb3Jkc0RhdGFUeXBlfSBmcm9tICcuLi91dGlscyc7XG5cbmltcG9ydCB7dW5wYWNrRnJvbUNoYW5uZWx9IGZyb20gJy4vcGFja2luZy11dGlscyc7XG5pbXBvcnQge3BhcnNlVXBzYW1wbGVBdHRyaWJ1dGVzLCBzY2FsZXNWYWxpZGF0aW9uLCBVcHNhbXBsZUF0dHJpYnV0ZXMsIHZhbGlkYXRlSW5wdXRzfSBmcm9tICcuL3Vwc2FtcGxlJztcblxuY29uc3QgcmVzaXplUHJvZ3JhbU1ldGFkYXRhID0ge1xuICBuYW1lOiAnUmVzaXplJyxcbiAgaW5wdXROYW1lczogWydBJ10sXG4gIGlucHV0VHlwZXM6IFtUZXh0dXJlVHlwZS5wYWNrZWRdXG59O1xuXG5leHBvcnQgY29uc3QgcmVzaXplOiBPcGVyYXRvckltcGxlbWVudGF0aW9uPFVwc2FtcGxlQXR0cmlidXRlcz4gPVxuICAgIChpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10sIGF0dHJpYnV0ZXM6IFVwc2FtcGxlQXR0cmlidXRlcyk6IFRlbnNvcltdID0+IHtcbiAgICAgIHZhbGlkYXRlSW5wdXRzKGlucHV0cywgYXR0cmlidXRlcyk7XG4gICAgICBjb25zdCBvdXRwdXQgPSBpbmZlcmVuY2VIYW5kbGVyLnJ1bihcbiAgICAgICAgICB7XG4gICAgICAgICAgICAuLi5yZXNpemVQcm9ncmFtTWV0YWRhdGEsXG4gICAgICAgICAgICBjYWNoZUhpbnQ6IGF0dHJpYnV0ZXMuY2FjaGVLZXksXG4gICAgICAgICAgICBnZXQ6ICgpID0+IGNyZWF0ZVBhY2tlZFJlc2l6ZVByb2dyYW1JbmZvKGluZmVyZW5jZUhhbmRsZXIsIGlucHV0cywgYXR0cmlidXRlcylcbiAgICAgICAgICB9LFxuICAgICAgICAgIGlucHV0cyk7XG4gICAgICByZXR1cm4gW291dHB1dF07XG4gICAgfTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlUmVzaXplQXR0cmlidXRlc1YxMDogT3BlcmF0b3JJbml0aWFsaXphdGlvbjxVcHNhbXBsZUF0dHJpYnV0ZXM+ID1cbiAgICAobm9kZTogR3JhcGguTm9kZSk6IFVwc2FtcGxlQXR0cmlidXRlcyA9PiBwYXJzZVVwc2FtcGxlQXR0cmlidXRlcyhub2RlLCAxMCk7XG5cbmV4cG9ydCBjb25zdCBwYXJzZVJlc2l6ZUF0dHJpYnV0ZXNWMTE6IE9wZXJhdG9ySW5pdGlhbGl6YXRpb248VXBzYW1wbGVBdHRyaWJ1dGVzPiA9XG4gICAgKG5vZGU6IEdyYXBoLk5vZGUpOiBVcHNhbXBsZUF0dHJpYnV0ZXMgPT4gcGFyc2VVcHNhbXBsZUF0dHJpYnV0ZXMobm9kZSwgMTEpO1xuXG5jb25zdCBjcmVhdGVQYWNrZWRSZXNpemVQcm9ncmFtSW5mbyA9XG4gICAgKGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSwgYXR0cmlidXRlczogVXBzYW1wbGVBdHRyaWJ1dGVzKTogUHJvZ3JhbUluZm8gPT4ge1xuICAgICAgY29uc3QgZ2xzbCA9IGdldEdsc2woaW5mZXJlbmNlSGFuZGxlci5zZXNzaW9uLmJhY2tlbmQuZ2xDb250ZXh0LnZlcnNpb24pO1xuICAgICAgY29uc3QgW3NjYWxlcywgb3V0cHV0U2hhcGVdID0gcHJlcGFyZUlucHV0cyhpbnB1dHMsIGF0dHJpYnV0ZXMpO1xuXG4gICAgICBjb25zdCBpc1NhbWUgPVxuICAgICAgICAgIHNjYWxlcy5ldmVyeSgoczogbnVtYmVyKSA9PiBzID09PSAxKSAmJiBhdHRyaWJ1dGVzLmNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlICE9PSAndGZfY3JvcF9hbmRfcmVzaXplJztcbiAgICAgIGlmIChpc1NhbWUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi5yZXNpemVQcm9ncmFtTWV0YWRhdGEsXG4gICAgICAgICAgb3V0cHV0OiB7ZGltczogb3V0cHV0U2hhcGUsIHR5cGU6IGlucHV0c1swXS50eXBlLCB0ZXh0dXJlVHlwZTogVGV4dHVyZVR5cGUucGFja2VkfSxcbiAgICAgICAgICBoYXNNYWluOiB0cnVlLFxuICAgICAgICAgIHNoYWRlclNvdXJjZTogYHZvaWQgbWFpbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmVjNCB2ID0gJHtnbHNsLnRleHR1cmUyRH0oWCwgVGV4Q29vcmRzKTtcbiAgICAgICAgICAgICAgICAgICAgJHtnbHNsLm91dHB1dH0gPSB2O1xuICAgICAgICAgICAgICAgIH1gXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGRpbSA9IG91dHB1dFNoYXBlLmxlbmd0aDtcbiAgICAgIGlmIChkaW0gPCAyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgb3V0cHV0IGRpbWVuc2lvbiBzaG91bGQgYmUgYXQgbGVhc3QgMiwgYnV0IGdvdCAke2RpbX1gKTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgb3V0cHV0SGVpZ2h0ID0gb3V0cHV0U2hhcGVbZGltIC0gMl07XG4gICAgICBjb25zdCBvdXRwdXRXaWR0aCA9IG91dHB1dFNoYXBlW2RpbSAtIDFdO1xuXG4gICAgICBjb25zdCBpbnB1dFNoYXBlID0gaW5wdXRzWzBdLmRpbXM7XG4gICAgICBpZiAoZGltICE9PSBpbnB1dFNoYXBlLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG91dHB1dCBkaW1lbnNpb24gc2hvdWxkIG1hdGNoIGlucHV0ICR7aW5wdXRTaGFwZS5sZW5ndGh9LCBidXQgZ290ICR7ZGltfWApO1xuICAgICAgfVxuICAgICAgY29uc3QgaW5wdXRIZWlnaHQgPSBpbnB1dFNoYXBlW2RpbSAtIDJdO1xuICAgICAgY29uc3QgaW5wdXRXaWR0aCA9IGlucHV0U2hhcGVbZGltIC0gMV07XG5cbiAgICAgIGNvbnN0IHNjYWxlc0hlaWdodCA9IHNjYWxlc1tkaW0gLSAyXTtcbiAgICAgIGNvbnN0IHNjYWxlc1dpZHRoID0gc2NhbGVzW2RpbSAtIDFdO1xuXG4gICAgICBsZXQgZ2V0U291cmNlRnJhY0luZGV4ID0gJyc7XG5cbiAgICAgIGlmIChhdHRyaWJ1dGVzLm1vZGUgIT09ICdsaW5lYXInKSB7XG4gICAgICAgIC8vIFRPRE86IHN1cHBvcnQgb3RoZXIgbW9kZXNcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGByZXNpemUgKHBhY2tlZCkgZG9lcyBub3Qgc3VwcG9ydCBtb2RlOiAnJHthdHRyaWJ1dGVzLm1vZGV9J2ApO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChhdHRyaWJ1dGVzLmNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlKSB7XG4gICAgICAgIGNhc2UgJ2FzeW1tZXRyaWMnOlxuICAgICAgICAgIGdldFNvdXJjZUZyYWNJbmRleCA9IGBcbiAgICAgICAgICAgICAgICAgICAgdmVjNCBnZXRTb3VyY2VGcmFjSW5kZXgoaXZlYzQgY29vcmRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmVjNChjb29yZHMpIC8gc2NhbGVXSFdIO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnaGFsZl9waXhlbCc6XG4gICAgICAgICAgZ2V0U291cmNlRnJhY0luZGV4ID0gYFxuICAgICAgICAgICAgICAgICAgICB2ZWM0IGdldFNvdXJjZUZyYWNJbmRleChpdmVjNCBjb29yZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAodmVjNChjb29yZHMpICsgMC41KSAvIHNjYWxlV0hXSCAtIDAuNTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3B5dG9yY2hfaGFsZl9waXhlbCc6XG4gICAgICAgICAgZ2V0U291cmNlRnJhY0luZGV4ID0gYFxuICAgICAgICAgICAgICAgICAgICB2ZWM0IGdldFNvdXJjZUZyYWNJbmRleChpdmVjNCBjb29yZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlYzQgZmNvb3JkcyA9IHZlYzQoY29vcmRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2ZWM0KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICR7b3V0cHV0V2lkdGh9LjAgPiAxLjAgPyAoZmNvb3Jkcy54ICsgMC41KSAvIHNjYWxlV0hXSC54IC0gMC41IDogMC4wLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICR7b3V0cHV0SGVpZ2h0fS4wID4gMS4wID8gKGZjb29yZHMueSArIDAuNSkgLyBzY2FsZVdIV0gueSAtIDAuNSA6IDAuMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAke291dHB1dFdpZHRofS4wID4gMS4wID8gKGZjb29yZHMueiArIDAuNSkgLyBzY2FsZVdIV0gueiAtIDAuNSA6IDAuMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAke291dHB1dEhlaWdodH0uMCA+IDEuMCA/IChmY29vcmRzLncgKyAwLjUpIC8gc2NhbGVXSFdILncgLSAwLjUgOiAwLjBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2FsaWduX2Nvcm5lcnMnOlxuICAgICAgICAgIGdldFNvdXJjZUZyYWNJbmRleCA9IGBcbiAgICAgICAgICAgICAgICAgICAgdmVjNCBnZXRTb3VyY2VGcmFjSW5kZXgoaXZlYzQgY29vcmRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2ZWM0IHJlc2l6ZWQgPSB2ZWM0KCR7b3V0cHV0V2lkdGh9LjAgLSAxLjAsICR7b3V0cHV0SGVpZ2h0fS4wIC0gMS4wLCAke291dHB1dFdpZHRofS4wIC0gMS4wLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICR7b3V0cHV0SGVpZ2h0fS4wIC0gMS4wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlYzQgb3JpZ2luYWwgPSB2ZWM0KCR7aW5wdXRXaWR0aH0uMCAtIDEuMCwgJHtpbnB1dEhlaWdodH0uMCAtIDEuMCwgJHtpbnB1dFdpZHRofS4wIC0gMS4wLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICR7aW5wdXRIZWlnaHR9LjAgLSAxLjApO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmVjNCBuZXdfc2NhbGUgPSBvcmlnaW5hbCAvIHJlc2l6ZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmVjNChjb29yZHMpICogbmV3X3NjYWxlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAvLyBUT0RPOnN1cHBvcnRpbmcgb3RoZXIgY29vcmRpbmF0ZVRyYW5zZm9ybU1vZGVzXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGByZXNpemUgKHBhY2tlZCkgZG9lcyBub3Qgc3VwcG9ydCBjb29yZGluYXRlVHJhbnNmb3JtTW9kZTogXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyR7YXR0cmlidXRlcy5jb29yZGluYXRlVHJhbnNmb3JtTW9kZX0nYCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNvb3Jkc0RhdGFUeXBlID0gZ2V0Q29vcmRzRGF0YVR5cGUoZGltKTtcbiAgICAgIGNvbnN0IHVucGFja0NoYW5uZWwgPSB1bnBhY2tGcm9tQ2hhbm5lbCgpO1xuICAgICAgY29uc3Qgc2hhZGVyU291cmNlID0gYFxuICAgICAgICAgICAgY29uc3QgdmVjMiBpbnB1dFdIID0gdmVjMigke2lucHV0SGVpZ2h0fS4wLCAke2lucHV0V2lkdGh9LjApO1xuICAgICAgICAgICAgY29uc3QgdmVjNCBzY2FsZVdIV0ggPSB2ZWM0KGZsb2F0KCR7c2NhbGVzSGVpZ2h0fSksIGZsb2F0KCR7c2NhbGVzV2lkdGh9KSwgZmxvYXQoJHtzY2FsZXNIZWlnaHR9KSwgZmxvYXQoJHtcbiAgICAgICAgICBzY2FsZXNXaWR0aH0pKTtcbiAgICAgICAgICAgICR7dW5wYWNrQ2hhbm5lbH1cbiAgICAgICAgICAgICR7Z2V0U291cmNlRnJhY0luZGV4fVxuICAgICAgICAgICAgZmxvYXQgZ2V0QVZhbHVlKGludCB4MTAsIGludCByLCBpbnQgYywgaW50IGQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0Q2hhbm5lbChnZXRBKHgxMCwgciwgYywgZCksIHZlYzIoYywgZCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICAgICAgICAgICR7Y29vcmRzRGF0YVR5cGV9IHJjID0gZ2V0T3V0cHV0Q29vcmRzKCk7XG5cbiAgICAgICAgICAgICAgICBpbnQgYmF0Y2ggPSByY1swXTtcbiAgICAgICAgICAgICAgICBpbnQgZGVwdGggPSByY1sxXTtcblxuICAgICAgICAgICAgICAgIC8vIHJldHJpZXZlIHRoZSA0IGNvb3JkaW5hdGVzIHRoYXQgaXMgdXNlZCBpbiB0aGUgNCBwYWNrZWQgb3V0cHV0IHZhbHVlcy5cbiAgICAgICAgICAgICAgICBpdmVjNCBjb29yZHMgPSBpdmVjNChyYy53eiwgcmMudyArIDEsIHJjLnogKyAxKTtcblxuICAgICAgICAgICAgICAgIC8vIGNhbGN1bGF0ZSB0aGUgc291cmNlIGluZGV4IGluIGZyYWN0aW9uXG4gICAgICAgICAgICAgICAgdmVjNCBzb3VyY2VGcmFjID0gZ2V0U291cmNlRnJhY0luZGV4KGNvb3Jkcyk7XG5cbiAgICAgICAgICAgICAgICAvLyBnZXQgdGhlIGxvd2VyIGFuZCB1cHBlciBib3VuZCBvZiB0aGUgNCB2YWx1ZXMgdGhhdCB3aWxsIGJlIHBhY2tlZCBpbnRvIG9uZSB0ZXhlbC5cbiAgICAgICAgICAgICAgICBpdmVjNCB4MDAgPSBpdmVjNChtYXgoc291cmNlRnJhYy54eSwgdmVjMigwLjApKSwgbWluKGlucHV0V0ggLSAxLjAsIGNlaWwoc291cmNlRnJhYy54eSkpKTtcbiAgICAgICAgICAgICAgICBpdmVjNCB4MDEgPSBpdmVjNChtYXgoc291cmNlRnJhYy54dywgdmVjMigwLjApKSwgbWluKGlucHV0V0ggLSAxLjAsIGNlaWwoc291cmNlRnJhYy54dykpKTtcbiAgICAgICAgICAgICAgICBpdmVjNCB4MTAgPSBpdmVjNChtYXgoc291cmNlRnJhYy56eSwgdmVjMigwLjApKSwgbWluKGlucHV0V0ggLSAxLjAsIGNlaWwoc291cmNlRnJhYy56eSkpKTtcbiAgICAgICAgICAgICAgICBpdmVjNCB4MTEgPSBpdmVjNChtYXgoc291cmNlRnJhYy56dywgdmVjMigwLjApKSwgbWluKGlucHV0V0ggLSAxLjAsIGNlaWwoc291cmNlRnJhYy56dykpKTtcblxuICAgICAgICAgICAgICAgIGJvb2wgaGFzTmV4dFJvdyA9IHJjLncgPCAke291dHB1dEhlaWdodCAtIDF9O1xuICAgICAgICAgICAgICAgIGJvb2wgaGFzTmV4dENvbCA9IHJjLnogPCAke291dHB1dFdpZHRoIC0gMX07XG5cbiAgICAgICAgICAgICAgICAvLyBwYWNrIHgwMCwgeDAxLCB4MTAsIHgxMSdzIHRvcC1sZWZ0IGNvcm5lciBpbnRvIG9uZSB2ZWM0IHN0cnVjdHVyZVxuICAgICAgICAgICAgICAgIHZlYzQgdG9wTGVmdCA9IHZlYzQoXG4gICAgICAgICAgICAgICAgICAgIGdldEFWYWx1ZShiYXRjaCwgZGVwdGgsIHgwMC54LCB4MDAueSksXG4gICAgICAgICAgICAgICAgICAgIGhhc05leHRDb2wgPyBnZXRBVmFsdWUoYmF0Y2gsIGRlcHRoLCB4MDEueCwgeDAxLnkpIDogMC4wLFxuICAgICAgICAgICAgICAgICAgICBoYXNOZXh0Um93ID8gZ2V0QVZhbHVlKGJhdGNoLCBkZXB0aCwgeDEwLngsIHgxMC55KSA6IDAuMCxcbiAgICAgICAgICAgICAgICAgICAgKGhhc05leHRSb3cgJiYgaGFzTmV4dENvbCkgPyBnZXRBVmFsdWUoYmF0Y2gsIGRlcHRoLCB4MTEueCwgeDExLnkpIDogMC4wKTtcblxuICAgICAgICAgICAgICAgIC8vIHBhY2sgeDAwLCB4MDEsIHgxMCwgeDExJ3MgdG9wLXJpZ2h0IGNvcm5lciBpbnRvIG9uZSB2ZWM0IHN0cnVjdHVyZVxuICAgICAgICAgICAgICAgIHZlYzQgdG9wUmlnaHQgPSB2ZWM0KFxuICAgICAgICAgICAgICAgICAgICBnZXRBVmFsdWUoYmF0Y2gsIGRlcHRoLCB4MDAueCwgeDAwLncpLFxuICAgICAgICAgICAgICAgICAgICBoYXNOZXh0Q29sID8gZ2V0QVZhbHVlKGJhdGNoLCBkZXB0aCwgeDAxLngsIHgwMS53KSA6IDAuMCxcbiAgICAgICAgICAgICAgICAgICAgaGFzTmV4dFJvdyA/IGdldEFWYWx1ZShiYXRjaCwgZGVwdGgsIHgxMC54LCB4MTAudykgOiAwLjAsXG4gICAgICAgICAgICAgICAgICAgIChoYXNOZXh0Um93ICYmIGhhc05leHRDb2wpID8gZ2V0QVZhbHVlKGJhdGNoLCBkZXB0aCwgeDExLngsIHgxMS53KSA6IDAuMCk7XG5cbiAgICAgICAgICAgICAgICAvLyBwYWNrIHgwMCwgeDAxLCB4MTAsIHgxMSdzIGJvdHRvbS1sZWZ0IGNvcm5lciBpbnRvIG9uZSB2ZWM0IHN0cnVjdHVyZVxuICAgICAgICAgICAgICAgIHZlYzQgYm90dG9tTGVmdCA9IHZlYzQoXG4gICAgICAgICAgICAgICAgICAgIGdldEFWYWx1ZShiYXRjaCwgZGVwdGgsIHgwMC56LCB4MDAueSksXG4gICAgICAgICAgICAgICAgICAgIGhhc05leHRDb2wgPyBnZXRBVmFsdWUoYmF0Y2gsIGRlcHRoLCB4MDEueiwgeDAxLnkpIDogMC4wLFxuICAgICAgICAgICAgICAgICAgICBoYXNOZXh0Um93ID8gZ2V0QVZhbHVlKGJhdGNoLCBkZXB0aCwgeDEwLnosIHgxMC55KSA6IDAuMCxcbiAgICAgICAgICAgICAgICAgICAgKGhhc05leHRSb3cgJiYgaGFzTmV4dENvbCkgPyBnZXRBVmFsdWUoYmF0Y2gsIGRlcHRoLCB4MTEueiwgeDExLnkpIDogMC4wKTtcblxuICAgICAgICAgICAgICAgIC8vIHBhY2sgeDAwLCB4MDEsIHgxMCwgeDExJ3MgYm90dG9tLXJpZ2h0IGNvcm5lciBpbnRvIG9uZSB2ZWM0IHN0cnVjdHVyZVxuICAgICAgICAgICAgICAgIHZlYzQgYm90dG9tUmlnaHQgPSB2ZWM0KFxuICAgICAgICAgICAgICAgICAgICBnZXRBVmFsdWUoYmF0Y2gsIGRlcHRoLCB4MDAueiwgeDAwLncpLFxuICAgICAgICAgICAgICAgICAgICBoYXNOZXh0Q29sID8gZ2V0QVZhbHVlKGJhdGNoLCBkZXB0aCwgeDAxLnosIHgwMS53KSA6IDAuMCxcbiAgICAgICAgICAgICAgICAgICAgaGFzTmV4dFJvdyA/IGdldEFWYWx1ZShiYXRjaCwgZGVwdGgsIHgxMC56LCB4MTAudykgOiAwLjAsXG4gICAgICAgICAgICAgICAgICAgIChoYXNOZXh0Um93ICYmIGhhc05leHRDb2wpID8gZ2V0QVZhbHVlKGJhdGNoLCBkZXB0aCwgeDExLnosIHgxMS53KSA6IDAuMCk7XG5cbiAgICAgICAgICAgICAgICAvLyBjYWxjdWxhdGUgdGhlIGludGVycG9sYXRpb24gZnJhY3Rpb24gb24gdSBhbmQgdiBkaXJlY3Rpb25cbiAgICAgICAgICAgICAgICB2ZWM0IGZyYWMgPSB2ZWM0KHNvdXJjZUZyYWMpIC0gZmxvb3Ioc291cmNlRnJhYyk7XG4gICAgICAgICAgICAgICAgdmVjNCBjbGFtcEZyYWMgPSBjbGFtcChmcmFjLCB2ZWM0KDAuMCksIHZlYzQoMS4wKSk7XG5cbiAgICAgICAgICAgICAgICB2ZWM0IHRvcCA9IG1peCh0b3BMZWZ0LCB0b3BSaWdodCwgY2xhbXBGcmFjLnl3eXcpO1xuICAgICAgICAgICAgICAgIHZlYzQgYm90dG9tID0gbWl4KGJvdHRvbUxlZnQsIGJvdHRvbVJpZ2h0LCBjbGFtcEZyYWMueXd5dyk7XG4gICAgICAgICAgICAgICAgdmVjNCBuZXdWYWx1ZSA9IG1peCh0b3AsIGJvdHRvbSwgY2xhbXBGcmFjLnh4enopO1xuXG4gICAgICAgICAgICAgICAgJHtnbHNsLm91dHB1dH0gPSB2ZWM0KG5ld1ZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgYDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLnJlc2l6ZVByb2dyYW1NZXRhZGF0YSxcbiAgICAgICAgb3V0cHV0OiB7ZGltczogb3V0cHV0U2hhcGUsIHR5cGU6IGlucHV0c1swXS50eXBlLCB0ZXh0dXJlVHlwZTogVGV4dHVyZVR5cGUucGFja2VkfSxcbiAgICAgICAgaGFzTWFpbjogdHJ1ZSxcbiAgICAgICAgc2hhZGVyU291cmNlXG4gICAgICB9O1xuICAgIH07XG5cblxuY29uc3QgcHJlcGFyZUlucHV0cyA9IChpbnB1dHM6IFRlbnNvcltdLCBhdHRyaWJ1dGVzOiBVcHNhbXBsZUF0dHJpYnV0ZXMpOiBbcmVhZG9ubHkgbnVtYmVyW10sIHJlYWRvbmx5IG51bWJlcltdXSA9PiB7XG4gIGNvbnN0IHggPSBpbnB1dHNbMF07XG4gIGNvbnN0IHhEaW1zID0geC5kaW1zO1xuXG4gIGxldCBzY2FsZXMgPSBhdHRyaWJ1dGVzLnNjYWxlcztcbiAgbGV0IG91dHB1dFNpemVzOiBudW1iZXJbXXx1bmRlZmluZWQ7XG4gIGlmIChzY2FsZXMubGVuZ3RoID09PSAwKSB7XG4gICAgY29uc3Qgc2NhbGVzVGVuc29yID0gaW5wdXRzW2F0dHJpYnV0ZXMuc2NhbGVzSW5wdXRJZHhdO1xuICAgIGlmIChzY2FsZXNUZW5zb3IgJiYgc2NhbGVzVGVuc29yLnNpemUgIT09IDApIHtcbiAgICAgIGlmIChpbnB1dHNbYXR0cmlidXRlcy5zaXplc0lucHV0SWR4XSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09ubHkgb25lIG9mIHNjYWxlcyBvciBzaXplcyBtdXN0IGJlIHByb3ZpZGVkIGFzIGlucHV0LicpO1xuICAgICAgfVxuICAgICAgc2NhbGVzID0gcGFyc2VTY2FsZXNEYXRhKHNjYWxlc1RlbnNvciwgYXR0cmlidXRlcy5tb2RlLCBhdHRyaWJ1dGVzLmlzUmVzaXplKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgc2l6ZXNUZW5zb3IgPSBpbnB1dHNbYXR0cmlidXRlcy5zaXplc0lucHV0SWR4XTtcbiAgICAgIGlmICghc2l6ZXNUZW5zb3IgfHwgc2l6ZXNUZW5zb3Iuc2l6ZSA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VpdGhlciBzY2FsZXMgb3Igc2l6ZXMgTVVTVCBiZSBwcm92aWRlZCBhcyBpbnB1dC4nKTtcbiAgICAgIH1cblxuICAgICAgb3V0cHV0U2l6ZXMgPSBBcnJheS5mcm9tKHNpemVzVGVuc29yLmludGVnZXJEYXRhKTtcbiAgICAgIHNjYWxlcyA9IHBhcnNlU2NhbGVzRGF0YUZyb21PdXRwdXRTaXplKG91dHB1dFNpemVzLCB4RGltcywgYXR0cmlidXRlcy5tb2RlLCBhdHRyaWJ1dGVzLmlzUmVzaXplKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGlucHV0c1thdHRyaWJ1dGVzLnNpemVzSW5wdXRJZHhdKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ09ubHkgb25lIG9mIHNjYWxlcyBvciBzaXplcyBtdXN0IGJlIHByb3ZpZGVkIGFzIGlucHV0LicpO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHlEaW1zID0gb3V0cHV0U2l6ZXMgfHwgKHhEaW1zLm1hcCgoZGltLCBpKSA9PiBNYXRoLmZsb29yKGRpbSAqIHNjYWxlc1tpXSkpKTtcblxuICByZXR1cm4gW3NjYWxlcywgeURpbXNdO1xufTtcblxuY29uc3QgcGFyc2VTY2FsZXNEYXRhID0gKHNjYWxlOiBUZW5zb3IsIG1vZGU6IHN0cmluZywgaXNSZXNpemU6IGJvb2xlYW4pOiBudW1iZXJbXSA9PiB7XG4gIGNvbnN0IHNjYWxlcyA9IEFycmF5LmZyb20oc2NhbGUuZmxvYXREYXRhKTtcbiAgc2NhbGVzVmFsaWRhdGlvbihzY2FsZXMsIG1vZGUsIGlzUmVzaXplKTtcbiAgcmV0dXJuIHNjYWxlcztcbn07XG5cbmNvbnN0IHBhcnNlU2NhbGVzRGF0YUZyb21PdXRwdXRTaXplID1cbiAgICAoeURpbXM6IHJlYWRvbmx5IG51bWJlcltdLCB4RGltczogcmVhZG9ubHkgbnVtYmVyW10sIG1vZGU6IHN0cmluZywgaXNSZXNpemU6IGJvb2xlYW4pOiBudW1iZXJbXSA9PiB7XG4gICAgICBjb25zdCBsZW5ndGggPSB4RGltcy5sZW5ndGg7XG4gICAgICBjb25zdCBzY2FsZXMgPSBuZXcgQXJyYXk8bnVtYmVyPihsZW5ndGgpO1xuXG4gICAgICBmb3IgKGxldCBpID0gMCwgZW5kID0gbGVuZ3RoOyBpIDwgZW5kOyBpKyspIHtcbiAgICAgICAgaWYgKHhEaW1zW2ldID09PSAwKSB7XG4gICAgICAgICAgaWYgKHlEaW1zW2ldICE9PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IGRpbSBpcyB6ZXJvIGJ1dCByZXF1aXJlZCBvdXRwdXQgZGltIGlzIG5vbi16ZXJvLicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzY2FsZXNbaV0gPSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNjYWxlc1tpXSA9IHlEaW1zW2ldIC8geERpbXNbaV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHNjYWxlc1ZhbGlkYXRpb24oc2NhbGVzLCBtb2RlLCBpc1Jlc2l6ZSk7XG4gICAgICByZXR1cm4gc2NhbGVzO1xuICAgIH07XG5cbi8vIHJvaSBkYXRhIGlzIG5vdCB1c2VkIHlldC4gYnV0IGxlYXZlIGhlcmUgZm9yIGZ1dHVyZSB1c2FnZS5cbi8vIGNvbnN0IGdldFJvaSA9IChpbnB1dHM6IFRlbnNvcltdLCBhdHRyaWJ1dGVzOiBVcHNhbXBsZUF0dHJpYnV0ZXMpIDogbnVtYmVyW10gPT4ge1xuLy8gICAgIGxldCByb2k6IG51bWJlcltdID0gW107XG4vLyAgICAgaWYgKGF0dHJpYnV0ZXMubmVlZFJvaUlucHV0KSB7XG4vLyAgICAgICAgIGlmIChhdHRyaWJ1dGVzLnJvaUlucHV0SWR4IDw9IDApIHtcbi8vICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCByb2kgaW5wdXQgaW5kZXguJyk7XG4vLyAgICAgICAgIH1cbi8vICAgICAgICAgY29uc3Qgcm9pVGVuc29yID0gaW5wdXRzW2F0dHJpYnV0ZXMucm9pSW5wdXRJZHhdO1xuLy8gICAgICAgICByb2kgPSByb2lUZW5zb3Iuc2l6ZSA+IDAgPyBBcnJheS5mcm9tKHJvaVRlbnNvci5mbG9hdERhdGEpIDogW107XG4vLyAgICAgfSBlbHNlIHtcbi8vICAgICAgICAgcm9pID0gbmV3IEFycmF5KGlucHV0c1swXS5kaW1zLmxlbmd0aCAqIDIpLmZpbGwoMCk7XG4vLyAgICAgfVxuLy8gICAgIHJldHVybiByb2k7XG4vLyB9O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi4vLi4vLi4vdGVuc29yJztcbmltcG9ydCB7V2ViR0xJbmZlcmVuY2VIYW5kbGVyfSBmcm9tICcuLi9pbmZlcmVuY2UtaGFuZGxlcic7XG5cbmV4cG9ydCBjb25zdCBzaGFwZSA9IChfaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTogVGVuc29yW10gPT4ge1xuICB2YWxpZGF0ZUlucHV0cyhpbnB1dHMpO1xuICByZXR1cm4gW25ldyBUZW5zb3IoW2lucHV0c1swXS5kaW1zLmxlbmd0aF0sICdpbnQzMicsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBuZXcgSW50MzJBcnJheShpbnB1dHNbMF0uZGltcykpXTtcbn07XG5cbmNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogVGVuc29yW10pOiB2b2lkID0+IHtcbiAgaWYgKCFpbnB1dHMgfHwgaW5wdXRzLmxlbmd0aCAhPT0gMSkge1xuICAgIHRocm93IG5ldyBFcnJvcignU2hhcGUgcmVxdWlyZXMgMSBpbnB1dC4nKTtcbiAgfVxufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtBdHRyaWJ1dGVXaXRoQ2FjaGVLZXksIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleX0gZnJvbSAnLi4vLi4vLi4vYXR0cmlidXRlLXdpdGgtY2FjaGUta2V5JztcbmltcG9ydCB7R3JhcGh9IGZyb20gJy4uLy4uLy4uL2dyYXBoJztcbmltcG9ydCB7TlVNQkVSX1RZUEVTLCBPcGVyYXRvckltcGxlbWVudGF0aW9uLCBPcGVyYXRvckluaXRpYWxpemF0aW9ufSBmcm9tICcuLi8uLi8uLi9vcGVyYXRvcnMnO1xuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4uLy4uLy4uL3RlbnNvcic7XG5pbXBvcnQge1NoYXBlVXRpbH0gZnJvbSAnLi4vLi4vLi4vdXRpbCc7XG5pbXBvcnQge1dlYkdMSW5mZXJlbmNlSGFuZGxlcn0gZnJvbSAnLi4vaW5mZXJlbmNlLWhhbmRsZXInO1xuaW1wb3J0IHtQcm9ncmFtSW5mbywgVGV4dHVyZVR5cGV9IGZyb20gJy4uL3R5cGVzJztcblxuZXhwb3J0IGludGVyZmFjZSBTbGljZUF0dHJpYnV0ZXMgZXh0ZW5kcyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkge1xuICByZWFkb25seSBheGVzOiBudW1iZXJbXTtcbiAgcmVhZG9ubHkgZW5kczogbnVtYmVyW107XG4gIHJlYWRvbmx5IHN0YXJ0czogbnVtYmVyW107XG59XG5cbmNvbnN0IHNsaWNlUHJvZ3JhbU1ldGFkYXRhID0ge1xuICBuYW1lOiAnU2xpY2UnLFxuICBpbnB1dE5hbWVzOiBbJ0EnXSxcbiAgaW5wdXRUeXBlczogW1RleHR1cmVUeXBlLnVucGFja2VkXVxufTtcblxuZXhwb3J0IGNvbnN0IHNsaWNlOiBPcGVyYXRvckltcGxlbWVudGF0aW9uPFNsaWNlQXR0cmlidXRlcz4gPVxuICAgIChpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10sIGF0dHJpYnV0ZXM6IFNsaWNlQXR0cmlidXRlcyk6IFRlbnNvcltdID0+IHtcbiAgICAgIHZhbGlkYXRlSW5wdXRzKGlucHV0cyk7XG4gICAgICBjb25zdCBvdXRwdXQgPSBpbmZlcmVuY2VIYW5kbGVyLnJ1bihcbiAgICAgICAgICB7XG4gICAgICAgICAgICAuLi5zbGljZVByb2dyYW1NZXRhZGF0YSxcbiAgICAgICAgICAgIGNhY2hlSGludDogYXR0cmlidXRlcy5jYWNoZUtleSxcbiAgICAgICAgICAgIGdldDogKCkgPT4gY3JlYXRlU2xpY2VQcm9ncmFtSW5mbyhpbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHNbMF0sIGF0dHJpYnV0ZXMpXG4gICAgICAgICAgfSxcbiAgICAgICAgICBpbnB1dHMpO1xuICAgICAgcmV0dXJuIFtvdXRwdXRdO1xuICAgIH07XG5cbmV4cG9ydCBjb25zdCBwYXJzZVNsaWNlQXR0cmlidXRlczogT3BlcmF0b3JJbml0aWFsaXphdGlvbjxTbGljZUF0dHJpYnV0ZXM+ID0gKG5vZGU6IEdyYXBoLk5vZGUpOiBTbGljZUF0dHJpYnV0ZXMgPT4ge1xuICBjb25zdCBzdGFydHMgPSBub2RlLmF0dHJpYnV0ZXMuZ2V0SW50cygnc3RhcnRzJyk7XG4gIGNvbnN0IGVuZHMgPSBub2RlLmF0dHJpYnV0ZXMuZ2V0SW50cygnZW5kcycpO1xuICBjb25zdCBheGVzID0gbm9kZS5hdHRyaWJ1dGVzLmdldEludHMoJ2F4ZXMnLCBbXSk7XG4gIHJldHVybiBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkoe3N0YXJ0cywgZW5kcywgYXhlc30pO1xufTtcblxuY29uc3QgY3JlYXRlU2xpY2VQcm9ncmFtSW5mbyA9XG4gICAgKF9pbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0OiBUZW5zb3IsIGF0dHJpYnV0ZXM6IFNsaWNlQXR0cmlidXRlcyk6IFByb2dyYW1JbmZvID0+IHtcbiAgICAgIGNvbnN0IGF4ZXMgPSAoYXR0cmlidXRlcy5heGVzLmxlbmd0aCA9PT0gMCkgPyBpbnB1dC5kaW1zLnNsaWNlKDApLm1hcCgoX3ZhbCwgaSkgPT4gaSkgOiBhdHRyaWJ1dGVzLmF4ZXM7XG4gICAgICBjb25zdCBub3JtYWxpemVkQXhlcyA9IFNoYXBlVXRpbC5ub3JtYWxpemVBeGVzKGF4ZXMsIGlucHV0LmRpbXMubGVuZ3RoKTtcbiAgICAgIGNvbnN0IHN0YXJ0cyA9IGF0dHJpYnV0ZXMuc3RhcnRzLm1hcCgoc3RhcnQsIGkpID0+IHtcbiAgICAgICAgaWYgKHN0YXJ0ID4gaW5wdXQuZGltc1tub3JtYWxpemVkQXhlc1tpXV0gLSAxKSB7XG4gICAgICAgICAgcmV0dXJuIGlucHV0LmRpbXNbbm9ybWFsaXplZEF4ZXNbaV1dO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTaGFwZVV0aWwubm9ybWFsaXplQXhpcyhzdGFydCwgaW5wdXQuZGltc1tub3JtYWxpemVkQXhlc1tpXV0pO1xuICAgICAgfSk7XG4gICAgICBjb25zdCBlbmRzID0gYXR0cmlidXRlcy5lbmRzLm1hcCgoZW5kLCBpKSA9PiB7XG4gICAgICAgIGlmIChlbmQgPiBpbnB1dC5kaW1zW25vcm1hbGl6ZWRBeGVzW2ldXSAtIDEpIHtcbiAgICAgICAgICByZXR1cm4gaW5wdXQuZGltc1tub3JtYWxpemVkQXhlc1tpXV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFNoYXBlVXRpbC5ub3JtYWxpemVBeGlzKGVuZCwgaW5wdXQuZGltc1tub3JtYWxpemVkQXhlc1tpXV0pO1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IG91dHB1dFNoYXBlID0gaW5wdXQuZGltcy5zbGljZSgpO1xuXG4gICAgICBjb25zdCBzbGljZU9wczogc3RyaW5nW10gPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9ybWFsaXplZEF4ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgb3V0cHV0U2hhcGVbbm9ybWFsaXplZEF4ZXNbaV1dID0gZW5kc1tpXSAtIHN0YXJ0c1tpXTtcbiAgICAgICAgaWYgKHN0YXJ0c1tpXSA+IDApIHtcbiAgICAgICAgICBzbGljZU9wcy5wdXNoKGBvdXRwdXRJZHhbJHtub3JtYWxpemVkQXhlc1tpXX1dICs9ICR7c3RhcnRzW2ldfTtgKTtcbiAgICAgICAgfSAgLy8gZWxzZSB7IHNsaWNlT3BzLnB1c2goYG91dHB1dElkeFske25vcm1hbGl6ZWRBeGVzW2ldfV0gKz0gMDtgKTsgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCByYW5rID0gb3V0cHV0U2hhcGUubGVuZ3RoO1xuICAgICAgY29uc3Qgc2hhZGVyU291cmNlID0gYFxuICAgICAgZmxvYXQgcHJvY2VzcyhpbnQgb3V0cHV0SWR4WyR7cmFua31dKSB7XG4gICAgICAgICR7c2xpY2VPcHMuam9pbignXFxuICAgICAgJyl9XG4gICAgICAgIHJldHVybiBfQShvdXRwdXRJZHgpO1xuICAgICAgfWA7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5zbGljZVByb2dyYW1NZXRhZGF0YSxcbiAgICAgICAgb3V0cHV0OiB7ZGltczogb3V0cHV0U2hhcGUsIHR5cGU6IGlucHV0LnR5cGUsIHRleHR1cmVUeXBlOiBUZXh0dXJlVHlwZS51bnBhY2tlZH0sXG4gICAgICAgIHNoYWRlclNvdXJjZVxuICAgICAgfTtcbiAgICB9O1xuXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IFRlbnNvcltdKTogdm9pZCA9PiB7XG4gIGlmICghaW5wdXRzIHx8IGlucHV0cy5sZW5ndGggIT09IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1NsaWNlIHJlcXVpcmVzIDEgaW5wdXQuJyk7XG4gIH1cbiAgaWYgKE5VTUJFUl9UWVBFUy5pbmRleE9mKGlucHV0c1swXS50eXBlKSA9PT0gLTEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW5wdXQgdHlwZS4nKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IHNsaWNlVjEwID0gKGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IFRlbnNvcltdID0+IHtcbiAgdmFsaWRhdGVJbnB1dHNWMTAoaW5wdXRzKTtcbiAgY29uc3QgYXR0cmlidXRlcyA9IGdlbmVyYXRlU2xpY2VBdHRyaWJ1dGVzRnJvbUlucHV0cyhpbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHMpO1xuICBjb25zdCBvdXRwdXQgPSBpbmZlcmVuY2VIYW5kbGVyLnJ1bihcbiAgICAgIHtcbiAgICAgICAgLi4uc2xpY2VQcm9ncmFtTWV0YWRhdGEsXG4gICAgICAgIGNhY2hlSGludDogYXR0cmlidXRlcy5jYWNoZUtleSxcbiAgICAgICAgZ2V0OiAoKSA9PiBjcmVhdGVTbGljZVByb2dyYW1JbmZvKGluZmVyZW5jZUhhbmRsZXIsIGlucHV0c1swXSwgYXR0cmlidXRlcylcbiAgICAgIH0sXG4gICAgICBbaW5wdXRzWzBdXSk7XG4gIHJldHVybiBbb3V0cHV0XTtcbn07XG5cbmNvbnN0IGdlbmVyYXRlU2xpY2VBdHRyaWJ1dGVzRnJvbUlucHV0cyA9XG4gICAgKGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IFNsaWNlQXR0cmlidXRlcyA9PiB7XG4gICAgICBpZiAoIWluZmVyZW5jZUhhbmRsZXIuc2Vzc2lvbi5pc0luaXRpYWxpemVyKGlucHV0c1sxXS5kYXRhSWQpIHx8XG4gICAgICAgICAgIWluZmVyZW5jZUhhbmRsZXIuc2Vzc2lvbi5pc0luaXRpYWxpemVyKGlucHV0c1syXS5kYXRhSWQpIHx8XG4gICAgICAgICAgKGlucHV0cy5sZW5ndGggPj0gNCAmJiAhaW5mZXJlbmNlSGFuZGxlci5zZXNzaW9uLmlzSW5pdGlhbGl6ZXIoaW5wdXRzWzNdLmRhdGFJZCkpIHx8XG4gICAgICAgICAgKGlucHV0cy5sZW5ndGggPj0gNSAmJiAhaW5mZXJlbmNlSGFuZGxlci5zZXNzaW9uLmlzSW5pdGlhbGl6ZXIoaW5wdXRzWzRdLmRhdGFJZCkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZHluYW1pYyBzbGljZSBhdHRyaWJ1dGVzIGFyZSBub3QgYWxsb3dlZCcpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaW5wdXRzLmxlbmd0aCA+PSA1ICYmIGlucHV0c1s0XS5pbnRlZ2VyRGF0YS5zb21lKChpOiBudW1iZXIpID0+IGkgIT09IDEpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY3VycmVudGx5IG5vbi0xIHN0ZXBzIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIFNsaWNlJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHN0YXJ0cyA9IEFycmF5LmZyb20oaW5wdXRzWzFdLmludGVnZXJEYXRhKTtcbiAgICAgIGNvbnN0IGVuZHMgPSBBcnJheS5mcm9tKGlucHV0c1syXS5pbnRlZ2VyRGF0YSk7XG4gICAgICBjb25zdCBheGVzID0gaW5wdXRzLmxlbmd0aCA+PSA0ID8gQXJyYXkuZnJvbShpbnB1dHNbM10uaW50ZWdlckRhdGEpIDogW107XG4gICAgICBjb25zdCBjYWNoZUtleSA9IGAke2F4ZXN9OyR7c3RhcnRzfTske2VuZHN9YDtcbiAgICAgIHJldHVybiB7c3RhcnRzLCBlbmRzLCBheGVzLCBjYWNoZUtleX07XG4gICAgfTtcblxuY29uc3QgdmFsaWRhdGVJbnB1dHNWMTAgPSAoaW5wdXRzOiBUZW5zb3JbXSk6IHZvaWQgPT4ge1xuICBpZiAoIWlucHV0cyB8fCBpbnB1dHMubGVuZ3RoIDwgMyB8fCBpbnB1dHMubGVuZ3RoID4gNSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpbnB1dCBudW1iZXIuJyk7XG4gIH1cbiAgaWYgKGlucHV0c1sxXS50eXBlICE9PSAnaW50MzInIHx8IGlucHV0c1sxXS5kaW1zLmxlbmd0aCAhPT0gMSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpbnB1dCB0eXBlLicpO1xuICB9XG4gIGlmIChpbnB1dHNbMl0udHlwZSAhPT0gJ2ludDMyJyB8fCBpbnB1dHNbMl0uZGltcy5sZW5ndGggIT09IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW5wdXQgdHlwZS4nKTtcbiAgfVxuICBpZiAoaW5wdXRzLmxlbmd0aCA+PSA0ICYmIChpbnB1dHNbM10udHlwZSAhPT0gJ2ludDMyJyB8fCBpbnB1dHNbM10uZGltcy5sZW5ndGggIT09IDEpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGlucHV0IHR5cGUuJyk7XG4gIH1cbiAgaWYgKGlucHV0cy5sZW5ndGggPj0gNSAmJiAoaW5wdXRzWzRdLnR5cGUgIT09ICdpbnQzMicgfHwgaW5wdXRzWzRdLmRpbXMubGVuZ3RoICE9PSAxKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpbnB1dCB0eXBlLicpO1xuICB9XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0F0dHJpYnV0ZVdpdGhDYWNoZUtleSwgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5fSBmcm9tICcuLi8uLi8uLi9hdHRyaWJ1dGUtd2l0aC1jYWNoZS1rZXknO1xuaW1wb3J0IHtHcmFwaH0gZnJvbSAnLi4vLi4vLi4vZ3JhcGgnO1xuaW1wb3J0IHtPcGVyYXRvckltcGxlbWVudGF0aW9uLCBPcGVyYXRvckluaXRpYWxpemF0aW9ufSBmcm9tICcuLi8uLi8uLi9vcGVyYXRvcnMnO1xuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4uLy4uLy4uL3RlbnNvcic7XG5pbXBvcnQge1NoYXBlVXRpbH0gZnJvbSAnLi4vLi4vLi4vdXRpbCc7XG5pbXBvcnQge2dldEdsc2x9IGZyb20gJy4uL2dsc2wtc291cmNlJztcbmltcG9ydCB7V2ViR0xJbmZlcmVuY2VIYW5kbGVyfSBmcm9tICcuLi9pbmZlcmVuY2UtaGFuZGxlcic7XG5pbXBvcnQge1Byb2dyYW1JbmZvLCBUZXh0dXJlVHlwZX0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQge3RyYW5zcG9zZSwgVHJhbnNwb3NlQXR0cmlidXRlc30gZnJvbSAnLi90cmFuc3Bvc2UnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFNvZnRtYXhBdHRyaWJ1dGVzIGV4dGVuZHMgQXR0cmlidXRlV2l0aENhY2hlS2V5IHtcbiAgcmVhZG9ubHkgYXhpczogbnVtYmVyO1xufVxuXG5jb25zdCBzb2Z0bWF4Q29tcHV0ZU1heFByb2dyYW1NZXRhZGF0YSA9IHtcbiAgbmFtZTogJ1NvZnRtYXhDb21wdXRlTWF4JyxcbiAgaW5wdXROYW1lczogWydBJ10sXG4gIGlucHV0VHlwZXM6IFtUZXh0dXJlVHlwZS51bnBhY2tlZF0sXG59O1xuXG5jb25zdCBzb2Z0bWF4Q29tcHV0ZVNjYWxlUHJvZ3JhbU1ldGFkYXRhID0ge1xuICBuYW1lOiAnU29mdG1heENvbXB1dGVTY2FsZScsXG4gIGlucHV0TmFtZXM6IFsnQScsICdNYXgnXSxcbiAgaW5wdXRUeXBlczogW1RleHR1cmVUeXBlLnVucGFja2VkLCBUZXh0dXJlVHlwZS51bnBhY2tlZF0sXG59O1xuXG5jb25zdCBzb2Z0bWF4UHJvZ3JhbU1ldGFkYXRhID0ge1xuICBuYW1lOiAnU29mdE1heCcsXG4gIGlucHV0TmFtZXM6IFsnQScsICdNYXgnLCAnTm9ybSddLFxuICBpbnB1dFR5cGVzOiBbVGV4dHVyZVR5cGUudW5wYWNrZWQsIFRleHR1cmVUeXBlLnVucGFja2VkLCBUZXh0dXJlVHlwZS51bnBhY2tlZF0sXG59O1xuXG5leHBvcnQgY29uc3Qgc29mdG1heDogT3BlcmF0b3JJbXBsZW1lbnRhdGlvbjxTb2Z0bWF4QXR0cmlidXRlcz4gPVxuICAgIChpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10sIGF0dHJpYnV0ZXM6IFNvZnRtYXhBdHRyaWJ1dGVzKTogVGVuc29yW10gPT4ge1xuICAgICAgdmFsaWRhdGVJbnB1dHMoaW5wdXRzKTtcblxuICAgICAgY29uc3QgaW5wdXRTaGFwZSA9IGlucHV0c1swXS5kaW1zLnNsaWNlKCk7XG4gICAgICBjb25zdCBheGlzID0gU2hhcGVVdGlsLm5vcm1hbGl6ZUF4aXMoYXR0cmlidXRlcy5heGlzLCBpbnB1dFNoYXBlLmxlbmd0aCk7XG4gICAgICBjb25zdCBsb2dpY2FsUm93Q291bnQgPSBTaGFwZVV0aWwuc2l6ZVRvRGltZW5zaW9uKGlucHV0U2hhcGUsIGF4aXMpO1xuICAgICAgY29uc3QgZmVhdHVyZUNvdW50ID0gU2hhcGVVdGlsLnNpemVGcm9tRGltZW5zaW9uKGlucHV0U2hhcGUsIGF4aXMpO1xuXG4gICAgICBjb25zdCBvdXRwdXQgPSBjb21wdXRlU29mdG1heChpbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHMsIGF0dHJpYnV0ZXMsIGxvZ2ljYWxSb3dDb3VudCwgZmVhdHVyZUNvdW50KTtcbiAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlU29mdG1heEF0dHJpYnV0ZXM6IE9wZXJhdG9ySW5pdGlhbGl6YXRpb248U29mdG1heEF0dHJpYnV0ZXM+ID1cbiAgICAobm9kZTogR3JhcGguTm9kZSk6IFNvZnRtYXhBdHRyaWJ1dGVzID0+IGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSh7YXhpczogbm9kZS5hdHRyaWJ1dGVzLmdldEludCgnYXhpcycsIDEpfSk7XG5cbmV4cG9ydCBjb25zdCBwYXJzZVNvZnRtYXhBdHRyaWJ1dGVzVjEzOiBPcGVyYXRvckluaXRpYWxpemF0aW9uPFNvZnRtYXhBdHRyaWJ1dGVzPiA9XG4gICAgKG5vZGU6IEdyYXBoLk5vZGUpOiBTb2Z0bWF4QXR0cmlidXRlcyA9PiBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkoe2F4aXM6IG5vZGUuYXR0cmlidXRlcy5nZXRJbnQoJ2F4aXMnLCAtMSl9KTtcblxuLy8gVGhlIFwic2VtYW50aWNcIiBtZWFuaW5nIG9mIGF4aXMgaGFzIGNoYW5nZWQgaW4gb3BzZXQtMTMuXG4vLyBQbGVhc2UgY29tcGFyZTogaHR0cHM6Ly9naXRodWIuY29tL29ubngvb25ueC9ibG9iL21haW4vZG9jcy9PcGVyYXRvcnMubWQjU29mdG1heFxuLy8gd2l0aCBodHRwczovL2dpdGh1Yi5jb20vb25ueC9vbm54L2Jsb2IvbWFpbi9kb2NzL0NoYW5nZWxvZy5tZCNTb2Z0bWF4LTExIGZvciBkZXRhaWxlZCBleHBsYW5hdGlvbnNcbi8vIFRvIGFjY291bnQgZm9yIHRoZSBvcHNldC0xMyBiZWhhdmlvciwgb3VyIHBsYW4gd2lsbCBiZSB0byB0cmFuc3Bvc2UgdGhlIFwiYXhpc1wiIGRpbSB0byB0aGUgaW5uZXJtb3N0IGRpbVxuLy8gYW5kIHBlcmZvcm0gc29mdG1heCBhbmQgdGhlbiByZXZlcnNlIHRoZSB0cmFuc3Bvc2UuIFdlIGNhbiBza2lwIHRoZSB0cmFuc3Bvc2luZyBhc3BlY3QgaWYgdGhlIGF4aXMgaXMgYWxyZWFkeVxuLy8gdGhlIGlubmVybW9zdCBkaW1cbmV4cG9ydCBjb25zdCBzb2Z0bWF4VjEzOiBPcGVyYXRvckltcGxlbWVudGF0aW9uPFNvZnRtYXhBdHRyaWJ1dGVzPiA9XG4gICAgKGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSwgYXR0cmlidXRlczogU29mdG1heEF0dHJpYnV0ZXMpOiBUZW5zb3JbXSA9PiB7XG4gICAgICB2YWxpZGF0ZUlucHV0cyhpbnB1dHMpO1xuXG4gICAgICBjb25zdCBpbnB1dFNoYXBlID0gaW5wdXRzWzBdLmRpbXMuc2xpY2UoKTtcbiAgICAgIGNvbnN0IGF4aXMgPSBTaGFwZVV0aWwubm9ybWFsaXplQXhpcyhhdHRyaWJ1dGVzLmF4aXMsIGlucHV0U2hhcGUubGVuZ3RoKTtcbiAgICAgIGNvbnN0IHJhbmsgPSBpbnB1dFNoYXBlLmxlbmd0aDtcblxuICAgICAgY29uc3QgaXNUcmFuc3Bvc2VSZXF1aXJlZCA9IChheGlzICE9PSByYW5rIC0gMSkgPyB0cnVlIDogZmFsc2U7XG4gICAgICBjb25zdCB0cmFuc3Bvc2VkSW5wdXRTaGFwZTogbnVtYmVyW10gPSBbXTtcbiAgICAgIGxldCBwZXJtOiBudW1iZXJbXSA9IFtdO1xuICAgICAgbGV0IHRyYW5zcG9zZWRJbnB1dHM6IFRlbnNvcltdID0gW107XG4gICAgICBsZXQgdHJhbnNwb3NlQXR0cmlidXRlOiBUcmFuc3Bvc2VBdHRyaWJ1dGVzO1xuXG4gICAgICBpZiAoaXNUcmFuc3Bvc2VSZXF1aXJlZCkge1xuICAgICAgICBwZXJtID0gQXJyYXkuZnJvbSh7bGVuZ3RoOiByYW5rfSkubWFwKChfLCBpKSA9PiBpKTtcblxuICAgICAgICAvLyBzd2FwIHRoZSBpbm5lcm1vc3QgZGltIHdpdGggdGhlIGRpbSBjb3JyZXNwb25kaW5nIHRvIGF4aXNcbiAgICAgICAgcGVybVtheGlzXSA9IHJhbmsgLSAxO1xuICAgICAgICBwZXJtW3JhbmsgLSAxXSA9IGF4aXM7XG5cbiAgICAgICAgcGVybS5tYXAocCA9PiB0cmFuc3Bvc2VkSW5wdXRTaGFwZS5wdXNoKGlucHV0U2hhcGVbcF0pKTtcblxuICAgICAgICB0cmFuc3Bvc2VBdHRyaWJ1dGUgPSBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkoe3Blcm19KTtcbiAgICAgICAgdHJhbnNwb3NlZElucHV0cyA9IHRyYW5zcG9zZShpbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHMsIHRyYW5zcG9zZUF0dHJpYnV0ZSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGxvZ2ljYWxSb3dDb3VudCA9IGlzVHJhbnNwb3NlUmVxdWlyZWQgPyBTaGFwZVV0aWwuc2l6ZVRvRGltZW5zaW9uKHRyYW5zcG9zZWRJbnB1dFNoYXBlLCByYW5rIC0gMSkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNoYXBlVXRpbC5zaXplVG9EaW1lbnNpb24oaW5wdXRTaGFwZSwgcmFuayAtIDEpO1xuICAgICAgY29uc3QgZmVhdHVyZUNvdW50ID0gaXNUcmFuc3Bvc2VSZXF1aXJlZCA/IFNoYXBlVXRpbC5zaXplRnJvbURpbWVuc2lvbih0cmFuc3Bvc2VkSW5wdXRTaGFwZSwgcmFuayAtIDEpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTaGFwZVV0aWwuc2l6ZUZyb21EaW1lbnNpb24oaW5wdXRTaGFwZSwgcmFuayAtIDEpO1xuXG4gICAgICBjb25zdCBvdXRwdXQgPSBjb21wdXRlU29mdG1heChcbiAgICAgICAgICBpbmZlcmVuY2VIYW5kbGVyLCBpc1RyYW5zcG9zZVJlcXVpcmVkID8gdHJhbnNwb3NlZElucHV0cyA6IGlucHV0cywgYXR0cmlidXRlcywgbG9naWNhbFJvd0NvdW50LCBmZWF0dXJlQ291bnQpO1xuXG4gICAgICBpZiAoaXNUcmFuc3Bvc2VSZXF1aXJlZCkge1xuICAgICAgICBjb25zdCByZXZlcnNlZE91dHB1dCA9IHRyYW5zcG9zZShpbmZlcmVuY2VIYW5kbGVyLCBvdXRwdXQsIHRyYW5zcG9zZUF0dHJpYnV0ZSEpO1xuICAgICAgICByZXR1cm4gcmV2ZXJzZWRPdXRwdXQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgfVxuICAgIH07XG5cbmNvbnN0IGNvbXB1dGVTb2Z0bWF4ID1cbiAgICAoaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdLCBhdHRyaWJ1dGVzOiBTb2Z0bWF4QXR0cmlidXRlcywgbG9naWNhbFJvd0NvdW50OiBudW1iZXIsXG4gICAgIGZlYXR1cmVDb3VudDogbnVtYmVyKTogVGVuc29yW10gPT4ge1xuICAgICAgY29uc3QgY29tcHV0ZU1heFByb2dyYW1JbmZvID1cbiAgICAgICAgICBjcmVhdGVDb21wdXRlTWF4UHJvZ3JhbUluZm8oaW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzWzBdLCBsb2dpY2FsUm93Q291bnQsIGZlYXR1cmVDb3VudCwgW2xvZ2ljYWxSb3dDb3VudF0pO1xuICAgICAgY29uc3QgbWF4ID0gaW5mZXJlbmNlSGFuZGxlci5ydW4oXG4gICAgICAgICAgey4uLnNvZnRtYXhDb21wdXRlTWF4UHJvZ3JhbU1ldGFkYXRhLCBjYWNoZUhpbnQ6IGF0dHJpYnV0ZXMuY2FjaGVLZXksIGdldDogKCkgPT4gY29tcHV0ZU1heFByb2dyYW1JbmZvfSxcbiAgICAgICAgICBpbnB1dHMpO1xuXG4gICAgICBjb25zdCBjb21wdXRlU2NhbGVQcm9ncmFtSW5mbyA9IGNyZWF0ZUNvbXB1dFNjYWxlUHJvZ3JhbUluZm8oXG4gICAgICAgICAgaW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzWzBdLCBsb2dpY2FsUm93Q291bnQsIGZlYXR1cmVDb3VudCwgY29tcHV0ZU1heFByb2dyYW1JbmZvLm91dHB1dC5kaW1zLFxuICAgICAgICAgIFtsb2dpY2FsUm93Q291bnRdKTtcbiAgICAgIGNvbnN0IHNjYWxlID0gaW5mZXJlbmNlSGFuZGxlci5ydW4oXG4gICAgICAgICAgey4uLnNvZnRtYXhDb21wdXRlU2NhbGVQcm9ncmFtTWV0YWRhdGEsIGNhY2hlSGludDogYXR0cmlidXRlcy5jYWNoZUtleSwgZ2V0OiAoKSA9PiBjb21wdXRlU2NhbGVQcm9ncmFtSW5mb30sXG4gICAgICAgICAgW2lucHV0c1swXSwgbWF4XSk7XG5cbiAgICAgIGNvbnN0IHNvZnRNYXhQcm9ncmFtSW5mbyA9IGNyZWF0ZVNvZnRNYXhQcm9ncmFtSW5mbyhcbiAgICAgICAgICBpbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHNbMF0sIGxvZ2ljYWxSb3dDb3VudCwgZmVhdHVyZUNvdW50LCBjb21wdXRlTWF4UHJvZ3JhbUluZm8ub3V0cHV0LmRpbXMsXG4gICAgICAgICAgY29tcHV0ZVNjYWxlUHJvZ3JhbUluZm8ub3V0cHV0LmRpbXMpO1xuICAgICAgY29uc3Qgb3V0cHV0ID0gaW5mZXJlbmNlSGFuZGxlci5ydW4oXG4gICAgICAgICAgey4uLnNvZnRtYXhQcm9ncmFtTWV0YWRhdGEsIGNhY2hlSGludDogYXR0cmlidXRlcy5jYWNoZUtleSwgZ2V0OiAoKSA9PiBzb2Z0TWF4UHJvZ3JhbUluZm99LFxuICAgICAgICAgIFtpbnB1dHNbMF0sIG1heCwgc2NhbGVdKTtcbiAgICAgIHJldHVybiBbb3V0cHV0XTtcbiAgICB9O1xuXG4vKipcbiAqIENyZWF0ZSBhIHRleHR1cmUgdGhhdCBjb250YWlucyB0aGUgbWF4aW11bSB2YWx1ZSBvZiBlYWNoIG9mIHRoZSAnTicgcm93c1xuICovXG5jb25zdCBjcmVhdGVDb21wdXRlTWF4UHJvZ3JhbUluZm8gPVxuICAgIChpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0OiBUZW5zb3IsIGxvZ2ljYWxSb3dDb3VudDogbnVtYmVyLCBmZWF0dXJlQ291bnQ6IG51bWJlcixcbiAgICAgb3V0cHV0U2hhcGU6IG51bWJlcltdKTogUHJvZ3JhbUluZm8gPT4ge1xuICAgICAgY29uc3QgW3RleHR1cmVXaWR0aCwgdGV4dHVyZUhlaWdodF0gPVxuICAgICAgICAgIGluZmVyZW5jZUhhbmRsZXIuY2FsY3VsYXRlVGV4dHVyZVdpZHRoQW5kSGVpZ2h0KGlucHV0LmRpbXMsIFRleHR1cmVUeXBlLnVucGFja2VkKTtcbiAgICAgIGNvbnN0IHJhbmsgPSBvdXRwdXRTaGFwZS5sZW5ndGg7XG5cbiAgICAgIGlmIChsb2dpY2FsUm93Q291bnQgPCAxIHx8IGZlYXR1cmVDb3VudCA8IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdMb2dpY2FsIHJvdyBjb3VudCBOIGFuZCBmZWF0dXJlIGNvdW50IEQgbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMScpO1xuICAgICAgfVxuXG4gICAgICBpZiAob3V0cHV0U2hhcGUubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRGltZW5zaW9uYWxpdHkgb2YgdGhlIG91dHB1dCBzaG91bGQgYmUgMScpO1xuICAgICAgfVxuXG4gICAgICBpZiAob3V0cHV0U2hhcGVbMF0gIT09IGxvZ2ljYWxSb3dDb3VudCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NoYXBlIG9mIHRoZSBvdXRwdXQgc2hvdWxkIGJlIGVxdWFsIHRvIGxvZ2ljYWwgcm93IGNvdW50Jyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGdsc2wgPSBnZXRHbHNsKGluZmVyZW5jZUhhbmRsZXIuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC52ZXJzaW9uKTtcbiAgICAgIGNvbnN0IHNoYWRlclNvdXJjZSA9IGBcbiAgICAgIGZsb2F0IHByb2Nlc3MoaW50WyR7cmFua31dIGluZGljZXMpIHtcbiAgICAgICAgaW50IGxvZ2ljYWxfcm93X3N0YXJ0X29mZnNldCA9IGluZGljZXNbMF0gKiAke2ZlYXR1cmVDb3VudH07XG5cbiAgICAgICAgZmxvYXQgbWF4ID0gZ2V0Q29sb3JBc0Zsb2F0KCR7Z2xzbC50ZXh0dXJlMkR9KEEsIG9mZnNldFRvQ29vcmRzKGxvZ2ljYWxfcm93X3N0YXJ0X29mZnNldCwgJHt0ZXh0dXJlV2lkdGh9LFxuICAgICAgICAke3RleHR1cmVIZWlnaHR9ICkpKTtcbiAgICAgICAgZm9yKGludCBpPTE7IGk8JHtmZWF0dXJlQ291bnR9OyArK2kpXG4gICAgICAgIHtcbiAgICAgICAgICBmbG9hdCBjdXJyZW50ID0gZ2V0Q29sb3JBc0Zsb2F0KCR7Z2xzbC50ZXh0dXJlMkR9KEEsIG9mZnNldFRvQ29vcmRzKGxvZ2ljYWxfcm93X3N0YXJ0X29mZnNldCArIGksXG4gICAgICAgICAgICAke3RleHR1cmVXaWR0aH0sICR7dGV4dHVyZUhlaWdodH0pKSk7XG4gICAgICAgICAgaWYoY3VycmVudCA+IG1heClcbiAgICAgICAgICBtYXggPSBjdXJyZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1heDtcbiAgICAgIH1gO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uc29mdG1heENvbXB1dGVNYXhQcm9ncmFtTWV0YWRhdGEsXG4gICAgICAgIG91dHB1dDoge2RpbXM6IG91dHB1dFNoYXBlLCB0eXBlOiBpbnB1dC50eXBlLCB0ZXh0dXJlVHlwZTogVGV4dHVyZVR5cGUudW5wYWNrZWR9LFxuICAgICAgICBzaGFkZXJTb3VyY2VcbiAgICAgIH07XG4gICAgfTtcblxuLyoqXG4gKiBDcmVhdGUgYSB0ZXh0dXJlIHRoYXQgY29udGFpbnMgdGhlIG5vcm1hbGl6YXRpb24gZmFjdG9yIGZvciBlYWNoIG9mIHRoZSAnTicgcm93c1xuICovXG5jb25zdCBjcmVhdGVDb21wdXRTY2FsZVByb2dyYW1JbmZvID1cbiAgICAoaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dDogVGVuc29yLCBsb2dpY2FsUm93Q291bnQ6IG51bWJlciwgZmVhdHVyZUNvdW50OiBudW1iZXIsXG4gICAgIG1heEVsZW1lbnRQZXJMb2dpY2FsUm93OiByZWFkb25seSBudW1iZXJbXSwgb3V0cHV0U2hhcGU6IG51bWJlcltdKTogUHJvZ3JhbUluZm8gPT4ge1xuICAgICAgY29uc3QgW3RleHR1cmVXaWR0aCwgdGV4dHVyZUhlaWdodF0gPVxuICAgICAgICAgIGluZmVyZW5jZUhhbmRsZXIuY2FsY3VsYXRlVGV4dHVyZVdpZHRoQW5kSGVpZ2h0KGlucHV0LmRpbXMsIFRleHR1cmVUeXBlLnVucGFja2VkKTtcbiAgICAgIGNvbnN0IHJhbmsgPSBvdXRwdXRTaGFwZS5sZW5ndGg7XG5cbiAgICAgIGlmIChsb2dpY2FsUm93Q291bnQgPCAxIHx8IGZlYXR1cmVDb3VudCA8IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdMb2dpY2FsIHJvdyBjb3VudCBOIGFuZCBmZWF0dXJlIGNvdW50IEQgbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMScpO1xuICAgICAgfVxuXG4gICAgICBpZiAob3V0cHV0U2hhcGUubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRGltZW5zaW9uYWxpdHkgb2YgdGhlIG91dHB1dCBzaG91bGQgYmUgMScpO1xuICAgICAgfVxuXG4gICAgICBpZiAob3V0cHV0U2hhcGVbMF0gIT09IGxvZ2ljYWxSb3dDb3VudCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NoYXBlIG9mIHRoZSBvdXRwdXQgc2hvdWxkIGJlIGVxdWFsIHRvIGxvZ2ljYWwgcm93IGNvdW50Jyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChtYXhFbGVtZW50UGVyTG9naWNhbFJvdy5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEaW1lbnNpb25hbGl0eSBvZiB0aGUgaW50ZXJtZWRpYXRlIHJlc3VsdHMgc2hvdWxkIGJlIDEnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1heEVsZW1lbnRQZXJMb2dpY2FsUm93WzBdICE9PSBsb2dpY2FsUm93Q291bnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTaGFwZSBvZiB0aGUgaW50ZXJtZWRpYXRlIHJlc3VsdHMgc2hvdWxkIGJlIGVxdWFsIHRvIGxvZ2ljYWwgcm93IGNvdW50Jyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGdsc2wgPSBnZXRHbHNsKGluZmVyZW5jZUhhbmRsZXIuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC52ZXJzaW9uKTtcbiAgICAgIGNvbnN0IHNoYWRlclNvdXJjZSA9IGBcbiAgICAgIGZsb2F0IHByb2Nlc3MoaW50WyR7cmFua31dIGluZGljZXMpIHtcbiAgICAgICAgaW50IGxvZ2ljYWxfcm93X3N0YXJ0X29mZnNldCA9IGluZGljZXNbMF0gKiAke2ZlYXR1cmVDb3VudH07XG5cbiAgICAgICAgZmxvYXQgbm9ybV9mYWN0b3IgPSAwLjA7XG4gICAgICAgIGZsb2F0IG1heCA9IF9NYXgoaW5kaWNlcyk7XG4gICAgICAgIGZvcihpbnQgaT0wOyBpPCR7ZmVhdHVyZUNvdW50fTsgKytpKVxuICAgICAgICB7XG4gICAgICAgICAgbm9ybV9mYWN0b3IgKz0gZXhwKGdldENvbG9yQXNGbG9hdCgke2dsc2wudGV4dHVyZTJEfShBLCBvZmZzZXRUb0Nvb3Jkcyhsb2dpY2FsX3Jvd19zdGFydF9vZmZzZXQgKyBpLFxuICAgICAgICAgICAgJHt0ZXh0dXJlV2lkdGh9LCAke3RleHR1cmVIZWlnaHR9KSkpIC0gbWF4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub3JtX2ZhY3RvcjtcbiAgICAgIH1gO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uc29mdG1heENvbXB1dGVTY2FsZVByb2dyYW1NZXRhZGF0YSxcbiAgICAgICAgb3V0cHV0OiB7ZGltczogb3V0cHV0U2hhcGUsIHR5cGU6IGlucHV0LnR5cGUsIHRleHR1cmVUeXBlOiBUZXh0dXJlVHlwZS51bnBhY2tlZH0sXG4gICAgICAgIHNoYWRlclNvdXJjZVxuICAgICAgfTtcbiAgICB9O1xuXG5jb25zdCBjcmVhdGVTb2Z0TWF4UHJvZ3JhbUluZm8gPVxuICAgIChpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0OiBUZW5zb3IsIGxvZ2ljYWxSb3dDb3VudDogbnVtYmVyLCBmZWF0dXJlQ291bnQ6IG51bWJlcixcbiAgICAgbWF4RWxlbWVudFBlckxvZ2ljYWxSb3c6IHJlYWRvbmx5IG51bWJlcltdLCBub3JtYWxpemF0aW9uUGVyTG9naWNhbFJvdzogcmVhZG9ubHkgbnVtYmVyW10pOiBQcm9ncmFtSW5mbyA9PiB7XG4gICAgICBjb25zdCBbdGV4dHVyZVdpZHRoLCB0ZXh0dXJlSGVpZ2h0XSA9XG4gICAgICAgICAgaW5mZXJlbmNlSGFuZGxlci5jYWxjdWxhdGVUZXh0dXJlV2lkdGhBbmRIZWlnaHQoaW5wdXQuZGltcywgVGV4dHVyZVR5cGUudW5wYWNrZWQpO1xuICAgICAgY29uc3QgcmFuayA9IGlucHV0LmRpbXMubGVuZ3RoO1xuXG4gICAgICBpZiAobG9naWNhbFJvd0NvdW50IDwgMSB8fCBmZWF0dXJlQ291bnQgPCAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTG9naWNhbCByb3cgY291bnQgTiBhbmQgZmVhdHVyZSBjb3VudCBEIG11c3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDEnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1heEVsZW1lbnRQZXJMb2dpY2FsUm93Lmxlbmd0aCAhPT0gMSB8fCBub3JtYWxpemF0aW9uUGVyTG9naWNhbFJvdy5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEaW1lbnNpb25hbGl0eSBvZiB0aGUgaW50ZXJtZWRpYXRlIHJlc3VsdHMgc2hvdWxkIGJlIDEnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1heEVsZW1lbnRQZXJMb2dpY2FsUm93WzBdICE9PSBsb2dpY2FsUm93Q291bnQgfHwgbm9ybWFsaXphdGlvblBlckxvZ2ljYWxSb3dbMF0gIT09IGxvZ2ljYWxSb3dDb3VudCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NoYXBlIG9mIHRoZSBpbnRlcm1lZGlhdGUgcmVzdWx0cyBzaG91bGQgYmUgZXF1YWwgdG8gbG9naWNhbCByb3cgY291bnQnKTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgc2hhZGVyU291cmNlID0gYFxuICAgICAgZmxvYXQgcHJvY2VzcyhpbnRbJHtyYW5rfV0gaW5kaWNlcykge1xuXG4gICAgICAvLyBnZXQgb2Zmc2V0IG9mIGN1cnJlbnQgbG9naWNhbCB0ZW5zb3IgaW5kZXggZnJvbSB0aGUgMi1EIHRleHR1cmUgY29vcmRpbmF0ZXMgKFRleENvb3JkcylcbiAgICAgIGludCBvZmZzZXQgPSBjb29yZHNUb09mZnNldChUZXhDb29yZHMsICR7dGV4dHVyZVdpZHRofSwgJHt0ZXh0dXJlSGVpZ2h0fSk7XG5cbiAgICAgIC8vZGV0ZXJtaW5lIHRoZSBsb2dpY2FsIHJvdyBmb3IgdGhpcyBpbmRleFxuICAgICAgaW50IGxvZ2ljYWxfcm93X2luZGV4WzFdO1xuICAgICAgbG9naWNhbF9yb3dfaW5kZXhbMF0gPSBvZmZzZXQgLyAke2ZlYXR1cmVDb3VudH07XG5cbiAgICAgIGZsb2F0IG5vcm1fZmFjdG9yID0gX05vcm0obG9naWNhbF9yb3dfaW5kZXgpO1xuXG4gICAgICAvLyBhdm9pZCBwb3NzaWJsZSBkaXZpc2lvbiBieSAwXG4gICAgICAvLyBpZiBub3JtX2ZhY29yIGlzIDAsIGFsbCBlbGVtZW50cyBhcmUgemVyb1xuICAgICAgLy8gaWYgc28sIHJldHVybiAwXG4gICAgICBpZihub3JtX2ZhY3RvciA9PSAwLjApXG4gICAgICAgIHJldHVybiAwLjA7XG5cbiAgICAgIHJldHVybiBleHAoX0EoaW5kaWNlcykgLSBfTWF4KGxvZ2ljYWxfcm93X2luZGV4KSkgLyBub3JtX2ZhY3RvcjtcbiAgICB9YDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLnNvZnRtYXhQcm9ncmFtTWV0YWRhdGEsXG4gICAgICAgIG91dHB1dDoge2RpbXM6IGlucHV0LmRpbXMsIHR5cGU6IGlucHV0LnR5cGUsIHRleHR1cmVUeXBlOiBUZXh0dXJlVHlwZS51bnBhY2tlZH0sXG4gICAgICAgIHNoYWRlclNvdXJjZVxuICAgICAgfTtcbiAgICB9O1xuXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IFRlbnNvcltdKTogdm9pZCA9PiB7XG4gIGlmICghaW5wdXRzIHx8IGlucHV0cy5sZW5ndGggIT09IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1NvZnRtYXggcmVxdWlyZXMgMSBpbnB1dC4nKTtcbiAgfVxuXG4gIGlmIChpbnB1dHNbMF0udHlwZSAhPT0gJ2Zsb2F0MzInICYmIGlucHV0c1swXS50eXBlICE9PSAnZmxvYXQ2NCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW5wdXQgdHlwZScpO1xuICB9XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0F0dHJpYnV0ZVdpdGhDYWNoZUtleSwgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5fSBmcm9tICcuLi8uLi8uLi9hdHRyaWJ1dGUtd2l0aC1jYWNoZS1rZXknO1xuaW1wb3J0IHtHcmFwaH0gZnJvbSAnLi4vLi4vLi4vZ3JhcGgnO1xuaW1wb3J0IHtPcGVyYXRvckltcGxlbWVudGF0aW9uLCBPcGVyYXRvckluaXRpYWxpemF0aW9ufSBmcm9tICcuLi8uLi8uLi9vcGVyYXRvcnMnO1xuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4uLy4uLy4uL3RlbnNvcic7XG5pbXBvcnQge1NoYXBlVXRpbCwgU3BsaXRVdGlsfSBmcm9tICcuLi8uLi8uLi91dGlsJztcbmltcG9ydCB7V2ViR0xJbmZlcmVuY2VIYW5kbGVyfSBmcm9tICcuLi9pbmZlcmVuY2UtaGFuZGxlcic7XG5pbXBvcnQge1Byb2dyYW1JbmZvLCBUZXh0dXJlVHlwZX0gZnJvbSAnLi4vdHlwZXMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFNwbGl0QXR0cmlidXRlcyBleHRlbmRzIEF0dHJpYnV0ZVdpdGhDYWNoZUtleSB7XG4gIHJlYWRvbmx5IGF4aXM6IG51bWJlcjtcbiAgcmVhZG9ubHkgc3BsaXQ6IG51bWJlcltdO1xuICByZWFkb25seSBudW1PdXRwdXRzOiBudW1iZXI7XG59XG5cbmNvbnN0IHNwbGl0UHJvZ3JhbU1ldGFkYXRhID0ge1xuICBuYW1lOiAnU3BsaXQnLFxuICBpbnB1dE5hbWVzOiBbJ0EnXSxcbiAgaW5wdXRUeXBlczogW1RleHR1cmVUeXBlLnVucGFja2VkXSxcbn07XG5cbmV4cG9ydCBjb25zdCBzcGxpdDogT3BlcmF0b3JJbXBsZW1lbnRhdGlvbjxTcGxpdEF0dHJpYnV0ZXM+ID1cbiAgICAoaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdLCBhdHRyaWJ1dGVzOiBTcGxpdEF0dHJpYnV0ZXMpOiBUZW5zb3JbXSA9PiB7XG4gICAgICB2YWxpZGF0ZUlucHV0cyhpbnB1dHMpO1xuXG4gICAgICBjb25zdCBheGlzID0gU2hhcGVVdGlsLm5vcm1hbGl6ZUF4aXMoYXR0cmlidXRlcy5heGlzLCBpbnB1dHNbMF0uZGltcy5sZW5ndGgpO1xuICAgICAgY29uc3QgY291bnQgPSBnZXRQcm9ncmFtQ291bnQoaW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzLCBheGlzLCBhdHRyaWJ1dGVzKTtcbiAgICAgIGNvbnN0IG91dHB1dDogVGVuc29yW10gPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7ICsraSkge1xuICAgICAgICBvdXRwdXQucHVzaChpbmZlcmVuY2VIYW5kbGVyLnJ1bihcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgLi4uc3BsaXRQcm9ncmFtTWV0YWRhdGEsXG4gICAgICAgICAgICAgIGNhY2hlSGludDogYCR7YXR0cmlidXRlcy5jYWNoZUtleX07JHtpfWAsXG4gICAgICAgICAgICAgIGdldDogKCkgPT4gY3JlYXRlU3BsaXRQcm9ncmFtSW5mbyhpbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHNbMF0sIGF0dHJpYnV0ZXMsIGF4aXMsIGkpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaW5wdXRzKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlU3BsaXRBdHRyaWJ1dGVzOiBPcGVyYXRvckluaXRpYWxpemF0aW9uPFNwbGl0QXR0cmlidXRlcz4gPSAobm9kZTogR3JhcGguTm9kZSk6IFNwbGl0QXR0cmlidXRlcyA9PiB7XG4gIGNvbnN0IGF4aXMgPSBub2RlLmF0dHJpYnV0ZXMuZ2V0SW50KCdheGlzJywgMCk7XG4gIGNvbnN0IHNwbGl0ID0gbm9kZS5hdHRyaWJ1dGVzLmdldEludHMoJ3NwbGl0JywgW10pO1xuICBjb25zdCBudW1PdXRwdXRzID0gbm9kZS5vdXRwdXRzLmxlbmd0aDtcbiAgcmV0dXJuIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSh7YXhpcywgc3BsaXQsIG51bU91dHB1dHN9KTtcbn07XG5cbmNvbnN0IGdldFByb2dyYW1Db3VudCA9XG4gICAgKF9pbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10sIGF4aXM6IG51bWJlciwgYXR0cmlidXRlczogU3BsaXRBdHRyaWJ1dGVzKTogbnVtYmVyID0+IHtcbiAgICAgIGNvbnN0IFssIG9mZnNldHNdID0gU3BsaXRVdGlsLnNwbGl0U2hhcGUoaW5wdXRzWzBdLmRpbXMsIGF4aXMsIGF0dHJpYnV0ZXMuc3BsaXQsIGF0dHJpYnV0ZXMubnVtT3V0cHV0cyk7XG4gICAgICByZXR1cm4gb2Zmc2V0cy5sZW5ndGg7XG4gICAgfTtcblxuY29uc3QgY3JlYXRlU3BsaXRQcm9ncmFtSW5mbyA9XG4gICAgKF9pbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0OiBUZW5zb3IsIGF0dHJpYnV0ZXM6IFNwbGl0QXR0cmlidXRlcywgYXhpczogbnVtYmVyLCBpbmRleDogbnVtYmVyKTpcbiAgICAgICAgUHJvZ3JhbUluZm8gPT4ge1xuICAgICAgICAgIGNvbnN0IFtzaGFwZXMsIG9mZnNldHNdID0gU3BsaXRVdGlsLnNwbGl0U2hhcGUoaW5wdXQuZGltcywgYXhpcywgYXR0cmlidXRlcy5zcGxpdCwgYXR0cmlidXRlcy5udW1PdXRwdXRzKTtcbiAgICAgICAgICBjb25zdCBvZmZzZXQgPSBvZmZzZXRzW2luZGV4XTtcbiAgICAgICAgICBjb25zdCBvdXRwdXRTaGFwZSA9IHNoYXBlc1tpbmRleF07XG4gICAgICAgICAgY29uc3QgcmFuayA9IG91dHB1dFNoYXBlLmxlbmd0aDtcbiAgICAgICAgICBjb25zdCBzaGFkZXJTb3VyY2UgPSBgXG4gICAgICBmbG9hdCBwcm9jZXNzKGludCBpbmRpY2VzWyR7cmFua31dKSB7XG4gICAgICAgIGluZGljZXNbJHtheGlzfV0gKz0gJHtvZmZzZXR9O1xuICAgICAgICByZXR1cm4gX0EoaW5kaWNlcyk7XG4gICAgICB9XG4gICAgYDtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uc3BsaXRQcm9ncmFtTWV0YWRhdGEsXG4gICAgICAgICAgICBjYWNoZUhpbnQ6IGAke2F0dHJpYnV0ZXMuY2FjaGVLZXl9OiR7aW5kZXh9YCxcbiAgICAgICAgICAgIG91dHB1dDoge2RpbXM6IG91dHB1dFNoYXBlLCB0eXBlOiBpbnB1dC50eXBlLCB0ZXh0dXJlVHlwZTogVGV4dHVyZVR5cGUudW5wYWNrZWR9LFxuICAgICAgICAgICAgc2hhZGVyU291cmNlXG4gICAgICAgICAgfTtcbiAgICAgICAgfTtcblxuY29uc3QgdmFsaWRhdGVJbnB1dHMgPSAoaW5wdXRzOiBUZW5zb3JbXSk6IHZvaWQgPT4ge1xuICBpZiAoIWlucHV0cyB8fCBpbnB1dHMubGVuZ3RoICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdTcGxpdCByZXF1aXJlcyBvbmUgaW5wdXQuJyk7XG4gIH1cblxuICBpZiAoaW5wdXRzWzBdLnR5cGUgIT09ICdpbnQ4JyAmJiBpbnB1dHNbMF0udHlwZSAhPT0gJ3VpbnQ4JyAmJiBpbnB1dHNbMF0udHlwZSAhPT0gJ2ludDE2JyAmJlxuICAgICAgaW5wdXRzWzBdLnR5cGUgIT09ICd1aW50MTYnICYmIGlucHV0c1swXS50eXBlICE9PSAnaW50MzInICYmIGlucHV0c1swXS50eXBlICE9PSAndWludDMyJyAmJlxuICAgICAgaW5wdXRzWzBdLnR5cGUgIT09ICdmbG9hdDMyJyAmJiBpbnB1dHNbMF0udHlwZSAhPT0gJ2Zsb2F0NjQnICYmIGlucHV0c1swXS50eXBlICE9PSAnYm9vbCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW5wdXQgdHlwZS4nKTtcbiAgfVxufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtHcmFwaH0gZnJvbSAnLi4vLi4vLi4vZ3JhcGgnO1xuaW1wb3J0IHtPcGVyYXRvckltcGxlbWVudGF0aW9uLCBPcGVyYXRvckluaXRpYWxpemF0aW9ufSBmcm9tICcuLi8uLi8uLi9vcGVyYXRvcnMnO1xuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4uLy4uLy4uL3RlbnNvcic7XG5pbXBvcnQge1NoYXBlVXRpbH0gZnJvbSAnLi4vLi4vLi4vdXRpbCc7XG5pbXBvcnQge1dlYkdMSW5mZXJlbmNlSGFuZGxlcn0gZnJvbSAnLi4vaW5mZXJlbmNlLWhhbmRsZXInO1xuXG5leHBvcnQgY29uc3Qgc3F1ZWV6ZTogT3BlcmF0b3JJbXBsZW1lbnRhdGlvbjxudW1iZXJbXT4gPVxuICAgIChpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10sIGF4ZXM6IG51bWJlcltdKTogVGVuc29yW10gPT4ge1xuICAgICAgdmFsaWRhdGVJbnB1dHMoaW5wdXRzKTtcbiAgICAgIGNvbnN0IG91dHB1dFNoYXBlID0gU2hhcGVVdGlsLnNxdWVlemVTaGFwZShpbnB1dHNbMF0uZGltcywgYXhlcyk7XG4gICAgICBjb25zdCBvdXRwdXQgPSBpbmZlcmVuY2VIYW5kbGVyLnJlc2hhcGVVbnBhY2tlZChpbnB1dHNbMF0sIG91dHB1dFNoYXBlKTtcbiAgICAgIHJldHVybiBbb3V0cHV0XTtcbiAgICB9O1xuXG5leHBvcnQgY29uc3Qgc3F1ZWV6ZVYxMyA9IChpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOiBUZW5zb3JbXSA9PiB7XG4gIHZhbGlkYXRlSW5wdXRzVjEzKGlucHV0cyk7XG4gIHJldHVybiBzcXVlZXplKGluZmVyZW5jZUhhbmRsZXIsIFtpbnB1dHNbMF1dLCBBcnJheS5mcm9tKGlucHV0c1sxXS5pbnRlZ2VyRGF0YSkpO1xufTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlU3F1ZWV6ZUF0dHJpYnV0ZXM6IE9wZXJhdG9ySW5pdGlhbGl6YXRpb248bnVtYmVyW10+ID0gKG5vZGU6IEdyYXBoLk5vZGUpOiBudW1iZXJbXSA9PlxuICAgIG5vZGUuYXR0cmlidXRlcy5nZXRJbnRzKCdheGVzJyk7XG5cbmNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogVGVuc29yW10pOiB2b2lkID0+IHtcbiAgaWYgKCFpbnB1dHMgfHwgaW5wdXRzLmxlbmd0aCAhPT0gMSkge1xuICAgIHRocm93IG5ldyBFcnJvcignU3F1ZWV6ZSByZXF1aXJlcyAxIGlucHV0LicpO1xuICB9XG5cbiAgaWYgKGlucHV0c1swXS50eXBlID09PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBpbnB1dCB0ZW5zb3IgdHlwZXMuJyk7XG4gIH1cbn07XG5cbmNvbnN0IHZhbGlkYXRlSW5wdXRzVjEzID0gKGlucHV0czogVGVuc29yW10pOiB2b2lkID0+IHtcbiAgaWYgKCFpbnB1dHMgfHwgaW5wdXRzLmxlbmd0aCAhPT0gMikge1xuICAgIHRocm93IG5ldyBFcnJvcignU3F1ZWV6ZSByZXF1aXJlcyAyIGlucHV0cy4nKTtcbiAgfVxuXG4gIGlmIChpbnB1dHNbMV0udHlwZSAhPT0gJ2ludDMyJykge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpbnB1dCB0eXBlLicpO1xuICB9XG59OyIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4uLy4uLy4uL3RlbnNvcic7XG5pbXBvcnQge2dldEdsc2x9IGZyb20gJy4uL2dsc2wtc291cmNlJztcbmltcG9ydCB7V2ViR0xJbmZlcmVuY2VIYW5kbGVyfSBmcm9tICcuLi9pbmZlcmVuY2UtaGFuZGxlcic7XG5pbXBvcnQge1Byb2dyYW1JbmZvLCBQcm9ncmFtTWV0YWRhdGEsIFRleHR1cmVUeXBlfSBmcm9tICcuLi90eXBlcyc7XG5cbmV4cG9ydCBjb25zdCBzdW0gPSAoaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTogVGVuc29yW10gPT4ge1xuICB2YWxpZGF0ZUlucHV0cyhpbnB1dHMpO1xuXG4gIGNvbnN0IHN1bVByb2dyYW1NZXRhZGF0YSA9IHtcbiAgICBuYW1lOiAnU3VtJyxcbiAgICBpbnB1dE5hbWVzOiBpbnB1dHMubWFwKChfdiwgaSkgPT4gYFgke2l9YCksXG4gICAgaW5wdXRUeXBlczogbmV3IEFycmF5KGlucHV0cy5sZW5ndGgpLmZpbGwoVGV4dHVyZVR5cGUudW5wYWNrZWQpXG4gIH07XG5cbiAgY29uc3Qgb3V0cHV0ID0gaW5mZXJlbmNlSGFuZGxlci5ydW4oXG4gICAgICB7Li4uc3VtUHJvZ3JhbU1ldGFkYXRhLCBnZXQ6ICgpID0+IGNyZWF0ZVN1bVByb2dyYW1JbmZvKGluZmVyZW5jZUhhbmRsZXIsIGlucHV0cywgc3VtUHJvZ3JhbU1ldGFkYXRhKX0sIGlucHV0cyk7XG4gIHJldHVybiBbb3V0cHV0XTtcbn07XG5cbmNvbnN0IGNyZWF0ZVN1bVByb2dyYW1JbmZvID1cbiAgICAoaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdLCBzdW1Qcm9ncmFtTWV0YWRhdGE6IFByb2dyYW1NZXRhZGF0YSk6IFByb2dyYW1JbmZvID0+IHtcbiAgICAgIGNvbnN0IGdsc2wgPSBnZXRHbHNsKGluZmVyZW5jZUhhbmRsZXIuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC52ZXJzaW9uKTtcbiAgICAgIGNvbnN0IG91dHB1dFNoYXBlID0gaW5wdXRzWzBdLmRpbXMuc2xpY2UoKTtcbiAgICAgIGNvbnN0IHN1bUxpbmUgPSBpbnB1dHMubWFwKChfdiwgaSkgPT4gYCR7Z2xzbC50ZXh0dXJlMkR9KFgke2l9LFRleENvb3JkcylgKS5qb2luKCcgKyAnKTtcbiAgICAgIGNvbnN0IHNoYWRlclNvdXJjZSA9IGBcbiAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgdmVjNCByZXN1bHQgPSAke3N1bUxpbmV9O1xuICAgICAgICAke2dsc2wub3V0cHV0fSA9IHJlc3VsdDtcbiAgICAgIH1cbiAgICBgO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uc3VtUHJvZ3JhbU1ldGFkYXRhLFxuICAgICAgICBvdXRwdXQ6IHtkaW1zOiBvdXRwdXRTaGFwZSwgdHlwZTogaW5wdXRzWzBdLnR5cGUsIHRleHR1cmVUeXBlOiBUZXh0dXJlVHlwZS51bnBhY2tlZH0sXG4gICAgICAgIGhhc01haW46IHRydWUsXG4gICAgICAgIHNoYWRlclNvdXJjZVxuICAgICAgfTtcbiAgICB9O1xuXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IFRlbnNvcltdKTogdm9pZCA9PiB7XG4gIGlmICghaW5wdXRzIHx8IGlucHV0cy5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1N1bSByZXF1aXJlcyBpbnB1dHMuJyk7XG4gIH1cblxuICBjb25zdCBsZW5ndGggPSBpbnB1dHNbMF0uZGltcy5sZW5ndGg7XG4gIGZvciAobGV0IGkgPSAxOyBpIDwgaW5wdXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGxlbmd0aCAhPT0gaW5wdXRzW2ldLmRpbXMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IHNoYXBlcyBhcmUgbWlzbWF0Y2hlZC4nKTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGxlbmd0aDsgaisrKSB7XG4gICAgICBpZiAoaW5wdXRzWzBdLmRpbXNbal0gIT09IGlucHV0c1tpXS5kaW1zW2pdKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgc2hhcGVzIGFyZSBub3QgbWF0Y2hlZC4nKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoaW5wdXRzWzBdLnR5cGUgIT09ICdmbG9hdDMyJyAmJiBpbnB1dHNbMF0udHlwZSAhPT0gJ2Zsb2F0NjQnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGlucHV0IHR5cGUuJyk7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDE7IGkgPCBpbnB1dHMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoaW5wdXRzWzBdLnR5cGUgIT09IGlucHV0c1tpXS50eXBlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IHR5cGVzIGFyZSBub3QgbWF0Y2hlZC4nKTtcbiAgICB9XG4gIH1cbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7TlVNQkVSX1RZUEVTfSBmcm9tICcuLi8uLi8uLi9vcGVyYXRvcnMnO1xuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4uLy4uLy4uL3RlbnNvcic7XG5pbXBvcnQge1dlYkdMSW5mZXJlbmNlSGFuZGxlcn0gZnJvbSAnLi4vaW5mZXJlbmNlLWhhbmRsZXInO1xuaW1wb3J0IHtQcm9ncmFtSW5mbywgUHJvZ3JhbU1ldGFkYXRhLCBUZXh0dXJlVHlwZX0gZnJvbSAnLi4vdHlwZXMnO1xuXG5leHBvcnQgY29uc3QgdGlsZSA9IChpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOiBUZW5zb3JbXSA9PiB7XG4gIHZhbGlkYXRlSW5wdXRzKGlucHV0cyk7XG5cbiAgY29uc3QgdGlsZVByb2dyYW1NZXRhZGF0YSA9IHtcbiAgICBuYW1lOiAnVGlsZScsXG4gICAgaW5wdXROYW1lczogWydBJ10sXG4gICAgaW5wdXRUeXBlczogW1RleHR1cmVUeXBlLnVucGFja2VkXSxcbiAgfTtcblxuICBjb25zdCBvdXRwdXQgPSBpbmZlcmVuY2VIYW5kbGVyLnJ1bihcbiAgICAgIHsuLi50aWxlUHJvZ3JhbU1ldGFkYXRhLCBnZXQ6ICgpID0+IGNyZWF0ZVRpbGVQcm9ncmFtSW5mbyhpbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHMsIHRpbGVQcm9ncmFtTWV0YWRhdGEpfSxcbiAgICAgIGlucHV0cyk7XG4gIHJldHVybiBbb3V0cHV0XTtcbn07XG5cbmNvbnN0IGNyZWF0ZVRpbGVQcm9ncmFtSW5mbyA9XG4gICAgKF9oYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10sIHRpbGVQcm9ncmFtTWV0YWRhdGE6IFByb2dyYW1NZXRhZGF0YSk6IFByb2dyYW1JbmZvID0+IHtcbiAgICAgIGNvbnN0IGlucHV0U2hhcGUgPSBpbnB1dHNbMF0uZGltcy5zbGljZSgpO1xuICAgICAgY29uc3Qgb3V0cHV0U2hhcGUgPSBuZXcgQXJyYXkoaW5wdXRTaGFwZS5sZW5ndGgpO1xuXG4gICAgICBjb25zdCB0aWxlT3BzOiBzdHJpbmdbXSA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dFNoYXBlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG91dHB1dFNoYXBlW2ldID0gaW5wdXRTaGFwZVtpXSAqIGlucHV0c1sxXS5udW1iZXJEYXRhW2ldO1xuICAgICAgICB0aWxlT3BzLnB1c2goYGlucHV0SWR4WyR7aX1dID0gaW50KG1vZChmbG9hdChvdXRwdXRJZHhbJHtpfV0pLCAke2lucHV0U2hhcGVbaV19LikpO2ApO1xuICAgICAgfVxuXG4gICAgICBjb25zdCByYW5rID0gb3V0cHV0U2hhcGUubGVuZ3RoO1xuICAgICAgY29uc3Qgc2hhZGVyU291cmNlID0gYFxuICAgICAgZmxvYXQgcHJvY2VzcyhpbnQgb3V0cHV0SWR4WyR7cmFua31dKSB7XG4gICAgICAgIGludCBpbnB1dElkeFske3Jhbmt9XTtcbiAgICAgICAgJHt0aWxlT3BzLmpvaW4oJ1xcbicpfVxuICAgICAgICByZXR1cm4gX0EoaW5wdXRJZHgpO1xuICAgICAgfVxuICAgIGA7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi50aWxlUHJvZ3JhbU1ldGFkYXRhLFxuICAgICAgICBvdXRwdXQ6IHtkaW1zOiBvdXRwdXRTaGFwZSwgdHlwZTogaW5wdXRzWzBdLnR5cGUsIHRleHR1cmVUeXBlOiBUZXh0dXJlVHlwZS51bnBhY2tlZH0sXG4gICAgICAgIHNoYWRlclNvdXJjZVxuICAgICAgfTtcbiAgICB9O1xuXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IFRlbnNvcltdKTogdm9pZCA9PiB7XG4gIGlmICghaW5wdXRzIHx8IGlucHV0cy5sZW5ndGggIT09IDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RpbGUgcmVxdWlyZXMgMiBpbnB1dC4nKTtcbiAgfVxuICBpZiAoaW5wdXRzWzFdLmRpbXMubGVuZ3RoICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgc2Vjb25kIGlucHV0IHNoYXBlIG11c3QgMSBkaW1lbnNpb24uJyk7XG4gIH1cbiAgaWYgKGlucHV0c1sxXS5kaW1zWzBdICE9PSBpbnB1dHNbMF0uZGltcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW5wdXQgc2hhcGUuJyk7XG4gIH1cbiAgaWYgKE5VTUJFUl9UWVBFUy5pbmRleE9mKGlucHV0c1swXS50eXBlKSA9PT0gLTEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW5wdXQgdHlwZS4nKTtcbiAgfVxuICBpZiAoaW5wdXRzWzFdLnR5cGUgIT09ICdpbnQzMicgJiYgaW5wdXRzWzFdLnR5cGUgIT09ICdpbnQxNicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcmVwZWF0IHR5cGUuJyk7XG4gIH1cbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7R3JhcGh9IGZyb20gJy4uLy4uLy4uL2dyYXBoJztcbmltcG9ydCB7T3BlcmF0b3JJbXBsZW1lbnRhdGlvbiwgT3BlcmF0b3JJbml0aWFsaXphdGlvbn0gZnJvbSAnLi4vLi4vLi4vb3BlcmF0b3JzJztcbmltcG9ydCB7VGVuc29yfSBmcm9tICcuLi8uLi8uLi90ZW5zb3InO1xuaW1wb3J0IHtTaGFwZVV0aWx9IGZyb20gJy4uLy4uLy4uL3V0aWwnO1xuaW1wb3J0IHtXZWJHTEluZmVyZW5jZUhhbmRsZXJ9IGZyb20gJy4uL2luZmVyZW5jZS1oYW5kbGVyJztcblxuZXhwb3J0IGNvbnN0IHVuc3F1ZWV6ZTogT3BlcmF0b3JJbXBsZW1lbnRhdGlvbjxudW1iZXJbXT4gPVxuICAgIChpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10sIGF4ZXM6IG51bWJlcltdKTogVGVuc29yW10gPT4ge1xuICAgICAgdmFsaWRhdGVJbnB1dHMoaW5wdXRzKTtcbiAgICAgIGNvbnN0IG91dHB1dFNoYXBlID0gU2hhcGVVdGlsLnVuc3F1ZWV6ZVNoYXBlKGlucHV0c1swXS5kaW1zLCBheGVzKTtcbiAgICAgIGNvbnN0IG91dHB1dCA9IGluZmVyZW5jZUhhbmRsZXIucmVzaGFwZVVucGFja2VkKGlucHV0c1swXSwgb3V0cHV0U2hhcGUpO1xuICAgICAgcmV0dXJuIFtvdXRwdXRdO1xuICAgIH07XG5cbmV4cG9ydCBjb25zdCB1bnNxdWVlemVWMTMgPSAoaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTogVGVuc29yW10gPT4ge1xuICB2YWxpZGF0ZUlucHV0c1YxMyhpbnB1dHMpO1xuICByZXR1cm4gdW5zcXVlZXplKGluZmVyZW5jZUhhbmRsZXIsIFtpbnB1dHNbMF1dLCBBcnJheS5mcm9tKGlucHV0c1sxXS5pbnRlZ2VyRGF0YSkpO1xufTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlVW5zcXVlZXplQXR0cmlidXRlczogT3BlcmF0b3JJbml0aWFsaXphdGlvbjxudW1iZXJbXT4gPSAobm9kZTogR3JhcGguTm9kZSk6IG51bWJlcltdID0+XG4gICAgbm9kZS5hdHRyaWJ1dGVzLmdldEludHMoJ2F4ZXMnKTtcblxuY29uc3QgdmFsaWRhdGVJbnB1dHMgPSAoaW5wdXRzOiBUZW5zb3JbXSk6IHZvaWQgPT4ge1xuICBpZiAoIWlucHV0cyB8fCBpbnB1dHMubGVuZ3RoICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbnNxdWVlemUgcmVxdWlyZXMgMSBpbnB1dC4nKTtcbiAgfVxuXG4gIGlmIChpbnB1dHNbMF0udHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgaW5wdXQgdGVuc29yIHR5cGVzLicpO1xuICB9XG59O1xuXG5jb25zdCB2YWxpZGF0ZUlucHV0c1YxMyA9IChpbnB1dHM6IFRlbnNvcltdKTogdm9pZCA9PiB7XG4gIGlmICghaW5wdXRzIHx8IGlucHV0cy5sZW5ndGggIT09IDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3F1ZWV6ZSByZXF1aXJlcyAyIGlucHV0cy4nKTtcbiAgfVxuXG4gIGlmIChpbnB1dHNbMV0udHlwZSAhPT0gJ2ludDMyJykge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpbnB1dCB0eXBlLicpO1xuICB9XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge09wU2V0fSBmcm9tICcuLi8uLi9vcHNldCc7XG5cbmltcG9ydCB7YmF0Y2hOb3JtYWxpemF0aW9uLCBwYXJzZUJhdGNoTm9ybWFsaXphdGlvbkF0dHJpYnV0ZXN9IGZyb20gJy4vb3BzL2JhdGNoLW5vcm1hbGl6YXRpb24nO1xuaW1wb3J0ICogYXMgYmluYXJ5T3BzIGZyb20gJy4vb3BzL2JpbmFyeS1vcCc7XG5pbXBvcnQge2Nhc3QsIHBhcnNlQ2FzdEF0dHJpYnV0ZXN9IGZyb20gJy4vb3BzL2Nhc3QnO1xuaW1wb3J0IHtjb25jYXQsIHBhcnNlQ29uY2F0QXR0cmlidXRlc30gZnJvbSAnLi9vcHMvY29uY2F0JztcbmltcG9ydCB7Y29udiwgcGFyc2VDb252QXR0cmlidXRlc30gZnJvbSAnLi9vcHMvY29udic7XG5pbXBvcnQge2NvbnZUcmFuc3Bvc2UsIHBhcnNlQ29udlRyYW5zcG9zZUF0dHJpYnV0ZXN9IGZyb20gJy4vb3BzL2NvbnYtdHJhbnNwb3NlJztcbmltcG9ydCB7ZGVwdGhUb1NwYWNlLCBwYXJzZURlcHRoVG9TcGFjZUF0dHJpYnV0ZXN9IGZyb20gJy4vb3BzL2RlcHRoLXRvLXNwYWNlJztcbmltcG9ydCB7ZmxhdHRlbiwgcGFyc2VGbGF0dGVuQXR0cmlidXRlc30gZnJvbSAnLi9vcHMvZmxhdHRlbic7XG5pbXBvcnQge2dhdGhlciwgcGFyc2VHYXRoZXJBdHRyaWJ1dGVzfSBmcm9tICcuL29wcy9nYXRoZXInO1xuaW1wb3J0IHtnZW1tLCBwYXJzZUdlbW1BdHRyaWJ1dGVzVjExLCBwYXJzZUdlbW1BdHRyaWJ1dGVzVjd9IGZyb20gJy4vb3BzL2dlbW0nO1xuaW1wb3J0IHtpbWFnZVNjYWxlciwgcGFyc2VJbWFnZVNjYWxlckF0dHJpYnV0ZXN9IGZyb20gJy4vb3BzL2ltYWdlLXNjYWxlcic7XG5pbXBvcnQge2luc3RhbmNlTm9ybWFsaXphdGlvbiwgcGFyc2VJbnN0YW5jZU5vcm1hbGl6YXRpb25BdHRyaWJ1dGVzfSBmcm9tICcuL29wcy9pbnN0YW5jZS1ub3JtYWxpemF0aW9uJztcbmltcG9ydCB7bHJuLCBwYXJzZUxybkF0dHJpYnV0ZXN9IGZyb20gJy4vb3BzL2xybic7XG5pbXBvcnQge21hdE11bCwgcGFyc2VNYXRNdWxBdHRyaWJ1dGVzfSBmcm9tICcuL29wcy9tYXRtdWwnO1xuaW1wb3J0IHtwYWRWMTEsIHBhZFYyLCBwYXJzZVBhZEF0dHJpYnV0ZXNWMTEsIHBhcnNlUGFkQXR0cmlidXRlc1YyfSBmcm9tICcuL29wcy9wYWQnO1xuaW1wb3J0IHthdmVyYWdlUG9vbCwgZ2xvYmFsQXZlcmFnZVBvb2wsIGdsb2JhbE1heFBvb2wsIG1heFBvb2wsIHBhcnNlQXZlcmFnZVBvb2xBdHRyaWJ1dGVzLCBwYXJzZUdsb2JhbEF2ZXJhZ2VQb29sQXR0cmlidXRlcywgcGFyc2VNYXhQb29sQXR0cmlidXRlc30gZnJvbSAnLi9vcHMvcG9vbCc7XG5pbXBvcnQge3BhcnNlUmVkdWNlQXR0cmlidXRlcywgcmVkdWNlTG9nU3VtLCByZWR1Y2VMb2dTdW1TcXVhcmUsIHJlZHVjZU1heCwgcmVkdWNlTWVhbiwgcmVkdWNlTWluLCByZWR1Y2VQcm9kLCByZWR1Y2VTdW19IGZyb20gJy4vb3BzL3JlZHVjZSc7XG5pbXBvcnQge3Jlc2hhcGV9IGZyb20gJy4vb3BzL3Jlc2hhcGUnO1xuaW1wb3J0IHtwYXJzZVJlc2l6ZUF0dHJpYnV0ZXNWMTAsIHBhcnNlUmVzaXplQXR0cmlidXRlc1YxMSwgcmVzaXplfSBmcm9tICcuL29wcy9yZXNpemUtcGFja2VkJztcbmltcG9ydCB7c2hhcGV9IGZyb20gJy4vb3BzL3NoYXBlJztcbmltcG9ydCB7cGFyc2VTbGljZUF0dHJpYnV0ZXMsIHNsaWNlLCBzbGljZVYxMH0gZnJvbSAnLi9vcHMvc2xpY2UnO1xuaW1wb3J0IHtwYXJzZVNvZnRtYXhBdHRyaWJ1dGVzLCBwYXJzZVNvZnRtYXhBdHRyaWJ1dGVzVjEzLCBzb2Z0bWF4LCBzb2Z0bWF4VjEzfSBmcm9tICcuL29wcy9zb2Z0bWF4JztcbmltcG9ydCB7cGFyc2VTcGxpdEF0dHJpYnV0ZXMsIHNwbGl0fSBmcm9tICcuL29wcy9zcGxpdCc7XG5pbXBvcnQge3BhcnNlU3F1ZWV6ZUF0dHJpYnV0ZXMsIHNxdWVlemUsIHNxdWVlemVWMTN9IGZyb20gJy4vb3BzL3NxdWVlemUnO1xuaW1wb3J0IHtzdW19IGZyb20gJy4vb3BzL3N1bSc7XG5pbXBvcnQge3RpbGV9IGZyb20gJy4vb3BzL3RpbGUnO1xuaW1wb3J0IHtwYXJzZVRyYW5zcG9zZUF0dHJpYnV0ZXMsIHRyYW5zcG9zZX0gZnJvbSAnLi9vcHMvdHJhbnNwb3NlJztcbmltcG9ydCAqIGFzIHVuYXJ5T3BzIGZyb20gJy4vb3BzL3VuYXJ5LW9wJztcbmltcG9ydCB7cGFyc2VVbnNxdWVlemVBdHRyaWJ1dGVzLCB1bnNxdWVlemUsIHVuc3F1ZWV6ZVYxM30gZnJvbSAnLi9vcHMvdW5zcXVlZXplJztcbmltcG9ydCB7cGFyc2VVcHNhbXBsZUF0dHJpYnV0ZXNWNywgcGFyc2VVcHNhbXBsZUF0dHJpYnV0ZXNWOSwgdXBzYW1wbGV9IGZyb20gJy4vb3BzL3Vwc2FtcGxlJztcblxuZXhwb3J0IGNvbnN0IFdFQkdMX09QX1JFU09MVkVfUlVMRVM6IHJlYWRvbmx5IE9wU2V0LlJlc29sdmVSdWxlW10gPSBbXG4gIFsnQWJzJywgJycsICc2KycsIHVuYXJ5T3BzLmFic10sXG4gIFsnQWNvcycsICcnLCAnNysnLCB1bmFyeU9wcy5hY29zXSxcbiAgWydBZGQnLCAnJywgJzcrJywgYmluYXJ5T3BzLmFkZF0sXG4gIFsnQW5kJywgJycsICc3KycsIGJpbmFyeU9wcy5hbmRdLFxuICBbJ0FzaW4nLCAnJywgJzcrJywgdW5hcnlPcHMuYXNpbl0sXG4gIFsnQXRhbicsICcnLCAnNysnLCB1bmFyeU9wcy5hdGFuXSxcbiAgLy8gVE9ETzogc3VwcG9ydCBuZXcgYXR0cmlidXRlcyBmb3IgQXZlcmFnZVBvb2wtMTBcbiAgWydBdmVyYWdlUG9vbCcsICcnLCAnNysnLCBhdmVyYWdlUG9vbCwgcGFyc2VBdmVyYWdlUG9vbEF0dHJpYnV0ZXNdLFxuICBbJ0JhdGNoTm9ybWFsaXphdGlvbicsICcnLCAnNysnLCBiYXRjaE5vcm1hbGl6YXRpb24sIHBhcnNlQmF0Y2hOb3JtYWxpemF0aW9uQXR0cmlidXRlc10sXG4gIFsnQ2FzdCcsICcnLCAnNisnLCBjYXN0LCBwYXJzZUNhc3RBdHRyaWJ1dGVzXSxcbiAgWydDZWlsJywgJycsICc2KycsIHVuYXJ5T3BzLmNlaWxdLFxuICBbJ0NsaXAnLCAnJywgJzYtMTAnLCB1bmFyeU9wcy5jbGlwLCB1bmFyeU9wcy5wYXJzZUNsaXBBdHRyaWJ1dGVzXSxcbiAgWydDbGlwJywgJycsICcxMSsnLCB1bmFyeU9wcy5jbGlwVjExXSxcbiAgWydDb25jYXQnLCAnJywgJzQrJywgY29uY2F0LCBwYXJzZUNvbmNhdEF0dHJpYnV0ZXNdLFxuICBbJ0NvbnYnLCAnJywgJzErJywgY29udiwgcGFyc2VDb252QXR0cmlidXRlc10sXG4gIFsnQ29udlRyYW5zcG9zZScsICcnLCAnMSsnLCBjb252VHJhbnNwb3NlLCBwYXJzZUNvbnZUcmFuc3Bvc2VBdHRyaWJ1dGVzXSxcbiAgWydDb3MnLCAnJywgJzcrJywgdW5hcnlPcHMuY29zXSxcbiAgWydEaXYnLCAnJywgJzcrJywgYmluYXJ5T3BzLmRpdl0sXG4gIFsnRHJvcG91dCcsICcnLCAnNysnLCB1bmFyeU9wcy5pZGVudGl0eV0sXG4gIFsnRGVwdGhUb1NwYWNlJywgJycsICcxKycsIGRlcHRoVG9TcGFjZSwgcGFyc2VEZXB0aFRvU3BhY2VBdHRyaWJ1dGVzXSxcbiAgWydFcXVhbCcsICcnLCAnNysnLCBiaW5hcnlPcHMuZXF1YWxdLFxuICBbJ0VsdScsICcnLCAnNisnLCB1bmFyeU9wcy5lbHUsIHVuYXJ5T3BzLnBhcnNlRWx1QXR0cmlidXRlc10sXG4gIFsnRXhwJywgJycsICc2KycsIHVuYXJ5T3BzLmV4cF0sXG4gIFsnRmxhdHRlbicsICcnLCAnMSsnLCBmbGF0dGVuLCBwYXJzZUZsYXR0ZW5BdHRyaWJ1dGVzXSxcbiAgWydGbG9vcicsICcnLCAnNisnLCB1bmFyeU9wcy5mbG9vcl0sXG4gIFsnRnVzZWRDb252JywgJ2NvbS5taWNyb3NvZnQnLCAnMSsnLCBjb252LCBwYXJzZUNvbnZBdHRyaWJ1dGVzXSxcbiAgWydHYXRoZXInLCAnJywgJzErJywgZ2F0aGVyLCBwYXJzZUdhdGhlckF0dHJpYnV0ZXNdLFxuICBbJ0dlbW0nLCAnJywgJzctMTAnLCBnZW1tLCBwYXJzZUdlbW1BdHRyaWJ1dGVzVjddLFxuICBbJ0dlbW0nLCAnJywgJzExKycsIGdlbW0sIHBhcnNlR2VtbUF0dHJpYnV0ZXNWMTFdLFxuICBbJ0dsb2JhbEF2ZXJhZ2VQb29sJywgJycsICcxKycsIGdsb2JhbEF2ZXJhZ2VQb29sLCBwYXJzZUdsb2JhbEF2ZXJhZ2VQb29sQXR0cmlidXRlc10sXG4gIFsnR2xvYmFsTWF4UG9vbCcsICcnLCAnMSsnLCBnbG9iYWxNYXhQb29sXSxcbiAgWydHcmVhdGVyJywgJycsICc3KycsIGJpbmFyeU9wcy5ncmVhdGVyXSxcbiAgWydJZGVudGl0eScsICcnLCAnMSsnLCB1bmFyeU9wcy5pZGVudGl0eV0sXG4gIFsnSW1hZ2VTY2FsZXInLCAnJywgJzErJywgaW1hZ2VTY2FsZXIsIHBhcnNlSW1hZ2VTY2FsZXJBdHRyaWJ1dGVzXSxcbiAgWydJbnN0YW5jZU5vcm1hbGl6YXRpb24nLCAnJywgJzYrJywgaW5zdGFuY2VOb3JtYWxpemF0aW9uLCBwYXJzZUluc3RhbmNlTm9ybWFsaXphdGlvbkF0dHJpYnV0ZXNdLFxuICBbJ0xlYWt5UmVsdScsICcnLCAnNisnLCB1bmFyeU9wcy5sZWFreVJlbHUsIHVuYXJ5T3BzLnBhcnNlTGVha3lSZWx1QXR0cmlidXRlc10sXG4gIFsnTGVzcycsICcnLCAnNysnLCBiaW5hcnlPcHMubGVzc10sXG4gIFsnTFJOJywgJycsICcxKycsIGxybiwgcGFyc2VMcm5BdHRyaWJ1dGVzXSxcbiAgWydMb2cnLCAnJywgJzYrJywgdW5hcnlPcHMubG9nXSxcbiAgWydNYXRNdWwnLCAnJywgJzErJywgbWF0TXVsLCBwYXJzZU1hdE11bEF0dHJpYnV0ZXNdLFxuICAvLyBUT0RPOiBzdXBwb3J0IG5ldyBhdHRyaWJ1dGVzIGZvciBNYXhQb29sLTggYW5kIE1heFBvb2wtMTBcbiAgWydNYXhQb29sJywgJycsICcxKycsIG1heFBvb2wsIHBhcnNlTWF4UG9vbEF0dHJpYnV0ZXNdLFxuICBbJ011bCcsICcnLCAnNysnLCBiaW5hcnlPcHMubXVsXSxcbiAgWydOZWcnLCAnJywgJzYrJywgdW5hcnlPcHMubmVnXSxcbiAgWydOb3QnLCAnJywgJzErJywgdW5hcnlPcHMubm90XSxcbiAgWydPcicsICcnLCAnNysnLCBiaW5hcnlPcHMub3JdLFxuICBbJ1BhZCcsICcnLCAnMi0xMCcsIHBhZFYyLCBwYXJzZVBhZEF0dHJpYnV0ZXNWMl0sXG4gIFsnUGFkJywgJycsICcxMSsnLCBwYWRWMTEsIHBhcnNlUGFkQXR0cmlidXRlc1YxMV0sXG4gIFsnUG93JywgJycsICc3KycsIGJpbmFyeU9wcy5wb3ddLFxuICBbJ1BSZWx1JywgJycsICc3KycsIGJpbmFyeU9wcy5wUmVsdV0sXG4gIFsnUmVkdWNlTG9nU3VtJywgJycsICcxKycsIHJlZHVjZUxvZ1N1bSwgcGFyc2VSZWR1Y2VBdHRyaWJ1dGVzXSxcbiAgWydSZWR1Y2VNYXgnLCAnJywgJzErJywgcmVkdWNlTWF4LCBwYXJzZVJlZHVjZUF0dHJpYnV0ZXNdLFxuICBbJ1JlZHVjZU1lYW4nLCAnJywgJzErJywgcmVkdWNlTWVhbiwgcGFyc2VSZWR1Y2VBdHRyaWJ1dGVzXSxcbiAgWydSZWR1Y2VNaW4nLCAnJywgJzErJywgcmVkdWNlTWluLCBwYXJzZVJlZHVjZUF0dHJpYnV0ZXNdLFxuICBbJ1JlZHVjZVByb2QnLCAnJywgJzErJywgcmVkdWNlUHJvZCwgcGFyc2VSZWR1Y2VBdHRyaWJ1dGVzXSxcbiAgWydSZWR1Y2VTdW0nLCAnJywgJzEtMTInLCByZWR1Y2VTdW0sIHBhcnNlUmVkdWNlQXR0cmlidXRlc10sXG4gIFsnUmVkdWNlU3VtU3F1YXJlJywgJycsICcxKycsIHJlZHVjZUxvZ1N1bVNxdWFyZSwgcGFyc2VSZWR1Y2VBdHRyaWJ1dGVzXSxcbiAgWydSZWx1JywgJycsICc2KycsIHVuYXJ5T3BzLnJlbHVdLFxuICBbJ1Jlc2hhcGUnLCAnJywgJzUrJywgcmVzaGFwZV0sXG4gIFsnUmVzaXplJywgJycsICcxMCcsIHJlc2l6ZSwgcGFyc2VSZXNpemVBdHRyaWJ1dGVzVjEwXSxcbiAgWydSZXNpemUnLCAnJywgJzExKycsIHJlc2l6ZSwgcGFyc2VSZXNpemVBdHRyaWJ1dGVzVjExXSxcbiAgWydTaGFwZScsICcnLCAnMSsnLCBzaGFwZV0sXG4gIFsnU2lnbW9pZCcsICcnLCAnNisnLCB1bmFyeU9wcy5zaWdtb2lkXSxcbiAgWydTaW4nLCAnJywgJzcrJywgdW5hcnlPcHMuc2luXSxcbiAgWydTbGljZScsICcnLCAnMTArJywgc2xpY2VWMTBdLCAgLy8gVE9ETzogc3VwcG9ydCAnc3RlcHMnIGZvciBTbGljZS0xMFxuICBbJ1NsaWNlJywgJycsICcxLTknLCBzbGljZSwgcGFyc2VTbGljZUF0dHJpYnV0ZXNdLFxuICAvLyBUaGUgXCJzZW1hbnRpY1wiIG1lYW5pbmcgb2YgYXhpcyBoYXMgY2hhbmdlZCBpbiBvcHNldC0xMy5cbiAgWydTb2Z0bWF4JywgJycsICcxLTEyJywgc29mdG1heCwgcGFyc2VTb2Z0bWF4QXR0cmlidXRlc10sXG4gIFsnU29mdG1heCcsICcnLCAnMTMrJywgc29mdG1heFYxMywgcGFyc2VTb2Z0bWF4QXR0cmlidXRlc1YxM10sXG4gIC8vICdTcGxpdCcgb3BlcmF0b3IgaGFzIGFuIG9wdGlvbmFsIGF0dHJpYnV0ZSAnc3BsaXQnXG4gIC8vIHRoaXMgYXR0cmlidXRlIGRldGVybWluZXMgaG93IHRoZSBzcGVjaWZpZWQgYXhpcyBvZiBpbnB1dCBkYXRhIGlzIHNwbGl0LlxuICAvLyBXaGVuIHRoZSBhdHRyaWJ1dGUgaXMgbWlzc2luZywgd2UgbmVlZCB0aGUgY291bnQgb2YgbnVtYmVyIG9mIG91dHB1dHNcbiAgLy8gc28gdGhhdCB3ZSBjYW4gZGV0ZXJtaW5lIHRoZSAnc3BsaXQnIGF0dHJpYnV0ZSBmcm9tIHRoZSBydW50aW1lIGlucHV0IHRvIHRoZSBPcGVyYXRvclxuICBbJ1NwbGl0JywgJycsICcyLTEyJywgc3BsaXQsIHBhcnNlU3BsaXRBdHRyaWJ1dGVzXSxcbiAgWydTcXJ0JywgJycsICc2KycsIHVuYXJ5T3BzLnNxcnRdLFxuICBbJ1NxdWVlemUnLCAnJywgJzEtMTInLCBzcXVlZXplLCBwYXJzZVNxdWVlemVBdHRyaWJ1dGVzXSxcbiAgWydTcXVlZXplJywgJycsICcxMysnLCBzcXVlZXplVjEzXSxcbiAgWydTdWInLCAnJywgJzcrJywgYmluYXJ5T3BzLnN1Yl0sXG4gIFsnU3VtJywgJycsICc2KycsIHN1bV0sXG4gIFsnVGFuJywgJycsICc3KycsIHVuYXJ5T3BzLnRhbl0sXG4gIFsnVGFuaCcsICcnLCAnNisnLCB1bmFyeU9wcy50YW5oXSxcbiAgWydUaWxlJywgJycsICc2KycsIHRpbGVdLFxuICBbJ1RyYW5zcG9zZScsICcnLCAnMSsnLCB0cmFuc3Bvc2UsIHBhcnNlVHJhbnNwb3NlQXR0cmlidXRlc10sXG4gIFsnVXBzYW1wbGUnLCAnJywgJzctOCcsIHVwc2FtcGxlLCBwYXJzZVVwc2FtcGxlQXR0cmlidXRlc1Y3XSxcbiAgWydVcHNhbXBsZScsICcnLCAnOScsIHVwc2FtcGxlLCBwYXJzZVVwc2FtcGxlQXR0cmlidXRlc1Y5XSxcbiAgWydVbnNxdWVlemUnLCAnJywgJzEtMTInLCB1bnNxdWVlemUsIHBhcnNlVW5zcXVlZXplQXR0cmlidXRlc10sXG4gIFsnVW5zcXVlZXplJywgJycsICcxMysnLCB1bnNxdWVlemVWMTNdLFxuICBbJ1hvcicsICcnLCAnNysnLCBiaW5hcnlPcHMueG9yXSxcbl07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmNvbnN0IElOTElORV9GVU5DX0RFRl9SRUdFWCA9IC9AaW5saW5lW1xcc1xcblxccl0rKFxcdyspW1xcc1xcblxccl0rKFswLTlhLXpBLVpfXSspXFxzKlxcKChbXildKilcXClcXHMqeygoW159XXxbXFxuXFxyXSkqKX0vZ207XG5jb25zdCBGVU5DX0NBTExfUkVHRVggPSAnKFxcXFx3Kyk/XFxcXHMrKFtfMC05YS16QS1aXSspXFxcXHMrPVxcXFxzK19fRlVOQ19fXFxcXCgoLiopXFxcXClcXFxccyo7Jztcbi8qKlxuICogR0xTTCBwcmVwcm9jZXNzb3IgcmVzcG9uc2libGUgZm9yIHJlc29sdmluZyBAaW5saW5lIGRpcmVjdGl2ZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlcGxhY2VJbmxpbmVzKHNjcmlwdDogc3RyaW5nKTogc3RyaW5nIHtcbiAgY29uc3QgaW5saW5lRGVmczoge1tuYW1lOiBzdHJpbmddOiB7cGFyYW1zOiBBcnJheTx7dHlwZTogc3RyaW5nOyBuYW1lOiBzdHJpbmd9fG51bGw+OyBib2R5OiBzdHJpbmd9fSA9IHt9O1xuICBsZXQgbWF0Y2g7XG4gIHdoaWxlICgobWF0Y2ggPSBJTkxJTkVfRlVOQ19ERUZfUkVHRVguZXhlYyhzY3JpcHQpKSAhPT0gbnVsbCkge1xuICAgIGNvbnN0IHBhcmFtcyA9IG1hdGNoWzNdXG4gICAgICAgICAgICAgICAgICAgICAgIC5zcGxpdCgnLCcpXG4gICAgICAgICAgICAgICAgICAgICAgIC5tYXAocyA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdG9rZW5zID0gcy50cmltKCkuc3BsaXQoJyAnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW5zICYmIHRva2Vucy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7dHlwZTogdG9rZW5zWzBdLCBuYW1lOiB0b2tlbnNbMV19O1xuICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcih2ID0+IHYgIT09IG51bGwpO1xuICAgIGlubGluZURlZnNbbWF0Y2hbMl1dID0ge3BhcmFtcywgYm9keTogbWF0Y2hbNF19O1xuICB9XG4gIGZvciAoY29uc3QgbmFtZSBpbiBpbmxpbmVEZWZzKSB7XG4gICAgY29uc3QgcmVnZXhTdHJpbmcgPSBGVU5DX0NBTExfUkVHRVgucmVwbGFjZSgnX19GVU5DX18nLCBuYW1lKTtcbiAgICBjb25zdCByZWdleCA9IG5ldyBSZWdFeHAocmVnZXhTdHJpbmcsICdnbScpO1xuICAgIHdoaWxlICgobWF0Y2ggPSByZWdleC5leGVjKHNjcmlwdCkpICE9PSBudWxsKSB7XG4gICAgICBjb25zdCB0eXBlID0gbWF0Y2hbMV07XG4gICAgICBjb25zdCB2YXJpYWJsZSA9IG1hdGNoWzJdO1xuICAgICAgY29uc3QgcGFyYW1zID0gbWF0Y2hbM10uc3BsaXQoJywnKTtcbiAgICAgIGNvbnN0IGRlY2xMaW5lID0gKHR5cGUpID8gYCR7dHlwZX0gJHt2YXJpYWJsZX07YCA6ICcnO1xuICAgICAgbGV0IG5ld0JvZHk6IHN0cmluZyA9IGlubGluZURlZnNbbmFtZV0uYm9keTtcbiAgICAgIGxldCBwYXJhbVJlZGVjTGluZSA9ICcnO1xuICAgICAgaW5saW5lRGVmc1tuYW1lXS5wYXJhbXMuZm9yRWFjaCgodiwgaSkgPT4ge1xuICAgICAgICBpZiAodikge1xuICAgICAgICAgIHBhcmFtUmVkZWNMaW5lICs9IGAke3YudHlwZX0gJHt2Lm5hbWV9ID0gJHtwYXJhbXNbaV19O1xcbmA7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgbmV3Qm9keSA9IGAke3BhcmFtUmVkZWNMaW5lfVxcbiAke25ld0JvZHl9YDtcbiAgICAgIG5ld0JvZHkgPSBuZXdCb2R5LnJlcGxhY2UoJ3JldHVybicsIGAke3ZhcmlhYmxlfSA9IGApO1xuICAgICAgY29uc3QgcmVwbGFjZW1lbnQgPSBgXG4gICAgICAke2RlY2xMaW5lfVxuICAgICAge1xuICAgICAgICAke25ld0JvZHl9XG4gICAgICB9XG4gICAgICBgO1xuICAgICAgc2NyaXB0ID0gc2NyaXB0LnJlcGxhY2UobWF0Y2hbMF0sIHJlcGxhY2VtZW50KTtcbiAgICB9XG4gIH1cbiAgc2NyaXB0ID0gc2NyaXB0LnJlcGxhY2UoSU5MSU5FX0ZVTkNfREVGX1JFR0VYLCAnJyk7XG4gIHJldHVybiBzY3JpcHQ7XG59XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7TG9nZ2VyfSBmcm9tICcuLi8uLi9pbnN0cnVtZW50JztcbmltcG9ydCB7YXNzZXJ0fSBmcm9tICcuLi8uLi91dGlsJztcblxuLyoqIExheW91dCBwcmVmZXJlbmNlcyAqL1xuZXhwb3J0IGludGVyZmFjZSBXaWR0aEhlaWdodFByZWZzIHtcbiAgYnJlYWtBeGlzPzogbnVtYmVyO1xuICBpc1BhY2tlZD86IGJvb2xlYW47XG4gIHJldmVyc2VXSD86IGJvb2xlYW47XG59XG4vKipcbiAqIFRleHR1cmVMYXlvdXRTdHJhdGVneSBpcyBhbiBhYnN0cmFjdGlvbiBmb3IgZGlmZmVyZW50IHBsYW5zXG4gKiBmb3IgbWFwcGluZyBuLWRpbWVuc2lvbmFsIGFycmF5cyB0byAyRCB0ZXh0dXJlcyAoYW5kIGJhY2spXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVGV4dHVyZUxheW91dFN0cmF0ZWd5IHtcbiAgY29tcHV0ZVRleHR1cmVXSChzaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sIHByZWZzPzogV2lkdGhIZWlnaHRQcmVmcyk6IFtudW1iZXIsIG51bWJlcl07XG59XG5cbi8qKlxuICogVGhpcyBzdHJhdGVneSB0cnkgdG8gZmluZCB0aGUgbWluaW1hbCBtYXgoVyxIKSB0aGF0IGZ1bGZpbGxzIChXICogSCA9PSB0b3RhbFNpemUpXG4gKi9cbmV4cG9ydCBjbGFzcyBBbHdheXNLZWVwT3JpZ2luYWxTaXplU3RyYXRlZ3kgaW1wbGVtZW50cyBUZXh0dXJlTGF5b3V0U3RyYXRlZ3kge1xuICBjb25zdHJ1Y3RvcihwdWJsaWMgbWF4VGV4dHVyZVNpemU6IG51bWJlcikge31cbiAgY29tcHV0ZVRleHR1cmVXSChzaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sIHByZWZzPzogV2lkdGhIZWlnaHRQcmVmcyk6IFtudW1iZXIsIG51bWJlcl0ge1xuICAgIC8vIHNjYWxhciB0ZW5zb3JcbiAgICBpZiAoc2hhcGUubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gWzEsIDFdO1xuICAgIH1cbiAgICBjb25zdCBtYXhUZXh0dXJlU2l6ZSA9IHRoaXMubWF4VGV4dHVyZVNpemU7XG4gICAgaWYgKHByZWZzICYmIHByZWZzLmJyZWFrQXhpcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBjaGVjayB0byBzZWUgaWYgZGltcyBmaXRcbiAgICAgIGNvbnN0IHdzaXplID0gcHJlZnMuYnJlYWtBeGlzID49IHNoYXBlLmxlbmd0aCA/IDEgOiBzaGFwZS5zbGljZShwcmVmcy5icmVha0F4aXMpLnJlZHVjZSgoYSwgYikgPT4gYSAqIGIpO1xuICAgICAgY29uc3QgaHNpemUgPSBwcmVmcy5icmVha0F4aXMgPD0gMCA/IDEgOiBzaGFwZS5zbGljZSgwLCBwcmVmcy5icmVha0F4aXMpLnJlZHVjZSgoYSwgYikgPT4gYSAqIGIpO1xuICAgICAgaWYgKHdzaXplID4gbWF4VGV4dHVyZVNpemUgfHwgaHNpemUgPiBtYXhUZXh0dXJlU2l6ZSkge1xuICAgICAgICAvLyBpZ25vcmUgcHJlZmVyZW5jZXNcbiAgICAgICAgLy8gY29udGludWUgd2l0aCBkZWZhdWx0IGxheW91dFxuICAgICAgICBMb2dnZXIudmVyYm9zZShcbiAgICAgICAgICAgICdUZXh0dXJlTGF5b3V0JyxcbiAgICAgICAgICAgIGBHaXZlbiB3aWR0aC9oZWlnaHQgcHJlZmVyZW5jZXMgd2VyZSB1bmF0dGFpbmFibGU6IHNoYXBlOiR7c2hhcGV9LCBicmVha0F4aXM6JHtwcmVmcy5icmVha0F4aXN9YCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gW3dzaXplLCBoc2l6ZV07XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHRvdGFsU2l6ZSA9IHNoYXBlLnJlZHVjZSgoYSwgYikgPT4gYSAqIGIpO1xuXG4gICAgbGV0IHdpZHRoID0gTWF0aC5mbG9vcihNYXRoLnNxcnQodG90YWxTaXplKSk7XG5cbiAgICBmb3IgKDsgd2lkdGggPCBtYXhUZXh0dXJlU2l6ZSAmJiB3aWR0aCA8IHRvdGFsU2l6ZTsgd2lkdGgrKykge1xuICAgICAgaWYgKHRvdGFsU2l6ZSAlIHdpZHRoID09PSAwKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh3aWR0aCA+PSBtYXhUZXh0dXJlU2l6ZSB8fCB0b3RhbFNpemUgJSB3aWR0aCAhPT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgZ2l2ZW4gZGltZW5zaW9ucyBhcmUgb3V0c2lkZSB0aGlzIEdQVSdzIGJvdW5kYXJpZXM6ICR7c2hhcGV9YCk7XG4gICAgfVxuICAgIHJldHVybiBbd2lkdGgsIHRvdGFsU2l6ZSAvIHdpZHRoXTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgUHJlZmVyTG9naWNhbFN0cmF0ZWd5IGltcGxlbWVudHMgVGV4dHVyZUxheW91dFN0cmF0ZWd5IHtcbiAgY29uc3RydWN0b3IocHVibGljIG1heFRleHR1cmVTaXplOiBudW1iZXIpIHt9XG4gIGNvbXB1dGVUZXh0dXJlV0goc2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLCBwcmVmcz86IFdpZHRoSGVpZ2h0UHJlZnMpOiBbbnVtYmVyLCBudW1iZXJdIHtcbiAgICBjb25zdCB3aCA9IHRoaXMuY29tcHV0ZVRleHR1cmUoc2hhcGUsIHByZWZzKTtcbiAgICBpZiAocHJlZnMgJiYgcHJlZnMuaXNQYWNrZWQpIHtcbiAgICAgIHdoWzBdIC89IDI7XG4gICAgICB3aFsxXSAvPSAyO1xuICAgIH1cbiAgICBpZiAocHJlZnMgJiYgcHJlZnMucmV2ZXJzZVdIKSB7XG4gICAgICByZXR1cm4gW3doWzFdLCB3aFswXV07XG4gICAgfVxuICAgIHJldHVybiB3aDtcbiAgfVxuXG4gIGNvbXB1dGVUZXh0dXJlKHNoYXBlOiByZWFkb25seSBudW1iZXJbXSwgcHJlZnM/OiBXaWR0aEhlaWdodFByZWZzKTogW251bWJlciwgbnVtYmVyXSB7XG4gICAgY29uc3QgaXNQYWNrZWQgPSBwcmVmcyAmJiBwcmVmcy5pc1BhY2tlZDtcbiAgICAvLyBzY2FsYXIgdGVuc29yXG4gICAgaWYgKHNoYXBlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGlzUGFja2VkID8gWzIsIDJdIDogWzEsIDFdO1xuICAgIH1cbiAgICBsZXQgbWF4VGV4dHVyZVNpemUgPSB0aGlzLm1heFRleHR1cmVTaXplO1xuICAgIGlmIChwcmVmcyAmJiBwcmVmcy5icmVha0F4aXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gY2hlY2sgdG8gc2VlIGlmIGRpbXMgZml0XG4gICAgICBjb25zdCB3c2l6ZSA9IHByZWZzLmJyZWFrQXhpcyA+PSBzaGFwZS5sZW5ndGggPyAxIDogc2hhcGUuc2xpY2UocHJlZnMuYnJlYWtBeGlzKS5yZWR1Y2UoKGEsIGIpID0+IGEgKiBiKTtcbiAgICAgIGNvbnN0IGhzaXplID0gcHJlZnMuYnJlYWtBeGlzIDw9IDAgPyAxIDogc2hhcGUuc2xpY2UoMCwgcHJlZnMuYnJlYWtBeGlzKS5yZWR1Y2UoKGEsIGIpID0+IGEgKiBiKTtcbiAgICAgIGlmICh3c2l6ZSA+IG1heFRleHR1cmVTaXplIHx8IGhzaXplID4gbWF4VGV4dHVyZVNpemUpIHtcbiAgICAgICAgLy8gaWdub3JlIHByZWZlcmVuY2VzXG4gICAgICAgIC8vIGNvbnRpbnVlIHdpdGggZGVmYXVsdCBsYXlvdXRcbiAgICAgICAgTG9nZ2VyLnZlcmJvc2UoXG4gICAgICAgICAgICAnVGV4dHVyZUxheW91dCcsXG4gICAgICAgICAgICBgR2l2ZW4gd2lkdGgvaGVpZ2h0IHByZWZlcmVuY2VzIHdlcmUgdW5hdHRhaW5hYmxlOiBzaGFwZToke3NoYXBlfSwgYnJlYWtBeGlzOiR7cHJlZnMuYnJlYWtBeGlzfWApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFt3c2l6ZSwgaHNpemVdO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgbG9nU2hhcGUgPSBzaGFwZS5zbGljZSgwKTtcbiAgICBpZiAoaXNQYWNrZWQpIHtcbiAgICAgIG1heFRleHR1cmVTaXplID0gbWF4VGV4dHVyZVNpemUgKiAyO1xuXG4gICAgICAvLyBUaGlzIGxvZ2ljIGVuc3VyZXMgd2UgYWNjdXJhdGVseSBjb3VudCB0aGUgbnVtYmVyIG9mIHBhY2tlZCB0ZXhlbHMgbmVlZGVkXG4gICAgICAvLyB0byBhY2NvbW1vZGF0ZSB0aGUgdGVuc29yLiBXZSBjYW4gb25seSBwYWNrIHZhbHVlcyBpbiB0aGUgc2FtZSB0ZXhlbCBpZlxuICAgICAgLy8gdGhleSBhcmUgZnJvbSBhZGphY2VudCBwYWlycyBvZiByb3dzL2NvbHMgd2l0aGluIHRoZSBzYW1lIGJhdGNoLiBTbyBpZiBhXG4gICAgICAvLyB0ZW5zb3IgaGFzIDMgcm93cywgd2UgcHJldGVuZCBpdCBoYXMgNCByb3dzIGluIG9yZGVyIHRvIGFjY291bnQgZm9yIHRoZVxuICAgICAgLy8gZmFjdCB0aGF0IHRoZSB0ZXhlbHMgY29udGFpbmluZyB0aGUgdGhpcmQgcm93IGFyZSBoYWxmIGVtcHR5LlxuICAgICAgbG9nU2hhcGUgPSBsb2dTaGFwZS5tYXAoXG4gICAgICAgICAgKF9kLCBpKSA9PiBpID49IGxvZ1NoYXBlLmxlbmd0aCAtIDIgPyAobG9nU2hhcGVbaV0gJSAyID09PSAwID8gbG9nU2hhcGVbaV0gOiBsb2dTaGFwZVtpXSArIDEpIDogbG9nU2hhcGVbaV0pO1xuXG4gICAgICAvLyBQYWNrZWQgdGV4dHVyZSBoZWlnaHQgaXMgYXQgbGVhc3QgMiAodGhlIGNoYW5uZWwgaGVpZ2h0IG9mIGEgc2luZ2xlXG4gICAgICAvLyB0ZXhlbCkuXG4gICAgICBpZiAobG9nU2hhcGUubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGxvZ1NoYXBlID0gWzIsIGxvZ1NoYXBlWzBdXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiBsb2dpY2FsIHNoYXBlIGlzIDIsIHdlIGRvbid0IHNxdWVlemUsIHNpbmNlIHdlIHdhbnQgdG8gbWF0Y2ggcGh5c2ljYWwuXG4gICAgaWYgKGxvZ1NoYXBlLmxlbmd0aCAhPT0gMikge1xuICAgICAgY29uc3Qgc3F1ZWV6ZVJlc3VsdCA9IHNxdWVlemVTaGFwZShsb2dTaGFwZSk7XG4gICAgICBsb2dTaGFwZSA9IHNxdWVlemVSZXN1bHQubmV3U2hhcGU7XG4gICAgfVxuXG4gICAgY29uc3Qgc2l6ZSA9IHNpemVGcm9tU2hhcGUobG9nU2hhcGUpO1xuICAgIGlmIChsb2dTaGFwZS5sZW5ndGggPD0gMSAmJiBzaXplIDw9IG1heFRleHR1cmVTaXplKSB7XG4gICAgICByZXR1cm4gWzEsIHNpemVdO1xuICAgIH0gZWxzZSBpZiAobG9nU2hhcGUubGVuZ3RoID09PSAyICYmIGxvZ1NoYXBlWzBdIDw9IG1heFRleHR1cmVTaXplICYmIGxvZ1NoYXBlWzFdIDw9IG1heFRleHR1cmVTaXplKSB7XG4gICAgICByZXR1cm4gbG9nU2hhcGUgYXMgW251bWJlciwgbnVtYmVyXTtcbiAgICB9IGVsc2UgaWYgKGxvZ1NoYXBlLmxlbmd0aCA9PT0gMyAmJiBsb2dTaGFwZVswXSAqIGxvZ1NoYXBlWzFdIDw9IG1heFRleHR1cmVTaXplICYmIGxvZ1NoYXBlWzJdIDw9IG1heFRleHR1cmVTaXplKSB7XG4gICAgICByZXR1cm4gW2xvZ1NoYXBlWzBdICogbG9nU2hhcGVbMV0sIGxvZ1NoYXBlWzJdXTtcbiAgICB9IGVsc2UgaWYgKGxvZ1NoYXBlLmxlbmd0aCA9PT0gMyAmJiBsb2dTaGFwZVswXSA8PSBtYXhUZXh0dXJlU2l6ZSAmJiBsb2dTaGFwZVsxXSAqIGxvZ1NoYXBlWzJdIDw9IG1heFRleHR1cmVTaXplKSB7XG4gICAgICByZXR1cm4gW2xvZ1NoYXBlWzBdLCBsb2dTaGFwZVsxXSAqIGxvZ1NoYXBlWzJdXTtcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgICBsb2dTaGFwZS5sZW5ndGggPT09IDQgJiYgbG9nU2hhcGVbMF0gKiBsb2dTaGFwZVsxXSAqIGxvZ1NoYXBlWzJdIDw9IG1heFRleHR1cmVTaXplICYmXG4gICAgICAgIGxvZ1NoYXBlWzNdIDw9IG1heFRleHR1cmVTaXplKSB7XG4gICAgICByZXR1cm4gW2xvZ1NoYXBlWzBdICogbG9nU2hhcGVbMV0gKiBsb2dTaGFwZVsyXSwgbG9nU2hhcGVbM11dO1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIGxvZ1NoYXBlLmxlbmd0aCA9PT0gNCAmJiBsb2dTaGFwZVswXSA8PSBtYXhUZXh0dXJlU2l6ZSAmJlxuICAgICAgICBsb2dTaGFwZVsxXSAqIGxvZ1NoYXBlWzJdICogbG9nU2hhcGVbM10gPD0gbWF4VGV4dHVyZVNpemUpIHtcbiAgICAgIHJldHVybiBbbG9nU2hhcGVbMF0sIGxvZ1NoYXBlWzFdICogbG9nU2hhcGVbMl0gKiBsb2dTaGFwZVszXV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpc1BhY2tlZCkge1xuICAgICAgICAvLyBGb3IgcGFja2VkIHRleHR1cmVzIHNpemUgZXF1YWxzIHRoZSBudW1iZXIgb2YgY2hhbm5lbHMgcmVxdWlyZWQgdG9cbiAgICAgICAgLy8gYWNjb21tb2RhdGUgdGhlIHRleHR1cmUgZGF0YS4gSG93ZXZlciBpbiBvcmRlciB0byBzcXVhcmlmeSBzdWNoIHRoYXRcbiAgICAgICAgLy8gaW5uZXIgZGltZW5zaW9ucyBzdGF5IGV2ZW4sIHdlIHJld3JpdGUgc2l6ZSB0byBlcXVhbCB0aGUgbnVtYmVyIG9mXG4gICAgICAgIC8vIHRleGVscy4gVGhlbiBpbiB0aGUgcmV0dXJuIHN0YXRlbWVudCB3ZSByZWh5ZHJhdGUgdGhlIHNxdWFyaWZpZWRcbiAgICAgICAgLy8gZGltZW5zaW9ucyB0byBjaGFubmVsIHVuaXRzLlxuICAgICAgICByZXR1cm4gc2l6ZVRvU3F1YXJpc2hTaGFwZShzaXplIC8gNCkubWFwKGQgPT4gZCAqIDIpIGFzIFtudW1iZXIsIG51bWJlcl07XG4gICAgICB9XG4gICAgICByZXR1cm4gc2l6ZVRvU3F1YXJpc2hTaGFwZShzaXplKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNxdWVlemVTaGFwZShzaGFwZTogbnVtYmVyW10sIGF4aXM/OiBudW1iZXJbXSk6IHtuZXdTaGFwZTogbnVtYmVyW107IGtlcHREaW1zOiBudW1iZXJbXX0ge1xuICBjb25zdCBuZXdTaGFwZTogbnVtYmVyW10gPSBbXTtcbiAgY29uc3Qga2VwdERpbXM6IG51bWJlcltdID0gW107XG4gIGNvbnN0IGlzRW1wdHlBcnJheSA9IGF4aXMgIT0gbnVsbCAmJiBBcnJheS5pc0FycmF5KGF4aXMpICYmIGF4aXMubGVuZ3RoID09PSAwO1xuICBjb25zdCBheGVzID0gKGF4aXMgPT0gbnVsbCB8fCBpc0VtcHR5QXJyYXkpID8gbnVsbCA6IHBhcnNlQXhpc1BhcmFtKGF4aXMsIHNoYXBlKS5zb3J0KCk7XG4gIGxldCBqID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaGFwZS5sZW5ndGg7ICsraSkge1xuICAgIGlmIChheGVzICE9IG51bGwpIHtcbiAgICAgIGlmIChheGVzW2pdID09PSBpICYmIHNoYXBlW2ldICE9PSAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2FuJ3Qgc3F1ZWV6ZSBheGlzICR7aX0gc2luY2UgaXRzIGRpbSAnJHtzaGFwZVtpXX0nIGlzIG5vdCAxYCk7XG4gICAgICB9XG4gICAgICBpZiAoKGF4ZXNbal0gPT0gbnVsbCB8fCBheGVzW2pdID4gaSkgJiYgc2hhcGVbaV0gPT09IDEpIHtcbiAgICAgICAgbmV3U2hhcGUucHVzaChzaGFwZVtpXSk7XG4gICAgICAgIGtlcHREaW1zLnB1c2goaSk7XG4gICAgICB9XG4gICAgICBpZiAoYXhlc1tqXSA8PSBpKSB7XG4gICAgICAgIGorKztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNoYXBlW2ldICE9PSAxKSB7XG4gICAgICBuZXdTaGFwZS5wdXNoKHNoYXBlW2ldKTtcbiAgICAgIGtlcHREaW1zLnB1c2goaSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB7bmV3U2hhcGUsIGtlcHREaW1zfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlQXhpc1BhcmFtKGF4aXM6IG51bWJlcnxudW1iZXJbXSwgc2hhcGU6IG51bWJlcltdKTogbnVtYmVyW10ge1xuICBjb25zdCByYW5rID0gc2hhcGUubGVuZ3RoO1xuXG4gIC8vIE5vcm1hbGl6ZSBpbnB1dFxuICBheGlzID0gYXhpcyA9PSBudWxsID8gc2hhcGUubWFwKChfcywgaSkgPT4gaSkgOiAoW10gYXMgbnVtYmVyW10pLmNvbmNhdChheGlzKTtcblxuICAvLyBDaGVjayBmb3IgdmFsaWQgcmFuZ2VcbiAgYXNzZXJ0KFxuICAgICAgYXhpcy5ldmVyeShheCA9PiBheCA+PSAtcmFuayAmJiBheCA8IHJhbmspLFxuICAgICAgKCkgPT4gYEFsbCB2YWx1ZXMgaW4gYXhpcyBwYXJhbSBtdXN0IGJlIGluIHJhbmdlIFstJHtyYW5rfSwgJHtyYW5rfSkgYnV0IGAgK1xuICAgICAgICAgIGBnb3QgYXhpcyAke2F4aXN9YCk7XG5cbiAgLy8gQ2hlY2sgZm9yIG9ubHkgaW50ZWdlcnNcbiAgYXNzZXJ0KFxuICAgICAgYXhpcy5ldmVyeShpc0ludCksXG4gICAgICAoKSA9PiAnQWxsIHZhbHVlcyBpbiBheGlzIHBhcmFtIG11c3QgYmUgaW50ZWdlcnMgYnV0ICcgK1xuICAgICAgICAgIGBnb3QgYXhpcyAke2F4aXN9YCk7XG5cbiAgLy8gSGFuZGxlIG5lZ2F0aXZlIGF4aXMuXG4gIHJldHVybiBheGlzLm1hcChhID0+IGEgPCAwID8gcmFuayArIGEgOiBhKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0ludChhOiBudW1iZXIpOiBib29sZWFuIHtcbiAgcmV0dXJuIGEgJSAxID09PSAwO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHNpemVGcm9tU2hhcGUoc2hhcGU6IG51bWJlcltdKTogbnVtYmVyIHtcbiAgaWYgKHNoYXBlLmxlbmd0aCA9PT0gMCkge1xuICAgIC8vIFNjYWxhci5cbiAgICByZXR1cm4gMTtcbiAgfVxuICBsZXQgc2l6ZSA9IHNoYXBlWzBdO1xuICBmb3IgKGxldCBpID0gMTsgaSA8IHNoYXBlLmxlbmd0aDsgaSsrKSB7XG4gICAgc2l6ZSAqPSBzaGFwZVtpXTtcbiAgfVxuICByZXR1cm4gc2l6ZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRSb3dzQ29scyhzaGFwZTogbnVtYmVyW10pOiBbbnVtYmVyLCBudW1iZXJdIHtcbiAgaWYgKHNoYXBlLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IEVycm9yKCdDYW5ub3QgZ2V0IHJvd3MgYW5kIGNvbHVtbnMgb2YgYW4gZW1wdHkgc2hhcGUgYXJyYXkuJyk7XG4gIH1cblxuICByZXR1cm4gW3NoYXBlLmxlbmd0aCA+IDEgPyBzaGFwZVtzaGFwZS5sZW5ndGggLSAyXSA6IDEsIHNoYXBlW3NoYXBlLmxlbmd0aCAtIDFdXTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzaXplVG9TcXVhcmlzaFNoYXBlKHNpemU6IG51bWJlcik6IFtudW1iZXIsIG51bWJlcl0ge1xuICBjb25zdCB3aWR0aCA9IE1hdGguY2VpbChNYXRoLnNxcnQoc2l6ZSkpO1xuICByZXR1cm4gW3dpZHRoLCBNYXRoLmNlaWwoc2l6ZSAvIHdpZHRoKV07XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0QmF0Y2hEaW0oc2hhcGU6IG51bWJlcltdLCBkaW1zVG9Ta2lwID0gMik6IG51bWJlciB7XG4gIHJldHVybiBzaXplRnJvbVNoYXBlKHNoYXBlLnNsaWNlKDAsIHNoYXBlLmxlbmd0aCAtIGRpbXNUb1NraXApKTtcbn1cbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtBcnJheVV0aWwsIEJyb2FkY2FzdFV0aWwsIFNoYXBlVXRpbH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5cbmltcG9ydCB7R2xzbENvbnRleHQsIEdsc2xMaWIsIEdsc2xMaWJSb3V0aW5lfSBmcm9tICcuL2dsc2wtZGVmaW5pdGlvbnMnO1xuaW1wb3J0IHtnZXRHbHNsfSBmcm9tICcuL2dsc2wtc291cmNlJztcbmltcG9ydCB7c3F1ZWV6ZVNoYXBlfSBmcm9tICcuL3RleHR1cmUtbGF5b3V0LXN0cmF0ZWd5JztcbmltcG9ydCB7VGV4dHVyZUxheW91dH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQge2dlbmVyYXRlU2hhZGVyRnVuY05hbWVGcm9tSW5wdXRTYW1wbGVyTmFtZSwgZ2VuZXJhdGVTaGFkZXJGdW5jTmFtZUZyb21JbnB1dFNhbXBsZXJOYW1lQXRPdXRDb29yZHMsIGdldENvb3Jkc0RhdGFUeXBlLCBnZXRHbENoYW5uZWxzLCBnZXRTcXVlZXplZFBhcmFtcywgc3F1ZWV6ZUlucHV0U2hhcGV9IGZyb20gJy4vdXRpbHMnO1xuXG4vKipcbiAqIEdMU0wgTGlicmFyeSByZXNwb25zaWJsZSBmb3IgZGF0YSB0eXBlcyBhbmQgcm91dGluZXMgZm9yIG1hbmlwdWxhdGluZ1xuICogY29vcmRpbmF0ZXMgYW5kIG1hcHBpbmcgdG8vZnJvbSB0ZW5zb3IgaW5kaWNlc1xuICovXG5leHBvcnQgY2xhc3MgQ29vcmRzR2xzbExpYiBleHRlbmRzIEdsc2xMaWIge1xuICByZXR1cm5UeXBlOiBzdHJpbmc7XG5cbiAgY29uc3RydWN0b3IoY29udGV4dDogR2xzbENvbnRleHQpIHtcbiAgICBzdXBlcihjb250ZXh0KTtcbiAgfVxuICBnZXRGdW5jdGlvbnMoKToge1tuYW1lOiBzdHJpbmddOiBHbHNsTGliUm91dGluZX0ge1xuICAgIHJldHVybiB7XG4gICAgICAuLi50aGlzLm9mZnNldFRvQ29vcmRzKCksXG4gICAgICAuLi50aGlzLmNvb3Jkc1RvT2Zmc2V0KCksXG4gICAgICAuLi50aGlzLnRvVmVjKCksXG4gICAgICAuLi50aGlzLnZhbHVlRnJvbSgpLFxuICAgICAgLy8gVE9ETyByZXR1cm4gdGhlc2Ugb25seSB3aGVuIHBhY2tpbmcgaXMgZW5hYmxlZC5cbiAgICAgIC4uLnRoaXMuZ2V0Q29tbW9uVXRpbEZ1bmNzKCksXG4gICAgICAuLi50aGlzLmdldElucHV0c1NhbXBsaW5nU25pcHBldHMoKSxcbiAgICAgIC4uLnRoaXMuZ2V0T3V0cHV0U2FtcGxpbmdTbmlwcGV0KClcbiAgICB9O1xuICB9XG4gIGdldEN1c3RvbVR5cGVzKCkge1xuICAgIHJldHVybiB7fTtcbiAgfVxuICAvKipcbiAgICogUHJvZHVjZXMgYSBmdW5jdGlvbiB0aGF0IGNhbiBtYXAgZnJvbVxuICAgKiAyRCBub3JtYWx6aWVkIGNvb3JkaW5hdGVzIChzLHQpIHRvIGEgZmxhdCBvZmZzZXRcbiAgICovXG4gIHByb3RlY3RlZCBvZmZzZXRUb0Nvb3JkcygpOiB7W25hbWU6IHN0cmluZ106IEdsc2xMaWJSb3V0aW5lfSB7XG4gICAgY29uc3QgZnVuY05hbWUgPSAnb2Zmc2V0VG9Db29yZHMnO1xuICAgIHJldHVybiB7XG4gICAgICBvZmZzZXRUb0Nvb3JkczogbmV3IEdsc2xMaWJSb3V0aW5lKGBcbiAgICAgIHZlYzIgJHtmdW5jTmFtZX0oaW50IG9mZnNldCwgaW50IHdpZHRoLCBpbnQgaGVpZ2h0KSB7XG4gICAgICAgIGludCB0ID0gb2Zmc2V0IC8gd2lkdGg7XG4gICAgICAgIGludCBzID0gb2Zmc2V0IC0gdCp3aWR0aDtcbiAgICAgICAgdmVjMiBjb29yZHMgPSAodmVjMihzLHQpICsgdmVjMigwLjUsMC41KSkgLyB2ZWMyKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICByZXR1cm4gY29vcmRzO1xuICAgICAgfVxuICAgICAgYClcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFByb2R1Y2VzIGEgZnVuY3Rpb24gdGhhdCBjYW4gbWFwIGZyb21cbiAgICogMkQgbm9ybWFsemllZCBjb29yZGluYXRlcyAocyx0KSB0byBhIGZsYXQgb2Zmc2V0XG4gICAqL1xuICBwcm90ZWN0ZWQgY29vcmRzVG9PZmZzZXQoKToge1tuYW1lOiBzdHJpbmddOiBHbHNsTGliUm91dGluZX0ge1xuICAgIGNvbnN0IGZ1bmNOYW1lID0gJ2Nvb3Jkc1RvT2Zmc2V0JztcbiAgICByZXR1cm4ge1xuICAgICAgY29vcmRzVG9PZmZzZXQ6IG5ldyBHbHNsTGliUm91dGluZShgXG4gICAgICBpbnQgJHtmdW5jTmFtZX0odmVjMiBjb29yZHMsIGludCB3aWR0aCwgaW50IGhlaWdodCkge1xuICAgICAgICBmbG9hdCBzID0gY29vcmRzLnMgKiBmbG9hdCh3aWR0aCk7XG4gICAgICAgIGZsb2F0IHQgPSBjb29yZHMudCAqIGZsb2F0KGhlaWdodCk7XG4gICAgICAgIGludCBvZmZzZXQgPSBpbnQodCkgKiB3aWR0aCArIGludChzKTtcbiAgICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICAgIH1cbiAgICAgIGApXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgY29kZSBmb3Igb3V0cHV0IHNhbXBsZXIuXG4gICAqL1xuXG4gIHByb3RlY3RlZCBnZXRPdXRwdXRTYW1wbGluZ1NuaXBwZXQoKToge1tuYW1lOiBzdHJpbmddOiBHbHNsTGliUm91dGluZX0ge1xuICAgIGNvbnN0IG91dHB1dExheW91dCA9IHRoaXMuY29udGV4dC5vdXRwdXRUZXh0dXJlTGF5b3V0O1xuICAgIGlmIChvdXRwdXRMYXlvdXQuaXNQYWNrZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFBhY2tlZE91dHB1dFNhbXBsaW5nU25pcHBldChvdXRwdXRMYXlvdXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRVbnBhY2tlZE91dHB1dFNhbXBsaW5nU25pcHBldChvdXRwdXRMYXlvdXQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgY29kZSBmb3IgcGFja2VkIG91dHB1dCBzYW1wbGVyLlxuICAgKi9cbiAgcHJvdGVjdGVkIGdldFBhY2tlZE91dHB1dFNhbXBsaW5nU25pcHBldChvdXRwdXRMYXlvdXQ6IFRleHR1cmVMYXlvdXQpOiB7W25hbWU6IHN0cmluZ106IEdsc2xMaWJSb3V0aW5lfSB7XG4gICAgY29uc3Qgb3V0U2hhcGUgPSBvdXRwdXRMYXlvdXQudW5wYWNrZWRTaGFwZTtcbiAgICBjb25zdCBvdXRUZXhTaGFwZSA9IFtvdXRwdXRMYXlvdXQud2lkdGgsIG91dHB1dExheW91dC5oZWlnaHRdO1xuICAgIGNvbnN0IHJlc3VsdDoge1tuYW1lOiBzdHJpbmddOiBHbHNsTGliUm91dGluZX0gPSB7fTtcbiAgICBjb25zdCBmdW5jTmFtZSA9ICdnZXRPdXRwdXRDb29yZHMnO1xuICAgIHN3aXRjaCAob3V0U2hhcGUubGVuZ3RoKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIHJlc3VsdFtmdW5jTmFtZV0gPSB0aGlzLmdldE91dHB1dFNjYWxhckNvb3JkcygpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgcmVzdWx0W2Z1bmNOYW1lXSA9IHRoaXMuZ2V0T3V0cHV0UGFja2VkMURDb29yZHMob3V0U2hhcGUgYXMgW251bWJlcl0sIG91dFRleFNoYXBlIGFzIFtudW1iZXIsIG51bWJlcl0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgcmVzdWx0W2Z1bmNOYW1lXSA9IHRoaXMuZ2V0T3V0cHV0UGFja2VkMkRDb29yZHMob3V0U2hhcGUgYXMgW251bWJlciwgbnVtYmVyXSwgb3V0VGV4U2hhcGUgYXMgW251bWJlciwgbnVtYmVyXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOlxuICAgICAgICByZXN1bHRbZnVuY05hbWVdID1cbiAgICAgICAgICAgIHRoaXMuZ2V0T3V0cHV0UGFja2VkM0RDb29yZHMob3V0U2hhcGUgYXMgW251bWJlciwgbnVtYmVyLCBudW1iZXJdLCBvdXRUZXhTaGFwZSBhcyBbbnVtYmVyLCBudW1iZXJdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXN1bHRbZnVuY05hbWVdID0gdGhpcy5nZXRPdXRwdXRQYWNrZWRORENvb3JkcyhvdXRTaGFwZSwgb3V0VGV4U2hhcGUgYXMgW251bWJlciwgbnVtYmVyXSk7XG4gICAgfVxuICAgIGNvbnN0IGdsc2wgPSBnZXRHbHNsKHRoaXMuY29udGV4dC5nbENvbnRleHQudmVyc2lvbik7XG4gICAgLy8gVE9ETyB3ZSBuZWVkIHRoaXMgdG8gcHJvcGVybHkgcmV0dXJuIGEgcGFja2VkIHZlYzQgZnJvbSBrZXJuZWxzLlxuICAgIC8vIFJlcGxhY2UgYWxsICd7Z2xzbC5vdXRwdXR9ID0gcmVzdWx0JyB3aXRoICdzZXRPdXRwdXQocmVzdWx0KScgaW4gYWxsIGtlcm5lbHMuXG4gICAgY29uc3QgZmxvYXRUZXh0dXJlU2V0UkdCQVNvdXJjZSA9IGBcbiAgICAgIHZvaWQgc2V0T3V0cHV0KHZlYzQgdmFsKSB7XG4gICAgICAgICR7Z2xzbC5vdXRwdXR9ID0gdmFsO1xuICAgICAgfVxuICAgIGA7XG4gICAgY29uc3QgZmxvYXRUZXh0dXJlU2V0UkdCQUZ1bmNOYW1lID0gJ2Zsb2F0VGV4dHVyZVNldFJHQkEnO1xuICAgIHJlc3VsdFtmbG9hdFRleHR1cmVTZXRSR0JBRnVuY05hbWVdID0gbmV3IEdsc2xMaWJSb3V0aW5lKGZsb2F0VGV4dHVyZVNldFJHQkFTb3VyY2UpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGVzIGNvZGUgZm9yIHVucGFja2VkIG91dHB1dCBzYW1wbGVyLlxuICAgKi9cbiAgcHJvdGVjdGVkIGdldFVucGFja2VkT3V0cHV0U2FtcGxpbmdTbmlwcGV0KG91dHB1dExheW91dDogVGV4dHVyZUxheW91dCk6IHtbbmFtZTogc3RyaW5nXTogR2xzbExpYlJvdXRpbmV9IHtcbiAgICBjb25zdCBvdXRTaGFwZSA9IG91dHB1dExheW91dC51bnBhY2tlZFNoYXBlO1xuICAgIGNvbnN0IG91dFRleFNoYXBlID0gW291dHB1dExheW91dC53aWR0aCwgb3V0cHV0TGF5b3V0LmhlaWdodF07XG4gICAgY29uc3QgcmVzdWx0OiB7W25hbWU6IHN0cmluZ106IEdsc2xMaWJSb3V0aW5lfSA9IHt9O1xuICAgIGNvbnN0IGZ1bmNOYW1lID0gJ2dldE91dHB1dENvb3Jkcyc7XG4gICAgc3dpdGNoIChvdXRTaGFwZS5sZW5ndGgpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgcmVzdWx0W2Z1bmNOYW1lXSA9IHRoaXMuZ2V0T3V0cHV0U2NhbGFyQ29vcmRzKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxOlxuICAgICAgICByZXN1bHRbZnVuY05hbWVdID0gdGhpcy5nZXRPdXRwdXRVbnBhY2tlZDFEQ29vcmRzKG91dFNoYXBlIGFzIFtudW1iZXJdLCBvdXRUZXhTaGFwZSBhcyBbbnVtYmVyLCBudW1iZXJdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIHJlc3VsdFtmdW5jTmFtZV0gPVxuICAgICAgICAgICAgdGhpcy5nZXRPdXRwdXRVbnBhY2tlZDJEQ29vcmRzKG91dFNoYXBlIGFzIFtudW1iZXIsIG51bWJlcl0sIG91dFRleFNoYXBlIGFzIFtudW1iZXIsIG51bWJlcl0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgcmVzdWx0W2Z1bmNOYW1lXSA9XG4gICAgICAgICAgICB0aGlzLmdldE91dHB1dFVucGFja2VkM0RDb29yZHMob3V0U2hhcGUgYXMgW251bWJlciwgbnVtYmVyLCBudW1iZXJdLCBvdXRUZXhTaGFwZSBhcyBbbnVtYmVyLCBudW1iZXJdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDQ6XG4gICAgICAgIHJlc3VsdFtmdW5jTmFtZV0gPSB0aGlzLmdldE91dHB1dFVucGFja2VkNERDb29yZHMoXG4gICAgICAgICAgICBvdXRTaGFwZSBhcyBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXSwgb3V0VGV4U2hhcGUgYXMgW251bWJlciwgbnVtYmVyXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA1OlxuICAgICAgICByZXN1bHRbZnVuY05hbWVdID0gdGhpcy5nZXRPdXRwdXRVbnBhY2tlZDVEQ29vcmRzKFxuICAgICAgICAgICAgb3V0U2hhcGUgYXMgW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXSwgb3V0VGV4U2hhcGUgYXMgW251bWJlciwgbnVtYmVyXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA2OlxuICAgICAgICByZXN1bHRbZnVuY05hbWVdID0gdGhpcy5nZXRPdXRwdXRVbnBhY2tlZDZEQ29vcmRzKFxuICAgICAgICAgICAgb3V0U2hhcGUgYXMgW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdLCBvdXRUZXhTaGFwZSBhcyBbbnVtYmVyLCBudW1iZXJdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIG91dHB1dCBkaW1lbnNpb25hbGl0eTogJHtvdXRTaGFwZS5sZW5ndGh9YCk7XG4gICAgfVxuICAgIGNvbnN0IGdsc2wgPSBnZXRHbHNsKHRoaXMuY29udGV4dC5nbENvbnRleHQudmVyc2lvbik7XG4gICAgLy8gVE9ETyB3ZSBuZWVkIHRoaXMgdG8gcHJvcGVybHkgcmV0dXJuIGEgcGFja2VkIHZlYzQgZnJvbSBrZXJuZWxzLlxuICAgIC8vIFJlcGxhY2UgYWxsICd7Z2xzbC5vdXRwdXR9ID0gcmVzdWx0JyB3aXRoICdzZXRPdXRwdXQocmVzdWx0KScgaW4gYWxsIGtlcm5lbHMuXG4gICAgY29uc3QgZmxvYXRUZXh0dXJlU2V0UlNvdXJjZSA9IGBcbiAgICAgICAgdm9pZCBzZXRPdXRwdXQoZmxvYXQgdmFsKSB7XG4gICAgICAgICAgJHtnbHNsLm91dHB1dH0gPSB2ZWM0KHZhbCwgMCwgMCwgMCk7XG4gICAgICAgIH1cbiAgICBgO1xuICAgIGNvbnN0IGZsb2F0VGV4dHVyZVNldFJGdW5jTmFtZSA9ICdmbG9hdFRleHR1cmVTZXRSJztcbiAgICByZXN1bHRbZmxvYXRUZXh0dXJlU2V0UkZ1bmNOYW1lXSA9IG5ldyBHbHNsTGliUm91dGluZShmbG9hdFRleHR1cmVTZXRSU291cmNlKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFNjYWxhciBvdXRwdXQgY29vcmRpbmF0ZXMuXG4gICAqL1xuICBwcm90ZWN0ZWQgZ2V0T3V0cHV0U2NhbGFyQ29vcmRzKCk6IEdsc2xMaWJSb3V0aW5lIHtcbiAgICByZXR1cm4gbmV3IEdsc2xMaWJSb3V0aW5lKGBcbiAgICAgIGludCBnZXRPdXRwdXRDb29yZHMoKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgIGApO1xuICB9XG5cbiAgLyoqXG4gICAqIDFEIHBhY2tlZCBvdXRwdXQgY29vcmRpbmF0ZXMuXG4gICAqL1xuICBwcm90ZWN0ZWQgZ2V0T3V0cHV0UGFja2VkMURDb29yZHMoX3NoYXBlOiBbbnVtYmVyXSwgdGV4U2hhcGU6IFtudW1iZXIsIG51bWJlcl0pOiBHbHNsTGliUm91dGluZSB7XG4gICAgY29uc3QgcGFja2VkVGV4U2hhcGUgPSB0ZXhTaGFwZTtcbiAgICBsZXQgc291cmNlID0gJyc7XG4gICAgaWYgKHBhY2tlZFRleFNoYXBlWzBdID09PSAxKSB7XG4gICAgICBzb3VyY2UgPSBgXG4gICAgICAgICAgaW50IGdldE91dHB1dENvb3JkcygpIHtcbiAgICAgICAgICAgIHJldHVybiAyICogaW50KFRleENvb3Jkcy55ICogJHtwYWNrZWRUZXhTaGFwZVsxXX0uMCk7XG4gICAgICAgICAgfVxuICAgICAgICBgO1xuICAgICAgcmV0dXJuIG5ldyBHbHNsTGliUm91dGluZShzb3VyY2UpO1xuICAgIH1cblxuICAgIGlmIChwYWNrZWRUZXhTaGFwZVsxXSA9PT0gMSkge1xuICAgICAgc291cmNlID0gYFxuICAgICAgICAgIGludCBnZXRPdXRwdXRDb29yZHMoKSB7XG4gICAgICAgICAgICByZXR1cm4gMiAqIGludChUZXhDb29yZHMueCAqICR7cGFja2VkVGV4U2hhcGVbMF19LjApO1xuICAgICAgICAgIH1cbiAgICAgICAgYDtcbiAgICAgIHJldHVybiBuZXcgR2xzbExpYlJvdXRpbmUoc291cmNlKTtcbiAgICB9XG5cbiAgICBzb3VyY2UgPSBgXG4gICAgICAgIGludCBnZXRPdXRwdXRDb29yZHMoKSB7XG4gICAgICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihUZXhDb29yZHMueHkgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMigke3BhY2tlZFRleFNoYXBlWzBdfSwgJHtwYWNrZWRUZXhTaGFwZVsxXX0pKTtcbiAgICAgICAgICByZXR1cm4gMiAqIChyZXNUZXhSQy55ICogJHtwYWNrZWRUZXhTaGFwZVswXX0gKyByZXNUZXhSQy54KTtcbiAgICAgICAgfVxuICAgICAgYDtcbiAgICByZXR1cm4gbmV3IEdsc2xMaWJSb3V0aW5lKHNvdXJjZSk7XG4gIH1cblxuICAvKipcbiAgICogMkQgcGFja2VkIG91dHB1dCBjb29yZGluYXRlcy5cbiAgICovXG4gIHByb3RlY3RlZCBnZXRPdXRwdXRQYWNrZWQyRENvb3JkcyhzaGFwZTogW251bWJlciwgbnVtYmVyXSwgdGV4U2hhcGU6IFtudW1iZXIsIG51bWJlcl0pOiBHbHNsTGliUm91dGluZSB7XG4gICAgbGV0IHNvdXJjZSA9ICcnO1xuICAgIGlmIChBcnJheVV0aWwuYXJyYXlzRXF1YWwoc2hhcGUsIHRleFNoYXBlKSkge1xuICAgICAgc291cmNlID0gYFxuICAgICAgICBpdmVjMiBnZXRPdXRwdXRDb29yZHMoKSB7XG4gICAgICAgICAgcmV0dXJuIDIgKiBpdmVjMihUZXhDb29yZHMueHkgKiB2ZWMyKCR7dGV4U2hhcGVbMF19LCAke3RleFNoYXBlWzFdfSkpO1xuICAgICAgICB9XG4gICAgICBgO1xuICAgICAgcmV0dXJuIG5ldyBHbHNsTGliUm91dGluZShzb3VyY2UpO1xuICAgIH1cblxuICAgIGNvbnN0IHBhY2tlZFRleFNoYXBlID0gdGV4U2hhcGU7XG4gICAgLy8gdGV4ZWxzIG5lZWRlZCB0byBhY2NvbW1vZGF0ZSBhIGxvZ2ljYWwgcm93XG4gICAgY29uc3QgdGV4ZWxzSW5Mb2dpY2FsUm93ID0gTWF0aC5jZWlsKHNoYXBlWzFdIC8gMik7XG5cbiAgICAvKipcbiAgICAgKiBnZXRPdXRwdXRDb29yZHNcbiAgICAgKlxuICAgICAqIHJlc1RleFJDOiBUaGUgcm93cyBhbmQgY29sdW1ucyBvZiB0aGUgdGV4ZWxzLiBJZiB5b3UgbW92ZSBvdmVyIG9uZVxuICAgICAqIHRleGVsIHRvIHRoZSByaWdodCBpbiB0aGUgcGFja2VkIHRleHR1cmUsIHlvdSBhcmUgbW92aW5nIG92ZXIgb25lIGNvbHVtblxuICAgICAqIChub3QgdHdvKS5cbiAgICAgKlxuICAgICAqIGluZGV4OiBUaGUgdGV4ZWwgaW5kZXhcbiAgICAgKi9cbiAgICBzb3VyY2UgPSBgXG4gICAgICAgIGl2ZWMyIGdldE91dHB1dENvb3JkcygpIHtcbiAgICAgICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKFRleENvb3Jkcy54eSAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoJHtwYWNrZWRUZXhTaGFwZVswXX0sICR7cGFja2VkVGV4U2hhcGVbMV19KSk7XG5cbiAgICAgICAgICBpbnQgaW5kZXggPSByZXNUZXhSQy55ICogJHtwYWNrZWRUZXhTaGFwZVswXX0gKyByZXNUZXhSQy54O1xuXG4gICAgICAgICAgLy8gcmV2ZXJzZSByIGFuZCBjIG9yZGVyIGZvciBwYWNrZWQgdGV4dHVyZVxuICAgICAgICAgIGludCByID0gaW1vZChpbmRleCwgJHt0ZXhlbHNJbkxvZ2ljYWxSb3d9KSAqIDI7XG4gICAgICAgICAgaW50IGMgPSAyICogKGluZGV4IC8gJHt0ZXhlbHNJbkxvZ2ljYWxSb3d9KTtcblxuICAgICAgICAgIHJldHVybiBpdmVjMihyLCBjKTtcbiAgICAgICAgfVxuICAgICAgYDtcbiAgICByZXR1cm4gbmV3IEdsc2xMaWJSb3V0aW5lKHNvdXJjZSk7XG4gIH1cblxuICAvKipcbiAgICogM0QgcGFja2VkIG91dHB1dCBjb29yZGluYXRlcy5cbiAgICovXG4gIHByb3RlY3RlZCBnZXRPdXRwdXRQYWNrZWQzRENvb3JkcyhzaGFwZTogW251bWJlciwgbnVtYmVyLCBudW1iZXJdLCB0ZXhTaGFwZTogW251bWJlciwgbnVtYmVyXSk6IEdsc2xMaWJSb3V0aW5lIHtcbiAgICBjb25zdCBwYWNrZWRUZXhTaGFwZSA9IFt0ZXhTaGFwZVswXSwgdGV4U2hhcGVbMV1dO1xuICAgIGNvbnN0IHRleGVsc0luTG9naWNhbFJvdyA9IE1hdGguY2VpbChzaGFwZVsyXSAvIDIpO1xuICAgIGNvbnN0IHRleGVsc0luQmF0Y2ggPSB0ZXhlbHNJbkxvZ2ljYWxSb3cgKiBNYXRoLmNlaWwoc2hhcGVbMV0gLyAyKTtcbiAgICBjb25zdCBzb3VyY2UgPSBgXG4gICAgICAgIGl2ZWMzIGdldE91dHB1dENvb3JkcygpIHtcbiAgICAgICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKFRleENvb3Jkcy54eSAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoJHtwYWNrZWRUZXhTaGFwZVswXX0sICR7cGFja2VkVGV4U2hhcGVbMV19KSk7XG4gICAgICAgICAgaW50IGluZGV4ID0gcmVzVGV4UkMueSAqICR7cGFja2VkVGV4U2hhcGVbMF19ICsgcmVzVGV4UkMueDtcblxuICAgICAgICAgIGludCBiID0gaW5kZXggLyAke3RleGVsc0luQmF0Y2h9O1xuICAgICAgICAgIGluZGV4IC09IGIgKiAke3RleGVsc0luQmF0Y2h9O1xuXG4gICAgICAgICAgLy8gcmV2ZXJzZSByIGFuZCBjIG9yZGVyIGZvciBwYWNrZWQgdGV4dHVyZVxuICAgICAgICAgIGludCByID0gaW1vZChpbmRleCwgJHt0ZXhlbHNJbkxvZ2ljYWxSb3d9KSAqIDI7XG4gICAgICAgICAgaW50IGMgPSAyICogKGluZGV4IC8gJHt0ZXhlbHNJbkxvZ2ljYWxSb3d9KTtcblxuICAgICAgICAgIHJldHVybiBpdmVjMyhiLCByLCBjKTtcbiAgICAgICAgfVxuICAgICAgYDtcbiAgICByZXR1cm4gbmV3IEdsc2xMaWJSb3V0aW5lKHNvdXJjZSk7XG4gIH1cblxuICAvKipcbiAgICogTkQgcGFja2VkIG91dHB1dCBjb29yZGluYXRlcy5cbiAgICovXG4gIHByb3RlY3RlZCBnZXRPdXRwdXRQYWNrZWRORENvb3JkcyhzaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sIHRleFNoYXBlOiBbbnVtYmVyLCBudW1iZXJdKTogR2xzbExpYlJvdXRpbmUge1xuICAgIGNvbnN0IHBhY2tlZFRleFNoYXBlID0gW3RleFNoYXBlWzBdLCB0ZXhTaGFwZVsxXV07XG5cbiAgICBjb25zdCB0ZXhlbHNJbkxvZ2ljYWxSb3cgPSBNYXRoLmNlaWwoc2hhcGVbc2hhcGUubGVuZ3RoIC0gMV0gLyAyKTtcbiAgICBjb25zdCB0ZXhlbHNJbkJhdGNoID0gdGV4ZWxzSW5Mb2dpY2FsUm93ICogTWF0aC5jZWlsKHNoYXBlW3NoYXBlLmxlbmd0aCAtIDJdIC8gMik7XG4gICAgbGV0IHRleGVsc0luQmF0Y2hOID0gdGV4ZWxzSW5CYXRjaDtcbiAgICBsZXQgYmF0Y2hlcyA9ICcnO1xuICAgIGxldCBjb29yZHMgPSAnYiwgciwgYyc7XG5cbiAgICBmb3IgKGxldCBiID0gMjsgYiA8IHNoYXBlLmxlbmd0aCAtIDE7IGIrKykge1xuICAgICAgdGV4ZWxzSW5CYXRjaE4gKj0gc2hhcGVbc2hhcGUubGVuZ3RoIC0gYiAtIDFdO1xuICAgICAgYmF0Y2hlcyA9IGBcbiAgICAgIGludCBiJHtifSA9IGluZGV4IC8gJHt0ZXhlbHNJbkJhdGNoTn07XG4gICAgICBpbmRleCAtPSBiJHtifSAqICR7dGV4ZWxzSW5CYXRjaE59O1xuICAgIGAgKyBiYXRjaGVzO1xuICAgICAgY29vcmRzID0gYGIke2J9LCBgICsgY29vcmRzO1xuICAgIH1cbiAgICBjb25zdCBzb3VyY2UgPSBgXG4gICAgICBpdmVjJHtzaGFwZS5sZW5ndGh9IGdldE91dHB1dENvb3JkcygpIHtcbiAgICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihUZXhDb29yZHMueHkgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMigke3BhY2tlZFRleFNoYXBlWzBdfSwgJHtwYWNrZWRUZXhTaGFwZVsxXX0pKTtcbiAgICAgICAgaW50IGluZGV4ID0gcmVzVGV4UkMueSAqICR7cGFja2VkVGV4U2hhcGVbMF19ICsgcmVzVGV4UkMueDtcblxuICAgICAgICAke2JhdGNoZXN9XG5cbiAgICAgICAgaW50IGIgPSBpbmRleCAvICR7dGV4ZWxzSW5CYXRjaH07XG4gICAgICAgIGluZGV4IC09IGIgKiAke3RleGVsc0luQmF0Y2h9O1xuXG4gICAgICAgIC8vIHJldmVyc2UgciBhbmQgYyBvcmRlciBmb3IgcGFja2VkIHRleHR1cmVcbiAgICAgICAgaW50IHIgPSBpbW9kKGluZGV4LCAke3RleGVsc0luTG9naWNhbFJvd30pICogMjtcbiAgICAgICAgaW50IGMgPSAyICogKGluZGV4IC8gJHt0ZXhlbHNJbkxvZ2ljYWxSb3d9KTtcblxuICAgICAgICByZXR1cm4gaXZlYyR7c2hhcGUubGVuZ3RofSgke2Nvb3Jkc30pO1xuICAgICAgfVxuICAgIGA7XG4gICAgcmV0dXJuIG5ldyBHbHNsTGliUm91dGluZShzb3VyY2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVucGFja2VkIDFEIG91dHB1dCBjb29yZGluYXRlcy5cbiAgICovXG4gIHByb3RlY3RlZCBnZXRPdXRwdXRVbnBhY2tlZDFEQ29vcmRzKF9zaGFwZTogW251bWJlcl0sIHRleFNoYXBlOiBbbnVtYmVyLCBudW1iZXJdKTogR2xzbExpYlJvdXRpbmUge1xuICAgIGNvbnN0IHNvdXJjZSA9IGBcbiAgICAgICAgaW50IGdldE91dHB1dENvb3JkcygpIHtcbiAgICAgICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKFRleENvb3Jkcy54eSAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoJHt0ZXhTaGFwZVswXX0sICR7dGV4U2hhcGVbMV19KSk7XG4gICAgICAgICAgcmV0dXJuIHJlc1RleFJDLnkgKiAke3RleFNoYXBlWzBdfSArIHJlc1RleFJDLng7XG4gICAgICAgIH1cbiAgICAgIGA7XG4gICAgcmV0dXJuIG5ldyBHbHNsTGliUm91dGluZShzb3VyY2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVucGFja2VkIDJEIG91dHB1dCBjb29yZGluYXRlcy5cbiAgICovXG4gIHByb3RlY3RlZCBnZXRPdXRwdXRVbnBhY2tlZDJEQ29vcmRzKHNoYXBlOiBbbnVtYmVyLCBudW1iZXJdLCB0ZXhTaGFwZTogW251bWJlciwgbnVtYmVyXSk6IEdsc2xMaWJSb3V0aW5lIHtcbiAgICBjb25zdCBzb3VyY2UgPSBgXG4gICAgICAgIGl2ZWMyIGdldE91dHB1dENvb3JkcygpIHtcbiAgICAgICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKFRleENvb3Jkcy54eSAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoJHt0ZXhTaGFwZVswXX0sICR7dGV4U2hhcGVbMV19KSk7XG4gICAgICAgICAgaW50IGluZGV4ID0gcmVzVGV4UkMueSAqICR7dGV4U2hhcGVbMF19ICsgcmVzVGV4UkMueDtcbiAgICAgICAgICBpbnQgciA9IGluZGV4IC8gJHtzaGFwZVsxXX07XG4gICAgICAgICAgaW50IGMgPSBpbmRleCAtIHIgKiAke3NoYXBlWzFdfTtcbiAgICAgICAgICByZXR1cm4gaXZlYzIociwgYyk7XG4gICAgICAgIH1cbiAgICAgIGA7XG4gICAgcmV0dXJuIG5ldyBHbHNsTGliUm91dGluZShzb3VyY2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVucGFja2VkIDNEIG91dHB1dCBjb29yZGluYXRlcy5cbiAgICovXG4gIHByb3RlY3RlZCBnZXRPdXRwdXRVbnBhY2tlZDNEQ29vcmRzKHNoYXBlOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sIHRleFNoYXBlOiBbbnVtYmVyLCBudW1iZXJdKTogR2xzbExpYlJvdXRpbmUge1xuICAgIGxldCBzb3VyY2UgPSAnJztcbiAgICBjb25zdCByYW5rID0gc2hhcGUubGVuZ3RoO1xuXG4gICAgbGV0IHN0cmlkZXMgPSBudWxsO1xuICAgIGlmIChyYW5rIDwgMikge1xuICAgICAgc3RyaWRlcyA9IFtdO1xuICAgIH1cblxuICAgIHN0cmlkZXMgPSBuZXcgQXJyYXkocmFuayAtIDEpO1xuICAgIHN0cmlkZXNbcmFuayAtIDJdID0gc2hhcGVbcmFuayAtIDFdO1xuICAgIGZvciAobGV0IGkgPSByYW5rIC0gMzsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHN0cmlkZXNbaV0gPSBzdHJpZGVzW2kgKyAxXSAqIHNoYXBlW2kgKyAxXTtcbiAgICB9XG4gICAgY29uc3QgY29vcmRzVG9Db21wdXRlID0gWydyJywgJ2MnLCAnZCddO1xuICAgIGNvbnN0IGNvb3Jkc0Zyb21JbmRleFNuaXBwZXQgPVxuICAgICAgICBzdHJpZGVzXG4gICAgICAgICAgICAubWFwKChzdHJpZGUsIGkpID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgbGluZTEgPSBgaW50ICR7Y29vcmRzVG9Db21wdXRlW2ldfSA9IGluZGV4IC8gJHtzdHJpZGV9YDtcbiAgICAgICAgICAgICAgY29uc3QgbGluZTIgPSBpID09PSBzdHJpZGVzLmxlbmd0aCAtIDEgP1xuICAgICAgICAgICAgICAgICAgYGludCAke2Nvb3Jkc1RvQ29tcHV0ZVtpICsgMV19ID0gaW5kZXggLSAke2Nvb3Jkc1RvQ29tcHV0ZVtpXX0gKiAke3N0cmlkZX1gIDpcbiAgICAgICAgICAgICAgICAgIGBpbmRleCAtPSAke2Nvb3Jkc1RvQ29tcHV0ZVtpXX0gKiAke3N0cmlkZX1gO1xuICAgICAgICAgICAgICByZXR1cm4gYCR7bGluZTF9OyAke2xpbmUyfTtgO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5qb2luKCcnKTtcblxuICAgIHNvdXJjZSA9IGBcbiAgICAgICAgaXZlYzMgZ2V0T3V0cHV0Q29vcmRzKCkge1xuICAgICAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIoVGV4Q29vcmRzLnh5ICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMigke3RleFNoYXBlWzBdfSwgJHt0ZXhTaGFwZVsxXX0pKTtcbiAgICAgICAgICBpbnQgaW5kZXggPSByZXNUZXhSQy55ICogJHt0ZXhTaGFwZVswXX0gKyByZXNUZXhSQy54O1xuICAgICAgICAgICR7Y29vcmRzRnJvbUluZGV4U25pcHBldH1cbiAgICAgICAgICByZXR1cm4gaXZlYzMociwgYywgZCk7XG4gICAgICAgIH1cbiAgICAgIGA7XG4gICAgcmV0dXJuIG5ldyBHbHNsTGliUm91dGluZShzb3VyY2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVucGFja2VkIDREIG91dHB1dCBjb29yZGluYXRlcy5cbiAgICovXG4gIHByb3RlY3RlZCBnZXRPdXRwdXRVbnBhY2tlZDREQ29vcmRzKHNoYXBlOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXSwgdGV4U2hhcGU6IFtudW1iZXIsIG51bWJlcl0pOlxuICAgICAgR2xzbExpYlJvdXRpbmUge1xuICAgIGxldCBzb3VyY2UgPSAnJztcbiAgICBjb25zdCByYW5rID0gc2hhcGUubGVuZ3RoO1xuXG4gICAgbGV0IHN0cmlkZXMgPSBudWxsO1xuICAgIGlmIChyYW5rIDwgMikge1xuICAgICAgc3RyaWRlcyA9IFtdO1xuICAgIH1cblxuICAgIHN0cmlkZXMgPSBuZXcgQXJyYXkocmFuayAtIDEpO1xuICAgIHN0cmlkZXNbcmFuayAtIDJdID0gc2hhcGVbcmFuayAtIDFdO1xuICAgIGZvciAobGV0IGkgPSByYW5rIC0gMzsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHN0cmlkZXNbaV0gPSBzdHJpZGVzW2kgKyAxXSAqIHNoYXBlW2kgKyAxXTtcbiAgICB9XG4gICAgY29uc3QgY29vcmRzVG9Db21wdXRlID0gWydyJywgJ2MnLCAnZCcsICdkMiddO1xuICAgIGNvbnN0IGNvb3Jkc0Zyb21JbmRleFNuaXBwZXQgPVxuICAgICAgICBzdHJpZGVzXG4gICAgICAgICAgICAubWFwKChzdHJpZGUsIGkpID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgbGluZTEgPSBgaW50ICR7Y29vcmRzVG9Db21wdXRlW2ldfSA9IGluZGV4IC8gJHtzdHJpZGV9YDtcbiAgICAgICAgICAgICAgY29uc3QgbGluZTIgPSBpID09PSBzdHJpZGVzLmxlbmd0aCAtIDEgP1xuICAgICAgICAgICAgICAgICAgYGludCAke2Nvb3Jkc1RvQ29tcHV0ZVtpICsgMV19ID0gaW5kZXggLSAke2Nvb3Jkc1RvQ29tcHV0ZVtpXX0gKiAke3N0cmlkZX1gIDpcbiAgICAgICAgICAgICAgICAgIGBpbmRleCAtPSAke2Nvb3Jkc1RvQ29tcHV0ZVtpXX0gKiAke3N0cmlkZX1gO1xuICAgICAgICAgICAgICByZXR1cm4gYCR7bGluZTF9OyAke2xpbmUyfTtgO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5qb2luKCcnKTtcblxuICAgIHNvdXJjZSA9IGBcbiAgICAgIGl2ZWM0IGdldE91dHB1dENvb3JkcygpIHtcbiAgICAgICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKFRleENvb3Jkcy54eSAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoJHt0ZXhTaGFwZVswXX0sICR7dGV4U2hhcGVbMV19KSk7XG4gICAgICAgICAgaW50IGluZGV4ID0gcmVzVGV4UkMueSAqICR7dGV4U2hhcGVbMF19ICsgcmVzVGV4UkMueDtcbiAgICAgICAgICAke2Nvb3Jkc0Zyb21JbmRleFNuaXBwZXR9XG4gICAgICAgICAgcmV0dXJuIGl2ZWM0KHIsIGMsIGQsIGQyKTtcbiAgICAgICAgfVxuICAgICAgYDtcbiAgICByZXR1cm4gbmV3IEdsc2xMaWJSb3V0aW5lKHNvdXJjZSk7XG4gIH1cblxuICAvKipcbiAgICogVW5wYWNrZWQgNUQgb3V0cHV0IGNvb3JkaW5hdGVzLlxuICAgKi9cbiAgcHJvdGVjdGVkIGdldE91dHB1dFVucGFja2VkNURDb29yZHMoc2hhcGU6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sIHRleFNoYXBlOiBbbnVtYmVyLCBudW1iZXJdKTpcbiAgICAgIEdsc2xMaWJSb3V0aW5lIHtcbiAgICBsZXQgc291cmNlID0gJyc7XG4gICAgY29uc3QgcmFuayA9IHNoYXBlLmxlbmd0aDtcblxuICAgIGxldCBzdHJpZGVzID0gbnVsbDtcbiAgICBpZiAocmFuayA8IDIpIHtcbiAgICAgIHN0cmlkZXMgPSBbXTtcbiAgICB9XG5cbiAgICBzdHJpZGVzID0gbmV3IEFycmF5KHJhbmsgLSAxKTtcbiAgICBzdHJpZGVzW3JhbmsgLSAyXSA9IHNoYXBlW3JhbmsgLSAxXTtcbiAgICBmb3IgKGxldCBpID0gcmFuayAtIDM7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBzdHJpZGVzW2ldID0gc3RyaWRlc1tpICsgMV0gKiBzaGFwZVtpICsgMV07XG4gICAgfVxuICAgIGNvbnN0IGNvb3Jkc1RvQ29tcHV0ZSA9IFsncicsICdjJywgJ2QnLCAnZDInLCAnZDMnXTtcbiAgICBjb25zdCBjb29yZHNGcm9tSW5kZXhTbmlwcGV0ID1cbiAgICAgICAgc3RyaWRlc1xuICAgICAgICAgICAgLm1hcCgoc3RyaWRlLCBpKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IGxpbmUxID0gYGludCAke2Nvb3Jkc1RvQ29tcHV0ZVtpXX0gPSBpbmRleCAvICR7c3RyaWRlfWA7XG4gICAgICAgICAgICAgIGNvbnN0IGxpbmUyID0gaSA9PT0gc3RyaWRlcy5sZW5ndGggLSAxID9cbiAgICAgICAgICAgICAgICAgIGBpbnQgJHtjb29yZHNUb0NvbXB1dGVbaSArIDFdfSA9IGluZGV4IC0gJHtjb29yZHNUb0NvbXB1dGVbaV19ICogJHtzdHJpZGV9YCA6XG4gICAgICAgICAgICAgICAgICBgaW5kZXggLT0gJHtjb29yZHNUb0NvbXB1dGVbaV19ICogJHtzdHJpZGV9YDtcbiAgICAgICAgICAgICAgcmV0dXJuIGAke2xpbmUxfTsgJHtsaW5lMn07YDtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuam9pbignJyk7XG5cbiAgICBzb3VyY2UgPSBgXG4gICAgICBpdmVjNSBnZXRPdXRwdXRDb29yZHMoKSB7XG4gICAgICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihUZXhDb29yZHMueHkgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWMyKCR7dGV4U2hhcGVbMF19LCAke3RleFNoYXBlWzFdfSkpO1xuICAgICAgICAgIGludCBpbmRleCA9IHJlc1RleFJDLnkgKiAke3RleFNoYXBlWzBdfSArIHJlc1RleFJDLng7XG4gICAgICAgICAgJHtjb29yZHNGcm9tSW5kZXhTbmlwcGV0fVxuICAgICAgICAgIHJldHVybiBpdmVjNShyLCBjLCBkLCBkMiwgZDMpO1xuICAgICAgICB9XG4gICAgICBgO1xuICAgIHJldHVybiBuZXcgR2xzbExpYlJvdXRpbmUoc291cmNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVbnBhY2tlZCA2RCBvdXRwdXQgY29vcmRpbmF0ZXMuXG4gICAqL1xuICBwcm90ZWN0ZWQgZ2V0T3V0cHV0VW5wYWNrZWQ2RENvb3JkcyhzaGFwZTogW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdLCB0ZXhTaGFwZTogW1xuICAgIG51bWJlciwgbnVtYmVyXG4gIF0pOiBHbHNsTGliUm91dGluZSB7XG4gICAgbGV0IHNvdXJjZSA9ICcnO1xuICAgIGNvbnN0IHJhbmsgPSBzaGFwZS5sZW5ndGg7XG5cbiAgICBsZXQgc3RyaWRlcyA9IG51bGw7XG4gICAgaWYgKHJhbmsgPCAyKSB7XG4gICAgICBzdHJpZGVzID0gW107XG4gICAgfVxuXG4gICAgc3RyaWRlcyA9IG5ldyBBcnJheShyYW5rIC0gMSk7XG4gICAgc3RyaWRlc1tyYW5rIC0gMl0gPSBzaGFwZVtyYW5rIC0gMV07XG4gICAgZm9yIChsZXQgaSA9IHJhbmsgLSAzOyBpID49IDA7IC0taSkge1xuICAgICAgc3RyaWRlc1tpXSA9IHN0cmlkZXNbaSArIDFdICogc2hhcGVbaSArIDFdO1xuICAgIH1cbiAgICBjb25zdCBjb29yZHNUb0NvbXB1dGUgPSBbJ3InLCAnYycsICdkJywgJ2QyJywgJ2QzJywgJ2Q0J107XG4gICAgY29uc3QgY29vcmRzRnJvbUluZGV4U25pcHBldCA9XG4gICAgICAgIHN0cmlkZXNcbiAgICAgICAgICAgIC5tYXAoKHN0cmlkZSwgaSkgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBsaW5lMSA9IGBpbnQgJHtjb29yZHNUb0NvbXB1dGVbaV19ID0gaW5kZXggLyAke3N0cmlkZX1gO1xuICAgICAgICAgICAgICBjb25zdCBsaW5lMiA9IGkgPT09IHN0cmlkZXMubGVuZ3RoIC0gMSA/XG4gICAgICAgICAgICAgICAgICBgaW50ICR7Y29vcmRzVG9Db21wdXRlW2kgKyAxXX0gPSBpbmRleCAtICR7Y29vcmRzVG9Db21wdXRlW2ldfSAqICR7c3RyaWRlfWAgOlxuICAgICAgICAgICAgICAgICAgYGluZGV4IC09ICR7Y29vcmRzVG9Db21wdXRlW2ldfSAqICR7c3RyaWRlfWA7XG4gICAgICAgICAgICAgIHJldHVybiBgJHtsaW5lMX07ICR7bGluZTJ9O2A7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmpvaW4oJycpO1xuXG4gICAgc291cmNlID0gYFxuICAgICBpdmVjNiBnZXRPdXRwdXRDb29yZHMoKSB7XG4gICAgICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKFRleENvb3Jkcy54eSAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMigke3RleFNoYXBlWzBdfSwgJHt0ZXhTaGFwZVsxXX0pKTtcbiAgICAgICAgIGludCBpbmRleCA9IHJlc1RleFJDLnkgKiAke3RleFNoYXBlWzBdfSArIHJlc1RleFJDLng7XG4gICAgICAgICAke2Nvb3Jkc0Zyb21JbmRleFNuaXBwZXR9XG4gICAgICAgICByZXR1cm4gaXZlYzYociwgYywgZCwgZDIsIGQzLCBkNCk7XG4gICAgICAgfVxuICAgICBgO1xuICAgIHJldHVybiBuZXcgR2xzbExpYlJvdXRpbmUoc291cmNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgY29kZSBmb3IgY29tbW9uIFVWIGNvb3JkcyBjb21wdXRhdGlvbiB1dGlsaXR5IGZ1bmN0aW9ucy5cbiAgICovXG4gIHByb3RlY3RlZCBnZXRDb21tb25VdGlsRnVuY3MoKToge1tuYW1lOiBzdHJpbmddOiBHbHNsTGliUm91dGluZX0ge1xuICAgIGNvbnN0IHJlc3VsdDoge1tuYW1lOiBzdHJpbmddOiBHbHNsTGliUm91dGluZX0gPSB7fTtcbiAgICBsZXQgZnVuY05hbWUgPSAndXZGcm9tRmxhdCc7XG4gICAgcmVzdWx0W2Z1bmNOYW1lXSA9IG5ldyBHbHNsTGliUm91dGluZShgXG4gICAgdmVjMiB1dkZyb21GbGF0KGludCB0ZXhOdW1SLCBpbnQgdGV4TnVtQywgaW50IGluZGV4KSB7XG4gICAgICBpbnQgdGV4QyA9IGluZGV4IC8gdGV4TnVtUjtcbiAgICAgIGludCB0ZXhSID0gaW5kZXggLSB0ZXhDICogdGV4TnVtUjtcbiAgICAgIC8vIFRPRE86IHN3YXAgdGV4UiwgdGV4QyBvcmRlciBpbiBmb2xsb3dpbmcgZnVuY3Rpb24gc28gcm93IGlzIGNvcnJlc3BvbmRpbmcgdG8gdSBhbmQgY29sdW1uIGlzIGNvcnJlc3BvbmRpbmcgdG9cbiAgICAgIC8vICAgICAgIHYuXG4gICAgICByZXR1cm4gKHZlYzIodGV4UiwgdGV4QykgKyBoYWxmQ1IpIC8gdmVjMih0ZXhOdW1SLCB0ZXhOdW1DKTtcbiAgICB9XG4gICAgYCk7XG4gICAgZnVuY05hbWUgPSAncGFja2VkVVZmcm9tMUQnO1xuICAgIHJlc3VsdFtmdW5jTmFtZV0gPSBuZXcgR2xzbExpYlJvdXRpbmUoYFxuICAgICAgdmVjMiBwYWNrZWRVVmZyb20xRChpbnQgdGV4TnVtUiwgaW50IHRleE51bUMsIGludCBpbmRleCkge1xuICAgICAgICBpbnQgdGV4ZWxJbmRleCA9IGluZGV4IC8gMjtcbiAgICAgICAgaW50IHRleFIgPSB0ZXhlbEluZGV4IC8gdGV4TnVtQztcbiAgICAgICAgaW50IHRleEMgPSB0ZXhlbEluZGV4IC0gdGV4UiAqIHRleE51bUM7XG4gICAgICAgIHJldHVybiAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgLyB2ZWMyKHRleE51bUMsIHRleE51bVIpO1xuICAgICAgfVxuICAgICAgYCk7XG4gICAgZnVuY05hbWUgPSAncGFja2VkVVZmcm9tMkQnO1xuICAgIHJlc3VsdFtmdW5jTmFtZV0gPSBuZXcgR2xzbExpYlJvdXRpbmUoYFxuICAgICAgdmVjMiBwYWNrZWRVVmZyb20yRChpbnQgdGV4TnVtUiwgaW50IHRleE51bUMsIGludCB0ZXhlbHNJbkxvZ2ljYWxSb3csIGludCByb3csIGludCBjb2wpIHtcbiAgICAgICAgaW50IHRleGVsSW5kZXggPSAocm93IC8gMikgKiB0ZXhlbHNJbkxvZ2ljYWxSb3cgKyAoY29sIC8gMik7XG4gICAgICAgIGludCB0ZXhSID0gdGV4ZWxJbmRleCAvIHRleE51bUM7XG4gICAgICAgIGludCB0ZXhDID0gdGV4ZWxJbmRleCAtIHRleFIgKiB0ZXhOdW1DO1xuICAgICAgICByZXR1cm4gKHZlYzIodGV4QywgdGV4UikgKyBoYWxmQ1IpIC8gdmVjMih0ZXhOdW1DLCB0ZXhOdW1SKTtcbiAgICAgIH1cbiAgICAgIGApO1xuICAgIGZ1bmNOYW1lID0gJ3BhY2tlZFVWZnJvbTNEJztcbiAgICByZXN1bHRbZnVuY05hbWVdID0gbmV3IEdsc2xMaWJSb3V0aW5lKGBcbiAgICAgIHZlYzIgcGFja2VkVVZmcm9tM0QoaW50IHRleE51bVIsIGludCB0ZXhOdW1DLFxuICAgICAgICAgIGludCB0ZXhlbHNJbkJhdGNoLCBpbnQgdGV4ZWxzSW5Mb2dpY2FsUm93LCBpbnQgYixcbiAgICAgICAgICBpbnQgcm93LCBpbnQgY29sKSB7XG4gICAgICAgIGludCBpbmRleCA9IGIgKiB0ZXhlbHNJbkJhdGNoICsgKHJvdyAvIDIpICogdGV4ZWxzSW5Mb2dpY2FsUm93ICsgKGNvbCAvIDIpO1xuICAgICAgICBpbnQgdGV4UiA9IGluZGV4IC8gdGV4TnVtQztcbiAgICAgICAgaW50IHRleEMgPSBpbmRleCAtIHRleFIgKiB0ZXhOdW1DO1xuICAgICAgICByZXR1cm4gKHZlYzIodGV4QywgdGV4UikgKyBoYWxmQ1IpIC8gdmVjMih0ZXhOdW1DLCB0ZXhOdW1SKTtcbiAgICAgIH1cbiAgICAgIGApO1xuICAgIGZ1bmNOYW1lID0gJ3NhbXBsZVRleHR1cmUnO1xuICAgIGNvbnN0IGdsc2wgPSBnZXRHbHNsKHRoaXMuY29udGV4dC5nbENvbnRleHQudmVyc2lvbik7XG4gICAgcmVzdWx0W2Z1bmNOYW1lXSA9IG5ldyBHbHNsTGliUm91dGluZShgXG4gICAgICAgIGZsb2F0IHNhbXBsZVRleHR1cmUoc2FtcGxlcjJEIHRleHR1cmVTYW1wbGVyLCB2ZWMyIHV2KSB7XG4gICAgICAgICAgICByZXR1cm4gJHtnbHNsLnRleHR1cmUyRH0odGV4dHVyZVNhbXBsZXIsIHV2KS5yO1xuICAgICAgICB9YCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3Rpbmcgc25pcHBldHMgZm9yIGlucHV0c1xuICAgKi9cbiAgcHJvdGVjdGVkIGdldElucHV0c1NhbXBsaW5nU25pcHBldHMoKToge1tuYW1lOiBzdHJpbmddOiBHbHNsTGliUm91dGluZX0ge1xuICAgIGNvbnN0IHJlc3VsdDoge1tuYW1lOiBzdHJpbmddOiBHbHNsTGliUm91dGluZX0gPSB7fTtcbiAgICBjb25zdCBvdXRwdXRMYXlvdXQgPSB0aGlzLmNvbnRleHQub3V0cHV0VGV4dHVyZUxheW91dDtcbiAgICB0aGlzLmNvbnRleHQucHJvZ3JhbUluZm8uaW5wdXROYW1lcy5mb3JFYWNoKChzYW1wbGVyTmFtZSwgaSkgPT4ge1xuICAgICAgY29uc3QgaW5wdXRMYXlvdXQgPSB0aGlzLmNvbnRleHQuaW5wdXRUZXh0dXJlTGF5b3V0c1tpXTtcbiAgICAgIGNvbnN0IGZ1bmNOYW1lID0gZ2VuZXJhdGVTaGFkZXJGdW5jTmFtZUZyb21JbnB1dFNhbXBsZXJOYW1lKHNhbXBsZXJOYW1lKTtcbiAgICAgIGlmIChpbnB1dExheW91dC5pc1BhY2tlZCkge1xuICAgICAgICByZXN1bHRbZnVuY05hbWVdID0gdGhpcy5nZXRQYWNrZWRTYW1wbGVyRnJvbUlucHV0KGZ1bmNOYW1lLCBzYW1wbGVyTmFtZSwgaW5wdXRMYXlvdXQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0W2Z1bmNOYW1lXSA9IHRoaXMuZ2V0VW5wYWNrZWRTYW1wbGVyRnJvbUlucHV0KGZ1bmNOYW1lLCBzYW1wbGVyTmFtZSwgaW5wdXRMYXlvdXQpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBvdXRDb29yZEZ1bmNOYW1lID0gZ2VuZXJhdGVTaGFkZXJGdW5jTmFtZUZyb21JbnB1dFNhbXBsZXJOYW1lQXRPdXRDb29yZHMoc2FtcGxlck5hbWUpO1xuICAgICAgaWYgKGlucHV0TGF5b3V0LnVucGFja2VkU2hhcGUubGVuZ3RoIDw9IG91dHB1dExheW91dC51bnBhY2tlZFNoYXBlLmxlbmd0aCkge1xuICAgICAgICBpZiAoaW5wdXRMYXlvdXQuaXNQYWNrZWQpIHtcbiAgICAgICAgICByZXN1bHRbb3V0Q29vcmRGdW5jTmFtZV0gPVxuICAgICAgICAgICAgICB0aGlzLmdldFBhY2tlZFNhbXBsZXJBdE91dHB1dENvb3JkcyhvdXRDb29yZEZ1bmNOYW1lLCBpbnB1dExheW91dCwgb3V0cHV0TGF5b3V0LCBzYW1wbGVyTmFtZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0W291dENvb3JkRnVuY05hbWVdID1cbiAgICAgICAgICAgICAgdGhpcy5nZXRVbnBhY2tlZFNhbXBsZXJBdE91dHB1dENvb3JkcyhvdXRDb29yZEZ1bmNOYW1lLCBpbnB1dExheW91dCwgb3V0cHV0TGF5b3V0LCBzYW1wbGVyTmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQ29uc3RydWN0aW5nIHNuaXBwZXRzIGZvciBvdXRwdXQgY29vcmRpbmF0ZXMgb2Ygc2FtcGxlcnNcbiAgICovXG4gIHByb3RlY3RlZCBnZXRQYWNrZWRTYW1wbGVyQXRPdXRwdXRDb29yZHMoXG4gICAgICBmdW5jTmFtZTogc3RyaW5nLCBpbnB1dExheW91dDogVGV4dHVyZUxheW91dCwgb3V0cHV0TGF5b3V0OiBUZXh0dXJlTGF5b3V0LCBuYW1lOiBzdHJpbmcpOiBHbHNsTGliUm91dGluZSB7XG4gICAgY29uc3QgaW5TaGFwZSA9IGlucHV0TGF5b3V0LnVucGFja2VkU2hhcGU7XG4gICAgY29uc3Qgb3V0U2hhcGUgPSBvdXRwdXRMYXlvdXQudW5wYWNrZWRTaGFwZTtcbiAgICBjb25zdCB0ZXhOYW1lID0gbmFtZTtcbiAgICBjb25zdCB0ZXhGdW5jU25pcHBldCA9IGdlbmVyYXRlU2hhZGVyRnVuY05hbWVGcm9tSW5wdXRTYW1wbGVyTmFtZSh0ZXhOYW1lKTtcblxuICAgIGNvbnN0IGluUmFuayA9IGluU2hhcGUubGVuZ3RoO1xuICAgIGNvbnN0IG91dFJhbmsgPSBvdXRTaGFwZS5sZW5ndGg7XG5cbiAgICBjb25zdCBicm9hZGNhc3REaW1zID0gQnJvYWRjYXN0VXRpbC5nZXRCcm9hZGNhc3REaW1zKGluU2hhcGUsIG91dFNoYXBlKTtcblxuICAgIGNvbnN0IHR5cGUgPSBnZXRDb29yZHNEYXRhVHlwZShvdXRSYW5rKTtcbiAgICBjb25zdCByYW5rRGlmZiA9IG91dFJhbmsgLSBpblJhbms7XG4gICAgbGV0IGNvb3Jkc1NuaXBwZXQ6IHN0cmluZztcbiAgICBjb25zdCBmaWVsZHMgPSBnZXRHbENoYW5uZWxzKCk7XG5cbiAgICBpZiAoaW5SYW5rID09PSAwKSB7XG4gICAgICBjb29yZHNTbmlwcGV0ID0gJyc7XG4gICAgfSBlbHNlIGlmIChvdXRSYW5rIDwgMiAmJiBicm9hZGNhc3REaW1zLmxlbmd0aCA+PSAxKSB7XG4gICAgICBjb29yZHNTbmlwcGV0ID0gJ2Nvb3JkcyA9IDA7JztcbiAgICB9IGVsc2Uge1xuICAgICAgY29vcmRzU25pcHBldCA9IGJyb2FkY2FzdERpbXMubWFwKGQgPT4gYGNvb3Jkcy4ke2ZpZWxkc1tkICsgcmFua0RpZmZdfSA9IDA7YCkuam9pbignXFxuJyk7XG4gICAgfVxuICAgIGxldCB1bnBhY2tlZENvb3Jkc1NuaXBwZXQgPSAnJztcbiAgICBpZiAob3V0UmFuayA8IDIgJiYgaW5SYW5rID4gMCkge1xuICAgICAgdW5wYWNrZWRDb29yZHNTbmlwcGV0ID0gJ2Nvb3Jkcyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHVucGFja2VkQ29vcmRzU25pcHBldCA9IGluU2hhcGUubWFwKChfcywgaSkgPT4gYGNvb3Jkcy4ke2ZpZWxkc1tpICsgcmFua0RpZmZdfWApLmpvaW4oJywgJyk7XG4gICAgfVxuXG4gICAgbGV0IG91dHB1dCA9ICdyZXR1cm4gb3V0cHV0VmFsdWU7JztcbiAgICBjb25zdCBpblNpemUgPSBTaGFwZVV0aWwuc2l6ZShpblNoYXBlKTtcbiAgICBjb25zdCBpc0lucHV0U2NhbGFyID0gaW5TaXplID09PSAxO1xuICAgIGNvbnN0IG91dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShvdXRTaGFwZSk7XG4gICAgY29uc3QgaXNPdXRwdXRTY2FsYXIgPSBvdXRTaXplID09PSAxO1xuXG4gICAgaWYgKGluUmFuayA9PT0gMSAmJiAhaXNJbnB1dFNjYWxhciAmJiAhaXNPdXRwdXRTY2FsYXIpIHtcbiAgICAgIG91dHB1dCA9IGBcbiAgICAgICAgcmV0dXJuIHZlYzQob3V0cHV0VmFsdWUueHksIG91dHB1dFZhbHVlLnh5KTtcbiAgICAgIGA7XG4gICAgfSBlbHNlIGlmIChpc0lucHV0U2NhbGFyICYmICFpc091dHB1dFNjYWxhcikge1xuICAgICAgaWYgKG91dFJhbmsgPT09IDEpIHtcbiAgICAgICAgb3V0cHV0ID0gYFxuICAgICAgICAgIHJldHVybiB2ZWM0KG91dHB1dFZhbHVlLngsIG91dHB1dFZhbHVlLngsIDAuLCAwLik7XG4gICAgICAgIGA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXRwdXQgPSBgXG4gICAgICAgICAgcmV0dXJuIHZlYzQob3V0cHV0VmFsdWUueCk7XG4gICAgICAgIGA7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChicm9hZGNhc3REaW1zLmxlbmd0aCkge1xuICAgICAgY29uc3Qgcm93cyA9IGluUmFuayAtIDI7XG4gICAgICBjb25zdCBjb2xzID0gaW5SYW5rIC0gMTtcblxuICAgICAgaWYgKGJyb2FkY2FzdERpbXMuaW5kZXhPZihyb3dzKSA+IC0xICYmIGJyb2FkY2FzdERpbXMuaW5kZXhPZihjb2xzKSA+IC0xKSB7XG4gICAgICAgIG91dHB1dCA9ICdyZXR1cm4gdmVjNChvdXRwdXRWYWx1ZS54KTsnO1xuICAgICAgfSBlbHNlIGlmIChicm9hZGNhc3REaW1zLmluZGV4T2Yocm93cykgPiAtMSkge1xuICAgICAgICBvdXRwdXQgPSAncmV0dXJuIHZlYzQob3V0cHV0VmFsdWUueCwgb3V0cHV0VmFsdWUueSwgJyArXG4gICAgICAgICAgICAnb3V0cHV0VmFsdWUueCwgb3V0cHV0VmFsdWUueSk7JztcbiAgICAgIH0gZWxzZSBpZiAoYnJvYWRjYXN0RGltcy5pbmRleE9mKGNvbHMpID4gLTEpIHtcbiAgICAgICAgb3V0cHV0ID0gJ3JldHVybiB2ZWM0KG91dHB1dFZhbHVlLnh4LCBvdXRwdXRWYWx1ZS56eik7JztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBzd2FwTGFzdERpbXNTbmlwcGV0ID0gYFxuICAgICAgICBpbnQgbGFzdERpbSA9IGNvb3Jkcy4ke2ZpZWxkc1tvdXRSYW5rIC0gMV19O1xuICAgICAgICBjb29yZHMuJHtmaWVsZHNbb3V0UmFuayAtIDFdfSA9IGNvb3Jkcy4ke2ZpZWxkc1tvdXRSYW5rIC0gMl19O1xuICAgICAgICBjb29yZHMuJHtmaWVsZHNbb3V0UmFuayAtIDJdfSA9IGxhc3REaW07XG4gICAgICBgO1xuICAgIGNvbnN0IHNvdXJjZSA9IGBcbiAgICAgIHZlYzQgJHtmdW5jTmFtZX0oKSB7XG4gICAgICAgICR7dHlwZX0gY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XG4gICAgICAgICR7c3dhcExhc3REaW1zU25pcHBldH1cbiAgICAgICAgJHtjb29yZHNTbmlwcGV0fVxuICAgICAgICB2ZWM0IG91dHB1dFZhbHVlID0gJHt0ZXhGdW5jU25pcHBldH0oJHt1bnBhY2tlZENvb3Jkc1NuaXBwZXR9KTtcbiAgICAgICAgJHtvdXRwdXR9XG4gICAgICB9XG4gICAgYDtcbiAgICByZXR1cm4gbmV3IEdsc2xMaWJSb3V0aW5lKHNvdXJjZSwgWydjb29yZGluYXRlcy5nZXRPdXRwdXRDb29yZHMnXSk7XG4gIH1cblxuICAvKipcbiAgICogQ29uc3RydWN0aW5nIHNuaXBwZXRzIGZvciB1bnBhY2tlZCBvdXRwdXQgY29vcmRpbmF0ZXMgb2Ygc2FtcGxlcnNcbiAgICovXG4gIHByb3RlY3RlZCBnZXRVbnBhY2tlZFNhbXBsZXJBdE91dHB1dENvb3JkcyhcbiAgICAgIGZ1bmNOYW1lOiBzdHJpbmcsIGlucHV0TGF5b3V0OiBUZXh0dXJlTGF5b3V0LCBvdXRwdXRMYXlvdXQ6IFRleHR1cmVMYXlvdXQsIG5hbWU6IHN0cmluZyk6IEdsc2xMaWJSb3V0aW5lIHtcbiAgICBjb25zdCBvdXRUZXhTaGFwZSA9IFtvdXRwdXRMYXlvdXQud2lkdGgsIG91dHB1dExheW91dC5oZWlnaHRdO1xuICAgIGNvbnN0IGluVGV4U2hhcGUgPSBbaW5wdXRMYXlvdXQud2lkdGgsIGlucHV0TGF5b3V0LmhlaWdodF07XG4gICAgY29uc3QgaW5SYW5rID0gaW5wdXRMYXlvdXQudW5wYWNrZWRTaGFwZS5sZW5ndGg7XG4gICAgY29uc3Qgb3V0UmFuayA9IG91dHB1dExheW91dC51bnBhY2tlZFNoYXBlLmxlbmd0aDtcbiAgICBjb25zdCBpblNoYXBlID0gaW5wdXRMYXlvdXQudW5wYWNrZWRTaGFwZTtcbiAgICBjb25zdCBvdXRTaGFwZSA9IG91dHB1dExheW91dC51bnBhY2tlZFNoYXBlO1xuICAgIGNvbnN0IHRleEZ1bmNTbmlwcGV0ID0gZ2VuZXJhdGVTaGFkZXJGdW5jTmFtZUZyb21JbnB1dFNhbXBsZXJOYW1lKG5hbWUpO1xuXG4gICAgaWYgKGluUmFuayA9PT0gb3V0UmFuayAmJiBBcnJheVV0aWwuYXJyYXlzRXF1YWwoaW5UZXhTaGFwZSwgb3V0VGV4U2hhcGUpKSB7XG4gICAgICBjb25zdCBzb3VyY2UgPSBgXG4gICAgICAgICAgZmxvYXQgJHtmdW5jTmFtZX0oKSB7XG4gICAgICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZSgke25hbWV9LCBUZXhDb29yZHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgYDtcbiAgICAgIHJldHVybiBuZXcgR2xzbExpYlJvdXRpbmUoc291cmNlLCBbJ2Nvb3JkaW5hdGVzLnNhbXBsZVRleHR1cmUnXSk7XG4gICAgfVxuXG4gICAgY29uc3QgdHlwZSA9IGdldENvb3Jkc0RhdGFUeXBlKG91dFJhbmspO1xuICAgIGNvbnN0IGJyb2FkY2FzdERpbXMgPSBCcm9hZGNhc3RVdGlsLmdldEJyb2FkY2FzdERpbXMoaW5TaGFwZSwgb3V0U2hhcGUpO1xuICAgIGNvbnN0IHJhbmtEaWZmID0gb3V0UmFuayAtIGluUmFuaztcbiAgICBsZXQgY29vcmRzU25pcHBldDogc3RyaW5nO1xuICAgIGNvbnN0IGZpZWxkcyA9IGdldEdsQ2hhbm5lbHMoKTtcblxuICAgIGlmIChpblJhbmsgPT09IDApIHtcbiAgICAgIGNvb3Jkc1NuaXBwZXQgPSAnJztcbiAgICB9IGVsc2UgaWYgKG91dFJhbmsgPCAyICYmIGJyb2FkY2FzdERpbXMubGVuZ3RoID49IDEpIHtcbiAgICAgIGNvb3Jkc1NuaXBwZXQgPSAnY29vcmRzID0gMDsnO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb29yZHNTbmlwcGV0ID0gYnJvYWRjYXN0RGltcy5tYXAoZCA9PiBgY29vcmRzLiR7ZmllbGRzW2QgKyByYW5rRGlmZl19ID0gMDtgKS5qb2luKCdcXG4nKTtcbiAgICB9XG4gICAgbGV0IHVucGFja2VkQ29vcmRzU25pcHBldCA9ICcnO1xuICAgIGlmIChvdXRSYW5rIDwgMiAmJiBpblJhbmsgPiAwKSB7XG4gICAgICB1bnBhY2tlZENvb3Jkc1NuaXBwZXQgPSAnY29vcmRzJztcbiAgICB9IGVsc2Uge1xuICAgICAgdW5wYWNrZWRDb29yZHNTbmlwcGV0ID0gaW5wdXRMYXlvdXQudW5wYWNrZWRTaGFwZS5tYXAoKF9zLCBpKSA9PiBgY29vcmRzLiR7ZmllbGRzW2kgKyByYW5rRGlmZl19YCkuam9pbignLCAnKTtcbiAgICB9XG4gICAgY29uc3Qgc291cmNlID0gYFxuICAgICAgICBmbG9hdCAke2Z1bmNOYW1lfSgpIHtcbiAgICAgICAgICAke3R5cGV9IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xuICAgICAgICAgICR7Y29vcmRzU25pcHBldH1cbiAgICAgICAgICByZXR1cm4gJHt0ZXhGdW5jU25pcHBldH0oJHt1bnBhY2tlZENvb3Jkc1NuaXBwZXR9KTtcbiAgICAgICAgfVxuICAgICAgYDtcbiAgICByZXR1cm4gbmV3IEdsc2xMaWJSb3V0aW5lKHNvdXJjZSwgWydjb29yZGluYXRlcy5nZXRPdXRwdXRDb29yZHMnXSk7XG4gIH1cblxuICAvKipcbiAgICogQ29uc3RydWN0aW5nIHNuaXBwZXRzIGZvciBwYWNrZWQgb3BlcmF0aW9ucy5cbiAgICovXG4gIHByb3RlY3RlZCBnZXRQYWNrZWRTYW1wbGVyRnJvbUlucHV0KGZ1bmNOYW1lOiBzdHJpbmcsIG5hbWU6IHN0cmluZywgaW5wdXRMYXlvdXQ6IFRleHR1cmVMYXlvdXQpOiBHbHNsTGliUm91dGluZSB7XG4gICAgc3dpdGNoIChpbnB1dExheW91dC51bnBhY2tlZFNoYXBlLmxlbmd0aCkge1xuICAgICAgY2FzZSAwOlxuICAgICAgICByZXR1cm4gdGhpcy5nZXRQYWNrZWRTYW1wbGVyU2NhbGFyKGZ1bmNOYW1lLCBuYW1lKTtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UGFja2VkU2FtcGxlcjFEKGZ1bmNOYW1lLCBuYW1lLCBpbnB1dExheW91dCk7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIHJldHVybiB0aGlzLmdldFBhY2tlZFNhbXBsZXIyRChmdW5jTmFtZSwgbmFtZSwgaW5wdXRMYXlvdXQpO1xuICAgICAgY2FzZSAzOlxuICAgICAgICByZXR1cm4gdGhpcy5nZXRQYWNrZWRTYW1wbGVyM0QoZnVuY05hbWUsIG5hbWUsIGlucHV0TGF5b3V0KTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB0aGlzLmdldFBhY2tlZFNhbXBsZXJORChmdW5jTmFtZSwgbmFtZSwgaW5wdXRMYXlvdXQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3Rpbmcgc25pcHBldHMgZm9yIHVucGFja2VkIG9wZXJhdGlvbnMuXG4gICAqL1xuICBwcm90ZWN0ZWQgZ2V0VW5wYWNrZWRTYW1wbGVyRnJvbUlucHV0KGZ1bmNOYW1lOiBzdHJpbmcsIG5hbWU6IHN0cmluZywgaW5wdXRMYXlvdXQ6IFRleHR1cmVMYXlvdXQpOiBHbHNsTGliUm91dGluZSB7XG4gICAgY29uc3Qgc2hhcGUgPSBpbnB1dExheW91dC51bnBhY2tlZFNoYXBlO1xuICAgIHN3aXRjaCAoc2hhcGUubGVuZ3RoKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIHJldHVybiB0aGlzLmdldFVucGFja2VkU2FtcGxlclNjYWxhcihmdW5jTmFtZSwgbmFtZSwgaW5wdXRMYXlvdXQpO1xuICAgICAgY2FzZSAxOlxuICAgICAgICByZXR1cm4gdGhpcy5nZXRVbnBhY2tlZFNhbXBsZXIxRChmdW5jTmFtZSwgbmFtZSwgaW5wdXRMYXlvdXQpO1xuICAgICAgY2FzZSAyOlxuICAgICAgICByZXR1cm4gdGhpcy5nZXRVbnBhY2tlZFNhbXBsZXIyRChmdW5jTmFtZSwgbmFtZSwgaW5wdXRMYXlvdXQpO1xuICAgICAgY2FzZSAzOlxuICAgICAgICByZXR1cm4gdGhpcy5nZXRVbnBhY2tlZFNhbXBsZXIzRChmdW5jTmFtZSwgbmFtZSwgaW5wdXRMYXlvdXQpO1xuICAgICAgY2FzZSA0OlxuICAgICAgICByZXR1cm4gdGhpcy5nZXRVbnBhY2tlZFNhbXBsZXI0RChmdW5jTmFtZSwgbmFtZSwgaW5wdXRMYXlvdXQpO1xuICAgICAgY2FzZSA1OlxuICAgICAgICByZXR1cm4gdGhpcy5nZXRVbnBhY2tlZFNhbXBsZXI1RChmdW5jTmFtZSwgbmFtZSwgaW5wdXRMYXlvdXQpO1xuICAgICAgY2FzZSA2OlxuICAgICAgICByZXR1cm4gdGhpcy5nZXRVbnBhY2tlZFNhbXBsZXI2RChmdW5jTmFtZSwgbmFtZSwgaW5wdXRMYXlvdXQpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgLy8gVE9ETyBzdXBwb3J0IG1vcmUgZGltZW5zaW9uYWxpdGllc1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGRpbWVuc2lvbiAke3NoYXBlLmxlbmd0aH0tRGApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQYWNrZWQgc2NhbGFyIHNuaXBwZXQuXG4gICAqL1xuICBwcm90ZWN0ZWQgZ2V0UGFja2VkU2FtcGxlclNjYWxhcihmdW5jTmFtZTogc3RyaW5nLCBuYW1lOiBzdHJpbmcpOiBHbHNsTGliUm91dGluZSB7XG4gICAgY29uc3QgZ2xzbCA9IGdldEdsc2wodGhpcy5jb250ZXh0LmdsQ29udGV4dC52ZXJzaW9uKTtcbiAgICBjb25zdCBzb3VyY2UgPSBgXG4gICAgICAgICAgdmVjNCAke2Z1bmNOYW1lfSgpIHtcbiAgICAgICAgICAgIHJldHVybiAke2dsc2wudGV4dHVyZTJEfSgke25hbWV9LCBoYWxmQ1IpO1xuICAgICAgICAgIH1cbiAgICAgICAgYDtcbiAgICByZXR1cm4gbmV3IEdsc2xMaWJSb3V0aW5lKHNvdXJjZSk7XG4gIH1cblxuICAvKipcbiAgICogUGFja2VkIDFEIHNuaXBwZXQuXG4gICAqL1xuICBwcm90ZWN0ZWQgZ2V0UGFja2VkU2FtcGxlcjFEKGZ1bmNOYW1lOiBzdHJpbmcsIG5hbWU6IHN0cmluZywgaW5wdXRMYXlvdXQ6IFRleHR1cmVMYXlvdXQpOiBHbHNsTGliUm91dGluZSB7XG4gICAgY29uc3QgdGV4U2hhcGUgPSBbaW5wdXRMYXlvdXQud2lkdGgsIGlucHV0TGF5b3V0LmhlaWdodF07XG4gICAgY29uc3QgcGFja2VkVGV4U2hhcGUgPSBbdGV4U2hhcGVbMV0sIHRleFNoYXBlWzBdXTtcbiAgICBjb25zdCBnbHNsID0gZ2V0R2xzbCh0aGlzLmNvbnRleHQuZ2xDb250ZXh0LnZlcnNpb24pO1xuXG4gICAgY29uc3QgcGFja2VkU2FtcGxlciA9IGB2ZWM0ICR7ZnVuY05hbWV9KGludCBpbmRleCkge1xuICAgICAgdmVjMiB1diA9IHBhY2tlZFVWZnJvbTFEKFxuICAgICAgJHtwYWNrZWRUZXhTaGFwZVswXX0sICR7cGFja2VkVGV4U2hhcGVbMV19LCBpbmRleCk7XG4gICAgICByZXR1cm4gJHtnbHNsLnRleHR1cmUyRH0oJHtuYW1lfSwgdXYpO1xuICAgIH1gO1xuICAgIGNvbnN0IHNvdXJjZSA9IHBhY2tlZFNhbXBsZXI7XG4gICAgcmV0dXJuIG5ldyBHbHNsTGliUm91dGluZShzb3VyY2UsIFsnY29vcmRpbmF0ZXMucGFja2VkVVZmcm9tMUQnXSk7XG4gIH1cblxuICAvKipcbiAgICogUGFja2VkIDJEIHNuaXBwZXQuXG4gICAqL1xuICBwcm90ZWN0ZWQgZ2V0UGFja2VkU2FtcGxlcjJEKGZ1bmNOYW1lOiBzdHJpbmcsIG5hbWU6IHN0cmluZywgaW5wdXRMYXlvdXQ6IFRleHR1cmVMYXlvdXQpOiBHbHNsTGliUm91dGluZSB7XG4gICAgY29uc3Qgc2hhcGUgPSBpbnB1dExheW91dC51bnBhY2tlZFNoYXBlO1xuICAgIGNvbnN0IHRleFNoYXBlID0gW2lucHV0TGF5b3V0LndpZHRoLCBpbnB1dExheW91dC5oZWlnaHRdO1xuICAgIGNvbnN0IGdsc2wgPSBnZXRHbHNsKHRoaXMuY29udGV4dC5nbENvbnRleHQudmVyc2lvbik7XG4gICAgY29uc3QgdGV4TnVtUiA9IHRleFNoYXBlWzBdO1xuICAgIGNvbnN0IHRleE51bUMgPSB0ZXhTaGFwZVsxXTtcblxuICAgIGlmICh0ZXhTaGFwZSAhPSBudWxsICYmIEFycmF5VXRpbC5hcnJheXNFcXVhbChzaGFwZSwgdGV4U2hhcGUpKSB7XG4gICAgICBjb25zdCBwYWNrZWRTYW1wbGVyID0gYHZlYzQgJHtmdW5jTmFtZX0oaW50IHJvdywgaW50IGNvbCkge1xuICAgICAgICB2ZWMyIHV2ID0gKHZlYzIoY29sLCByb3cpICsgaGFsZkNSKSAvIHZlYzIoJHt0ZXhOdW1DfS4wLCAke3RleE51bVJ9LjApO1xuICAgICAgICByZXR1cm4gJHtnbHNsLnRleHR1cmUyRH0oJHtuYW1lfSwgdXYpO1xuICAgICAgfWA7XG5cbiAgICAgIHJldHVybiBuZXcgR2xzbExpYlJvdXRpbmUocGFja2VkU2FtcGxlcik7XG4gICAgfVxuICAgIGNvbnN0IHBhY2tlZFRleFNoYXBlID0gdGV4U2hhcGU7XG4gICAgY29uc3QgdmFsdWVzUGVyUm93ID0gTWF0aC5jZWlsKHNoYXBlWzFdIC8gMik7XG4gICAgY29uc3QgcGFja2VkU2FtcGxlciA9IGB2ZWM0ICR7ZnVuY05hbWV9KGludCByb3csIGludCBjb2wpIHtcbiAgICAgIHZlYzIgdXYgPSBwYWNrZWRVVmZyb20yRCgke3BhY2tlZFRleFNoYXBlWzFdfSwgJHtwYWNrZWRUZXhTaGFwZVswXX0sICR7dmFsdWVzUGVyUm93fSwgcm93LCBjb2wpO1xuICAgICAgcmV0dXJuICR7Z2xzbC50ZXh0dXJlMkR9KCR7bmFtZX0sIHV2KTtcbiAgICB9YDtcbiAgICBjb25zdCBzb3VyY2UgPSBwYWNrZWRTYW1wbGVyO1xuICAgIHJldHVybiBuZXcgR2xzbExpYlJvdXRpbmUoc291cmNlLCBbJ2Nvb3JkaW5hdGVzLnBhY2tlZFVWZnJvbTJEJ10pO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhY2tlZCAzRCBzbmlwcGV0LlxuICAgKi9cbiAgcHJvdGVjdGVkIGdldFBhY2tlZFNhbXBsZXIzRChmdW5jTmFtZTogc3RyaW5nLCBuYW1lOiBzdHJpbmcsIGlucHV0TGF5b3V0OiBUZXh0dXJlTGF5b3V0KTogR2xzbExpYlJvdXRpbmUge1xuICAgIGNvbnN0IHNoYXBlID0gaW5wdXRMYXlvdXQudW5wYWNrZWRTaGFwZTtcbiAgICBjb25zdCB0ZXhTaGFwZSA9IFtpbnB1dExheW91dC53aWR0aCwgaW5wdXRMYXlvdXQuaGVpZ2h0XTtcbiAgICBjb25zdCBwYWNrZWRUZXhTaGFwZSA9IFt0ZXhTaGFwZVswXSwgdGV4U2hhcGVbMV1dO1xuICAgIGNvbnN0IGdsc2wgPSBnZXRHbHNsKHRoaXMuY29udGV4dC5nbENvbnRleHQudmVyc2lvbik7XG5cbiAgICBpZiAoc2hhcGVbMF0gPT09IDEpIHtcbiAgICAgIGNvbnN0IHNxdWVlemVkU2hhcGUgPSBzaGFwZS5zbGljZSgxKTtcbiAgICAgIGNvbnN0IGtlcHREaW1zID0gWzEsIDJdO1xuICAgICAgY29uc3QgbmV3SW5wdXRTaGFwZSA9IHNxdWVlemVJbnB1dFNoYXBlKHNoYXBlLCBzcXVlZXplZFNoYXBlKTtcbiAgICAgIGNvbnN0IHBhcmFtcyA9IFsnYicsICdyb3cnLCAnY29sJ107XG4gICAgICAvLyBEZWVwIGNvcHkgb2YgaW5wdXQgdGV4dHVyZSBsYXlvdXQuXG4gICAgICBjb25zdCBuZXdJbnB1dExheW91dDogVGV4dHVyZUxheW91dCA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoaW5wdXRMYXlvdXQpKTtcbiAgICAgIG5ld0lucHV0TGF5b3V0LnVucGFja2VkU2hhcGUgPSBuZXdJbnB1dFNoYXBlO1xuICAgICAgY29uc3Qgc2FtcGxlclJvdXRpbmUgPSB0aGlzLmdldFBhY2tlZFNhbXBsZXJGcm9tSW5wdXQoZnVuY05hbWUsIG5hbWUsIG5ld0lucHV0TGF5b3V0KTtcbiAgICAgIGNvbnN0IHBhY2tlZFNhbXBsZXIgPSBgJHtzYW1wbGVyUm91dGluZS5yb3V0aW5lQm9keX1cbiAgICAgIHZlYzQgJHtmdW5jTmFtZX0oaW50IGIsIGludCByb3csIGludCBjb2wpIHtcbiAgICAgICAgcmV0dXJuICR7ZnVuY05hbWV9KCR7Z2V0U3F1ZWV6ZWRQYXJhbXMocGFyYW1zLCBrZXB0RGltcyl9KTtcbiAgICAgIH0gYDtcbiAgICAgIGNvbnN0IHNvdXJjZSA9IHBhY2tlZFNhbXBsZXI7XG4gICAgICByZXR1cm4gbmV3IEdsc2xMaWJSb3V0aW5lKHNvdXJjZSwgc2FtcGxlclJvdXRpbmUuZGVwZW5kZW5jaWVzKTtcbiAgICB9XG4gICAgY29uc3QgdGV4TnVtUiA9IHBhY2tlZFRleFNoYXBlWzBdO1xuICAgIGNvbnN0IHRleE51bUMgPSBwYWNrZWRUZXhTaGFwZVsxXTtcblxuICAgIGNvbnN0IHZhbHVlc1BlclJvdyA9IE1hdGguY2VpbChzaGFwZVsyXSAvIDIpO1xuICAgIGNvbnN0IHRleGVsc0luQmF0Y2ggPSB2YWx1ZXNQZXJSb3cgKiBNYXRoLmNlaWwoc2hhcGVbMV0gLyAyKTtcblxuICAgIGNvbnN0IHBhY2tlZFNhbXBsZXIgPSBgdmVjNCAke2Z1bmNOYW1lfShpbnQgYiwgaW50IHJvdywgaW50IGNvbCkge1xuICAgICAgdmVjMiB1diA9IHBhY2tlZFVWZnJvbTNEKFxuICAgICAgICAke3RleE51bUN9LCAke3RleE51bVJ9LCAke3RleGVsc0luQmF0Y2h9LCAke3ZhbHVlc1BlclJvd30sIGIsIHJvdywgY29sKTtcbiAgICAgIHJldHVybiAke2dsc2wudGV4dHVyZTJEfSgke25hbWV9LCB1dik7fWA7XG4gICAgY29uc3Qgc291cmNlID0gcGFja2VkU2FtcGxlcjtcbiAgICByZXR1cm4gbmV3IEdsc2xMaWJSb3V0aW5lKHNvdXJjZSwgWydjb29yZGluYXRlcy5wYWNrZWRVVmZyb20zRCddKTtcbiAgfVxuICAvKlxuICAgKiBQYWNrZWQgTkQgc25pcHBldC5cbiAgICovXG4gIHByb3RlY3RlZCBnZXRQYWNrZWRTYW1wbGVyTkQoZnVuY05hbWU6IHN0cmluZywgbmFtZTogc3RyaW5nLCBpbnB1dExheW91dDogVGV4dHVyZUxheW91dCk6IEdsc2xMaWJSb3V0aW5lIHtcbiAgICBjb25zdCBzaGFwZSA9IGlucHV0TGF5b3V0LnVucGFja2VkU2hhcGU7XG4gICAgY29uc3QgcmFuayA9IHNoYXBlLmxlbmd0aDtcbiAgICBjb25zdCB0ZXhTaGFwZSA9IFtpbnB1dExheW91dC53aWR0aCwgaW5wdXRMYXlvdXQuaGVpZ2h0XTtcbiAgICBjb25zdCBnbHNsID0gZ2V0R2xzbCh0aGlzLmNvbnRleHQuZ2xDb250ZXh0LnZlcnNpb24pO1xuXG4gICAgY29uc3QgcGFja2VkVGV4U2hhcGUgPSBbdGV4U2hhcGVbMF0sIHRleFNoYXBlWzFdXTtcbiAgICBjb25zdCB0ZXhOdW1SID0gcGFja2VkVGV4U2hhcGVbMV07XG4gICAgY29uc3QgdGV4TnVtQyA9IHBhY2tlZFRleFNoYXBlWzBdO1xuICAgIGNvbnN0IHZhbHVlc1BlclJvdyA9IE1hdGguY2VpbChzaGFwZVtyYW5rIC0gMV0gLyAyKTtcbiAgICBsZXQgdGV4ZWxzSW5CYXRjaCA9IHZhbHVlc1BlclJvdyAqIE1hdGguY2VpbChzaGFwZVtyYW5rIC0gMl0gLyAyKTtcbiAgICBsZXQgcGFyYW1zID0gJ2ludCBiLCBpbnQgcm93LCBpbnQgY29sJztcbiAgICBsZXQgaW5kZXggPSBgYiAqICR7dGV4ZWxzSW5CYXRjaH0gKyAocm93IC8gMikgKiAke3ZhbHVlc1BlclJvd30gKyAoY29sIC8gMilgO1xuICAgIGZvciAobGV0IGIgPSAyOyBiIDwgcmFuayAtIDE7IGIrKykge1xuICAgICAgcGFyYW1zID0gYGludCBiJHtifSwgYCArIHBhcmFtcztcbiAgICAgIHRleGVsc0luQmF0Y2ggKj0gc2hhcGVbcmFuayAtIGIgLSAxXTtcbiAgICAgIGluZGV4ID0gYGIke2J9ICogJHt0ZXhlbHNJbkJhdGNofSArIGAgKyBpbmRleDtcbiAgICB9XG4gICAgY29uc3QgcGFja2VkU2FtcGxlciA9IGB2ZWM0ICR7ZnVuY05hbWV9KCR7cGFyYW1zfSkge1xuICAgICAgaW50IGluZGV4ID0gJHtpbmRleH07XG4gICAgICBpbnQgdGV4UiA9IGluZGV4IC8gJHt0ZXhOdW1DfTtcbiAgICAgIGludCB0ZXhDID0gaW5kZXggLSB0ZXhSICogJHt0ZXhOdW1DfTtcbiAgICAgIHZlYzIgdXYgPSAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgLyB2ZWMyKCR7dGV4TnVtQ30sICR7dGV4TnVtUn0pO1xuICAgICAgcmV0dXJuICR7Z2xzbC50ZXh0dXJlMkR9KCR7bmFtZX0sIHV2KTtcbiAgICB9YDtcbiAgICBjb25zdCBzb3VyY2UgPSBwYWNrZWRTYW1wbGVyO1xuICAgIHJldHVybiBuZXcgR2xzbExpYlJvdXRpbmUoc291cmNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVbnBhY2tlZCBzY2FsYXIgc25pcHBldC5cbiAgICovXG4gIHByb3RlY3RlZCBnZXRVbnBhY2tlZFNhbXBsZXJTY2FsYXIoZnVuY05hbWU6IHN0cmluZywgbmFtZTogc3RyaW5nLCBpbnB1dExheW91dDogVGV4dHVyZUxheW91dCk6IEdsc2xMaWJSb3V0aW5lIHtcbiAgICBjb25zdCBbdGV4TnVtUiwgdGV4TnVtQ10gPSBbaW5wdXRMYXlvdXQud2lkdGgsIGlucHV0TGF5b3V0LmhlaWdodF07XG4gICAgaWYgKHRleE51bVIgPT09IDEgJiYgdGV4TnVtQyA9PT0gMSkge1xuICAgICAgY29uc3Qgc291cmNlID0gYFxuICAgICAgICAgIGZsb2F0ICR7ZnVuY05hbWV9KCkge1xuICAgICAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHtuYW1lfSwgaGFsZkNSKTtcbiAgICAgICAgICB9XG4gICAgICAgIGA7XG4gICAgICByZXR1cm4gbmV3IEdsc2xMaWJSb3V0aW5lKHNvdXJjZSwgWydjb29yZGluYXRlcy5zYW1wbGVUZXh0dXJlJ10pO1xuICAgIH1cblxuICAgIGNvbnN0IHNvdXJjZSA9IGBcbiAgICAgICAgZmxvYXQgJHtmdW5jTmFtZX0oKSB7XG4gICAgICAgICAgaW50IG9mZnNldF8ke25hbWV9ID0gY29vcmRzVG9PZmZzZXQoVGV4Q29vcmRzLCAke3RleE51bVJ9LCAke3RleE51bUN9KTtcbiAgICAgICAgICB2ZWMyIHV2ID0gdXZGcm9tRmxhdCgke3RleE51bVJ9LCAke3RleE51bUN9LCBvZmZzZXRfJHtuYW1lfSk7XG4gICAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHtuYW1lfSwgdXYpO1xuICAgICAgICB9XG4gICAgICBgO1xuICAgIHJldHVybiBuZXcgR2xzbExpYlJvdXRpbmUoXG4gICAgICAgIHNvdXJjZSwgWydjb29yZGluYXRlcy51dkZyb21GbGF0JywgJ2Nvb3JkaW5hdGVzLnNhbXBsZVRleHR1cmUnLCAnY29vcmRpbmF0ZXMuY29vcmRzVG9PZmZzZXQnXSk7XG4gIH1cblxuICAvKipcbiAgICogVW5wYWNrZWQgMUQgc25pcHBldC5cbiAgICovXG4gIHByb3RlY3RlZCBnZXRVbnBhY2tlZFNhbXBsZXIxRChmdW5jTmFtZTogc3RyaW5nLCBuYW1lOiBzdHJpbmcsIGlucHV0TGF5b3V0OiBUZXh0dXJlTGF5b3V0KTogR2xzbExpYlJvdXRpbmUge1xuICAgIGNvbnN0IHROdW1SID0gaW5wdXRMYXlvdXQud2lkdGg7XG4gICAgY29uc3QgdE51bUMgPSBpbnB1dExheW91dC5oZWlnaHQ7XG5cbiAgICBpZiAodE51bUMgPT09IDEgJiYgdE51bVIgPT09IDEpIHtcbiAgICAgIGNvbnN0IHNvdXJjZSA9IGBcbiAgICAgICAgZmxvYXQgJHtmdW5jTmFtZX0oaW50IGluZGV4KSB7XG4gICAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHtuYW1lfSwgaGFsZkNSKTtcbiAgICAgICAgfVxuICAgICAgYDtcbiAgICAgIHJldHVybiBuZXcgR2xzbExpYlJvdXRpbmUoc291cmNlLCBbJ2Nvb3JkaW5hdGVzLnNhbXBsZVRleHR1cmUnXSk7XG4gICAgfVxuXG4gICAgaWYgKHROdW1DID09PSAxKSB7XG4gICAgICBjb25zdCBzb3VyY2UgPSBgXG4gICAgICAgICAgZmxvYXQgJHtmdW5jTmFtZX0oaW50IGluZGV4KSB7XG4gICAgICAgICAgICB2ZWMyIHV2ID0gdmVjMigoZmxvYXQoaW5kZXgpICsgMC41KSAvICR7dE51bVJ9LjAsIDAuNSk7XG4gICAgICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZSgke25hbWV9LCB1dik7XG4gICAgICAgICAgfVxuICAgICAgICBgO1xuICAgICAgcmV0dXJuIG5ldyBHbHNsTGliUm91dGluZShzb3VyY2UsIFsnY29vcmRpbmF0ZXMuc2FtcGxlVGV4dHVyZSddKTtcbiAgICB9XG4gICAgaWYgKHROdW1SID09PSAxKSB7XG4gICAgICBjb25zdCBzb3VyY2UgPSBgXG4gICAgICAgICAgZmxvYXQgJHtmdW5jTmFtZX0oaW50IGluZGV4KSB7XG4gICAgICAgICAgICB2ZWMyIHV2ID0gdmVjMigwLjUsIChmbG9hdChpbmRleCkgKyAwLjUpIC8gJHt0TnVtQ30uMCk7XG4gICAgICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZSgke25hbWV9LCB1dik7XG4gICAgICAgICAgfVxuICAgICAgICBgO1xuICAgICAgcmV0dXJuIG5ldyBHbHNsTGliUm91dGluZShzb3VyY2UsIFsnY29vcmRpbmF0ZXMuc2FtcGxlVGV4dHVyZSddKTtcbiAgICB9XG4gICAgY29uc3Qgc291cmNlID0gYFxuICAgICAgICBmbG9hdCAke2Z1bmNOYW1lfShpbnQgaW5kZXgpIHtcbiAgICAgICAgICB2ZWMyIHV2ID0gdXZGcm9tRmxhdCgke3ROdW1SfSwgJHt0TnVtQ30sIGluZGV4KTtcbiAgICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZSgke25hbWV9LCB1dik7XG4gICAgICAgIH1cbiAgICAgIGA7XG4gICAgcmV0dXJuIG5ldyBHbHNsTGliUm91dGluZShzb3VyY2UsIFsnY29vcmRpbmF0ZXMudXZGcm9tRmxhdCcsICdjb29yZGluYXRlcy5zYW1wbGVUZXh0dXJlJ10pO1xuICB9XG5cbiAgLyoqXG4gICAqIFVucGFja2VkIDJEIHNuaXBwZXQuXG4gICAqL1xuXG4gIHByb3RlY3RlZCBnZXRVbnBhY2tlZFNhbXBsZXIyRChmdW5jTmFtZTogc3RyaW5nLCBuYW1lOiBzdHJpbmcsIGlucHV0TGF5b3V0OiBUZXh0dXJlTGF5b3V0KTogR2xzbExpYlJvdXRpbmUge1xuICAgIGNvbnN0IHNoYXBlID0gaW5wdXRMYXlvdXQudW5wYWNrZWRTaGFwZTtcblxuICAgIC8vIFRPRE86IG1vZGlmeSByb3cvY29sIG9yZGVyIGZvciBvdGhlciBkaW1lbnNpb25zLlxuICAgIGNvbnN0IHRleFNoYXBlID0gW2lucHV0TGF5b3V0LmhlaWdodCwgaW5wdXRMYXlvdXQud2lkdGhdO1xuXG4gICAgaWYgKHRleFNoYXBlICE9IG51bGwgJiYgQXJyYXlVdGlsLmFycmF5c0VxdWFsKHNoYXBlLCB0ZXhTaGFwZSkpIHtcbiAgICAgIGNvbnN0IHRleE51bVIgPSB0ZXhTaGFwZVsxXTtcbiAgICAgIGNvbnN0IHRleE51bUMgPSB0ZXhTaGFwZVswXTtcbiAgICAgIGNvbnN0IHNvdXJjZSA9IGBcbiAgICAgICAgICBmbG9hdCAke2Z1bmNOYW1lfShpbnQgcm93LCBpbnQgY29sKSB7XG4gICAgICAgICAgICB2ZWMyIHV2ID0gKHZlYzIocm93LCBjb2wpICsgaGFsZkNSKSAvIHZlYzIoJHt0ZXhOdW1SfS4wLCAke3RleE51bUN9LjApO1xuICAgICAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHtuYW1lfSwgdXYpO1xuICAgICAgICAgIH1cbiAgICAgICAgYDtcbiAgICAgIHJldHVybiBuZXcgR2xzbExpYlJvdXRpbmUoc291cmNlLCBbJ2Nvb3JkaW5hdGVzLnNhbXBsZVRleHR1cmUnXSk7XG4gICAgfVxuXG4gICAgY29uc3Qge25ld1NoYXBlLCBrZXB0RGltc30gPSBzcXVlZXplU2hhcGUoc2hhcGUgYXMgbnVtYmVyW10pO1xuICAgIGNvbnN0IHNxdWVlemVkU2hhcGUgPSBuZXdTaGFwZTtcbiAgICBpZiAoc3F1ZWV6ZWRTaGFwZS5sZW5ndGggPCBzaGFwZS5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IG5ld0lucHV0U2hhcGUgPSBzcXVlZXplSW5wdXRTaGFwZShzaGFwZSwgc3F1ZWV6ZWRTaGFwZSk7XG4gICAgICAvLyBEZWVwIGNvcHkgb2YgaW5wdXQgdGV4dHVyZSBsYXlvdXQuXG4gICAgICBjb25zdCBuZXdJbnB1dExheW91dDogVGV4dHVyZUxheW91dCA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoaW5wdXRMYXlvdXQpKTtcbiAgICAgIG5ld0lucHV0TGF5b3V0LnVucGFja2VkU2hhcGUgPSBuZXdJbnB1dFNoYXBlO1xuXG4gICAgICBjb25zdCBwYXJhbXMgPSBbJ2NvbCcsICdyb3cnXTtcbiAgICAgIGNvbnN0IHNvdXJjZSA9IGBcbiAgICAgICAgICAke3RoaXMuZ2V0VW5wYWNrZWRTYW1wbGVyRnJvbUlucHV0KGZ1bmNOYW1lLCBuYW1lLCBuZXdJbnB1dExheW91dCkucm91dGluZUJvZHl9XG4gICAgICAgICAgZmxvYXQgJHtmdW5jTmFtZX0oaW50IHJvdywgaW50IGNvbCkge1xuICAgICAgICAgICAgcmV0dXJuICR7ZnVuY05hbWV9KCR7Z2V0U3F1ZWV6ZWRQYXJhbXMocGFyYW1zLCBrZXB0RGltcyl9KTtcbiAgICAgICAgICB9XG4gICAgICAgIGA7XG4gICAgICByZXR1cm4gbmV3IEdsc2xMaWJSb3V0aW5lKHNvdXJjZSwgWydjb29yZGluYXRlcy5zYW1wbGVUZXh0dXJlJ10pO1xuICAgIH1cblxuICAgIGNvbnN0IHRleE51bVIgPSB0ZXhTaGFwZVsxXTtcbiAgICBjb25zdCB0ZXhOdW1DID0gdGV4U2hhcGVbMF07XG4gICAgaWYgKHRleE51bUMgPT09IDEpIHtcbiAgICAgIGNvbnN0IHNvdXJjZSA9IGBcbiAgICAgICAgICBmbG9hdCAke2Z1bmNOYW1lfShpbnQgcm93LCBpbnQgY29sKSB7XG4gICAgICAgICAgICBpbnQgb2Zmc2V0XyR7bmFtZX0gPSBjb29yZHNUb09mZnNldChUZXhDb29yZHMsICR7dGV4TnVtUn0sICR7dGV4TnVtQ30pO1xuICAgICAgICAgICAgZmxvYXQgaW5kZXggPSBkb3QodmVjMyhyb3csIGNvbCwgb2Zmc2V0XyR7bmFtZX0pLCB2ZWMzKCR7c2hhcGVbMV19LCAxLCAxKSk7XG4gICAgICAgICAgICB2ZWMyIHV2ID0gdmVjMigwLjUsIChpbmRleCArIDAuNSkgLyAke3RleE51bVJ9LjApO1xuICAgICAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHtuYW1lfSwgdXYpO1xuICAgICAgICAgIH1cbiAgICAgICAgYDtcbiAgICAgIHJldHVybiBuZXcgR2xzbExpYlJvdXRpbmUoc291cmNlLCBbJ2Nvb3JkaW5hdGVzLnNhbXBsZVRleHR1cmUnLCAnY29vcmRpbmF0ZXMuY29vcmRzVG9PZmZzZXQnXSk7XG4gICAgfVxuXG4gICAgaWYgKHRleE51bVIgPT09IDEpIHtcbiAgICAgIGNvbnN0IHNvdXJjZSA9IGBcbiAgICAgICAgICBmbG9hdCAke2Z1bmNOYW1lfShpbnQgcm93LCBpbnQgY29sKSB7XG4gICAgICAgICAgICBpbnQgb2Zmc2V0XyR7bmFtZX0gPSBjb29yZHNUb09mZnNldChUZXhDb29yZHMsICR7dGV4TnVtUn0sICR7dGV4TnVtQ30pO1xuICAgICAgICAgICAgZmxvYXQgaW5kZXggPSBkb3QodmVjMyhyb3csIGNvbCwgb2Zmc2V0XyR7bmFtZX0pLCB2ZWMzKCR7c2hhcGVbMV19LCAxLCAxKSk7XG4gICAgICAgICAgICB2ZWMyIHV2ID0gdmVjMigoaW5kZXggKyAwLjUpIC8gJHt0ZXhOdW1DfS4wLCAwLjUpO1xuICAgICAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHtuYW1lfSwgdXYpO1xuICAgICAgICAgIH1cbiAgICAgICAgYDtcbiAgICAgIHJldHVybiBuZXcgR2xzbExpYlJvdXRpbmUoc291cmNlLCBbJ2Nvb3JkaW5hdGVzLnNhbXBsZVRleHR1cmUnLCAnY29vcmRpbmF0ZXMuY29vcmRzVG9PZmZzZXQnXSk7XG4gICAgfVxuXG4gICAgY29uc3Qgc291cmNlID0gYFxuICAgICAgICBmbG9hdCAke2Z1bmNOYW1lfShpbnQgcm93LCBpbnQgY29sKSB7XG4gICAgICAgICAgaW50IGluZGV4ID0gY29sICogJHtzaGFwZVsxXX0gKyByb3c7XG4gICAgICAgICAgdmVjMiB1diA9IHV2RnJvbUZsYXQoJHt0ZXhOdW1SfSwgJHt0ZXhOdW1DfSwgaW5kZXgpO1xuICAgICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKCR7bmFtZX0sIHV2KTtcbiAgICAgICAgfVxuICAgICAgYDtcbiAgICByZXR1cm4gbmV3IEdsc2xMaWJSb3V0aW5lKFxuICAgICAgICBzb3VyY2UsIFsnY29vcmRpbmF0ZXMudXZGcm9tRmxhdCcsICdjb29yZGluYXRlcy5zYW1wbGVUZXh0dXJlJywgJ2Nvb3JkaW5hdGVzLmNvb3Jkc1RvT2Zmc2V0J10pO1xuICB9XG5cbiAgLyoqXG4gICAqIFVucGFja2VkIDNEIHNuaXBwZXQuXG4gICAqL1xuXG4gIHByb3RlY3RlZCBnZXRVbnBhY2tlZFNhbXBsZXIzRChmdW5jTmFtZTogc3RyaW5nLCBuYW1lOiBzdHJpbmcsIGlucHV0TGF5b3V0OiBUZXh0dXJlTGF5b3V0KTogR2xzbExpYlJvdXRpbmUge1xuICAgIGNvbnN0IHNoYXBlID0gaW5wdXRMYXlvdXQudW5wYWNrZWRTaGFwZTtcbiAgICBjb25zdCBzdHJpZGUwID0gc2hhcGVbMV0gKiBzaGFwZVsyXTtcbiAgICBjb25zdCBzdHJpZGUxID0gc2hhcGVbMl07XG5cbiAgICBjb25zdCB7bmV3U2hhcGUsIGtlcHREaW1zfSA9IHNxdWVlemVTaGFwZShzaGFwZSBhcyBudW1iZXJbXSk7XG4gICAgY29uc3Qgc3F1ZWV6ZWRTaGFwZSA9IG5ld1NoYXBlO1xuICAgIGlmIChzcXVlZXplZFNoYXBlLmxlbmd0aCA8IHNoYXBlLmxlbmd0aCkge1xuICAgICAgY29uc3QgbmV3SW5wdXRTaGFwZSA9IHNxdWVlemVJbnB1dFNoYXBlKHNoYXBlLCBzcXVlZXplZFNoYXBlKTtcbiAgICAgIGNvbnN0IHBhcmFtcyA9IFsnYmF0Y2gnLCAnY29sJywgJ3JvdyddO1xuICAgICAgLy8gRGVlcCBjb3B5IG9mIGlucHV0IHRleHR1cmUgbGF5b3V0LlxuICAgICAgY29uc3QgbmV3SW5wdXRMYXlvdXQ6IFRleHR1cmVMYXlvdXQgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGlucHV0TGF5b3V0KSk7XG4gICAgICBuZXdJbnB1dExheW91dC51bnBhY2tlZFNoYXBlID0gbmV3SW5wdXRTaGFwZTtcbiAgICAgIGNvbnN0IHJvdXRpbmUgPSB0aGlzLmdldFVucGFja2VkU2FtcGxlckZyb21JbnB1dChmdW5jTmFtZSwgbmFtZSwgbmV3SW5wdXRMYXlvdXQpO1xuICAgICAgLy8gVE9ETzogcmV2aXNpdCB0aGUgbG9naWMgaGVyZSB0byBtYWtlIGl0IHNpbXBsZXJcbiAgICAgIGNvbnN0IHJldkRpbXMgPSBrZXB0RGltcy5yZXZlcnNlKCk7XG4gICAgICBjb25zdCBzb3VyY2UgPSBgXG4gICAgICAgICAgJHtyb3V0aW5lLnJvdXRpbmVCb2R5fVxuICAgICAgICAgIGZsb2F0ICR7ZnVuY05hbWV9KGludCBiYXRjaCwgaW50IHJvdywgaW50IGNvbCkge1xuICAgICAgICAgICAgcmV0dXJuICR7ZnVuY05hbWV9KCR7Z2V0U3F1ZWV6ZWRQYXJhbXMocGFyYW1zLCByZXZEaW1zKX0pO1xuICAgICAgICAgIH1cbiAgICAgICAgYDtcbiAgICAgIHJldHVybiBuZXcgR2xzbExpYlJvdXRpbmUoc291cmNlLCByb3V0aW5lLmRlcGVuZGVuY2llcyk7XG4gICAgfVxuXG4gICAgY29uc3QgdGV4TnVtUiA9IGlucHV0TGF5b3V0LndpZHRoO1xuICAgIGNvbnN0IHRleE51bUMgPSBpbnB1dExheW91dC5oZWlnaHQ7XG4gICAgY29uc3Qgc291cmNlID0gYFxuICAgICAgICAgIGZsb2F0ICR7ZnVuY05hbWV9KGludCBkZXB0aCwgaW50IHJvdywgaW50IGNvbCkge1xuICAgICAgICAgICAgLy8gRXhwbGljaXRseSB1c2UgaW50ZWdlciBvcGVyYXRpb25zIGFzIGRvdCgpIG9ubHkgd29ya3Mgb24gZmxvYXRzLlxuICAgICAgICAgICAgaW50IGluZGV4ID0gZGVwdGggKiAke3N0cmlkZTB9ICsgY29sICogJHtzdHJpZGUxfSArIHJvdztcbiAgICAgICAgICAgIHZlYzIgdXYgPSB1dkZyb21GbGF0KCR7dGV4TnVtUn0sICR7dGV4TnVtQ30sIGluZGV4KTtcbiAgICAgICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKCR7bmFtZX0sIHV2KTtcbiAgICAgICAgICB9XG4gICAgICBgO1xuICAgIHJldHVybiBuZXcgR2xzbExpYlJvdXRpbmUoXG4gICAgICAgIHNvdXJjZSwgWydjb29yZGluYXRlcy51dkZyb21GbGF0JywgJ2Nvb3JkaW5hdGVzLnNhbXBsZVRleHR1cmUnLCAnY29vcmRpbmF0ZXMuY29vcmRzVG9PZmZzZXQnXSk7XG4gIH1cblxuICAvKipcbiAgICogVW5wYWNrZWQgNEQgc25pcHBldC5cbiAgICovXG5cbiAgcHJvdGVjdGVkIGdldFVucGFja2VkU2FtcGxlcjREKGZ1bmNOYW1lOiBzdHJpbmcsIG5hbWU6IHN0cmluZywgaW5wdXRMYXlvdXQ6IFRleHR1cmVMYXlvdXQpOiBHbHNsTGliUm91dGluZSB7XG4gICAgY29uc3Qgc2hhcGUgPSBpbnB1dExheW91dC51bnBhY2tlZFNoYXBlO1xuICAgIGNvbnN0IHN0cmlkZTIgPSBzaGFwZVszXTtcbiAgICBjb25zdCBzdHJpZGUxID0gc2hhcGVbMl0gKiBzdHJpZGUyO1xuICAgIGNvbnN0IHN0cmlkZTAgPSBzaGFwZVsxXSAqIHN0cmlkZTE7XG5cbiAgICAvL1xuICAgIC8vIFRPRE86IHJlLWVuYWJsZSB0aGlzIHNob3J0Y3V0IG9uY2UgdGhlIGluZGV4IGNhbGN1bGF0aW9uIGJ1ZyBpcyBmaXhlZC5cbiAgICAvL1xuICAgIC8vIGNvbnN0IHtuZXdTaGFwZSwga2VwdERpbXN9ID0gc3F1ZWV6ZVNoYXBlKHNoYXBlIGFzIG51bWJlcltdKTtcbiAgICAvLyBpZiAobmV3U2hhcGUubGVuZ3RoIDwgc2hhcGUubGVuZ3RoKSB7XG4gICAgLy8gICBjb25zdCBuZXdJbnB1dFNoYXBlID0gc3F1ZWV6ZUlucHV0U2hhcGUoc2hhcGUsIG5ld1NoYXBlKTtcbiAgICAvLyAgIGNvbnN0IHBhcmFtcyA9IFsncm93JywgJ2NvbCcsICdkZXB0aCcsICdkZXB0aDInXTtcbiAgICAvLyAgIC8vIERlZXAgY29weSBvZiBpbnB1dCB0ZXh0dXJlIGxheW91dC5cbiAgICAvLyAgIGNvbnN0IG5ld0lucHV0TGF5b3V0OiBUZXh0dXJlTGF5b3V0ID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShpbnB1dExheW91dCkpO1xuICAgIC8vICAgbmV3SW5wdXRMYXlvdXQudW5wYWNrZWRTaGFwZSA9IG5ld0lucHV0U2hhcGU7XG4gICAgLy8gICBjb25zdCBzb3VyY2UgPSBgXG4gICAgLy8gICAgICAgJHt0aGlzLmdldFVucGFja2VkU2FtcGxlckZyb21JbnB1dChmdW5jTmFtZSwgbmFtZSwgbmV3SW5wdXRMYXlvdXQpLnJvdXRpbmVCb2R5fVxuICAgIC8vICAgICAgIGZsb2F0ICR7ZnVuY05hbWV9KGludCByb3csIGludCBjb2wsIGludCBkZXB0aCwgaW50IGRlcHRoMikge1xuICAgIC8vICAgICAgICAgcmV0dXJuICR7ZnVuY05hbWV9KCR7Z2V0U3F1ZWV6ZWRQYXJhbXMocGFyYW1zLCBrZXB0RGltcyl9KTtcbiAgICAvLyAgICAgICB9XG4gICAgLy8gICAgIGA7XG4gICAgLy8gICByZXR1cm4gbmV3IEdsc2xMaWJSb3V0aW5lKFxuICAgIC8vICAgICAgIHNvdXJjZSwgWydjb29yZGluYXRlcy51dkZyb21GbGF0JywgJ2Nvb3JkaW5hdGVzLnNhbXBsZVRleHR1cmUnLCAnY29vcmRpbmF0ZXMuY29vcmRzVG9PZmZzZXQnXSk7XG4gICAgLy8gfVxuXG4gICAgY29uc3QgdGV4TnVtUiA9IGlucHV0TGF5b3V0LndpZHRoO1xuICAgIGNvbnN0IHRleE51bUMgPSBpbnB1dExheW91dC5oZWlnaHQ7XG4gICAgY29uc3Qgc291cmNlID0gYFxuICAgICAgICBmbG9hdCAke2Z1bmNOYW1lfShpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgsIGludCBkZXB0aDIpIHtcbiAgICAgICAgICBpbnQgaW5kZXggPSByb3cgKiAke3N0cmlkZTB9ICsgY29sICogJHtzdHJpZGUxfSArXG4gICAgICAgICAgICAgIGRlcHRoMiAqICR7c3RyaWRlMn0gKyBkZXB0aDtcbiAgICAgICAgICB2ZWMyIHV2ID0gdXZGcm9tRmxhdCgke3RleE51bVJ9LCAke3RleE51bUN9LCBpbmRleCk7XG4gICAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHtuYW1lfSwgdXYpO1xuICAgICAgICB9XG4gICAgICBgO1xuICAgIHJldHVybiBuZXcgR2xzbExpYlJvdXRpbmUoc291cmNlLCBbJ2Nvb3JkaW5hdGVzLnV2RnJvbUZsYXQnLCAnY29vcmRpbmF0ZXMuc2FtcGxlVGV4dHVyZSddKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVbnBhY2tlZCA1RCBzbmlwcGV0LlxuICAgKi9cbiAgcHJvdGVjdGVkIGdldFVucGFja2VkU2FtcGxlcjVEKGZ1bmNOYW1lOiBzdHJpbmcsIG5hbWU6IHN0cmluZywgaW5wdXRMYXlvdXQ6IFRleHR1cmVMYXlvdXQpOiBHbHNsTGliUm91dGluZSB7XG4gICAgY29uc3Qgc2hhcGUgPSBpbnB1dExheW91dC51bnBhY2tlZFNoYXBlO1xuICAgIGNvbnN0IHN0cmlkZTMgPSBzaGFwZVs0XTtcbiAgICBjb25zdCBzdHJpZGUyID0gc2hhcGVbM10gKiBzdHJpZGUzO1xuICAgIGNvbnN0IHN0cmlkZTEgPSBzaGFwZVsyXSAqIHN0cmlkZTI7XG4gICAgY29uc3Qgc3RyaWRlMCA9IHNoYXBlWzFdICogc3RyaWRlMTtcblxuICAgIGNvbnN0IHtuZXdTaGFwZSwga2VwdERpbXN9ID0gc3F1ZWV6ZVNoYXBlKHNoYXBlIGFzIG51bWJlcltdKTtcbiAgICBpZiAobmV3U2hhcGUubGVuZ3RoIDwgc2hhcGUubGVuZ3RoKSB7XG4gICAgICBjb25zdCBuZXdJbnB1dFNoYXBlID0gc3F1ZWV6ZUlucHV0U2hhcGUoc2hhcGUsIG5ld1NoYXBlKTtcbiAgICAgIGNvbnN0IHBhcmFtcyA9IFsncm93JywgJ2NvbCcsICdkZXB0aCcsICdkZXB0aDInLCAnZGVwdGgzJ107XG4gICAgICAvLyBEZWVwIGNvcHkgb2YgaW5wdXQgdGV4dHVyZSBsYXlvdXQuXG4gICAgICBjb25zdCBuZXdJbnB1dExheW91dDogVGV4dHVyZUxheW91dCA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoaW5wdXRMYXlvdXQpKTtcbiAgICAgIG5ld0lucHV0TGF5b3V0LnVucGFja2VkU2hhcGUgPSBuZXdJbnB1dFNoYXBlO1xuXG4gICAgICBjb25zdCBzb3VyY2UgPSBgXG4gICAgICAgICAgJHt0aGlzLmdldFVucGFja2VkU2FtcGxlckZyb21JbnB1dChmdW5jTmFtZSwgbmFtZSwgbmV3SW5wdXRMYXlvdXQpLnJvdXRpbmVCb2R5fVxuICAgICAgICAgIGZsb2F0ICR7ZnVuY05hbWV9KGludCByb3csIGludCBjb2wsIGludCBkZXB0aCwgaW50IGRlcHRoMiwgaW50IGRlcHRoMykge1xuICAgICAgICAgICAgcmV0dXJuICR7ZnVuY05hbWV9KCR7Z2V0U3F1ZWV6ZWRQYXJhbXMocGFyYW1zLCBrZXB0RGltcyl9KTtcbiAgICAgICAgICB9XG4gICAgICAgIGA7XG4gICAgICByZXR1cm4gbmV3IEdsc2xMaWJSb3V0aW5lKHNvdXJjZSwgWydjb29yZGluYXRlcy5zYW1wbGVUZXh0dXJlJywgJ2Nvb3JkaW5hdGVzLnV2RnJvbUZsYXQnXSk7XG4gICAgfVxuXG4gICAgY29uc3QgdGV4TnVtUiA9IGlucHV0TGF5b3V0LndpZHRoO1xuICAgIGNvbnN0IHRleE51bUMgPSBpbnB1dExheW91dC5oZWlnaHQ7XG4gICAgY29uc3Qgc291cmNlID0gYFxuICAgICAgICBmbG9hdCAke2Z1bmNOYW1lfShpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgsIGludCBkZXB0aDIsIGludCBkZXB0aDMpIHtcbiAgICAgICAgICBpbnQgaW5kZXggPSByb3cgKiAke3N0cmlkZTB9ICsgY29sICogJHtzdHJpZGUxfSArIGRlcHRoICogJHtzdHJpZGUyfSArXG4gICAgICAgICAgZGVwdGgzICogJHtzdHJpZGUzfSArIGRlcHRoMjtcbiAgICAgICAgICB2ZWMyIHV2ID0gdXZGcm9tRmxhdCgke3RleE51bVJ9LCAke3RleE51bUN9LCBpbmRleCk7XG4gICAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHtuYW1lfSwgdXYpO1xuICAgICAgICB9XG4gICAgICBgO1xuICAgIHJldHVybiBuZXcgR2xzbExpYlJvdXRpbmUoc291cmNlLCBbJ2Nvb3JkaW5hdGVzLnNhbXBsZVRleHR1cmUnLCAnY29vcmRpbmF0ZXMudXZGcm9tRmxhdCddKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVbnBhY2tlZCA2RCBzbmlwcGV0LlxuICAgKi9cbiAgcHJvdGVjdGVkIGdldFVucGFja2VkU2FtcGxlcjZEKGZ1bmNOYW1lOiBzdHJpbmcsIG5hbWU6IHN0cmluZywgaW5wdXRMYXlvdXQ6IFRleHR1cmVMYXlvdXQpOiBHbHNsTGliUm91dGluZSB7XG4gICAgY29uc3Qgc2hhcGUgPSBpbnB1dExheW91dC51bnBhY2tlZFNoYXBlO1xuICAgIGNvbnN0IHN0cmlkZTQgPSBzaGFwZVs1XTtcbiAgICBjb25zdCBzdHJpZGUzID0gc2hhcGVbNF0gKiBzdHJpZGU0O1xuICAgIGNvbnN0IHN0cmlkZTIgPSBzaGFwZVszXSAqIHN0cmlkZTM7XG4gICAgY29uc3Qgc3RyaWRlMSA9IHNoYXBlWzJdICogc3RyaWRlMjtcbiAgICBjb25zdCBzdHJpZGUwID0gc2hhcGVbMV0gKiBzdHJpZGUxO1xuXG4gICAgY29uc3Qge25ld1NoYXBlLCBrZXB0RGltc30gPSBzcXVlZXplU2hhcGUoc2hhcGUgYXMgbnVtYmVyW10pO1xuICAgIGlmIChuZXdTaGFwZS5sZW5ndGggPCBzaGFwZS5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IG5ld0lucHV0U2hhcGUgPSBzcXVlZXplSW5wdXRTaGFwZShzaGFwZSwgbmV3U2hhcGUpO1xuICAgICAgY29uc3QgcGFyYW1zID0gWydyb3cnLCAnY29sJywgJ2RlcHRoJywgJ2RlcHRoMicsICdkZXB0aDMnLCAnZGVwdGg0J107XG4gICAgICAvLyBEZWVwIGNvcHkgb2YgaW5wdXQgdGV4dHVyZSBsYXlvdXQuXG4gICAgICBjb25zdCBuZXdJbnB1dExheW91dDogVGV4dHVyZUxheW91dCA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoaW5wdXRMYXlvdXQpKTtcbiAgICAgIG5ld0lucHV0TGF5b3V0LnVucGFja2VkU2hhcGUgPSBuZXdJbnB1dFNoYXBlO1xuXG4gICAgICBjb25zdCBzb3VyY2UgPSBgXG4gICAgICAgICAgICAke3RoaXMuZ2V0VW5wYWNrZWRTYW1wbGVyRnJvbUlucHV0KGZ1bmNOYW1lLCBuYW1lLCBuZXdJbnB1dExheW91dCkucm91dGluZUJvZHl9XG4gICAgICAgICAgICBmbG9hdCAke2Z1bmNOYW1lfShpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgsXG4gICAgICAgICAgICAgIGludCBkZXB0aDIsIGludCBkZXB0aDMsIGludCBkZXB0aDQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuICR7ZnVuY05hbWV9KCR7Z2V0U3F1ZWV6ZWRQYXJhbXMocGFyYW1zLCBrZXB0RGltcyl9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBgO1xuICAgICAgcmV0dXJuIG5ldyBHbHNsTGliUm91dGluZShzb3VyY2UsIFsnY29vcmRpbmF0ZXMuc2FtcGxlVGV4dHVyZScsICdjb29yZGluYXRlcy51dkZyb21GbGF0J10pO1xuICAgIH1cblxuICAgIGNvbnN0IHRleE51bVIgPSBpbnB1dExheW91dC53aWR0aDtcbiAgICBjb25zdCB0ZXhOdW1DID0gaW5wdXRMYXlvdXQuaGVpZ2h0O1xuICAgIGNvbnN0IHNvdXJjZSA9IGBcbiAgICAgICAgICBmbG9hdCAke2Z1bmNOYW1lfShpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgsXG4gICAgICAgICAgICBpbnQgZGVwdGgyLCBpbnQgZGVwdGgzLCBpbnQgZGVwdGg0KSB7XG4gICAgICAgICAgICBpbnQgaW5kZXggPSByb3cgKiAke3N0cmlkZTB9ICsgY29sICogJHtzdHJpZGUxfSArIGRlcHRoICogJHtzdHJpZGUyfSArXG4gICAgICAgICAgICBkZXB0aDIgKiAke3N0cmlkZTN9ICsgZGVwdGgzICogJHtzdHJpZGU0fSArIGRlcHRoNDtcbiAgICAgICAgICAgIHZlYzIgdXYgPSB1dkZyb21GbGF0KCR7dGV4TnVtUn0sICR7dGV4TnVtQ30sIGluZGV4KTtcbiAgICAgICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKCR7bmFtZX0sIHV2KTtcbiAgICAgICAgICB9XG4gICAgICAgIGA7XG4gICAgcmV0dXJuIG5ldyBHbHNsTGliUm91dGluZShcbiAgICAgICAgc291cmNlLCBbJ2Nvb3JkaW5hdGVzLnV2RnJvbUZsYXQnLCAnY29vcmRpbmF0ZXMuc2FtcGxlVGV4dHVyZScsICdjb29yZGluYXRlcy5jb29yZHNUb09mZnNldCddKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGlzIHRoZSBtYWluIGZ1bmN0aW9uIHRvIG1hcCBmcm9tIHRoZSBnaXZlbiB0ZXh0dXJlIGNvb3JkaWFudGVzIChzLHQpXG4gICAqIHRvIGxvZ2ljYWwgaW5kaWNlcyBmb3IgdGhlIG91dHB1dFxuICAgKiBUaGVyZSB3aWxsIG9ubHkgYmUgb25lIHNpbmdsZSB2YXJpYXRpb24gb2YgdGhpc1xuICAgKiBBbHNvIHNlZSBjb29yZHNUb09mZnNldCBhbmQgb2Zmc2V0VG9JbmRpY2VzIGZvciBpbnB1dC1zcGVjaWZpYyB2ZXJzaW9uc1xuICAgKi9cbiAgcHJvdGVjdGVkIHRvVmVjKCk6IHtbbmFtZTogc3RyaW5nXTogR2xzbExpYlJvdXRpbmV9IHtcbiAgICBjb25zdCBvdXRwdXQgPSB0aGlzLmNvbnRleHQub3V0cHV0VGV4dHVyZUxheW91dDtcbiAgICBjb25zdCByYW5rID0gb3V0cHV0LnNoYXBlLmxlbmd0aDtcbiAgICBjb25zdCBzdHJpZGVzID0gb3V0cHV0LnN0cmlkZXM7XG4gICAgY29uc3QgeFNjYWxlID0gb3V0cHV0LndpZHRoO1xuICAgIGNvbnN0IHlTY2FsZSA9IG91dHB1dC5oZWlnaHQ7XG5cbiAgICBjb25zdCBzdHJpZGVzQmxvY2sgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhbmsgLSAxOyArK2kpIHtcbiAgICAgIHN0cmlkZXNCbG9jay5wdXNoKGBcbiAgICAgICAgY1ske2l9XSA9IG9mZnNldCAvICR7c3RyaWRlc1tpXX07YCk7XG4gICAgICBzdHJpZGVzQmxvY2sucHVzaChgXG4gICAgICAgIG9mZnNldCAtPSBjWyR7aX1dICogJHtzdHJpZGVzW2ldfTtgKTtcbiAgICB9XG4gICAgc3RyaWRlc0Jsb2NrLnB1c2goYFxuICAgICAgICBjWyR7cmFuayAtIDF9XSA9IG9mZnNldDtgKTtcbiAgICBjb25zdCBib2R5ID0gYFxuICAgICAgdm9pZCB0b1ZlYyh2ZWMyIHRleENvb3Jkcywgb3V0IGludCBjWyR7cmFua31dKSB7XG4gICAgICAgIGludCBvZmZzZXQgPSBjb29yZHNUb09mZnNldCh0ZXhDb29yZHMsICR7eFNjYWxlfSwgJHt5U2NhbGV9KTtcbiAgICAgICAgJHtzdHJpZGVzQmxvY2suam9pbignJyl9XG4gICAgICB9XG4gICAgICB2b2lkIHRvVmVjKGludCBvZmZzZXQsIG91dCBpbnQgY1ske3Jhbmt9XSkge1xuICAgICAgICAke3N0cmlkZXNCbG9jay5qb2luKCcnKX1cbiAgICAgIH1cbiAgICBgO1xuICAgIHJldHVybiB7dG9WZWM6IG5ldyBHbHNsTGliUm91dGluZShib2R5LCBbJ2Nvb3JkaW5hdGVzLmNvb3Jkc1RvT2Zmc2V0J10pfTtcbiAgfVxuICAvKipcbiAgICogVGhlc2UgYXJlIHZhbHVlIGdldHRlciBmdW5jdGlvbnMgZ2VuZXJhdGVkIGZvciBlYWNoIGlucHV0XG4gICAqIEVhY2ggZnVuY3Rpb24gaXMgaGFyZHdpcmVkIHRvIHRoZSBuYW1lIGFuZCBkaW1lbnNpb25zIG9mIHRoZSBpbnB1dFxuICAgKiBBbiAnX1QnIHZhcmlhdGlvbiBpcyBhbHNvIHByb2R1Y2VkIHdoaWNoIGFjY2Vzc2VzIHZhbHVlcyBhcyBpZiB0aGVcbiAgICogaW5wdXQgd2FzIHRyYW5zcG9zZWRcbiAgICovXG4gIHByb3RlY3RlZCB2YWx1ZUZyb20oKToge1tuYW1lOiBzdHJpbmddOiBHbHNsTGliUm91dGluZX0ge1xuICAgIGNvbnN0IHJlc3VsdDoge1tuYW1lOiBzdHJpbmddOiBHbHNsTGliUm91dGluZX0gPSB7fTtcbiAgICB0aGlzLmNvbnRleHQucHJvZ3JhbUluZm8uaW5wdXROYW1lcy5mb3JFYWNoKChuYW1lLCBpKSA9PiB7XG4gICAgICBjb25zdCBsYXlvdXQgPSB0aGlzLmNvbnRleHQuaW5wdXRUZXh0dXJlTGF5b3V0c1tpXTtcbiAgICAgIGNvbnN0IHNoYXBlID0gbGF5b3V0LnVucGFja2VkU2hhcGUubGVuZ3RoID4gMCA/IGxheW91dC51bnBhY2tlZFNoYXBlIDogbGF5b3V0LnNoYXBlO1xuICAgICAgY29uc3QgcmFuayA9IHNoYXBlLmxlbmd0aDtcbiAgICAgIGxldCBmdW5jTmFtZSA9IGBfJHtuYW1lfWA7XG4gICAgICByZXN1bHRbZnVuY05hbWVdID0gbmV3IEdsc2xMaWJSb3V0aW5lKFxuICAgICAgICAgIHRoaXMuZ2V0VmFsdWVGcm9tU2luZ2xlKG5hbWUsIHJhbmssIGxheW91dC53aWR0aCwgbGF5b3V0LmhlaWdodCwgZmFsc2UpLFxuICAgICAgICAgIFtgc2hhcGVVdGlscy5pbmRpY2VzVG9PZmZzZXQke2Z1bmNOYW1lfWAsICdjb29yZGluYXRlcy5vZmZzZXRUb0Nvb3JkcycsICdmcmFnY29sb3IuZ2V0Q29sb3JBc0Zsb2F0J10pO1xuICAgICAgZnVuY05hbWUgPSBmdW5jTmFtZSArICdfVCc7XG4gICAgICByZXN1bHRbZnVuY05hbWVdID0gbmV3IEdsc2xMaWJSb3V0aW5lKFxuICAgICAgICAgIHRoaXMuZ2V0VmFsdWVGcm9tU2luZ2xlKG5hbWUsIHJhbmssIGxheW91dC53aWR0aCwgbGF5b3V0LmhlaWdodCwgdHJ1ZSksXG4gICAgICAgICAgW2BzaGFwZVV0aWxzLmluZGljZXNUb09mZnNldCR7ZnVuY05hbWV9YCwgJ2Nvb3JkaW5hdGVzLm9mZnNldFRvQ29vcmRzJywgJ2ZyYWdjb2xvci5nZXRDb2xvckFzRmxvYXQnXSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICAvKipcbiAgICogUHJvZHVjZXMgb25lIHZhbHVlIGdldHRlciBmdW5jdGlvbiBmb3IgdGhlIG5hbWUgYW5kIHJhbmsgZ2l2ZW5cbiAgICogSWYgYSB0cmFuc3Bvc2UgaXMgc2V0IHByb3BlciBvZmZzZXRUb0Nvb3JkcyBtYXBwaW5nIHdpbGwgYmUgdXNlZFxuICAgKiBAcGFyYW0gbmFtZSBuYW1lIG9mIHRoZSBmdW5jdGlvblxuICAgKiBAcGFyYW0gcmFuayByYW5rIG9mIHRoZSBpbnB1dFxuICAgKiBAcGFyYW0gdHJhbnNwb3NlIHdoZXRoZXIgb3Igbm90IHNob3VsZCBnZW5lcmF0ZSBhIHRyYW5zcG9zZSB2YXJpYXRpb25cbiAgICovXG4gIHByb3RlY3RlZCBnZXRWYWx1ZUZyb21TaW5nbGUodmFyTmFtZTogc3RyaW5nLCByYW5rOiBudW1iZXIsIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyLCB0cmFuc3Bvc2U6IGJvb2xlYW4pOlxuICAgICAgc3RyaW5nIHtcbiAgICBsZXQgbmFtZSA9IGBfJHt2YXJOYW1lfWA7XG4gICAgaWYgKHRyYW5zcG9zZSkge1xuICAgICAgbmFtZSA9IG5hbWUgKyAnX1QnO1xuICAgIH1cbiAgICBjb25zdCBnbHNsID0gZ2V0R2xzbCh0aGlzLmNvbnRleHQuZ2xDb250ZXh0LnZlcnNpb24pO1xuICAgIHJldHVybiBgXG4gICAgICAgIGZsb2F0ICR7bmFtZX0oaW50IG1bJHtyYW5rfV0pIHtcbiAgICAgICAgICBpbnQgb2Zmc2V0ID0gaW5kaWNlc1RvT2Zmc2V0JHtuYW1lfShtKTtcbiAgICAgICAgICB2ZWMyIGNvb3JkcyA9IG9mZnNldFRvQ29vcmRzKG9mZnNldCwgJHt3aWR0aH0sICR7aGVpZ2h0fSk7XG4gICAgICAgICAgZmxvYXQgdmFsdWUgPSBnZXRDb2xvckFzRmxvYXQoJHtnbHNsLnRleHR1cmUyRH0oJHt2YXJOYW1lfSwgY29vcmRzKSk7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGA7XG4gIH1cblxuICAvKipcbiAgICogUHJvZHVjZXMgYSBwYWNrZWQgdmFsdWUgZ2V0dGVyIGZ1bmN0aW9uIGZvciB0aGUgbmFtZSBhbmQgcmFuayBnaXZlblxuICAgKiBJZiBhIHRyYW5zcG9zZSBpcyBzZXQgcHJvcGVyIG9mZnNldFRvQ29vcmRzIG1hcHBpbmcgd2lsbCBiZSB1c2VkXG4gICAqIEBwYXJhbSBuYW1lIG5hbWUgb2YgdGhlIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSByYW5rIHJhbmsgb2YgdGhlIGlucHV0XG4gICAqIEBwYXJhbSB0cmFuc3Bvc2Ugd2hldGhlciBvciBub3Qgc2hvdWxkIGdlbmVyYXRlIGEgdHJhbnNwb3NlIHZhcmlhdGlvblxuICAgKi9cbiAgcHJvdGVjdGVkIGdldFBhY2tlZFZhbHVlRnJvbSh2YXJOYW1lOiBzdHJpbmcsIHJhbms6IG51bWJlciwgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIsIHRyYW5zcG9zZTogYm9vbGVhbik6XG4gICAgICBzdHJpbmcge1xuICAgIGxldCBuYW1lID0gYF8ke3Zhck5hbWV9X1BhY2tgO1xuICAgIGlmICh0cmFuc3Bvc2UpIHtcbiAgICAgIG5hbWUgPSBuYW1lICsgJ19UJztcbiAgICB9XG4gICAgY29uc3QgZ2xzbCA9IGdldEdsc2wodGhpcy5jb250ZXh0LmdsQ29udGV4dC52ZXJzaW9uKTtcbiAgICByZXR1cm4gYFxuICAgICAgICB2ZWM0ICR7bmFtZX0oaW50IG1bJHtyYW5rfV0pIHtcbiAgICAgICAgICBpbnQgb2Zmc2V0ID0gaW5kaWNlc1RvT2Zmc2V0XyR7dmFyTmFtZX0obSk7XG4gICAgICAgICAgdmVjMiBjb29yZHMgPSBvZmZzZXRUb0Nvb3JkcyhvZmZzZXQsICR7d2lkdGh9LCAke2hlaWdodH0pO1xuICAgICAgICAgIHJldHVybiAke2dsc2wudGV4dHVyZTJEfSgke3Zhck5hbWV9LCBjb29yZHMpO1xuICAgICAgICB9XG4gICAgICAgIGA7XG4gIH1cbn1cbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtHbHNsQ29udGV4dCwgR2xzbExpYiwgR2xzbExpYlJvdXRpbmV9IGZyb20gJy4vZ2xzbC1kZWZpbml0aW9ucyc7XG5cbi8qKlxuICogVGhpcyBHTFNMIGxpYnJhcnkgaGFuZGxlcyByb3V0aW5lcyBjb252ZXJ0aW5nXG4gKiBmbG9hdDMyIHRvL2Zyb20gVW5zaWduZWQgYnl0ZSBvciBmbG9hdCAxNlxuICovXG5leHBvcnQgY2xhc3MgRW5jb2RpbmdHbHNsTGliIGV4dGVuZHMgR2xzbExpYiB7XG4gIGNvbnN0cnVjdG9yKGNvbnRleHQ6IEdsc2xDb250ZXh0KSB7XG4gICAgc3VwZXIoY29udGV4dCk7XG4gIH1cbiAgZ2V0RnVuY3Rpb25zKCk6IHtbbmFtZTogc3RyaW5nXTogR2xzbExpYlJvdXRpbmV9IHtcbiAgICByZXR1cm4gey4uLnRoaXMuZW5jb2RlRmxvYXQzMigpLCAuLi50aGlzLmRlY29kZUZsb2F0MzIoKX07XG4gIH1cbiAgZ2V0Q3VzdG9tVHlwZXMoKToge1tuYW1lOiBzdHJpbmddOiBzdHJpbmd9IHtcbiAgICByZXR1cm4ge307XG4gIH1cbiAgcHJvdGVjdGVkIGVuY29kZUZsb2F0MzIoKToge1tuYW1lOiBzdHJpbmddOiBHbHNsTGliUm91dGluZX0ge1xuICAgIHJldHVybiB7XG4gICAgICBlbmNvZGU6IG5ldyBHbHNsTGliUm91dGluZShgaGlnaHAgdmVjNCBlbmNvZGUoaGlnaHAgZmxvYXQgZikge1xuICAgICAgICByZXR1cm4gdmVjNChmLCAwLjAsIDAuMCwgMC4wKTtcbiAgICAgIH1cbiAgICAgICAgYClcbiAgICB9O1xuICB9XG4gIHByb3RlY3RlZCBkZWNvZGVGbG9hdDMyKCk6IHtbbmFtZTogc3RyaW5nXTogR2xzbExpYlJvdXRpbmV9IHtcbiAgICByZXR1cm4ge1xuICAgICAgZGVjb2RlOiBuZXcgR2xzbExpYlJvdXRpbmUoYGhpZ2hwIGZsb2F0IGRlY29kZShoaWdocCB2ZWM0IHJnYmEpIHtcbiAgICAgICAgcmV0dXJuIHJnYmEucjtcbiAgICAgIH1cbiAgICAgICAgYClcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiByZXR1cm5zIHRoZSByb3V0aW5lIHRvIGVuY29kZSBlbmNvZGUgYSAzMmJpdCBmbG9hdCB0byBhIHZlYzQgKG9mIHVuc2lnbmVkIGJ5dGVzKVxuICAgKiBAY3JlZGl0OiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy83MDU5OTYyL2hvdy1kby1pLWNvbnZlcnQtYS12ZWM0LXJnYmEtdmFsdWUtdG8tYS1mbG9hdFxuICAgKi9cbiAgcHJvdGVjdGVkIGVuY29kZVVpbnQ4KCk6IHtbbmFtZTogc3RyaW5nXTogR2xzbExpYlJvdXRpbmV9IHtcbiAgICBjb25zdCBlbmRpYW5uZXNzID0gRW5jb2RpbmdHbHNsTGliLmlzTGl0dGxlRW5kaWFuKCkgPyAncmdiYS5yZ2JhPXJnYmEuYWJncjsnIDogJyc7XG4gICAgcmV0dXJuIHtcbiAgICAgIGVuY29kZTogbmV3IEdsc2xMaWJSb3V0aW5lKGBcbiAgICAgIGhpZ2hwIHZlYzQgZW5jb2RlKGhpZ2hwIGZsb2F0IGYpIHtcbiAgICAgICAgaGlnaHAgZmxvYXQgRiA9IGFicyhmKTtcbiAgICAgICAgaGlnaHAgZmxvYXQgU2lnbiA9IHN0ZXAoMC4wLC1mKTtcbiAgICAgICAgaGlnaHAgZmxvYXQgRXhwb25lbnQgPSBmbG9vcihsb2cyKEYpKTtcbiAgICAgICAgaGlnaHAgZmxvYXQgTWFudGlzc2EgPSAoZXhwMigtIEV4cG9uZW50KSAqIEYpO1xuICAgICAgICBFeHBvbmVudCA9IGZsb29yKGxvZzIoRikgKyAxMjcuMCkgKyBmbG9vcihsb2cyKE1hbnRpc3NhKSk7XG4gICAgICAgIGhpZ2hwIHZlYzQgcmdiYTtcbiAgICAgICAgcmdiYVswXSA9IDEyOC4wICogU2lnbiAgKyBmbG9vcihFeHBvbmVudCpleHAyKC0xLjApKTtcbiAgICAgICAgcmdiYVsxXSA9IDEyOC4wICogbW9kKEV4cG9uZW50LDIuMCkgKyBtb2QoZmxvb3IoTWFudGlzc2EqMTI4LjApLDEyOC4wKTtcbiAgICAgICAgcmdiYVsyXSA9IGZsb29yKG1vZChmbG9vcihNYW50aXNzYSpleHAyKDIzLjAgLTguMCkpLGV4cDIoOC4wKSkpO1xuICAgICAgICByZ2JhWzNdID0gZmxvb3IoZXhwMigyMy4wKSptb2QoTWFudGlzc2EsZXhwMigtMTUuMCkpKTtcbiAgICAgICAgJHtlbmRpYW5uZXNzfVxuICAgICAgICByZ2JhID0gcmdiYSAvIDI1NS4wOyAvLyB2YWx1ZXMgbmVlZCB0byBiZSBub3JtYWxpemVkIHRvIFswLDFdXG4gICAgICAgIHJldHVybiByZ2JhO1xuICAgIH1cbiAgICAgICAgYClcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiByZXR1cm5zIHRoZSByb3V0aW5lIHRvIGVuY29kZSBhIHZlYzQgb2YgdW5zaWduZWQgYnl0ZXMgdG8gZmxvYXQzMlxuICAgKiBAY3JlZGl0OiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy83MDU5OTYyL2hvdy1kby1pLWNvbnZlcnQtYS12ZWM0LXJnYmEtdmFsdWUtdG8tYS1mbG9hdFxuICAgKi9cbiAgcHJvdGVjdGVkIGRlY29kZVVpbnQ4KCk6IHtbbmFtZTogc3RyaW5nXTogR2xzbExpYlJvdXRpbmV9IHtcbiAgICBjb25zdCBlbmRpYW5uZXNzID0gRW5jb2RpbmdHbHNsTGliLmlzTGl0dGxlRW5kaWFuKCkgPyAncmdiYS5yZ2JhPXJnYmEuYWJncjsnIDogJyc7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRlY29kZTogbmV3IEdsc2xMaWJSb3V0aW5lKGBcbiAgICAgICAgaGlnaHAgZmxvYXQgZGVjb2RlKGhpZ2hwIHZlYzQgcmdiYSkge1xuICAgICAgICAgIHJnYmEgPSByZ2JhICogMjU1LjA7IC8vIHZhbHVlcyBuZWVkIHRvIGJlIGRlLW5vcm1hbGl6ZWQgZnJvbSBbMCwxXSB0byBbMCwyNTVdXG4gICAgICAgICAgJHtlbmRpYW5uZXNzfVxuICAgICAgICAgIGhpZ2hwIGZsb2F0IFNpZ24gPSAxLjAgLSBzdGVwKDEyOC4wLHJnYmFbMF0pKjIuMDtcbiAgICAgICAgICBoaWdocCBmbG9hdCBFeHBvbmVudCA9IDIuMCAqIG1vZChyZ2JhWzBdLDEyOC4wKSArIHN0ZXAoMTI4LjAscmdiYVsxXSkgLSAxMjcuMDtcbiAgICAgICAgICBoaWdocCBmbG9hdCBNYW50aXNzYSA9IG1vZChyZ2JhWzFdLDEyOC4wKSo2NTUzNi4wICsgcmdiYVsyXSoyNTYuMCArcmdiYVszXSArIGZsb2F0KDB4ODAwMDAwKTtcbiAgICAgICAgICBoaWdocCBmbG9hdCBSZXN1bHQgPSAgU2lnbiAqIGV4cDIoRXhwb25lbnQpICogKE1hbnRpc3NhICogZXhwMigtMjMuMCApKTtcbiAgICAgICAgICByZXR1cm4gUmVzdWx0O1xuICAgICAgfVxuICAgICAgICBgKVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIERldGVybWluZXMgaWYgdGhlIG1hY2hpbmUgaXMgbGl0dGxlIGVuZGlhbiBvciBub3RcbiAgICogQGNyZWRpdDogaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vVG9vVGFsbE5hdGUvNDc1MDk1M1xuICAgKi9cbiAgc3RhdGljIGlzTGl0dGxlRW5kaWFuKCk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IGIgPSBuZXcgQXJyYXlCdWZmZXIoNCk7XG4gICAgY29uc3QgYSA9IG5ldyBVaW50MzJBcnJheShiKTtcbiAgICBjb25zdCBjID0gbmV3IFVpbnQ4QXJyYXkoYik7XG4gICAgYVswXSA9IDB4ZGVhZGJlZWY7XG4gICAgaWYgKGNbMF0gPT09IDB4ZWYpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoY1swXSA9PT0gMHhkZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24gZW5kaWFubmVzcycpO1xuICB9XG59XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7R2xzbENvbnRleHQsIEdsc2xMaWIsIEdsc2xMaWJSb3V0aW5lfSBmcm9tICcuL2dsc2wtZGVmaW5pdGlvbnMnO1xuaW1wb3J0IHtnZXRHbHNsfSBmcm9tICcuL2dsc2wtc291cmNlJztcblxuLyoqXG4gKiBUaGlzIEdMU0wgbGlicmFyeSBoYW5kbGVzIHJvdXRpbmVzIGFyb3VuZCByZWFkaW5nIGEgdGV4bGV0IGFuZCB3cml0aW5nIHRvIGl0XG4gKiBSZWFkaW5nIGFuZCB3cml0aW5nIGNvdWxkIGJlIG1vcmUgdGhhbiBqdXN0IGRlYWxpbmcgd2l0aCBvbmUgY2hhbm5lbFxuICogSXQgbWF5IHJlcXVpcmUgZW5jb2RpbmcvZGVjb2RpbmcgdG8vZnJvbSA0IGNoYW5uZWxzIGludG8gb25lXG4gKi9cbmV4cG9ydCBjbGFzcyBGcmFnQ29sb3JHbHNsTGliIGV4dGVuZHMgR2xzbExpYiB7XG4gIGNvbnN0cnVjdG9yKGNvbnRleHQ6IEdsc2xDb250ZXh0KSB7XG4gICAgc3VwZXIoY29udGV4dCk7XG4gIH1cbiAgZ2V0RnVuY3Rpb25zKCk6IHtbbmFtZTogc3RyaW5nXTogR2xzbExpYlJvdXRpbmV9IHtcbiAgICByZXR1cm4gey4uLnRoaXMuc2V0RnJhZ0NvbG9yKCksIC4uLnRoaXMuZ2V0Q29sb3JBc0Zsb2F0KCl9O1xuICB9XG4gIGdldEN1c3RvbVR5cGVzKCk6IHtbbmFtZTogc3RyaW5nXTogc3RyaW5nfSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG4gIHByb3RlY3RlZCBzZXRGcmFnQ29sb3IoKToge1tuYW1lOiBzdHJpbmddOiBHbHNsTGliUm91dGluZX0ge1xuICAgIGNvbnN0IGdsc2wgPSBnZXRHbHNsKHRoaXMuY29udGV4dC5nbENvbnRleHQudmVyc2lvbik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNldEZyYWdDb2xvcjogbmV3IEdsc2xMaWJSb3V0aW5lKFxuICAgICAgICAgIGBcbiAgICAgICAgdm9pZCBzZXRGcmFnQ29sb3IoZmxvYXQgdmFsdWUpIHtcbiAgICAgICAgICAgICR7Z2xzbC5vdXRwdXR9ID0gZW5jb2RlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBgLFxuICAgICAgICAgIFsnZW5jb2RpbmcuZW5jb2RlJ10pXG4gICAgfTtcbiAgfVxuICBwcm90ZWN0ZWQgZ2V0Q29sb3JBc0Zsb2F0KCk6IHtbbmFtZTogc3RyaW5nXTogR2xzbExpYlJvdXRpbmV9IHtcbiAgICByZXR1cm4ge1xuICAgICAgZ2V0Q29sb3JBc0Zsb2F0OiBuZXcgR2xzbExpYlJvdXRpbmUoXG4gICAgICAgICAgYFxuICAgICAgICBmbG9hdCBnZXRDb2xvckFzRmxvYXQodmVjNCBjb2xvcikge1xuICAgICAgICAgICAgcmV0dXJuIGRlY29kZShjb2xvcik7XG4gICAgICAgIH1cbiAgICAgICAgYCxcbiAgICAgICAgICBbJ2VuY29kaW5nLmRlY29kZSddKVxuICAgIH07XG4gIH1cbn1cbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtHbHNsQ29udGV4dCwgR2xzbExpYiwgR2xzbExpYlJvdXRpbmV9IGZyb20gJy4vZ2xzbC1kZWZpbml0aW9ucyc7XG5cbi8qKlxuICogR0xTTCBMaWJyYXJ5IHJlc3BvbnNpYmxlIGZvciBkYXRhIHR5cGVzIGFuZCByb3V0aW5lcyBmb3IgbWFuaXB1bGF0aW5nXG4gKiBjb29yZGluYXRlcyBhbmQgbWFwcGluZyB0by9mcm9tIHRlbnNvciBpbmRpY2VzXG4gKi9cbmV4cG9ydCBjbGFzcyBTaGFwZVV0aWxzR2xzbExpYiBleHRlbmRzIEdsc2xMaWIge1xuICBjb25zdHJ1Y3Rvcihjb250ZXh0OiBHbHNsQ29udGV4dCkge1xuICAgIHN1cGVyKGNvbnRleHQpO1xuICB9XG4gIGdldEZ1bmN0aW9ucygpOiB7W25hbWU6IHN0cmluZ106IEdsc2xMaWJSb3V0aW5lfSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnRoaXMuYmNhc3RJbmRleCgpLFxuICAgICAgLi4udGhpcy5iY2FzdE1hdG11bEluZGV4KCksXG4gICAgICAuLi50aGlzLm9mZnNldFRvSW5kaWNlcygpLFxuICAgICAgLi4udGhpcy5pbmRpY2VzVG9PZmZzZXQoKSxcbiAgICAgIC4uLnRoaXMuaW5jcmVtZW50SW5kaWNlcygpXG4gICAgfTtcbiAgfVxuICBnZXRDdXN0b21UeXBlcygpIHtcbiAgICByZXR1cm4ge307XG4gIH1cbiAgcHJvdGVjdGVkIGJjYXN0SW5kZXgoKToge1tuYW1lOiBzdHJpbmddOiBHbHNsTGliUm91dGluZX0ge1xuICAgIGNvbnN0IG91dHB1dFJhbmsgPSB0aGlzLmNvbnRleHQub3V0cHV0VGV4dHVyZUxheW91dC5zaGFwZS5sZW5ndGg7XG4gICAgY29uc3QgcmVzdWx0OiB7W25hbWU6IHN0cmluZ106IEdsc2xMaWJSb3V0aW5lfSA9IHt9O1xuICAgIHRoaXMuY29udGV4dC5wcm9ncmFtSW5mby5pbnB1dE5hbWVzLmZvckVhY2goKG5hbWUsIGkpID0+IHtcbiAgICAgIGNvbnN0IHNoYXBlID0gdGhpcy5jb250ZXh0LmlucHV0VGV4dHVyZUxheW91dHNbaV0udW5wYWNrZWRTaGFwZTtcbiAgICAgIGlmIChzaGFwZS5sZW5ndGggPD0gb3V0cHV0UmFuaykge1xuICAgICAgICBjb25zdCByYW5rID0gc2hhcGUubGVuZ3RoO1xuICAgICAgICBjb25zdCBkaW1PZmZzZXQgPSBvdXRwdXRSYW5rIC0gcmFuaztcbiAgICAgICAgY29uc3QgZnVuY05hbWUgPSBgYmNhc3RJbmRpY2VzXyR7bmFtZX1gO1xuICAgICAgICBsZXQgYmxvY2sgPSAnJztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5rOyArK2kpIHtcbiAgICAgICAgICBibG9jayArPSBgXG4gICAgICAgICAgcmVhbEluZGljZXNbJHtpfV0gPSBpbnQoIG1vZChmbG9hdChiY2FzdGVkSW5kaWNlc1ske2RpbU9mZnNldCArIGl9XSksICR7c2hhcGVbaV19LjApICk7XG4gICAgICAgICAgYDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBib2R5ID0gYFxuICAgICAgICB2b2lkICR7ZnVuY05hbWV9IChpbnQgYmNhc3RlZEluZGljZXNbJHtvdXRwdXRSYW5rfV0sIG91dCBpbnQgcmVhbEluZGljZXNbJHtyYW5rfV0pIHtcbiAgICAgICAgICAke2Jsb2NrfVxuICAgICAgICB9XG4gICAgICAgIGA7XG4gICAgICAgIHJlc3VsdFtmdW5jTmFtZV0gPSBuZXcgR2xzbExpYlJvdXRpbmUoYm9keSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBwcm90ZWN0ZWQgYmNhc3RNYXRtdWxJbmRleCgpOiB7W25hbWU6IHN0cmluZ106IEdsc2xMaWJSb3V0aW5lfSB7XG4gICAgY29uc3Qgb3V0cHV0UmFuayA9IHRoaXMuY29udGV4dC5vdXRwdXRUZXh0dXJlTGF5b3V0LnNoYXBlLmxlbmd0aDtcbiAgICBjb25zdCByZXN1bHQ6IHtbbmFtZTogc3RyaW5nXTogR2xzbExpYlJvdXRpbmV9ID0ge307XG4gICAgdGhpcy5jb250ZXh0LnByb2dyYW1JbmZvLmlucHV0TmFtZXMuZm9yRWFjaCgobmFtZSwgaSkgPT4ge1xuICAgICAgY29uc3Qgc2hhcGUgPSB0aGlzLmNvbnRleHQuaW5wdXRUZXh0dXJlTGF5b3V0c1tpXS5zaGFwZTtcbiAgICAgIGlmICghKHNoYXBlLmxlbmd0aCA8IDIgfHwgc2hhcGUubGVuZ3RoID4gb3V0cHV0UmFuaykpIHtcbiAgICAgICAgY29uc3QgcmFuayA9IHNoYXBlLmxlbmd0aDtcbiAgICAgICAgY29uc3QgZGltT2Zmc2V0ID0gb3V0cHV0UmFuayAtIHJhbms7XG4gICAgICAgIGNvbnN0IGZ1bmNOYW1lID0gYGJjYXN0TWF0bXVsSW5kaWNlc18ke25hbWV9YDtcbiAgICAgICAgbGV0IGJsb2NrID0gJyc7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuayAtIDI7ICsraSkge1xuICAgICAgICAgIGJsb2NrICs9IGBcbiAgICAgICAgICByZWFsSW5kaWNlc1ske2l9XSA9IGludCggbW9kKGZsb2F0KGJjYXN0ZWRJbmRpY2VzWyR7ZGltT2Zmc2V0ICsgaX1dKSwgJHtzaGFwZVtpXX0uMCkgKTtcbiAgICAgICAgICBgO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJvZHkgPSBgXG4gICAgICAgIHZvaWQgJHtmdW5jTmFtZX0oaW50IGJjYXN0ZWRJbmRpY2VzWyR7b3V0cHV0UmFua31dLCBvdXQgaW50IHJlYWxJbmRpY2VzWyR7cmFua31dKSB7XG4gICAgICAgICAgJHtibG9ja31cbiAgICAgICAgICByZWFsSW5kaWNlc1ske3JhbmsgLSAxfV0gPSBiY2FzdGVkSW5kaWNlc1ske291dHB1dFJhbmsgLSAxfV07XG4gICAgICAgICAgcmVhbEluZGljZXNbJHtyYW5rIC0gMn1dID0gYmNhc3RlZEluZGljZXNbJHtvdXRwdXRSYW5rIC0gMn1dO1xuICAgICAgICB9XG4gICAgICAgIGA7XG4gICAgICAgIHJlc3VsdFtmdW5jTmFtZV0gPSBuZXcgR2xzbExpYlJvdXRpbmUoYm9keSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBwcm90ZWN0ZWQgaW5kaWNlc1RvT2Zmc2V0KCk6IHtbbmFtZTogc3RyaW5nXTogR2xzbExpYlJvdXRpbmV9IHtcbiAgICBjb25zdCByZXN1bHQ6IHtbbmFtZTogc3RyaW5nXTogR2xzbExpYlJvdXRpbmV9ID0ge307XG4gICAgdGhpcy5jb250ZXh0LnByb2dyYW1JbmZvLmlucHV0TmFtZXMuZm9yRWFjaCgobmFtZSwgaSkgPT4ge1xuICAgICAgY29uc3Qgc2hhcGUgPSB0aGlzLmNvbnRleHQuaW5wdXRUZXh0dXJlTGF5b3V0c1tpXS5zaGFwZTtcbiAgICAgIGNvbnN0IHN0cmlkZXMgPSB0aGlzLmNvbnRleHQuaW5wdXRUZXh0dXJlTGF5b3V0c1tpXS5zdHJpZGVzO1xuICAgICAgY29uc3QgcmFuayA9IHNoYXBlLmxlbmd0aDtcbiAgICAgIGxldCBmdW5jTmFtZSA9IGBpbmRpY2VzVG9PZmZzZXRfJHtuYW1lfWA7XG4gICAgICByZXN1bHRbZnVuY05hbWVdID0gbmV3IEdsc2xMaWJSb3V0aW5lKFNoYXBlVXRpbHNHbHNsTGliLmluZGV4VG9PZmZzZXRTaW5nbGUoZnVuY05hbWUsIHJhbmssIHN0cmlkZXMpKTtcbiAgICAgIGZ1bmNOYW1lID0gYGluZGljZXNUb09mZnNldF8ke25hbWV9X1RgO1xuICAgICAgcmVzdWx0W2Z1bmNOYW1lXSA9XG4gICAgICAgICAgbmV3IEdsc2xMaWJSb3V0aW5lKFNoYXBlVXRpbHNHbHNsTGliLmluZGV4VG9PZmZzZXRTaW5nbGUoZnVuY05hbWUsIHJhbmssIHN0cmlkZXMuc2xpY2UoKS5yZXZlcnNlKCkpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHN0YXRpYyBpbmRleFRvT2Zmc2V0U2luZ2xlKG5hbWU6IHN0cmluZywgcmFuazogbnVtYmVyLCBzdHJpZGVzOiByZWFkb25seSBudW1iZXJbXSk6IHN0cmluZyB7XG4gICAgbGV0IGJsb2NrID0gJyc7XG4gICAgZm9yIChsZXQgaSA9IHJhbmsgLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgYmxvY2sgKz0gYFxuICAgICAgICBvZmZzZXQgKz0gaW5kaWNlc1ske2l9XSAqICR7c3RyaWRlc1tpXX07XG4gICAgICAgIGA7XG4gICAgfVxuICAgIHJldHVybiBgXG4gICAgICBpbnQgJHtuYW1lfShpbnQgaW5kaWNlc1ske3Jhbmt9XSkge1xuICAgICAgICBpbnQgb2Zmc2V0ID0gMDtcbiAgICAgICAgJHtibG9ja31cbiAgICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICAgIH1cbiAgICAgIGA7XG4gIH1cbiAgcHJvdGVjdGVkIG9mZnNldFRvSW5kaWNlcygpOiB7W25hbWU6IHN0cmluZ106IEdsc2xMaWJSb3V0aW5lfSB7XG4gICAgY29uc3QgcmVzdWx0OiB7W25hbWU6IHN0cmluZ106IEdsc2xMaWJSb3V0aW5lfSA9IHt9O1xuICAgIHRoaXMuY29udGV4dC5wcm9ncmFtSW5mby5pbnB1dE5hbWVzLmZvckVhY2goKG5hbWUsIGkpID0+IHtcbiAgICAgIGNvbnN0IHNoYXBlID0gdGhpcy5jb250ZXh0LmlucHV0VGV4dHVyZUxheW91dHNbaV0uc2hhcGU7XG4gICAgICBjb25zdCBzdHJpZGVzID0gdGhpcy5jb250ZXh0LmlucHV0VGV4dHVyZUxheW91dHNbaV0uc3RyaWRlcztcbiAgICAgIGNvbnN0IHJhbmsgPSBzaGFwZS5sZW5ndGg7XG4gICAgICBsZXQgZnVuY05hbWUgPSBgb2Zmc2V0VG9JbmRpY2VzXyR7bmFtZX1gO1xuICAgICAgcmVzdWx0W2Z1bmNOYW1lXSA9IG5ldyBHbHNsTGliUm91dGluZShTaGFwZVV0aWxzR2xzbExpYi5vZmZzZXRUb0luZGljZXNTaW5nbGUoZnVuY05hbWUsIHJhbmssIHN0cmlkZXMpKTtcbiAgICAgIGZ1bmNOYW1lID0gYG9mZnNldFRvSW5kaWNlc18ke25hbWV9X1RgO1xuICAgICAgcmVzdWx0W2Z1bmNOYW1lXSA9XG4gICAgICAgICAgbmV3IEdsc2xMaWJSb3V0aW5lKFNoYXBlVXRpbHNHbHNsTGliLm9mZnNldFRvSW5kaWNlc1NpbmdsZShmdW5jTmFtZSwgcmFuaywgc3RyaWRlcy5zbGljZSgpLnJldmVyc2UoKSkpO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgc3RhdGljIG9mZnNldFRvSW5kaWNlc1NpbmdsZShuYW1lOiBzdHJpbmcsIHJhbms6IG51bWJlciwgc3RyaWRlczogcmVhZG9ubHkgbnVtYmVyW10pOiBzdHJpbmcge1xuICAgIGNvbnN0IHN0cmlkZXNCbG9jayA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuayAtIDE7ICsraSkge1xuICAgICAgc3RyaWRlc0Jsb2NrLnB1c2goYFxuICAgICAgaW5kaWNlc1ske2l9XSA9IG9mZnNldCAvICR7c3RyaWRlc1tpXX07YCk7XG4gICAgICBzdHJpZGVzQmxvY2sucHVzaChgXG4gICAgICAgIG9mZnNldCAtPSBpbmRpY2VzWyR7aX1dICogJHtzdHJpZGVzW2ldfTtgKTtcbiAgICB9XG4gICAgc3RyaWRlc0Jsb2NrLnB1c2goYFxuICAgICAgaW5kaWNlc1ske3JhbmsgLSAxfV0gPSBvZmZzZXQ7YCk7XG4gICAgcmV0dXJuIGBcbiAgICAgIHZvaWQgJHtuYW1lfShpbnQgb2Zmc2V0LCBvdXQgaW50IGluZGljZXNbJHtyYW5rfV0pIHtcbiAgICAgICAgJHtzdHJpZGVzQmxvY2suam9pbignJyl9XG4gICAgICB9XG4gICAgICBgO1xuICB9XG4gIHByb3RlY3RlZCBpbmNyZW1lbnRJbmRpY2VzKCk6IHtbbmFtZTogc3RyaW5nXTogR2xzbExpYlJvdXRpbmV9IHtcbiAgICBjb25zdCByZXN1bHQ6IHtbbmFtZTogc3RyaW5nXTogR2xzbExpYlJvdXRpbmV9ID0ge307XG4gICAgdGhpcy5jb250ZXh0LnByb2dyYW1JbmZvLmlucHV0TmFtZXMuZm9yRWFjaCgobmFtZSwgaSkgPT4ge1xuICAgICAgY29uc3Qgc2hhcGUgPSB0aGlzLmNvbnRleHQuaW5wdXRUZXh0dXJlTGF5b3V0c1tpXS5zaGFwZTtcbiAgICAgIGNvbnN0IHJhbmsgPSBzaGFwZS5sZW5ndGg7XG4gICAgICBjb25zdCBmdW5jTmFtZSA9IGBpbmNyZW1lbnRJbmRpY2VzXyR7bmFtZX1gO1xuICAgICAgbGV0IHNoYXBlSW5pdCA9ICcnO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5rOyArK2kpIHtcbiAgICAgICAgc2hhcGVJbml0ICs9IGBcbiAgICAgICAgc2hhcGVbJHtpfV0gPSAke3NoYXBlW2ldfTtgO1xuICAgICAgfVxuICAgICAgY29uc3QgYm9keSA9IGBcbiAgICAgICAgdm9pZCAke2Z1bmNOYW1lfShpbnQgYXhpcywgb3V0IGludCBpbmRpY2VzWyR7cmFua31dKSB7XG4gICAgICAgICAgaW50IHNoYXBlWyR7cmFua31dO1xuICAgICAgICAgICR7c2hhcGVJbml0fTtcbiAgICAgICAgICBmb3IoaW50IGkgPSAke3Jhbmt9IC0xIDsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICAgIGlmKGkgPiBheGlzKSBjb250aW51ZTtcbiAgICAgICAgICAgIGluZGljZXNbaV0gKz0gMTtcbiAgICAgICAgICAgIGlmKGluZGljZXNbaV0gPCBzaGFwZVtpXSkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluZGljZXNbaV0gPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBgO1xuICAgICAgcmVzdWx0W2Z1bmNOYW1lXSA9IG5ldyBHbHNsTGliUm91dGluZShib2R5KTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7R2xzbENvbnRleHQsIEdsc2xMaWIsIEdsc2xMaWJSb3V0aW5lfSBmcm9tICcuL2dsc2wtZGVmaW5pdGlvbnMnO1xuXG4vKipcbiAqIEdMU0wgTGlicmFyeSByZXNwb25zaWJsZSBmb3IgdmVjIHJvdXRpbmVzXG4gKiBWZWMgaXMgYW4gdmFyaWJsZSBsZW5ndGggaW50IGFycmF5LiBUaGUgbGVuZ3RoIGlzIGZpeGVkIGF0IHRoZSB0aW1lIG9mXG4gKiBnZW5lcmF0aW5nIHRoZSBsaWJyYXJ5IGZ1bmN0aW9ucyBmcm9tIHRoZSBkaW1lbnNpb25zIG9mIHRoZSBvdXRwdXQuXG4gKi9cbmV4cG9ydCBjbGFzcyBWZWNHbHNsTGliIGV4dGVuZHMgR2xzbExpYiB7XG4gIGNvbnN0cnVjdG9yKGNvbnRleHQ6IEdsc2xDb250ZXh0KSB7XG4gICAgc3VwZXIoY29udGV4dCk7XG4gIH1cbiAgZ2V0Q3VzdG9tVHlwZXMoKToge1tuYW1lOiBzdHJpbmddOiBzdHJpbmd9IHtcbiAgICByZXR1cm4ge307XG4gIH1cbiAgZ2V0RnVuY3Rpb25zKCk6IHtbbmFtZTogc3RyaW5nXTogR2xzbExpYlJvdXRpbmV9IHtcbiAgICByZXR1cm4gey4uLnRoaXMuYmluYXJ5VmVjRnVuY3Rpb25zKCksIC4uLnRoaXMuY29weVZlYygpLCAuLi50aGlzLnNldFZlY0l0ZW0oKSwgLi4udGhpcy5nZXRWZWNJdGVtKCl9O1xuICB9XG4gIHByb3RlY3RlZCBiaW5hcnlWZWNGdW5jdGlvbnMoKToge1tuYW1lOiBzdHJpbmddOiBHbHNsTGliUm91dGluZX0ge1xuICAgIGNvbnN0IG91dHB1dExheW91dCA9IHRoaXMuY29udGV4dC5vdXRwdXRUZXh0dXJlTGF5b3V0O1xuICAgIGNvbnN0IHJhbmsgPSBvdXRwdXRMYXlvdXQuc2hhcGUubGVuZ3RoO1xuICAgIGNvbnN0IG5hbWVPcDoge1tuYW1lOiBzdHJpbmddOiBzdHJpbmd9ID0ge2FkZDogJys9Jywgc3ViOiAnLT0nLCBtdWw6ICcqPScsIGRpdjogJy89J307XG4gICAgY29uc3QgcmVzdWx0OiB7W25hbWU6IHN0cmluZ106IEdsc2xMaWJSb3V0aW5lfSA9IHt9O1xuICAgIGZvciAoY29uc3QgbmFtZSBpbiBuYW1lT3ApIHtcbiAgICAgIGNvbnN0IGZuYW1lID0gYCR7bmFtZX1WZWNgO1xuICAgICAgbGV0IGFzc2lnbm1lbnRCbG9jayA9ICcnO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5rOyArK2kpIHtcbiAgICAgICAgYXNzaWdubWVudEJsb2NrICs9IGBcbiAgICAgICAgICBkZXN0WyR7aX1dICR7bmFtZU9wW25hbWVdfSBzcmNbJHtpfV07XG4gICAgICAgICAgYDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGJvZHkgPSBgXG4gICAgICAgIHZvaWQgJHtmbmFtZX0oaW50IHNyY1ske3Jhbmt9XSwgb3V0IGludCBkZXN0WyR7cmFua31dKSB7XG4gICAgICAgICAgJHthc3NpZ25tZW50QmxvY2t9XG4gICAgICAgIH1cbiAgICAgICAgYDtcbiAgICAgIHJlc3VsdFtmbmFtZV0gPSBuZXcgR2xzbExpYlJvdXRpbmUoYm9keSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBwcm90ZWN0ZWQgY29weVZlYygpOiB7W25hbWU6IHN0cmluZ106IEdsc2xMaWJSb3V0aW5lfSB7XG4gICAgY29uc3Qgb3V0cHV0TGF5b3V0ID0gdGhpcy5jb250ZXh0Lm91dHB1dFRleHR1cmVMYXlvdXQ7XG4gICAgY29uc3QgcmFuayA9IG91dHB1dExheW91dC5zaGFwZS5sZW5ndGg7XG4gICAgbGV0IGFzc2lnbm1lbnRCbG9jayA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuazsgKytpKSB7XG4gICAgICBhc3NpZ25tZW50QmxvY2sgKz0gYFxuICAgICAgICBkZXN0WyR7aX1dID0gc3JjWyR7aX1dO1xuICAgICAgICBgO1xuICAgIH1cbiAgICBjb25zdCBib2R5ID0gYFxuICAgICAgdm9pZCBjb3B5VmVjKGludCBzcmNbJHtyYW5rfV0sIG91dCBpbnQgZGVzdFske3Jhbmt9XSkge1xuICAgICAgICAke2Fzc2lnbm1lbnRCbG9ja31cbiAgICAgIH1cbiAgICAgIGA7XG4gICAgcmV0dXJuIHtjb3B5VmVjOiBuZXcgR2xzbExpYlJvdXRpbmUoYm9keSl9O1xuICB9XG5cbiAgcHJvdGVjdGVkIHNldFZlY0l0ZW0oKToge1tuYW1lOiBzdHJpbmddOiBHbHNsTGliUm91dGluZX0ge1xuICAgIGNvbnN0IG91dHB1dExheW91dCA9IHRoaXMuY29udGV4dC5vdXRwdXRUZXh0dXJlTGF5b3V0O1xuICAgIGNvbnN0IHJhbmsgPSBvdXRwdXRMYXlvdXQuc2hhcGUubGVuZ3RoO1xuICAgIGxldCBibG9jayA9IGBcbiAgICAgICAgaWYoaW5kZXggPCAwKVxuICAgICAgICAgICAgaW5kZXggPSR7cmFua30gKyBpbmRleDtcbiAgICAgICAgaWYgKGluZGV4ID09IDApXG4gICAgICAgICAgICBtWzBdID0gdmFsdWU7XG4gICAgICAgIGA7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCByYW5rIC0gMTsgKytpKSB7XG4gICAgICBibG9jayArPSBgXG4gICAgICAgIGVsc2UgaWYgKGluZGV4ID09ICR7aX0pXG4gICAgICAgICAgICBtWyR7aX1dID0gdmFsdWU7XG4gICAgICAgICAgICBgO1xuICAgIH1cbiAgICBibG9jayArPSBgXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIG1bJHtyYW5rIC0gMX1dID0gdmFsdWU7XG4gICAgICAgIGA7XG4gICAgY29uc3QgYm9keSA9IGBcbiAgICAgIHZvaWQgc2V0VmVjSXRlbShvdXQgaW50IG1bJHtyYW5rfV0sIGludCBpbmRleCwgaW50IHZhbHVlKSB7XG4gICAgICAgICR7YmxvY2t9XG4gICAgICB9XG4gICAgICAgIGA7XG4gICAgcmV0dXJuIHtzZXRWZWNJdGVtOiBuZXcgR2xzbExpYlJvdXRpbmUoYm9keSl9O1xuICB9XG4gIHByb3RlY3RlZCBnZXRWZWNJdGVtKCk6IHtbbmFtZTogc3RyaW5nXTogR2xzbExpYlJvdXRpbmV9IHtcbiAgICBjb25zdCBvdXRwdXRMYXlvdXQgPSB0aGlzLmNvbnRleHQub3V0cHV0VGV4dHVyZUxheW91dDtcbiAgICBjb25zdCByYW5rID0gb3V0cHV0TGF5b3V0LnNoYXBlLmxlbmd0aDtcbiAgICBsZXQgYmxvY2sgPSBgXG4gICAgICAgIGlmKGluZGV4IDwgMClcbiAgICAgICAgICAgIGluZGV4ID0gJHtyYW5rfSArIGluZGV4O1xuICAgICAgICBpZiAoaW5kZXggPT0gMClcbiAgICAgICAgICAgIHJldHVybiBtWzBdO1xuICAgICAgYDtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IHJhbmsgLSAxOyArK2kpIHtcbiAgICAgIGJsb2NrICs9IGBcbiAgICAgICAgZWxzZSBpZiAoaW5kZXggPT0gJHtpfSlcbiAgICAgICAgICAgIHJldHVybiBtWyR7aX1dO1xuICAgICAgYDtcbiAgICB9XG4gICAgYmxvY2sgKz0gYFxuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gbVske3JhbmsgLSAxfV07XG4gICAgICAgIGA7XG4gICAgY29uc3QgYm9keSA9IGBcbiAgICAgIGludCBnZXRWZWNJdGVtKGludCBtWyR7cmFua31dLCBpbnQgaW5kZXgpIHtcbiAgICAgICAgJHtibG9ja31cbiAgICAgIH1cbiAgICBgO1xuICAgIHJldHVybiB7Z2V0VmVjSXRlbTogbmV3IEdsc2xMaWJSb3V0aW5lKGJvZHkpfTtcbiAgfVxufVxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0Nvb3Jkc0dsc2xMaWJ9IGZyb20gJy4vZ2xzbC1jb29yZGluYXRlLWxpYic7XG5pbXBvcnQge0dsc2xDb250ZXh0LCBHbHNsTGlifSBmcm9tICcuL2dsc2wtZGVmaW5pdGlvbnMnO1xuaW1wb3J0IHtFbmNvZGluZ0dsc2xMaWJ9IGZyb20gJy4vZ2xzbC1lbmNvZGluZy1saWInO1xuaW1wb3J0IHtGcmFnQ29sb3JHbHNsTGlifSBmcm9tICcuL2dsc2wtZnJhZ2NvbG9yLWxpYic7XG5pbXBvcnQge1NoYXBlVXRpbHNHbHNsTGlifSBmcm9tICcuL2dsc2wtc2hhcGUtdXRpbHMtbGliJztcbmltcG9ydCB7VmVjR2xzbExpYn0gZnJvbSAnLi9nbHNsLXZlYy1saWInO1xuXG5leHBvcnQgY29uc3QgZ2xzbFJlZ2lzdHJ5OiB7W25hbWU6IHN0cmluZ106IG5ldyAoY29udGV4dDogR2xzbENvbnRleHQpID0+IEdsc2xMaWJ9ID0ge1xuICAnZW5jb2RpbmcnOiBFbmNvZGluZ0dsc2xMaWIsXG4gICdmcmFnY29sb3InOiBGcmFnQ29sb3JHbHNsTGliLFxuICAndmVjJzogVmVjR2xzbExpYixcbiAgJ3NoYXBlVXRpbHMnOiBTaGFwZVV0aWxzR2xzbExpYixcbiAgJ2Nvb3JkaW5hdGVzJzogQ29vcmRzR2xzbExpYixcbiAgLy8gICdhcnJheXMnOiBBcnJheUdsc2xTTGliXG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0dsc2xDb250ZXh0LCBHbHNsTGliLCBHbHNsTGliUm91dGluZU5vZGUsIFRvcG9sb2dpY2FsU29ydEdsc2xSb3V0aW5lc30gZnJvbSAnLi9nbHNsLWRlZmluaXRpb25zJztcbmltcG9ydCB7cmVwbGFjZUlubGluZXN9IGZyb20gJy4vZ2xzbC1mdW5jdGlvbi1pbmxpbmVyJztcbmltcG9ydCB7Z2xzbFJlZ2lzdHJ5fSBmcm9tICcuL2dsc2wtcmVnaXN0ZXJlZC1saWJzJztcbmltcG9ydCB7Z2V0RGVmYXVsdEZyYWdTaGFkZXJNYWluLCBnZXRGcmFnU2hhZGVyUHJlYW1ibGV9IGZyb20gJy4vZ2xzbC1zb3VyY2UnO1xuaW1wb3J0IHtQcm9ncmFtSW5mbywgVGV4dHVyZUxheW91dCwgVmFyaWFibGVJbmZvfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7V2ViR0xDb250ZXh0fSBmcm9tICcuL3dlYmdsLWNvbnRleHQnO1xuXG4vKipcbiAqIFByZXByb2Nlc3NvciBmb3IgdGhlIGFkZGl0aW9ucyB0byB0aGUgR0xTTCBsYW5ndWFnZVxuICogSXQgZGVhbHMgd2l0aDpcbiAqICBAaW5jbHVkZSBkaXJlY3RpdmVzXG4gKiAgQGlubGluZVxuICogIExvb3AgdW5yb2xsaW5nIChub3QgaW1wbGVtZW50ZWQpXG4gKiAgTWFjcm8gcmVzb2x1dGlvbiAobm90IGltcGxlbWVudGVkKVxuICovXG5leHBvcnQgY2xhc3MgR2xzbFByZXByb2Nlc3NvciB7XG4gIHJlYWRvbmx5IGNvbnRleHQ6IEdsc2xDb250ZXh0O1xuICByZWFkb25seSBsaWJzOiB7W25hbWU6IHN0cmluZ106IEdsc2xMaWJ9ID0ge307XG4gIHJlYWRvbmx5IGdsc2xMaWJSb3V0aW5lRGVwZW5kZW5jeUdyYXBoOiB7W3JvdXRpbmVOYW1lOiBzdHJpbmddOiBHbHNsTGliUm91dGluZU5vZGV9ID0ge307XG5cbiAgY29uc3RydWN0b3IoXG4gICAgICBnbENvbnRleHQ6IFdlYkdMQ29udGV4dCwgcHJvZ3JhbUluZm86IFByb2dyYW1JbmZvLCBpbnB1dFRleHR1cmVMYXlvdXRzOiBUZXh0dXJlTGF5b3V0W10sXG4gICAgICBvdXRwdXRUZXh0dXJlTGF5b3V0OiBUZXh0dXJlTGF5b3V0KSB7XG4gICAgdGhpcy5jb250ZXh0ID0gbmV3IEdsc2xDb250ZXh0KGdsQ29udGV4dCwgcHJvZ3JhbUluZm8sIGlucHV0VGV4dHVyZUxheW91dHMsIG91dHB1dFRleHR1cmVMYXlvdXQpO1xuXG4gICAgLy8gY29uc3RydWN0IEdsc2xMaWJzXG4gICAgT2JqZWN0LmtleXMoZ2xzbFJlZ2lzdHJ5KS5mb3JFYWNoKChuYW1lOiBzdHJpbmcpID0+IHtcbiAgICAgIGNvbnN0IGxpYiA9IG5ldyBnbHNsUmVnaXN0cnlbbmFtZV0odGhpcy5jb250ZXh0KTtcbiAgICAgIHRoaXMubGlic1tuYW1lXSA9IGxpYjtcbiAgICB9KTtcblxuICAgIC8vIGNvbnN0cnVjdCBHbHNsUm91dGluZURlcGVuZGVuY3lHcmFwaFxuICAgIGNvbnN0IG1hcCA9IHRoaXMuZ2xzbExpYlJvdXRpbmVEZXBlbmRlbmN5R3JhcGg7XG4gICAgZm9yIChjb25zdCBsaWJOYW1lIGluIHRoaXMubGlicykge1xuICAgICAgY29uc3QgbGliID0gdGhpcy5saWJzW2xpYk5hbWVdO1xuICAgICAgY29uc3Qgcm91dGluZXNJbkxpYiA9IGxpYi5nZXRGdW5jdGlvbnMoKTtcbiAgICAgIGZvciAoY29uc3Qgcm91dGluZSBpbiByb3V0aW5lc0luTGliKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGxpYk5hbWUgKyAnLicgKyByb3V0aW5lO1xuICAgICAgICBsZXQgY3VycmVudE5vZGU6IEdsc2xMaWJSb3V0aW5lTm9kZTtcbiAgICAgICAgaWYgKG1hcFtrZXldKSB7XG4gICAgICAgICAgY3VycmVudE5vZGUgPSBtYXBba2V5XTtcbiAgICAgICAgICBjdXJyZW50Tm9kZS5yb3V0aW5lQm9keSA9IHJvdXRpbmVzSW5MaWJbcm91dGluZV0ucm91dGluZUJvZHk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3VycmVudE5vZGUgPSBuZXcgR2xzbExpYlJvdXRpbmVOb2RlKGtleSwgcm91dGluZXNJbkxpYltyb3V0aW5lXS5yb3V0aW5lQm9keSk7XG4gICAgICAgICAgbWFwW2tleV0gPSBjdXJyZW50Tm9kZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkZXBlbmRlbmNpZXMgPSByb3V0aW5lc0luTGliW3JvdXRpbmVdLmRlcGVuZGVuY2llcztcbiAgICAgICAgaWYgKGRlcGVuZGVuY2llcykge1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVwZW5kZW5jaWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAoIW1hcFtkZXBlbmRlbmNpZXNbaV1dKSB7XG4gICAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBuZXcgR2xzbExpYlJvdXRpbmVOb2RlKGRlcGVuZGVuY2llc1tpXSk7XG4gICAgICAgICAgICAgIG1hcFtkZXBlbmRlbmNpZXNbaV1dID0gbm9kZTtcbiAgICAgICAgICAgICAgY3VycmVudE5vZGUuYWRkRGVwZW5kZW5jeShub2RlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGN1cnJlbnROb2RlLmFkZERlcGVuZGVuY3kobWFwW2RlcGVuZGVuY2llc1tpXV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByZXByb2Nlc3MoKTogc3RyaW5nIHtcbiAgICBjb25zdCBwcm9ncmFtSW5mbyA9IHRoaXMuY29udGV4dC5wcm9ncmFtSW5mbztcbiAgICBsZXQgc291cmNlID0gcHJvZ3JhbUluZm8uc2hhZGVyU291cmNlO1xuXG4gICAgLy8gYXBwZW5kIG1haW4oKSBmdW5jdGlvblxuICAgIGlmICghdGhpcy5jb250ZXh0LnByb2dyYW1JbmZvLmhhc01haW4pIHtcbiAgICAgIHNvdXJjZSA9IGAke3NvdXJjZX1cbiAgICAgICR7Z2V0RGVmYXVsdEZyYWdTaGFkZXJNYWluKHRoaXMuY29udGV4dC5nbENvbnRleHQudmVyc2lvbiwgdGhpcy5jb250ZXh0Lm91dHB1dFRleHR1cmVMYXlvdXQuc2hhcGUubGVuZ3RoKX1gO1xuICAgIH1cbiAgICAvLyByZXBsYWNlIGlubGluZXNcbiAgICBzb3VyY2UgPSByZXBsYWNlSW5saW5lcyhzb3VyY2UpO1xuXG4gICAgLy8gY29uY2F0IGZpbmFsIHNvdXJjZSBzdHJpbmdcbiAgICByZXR1cm4gYCR7Z2V0RnJhZ1NoYWRlclByZWFtYmxlKHRoaXMuY29udGV4dC5nbENvbnRleHQudmVyc2lvbil9XG4gICAgJHt0aGlzLmdldFVuaWZvcm1zKHByb2dyYW1JbmZvLmlucHV0TmFtZXMsIHByb2dyYW1JbmZvLnZhcmlhYmxlcyl9XG4gICAgJHt0aGlzLmdldEltcG9ydHMoc291cmNlKX1cbiAgICAke3NvdXJjZX1gO1xuICB9XG5cbiAgcHJvdGVjdGVkIGdldEltcG9ydHMoc2NyaXB0OiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGNvbnN0IHJvdXRpbmVzSW5jbHVkZWQgPSB0aGlzLnNlbGVjdEdsc2xMaWJSb3V0aW5lc1RvQmVJbmNsdWRlZChzY3JpcHQpO1xuXG4gICAgaWYgKHJvdXRpbmVzSW5jbHVkZWQubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgbGV0IHJvdXRpbmVzID0gJyc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3V0aW5lc0luY2x1ZGVkLmxlbmd0aDsgKytpKSB7XG4gICAgICBpZiAocm91dGluZXNJbmNsdWRlZFtpXS5yb3V0aW5lQm9keSkge1xuICAgICAgICByb3V0aW5lcyArPSByb3V0aW5lc0luY2x1ZGVkW2ldLnJvdXRpbmVCb2R5ICsgJ1xcbic7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE1pc3NpbmcgYm9keSBmb3IgdGhlIEdsc2wgTGlicmFyeSByb3V0aW5lOiAke3JvdXRpbmVzSW5jbHVkZWRbaV0ubmFtZX1gKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcm91dGluZXM7XG4gIH1cbiAgcHJpdmF0ZSBzZWxlY3RHbHNsTGliUm91dGluZXNUb0JlSW5jbHVkZWQoc2NyaXB0OiBzdHJpbmcpOiBHbHNsTGliUm91dGluZU5vZGVbXSB7XG4gICAgY29uc3Qgbm9kZXM6IEdsc2xMaWJSb3V0aW5lTm9kZVtdID0gW107XG5cbiAgICBPYmplY3Qua2V5cyh0aGlzLmdsc2xMaWJSb3V0aW5lRGVwZW5kZW5jeUdyYXBoKS5mb3JFYWNoKGNsYXNzQW5kUm91dGluZSA9PiB7XG4gICAgICBjb25zdCByb3V0aW5lID0gY2xhc3NBbmRSb3V0aW5lLnNwbGl0KCcuJylbMV07XG4gICAgICBpZiAoc2NyaXB0LmluZGV4T2Yocm91dGluZSkgIT09IC0xKSB7XG4gICAgICAgIG5vZGVzLnB1c2godGhpcy5nbHNsTGliUm91dGluZURlcGVuZGVuY3lHcmFwaFtjbGFzc0FuZFJvdXRpbmVdKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBUb3BvbG9naWNhbFNvcnRHbHNsUm91dGluZXMucmV0dXJuT3JkZXJlZE5vZGVzKG5vZGVzKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBnZXRVbmlmb3JtcyhzYW1wbGVycz86IHN0cmluZ1tdLCB2YXJpYWJsZXM/OiBWYXJpYWJsZUluZm9bXSk6IHN0cmluZyB7XG4gICAgY29uc3QgdW5pZm9ybUxpbmVzOiBzdHJpbmdbXSA9IFtdO1xuICAgIGlmIChzYW1wbGVycykge1xuICAgICAgZm9yIChjb25zdCBzYW1wbGVyIG9mIHNhbXBsZXJzKSB7XG4gICAgICAgIHVuaWZvcm1MaW5lcy5wdXNoKGB1bmlmb3JtIHNhbXBsZXIyRCAke3NhbXBsZXJ9O2ApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodmFyaWFibGVzKSB7XG4gICAgICBmb3IgKGNvbnN0IHZhcmlhYmxlIG9mIHZhcmlhYmxlcykge1xuICAgICAgICB1bmlmb3JtTGluZXMucHVzaChcbiAgICAgICAgICAgIGB1bmlmb3JtICR7dmFyaWFibGUudHlwZX0gJHt2YXJpYWJsZS5uYW1lfSR7dmFyaWFibGUuYXJyYXlMZW5ndGggPyBgWyR7dmFyaWFibGUuYXJyYXlMZW5ndGh9XWAgOiAnJ307YCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1bmlmb3JtTGluZXMuam9pbignXFxuJyk7XG4gIH1cbn1cbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtlbnZ9IGZyb20gJ29ubnhydW50aW1lLWNvbW1vbic7XG5cbmltcG9ydCB7TG9nZ2VyLCBQcm9maWxlcn0gZnJvbSAnLi4vLi4vaW5zdHJ1bWVudCc7XG5cbmltcG9ydCB7R2xzbFByZXByb2Nlc3Nvcn0gZnJvbSAnLi9nbHNsLXByZXByb2Nlc3Nvcic7XG5pbXBvcnQge2dldFZlcnRleFNoYWRlclNvdXJjZX0gZnJvbSAnLi9nbHNsLXNvdXJjZSc7XG5pbXBvcnQge1RleHR1cmVMYXlvdXRTdHJhdGVneX0gZnJvbSAnLi90ZXh0dXJlLWxheW91dC1zdHJhdGVneSc7XG5pbXBvcnQge0FydGlmYWN0LCBQcm9ncmFtSW5mbywgUHJvZ3JhbVZhcmlhYmxlLCBUZXh0dXJlRGF0YSwgVGV4dHVyZUxheW91dCwgVmFyaWFibGVJbmZvfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7V2ViR0xDb250ZXh0fSBmcm9tICcuL3dlYmdsLWNvbnRleHQnO1xuXG4vKipcbiAqIFByb2dyYW1NYW5hZ2VyIGlzIHRoZSBtYWluIGNsYXNzIGJlaGluZCBydW5uaW5nIGNvbXB1dGF0aW9uc1xuICogSXQgYnVpbGRzIFByb2dyYW1JbmZvJ3MgaW50byBBcnRpZmFjdHNcbiAqIEl0IGNvbXBpbGVzIGdpdmVuIFByb2dyYW1JbmZvJ3MgaW50byBXZWJHTCBQcm9yYW1zIChjYWNoZWQgYXMgQXJ0aWZhY3RzKVxuICogVXNlcyB0aGUgYXJ0aWZhY3QgdG8gcnVuIHRoZSBjb21wdXRhdGlvbiBieSBjYWxsaW5nIERyYXcgb25cbiAqIHRoZSBXZWJHTCBkcmF3aW5nIGJ1ZmZlclxuICogUHJvZ3JhbU1hbmFnZXIgYXV0b21hdGljYWxseSBtYXBzIChiaW5kcykgaW5wdXQgdmFyaWFibGVzIHRvIHRoZWlyXG4gKiBjb3JyZXNwb25kaW5nIExvY2F0aW9uJ3MgaW4gdGhlIGJpbmFyeSBwcm9ncmFtXG4gKi9cbmV4cG9ydCBjbGFzcyBQcm9ncmFtTWFuYWdlciB7XG4gIHJlcG86IE1hcDx1bmtub3duLCBBcnRpZmFjdD47ICAvLyB0aGlzIHNob3VsZCBiZSBwZXItc2Vzc2lvbiBvYmplY3RcbiAgdmVydGV4U2hhZGVyOiBXZWJHTFNoYWRlcjtcbiAgYXR0cmlidXRlc0JvdW5kOiBib29sZWFuO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgICAgcHVibGljIHByb2ZpbGVyOiBSZWFkb25seTxQcm9maWxlcj4sIHB1YmxpYyBnbENvbnRleHQ6IFdlYkdMQ29udGV4dCxcbiAgICAgIHB1YmxpYyB0ZXh0dXJlTGF5b3V0U3RyYXRlZ3k6IFRleHR1cmVMYXlvdXRTdHJhdGVneSkge1xuICAgIHRoaXMucmVwbyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLmF0dHJpYnV0ZXNCb3VuZCA9IGZhbHNlO1xuICB9XG4gIGdldEFydGlmYWN0KGtleTogdW5rbm93bik6IEFydGlmYWN0fHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMucmVwby5nZXQoa2V5KTtcbiAgfVxuICBzZXRBcnRpZmFjdChrZXk6IHVua25vd24sIGFydGlmYWN0OiBBcnRpZmFjdCk6IHZvaWQge1xuICAgIHRoaXMucmVwby5zZXQoa2V5LCBhcnRpZmFjdCk7XG4gIH1cbiAgcnVuKGJ1aWxkQXJ0aWZhY3Q6IEFydGlmYWN0LCBpbnB1dHM6IFRleHR1cmVEYXRhW10sIG91dHB1dDogVGV4dHVyZURhdGEpOiB2b2lkIHtcbiAgICB0aGlzLnByb2ZpbGVyLmV2ZW50KCdvcCcsIGBQcm9ncmFtTWFuYWdlci5ydW4gJHtidWlsZEFydGlmYWN0LnByb2dyYW1JbmZvLm5hbWUgPz8gJ3Vua25vd24ga2VybmVsJ31gLCAoKSA9PiB7XG4gICAgICBjb25zdCBnbCA9IHRoaXMuZ2xDb250ZXh0LmdsO1xuICAgICAgY29uc3QgcHJvZ3JhbSA9IGJ1aWxkQXJ0aWZhY3QucHJvZ3JhbTtcbiAgICAgIGdsLnVzZVByb2dyYW0ocHJvZ3JhbSk7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLmJpbmRPdXRwdXQob3V0cHV0KTtcbiAgICAgICAgaWYgKCF0aGlzLmF0dHJpYnV0ZXNCb3VuZCkge1xuICAgICAgICAgIHRoaXMuYmluZEF0dHJpYnV0ZXMoYnVpbGRBcnRpZmFjdC5hdHRyaWJMb2NhdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYmluZFVuaWZvcm1zKGJ1aWxkQXJ0aWZhY3QudW5pZm9ybUxvY2F0aW9ucywgYnVpbGRBcnRpZmFjdC5wcm9ncmFtSW5mby52YXJpYWJsZXMgPz8gW10sIGlucHV0cyk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgTG9nZ2VyLmVycm9yKCdQcm9ncmFtTWFuYWdlcicsIGJ1aWxkQXJ0aWZhY3QucHJvZ3JhbUluZm8uc2hhZGVyU291cmNlKTtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgICAgdGhpcy5wcm9maWxlci5ldmVudCgnYmFja2VuZCcsICdHbENvbnRleHQuZHJhdygpJywgKCkgPT4ge1xuICAgICAgICB0aGlzLmdsQ29udGV4dC5kcmF3KCk7XG4gICAgICB9KTtcbiAgICB9LCB0aGlzLmdsQ29udGV4dCk7XG4gIH1cbiAgZGlzcG9zZSgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy52ZXJ0ZXhTaGFkZXIpIHtcbiAgICAgIHRoaXMuZ2xDb250ZXh0LmRlbGV0ZVNoYWRlcih0aGlzLnZlcnRleFNoYWRlcik7XG4gICAgfVxuICAgIHRoaXMucmVwby5mb3JFYWNoKGEgPT4gdGhpcy5nbENvbnRleHQuZGVsZXRlUHJvZ3JhbShhLnByb2dyYW0pKTtcbiAgfVxuICBidWlsZChwcm9ncmFtSW5mbzogUHJvZ3JhbUluZm8sIGlucHV0VGV4dHVyZUxheW91dHM6IFRleHR1cmVMYXlvdXRbXSwgb3V0cHV0VGV4dHVyZUxheW91dDogVGV4dHVyZUxheW91dCk6IEFydGlmYWN0IHtcbiAgICByZXR1cm4gdGhpcy5wcm9maWxlci5ldmVudCgnYmFja2VuZCcsICdQcm9ncmFtTWFuYWdlci5idWlsZCcsICgpID0+IHtcbiAgICAgIGNvbnN0IHByZXByb2Nlc3NvciA9IG5ldyBHbHNsUHJlcHJvY2Vzc29yKHRoaXMuZ2xDb250ZXh0LCBwcm9ncmFtSW5mbywgaW5wdXRUZXh0dXJlTGF5b3V0cywgb3V0cHV0VGV4dHVyZUxheW91dCk7XG4gICAgICBjb25zdCBmcmFnU2NyaXB0ID0gcHJlcHJvY2Vzc29yLnByZXByb2Nlc3MoKTtcbiAgICAgIGNvbnN0IHByb2dyYW0gPSB0aGlzLmNvbXBpbGUoZnJhZ1NjcmlwdCk7XG4gICAgICBjb25zdCBhcnRpZmFjdCA9IHtcbiAgICAgICAgcHJvZ3JhbUluZm8sXG4gICAgICAgIHByb2dyYW0sXG4gICAgICAgIHVuaWZvcm1Mb2NhdGlvbnM6IHRoaXMuZ2V0VW5pZm9ybUxvY2F0aW9ucyhcbiAgICAgICAgICAgIHByb2dyYW0sIHByZXByb2Nlc3Nvci5jb250ZXh0LnByb2dyYW1JbmZvLmlucHV0TmFtZXMsIHByZXByb2Nlc3Nvci5jb250ZXh0LnByb2dyYW1JbmZvLnZhcmlhYmxlcyksXG4gICAgICAgIGF0dHJpYkxvY2F0aW9uczogdGhpcy5nZXRBdHRyaWJMb2NhdGlvbnMocHJvZ3JhbSlcbiAgICAgIH07XG4gICAgICByZXR1cm4gYXJ0aWZhY3Q7XG4gICAgfSk7XG4gIH1cbiAgcHJvdGVjdGVkIGNvbXBpbGUoZnJhZ1NoYWRlclNjcmlwdDogc3RyaW5nKTogV2ViR0xQcm9ncmFtIHtcbiAgICBpZiAoIXRoaXMudmVydGV4U2hhZGVyKSB7XG4gICAgICBMb2dnZXIudmVyYm9zZSgnUHJvcmdyYW1NYW5hZ2VyJywgJ0NvbXBpbGluZyBhbmQgY2FjaGluZyBWZXJ0ZXggc2hhZGVyIGZvciB0aGUgZmlyc3QgdGltZScpO1xuICAgICAgY29uc3QgdmVydGV4U2hhZGVyU2NyaXB0ID0gZ2V0VmVydGV4U2hhZGVyU291cmNlKHRoaXMuZ2xDb250ZXh0LnZlcnNpb24pO1xuICAgICAgdGhpcy52ZXJ0ZXhTaGFkZXIgPSB0aGlzLmdsQ29udGV4dC5jb21waWxlU2hhZGVyKHZlcnRleFNoYWRlclNjcmlwdCwgdGhpcy5nbENvbnRleHQuZ2wuVkVSVEVYX1NIQURFUik7XG4gICAgfVxuICAgIGlmIChlbnYuZGVidWcpIHtcbiAgICAgIExvZ2dlci52ZXJib3NlKCdQcm9yZ3JhbU1hbmFnZXInLCBgRnJhZ1NoYWRlcjpcbiR7ZnJhZ1NoYWRlclNjcmlwdH1cbmApO1xuICAgIH1cbiAgICBjb25zdCBmcmFnU2hhZGVyID0gdGhpcy5nbENvbnRleHQuY29tcGlsZVNoYWRlcihmcmFnU2hhZGVyU2NyaXB0LCB0aGlzLmdsQ29udGV4dC5nbC5GUkFHTUVOVF9TSEFERVIpO1xuICAgIGNvbnN0IHByb2dyYW0gPSB0aGlzLmdsQ29udGV4dC5jcmVhdGVQcm9ncmFtKHRoaXMudmVydGV4U2hhZGVyLCBmcmFnU2hhZGVyKTtcbiAgICB0aGlzLmdsQ29udGV4dC5kZWxldGVTaGFkZXIoZnJhZ1NoYWRlcik7XG4gICAgcmV0dXJuIHByb2dyYW07XG4gIH1cbiAgYmluZE91dHB1dCh0ZDogVGV4dHVyZURhdGEpOiB2b2lkIHtcbiAgICBjb25zdCB3aWR0aCA9IHRkLndpZHRoO1xuICAgIGNvbnN0IGhlaWdodCA9IHRkLmhlaWdodDtcbiAgICBMb2dnZXIudmVyYm9zZShcbiAgICAgICAgJ1Byb3JncmFtTWFuYWdlcicsXG4gICAgICAgIGBCaW5kaW5nIG91dHB1dCB0ZXh0dXJlIHRvIEZyYW1lYnVmZmVyOiB3L2g9JHt3aWR0aH0vJHtoZWlnaHR9LCBzaGFwZT0ke3RkLnNoYXBlfSwgdHlwZT0ke3RkLnRlbnNvci50eXBlfWApO1xuICAgIHRoaXMuZ2xDb250ZXh0LmF0dGFjaEZyYW1lYnVmZmVyKHRkLnRleHR1cmUsIHdpZHRoLCBoZWlnaHQpO1xuICB9XG4gIGJpbmRBdHRyaWJ1dGVzKGF0dHJpYkxvY2F0aW9uczogQXJ0aWZhY3QuQXR0cmliTG9jYXRpb25zKTogdm9pZCB7XG4gICAgY29uc3QgcG9zaXRpb25IYW5kbGUgPSBhdHRyaWJMb2NhdGlvbnMucG9zaXRpb247XG4gICAgY29uc3QgdGV4dHVyZUNvb3JkSGFuZGxlID0gYXR0cmliTG9jYXRpb25zLnRleHR1cmVDb29yZDtcbiAgICB0aGlzLmdsQ29udGV4dC5zZXRWZXJ0ZXhBdHRyaWJ1dGVzKHBvc2l0aW9uSGFuZGxlLCB0ZXh0dXJlQ29vcmRIYW5kbGUpO1xuICAgIHRoaXMuYXR0cmlidXRlc0JvdW5kID0gdHJ1ZTtcbiAgfVxuICBiaW5kVW5pZm9ybXModW5pZm9ybUxvY2F0aW9uczogQXJ0aWZhY3QuVW5pZm9ybUxvY2F0aW9ucywgdmFyaWFibGVzOiBQcm9ncmFtVmFyaWFibGVbXSwgdGV4dHVyZXM6IFRleHR1cmVEYXRhW10pOlxuICAgICAgdm9pZCB7XG4gICAgY29uc3QgZ2wgPSB0aGlzLmdsQ29udGV4dC5nbDtcbiAgICBsZXQgdGV4dHVyZVBvc2l0aW9uID0gMDtcbiAgICBmb3IgKGNvbnN0IHtuYW1lLCB0eXBlLCBsb2NhdGlvbiwgYXJyYXlMZW5ndGh9IG9mIHVuaWZvcm1Mb2NhdGlvbnMpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gdmFyaWFibGVzLmZpbmQodiA9PiB2Lm5hbWUgPT09IG5hbWUpPy5kYXRhO1xuICAgICAgaWYgKHR5cGUgIT09ICdzYW1wbGVyMkQnICYmICF2YWx1ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHZhcmlhYmxlICcke25hbWV9JyBkb2VzIG5vdCBoYXZlIGRhdGEgZGVmaW5lZCBpbiBwcm9ncmFtIGluZm9gKTtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlICdzYW1wbGVyMkQnOlxuICAgICAgICAgIHRoaXMuYmluZFRleHR1cmUodGV4dHVyZXNbdGV4dHVyZVBvc2l0aW9uXSwgbG9jYXRpb24sIHRleHR1cmVQb3NpdGlvbik7XG4gICAgICAgICAgdGV4dHVyZVBvc2l0aW9uKys7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2Zsb2F0JzpcbiAgICAgICAgICBpZiAoYXJyYXlMZW5ndGgpIHtcbiAgICAgICAgICAgIGdsLnVuaWZvcm0xZnYobG9jYXRpb24sIHZhbHVlIGFzIG51bWJlcltdKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2wudW5pZm9ybTFmKGxvY2F0aW9uLCB2YWx1ZSBhcyBudW1iZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnaW50JzpcbiAgICAgICAgICBpZiAoYXJyYXlMZW5ndGgpIHtcbiAgICAgICAgICAgIGdsLnVuaWZvcm0xaXYobG9jYXRpb24sIHZhbHVlIGFzIG51bWJlcltdKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2wudW5pZm9ybTFpKGxvY2F0aW9uLCB2YWx1ZSBhcyBudW1iZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuaWZvcm0gbm90IGltcGxlbWVudGVkOiAke3R5cGV9YCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGJpbmRUZXh0dXJlKHRkOiBUZXh0dXJlRGF0YSwgdW5pZm9ybUhhbmRsZTogV2ViR0xVbmlmb3JtTG9jYXRpb24sIHBvc2l0aW9uOiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLmdsQ29udGV4dC5iaW5kVGV4dHVyZVRvVW5pZm9ybSh0ZC50ZXh0dXJlLCBwb3NpdGlvbiwgdW5pZm9ybUhhbmRsZSk7XG4gIH1cbiAgZ2V0QXR0cmliTG9jYXRpb25zKHByb2dyYW06IFdlYkdMUHJvZ3JhbSk6IEFydGlmYWN0LkF0dHJpYkxvY2F0aW9ucyB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBvc2l0aW9uOiB0aGlzLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdwb3NpdGlvbicpLFxuICAgICAgdGV4dHVyZUNvb3JkOiB0aGlzLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICd0ZXh0dXJlQ29vcmQnKVxuICAgIH07XG4gIH1cbiAgZ2V0VW5pZm9ybUxvY2F0aW9ucyhwcm9ncmFtOiBXZWJHTFByb2dyYW0sIHNhbXBsZXJzPzogc3RyaW5nW10sIHZhcmlhYmxlcz86IFZhcmlhYmxlSW5mb1tdKTpcbiAgICAgIEFydGlmYWN0LlVuaWZvcm1Mb2NhdGlvbnMge1xuICAgIGNvbnN0IHVuaWZvcm1Mb2NhdGlvbnM6IEFydGlmYWN0LlVuaWZvcm1Mb2NhdGlvbnMgPSBbXTtcbiAgICBpZiAoc2FtcGxlcnMpIHtcbiAgICAgIGZvciAoY29uc3Qgc2FtcGxlciBvZiBzYW1wbGVycykge1xuICAgICAgICB1bmlmb3JtTG9jYXRpb25zLnB1c2goe25hbWU6IHNhbXBsZXIsIHR5cGU6ICdzYW1wbGVyMkQnLCBsb2NhdGlvbjogdGhpcy5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgc2FtcGxlcil9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHZhcmlhYmxlcykge1xuICAgICAgZm9yIChjb25zdCB2YXJpYWJsZSBvZiB2YXJpYWJsZXMpIHtcbiAgICAgICAgdW5pZm9ybUxvY2F0aW9ucy5wdXNoKHsuLi52YXJpYWJsZSwgbG9jYXRpb246IHRoaXMuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIHZhcmlhYmxlLm5hbWUpfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1bmlmb3JtTG9jYXRpb25zO1xuICB9XG4gIGdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtOiBXZWJHTFByb2dyYW0sIG5hbWU6IHN0cmluZyk6IFdlYkdMVW5pZm9ybUxvY2F0aW9uIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuZ2xDb250ZXh0LmdsO1xuICAgIGNvbnN0IHJlZmVyZW5jZSA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCBuYW1lKTtcbiAgICBpZiAocmVmZXJlbmNlID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuaWZvcm0gJHtuYW1lfSBub3QgZm91bmQuYCk7XG4gICAgfVxuICAgIHJldHVybiByZWZlcmVuY2U7XG4gIH1cbiAgZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbTogV2ViR0xQcm9ncmFtLCBuYW1lOiBzdHJpbmcpOiBudW1iZXIge1xuICAgIGNvbnN0IGdsID0gdGhpcy5nbENvbnRleHQuZ2w7XG4gICAgY29uc3QgYXR0cmlidXRlTG9jYXRpb246IG51bWJlciA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sIG5hbWUpO1xuICAgIHJldHVybiBhdHRyaWJ1dGVMb2NhdGlvbjtcbiAgfVxufVxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0xvZ2dlciwgUHJvZmlsZXJ9IGZyb20gJy4uLy4uL2luc3RydW1lbnQnO1xuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4uLy4uL3RlbnNvcic7XG5cbmltcG9ydCB7RW5jb2RlciwgRW5jb2RlclVzYWdlfSBmcm9tICcuL3RleHR1cmUtZGF0YS1lbmNvZGVyJztcbmltcG9ydCB7VGV4dHVyZUxheW91dFN0cmF0ZWd5fSBmcm9tICcuL3RleHR1cmUtbGF5b3V0LXN0cmF0ZWd5JztcbmltcG9ydCB7VGV4dHVyZURhdGEsIFRleHR1cmVMYXlvdXR9IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHtXZWJHTENvbnRleHR9IGZyb20gJy4vd2ViZ2wtY29udGV4dCc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVGV4dHVyZU1hbmFnZXJDb25maWcge1xuICByZXVzZVRleHR1cmVzPzogYm9vbGVhbjtcbn1cblxuLyoqXG4gKiBUZXh0dXJlTWFuYWdlciBpcyB0aGUgbWFpbmx5IHJlc3BvbnNpYmxlIGZvciBjYWNoaW5nIFRleHR1cmVzXG4gKiBUZXh0dXJlcyBhcmUgY2FjaGVkIGluIDIgbGV2ZWxzOlxuICogICAxLiB0aGUgdGV4dXJlcyB3aGljaCBhcmUgYXNzb2NpYXRlZCB3aXRoIGEgZGF0YUlkIChmcm9tIFRlbnNvcilcbiAqICAgIENhY2hpbmcgdGhlc2UgaXMgY3J1Y2lhbCB0byBwZXJmb3JtYW5jZS4gVGhlc2UgYXJlIEluLXVzZSBUZXh0dXJlc1xuICogICAyLiB0ZXh0dXJlcyB3aGljaCBhcmUgbm90IGluIHVzZSBieSBhbnkgY3VycmVudCBQcm9ncmFtSW5mby9UZW5zb3JcbiAqICAgICBUaGVzZSBhcmUgY2FsbGVkIEZyZWUgVGV4dHVyZXNcbiAqIFRleHR1cmVNYW5hZ2VyIGlzIGFsc28gdXNlZCB0byBoZWxwIGNyZWF0aW5nIHRleHR1cmVzLiBGb3IgdGhpcyBpdFxuICogdXNlcyBXZWJHTENvbnRleHQgYW5kIFRleHR1cmVMYXlvdXRTdHJhdGVneVxuICovXG5leHBvcnQgY2xhc3MgVGV4dHVyZU1hbmFnZXIge1xuICBwcml2YXRlIHJlYWRvbmx5IGluVXNlVGV4dHVyZXM6IE1hcDxzdHJpbmcsIFdlYkdMVGV4dHVyZVtdPjtcbiAgcHJpdmF0ZSByZWFkb25seSBpZGxlVGV4dHVyZXM6IE1hcDxzdHJpbmcsIFdlYkdMVGV4dHVyZVtdPjtcbiAgcHJpdmF0ZSByZWFkb25seSB0ZXh0dXJlTG9va3VwOiBNYXA8V2ViR0xUZXh0dXJlLCBzdHJpbmc+O1xuICBwcml2YXRlIHJlYWRvbmx5IHBlbmRpbmdSZWFkOiBNYXA8VGVuc29yLklkLCBBcnJheTwoYXJyOiBUZW5zb3IuTnVtYmVyVHlwZSkgPT4gdm9pZD4+ID0gbmV3IE1hcCgpO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgICAgcHVibGljIGdsQ29udGV4dDogV2ViR0xDb250ZXh0LCBwdWJsaWMgbGF5b3V0U3RyYXRlZ3k6IFRleHR1cmVMYXlvdXRTdHJhdGVneSwgcHVibGljIHByb2ZpbGVyOiBSZWFkb25seTxQcm9maWxlcj4sXG4gICAgICBwcml2YXRlIGNvbmZpZzogVGV4dHVyZU1hbmFnZXJDb25maWcpIHtcbiAgICBpZiAoY29uZmlnLnJldXNlVGV4dHVyZXMpIHtcbiAgICAgIHRoaXMuaW5Vc2VUZXh0dXJlcyA9IG5ldyBNYXAoKTtcbiAgICAgIHRoaXMuaWRsZVRleHR1cmVzID0gbmV3IE1hcCgpO1xuICAgICAgdGhpcy50ZXh0dXJlTG9va3VwID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgfVxuICBjcmVhdGVUZXh0dXJlRnJvbUxheW91dChcbiAgICAgIGRhdGFUeXBlOiBUZW5zb3IuRGF0YVR5cGUsIGxheW91dDogVGV4dHVyZUxheW91dCwgZGF0YT86IFRlbnNvci5OdW1iZXJUeXBlLCB1c2FnZT86IEVuY29kZXJVc2FnZSkge1xuICAgIGNvbnN0IHRleHR1cmVEYXRhVHlwZSA9IHRoaXMudG9FbmNvZGVyVHlwZShkYXRhVHlwZSk7XG5cbiAgICBjb25zdCBlbmNvZGVyID0gdGhpcy5nbENvbnRleHQuZ2V0RW5jb2Rlcih0ZXh0dXJlRGF0YVR5cGUsIGxheW91dC5jaGFubmVscyB8fCAxLCB1c2FnZSk7XG4gICAgaWYgKGxheW91dC5pc1BhY2tlZCAmJiB1c2FnZSA9PT0gRW5jb2RlclVzYWdlLlVwbG9hZE9ubHkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJyk7XG4gICAgfVxuICAgIGNvbnN0IHdpZHRoID0gbGF5b3V0LndpZHRoO1xuICAgIGNvbnN0IGhlaWdodCA9IGxheW91dC5oZWlnaHQ7XG5cbiAgICBsZXQga2V5OiBzdHJpbmd8dW5kZWZpbmVkO1xuICAgIGxldCBpblVzZVRleHR1cmVzOiBXZWJHTFRleHR1cmVbXXx1bmRlZmluZWQ7XG4gICAgaWYgKHRoaXMuY29uZmlnLnJldXNlVGV4dHVyZXMpIHtcbiAgICAgIGtleSA9IGAke3dpZHRofXgke2hlaWdodH1fJHtlbmNvZGVyLmZvcm1hdH1fJHtlbmNvZGVyLmludGVybmFsRm9ybWF0fV8ke2VuY29kZXIudGV4dHVyZVR5cGV9YDtcbiAgICAgIGluVXNlVGV4dHVyZXMgPSB0aGlzLmluVXNlVGV4dHVyZXMuZ2V0KGtleSk7XG4gICAgICBpZiAoIWluVXNlVGV4dHVyZXMpIHtcbiAgICAgICAgaW5Vc2VUZXh0dXJlcyA9IFtdO1xuICAgICAgICB0aGlzLmluVXNlVGV4dHVyZXMuc2V0KGtleSwgaW5Vc2VUZXh0dXJlcyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGlkbGVUZXh0dXJlcyA9IHRoaXMuaWRsZVRleHR1cmVzLmdldChrZXkpO1xuICAgICAgaWYgKGlkbGVUZXh0dXJlcyAmJiBpZGxlVGV4dHVyZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCB0ZXh0dXJlID0gaWRsZVRleHR1cmVzLnBvcCgpITtcbiAgICAgICAgaW5Vc2VUZXh0dXJlcy5wdXNoKHRleHR1cmUpO1xuICAgICAgICBpZiAodXNhZ2UgPT09IEVuY29kZXJVc2FnZS5VcGxvYWRPbmx5KSB7XG4gICAgICAgICAgdGhpcy5nbENvbnRleHQudXBkYXRlVGV4dHVyZSh0ZXh0dXJlLCB3aWR0aCwgaGVpZ2h0LCBlbmNvZGVyLCB0aGlzLnRvVGV4dHVyZURhdGEoZGF0YVR5cGUsIGRhdGEpISk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRleHR1cmU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgTG9nZ2VyLnZlcmJvc2UoJ1RleHR1cmVNYW5hZ2VyJywgYENyZWF0aW5nIG5ldyB0ZXh0dXJlIG9mIHNpemUgJHtsYXlvdXQud2lkdGh9eCR7bGF5b3V0LmhlaWdodH1gKTtcbiAgICBjb25zdCB0ZXh0dXJlID0gdGhpcy5nbENvbnRleHQuYWxsb2NhdGVUZXh0dXJlKHdpZHRoLCBoZWlnaHQsIGVuY29kZXIsIHRoaXMudG9UZXh0dXJlRGF0YShkYXRhVHlwZSwgZGF0YSkpO1xuXG4gICAgaWYgKHRoaXMuY29uZmlnLnJldXNlVGV4dHVyZXMpIHtcbiAgICAgIGluVXNlVGV4dHVyZXMhLnB1c2godGV4dHVyZSk7XG4gICAgICB0aGlzLnRleHR1cmVMb29rdXAuc2V0KHRleHR1cmUsIGtleSEpO1xuICAgIH1cbiAgICByZXR1cm4gdGV4dHVyZTtcbiAgfVxuICByZWFkVGV4dHVyZSh0ZDogVGV4dHVyZURhdGEsIGRhdGFUeXBlOiBUZW5zb3IuRGF0YVR5cGUsIGNoYW5uZWxzPzogbnVtYmVyKTogVGVuc29yLk51bWJlclR5cGUge1xuICAgIGlmICghY2hhbm5lbHMpIHtcbiAgICAgIGNoYW5uZWxzID0gMTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucHJvZmlsZXIuZXZlbnQoJ2JhY2tlbmQnLCAnVGV4dHVyZU1hbmFnZXIucmVhZFRleHR1cmUnLCAoKSA9PiB7XG4gICAgICBjb25zdCBkYXRhU2l6ZSA9IHRkLnNoYXBlLnJlZHVjZSgoYSwgYikgPT4gYSAqIGIpICogY2hhbm5lbHMhO1xuICAgICAgY29uc3QgZGF0YSA9IHRoaXMuZ2xDb250ZXh0LnJlYWRUZXh0dXJlKFxuICAgICAgICAgIHRkLnRleHR1cmUsIHRkLndpZHRoLCB0ZC5oZWlnaHQsIGRhdGFTaXplLCB0aGlzLnRvRW5jb2RlclR5cGUoZGF0YVR5cGUpLCBjaGFubmVscyEpO1xuICAgICAgcmV0dXJuIHRoaXMudG9UZW5zb3JEYXRhKGRhdGFUeXBlLCBkYXRhKTtcbiAgICB9KTtcbiAgfVxuICBhc3luYyByZWFkVGV4dHVyZUFzeW5jKHRkOiBUZXh0dXJlRGF0YSwgZGF0YVR5cGU6IFRlbnNvci5EYXRhVHlwZSwgY2hhbm5lbHM/OiBudW1iZXIpOiBQcm9taXNlPFRlbnNvci5OdW1iZXJUeXBlPiB7XG4gICAgY29uc3QgZGF0YUlkID0gdGQudGVuc29yLmRhdGFJZDtcbiAgICBpZiAoIWNoYW5uZWxzKSB7XG4gICAgICBjaGFubmVscyA9IDE7XG4gICAgfVxuICAgIGlmICh0aGlzLnBlbmRpbmdSZWFkLmhhcyhkYXRhSWQpKSB7XG4gICAgICBjb25zdCBzdWJzY3JpYmVycyA9IHRoaXMucGVuZGluZ1JlYWQuZ2V0KGRhdGFJZCk7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2U8VGVuc29yLk51bWJlclR5cGU+KHJlc29sdmUgPT4gc3Vic2NyaWJlcnM/LnB1c2gocmVzb2x2ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wcm9maWxlci5ldmVudCgnYmFja2VuZCcsICdUZXh0dXJlTWFuYWdlci5yZWFkVGV4dHVyZUFzeW5jJywgYXN5bmMgKCkgPT4ge1xuICAgICAgdGhpcy5wZW5kaW5nUmVhZC5zZXQoZGF0YUlkLCBbXSk7XG4gICAgICBjb25zdCBkYXRhU2l6ZSA9IHRkLnNoYXBlLnJlZHVjZSgoYSwgYikgPT4gYSAqIGIpICogY2hhbm5lbHMhO1xuICAgICAgLy8gYWRkIGEgZmVuY2Ugd2FpdGluZyBmb3IgdGhlIGRhdGEgdG8gYmUgcmVhZHlcbiAgICAgIGF3YWl0IHRoaXMuZ2xDb250ZXh0LmNyZWF0ZUFuZFdhaXRGb3JGZW5jZSgpO1xuICAgICAgY29uc3QgZGF0YSA9IHRoaXMuZ2xDb250ZXh0LnJlYWRUZXh0dXJlKFxuICAgICAgICAgIHRkLnRleHR1cmUsIHRkLndpZHRoLCB0ZC5oZWlnaHQsIGRhdGFTaXplLCB0aGlzLnRvRW5jb2RlclR5cGUoZGF0YVR5cGUpLCBjaGFubmVscyEpO1xuICAgICAgY29uc3QgdGVuc29yRGF0YSA9IHRoaXMudG9UZW5zb3JEYXRhKGRhdGFUeXBlLCBkYXRhKTtcbiAgICAgIGNvbnN0IHN1YnNjcmliZXJzID0gdGhpcy5wZW5kaW5nUmVhZC5nZXQoZGF0YUlkKTtcbiAgICAgIHRoaXMucGVuZGluZ1JlYWQuZGVsZXRlKGRhdGFJZCk7XG4gICAgICBzdWJzY3JpYmVycz8uZm9yRWFjaChyZXNvbHZlID0+IHJlc29sdmUodGVuc29yRGF0YSkpO1xuICAgICAgcmV0dXJuIHRlbnNvckRhdGE7XG4gICAgfSk7XG4gIH1cbiAgcmVhZFVpbnQ4VGV4dHVyZUFzRmxvYXQodGQ6IFRleHR1cmVEYXRhKTogRmxvYXQzMkFycmF5IHtcbiAgICByZXR1cm4gdGhpcy5wcm9maWxlci5ldmVudCgnYmFja2VuZCcsICdUZXh0dXJlTWFuYWdlci5yZWFkVWludDhUZXh0dXJlQXNGbG9hdCcsICgpID0+IHtcbiAgICAgIGNvbnN0IGRhdGFTaXplID0gdGQuc2hhcGUucmVkdWNlKChhLCBiKSA9PiBhICogYik7XG4gICAgICBjb25zdCBkYXRhID0gdGhpcy5nbENvbnRleHQucmVhZFRleHR1cmUodGQudGV4dHVyZSwgdGQud2lkdGgsIHRkLmhlaWdodCwgZGF0YVNpemUgKiA0LCAnYnl0ZScsIDQpO1xuICAgICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoZGF0YS5idWZmZXIsIGRhdGEuYnl0ZU9mZnNldCwgZGF0YVNpemUpO1xuICAgIH0pO1xuICB9XG4gIHJlbGVhc2VUZXh0dXJlKHRleHR1cmVEYXRhOiBUZXh0dXJlRGF0YSwgZGVsZXRlVGV4dHVyZT86IGJvb2xlYW4pOiB2b2lkIHtcbiAgICBsZXQga2V5OiBzdHJpbmd8dW5kZWZpbmVkO1xuICAgIGlmICh0aGlzLmNvbmZpZy5yZXVzZVRleHR1cmVzKSB7XG4gICAgICBrZXkgPSB0aGlzLnRleHR1cmVMb29rdXAuZ2V0KHRleHR1cmVEYXRhLnRleHR1cmUpO1xuICAgICAgaWYgKGtleSkge1xuICAgICAgICBpZiAoZGVsZXRlVGV4dHVyZSkge1xuICAgICAgICAgIHRoaXMudGV4dHVyZUxvb2t1cC5kZWxldGUoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpblVzZVRleHR1cmVzID0gdGhpcy5pblVzZVRleHR1cmVzLmdldChrZXkpO1xuICAgICAgICBpZiAoaW5Vc2VUZXh0dXJlcykge1xuICAgICAgICAgIGNvbnN0IGluZGV4ID0gaW5Vc2VUZXh0dXJlcy5pbmRleE9mKHRleHR1cmVEYXRhLnRleHR1cmUpO1xuICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgIGluVXNlVGV4dHVyZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIGxldCBpZGxlVGV4dHVyZXMgPSB0aGlzLmlkbGVUZXh0dXJlcy5nZXQoa2V5KTtcbiAgICAgICAgICAgIGlmICghaWRsZVRleHR1cmVzKSB7XG4gICAgICAgICAgICAgIGlkbGVUZXh0dXJlcyA9IFtdO1xuICAgICAgICAgICAgICB0aGlzLmlkbGVUZXh0dXJlcy5zZXQoa2V5LCBpZGxlVGV4dHVyZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWRsZVRleHR1cmVzLnB1c2godGV4dHVyZURhdGEudGV4dHVyZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFrZXkgfHwgZGVsZXRlVGV4dHVyZSkge1xuICAgICAgTG9nZ2VyLnZlcmJvc2UoJ1RleHR1cmVNYW5hZ2VyJywgYERlbGV0aW5nIHRleHR1cmUgb2Ygc2l6ZSAke3RleHR1cmVEYXRhLndpZHRofXgke3RleHR1cmVEYXRhLmhlaWdodH1gKTtcbiAgICAgIHRoaXMuZ2xDb250ZXh0LmRlbGV0ZVRleHR1cmUodGV4dHVyZURhdGEudGV4dHVyZSk7XG4gICAgfVxuICB9XG4gIHRvVGVuc29yRGF0YShkYXRhVHlwZTogVGVuc29yLkRhdGFUeXBlLCBkYXRhOiBFbmNvZGVyLkRhdGFBcnJheVR5cGUpOiBUZW5zb3IuTnVtYmVyVHlwZSB7XG4gICAgc3dpdGNoIChkYXRhVHlwZSkge1xuICAgICAgY2FzZSAnaW50MTYnOlxuICAgICAgICByZXR1cm4gZGF0YSBpbnN0YW5jZW9mIEludDE2QXJyYXkgPyBkYXRhIDogSW50MTZBcnJheS5mcm9tKGRhdGEpO1xuICAgICAgY2FzZSAnaW50MzInOlxuICAgICAgICByZXR1cm4gZGF0YSBpbnN0YW5jZW9mIEludDMyQXJyYXkgPyBkYXRhIDogSW50MzJBcnJheS5mcm9tKGRhdGEpO1xuICAgICAgY2FzZSAnaW50OCc6XG4gICAgICAgIHJldHVybiBkYXRhIGluc3RhbmNlb2YgSW50OEFycmF5ID8gZGF0YSA6IEludDhBcnJheS5mcm9tKGRhdGEpO1xuICAgICAgY2FzZSAndWludDE2JzpcbiAgICAgICAgcmV0dXJuIGRhdGEgaW5zdGFuY2VvZiBVaW50MTZBcnJheSA/IGRhdGEgOiBVaW50MTZBcnJheS5mcm9tKGRhdGEpO1xuICAgICAgY2FzZSAndWludDMyJzpcbiAgICAgICAgcmV0dXJuIGRhdGEgaW5zdGFuY2VvZiBVaW50MzJBcnJheSA/IGRhdGEgOiBVaW50MzJBcnJheS5mcm9tKGRhdGEpO1xuICAgICAgY2FzZSAndWludDgnOlxuICAgICAgY2FzZSAnYm9vbCc6XG4gICAgICAgIHJldHVybiBkYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSA/IGRhdGEgOiBVaW50OEFycmF5LmZyb20oZGF0YSk7XG4gICAgICBjYXNlICdmbG9hdDMyJzpcbiAgICAgICAgcmV0dXJuIGRhdGEgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkgPyBkYXRhIDogRmxvYXQzMkFycmF5LmZyb20oZGF0YSk7XG4gICAgICBjYXNlICdmbG9hdDY0JzpcbiAgICAgICAgcmV0dXJuIGRhdGEgaW5zdGFuY2VvZiBGbG9hdDY0QXJyYXkgPyBkYXRhIDogRmxvYXQ2NEFycmF5LmZyb20oZGF0YSk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRlbnNvckRhdGEgdHlwZSAke2RhdGFUeXBlfSBpcyBub3Qgc3VwcG9ydGVkYCk7XG4gICAgfVxuICB9XG4gIHRvVGV4dHVyZURhdGEoX2RhdGFUeXBlOiBUZW5zb3IuRGF0YVR5cGUsIGRhdGE6IFRlbnNvci5OdW1iZXJUeXBlfHVuZGVmaW5lZCk6IEVuY29kZXIuRGF0YUFycmF5VHlwZXx1bmRlZmluZWQge1xuICAgIGlmICghZGF0YSkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIChkYXRhIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5KSA/IGRhdGEgOiBuZXcgRmxvYXQzMkFycmF5KGRhdGEpO1xuICAgIC8qXG4gICAgc3dpdGNoIChkYXRhVHlwZSkge1xuICAgICAgY2FzZSAnaW50MTYnOlxuICAgICAgY2FzZSAnaW50MzInOlxuICAgICAgY2FzZSAndWludDE2JzpcbiAgICAgIGNhc2UgJ3VpbnQzMic6XG4gICAgICAgIHJldHVybiAoZGF0YS5jb25zdHJ1Y3RvciA9PT0gVWludDMyQXJyYXkpID8gZGF0YSBhcyBVaW50MzJBcnJheSA6IG5ldyBVaW50MzJBcnJheShkYXRhKTtcbiAgICAgIGNhc2UgJ2ludDgnOlxuICAgICAgY2FzZSAndWludDgnOlxuICAgICAgY2FzZSAnYm9vbCc6XG4gICAgICAgIHJldHVybiAoZGF0YS5jb25zdHJ1Y3RvciA9PT0gVWludDhBcnJheSkgPyBkYXRhIGFzIFVpbnQ4QXJyYXkgOiBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgICAgIGNhc2UgJ2Zsb2F0MzInOlxuICAgICAgY2FzZSAnZmxvYXQ2NCc6XG4gICAgICAgIHJldHVybiAoZGF0YS5jb25zdHJ1Y3RvciA9PT0gRmxvYXQzMkFycmF5KSA/IGRhdGEgYXMgRmxvYXQzMkFycmF5IDogbmV3IEZsb2F0MzJBcnJheShkYXRhKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVGVuc29yRGF0YSB0eXBlICR7ZGF0YVR5cGV9IGlzIG5vdCBzdXBwb3J0ZWRgKTtcbiAgICB9XG4gICAgKi9cbiAgfVxuICB0b0VuY29kZXJUeXBlKF9kYXRhVHlwZTogVGVuc29yLkRhdGFUeXBlKTogRW5jb2Rlci5EYXRhVHlwZSB7XG4gICAgcmV0dXJuICdmbG9hdCc7XG4gICAgLy8gc3dpdGNoIChkYXRhVHlwZSkge1xuICAgIC8vICAgY2FzZSAnaW50MTYnOlxuICAgIC8vICAgY2FzZSAnaW50MzInOlxuICAgIC8vICAgY2FzZSAndWludDE2JzpcbiAgICAvLyAgIGNhc2UgJ3VpbnQzMic6XG4gICAgLy8gICAgIHJldHVybiAnaW50JztcbiAgICAvLyAgIGNhc2UgJ3VpbnQ4JzpcbiAgICAvLyAgIGNhc2UgJ2Jvb2wnOlxuICAgIC8vICAgICByZXR1cm4gJ2J5dGUnO1xuICAgIC8vICAgY2FzZSAnZmxvYXQzMic6XG4gICAgLy8gICBjYXNlICdmbG9hdDY0JzpcbiAgICAvLyAgICAgcmV0dXJuICdmbG9hdCc7XG4gICAgLy8gICBkZWZhdWx0OlxuICAgIC8vICAgICB0aHJvdyBuZXcgRXJyb3IoYFRlbnNvckRhdGEgdHlwZSAke2RhdGFUeXBlfSBpcyBub3Qgc3VwcG9ydGVkYCk7XG4gICAgLy8gfVxuICB9XG4gIGNsZWFyQWN0aXZlVGV4dHVyZXMoKTogdm9pZCB7XG4gICAgdGhpcy5nbENvbnRleHQuY2xlYXJBY3RpdmVUZXh0dXJlcygpO1xuICB9XG59XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7U2Vzc2lvbkhhbmRsZXJ9IGZyb20gJy4uLy4uL2JhY2tlbmQnO1xuaW1wb3J0IHtHcmFwaH0gZnJvbSAnLi4vLi4vZ3JhcGgnO1xuaW1wb3J0IHtMb2dnZXJ9IGZyb20gJy4uLy4uL2luc3RydW1lbnQnO1xuaW1wb3J0IHtPcGVyYXRvcn0gZnJvbSAnLi4vLi4vb3BlcmF0b3JzJztcbmltcG9ydCB7T3BTZXQsIHJlc29sdmVPcGVyYXRvcn0gZnJvbSAnLi4vLi4vb3BzZXQnO1xuaW1wb3J0IHtTZXNzaW9ufSBmcm9tICcuLi8uLi9zZXNzaW9uJztcbmltcG9ydCB7VGVuc29yfSBmcm9tICcuLi8uLi90ZW5zb3InO1xuaW1wb3J0IHtXZWJHTEJhY2tlbmR9IGZyb20gJy4uL2JhY2tlbmQtd2ViZ2wnO1xuXG5pbXBvcnQge1dlYkdMSW5mZXJlbmNlSGFuZGxlcn0gZnJvbSAnLi9pbmZlcmVuY2UtaGFuZGxlcic7XG5pbXBvcnQge1dFQkdMX09QX1JFU09MVkVfUlVMRVN9IGZyb20gJy4vb3AtcmVzb2x2ZS1ydWxlcyc7XG5pbXBvcnQge1Byb2dyYW1NYW5hZ2VyfSBmcm9tICcuL3Byb2dyYW0tbWFuYWdlcic7XG5pbXBvcnQge1ByZWZlckxvZ2ljYWxTdHJhdGVneSwgVGV4dHVyZUxheW91dFN0cmF0ZWd5fSBmcm9tICcuL3RleHR1cmUtbGF5b3V0LXN0cmF0ZWd5JztcbmltcG9ydCB7VGV4dHVyZU1hbmFnZXJ9IGZyb20gJy4vdGV4dHVyZS1tYW5hZ2VyJztcbmltcG9ydCB7VGV4dHVyZURhdGF9IGZyb20gJy4vdHlwZXMnO1xuXG5leHBvcnQgY2xhc3MgV2ViR0xTZXNzaW9uSGFuZGxlciBpbXBsZW1lbnRzIFNlc3Npb25IYW5kbGVyIHtcbiAgcHJvZ3JhbU1hbmFnZXI6IFByb2dyYW1NYW5hZ2VyO1xuICB0ZXh0dXJlTWFuYWdlcjogVGV4dHVyZU1hbmFnZXI7XG4gIGxheW91dFN0cmF0ZWd5OiBUZXh0dXJlTGF5b3V0U3RyYXRlZ3k7XG4gIHBhY2tlZFRleHR1cmVEYXRhQ2FjaGU6IE1hcDxUZW5zb3IuSWQsIFRleHR1cmVEYXRhPjtcbiAgdW5wYWNrZWRUZXh0dXJlRGF0YUNhY2hlOiBNYXA8VGVuc29yLklkLCBUZXh0dXJlRGF0YT47XG4gIHBhY2sydW5wYWNrTWFwOiBNYXA8VGVuc29yLklkLCBUZW5zb3IuSWQ+O1xuICB1bnBhY2sycGFja01hcDogTWFwPFRlbnNvci5JZCwgVGVuc29yLklkPjtcbiAgaW5pdGlhbGl6ZXJzOiBTZXQ8VGVuc29yLklkPjtcbiAgcGFjaz86IGJvb2xlYW47XG5cbiAgY29uc3RydWN0b3IocHVibGljIHJlYWRvbmx5IGJhY2tlbmQ6IFdlYkdMQmFja2VuZCwgcHVibGljIHJlYWRvbmx5IGNvbnRleHQ6IFNlc3Npb24uQ29udGV4dCkge1xuICAgIHRoaXMubGF5b3V0U3RyYXRlZ3kgPSBuZXcgUHJlZmVyTG9naWNhbFN0cmF0ZWd5KGJhY2tlbmQuZ2xDb250ZXh0Lm1heFRleHR1cmVTaXplKTtcbiAgICB0aGlzLnByb2dyYW1NYW5hZ2VyID0gbmV3IFByb2dyYW1NYW5hZ2VyKHRoaXMuY29udGV4dC5wcm9maWxlciwgYmFja2VuZC5nbENvbnRleHQsIHRoaXMubGF5b3V0U3RyYXRlZ3kpO1xuICAgIHRoaXMudGV4dHVyZU1hbmFnZXIgPSBuZXcgVGV4dHVyZU1hbmFnZXIoXG4gICAgICAgIGJhY2tlbmQuZ2xDb250ZXh0LCB0aGlzLmxheW91dFN0cmF0ZWd5LCB0aGlzLmNvbnRleHQucHJvZmlsZXIsXG4gICAgICAgIHtyZXVzZVRleHR1cmVzOiBiYWNrZW5kLnRleHR1cmVDYWNoZU1vZGUgPT09ICdmdWxsJ30pO1xuICAgIHRoaXMucGFja2VkVGV4dHVyZURhdGFDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLnVucGFja2VkVGV4dHVyZURhdGFDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLnBhY2sgPSBiYWNrZW5kLnBhY2s7XG4gICAgdGhpcy5wYWNrMnVucGFja01hcCA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLnVucGFjazJwYWNrTWFwID0gbmV3IE1hcCgpO1xuICB9XG5cbiAgY3JlYXRlSW5mZXJlbmNlSGFuZGxlcigpIHtcbiAgICByZXR1cm4gbmV3IFdlYkdMSW5mZXJlbmNlSGFuZGxlcih0aGlzKTtcbiAgfVxuICBvbkdyYXBoSW5pdGlhbGl6ZWQoZ3JhcGg6IEdyYXBoKTogdm9pZCB7XG4gICAgY29uc3QgaW5pdGlhbGl6ZXJzID0gZ3JhcGguZ2V0VmFsdWVzKCkuZmlsdGVyKHYgPT4gdi5mcm9tID09PSAtMSAmJiB2LnRlbnNvcikubWFwKHYgPT4gdi50ZW5zb3IhLmRhdGFJZCk7XG4gICAgdGhpcy5pbml0aWFsaXplcnMgPSBuZXcgU2V0KGluaXRpYWxpemVycyk7XG4gIH1cbiAgaXNJbml0aWFsaXplcih0ZW5zb3JJZDogVGVuc29yLklkKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuaW5pdGlhbGl6ZXJzID8gdGhpcy5pbml0aWFsaXplcnMuaGFzKHRlbnNvcklkKSA6IGZhbHNlO1xuICB9XG4gIGFkZEluaXRpYWxpemVyKHRlbnNvcklkOiBUZW5zb3IuSWQpOiB2b2lkIHtcbiAgICB0aGlzLmluaXRpYWxpemVycy5hZGQodGVuc29ySWQpO1xuICB9XG4gIGdldFRleHR1cmVEYXRhKHRlbnNvcklkOiBUZW5zb3IuSWQsIGlzUGFja2VkOiBib29sZWFuKTogVGV4dHVyZURhdGF8dW5kZWZpbmVkIHtcbiAgICBpZiAoaXNQYWNrZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhY2tlZFRleHR1cmVEYXRhQ2FjaGUuZ2V0KHRlbnNvcklkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMudW5wYWNrZWRUZXh0dXJlRGF0YUNhY2hlLmdldCh0ZW5zb3JJZCk7XG4gICAgfVxuICB9XG4gIHNldFRleHR1cmVEYXRhKHRlbnNvcklkOiBUZW5zb3IuSWQsIHRleHR1cmVEYXRhOiBUZXh0dXJlRGF0YSwgaXNQYWNrZWQgPSBmYWxzZSk6IHZvaWQge1xuICAgIExvZ2dlci52ZXJib3NlKCdXZWJHTFNlc3Npb25IYW5kbGVyJywgJ1N0b3JpbmcgVGV4dHVyZSBkYXRhIGluIGNhY2hlJyk7XG4gICAgaWYgKGlzUGFja2VkKSB7XG4gICAgICB0aGlzLnBhY2tlZFRleHR1cmVEYXRhQ2FjaGUuc2V0KHRlbnNvcklkLCB0ZXh0dXJlRGF0YSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudW5wYWNrZWRUZXh0dXJlRGF0YUNhY2hlLnNldCh0ZW5zb3JJZCwgdGV4dHVyZURhdGEpO1xuICAgIH1cbiAgfVxuICBkaXNwb3NlKCk6IHZvaWQge1xuICAgIHRoaXMucHJvZ3JhbU1hbmFnZXIuZGlzcG9zZSgpO1xuICAgIHRoaXMudGV4dHVyZU1hbmFnZXIuY2xlYXJBY3RpdmVUZXh0dXJlcygpO1xuICAgIHRoaXMucGFja2VkVGV4dHVyZURhdGFDYWNoZS5mb3JFYWNoKHRkID0+IHRoaXMudGV4dHVyZU1hbmFnZXIucmVsZWFzZVRleHR1cmUodGQsIHRydWUpKTtcbiAgICB0aGlzLnBhY2tlZFRleHR1cmVEYXRhQ2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy51bnBhY2tlZFRleHR1cmVEYXRhQ2FjaGUuZm9yRWFjaCh0ZCA9PiB0aGlzLnRleHR1cmVNYW5hZ2VyLnJlbGVhc2VUZXh0dXJlKHRkLCB0cnVlKSk7XG4gICAgdGhpcy51bnBhY2tlZFRleHR1cmVEYXRhQ2FjaGUgPSBuZXcgTWFwKCk7XG4gIH1cbiAgcmVzb2x2ZShub2RlOiBHcmFwaC5Ob2RlLCBvcHNldHM6IHJlYWRvbmx5IE9wU2V0W10sIGdyYXBoOiBHcmFwaCk6IE9wZXJhdG9yIHtcbiAgICBjb25zdCBvcCA9IHJlc29sdmVPcGVyYXRvcihub2RlLCBvcHNldHMsIFdFQkdMX09QX1JFU09MVkVfUlVMRVMpO1xuICAgIHJldHVybiB7aW1wbDogb3Aub3BJbXBsLCBjb250ZXh0OiBvcC5vcEluaXQgPyBvcC5vcEluaXQobm9kZSwgZ3JhcGgpIDogbm9kZX07XG4gIH1cbn1cbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtlbnZ9IGZyb20gJ29ubnhydW50aW1lLWNvbW1vbic7XG5cbmltcG9ydCAqIGFzIERhdGFFbmNvZGVycyBmcm9tICcuL3RleHR1cmUtZGF0YS1lbmNvZGVyJztcbmltcG9ydCB7RGF0YUVuY29kZXIsIEVuY29kZXIsIEVuY29kZXJVc2FnZX0gZnJvbSAnLi90ZXh0dXJlLWRhdGEtZW5jb2Rlcic7XG5pbXBvcnQge3JlcGVhdGVkVHJ5fSBmcm9tICcuL3V0aWxzJztcblxuZXhwb3J0IGludGVyZmFjZSBGZW5jZUNvbnRleHQge1xuICBxdWVyeTogV2ViR0xTeW5jfG51bGw7XG4gIGlzRmVuY2VQYXNzZWQoKTogYm9vbGVhbjtcbn1cblxudHlwZSBQb2xsSXRlbSA9IHtcbiAgaXNEb25lRm46ICgpID0+IGJvb2xlYW47IHJlc29sdmVGbjogKCkgPT4gdm9pZDtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBsaW5lYXJTZWFyY2hMYXN0VHJ1ZShhcnI6IEFycmF5PCgpID0+IGJvb2xlYW4+KTogbnVtYmVyIHtcbiAgbGV0IGkgPSAwO1xuICBmb3IgKDsgaSA8IGFyci5sZW5ndGg7ICsraSkge1xuICAgIGNvbnN0IGlzRG9uZSA9IGFycltpXSgpO1xuICAgIGlmICghaXNEb25lKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGkgLSAxO1xufVxuXG4vKipcbiAqIEFic3RyYWN0aW9uIGFuZCB3cmFwcGVyIGFyb3VuZCBXZWJHTFJlbmRlcmluZ0NvbnRleHQgYW5kIGl0cyBvcGVyYXRpb25zXG4gKi9cbmV4cG9ydCBjbGFzcyBXZWJHTENvbnRleHQge1xuICBnbDogV2ViR0xSZW5kZXJpbmdDb250ZXh0O1xuICB2ZXJzaW9uOiAxfDI7XG5cbiAgcHJpdmF0ZSB2ZXJ0ZXhidWZmZXI6IFdlYkdMQnVmZmVyO1xuICBwcml2YXRlIGZyYW1lYnVmZmVyOiBXZWJHTEZyYW1lYnVmZmVyO1xuXG4gIC8vIFdlYkdMIGZsYWdzIGFuZCB2aXRhbCBwYXJhbWV0ZXJzXG4gIHByaXZhdGUgaXNGbG9hdFRleHR1cmVBdHRhY2hhYmxlVG9GcmFtZUJ1ZmZlcjogYm9vbGVhbjtcbiAgaXNGbG9hdDMyRG93bmxvYWRTdXBwb3J0ZWQ6IGJvb2xlYW47XG4gIGlzUmVuZGVyRmxvYXQzMlN1cHBvcnRlZDogYm9vbGVhbjtcbiAgaXNCbGVuZFN1cHBvcnRlZDogYm9vbGVhbjtcbiAgbWF4VGV4dHVyZVNpemU6IG51bWJlcjtcbiAgLy8gcHJpdmF0ZSBtYXhDb21iaW5lZFRleHR1cmVJbWFnZVVuaXRzOiBudW1iZXI7XG4gIHByaXZhdGUgbWF4VGV4dHVyZUltYWdlVW5pdHM6IG51bWJlcjtcbiAgLy8gcHJpdmF0ZSBtYXhDdWJlTWFwVGV4dHVyZVNpemU6IG51bWJlcjtcbiAgLy8gcHJpdmF0ZSBzaGFkaW5nTGFuZ3VhZ2VWZXJzaW9uOiBzdHJpbmc7XG4gIC8vIHByaXZhdGUgd2ViZ2xWZW5kb3I6IHN0cmluZztcbiAgLy8gcHJpdmF0ZSB3ZWJnbFZlcnNpb246IHN0cmluZztcblxuICAvLyBXZWJHTDIgZmxhZ3MgYW5kIHZpdGFsIHBhcmFtZXRlcnNcbiAgLy8gcHJpdmF0ZSBtYXgzRFRleHR1cmVTaXplOiBudW1iZXI7XG4gIC8vIHByaXZhdGUgbWF4QXJyYXlUZXh0dXJlTGF5ZXJzOiBudW1iZXI7XG4gIC8vIHByaXZhdGUgbWF4Q29sb3JBdHRhY2htZW50czogbnVtYmVyO1xuICAvLyBwcml2YXRlIG1heERyYXdCdWZmZXJzOiBudW1iZXI7XG5cbiAgLy8gV2ViR0wgZXh0ZW5zaW9uc1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY2FtZWxjYXNlXG4gIHRleHR1cmVGbG9hdEV4dGVuc2lvbjogT0VTX3RleHR1cmVfZmxvYXR8bnVsbDtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNhbWVsY2FzZVxuICB0ZXh0dXJlSGFsZkZsb2F0RXh0ZW5zaW9uOiBPRVNfdGV4dHVyZV9oYWxmX2Zsb2F0fG51bGw7XG5cbiAgLy8gV2ViR0wyIGV4dGVuc2lvbnNcbiAgY29sb3JCdWZmZXJGbG9hdEV4dGVuc2lvbjogdW5rbm93bnxudWxsO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG4gIGRpc2pvaW50VGltZXJRdWVyeVdlYmdsMkV4dGVuc2lvbjoge1RJTUVfRUxBUFNFRF9FWFQ6IEdMZW51bTsgR1BVX0RJU0pPSU5UX0VYVDogR0xlbnVtfXxudWxsO1xuXG4gIHByaXZhdGUgZGlzcG9zZWQ6IGJvb2xlYW47XG4gIHByaXZhdGUgZnJhbWVCdWZmZXJCb3VuZCA9IGZhbHNlO1xuXG4gIGNvbnN0cnVjdG9yKGdsOiBXZWJHTFJlbmRlcmluZ0NvbnRleHQsIHZlcnNpb246IDF8Mikge1xuICAgIHRoaXMuZ2wgPSBnbDtcbiAgICB0aGlzLnZlcnNpb24gPSB2ZXJzaW9uO1xuXG4gICAgdGhpcy5nZXRFeHRlbnNpb25zKCk7XG4gICAgdGhpcy52ZXJ0ZXhidWZmZXIgPSB0aGlzLmNyZWF0ZVZlcnRleGJ1ZmZlcigpO1xuICAgIHRoaXMuZnJhbWVidWZmZXIgPSB0aGlzLmNyZWF0ZUZyYW1lYnVmZmVyKCk7XG4gICAgdGhpcy5xdWVyeVZpdGFsUGFyYW1ldGVycygpO1xuICB9XG5cbiAgYWxsb2NhdGVUZXh0dXJlKHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyLCBlbmNvZGVyOiBEYXRhRW5jb2RlciwgZGF0YT86IEVuY29kZXIuRGF0YUFycmF5VHlwZSk6IFdlYkdMVGV4dHVyZSB7XG4gICAgY29uc3QgZ2wgPSB0aGlzLmdsO1xuICAgIC8vIGNyZWF0ZSB0aGUgdGV4dHVyZVxuICAgIGNvbnN0IHRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XG4gICAgLy8gYmluZCB0aGUgdGV4dHVyZSBzbyB0aGUgZm9sbG93aW5nIG1ldGhvZHMgZWZmZWN0IHRoaXMgdGV4dHVyZS5cbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTkVBUkVTVCk7XG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLk5FQVJFU1QpO1xuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLkNMQU1QX1RPX0VER0UpO1xuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UpO1xuICAgIGNvbnN0IGJ1ZmZlciA9IGRhdGEgPyBlbmNvZGVyLmVuY29kZShkYXRhLCB3aWR0aCAqIGhlaWdodCkgOiBudWxsO1xuICAgIGdsLnRleEltYWdlMkQoXG4gICAgICAgIGdsLlRFWFRVUkVfMkQsXG4gICAgICAgIDAsICAvLyBMZXZlbCBvZiBkZXRhaWwuXG4gICAgICAgIGVuY29kZXIuaW50ZXJuYWxGb3JtYXQsIHdpZHRoLCBoZWlnaHQsXG4gICAgICAgIDAsICAvLyBBbHdheXMgMCBpbiBPcGVuR0wgRVMuXG4gICAgICAgIGVuY29kZXIuZm9ybWF0LCBlbmNvZGVyLnRleHR1cmVUeXBlLCBidWZmZXIpO1xuICAgIHRoaXMuY2hlY2tFcnJvcigpO1xuICAgIHJldHVybiB0ZXh0dXJlIGFzIFdlYkdMVGV4dHVyZTtcbiAgfVxuICB1cGRhdGVUZXh0dXJlKFxuICAgICAgdGV4dHVyZTogV2ViR0xUZXh0dXJlLCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlciwgZW5jb2RlcjogRGF0YUVuY29kZXIsIGRhdGE6IEVuY29kZXIuRGF0YUFycmF5VHlwZSk6IHZvaWQge1xuICAgIGNvbnN0IGdsID0gdGhpcy5nbDtcbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlKTtcbiAgICBjb25zdCBidWZmZXIgPSBlbmNvZGVyLmVuY29kZShkYXRhLCB3aWR0aCAqIGhlaWdodCk7XG4gICAgZ2wudGV4U3ViSW1hZ2UyRChcbiAgICAgICAgZ2wuVEVYVFVSRV8yRCxcbiAgICAgICAgMCwgIC8vIGxldmVsXG4gICAgICAgIDAsICAvLyB4b2Zmc2V0XG4gICAgICAgIDAsICAvLyB5b2Zmc2V0XG4gICAgICAgIHdpZHRoLCBoZWlnaHQsIGVuY29kZXIuZm9ybWF0LCBlbmNvZGVyLnRleHR1cmVUeXBlLCBidWZmZXIpO1xuICAgIHRoaXMuY2hlY2tFcnJvcigpO1xuICB9XG4gIGF0dGFjaEZyYW1lYnVmZmVyKHRleHR1cmU6IFdlYkdMVGV4dHVyZSwgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIpOiB2b2lkIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuZ2w7XG4gICAgLy8gTWFrZSBpdCB0aGUgdGFyZ2V0IGZvciBmcmFtZWJ1ZmZlciBvcGVyYXRpb25zIC0gaW5jbHVkaW5nIHJlbmRlcmluZy5cbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlKTtcbiAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIHRoaXMuZnJhbWVidWZmZXIpO1xuICAgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKFxuICAgICAgICBnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAsIGdsLlRFWFRVUkVfMkQsIHRleHR1cmUsXG4gICAgICAgIDApOyAgLy8gMCwgd2UgYXJlbid0IHVzaW5nIE1JUE1BUHNcbiAgICB0aGlzLmNoZWNrRXJyb3IoKTtcbiAgICBnbC52aWV3cG9ydCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICBnbC5zY2lzc29yKDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICB9XG4gIHJlYWRUZXh0dXJlKFxuICAgICAgdGV4dHVyZTogV2ViR0xUZXh0dXJlLCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlciwgZGF0YVNpemU6IG51bWJlciwgZGF0YVR5cGU6IEVuY29kZXIuRGF0YVR5cGUsXG4gICAgICBjaGFubmVsczogbnVtYmVyKTogRW5jb2Rlci5EYXRhQXJyYXlUeXBlIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuZ2w7XG4gICAgaWYgKCFjaGFubmVscykge1xuICAgICAgY2hhbm5lbHMgPSAxO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuZnJhbWVCdWZmZXJCb3VuZCkge1xuICAgICAgdGhpcy5hdHRhY2hGcmFtZWJ1ZmZlcih0ZXh0dXJlLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB9XG4gICAgY29uc3QgZW5jb2RlciA9IHRoaXMuZ2V0RW5jb2RlcihkYXRhVHlwZSwgY2hhbm5lbHMpO1xuICAgIGNvbnN0IGJ1ZmZlciA9IGVuY29kZXIuYWxsb2NhdGUod2lkdGggKiBoZWlnaHQpO1xuICAgIC8vIGJpbmQgdGV4dHVyZSB0byBmcmFtZWJ1ZmZlclxuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUpO1xuICAgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKFxuICAgICAgICBnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAsIGdsLlRFWFRVUkVfMkQsIHRleHR1cmUsXG4gICAgICAgIDApOyAgLy8gMCwgd2UgYXJlbid0IHVzaW5nIE1JUE1BUHNcbiAgICAvLyBUT0RPOiBDaGVjayBpZiBmcmFtZWJ1ZmZlciBpcyByZWFkeVxuICAgIGdsLnJlYWRQaXhlbHMoMCwgMCwgd2lkdGgsIGhlaWdodCwgZ2wuUkdCQSwgZW5jb2Rlci50ZXh0dXJlVHlwZSwgYnVmZmVyKTtcbiAgICB0aGlzLmNoZWNrRXJyb3IoKTtcbiAgICAvLyB1bmJpbmQgRkJcbiAgICByZXR1cm4gZW5jb2Rlci5kZWNvZGUoYnVmZmVyLCBkYXRhU2l6ZSk7XG4gIH1cblxuICBpc0ZyYW1lYnVmZmVyUmVhZHkoKTogYm9vbGVhbiB7XG4gICAgLy8gVE9ETzogSW1wbGVtZW50IGxvZ2ljIHRvIGNoZWNrIGlmIHRoZSBmcmFtZWJ1ZmZlciBpcyByZWFkeVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGdldEFjdGl2ZVRleHR1cmUoKTogc3RyaW5nIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuZ2w7XG4gICAgY29uc3QgbiA9IGdsLmdldFBhcmFtZXRlcih0aGlzLmdsLkFDVElWRV9URVhUVVJFKTtcbiAgICByZXR1cm4gYFRFWFRVUkUkeyhuIC0gZ2wuVEVYVFVSRTApfWA7XG4gIH1cbiAgZ2V0VGV4dHVyZUJpbmRpbmcoKTogV2ViR0xUZXh0dXJlIHtcbiAgICByZXR1cm4gdGhpcy5nbC5nZXRQYXJhbWV0ZXIodGhpcy5nbC5URVhUVVJFX0JJTkRJTkdfMkQpO1xuICB9XG4gIGdldEZyYW1lYnVmZmVyQmluZGluZygpOiBXZWJHTEZyYW1lYnVmZmVyIHtcbiAgICByZXR1cm4gdGhpcy5nbC5nZXRQYXJhbWV0ZXIodGhpcy5nbC5GUkFNRUJVRkZFUl9CSU5ESU5HKTtcbiAgfVxuICBzZXRWZXJ0ZXhBdHRyaWJ1dGVzKHBvc2l0aW9uSGFuZGxlOiBudW1iZXIsIHRleHR1cmVDb29yZEhhbmRsZTogbnVtYmVyKTogdm9pZCB7XG4gICAgY29uc3QgZ2wgPSB0aGlzLmdsO1xuICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIocG9zaXRpb25IYW5kbGUsIDMsIGdsLkZMT0FULCBmYWxzZSwgMjAsIDApO1xuICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHBvc2l0aW9uSGFuZGxlKTtcbiAgICBpZiAodGV4dHVyZUNvb3JkSGFuZGxlICE9PSAtMSkge1xuICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcih0ZXh0dXJlQ29vcmRIYW5kbGUsIDIsIGdsLkZMT0FULCBmYWxzZSwgMjAsIDEyKTtcbiAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHRleHR1cmVDb29yZEhhbmRsZSk7XG4gICAgfVxuICAgIHRoaXMuY2hlY2tFcnJvcigpO1xuICB9XG4gIGNyZWF0ZVByb2dyYW0oXG4gICAgICB2ZXJ0ZXhTaGFkZXI6IFdlYkdMU2hhZGVyLFxuICAgICAgZnJhZ1NoYWRlcjogV2ViR0xTaGFkZXIsXG4gICAgICApOiBXZWJHTFByb2dyYW0ge1xuICAgIGNvbnN0IGdsID0gdGhpcy5nbDtcbiAgICBjb25zdCBwcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpITtcblxuICAgIC8vIHRoZSBwcm9ncmFtIGNvbnNpc3RzIG9mIG91ciBzaGFkZXJzXG4gICAgZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIHZlcnRleFNoYWRlcik7XG4gICAgZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIGZyYWdTaGFkZXIpO1xuICAgIGdsLmxpbmtQcm9ncmFtKHByb2dyYW0pO1xuICAgIHJldHVybiBwcm9ncmFtO1xuICB9XG4gIGNvbXBpbGVTaGFkZXIoc2hhZGVyU291cmNlOiBzdHJpbmcsIHNoYWRlclR5cGU6IG51bWJlcik6IFdlYkdMU2hhZGVyIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuZ2w7XG4gICAgY29uc3Qgc2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKHNoYWRlclR5cGUpO1xuICAgIGlmICghc2hhZGVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGNyZWF0ZVNoYWRlcigpIHJldHVybmVkIG51bGwgd2l0aCB0eXBlICR7c2hhZGVyVHlwZX1gKTtcbiAgICB9XG5cbiAgICBnbC5zaGFkZXJTb3VyY2Uoc2hhZGVyLCBzaGFkZXJTb3VyY2UpO1xuICAgIGdsLmNvbXBpbGVTaGFkZXIoc2hhZGVyKTtcbiAgICBpZiAoZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKHNoYWRlciwgZ2wuQ09NUElMRV9TVEFUVVMpID09PSBmYWxzZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gY29tcGlsZSBzaGFkZXI6ICR7Z2wuZ2V0U2hhZGVySW5mb0xvZyhzaGFkZXIpfVxuU2hhZGVyIHNvdXJjZTpcbiR7c2hhZGVyU291cmNlfWApO1xuICAgIH1cbiAgICByZXR1cm4gc2hhZGVyO1xuICB9XG4gIGRlbGV0ZVNoYWRlcihzaGFkZXI6IFdlYkdMU2hhZGVyKTogdm9pZCB7XG4gICAgdGhpcy5nbC5kZWxldGVTaGFkZXIoc2hhZGVyKTtcbiAgfVxuICBiaW5kVGV4dHVyZVRvVW5pZm9ybSh0ZXh0dXJlOiBXZWJHTFRleHR1cmUsIHBvc2l0aW9uOiBudW1iZXIsIHVuaWZvcm1IYW5kbGU6IFdlYkdMVW5pZm9ybUxvY2F0aW9uKTogdm9pZCB7XG4gICAgY29uc3QgZ2wgPSB0aGlzLmdsO1xuICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTAgKyBwb3NpdGlvbik7XG4gICAgdGhpcy5jaGVja0Vycm9yKCk7XG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSk7XG4gICAgdGhpcy5jaGVja0Vycm9yKCk7XG4gICAgZ2wudW5pZm9ybTFpKHVuaWZvcm1IYW5kbGUsIHBvc2l0aW9uKTtcbiAgICB0aGlzLmNoZWNrRXJyb3IoKTtcbiAgfVxuICBkcmF3KCk6IHZvaWQge1xuICAgIHRoaXMuZ2wuZHJhd0FycmF5cyh0aGlzLmdsLlRSSUFOR0xFX1NUUklQLCAwLCA0KTtcbiAgICB0aGlzLmNoZWNrRXJyb3IoKTtcbiAgfVxuICBjaGVja0Vycm9yKCk6IHZvaWQge1xuICAgIGlmIChlbnYuZGVidWcpIHtcbiAgICAgIGNvbnN0IGdsID0gdGhpcy5nbDtcbiAgICAgIGNvbnN0IGVycm9yID0gZ2wuZ2V0RXJyb3IoKTtcbiAgICAgIGxldCBsYWJlbCA9ICcnO1xuICAgICAgc3dpdGNoIChlcnJvcikge1xuICAgICAgICBjYXNlIChnbC5OT19FUlJPUik6XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjYXNlIChnbC5JTlZBTElEX0VOVU0pOlxuICAgICAgICAgIGxhYmVsID0gJ0lOVkFMSURfRU5VTSc7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgKGdsLklOVkFMSURfVkFMVUUpOlxuICAgICAgICAgIGxhYmVsID0gJ0lOVkFMSURfVkFMVUUnO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIChnbC5JTlZBTElEX09QRVJBVElPTik6XG4gICAgICAgICAgbGFiZWwgPSAnSU5WQUxJRF9PUEVSQVRJT04nO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIChnbC5JTlZBTElEX0ZSQU1FQlVGRkVSX09QRVJBVElPTik6XG4gICAgICAgICAgbGFiZWwgPSAnSU5WQUxJRF9GUkFNRUJVRkZFUl9PUEVSQVRJT04nO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIChnbC5PVVRfT0ZfTUVNT1JZKTpcbiAgICAgICAgICBsYWJlbCA9ICdPVVRfT0ZfTUVNT1JZJztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAoZ2wuQ09OVEVYVF9MT1NUX1dFQkdMKTpcbiAgICAgICAgICBsYWJlbCA9ICdDT05URVhUX0xPU1RfV0VCR0wnO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGxhYmVsID0gYFVua25vd24gV2ViR0wgRXJyb3I6ICR7ZXJyb3IudG9TdHJpbmcoMTYpfWA7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IobGFiZWwpO1xuICAgIH1cbiAgfVxuICBkZWxldGVUZXh0dXJlKHRleHR1cmU6IFdlYkdMVGV4dHVyZSk6IHZvaWQge1xuICAgIHRoaXMuZ2wuZGVsZXRlVGV4dHVyZSh0ZXh0dXJlKTtcbiAgfVxuICBkZWxldGVQcm9ncmFtKHByb2dyYW06IFdlYkdMUHJvZ3JhbSk6IHZvaWQge1xuICAgIHRoaXMuZ2wuZGVsZXRlUHJvZ3JhbShwcm9ncmFtKTtcbiAgfVxuICBnZXRFbmNvZGVyKGRhdGFUeXBlOiBFbmNvZGVyLkRhdGFUeXBlLCBjaGFubmVsczogbnVtYmVyLCB1c2FnZTogRW5jb2RlclVzYWdlID0gRW5jb2RlclVzYWdlLkRlZmF1bHQpOiBEYXRhRW5jb2RlciB7XG4gICAgaWYgKHRoaXMudmVyc2lvbiA9PT0gMikge1xuICAgICAgcmV0dXJuIG5ldyBEYXRhRW5jb2RlcnMuUmVkRmxvYXQzMkRhdGFFbmNvZGVyKHRoaXMuZ2wgYXMgV2ViR0wyUmVuZGVyaW5nQ29udGV4dCwgY2hhbm5lbHMpO1xuICAgIH1cblxuICAgIHN3aXRjaCAoZGF0YVR5cGUpIHtcbiAgICAgIGNhc2UgJ2Zsb2F0JzpcbiAgICAgICAgaWYgKHVzYWdlID09PSBFbmNvZGVyVXNhZ2UuVXBsb2FkT25seSB8fCB0aGlzLmlzUmVuZGVyRmxvYXQzMlN1cHBvcnRlZCkge1xuICAgICAgICAgIHJldHVybiBuZXcgRGF0YUVuY29kZXJzLlJHQkFGbG9hdERhdGFFbmNvZGVyKHRoaXMuZ2wsIGNoYW5uZWxzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbmV3IERhdGFFbmNvZGVycy5SR0JBRmxvYXREYXRhRW5jb2RlcihcbiAgICAgICAgICAgICAgdGhpcy5nbCwgY2hhbm5lbHMsIHRoaXMudGV4dHVyZUhhbGZGbG9hdEV4dGVuc2lvbiEuSEFMRl9GTE9BVF9PRVMpO1xuICAgICAgICB9XG4gICAgICBjYXNlICdpbnQnOlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCcpO1xuICAgICAgY2FzZSAnYnl0ZSc6XG4gICAgICAgIHJldHVybiBuZXcgRGF0YUVuY29kZXJzLlVpbnQ4RGF0YUVuY29kZXIodGhpcy5nbCwgY2hhbm5lbHMpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGRhdGFUeXBlOiAke2RhdGFUeXBlfWApO1xuICAgIH1cbiAgfVxuICBjbGVhckFjdGl2ZVRleHR1cmVzKCk6IHZvaWQge1xuICAgIGNvbnN0IGdsID0gdGhpcy5nbDtcbiAgICBmb3IgKGxldCB1bml0ID0gMDsgdW5pdCA8IHRoaXMubWF4VGV4dHVyZUltYWdlVW5pdHM7ICsrdW5pdCkge1xuICAgICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCArIHVuaXQpO1xuICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgbnVsbCk7XG4gICAgfVxuICB9XG4gIGRpc3Bvc2UoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuZGlzcG9zZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZ2wgPSB0aGlzLmdsO1xuICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgbnVsbCk7XG4gICAgZ2wuZGVsZXRlRnJhbWVidWZmZXIodGhpcy5mcmFtZWJ1ZmZlcik7XG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIG51bGwpO1xuICAgIGdsLmRlbGV0ZUJ1ZmZlcih0aGlzLnZlcnRleGJ1ZmZlcik7XG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgbnVsbCk7XG4gICAgZ2wuZmluaXNoKCk7XG4gICAgdGhpcy5kaXNwb3NlZCA9IHRydWU7XG4gIH1cblxuICBwcml2YXRlIGNyZWF0ZURlZmF1bHRHZW9tZXRyeSgpOiBGbG9hdDMyQXJyYXkge1xuICAgIC8vIFNldHMgb2YgeCx5LHooPTApLHMsdCBjb29yZGluYXRlcy5cbiAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheShbXG4gICAgICAtMS4wLCAxLjAsICAwLjAsIDAuMCwgMS4wLCAgLy8gdXBwZXIgbGVmdFxuICAgICAgLTEuMCwgLTEuMCwgMC4wLCAwLjAsIDAuMCwgIC8vIGxvd2VyIGxlZnRcbiAgICAgIDEuMCwgIDEuMCwgIDAuMCwgMS4wLCAxLjAsICAvLyB1cHBlciByaWdodFxuICAgICAgMS4wLCAgLTEuMCwgMC4wLCAxLjAsIDAuMCAgIC8vIGxvd2VyIHJpZ2h0XG4gICAgXSk7XG4gIH1cbiAgcHJpdmF0ZSBjcmVhdGVWZXJ0ZXhidWZmZXIoKTogV2ViR0xCdWZmZXIge1xuICAgIGNvbnN0IGdsID0gdGhpcy5nbDtcbiAgICBjb25zdCBidWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcbiAgICBpZiAoIWJ1ZmZlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjcmVhdGVCdWZmZXIoKSByZXR1cm5lZCBudWxsJyk7XG4gICAgfVxuICAgIGNvbnN0IGdlb21ldHJ5ID0gdGhpcy5jcmVhdGVEZWZhdWx0R2VvbWV0cnkoKTtcbiAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYnVmZmVyKTtcbiAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgZ2VvbWV0cnksIGdsLlNUQVRJQ19EUkFXKTtcbiAgICB0aGlzLmNoZWNrRXJyb3IoKTtcbiAgICByZXR1cm4gYnVmZmVyO1xuICB9XG4gIHByaXZhdGUgY3JlYXRlRnJhbWVidWZmZXIoKTogV2ViR0xGcmFtZWJ1ZmZlciB7XG4gICAgY29uc3QgZmIgPSB0aGlzLmdsLmNyZWF0ZUZyYW1lYnVmZmVyKCk7XG4gICAgaWYgKCFmYikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjcmVhdGVGcmFtZWJ1ZmZlciByZXR1cm5lZCBudWxsJyk7XG4gICAgfVxuICAgIHJldHVybiBmYjtcbiAgfVxuXG4gIHByaXZhdGUgcXVlcnlWaXRhbFBhcmFtZXRlcnMoKTogdm9pZCB7XG4gICAgY29uc3QgZ2wgPSB0aGlzLmdsO1xuXG4gICAgdGhpcy5pc0Zsb2F0VGV4dHVyZUF0dGFjaGFibGVUb0ZyYW1lQnVmZmVyID0gdGhpcy5jaGVja0Zsb2F0VGV4dHVyZUF0dGFjaGFibGVUb0ZyYW1lQnVmZmVyKCk7XG4gICAgdGhpcy5pc1JlbmRlckZsb2F0MzJTdXBwb3J0ZWQgPSB0aGlzLmNoZWNrUmVuZGVyRmxvYXQzMigpO1xuICAgIHRoaXMuaXNGbG9hdDMyRG93bmxvYWRTdXBwb3J0ZWQgPSB0aGlzLmNoZWNrRmxvYXQzMkRvd25sb2FkKCk7XG5cbiAgICBpZiAodGhpcy52ZXJzaW9uID09PSAxICYmICF0aGlzLnRleHR1cmVIYWxmRmxvYXRFeHRlbnNpb24gJiYgIXRoaXMuaXNSZW5kZXJGbG9hdDMyU3VwcG9ydGVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JvdGggZmxvYXQzMiBhbmQgZmxvYXQxNiBUZXh0dXJlVHlwZSBhcmUgbm90IHN1cHBvcnRlZCcpO1xuICAgIH1cblxuICAgIHRoaXMuaXNCbGVuZFN1cHBvcnRlZCA9ICF0aGlzLmlzUmVuZGVyRmxvYXQzMlN1cHBvcnRlZCB8fCB0aGlzLmNoZWNrRmxvYXQzMkJsZW5kKCk7XG5cbiAgICAvLyB0aGlzLm1heENvbWJpbmVkVGV4dHVyZUltYWdlVW5pdHMgPSBnbC5nZXRQYXJhbWV0ZXIoZ2wuTUFYX0NPTUJJTkVEX1RFWFRVUkVfSU1BR0VfVU5JVFMpO1xuICAgIHRoaXMubWF4VGV4dHVyZVNpemUgPSBnbC5nZXRQYXJhbWV0ZXIoZ2wuTUFYX1RFWFRVUkVfU0laRSk7XG4gICAgdGhpcy5tYXhUZXh0dXJlSW1hZ2VVbml0cyA9IGdsLmdldFBhcmFtZXRlcihnbC5NQVhfVEVYVFVSRV9JTUFHRV9VTklUUyk7XG4gICAgLy8gdGhpcy5tYXhDdWJlTWFwVGV4dHVyZVNpemUgPSBnbC5nZXRQYXJhbWV0ZXIoZ2wuTUFYX0NVQkVfTUFQX1RFWFRVUkVfU0laRSk7XG4gICAgLy8gdGhpcy5zaGFkaW5nTGFuZ3VhZ2VWZXJzaW9uID0gZ2wuZ2V0UGFyYW1ldGVyKGdsLlNIQURJTkdfTEFOR1VBR0VfVkVSU0lPTik7XG4gICAgLy8gdGhpcy53ZWJnbFZlbmRvciA9IGdsLmdldFBhcmFtZXRlcihnbC5WRU5ET1IpO1xuICAgIC8vIHRoaXMud2ViZ2xWZXJzaW9uID0gZ2wuZ2V0UGFyYW1ldGVyKGdsLlZFUlNJT04pO1xuXG4gICAgaWYgKHRoaXMudmVyc2lvbiA9PT0gMikge1xuICAgICAgLy8gdGhpcy5tYXgzRFRleHR1cmVTaXplID0gZ2wuZ2V0UGFyYW1ldGVyKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuTUFYXzNEX1RFWFRVUkVfU0laRSk7XG4gICAgICAvLyB0aGlzLm1heEFycmF5VGV4dHVyZUxheWVycyA9IGdsLmdldFBhcmFtZXRlcihXZWJHTDJSZW5kZXJpbmdDb250ZXh0Lk1BWF9BUlJBWV9URVhUVVJFX0xBWUVSUyk7XG4gICAgICAvLyB0aGlzLm1heENvbG9yQXR0YWNobWVudHMgPSBnbC5nZXRQYXJhbWV0ZXIoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5NQVhfQ09MT1JfQVRUQUNITUVOVFMpO1xuICAgICAgLy8gdGhpcy5tYXhEcmF3QnVmZmVycyA9IGdsLmdldFBhcmFtZXRlcihXZWJHTDJSZW5kZXJpbmdDb250ZXh0Lk1BWF9EUkFXX0JVRkZFUlMpO1xuICAgIH1cbiAgfVxuICBwcml2YXRlIGdldEV4dGVuc2lvbnMoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMudmVyc2lvbiA9PT0gMikge1xuICAgICAgdGhpcy5jb2xvckJ1ZmZlckZsb2F0RXh0ZW5zaW9uID0gdGhpcy5nbC5nZXRFeHRlbnNpb24oJ0VYVF9jb2xvcl9idWZmZXJfZmxvYXQnKTtcbiAgICAgIHRoaXMuZGlzam9pbnRUaW1lclF1ZXJ5V2ViZ2wyRXh0ZW5zaW9uID0gdGhpcy5nbC5nZXRFeHRlbnNpb24oJ0VYVF9kaXNqb2ludF90aW1lcl9xdWVyeV93ZWJnbDInKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy50ZXh0dXJlRmxvYXRFeHRlbnNpb24gPSB0aGlzLmdsLmdldEV4dGVuc2lvbignT0VTX3RleHR1cmVfZmxvYXQnKTtcbiAgICAgIHRoaXMudGV4dHVyZUhhbGZGbG9hdEV4dGVuc2lvbiA9IHRoaXMuZ2wuZ2V0RXh0ZW5zaW9uKCdPRVNfdGV4dHVyZV9oYWxmX2Zsb2F0Jyk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBjaGVja0Zsb2F0VGV4dHVyZUF0dGFjaGFibGVUb0ZyYW1lQnVmZmVyKCk6IGJvb2xlYW4ge1xuICAgIC8vIHRlc3Qgd2hldGhlciBGbG9hdDMyIHRleHR1cmUgaXMgc3VwcG9ydGVkOlxuICAgIC8vIFNURVAuMSBjcmVhdGUgYSBmbG9hdCB0ZXh0dXJlXG4gICAgY29uc3QgZ2wgPSB0aGlzLmdsO1xuICAgIGNvbnN0IHRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSk7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuICAgIGNvbnN0IGludGVybmFsRm9ybWF0ID0gdGhpcy52ZXJzaW9uID09PSAyID8gKGdsIGFzIHVua25vd24gYXMge1JHQkEzMkY6IG51bWJlcn0pLlJHQkEzMkYgOiBnbC5SR0JBO1xuICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgaW50ZXJuYWxGb3JtYXQsIDEsIDEsIDAsIGdsLlJHQkEsIGdsLkZMT0FULCBudWxsKTtcbiAgICAvLyBTVEVQLjIgYmluZCBhIGZyYW1lIGJ1ZmZlclxuICAgIGNvbnN0IGZyYW1lQnVmZmVyID0gZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcbiAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIGZyYW1lQnVmZmVyKTtcbiAgICAvLyBTVEVQLjMgYXR0YWNoIHRleHR1cmUgdG8gZnJhbWVidWZmZXJcbiAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAsIGdsLlRFWFRVUkVfMkQsIHRleHR1cmUsIDApO1xuICAgIC8vIFNURVAuNCB0ZXN0IHdoZXRoZXIgZnJhbWVidWZmZXIgaXMgY29tcGxldGVcbiAgICBjb25zdCBpc0NvbXBsZXRlID0gZ2wuY2hlY2tGcmFtZWJ1ZmZlclN0YXR1cyhnbC5GUkFNRUJVRkZFUikgPT09IGdsLkZSQU1FQlVGRkVSX0NPTVBMRVRFO1xuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIG51bGwpO1xuICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgbnVsbCk7XG4gICAgZ2wuZGVsZXRlVGV4dHVyZSh0ZXh0dXJlKTtcbiAgICBnbC5kZWxldGVGcmFtZWJ1ZmZlcihmcmFtZUJ1ZmZlcik7XG4gICAgcmV0dXJuIGlzQ29tcGxldGU7XG4gIH1cblxuICBwcml2YXRlIGNoZWNrUmVuZGVyRmxvYXQzMigpOiBib29sZWFuIHtcbiAgICBpZiAodGhpcy52ZXJzaW9uID09PSAyKSB7XG4gICAgICBpZiAoIXRoaXMuY29sb3JCdWZmZXJGbG9hdEV4dGVuc2lvbikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghdGhpcy50ZXh0dXJlRmxvYXRFeHRlbnNpb24pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5pc0Zsb2F0VGV4dHVyZUF0dGFjaGFibGVUb0ZyYW1lQnVmZmVyO1xuICB9XG5cbiAgcHJpdmF0ZSBjaGVja0Zsb2F0MzJEb3dubG9hZCgpOiBib29sZWFuIHtcbiAgICBpZiAodGhpcy52ZXJzaW9uID09PSAyKSB7XG4gICAgICBpZiAoIXRoaXMuY29sb3JCdWZmZXJGbG9hdEV4dGVuc2lvbikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghdGhpcy50ZXh0dXJlRmxvYXRFeHRlbnNpb24pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLmdsLmdldEV4dGVuc2lvbignV0VCR0xfY29sb3JfYnVmZmVyX2Zsb2F0JykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5pc0Zsb2F0VGV4dHVyZUF0dGFjaGFibGVUb0ZyYW1lQnVmZmVyO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIHdoZXRoZXIgR0xfQkxFTkQgaXMgc3VwcG9ydGVkXG4gICAqL1xuICBwcml2YXRlIGNoZWNrRmxvYXQzMkJsZW5kKCk6IGJvb2xlYW4ge1xuICAgIC8vIGl0IGxvb2tzIGxpa2UgY3VycmVudGx5ICgyMDE5LTA1LTA4KSB0aGVyZSBpcyBubyBlYXN5IHdheSB0byBkZXRlY3Qgd2hldGhlciBCTEVORCBpcyBzdXBwb3J0ZWRcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L29ubnhqcy9pc3N1ZXMvMTQ1XG5cbiAgICBjb25zdCBnbCA9IHRoaXMuZ2w7XG5cbiAgICBsZXQgdGV4dHVyZTogV2ViR0xUZXh0dXJlfG51bGx8dW5kZWZpbmVkO1xuICAgIGxldCBmcmFtZUJ1ZmZlcjogV2ViR0xGcmFtZWJ1ZmZlcnxudWxsfHVuZGVmaW5lZDtcbiAgICBsZXQgdmVydGV4U2hhZGVyOiBXZWJHTFNoYWRlcnxudWxsfHVuZGVmaW5lZDtcbiAgICBsZXQgZnJhZ21lbnRTaGFkZXI6IFdlYkdMU2hhZGVyfG51bGx8dW5kZWZpbmVkO1xuICAgIGxldCBwcm9ncmFtOiBXZWJHTFByb2dyYW18bnVsbHx1bmRlZmluZWQ7XG5cbiAgICB0cnkge1xuICAgICAgdGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcbiAgICAgIGZyYW1lQnVmZmVyID0gZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcbiAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUpO1xuXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG4gICAgICBjb25zdCBpbnRlcm5hbEZvcm1hdCA9IHRoaXMudmVyc2lvbiA9PT0gMiA/IChnbCBhcyB1bmtub3duIGFzIHtSR0JBMzJGOiBudW1iZXJ9KS5SR0JBMzJGIDogZ2wuUkdCQTtcbiAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgaW50ZXJuYWxGb3JtYXQsIDEsIDEsIDAsIGdsLlJHQkEsIGdsLkZMT0FULCBudWxsKTtcblxuICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBmcmFtZUJ1ZmZlcik7XG4gICAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAsIGdsLlRFWFRVUkVfMkQsIHRleHR1cmUsIDApO1xuXG4gICAgICBnbC5lbmFibGUoZ2wuQkxFTkQpO1xuXG4gICAgICB2ZXJ0ZXhTaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIoZ2wuVkVSVEVYX1NIQURFUik7XG4gICAgICBpZiAoIXZlcnRleFNoYWRlcikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBnbC5zaGFkZXJTb3VyY2UodmVydGV4U2hhZGVyLCAndm9pZCBtYWluKCl7fScpO1xuICAgICAgZ2wuY29tcGlsZVNoYWRlcih2ZXJ0ZXhTaGFkZXIpO1xuXG4gICAgICBmcmFnbWVudFNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlcihnbC5GUkFHTUVOVF9TSEFERVIpO1xuICAgICAgaWYgKCFmcmFnbWVudFNoYWRlcikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBnbC5zaGFkZXJTb3VyY2UoZnJhZ21lbnRTaGFkZXIsICdwcmVjaXNpb24gaGlnaHAgZmxvYXQ7dm9pZCBtYWluKCl7Z2xfRnJhZ0NvbG9yPXZlYzQoMC41KTt9Jyk7XG4gICAgICBnbC5jb21waWxlU2hhZGVyKGZyYWdtZW50U2hhZGVyKTtcblxuICAgICAgcHJvZ3JhbSA9IGdsLmNyZWF0ZVByb2dyYW0oKTtcbiAgICAgIGlmICghcHJvZ3JhbSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgdmVydGV4U2hhZGVyKTtcbiAgICAgIGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCBmcmFnbWVudFNoYWRlcik7XG4gICAgICBnbC5saW5rUHJvZ3JhbShwcm9ncmFtKTtcbiAgICAgIGdsLnVzZVByb2dyYW0ocHJvZ3JhbSk7XG5cbiAgICAgIGdsLmRyYXdBcnJheXMoZ2wuUE9JTlRTLCAwLCAxKTtcbiAgICAgIHJldHVybiBnbC5nZXRFcnJvcigpID09PSBnbC5OT19FUlJPUjtcblxuICAgIH0gZmluYWxseSB7XG4gICAgICBnbC5kaXNhYmxlKGdsLkJMRU5EKTtcblxuICAgICAgaWYgKHByb2dyYW0pIHtcbiAgICAgICAgZ2wuZGVsZXRlUHJvZ3JhbShwcm9ncmFtKTtcbiAgICAgIH1cbiAgICAgIGlmICh2ZXJ0ZXhTaGFkZXIpIHtcbiAgICAgICAgZ2wuZGVsZXRlU2hhZGVyKHZlcnRleFNoYWRlcik7XG4gICAgICB9XG4gICAgICBpZiAoZnJhZ21lbnRTaGFkZXIpIHtcbiAgICAgICAgZ2wuZGVsZXRlU2hhZGVyKGZyYWdtZW50U2hhZGVyKTtcbiAgICAgIH1cbiAgICAgIGlmIChmcmFtZUJ1ZmZlcikge1xuICAgICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIG51bGwpO1xuICAgICAgICBnbC5kZWxldGVGcmFtZWJ1ZmZlcihmcmFtZUJ1ZmZlcik7XG4gICAgICB9XG4gICAgICBpZiAodGV4dHVyZSkge1xuICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBudWxsKTtcbiAgICAgICAgZ2wuZGVsZXRlVGV4dHVyZSh0ZXh0dXJlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBiZWdpblRpbWVyKCk6IFdlYkdMUXVlcnkge1xuICAgIGlmICh0aGlzLnZlcnNpb24gPT09IDIgJiYgdGhpcy5kaXNqb2ludFRpbWVyUXVlcnlXZWJnbDJFeHRlbnNpb24pIHtcbiAgICAgIGNvbnN0IGdsMiA9IHRoaXMuZ2wgYXMgV2ViR0wyUmVuZGVyaW5nQ29udGV4dDtcbiAgICAgIGNvbnN0IGV4dCA9IHRoaXMuZGlzam9pbnRUaW1lclF1ZXJ5V2ViZ2wyRXh0ZW5zaW9uO1xuXG4gICAgICBjb25zdCBxdWVyeSA9IGdsMi5jcmVhdGVRdWVyeSgpIGFzIFdlYkdMUXVlcnk7XG4gICAgICBnbDIuYmVnaW5RdWVyeShleHQuVElNRV9FTEFQU0VEX0VYVCwgcXVlcnkpO1xuICAgICAgcmV0dXJuIHF1ZXJ5O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUT0RPOiBhZGQgd2ViZ2wgMSBoYW5kbGluZy5cbiAgICAgIHRocm93IG5ldyBFcnJvcignV2ViR0wxIHByb2ZpbGluZyBjdXJyZW50bHkgbm90IHN1cHBvcnRlZC4nKTtcbiAgICB9XG4gIH1cblxuICBlbmRUaW1lcigpIHtcbiAgICBpZiAodGhpcy52ZXJzaW9uID09PSAyICYmIHRoaXMuZGlzam9pbnRUaW1lclF1ZXJ5V2ViZ2wyRXh0ZW5zaW9uKSB7XG4gICAgICBjb25zdCBnbDIgPSB0aGlzLmdsIGFzIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQ7XG4gICAgICBjb25zdCBleHQgPSB0aGlzLmRpc2pvaW50VGltZXJRdWVyeVdlYmdsMkV4dGVuc2lvbjtcbiAgICAgIGdsMi5lbmRRdWVyeShleHQuVElNRV9FTEFQU0VEX0VYVCk7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRPRE86IGFkZCB3ZWJnbCAxIGhhbmRsaW5nLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdXZWJHTDEgcHJvZmlsaW5nIGN1cnJlbnRseSBub3Qgc3VwcG9ydGVkJyk7XG4gICAgfVxuICB9XG5cbiAgaXNUaW1lclJlc3VsdEF2YWlsYWJsZShxdWVyeTogV2ViR0xRdWVyeSk6IGJvb2xlYW4ge1xuICAgIGxldCBhdmFpbGFibGUgPSBmYWxzZSwgZGlzam9pbnQgPSBmYWxzZTtcbiAgICBpZiAodGhpcy52ZXJzaW9uID09PSAyICYmIHRoaXMuZGlzam9pbnRUaW1lclF1ZXJ5V2ViZ2wyRXh0ZW5zaW9uKSB7XG4gICAgICBjb25zdCBnbDIgPSB0aGlzLmdsIGFzIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQ7XG4gICAgICBjb25zdCBleHQgPSB0aGlzLmRpc2pvaW50VGltZXJRdWVyeVdlYmdsMkV4dGVuc2lvbjtcblxuICAgICAgYXZhaWxhYmxlID0gZ2wyLmdldFF1ZXJ5UGFyYW1ldGVyKHF1ZXJ5LCBnbDIuUVVFUllfUkVTVUxUX0FWQUlMQUJMRSk7XG4gICAgICBkaXNqb2ludCA9IGdsMi5nZXRQYXJhbWV0ZXIoZXh0LkdQVV9ESVNKT0lOVF9FWFQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUT0RPOiBhZGQgd2ViZ2wgMSBoYW5kbGluZy5cbiAgICAgIHRocm93IG5ldyBFcnJvcignV2ViR0wxIHByb2ZpbGluZyBjdXJyZW50bHkgbm90IHN1cHBvcnRlZCcpO1xuICAgIH1cblxuICAgIHJldHVybiBhdmFpbGFibGUgJiYgIWRpc2pvaW50O1xuICB9XG5cbiAgZ2V0VGltZXJSZXN1bHQocXVlcnk6IFdlYkdMUXVlcnkpOiBudW1iZXIge1xuICAgIGxldCB0aW1lRWxhcHNlZCA9IDA7XG4gICAgaWYgKHRoaXMudmVyc2lvbiA9PT0gMikge1xuICAgICAgY29uc3QgZ2wyID0gdGhpcy5nbCBhcyBXZWJHTDJSZW5kZXJpbmdDb250ZXh0O1xuICAgICAgdGltZUVsYXBzZWQgPSBnbDIuZ2V0UXVlcnlQYXJhbWV0ZXIocXVlcnksIGdsMi5RVUVSWV9SRVNVTFQpO1xuICAgICAgZ2wyLmRlbGV0ZVF1ZXJ5KHF1ZXJ5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVE9ETzogYWRkIHdlYmdsIDEgaGFuZGxpbmcuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlYkdMMSBwcm9maWxpbmcgY3VycmVudGx5IG5vdCBzdXBwb3J0ZWQnKTtcbiAgICB9XG4gICAgLy8gcmV0dXJuIG1pbGlzZWNvbmRzXG4gICAgcmV0dXJuIHRpbWVFbGFwc2VkIC8gMTAwMDAwMDtcbiAgfVxuXG4gIGFzeW5jIHdhaXRGb3JRdWVyeUFuZEdldFRpbWUocXVlcnk6IFdlYkdMUXVlcnkpOiBQcm9taXNlPG51bWJlcj4ge1xuICAgIGF3YWl0IHJlcGVhdGVkVHJ5KCgpID0+IHRoaXMuaXNUaW1lclJlc3VsdEF2YWlsYWJsZShxdWVyeSkpO1xuICAgIHJldHVybiB0aGlzLmdldFRpbWVyUmVzdWx0KHF1ZXJ5KTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBjcmVhdGVBbmRXYWl0Rm9yRmVuY2UoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgZmVuY2VDb250ZXh0ID0gdGhpcy5jcmVhdGVGZW5jZSh0aGlzLmdsKTtcbiAgICByZXR1cm4gdGhpcy5wb2xsRmVuY2UoZmVuY2VDb250ZXh0KTtcbiAgfVxuXG4gIHByaXZhdGUgY3JlYXRlRmVuY2UoZ2w6IFdlYkdMUmVuZGVyaW5nQ29udGV4dCk6IEZlbmNlQ29udGV4dCB7XG4gICAgbGV0IGlzRmVuY2VQYXNzZWQ6ICgpID0+IGJvb2xlYW47XG4gICAgY29uc3QgZ2wyID0gZ2wgYXMgV2ViR0wyUmVuZGVyaW5nQ29udGV4dDtcbiAgICBjb25zdCBxdWVyeSA9IGdsMi5mZW5jZVN5bmMoZ2wyLlNZTkNfR1BVX0NPTU1BTkRTX0NPTVBMRVRFLCAwKTtcbiAgICBnbC5mbHVzaCgpO1xuICAgIGlmIChxdWVyeSA9PT0gbnVsbCkge1xuICAgICAgaXNGZW5jZVBhc3NlZCA9ICgpID0+IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlzRmVuY2VQYXNzZWQgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHN0YXR1cyA9IGdsMi5jbGllbnRXYWl0U3luYyhxdWVyeSwgMCwgMCk7XG4gICAgICAgIHJldHVybiBzdGF0dXMgPT09IGdsMi5BTFJFQURZX1NJR05BTEVEIHx8IHN0YXR1cyA9PT0gZ2wyLkNPTkRJVElPTl9TQVRJU0ZJRUQ7XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4ge3F1ZXJ5LCBpc0ZlbmNlUGFzc2VkfTtcbiAgfVxuXG4gIGFzeW5jIHBvbGxGZW5jZShmZW5jZUNvbnRleHQ6IEZlbmNlQ29udGV4dCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZTx2b2lkPihyZXNvbHZlID0+IHtcbiAgICAgIHZvaWQgdGhpcy5hZGRJdGVtVG9Qb2xsKCgpID0+IGZlbmNlQ29udGV4dC5pc0ZlbmNlUGFzc2VkKCksICgpID0+IHJlc29sdmUoKSk7XG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIGl0ZW1zVG9Qb2xsOiBQb2xsSXRlbVtdID0gW107XG5cbiAgcG9sbEl0ZW1zKCk6IHZvaWQge1xuICAgIC8vIEZpbmQgdGhlIGxhc3QgcXVlcnkgdGhhdCBoYXMgZmluaXNoZWQuXG4gICAgY29uc3QgaW5kZXggPSBsaW5lYXJTZWFyY2hMYXN0VHJ1ZSh0aGlzLml0ZW1zVG9Qb2xsLm1hcCh4ID0+IHguaXNEb25lRm4pKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBpbmRleDsgKytpKSB7XG4gICAgICBjb25zdCB7cmVzb2x2ZUZufSA9IHRoaXMuaXRlbXNUb1BvbGxbaV07XG4gICAgICByZXNvbHZlRm4oKTtcbiAgICB9XG4gICAgdGhpcy5pdGVtc1RvUG9sbCA9IHRoaXMuaXRlbXNUb1BvbGwuc2xpY2UoaW5kZXggKyAxKTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgYWRkSXRlbVRvUG9sbChpc0RvbmVGbjogKCkgPT4gYm9vbGVhbiwgcmVzb2x2ZUZuOiAoKSA9PiB2b2lkKSB7XG4gICAgdGhpcy5pdGVtc1RvUG9sbC5wdXNoKHtpc0RvbmVGbiwgcmVzb2x2ZUZufSk7XG4gICAgaWYgKHRoaXMuaXRlbXNUb1BvbGwubGVuZ3RoID4gMSkge1xuICAgICAgLy8gV2UgYWxyZWFkeSBoYXZlIGEgcnVubmluZyBsb29wIHRoYXQgcG9sbHMuXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIFN0YXJ0IGEgbmV3IGxvb3AgdGhhdCBwb2xscy5cbiAgICBhd2FpdCByZXBlYXRlZFRyeSgoKSA9PiB7XG4gICAgICB0aGlzLnBvbGxJdGVtcygpO1xuICAgICAgLy8gRW5kIHRoZSBsb29wIGlmIG5vIG1vcmUgaXRlbXMgdG8gcG9sbC5cbiAgICAgIHJldHVybiB0aGlzLml0ZW1zVG9Qb2xsLmxlbmd0aCA9PT0gMDtcbiAgICB9KTtcbiAgfVxufVxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0xvZ2dlcn0gZnJvbSAnLi4vLi4vaW5zdHJ1bWVudCc7XG5cbmltcG9ydCB7V2ViR0xDb250ZXh0fSBmcm9tICcuL3dlYmdsLWNvbnRleHQnO1xuXG5jb25zdCBjYWNoZToge1tjb250ZXh0SWQ6IHN0cmluZ106IFdlYkdMQ29udGV4dH0gPSB7fTtcblxuLyoqXG4gKiBUaGlzIGZhY3RvcnkgZnVuY3Rpb24gY3JlYXRlcyBwcm9wZXIgV2ViR0xSZW5kZXJpbmdDb250ZXh0IGJhc2VkIG9uXG4gKiB0aGUgY3VycmVudCBicm93c2VycyBjYXBhYmlsaXRpZXNcbiAqIFRoZSBvcmRlciBpcyBmcm9tIGhpZ2hlci9tb3N0IHJlY2VudCB2ZXJzaW9ucyB0byBtb3N0IGJhc2ljXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVXZWJHTENvbnRleHQoY29udGV4dElkPzogJ3dlYmdsJ3wnd2ViZ2wyJyk6IFdlYkdMQ29udGV4dCB7XG4gIGxldCBjb250ZXh0OiBXZWJHTENvbnRleHR8dW5kZWZpbmVkO1xuICBpZiAoKCFjb250ZXh0SWQgfHwgY29udGV4dElkID09PSAnd2ViZ2wyJykgJiYgJ3dlYmdsMicgaW4gY2FjaGUpIHtcbiAgICBjb250ZXh0ID0gY2FjaGUud2ViZ2wyO1xuICB9IGVsc2UgaWYgKCghY29udGV4dElkIHx8IGNvbnRleHRJZCA9PT0gJ3dlYmdsJykgJiYgJ3dlYmdsJyBpbiBjYWNoZSkge1xuICAgIGNvbnRleHQgPSBjYWNoZS53ZWJnbDtcbiAgfVxuXG4gIGlmICghY29udGV4dCkge1xuICAgIHRyeSB7XG4gICAgICAvLyB0cnkgdG8gY3JlYXRlIHdlYmdsIGNvbnRleHQgZnJvbSBhbiBvZmZzY3JlZW4gY2FudmFzXG4gICAgICBjb25zdCBvZmZzY3JlZW5DYW52YXMgPSBjcmVhdGVPZmZzY3JlZW5DYW52YXMoKTtcbiAgICAgIGNvbnRleHQgPSBjcmVhdGVOZXdXZWJHTENvbnRleHQob2Zmc2NyZWVuQ2FudmFzLCBjb250ZXh0SWQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIGlmIGZhaWxlZCwgZmFsbGJhY2sgdG8gdHJ5IHRvIHVzZSBhIG5vcm1hbCBjYW52YXMgZWxlbWVudFxuICAgICAgY29uc3QgY2FudmFzID0gY3JlYXRlQ2FudmFzKCk7XG4gICAgICBjb250ZXh0ID0gY3JlYXRlTmV3V2ViR0xDb250ZXh0KGNhbnZhcywgY29udGV4dElkKTtcbiAgICB9XG4gIH1cblxuICBjb250ZXh0SWQgPSBjb250ZXh0SWQgfHwgY29udGV4dC52ZXJzaW9uID09PSAxID8gJ3dlYmdsJyA6ICd3ZWJnbDInO1xuICBjb25zdCBnbCA9IGNvbnRleHQuZ2w7XG5cbiAgY2FjaGVbY29udGV4dElkXSA9IGNvbnRleHQ7XG5cbiAgaWYgKGdsLmlzQ29udGV4dExvc3QoKSkge1xuICAgIGRlbGV0ZSBjYWNoZVtjb250ZXh0SWRdO1xuICAgIHJldHVybiBjcmVhdGVXZWJHTENvbnRleHQoY29udGV4dElkKTtcbiAgfVxuXG4gIGdsLmRpc2FibGUoZ2wuREVQVEhfVEVTVCk7XG4gIGdsLmRpc2FibGUoZ2wuU1RFTkNJTF9URVNUKTtcbiAgZ2wuZGlzYWJsZShnbC5CTEVORCk7XG4gIGdsLmRpc2FibGUoZ2wuRElUSEVSKTtcbiAgZ2wuZGlzYWJsZShnbC5QT0xZR09OX09GRlNFVF9GSUxMKTtcbiAgZ2wuZGlzYWJsZShnbC5TQU1QTEVfQ09WRVJBR0UpO1xuICBnbC5lbmFibGUoZ2wuU0NJU1NPUl9URVNUKTtcbiAgZ2wuZW5hYmxlKGdsLkNVTExfRkFDRSk7XG4gIGdsLmN1bGxGYWNlKGdsLkJBQ0spO1xuXG4gIHJldHVybiBjb250ZXh0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTmV3V2ViR0xDb250ZXh0KGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQsIGNvbnRleHRJZD86ICd3ZWJnbCd8J3dlYmdsMicpOiBXZWJHTENvbnRleHQge1xuICBjb25zdCBjb250ZXh0QXR0cmlidXRlczogV2ViR0xDb250ZXh0QXR0cmlidXRlcyA9IHtcbiAgICBhbHBoYTogZmFsc2UsXG4gICAgZGVwdGg6IGZhbHNlLFxuICAgIGFudGlhbGlhczogZmFsc2UsXG4gICAgc3RlbmNpbDogZmFsc2UsXG4gICAgcHJlc2VydmVEcmF3aW5nQnVmZmVyOiBmYWxzZSxcbiAgICBwcmVtdWx0aXBsaWVkQWxwaGE6IGZhbHNlLFxuICAgIGZhaWxJZk1ham9yUGVyZm9ybWFuY2VDYXZlYXQ6IGZhbHNlXG4gIH07XG4gIGxldCBnbDogV2ViR0xSZW5kZXJpbmdDb250ZXh0fG51bGw7XG4gIGNvbnN0IGNhID0gY29udGV4dEF0dHJpYnV0ZXM7XG4gIGlmICghY29udGV4dElkIHx8IGNvbnRleHRJZCA9PT0gJ3dlYmdsMicpIHtcbiAgICBnbCA9IGNhbnZhcy5nZXRDb250ZXh0KCd3ZWJnbDInLCBjYSk7XG4gICAgaWYgKGdsKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gbmV3IFdlYkdMQ29udGV4dChnbCwgMik7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgTG9nZ2VyLndhcm5pbmcoJ0dsQ29udGV4dEZhY3RvcnknLCBgZmFpbGVkIHRvIGNyZWF0ZSBXZWJHTENvbnRleHQgdXNpbmcgY29udGV4dElkICd3ZWJnbDInLiBFcnJvcjogJHtlcnJ9YCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICghY29udGV4dElkIHx8IGNvbnRleHRJZCA9PT0gJ3dlYmdsJykge1xuICAgIGdsID0gY2FudmFzLmdldENvbnRleHQoJ3dlYmdsJywgY2EpIHx8IGNhbnZhcy5nZXRDb250ZXh0KCdleHBlcmltZW50YWwtd2ViZ2wnLCBjYSkgYXMgV2ViR0xSZW5kZXJpbmdDb250ZXh0O1xuICAgIGlmIChnbCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG5ldyBXZWJHTENvbnRleHQoZ2wsIDEpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIExvZ2dlci53YXJuaW5nKFxuICAgICAgICAgICAgJ0dsQ29udGV4dEZhY3RvcnknLFxuICAgICAgICAgICAgYGZhaWxlZCB0byBjcmVhdGUgV2ViR0xDb250ZXh0IHVzaW5nIGNvbnRleHRJZCAnd2ViZ2wnIG9yICdleHBlcmltZW50YWwtd2ViZ2wnLiBFcnJvcjogJHtlcnJ9YCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKCdXZWJHTCBpcyBub3Qgc3VwcG9ydGVkJyk7XG59XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbmRlY2xhcmUgbGV0IE9mZnNjcmVlbkNhbnZhczoge25ldyAod2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIpOiBIVE1MQ2FudmFzRWxlbWVudH07XG5cbmZ1bmN0aW9uIGNyZWF0ZUNhbnZhcygpOiBIVE1MQ2FudmFzRWxlbWVudCB7XG4gIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZmFpbGVkIHRvIGNyZWF0ZSBjYW52YXM6IGRvY3VtZW50IGlzIG5vdCBzdXBwb3J0ZWQnKTtcbiAgfVxuICBjb25zdCBjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gIGNhbnZhcy53aWR0aCA9IDE7XG4gIGNhbnZhcy5oZWlnaHQgPSAxO1xuICByZXR1cm4gY2FudmFzO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVPZmZzY3JlZW5DYW52YXMoKTogSFRNTENhbnZhc0VsZW1lbnQge1xuICBpZiAodHlwZW9mIE9mZnNjcmVlbkNhbnZhcyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdmYWlsZWQgdG8gY3JlYXRlIG9mZnNjcmVlbiBjYW52YXM6IE9mZnNjcmVlbkNhbnZhcyBpcyBub3Qgc3VwcG9ydGVkJyk7XG4gIH1cbiAgcmV0dXJuIG5ldyBPZmZzY3JlZW5DYW52YXMoMSwgMSk7XG59XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7ZW52fSBmcm9tICdvbm54cnVudGltZS1jb21tb24nO1xuXG5pbXBvcnQge0JhY2tlbmQsIFNlc3Npb25IYW5kbGVyfSBmcm9tICcuLi9iYWNrZW5kJztcbmltcG9ydCB7TG9nZ2VyfSBmcm9tICcuLi9pbnN0cnVtZW50JztcbmltcG9ydCB7U2Vzc2lvbn0gZnJvbSAnLi4vc2Vzc2lvbic7XG5cbmltcG9ydCB7V2ViR0xTZXNzaW9uSGFuZGxlcn0gZnJvbSAnLi93ZWJnbC9zZXNzaW9uLWhhbmRsZXInO1xuaW1wb3J0IHtXZWJHTENvbnRleHR9IGZyb20gJy4vd2ViZ2wvd2ViZ2wtY29udGV4dCc7XG5pbXBvcnQge2NyZWF0ZVdlYkdMQ29udGV4dH0gZnJvbSAnLi93ZWJnbC93ZWJnbC1jb250ZXh0LWZhY3RvcnknO1xuXG4vKipcbiAqIFdlYkdMQmFja2VuZCBpcyB0aGUgZW50cnkgcG9pbnQgZm9yIGFsbCBXZWJHTCBvcGVhcnRpb25zXG4gKiBXaGVuIGl0IHN0YXJ0cyBpdCBjcmVhdGVkIHRoZSBXZWJHTFJlbmRlcmluZ0NvbnRleHRcbiAqIGFuZCBvdGhlciBtYWluIGZyYW1ld29yayBjb21wb25lbnRzIHN1Y2ggYXMgUHJvZ3JhbSBhbmQgVGV4dHVyZSBNYW5hZ2Vyc1xuICovXG5leHBvcnQgY2xhc3MgV2ViR0xCYWNrZW5kIGltcGxlbWVudHMgQmFja2VuZCB7XG4gIGdsQ29udGV4dDogV2ViR0xDb250ZXh0O1xuXG4gIGdldCBjb250ZXh0SWQoKTogJ3dlYmdsJ3wnd2ViZ2wyJ3x1bmRlZmluZWQge1xuICAgIHJldHVybiBlbnYud2ViZ2wuY29udGV4dElkO1xuICB9XG4gIHNldCBjb250ZXh0SWQodmFsdWU6ICd3ZWJnbCd8J3dlYmdsMid8dW5kZWZpbmVkKSB7XG4gICAgZW52LndlYmdsLmNvbnRleHRJZCA9IHZhbHVlO1xuICB9XG5cbiAgZ2V0IG1hdG11bE1heEJhdGNoU2l6ZSgpOiBudW1iZXJ8dW5kZWZpbmVkIHtcbiAgICByZXR1cm4gZW52LndlYmdsLm1hdG11bE1heEJhdGNoU2l6ZTtcbiAgfVxuICBzZXQgbWF0bXVsTWF4QmF0Y2hTaXplKHZhbHVlOiBudW1iZXJ8dW5kZWZpbmVkKSB7XG4gICAgZW52LndlYmdsLm1hdG11bE1heEJhdGNoU2l6ZSA9IHZhbHVlO1xuICB9XG5cbiAgZ2V0IHRleHR1cmVDYWNoZU1vZGUoKTogJ2luaXRpYWxpemVyT25seSd8J2Z1bGwnfHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIGVudi53ZWJnbC50ZXh0dXJlQ2FjaGVNb2RlO1xuICB9XG4gIHNldCB0ZXh0dXJlQ2FjaGVNb2RlKHZhbHVlOiAnaW5pdGlhbGl6ZXJPbmx5J3wnZnVsbCd8dW5kZWZpbmVkKSB7XG4gICAgZW52LndlYmdsLnRleHR1cmVDYWNoZU1vZGUgPSB2YWx1ZTtcbiAgfVxuXG4gIGdldCBwYWNrKCk6IGJvb2xlYW58dW5kZWZpbmVkIHtcbiAgICByZXR1cm4gZW52LndlYmdsLnBhY2s7XG4gIH1cbiAgc2V0IHBhY2sodmFsdWU6IGJvb2xlYW58dW5kZWZpbmVkKSB7XG4gICAgZW52LndlYmdsLnBhY2sgPSB2YWx1ZTtcbiAgfVxuXG4gIGdldCBhc3luYygpOiBib29sZWFufHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIGVudi53ZWJnbC5hc3luYztcbiAgfVxuICBzZXQgYXN5bmModmFsdWU6IGJvb2xlYW58dW5kZWZpbmVkKSB7XG4gICAgZW52LndlYmdsLmFzeW5jID0gdmFsdWU7XG4gIH1cblxuICBpbml0aWFsaXplKCk6IGJvb2xlYW4ge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLmdsQ29udGV4dCA9IGNyZWF0ZVdlYkdMQ29udGV4dCh0aGlzLmNvbnRleHRJZCk7XG4gICAgICBpZiAodHlwZW9mIHRoaXMubWF0bXVsTWF4QmF0Y2hTaXplICE9PSAnbnVtYmVyJykge1xuICAgICAgICB0aGlzLm1hdG11bE1heEJhdGNoU2l6ZSA9IDE2O1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB0aGlzLnRleHR1cmVDYWNoZU1vZGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRoaXMudGV4dHVyZUNhY2hlTW9kZSA9ICdmdWxsJztcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgdGhpcy5wYWNrICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgdGhpcy5wYWNrID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHRoaXMuYXN5bmMgIT09ICdib29sZWFuJykge1xuICAgICAgICB0aGlzLmFzeW5jID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIExvZ2dlci5zZXRXaXRoRW52KGVudik7XG5cbiAgICAgIGlmICghZW52LndlYmdsLmNvbnRleHQpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVudi53ZWJnbCwgJ2NvbnRleHQnLCB7dmFsdWU6IHRoaXMuZ2xDb250ZXh0LmdsfSk7XG4gICAgICB9XG5cbiAgICAgIExvZ2dlci52ZXJib3NlKFxuICAgICAgICAgICdXZWJHTEJhY2tlbmQnLFxuICAgICAgICAgIGBDcmVhdGVkIFdlYkdMQ29udGV4dDogJHt0eXBlb2YgdGhpcy5nbENvbnRleHR9IHdpdGggbWF0bXVsTWF4QmF0Y2hTaXplOiAke1xuICAgICAgICAgICAgICB0aGlzLm1hdG11bE1heEJhdGNoU2l6ZX07IHRleHR1cmVDYWNoZU1vZGU6ICR7dGhpcy50ZXh0dXJlQ2FjaGVNb2RlfTsgcGFjazogJHt0aGlzLnBhY2t9OyBhc3luYzogJHtcbiAgICAgICAgICAgICAgdGhpcy5hc3luY30uYCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBMb2dnZXIud2FybmluZygnV2ViR0xCYWNrZW5kJywgYFVuYWJsZSB0byBpbml0aWFsaXplIFdlYkdMQmFja2VuZC4gJHtlfWApO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBjcmVhdGVTZXNzaW9uSGFuZGxlcihjb250ZXh0OiBTZXNzaW9uLkNvbnRleHQpOiBTZXNzaW9uSGFuZGxlciB7XG4gICAgcmV0dXJuIG5ldyBXZWJHTFNlc3Npb25IYW5kbGVyKHRoaXMsIGNvbnRleHQpO1xuICB9XG4gIGRpc3Bvc2UoKTogdm9pZCB7XG4gICAgdGhpcy5nbENvbnRleHQuZGlzcG9zZSgpO1xuICB9XG59XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7V2ViR0xCYWNrZW5kfSBmcm9tICcuL2JhY2tlbmRzL2JhY2tlbmQtd2ViZ2wnO1xuaW1wb3J0IHtHcmFwaH0gZnJvbSAnLi9ncmFwaCc7XG5pbXBvcnQge09wZXJhdG9yfSBmcm9tICcuL29wZXJhdG9ycyc7XG5pbXBvcnQge09wU2V0fSBmcm9tICcuL29wc2V0JztcbmltcG9ydCB7U2Vzc2lvbn0gZnJvbSAnLi9zZXNzaW9uJztcblxuZXhwb3J0IGludGVyZmFjZSBJbmZlcmVuY2VIYW5kbGVyIHtcbiAgLyoqXG4gICAqIGRpc3Bvc2UgdGhlIGluZmVyZW5jZSBoYW5kbGVyLiBpdCB3aWxsIGJlIGNhbGxlZCBhcyB0aGUgbGFzdCBzdGVwIGluIFNlc3Npb24ucnVuKClcbiAgICovXG4gIGRpc3Bvc2UoKTogdm9pZDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTZXNzaW9uSGFuZGxlciB7XG4gIC8qKlxuICAgKiB0cmFuc2Zvcm0gdGhlIGdyYXBoIGF0IGluaXRpYWxpemF0aW9uIHRpbWVcbiAgICogQHBhcmFtIGdyYXBoVHJhbnNmb3JtZXIgdGhlIGdyYXBoIHRyYW5zZm9ybWVyIHRvIG1hbmlwdWxhdGUgdGhlIG1vZGVsIGdyYXBoXG4gICAqL1xuICB0cmFuc2Zvcm1HcmFwaD8oZ3JhcGhUcmFuc2Zvcm1lcjogR3JhcGguVHJhbnNmb3JtZXIpOiB2b2lkO1xuXG4gIC8qKlxuICAgKiBjcmVhdGUgYW4gaW5zdGFuY2Ugb2YgSW5mZXJlbmNlSGFuZGxlciB0byB1c2UgaW4gYSBTZXNzaW9uLnJ1bigpIGNhbGxcbiAgICovXG4gIGNyZWF0ZUluZmVyZW5jZUhhbmRsZXIoKTogSW5mZXJlbmNlSGFuZGxlcjtcblxuICAvKipcbiAgICogZGlzcG9zZSB0aGUgc2Vzc2lvbiBoYW5kbGVyLiBpdCB3aWxsIGJlIGNhbGxlZCB3aGVuIGEgc2Vzc2lvbiBpcyBiZWluZyBkaXNwb3NlZCBleHBsaWNpdGx5XG4gICAqL1xuICBkaXNwb3NlKCk6IHZvaWQ7XG5cbiAgLyoqXG4gICAqIFJlc29sdmVzIHRoZSBvcGVyYXRvciBmcm9tIHRoZSBuYW1lIGFuZCBvcHNldCB2ZXJzaW9uOyBiYWNrZW5kIHNwZWNpZmljXG4gICAqIEBwYXJhbSBub2RlIHRoZSBub2RlIHRvIHJlc29sdmVcbiAgICogQHBhcmFtIG9wc2V0cyBhIGxpc3Qgb2Ygb3BzZXRzIHRoYXQgZXhwb3J0ZWQgZnJvbSB0aGUgbW9kZWxcbiAgICogQHBhcmFtIGdyYXBoIHRoZSBjb21wbGV0ZWx5IGluaXRpYWxpemVkIGdyYXBoXG4gICAqL1xuICByZXNvbHZlKG5vZGU6IEdyYXBoLk5vZGUsIG9wc2V0czogcmVhZG9ubHkgT3BTZXRbXSwgZ3JhcGg6IEdyYXBoKTogT3BlcmF0b3I7XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIGxldCdzIHRoZSBzZXNzaW9uSGFuZGxlciBrbm93IHRoYXQgdGhlIGdyYXBoIGluaXRpYWxpemF0aW9uIGlzIGNvbXBsZXRlXG4gICAqIEBwYXJhbSBncmFwaCB0aGUgY29tcGxldGVseSBpbml0aWFsaXplZCBncmFwaFxuICAgKi9cbiAgb25HcmFwaEluaXRpYWxpemVkPyhncmFwaDogR3JhcGgpOiB2b2lkO1xuXG4gIC8qKlxuICAgKiBhIHJlZmVyZW5jZSB0byB0aGUgY29ycmVzcG9uZGluZyBiYWNrZW5kXG4gICAqL1xuICByZWFkb25seSBiYWNrZW5kOiBCYWNrZW5kO1xuXG4gIC8qKlxuICAgKiBhIHJlZmVyZW5jZSB0byB0aGUgc2Vzc2lvbiBjb250ZXh0XG4gICAqL1xuICByZWFkb25seSBjb250ZXh0OiBTZXNzaW9uLkNvbnRleHQ7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQmFja2VuZCB7XG4gIC8qKlxuICAgKiBpbml0aWFsaXplIHRoZSBiYWNrZW5kLiB3aWxsIGJlIGNhbGxlZCBvbmx5IG9uY2UsIHdoZW4gdGhlIGZpcnN0IHRpbWUgdGhlXG4gICAqIGJhY2tlbmQgaXQgdG8gYmUgdXNlZFxuICAgKi9cbiAgaW5pdGlhbGl6ZSgpOiBib29sZWFufFByb21pc2U8Ym9vbGVhbj47XG5cbiAgLyoqXG4gICAqIGNyZWF0ZSBhbiBpbnN0YW5jZSBvZiBTZXNzaW9uSGFuZGxlciB0byB1c2UgaW4gYSBTZXNzaW9uIG9iamVjdCdzIGxpZmVjeWNsZVxuICAgKi9cbiAgY3JlYXRlU2Vzc2lvbkhhbmRsZXIoY29udGV4dDogU2Vzc2lvbi5Db250ZXh0KTogU2Vzc2lvbkhhbmRsZXI7XG5cbiAgLyoqXG4gICAqIGRpc3Bvc2UgdGhlIGJhY2tlbmQuIGN1cnJlbnRseSB0aGlzIHdpbGwgbm90IGJlIGNhbGxlZFxuICAgKi9cbiAgZGlzcG9zZSgpOiB2b2lkO1xufVxuXG4vLyBjYWNoZXMgYWxsIGluaXRpYWxpemVkIGJhY2tlbmQgaW5zdGFuY2VzXG5jb25zdCBiYWNrZW5kc0NhY2hlOiBNYXA8c3RyaW5nLCBCYWNrZW5kPiA9IG5ldyBNYXAoKTtcblxuZXhwb3J0IGNvbnN0IGJhY2tlbmQ6IHtbbmFtZTogc3RyaW5nXTogQmFja2VuZH0gPSB7XG4gIHdlYmdsOiBuZXcgV2ViR0xCYWNrZW5kKClcbn07XG5cbi8qKlxuICogUmVzb2x2ZSBhIHJlZmVyZW5jZSB0byB0aGUgYmFja2VuZC4gSWYgYSBoaW50IGlzIHNwZWNpZmllZCwgdGhlIGNvcnJlc3BvbmRpbmdcbiAqIGJhY2tlbmQgd2lsbCBiZSB1c2VkLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVzb2x2ZUJhY2tlbmQoaGludD86IHN0cmluZ3xyZWFkb25seSBzdHJpbmdbXSk6IFByb21pc2U8QmFja2VuZD4ge1xuICBpZiAoIWhpbnQpIHtcbiAgICByZXR1cm4gcmVzb2x2ZUJhY2tlbmQoWyd3ZWJnbCddKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBoaW50cyA9IHR5cGVvZiBoaW50ID09PSAnc3RyaW5nJyA/IFtoaW50XSA6IGhpbnQ7XG5cbiAgICBmb3IgKGNvbnN0IGJhY2tlbmRIaW50IG9mIGhpbnRzKSB7XG4gICAgICBjb25zdCBjYWNoZSA9IGJhY2tlbmRzQ2FjaGUuZ2V0KGJhY2tlbmRIaW50KTtcbiAgICAgIGlmIChjYWNoZSkge1xuICAgICAgICByZXR1cm4gY2FjaGU7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGJhY2tlbmQgPSBhd2FpdCB0cnlMb2FkQmFja2VuZChiYWNrZW5kSGludCk7XG4gICAgICBpZiAoYmFja2VuZCkge1xuICAgICAgICByZXR1cm4gYmFja2VuZDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoJ25vIGF2YWlsYWJsZSBiYWNrZW5kIHRvIHVzZScpO1xufVxuXG5hc3luYyBmdW5jdGlvbiB0cnlMb2FkQmFja2VuZChiYWNrZW5kSGludDogc3RyaW5nKTogUHJvbWlzZTxCYWNrZW5kfHVuZGVmaW5lZD4ge1xuICBjb25zdCBiYWNrZW5kT2JqID0gYmFja2VuZDtcblxuICBpZiAodHlwZW9mIGJhY2tlbmRPYmpbYmFja2VuZEhpbnRdICE9PSAndW5kZWZpbmVkJyAmJiBpc0JhY2tlbmQoYmFja2VuZE9ialtiYWNrZW5kSGludF0pKSB7XG4gICAgY29uc3QgYmFja2VuZCA9IGJhY2tlbmRPYmpbYmFja2VuZEhpbnRdO1xuICAgIGxldCBpbml0ID0gYmFja2VuZC5pbml0aWFsaXplKCk7XG4gICAgaWYgKHR5cGVvZiBpbml0ID09PSAnb2JqZWN0JyAmJiAndGhlbicgaW4gaW5pdCkge1xuICAgICAgaW5pdCA9IGF3YWl0IGluaXQ7XG4gICAgfVxuICAgIGlmIChpbml0KSB7XG4gICAgICBiYWNrZW5kc0NhY2hlLnNldChiYWNrZW5kSGludCwgYmFja2VuZCk7XG4gICAgICByZXR1cm4gYmFja2VuZDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBpc0JhY2tlbmQob2JqOiB1bmtub3duKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gIGNvbnN0IG8gPSBvYmogYXMgYW55O1xuXG4gIC8vIGNoZWNrIGlmIGFuIG9iamVjdCBpcyBhIEJhY2tlbmQgaW5zdGFuY2VcbiAgaWYgKFxuICAgICAgJ2luaXRpYWxpemUnIGluIG8gJiYgdHlwZW9mIG8uaW5pdGlhbGl6ZSA9PT0gJ2Z1bmN0aW9uJyAmJiAgICAgICAgICAgICAgICAgICAgICAvLyBpbml0aWFsaXplKClcbiAgICAgICdjcmVhdGVTZXNzaW9uSGFuZGxlcicgaW4gbyAmJiB0eXBlb2Ygby5jcmVhdGVTZXNzaW9uSGFuZGxlciA9PT0gJ2Z1bmN0aW9uJyAmJiAgLy8gY3JlYXRlU2Vzc2lvbkhhbmRsZXIoKVxuICAgICAgJ2Rpc3Bvc2UnIGluIG8gJiYgdHlwZW9mIG8uZGlzcG9zZSA9PT0gJ2Z1bmN0aW9uJyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkaXNwb3NlKClcbiAgKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydCB0eXBlIEJhY2tlbmRUeXBlID0gQmFja2VuZDtcbmV4cG9ydCB0eXBlIFNlc3Npb25IYW5kbGVyVHlwZSA9IFJldHVyblR5cGU8QmFja2VuZFR5cGVbJ2NyZWF0ZVNlc3Npb25IYW5kbGVyJ10+O1xuZXhwb3J0IHR5cGUgSW5mZXJlbmNlSGFuZGxlclR5cGUgPSBSZXR1cm5UeXBlPFNlc3Npb25IYW5kbGVyVHlwZVsnY3JlYXRlSW5mZXJlbmNlSGFuZGxlciddPjtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtTZXNzaW9uSGFuZGxlcn0gZnJvbSAnLi9iYWNrZW5kJztcbmltcG9ydCB7R3JhcGh9IGZyb20gJy4vZ3JhcGgnO1xuaW1wb3J0IHtMb2dnZXIsIFByb2ZpbGVyfSBmcm9tICcuL2luc3RydW1lbnQnO1xuaW1wb3J0IHtPcGVyYXRvcn0gZnJvbSAnLi9vcGVyYXRvcnMnO1xuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4vdGVuc29yJztcblxuY2xhc3MgS2VybmVsT3Age1xuICBjb25zdHJ1Y3RvcihwdWJsaWMgb3A6IE9wZXJhdG9yLCBwdWJsaWMgbm9kZTogR3JhcGguTm9kZSkge31cbn1cblxuZXhwb3J0IGNsYXNzIEV4ZWN1dGlvblBsYW4ge1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGdyYXBoOiBHcmFwaCwgb3BzOiBPcGVyYXRvcltdLCBwcml2YXRlIHByb2ZpbGVyOiBSZWFkb25seTxQcm9maWxlcj4pIHtcbiAgICB0aGlzLmluaXRpYWxpemUob3BzKTtcbiAgfVxuXG4gIGluaXRpYWxpemUob3BzOiBPcGVyYXRvcltdKSB7XG4gICAgdGhpcy5wcm9maWxlci5ldmVudCgnc2Vzc2lvbicsICdFeGVjdXRpb25QbGFuLmluaXRpYWxpemUnLCAoKSA9PiB7XG4gICAgICBjb25zdCBncmFwaE5vZGVzID0gdGhpcy5ncmFwaC5nZXROb2RlcygpO1xuICAgICAgaWYgKGdyYXBoTm9kZXMubGVuZ3RoICE9PSBvcHMubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHNpemUgb2Ygbm9kZXMgYW5kIE9QcyBkbyBub3QgbWF0Y2guJyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX29wcyA9IG9wcy5tYXAoKG9wLCBpKSA9PiBuZXcgS2VybmVsT3Aob3AsIGdyYXBoTm9kZXNbaV0pKTtcbiAgICAgIHRoaXMucmVzZXQoKTtcblxuICAgICAgLy8gbG9vayBmb3Igc3RhcnRlciBub2RlKHMpXG4gICAgICB0aGlzLl9zdGFydGVyID0gW107XG4gICAgICB0aGlzLl9vcHMuZm9yRWFjaCgob3AsIGkpID0+IHtcbiAgICAgICAgbGV0IHJlc29sdmVkID0gdHJ1ZTtcbiAgICAgICAgZm9yIChjb25zdCBpbnB1dCBvZiBvcC5ub2RlLmlucHV0cykge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgIXRoaXMuX3ZhbHVlc1tpbnB1dF0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vdCBhbiBpbml0aWFsaXplZCBpbnB1dFxuICAgICAgICAgICAgICAmJiB0aGlzLmdyYXBoLmdldElucHV0SW5kaWNlcygpLmluZGV4T2YoaW5wdXQpID09PSAtMSAgLy8gbm90IG1vZGVsIGlucHV0XG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICByZXNvbHZlZCA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChyZXNvbHZlZCkge1xuICAgICAgICAgIHRoaXMuX3N0YXJ0ZXIucHVzaChpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICByZXNldCgpIHtcbiAgICB0aGlzLl92YWx1ZXMgPSB0aGlzLmdyYXBoLmdldFZhbHVlcygpLm1hcChpID0+IGkudGVuc29yKTtcbiAgfVxuXG4gIGFzeW5jIGV4ZWN1dGUoc2Vzc2lvbkhhbmRsZXI6IFNlc3Npb25IYW5kbGVyLCBtb2RlbElucHV0czogVGVuc29yW10pOiBQcm9taXNlPFRlbnNvcltdPiB7XG4gICAgcmV0dXJuIHRoaXMucHJvZmlsZXIuZXZlbnQoJ3Nlc3Npb24nLCAnRXhlY3V0aW9uUGxhbi5leGVjdXRlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gcmVzZXQgbWVkaWVtIHJlc3VsdFxuICAgICAgdGhpcy5yZXNldCgpO1xuXG4gICAgICAvLyBjcmVhdGUgaW5mZXJlbmNlIGhhbmRsZXJcbiAgICAgIGNvbnN0IGluZmVyZW5jZUhhbmRsZXIgPSBzZXNzaW9uSGFuZGxlci5jcmVhdGVJbmZlcmVuY2VIYW5kbGVyKCk7XG5cbiAgICAgIC8vIHBvcHVsYXRlIGlucHV0cyB2YWx1ZVxuICAgICAgY29uc3QgZ3JhcGhJbnB1dHMgPSB0aGlzLmdyYXBoLmdldElucHV0SW5kaWNlcygpO1xuICAgICAgaWYgKG1vZGVsSW5wdXRzLmxlbmd0aCAhPT0gZ3JhcGhJbnB1dHMubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgbnVtYmVyIG9mIGlucHV0IHRlbnNvcnMgZG9uJ3QgbWF0Y2ggdGhlIG51bWJlciBvZiBpbnB1dHMgdG8gdGhlIG1vZGVsOiBhY3R1YWw6ICR7XG4gICAgICAgICAgICBtb2RlbElucHV0cy5sZW5ndGh9IGV4cGVjdGVkOiAke2dyYXBoSW5wdXRzLmxlbmd0aH1gKTtcbiAgICAgIH1cblxuICAgICAgbW9kZWxJbnB1dHMuZm9yRWFjaCgoaW5wdXQsIGkpID0+IHtcbiAgICAgICAgY29uc3QgaW5kZXggPSBncmFwaElucHV0c1tpXTtcbiAgICAgICAgdGhpcy5fdmFsdWVzW2luZGV4XSA9IGlucHV0O1xuICAgICAgfSk7XG5cbiAgICAgIC8vIHByZXBhcmUgcnVubmluZyBzZXF1ZW5jZVxuICAgICAgY29uc3Qgc2VxdWVuY2U6IG51bWJlcltdID0gdGhpcy5fc3RhcnRlci5zbGljZSgwKTtcblxuICAgICAgLy8gZXhlY3V0aW9uIGl0ZXJhdGlvbnNcbiAgICAgIGNvbnN0IGdyYXBoVmFsdWVzID0gdGhpcy5ncmFwaC5nZXRWYWx1ZXMoKTtcbiAgICAgIGNvbnN0IGdyYXBoTm9kZXMgPSB0aGlzLmdyYXBoLmdldE5vZGVzKCk7XG5cbiAgICAgIGxldCByZWFyID0gMDtcbiAgICAgIHdoaWxlIChyZWFyIDwgc2VxdWVuY2UubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHRoaXNPcEluZGV4ID0gc2VxdWVuY2VbcmVhcisrXTtcbiAgICAgICAgY29uc3QgdGhpc09wID0gdGhpcy5fb3BzW3RoaXNPcEluZGV4XTtcblxuICAgICAgICAvLyBjaGVjayBpbnB1dFxuICAgICAgICBjb25zdCBpbnB1dExpc3QgPSB0aGlzT3Aubm9kZS5pbnB1dHMubWFwKGkgPT4gdGhpcy5fdmFsdWVzW2ldKTtcbiAgICAgICAgaWYgKGlucHV0TGlzdC5pbmRleE9mKHVuZGVmaW5lZCkgIT09IC0xKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bnJlc29sdmVkIGlucHV0IGRldGVjdGVkOiBvcDogJHt0aGlzT3Aubm9kZX1gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJ1blxuICAgICAgICBjb25zdCBpbnB1dFRlbnNvcnMgPSBpbnB1dExpc3QgYXMgVGVuc29yW107XG4gICAgICAgIExvZ2dlci52ZXJib3NlKFxuICAgICAgICAgICAgJ0V4ZWNQbGFuJyxcbiAgICAgICAgICAgIGBSdW5pbmcgb3A6JHt0aGlzT3Aubm9kZS5uYW1lfSAoJHtcbiAgICAgICAgICAgICAgICBpbnB1dFRlbnNvcnMubWFwKCh0LCBpKSA9PiBgJyR7dGhpc09wLm5vZGUuaW5wdXRzW2ldfSc6ICR7dC50eXBlfVske3QuZGltcy5qb2luKCcsJyl9XWApLmpvaW4oJywgJyl9KWApO1xuXG4gICAgICAgIGNvbnN0IG91dHB1dExpc3QgPSBhd2FpdCB0aGlzLnByb2ZpbGVyLmV2ZW50KFxuICAgICAgICAgICAgJ25vZGUnLCB0aGlzT3Aubm9kZS5uYW1lLCBhc3luYyAoKSA9PiB0aGlzT3Aub3AuaW1wbChpbmZlcmVuY2VIYW5kbGVyLCBpbnB1dFRlbnNvcnMsIHRoaXNPcC5vcC5jb250ZXh0KSk7XG5cbiAgICAgICAgLy8gY2hlY2sgb3V0cHV0XG4gICAgICAgIGlmIChvdXRwdXRMaXN0Lmxlbmd0aCAhPT0gdGhpc09wLm5vZGUub3V0cHV0cy5sZW5ndGgpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RoZSBzaXplIG9mIG91dHB1dCBkb2VzIG5vdCBtYXRjaCBtb2RlbCBkZWZpbml0aW9uLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZmlsbCB2YWx1ZVxuICAgICAgICBvdXRwdXRMaXN0LmZvckVhY2goKG91dHB1dCwgaSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGogPSB0aGlzT3Aubm9kZS5vdXRwdXRzW2ldO1xuICAgICAgICAgIGlmICh0aGlzLl92YWx1ZXNbal0pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgb3V0cHV0IFske2p9XSBhbHJlYWR5IGhhcyB2YWx1ZTogb3A6JHt0aGlzT3Aubm9kZS5uYW1lfWApO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl92YWx1ZXNbal0gPSBvdXRwdXQ7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHJlc29sdmUgZG93bnN0cmVhbSBub2Rlc1xuICAgICAgICBjb25zdCBkb3duc3RyZWFtTm9kZXMgPSBuZXcgU2V0PG51bWJlcj4oKTtcbiAgICAgICAgb3V0cHV0TGlzdC5mb3JFYWNoKChfb3V0cHV0LCBpKSA9PiB7XG4gICAgICAgICAgY29uc3QgaiA9IHRoaXNPcC5ub2RlLm91dHB1dHNbaV07XG4gICAgICAgICAgZm9yIChjb25zdCBjdXJyZW50RG93bnN0cmVhbU5vZGVJbmRleCBvZiBncmFwaFZhbHVlc1tqXS50bykge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudERvd25zdHJlYW1Ob2RlID0gZ3JhcGhOb2Rlc1tjdXJyZW50RG93bnN0cmVhbU5vZGVJbmRleF07XG4gICAgICAgICAgICBsZXQgcmVzb2x2ZWQgPSB0cnVlO1xuICAgICAgICAgICAgZm9yIChjb25zdCBrIG9mIGN1cnJlbnREb3duc3RyZWFtTm9kZS5pbnB1dHMpIHtcbiAgICAgICAgICAgICAgaWYgKCF0aGlzLl92YWx1ZXNba10pIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzb2x2ZWQpIHtcbiAgICAgICAgICAgICAgZG93bnN0cmVhbU5vZGVzLmFkZChjdXJyZW50RG93bnN0cmVhbU5vZGVJbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgc2VxdWVuY2UucHVzaCguLi5kb3duc3RyZWFtTm9kZXMpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBvdXRwdXQ6IFRlbnNvcltdID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZ3JhcGguZ2V0T3V0cHV0SW5kaWNlcygpLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IG91dHB1dEluZGV4ID0gdGhpcy5ncmFwaC5nZXRPdXRwdXRJbmRpY2VzKClbaV07XG4gICAgICAgIGNvbnN0IG91dHB1dFRlbnNvciA9IHRoaXMuX3ZhbHVlc1tvdXRwdXRJbmRleF07XG4gICAgICAgIGlmIChvdXRwdXRUZW5zb3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgcmVxdWlyZWQgb3V0cHV0IFske291dHB1dEluZGV4fV0gZG9lcyBub3QgaGF2ZSB2YWx1ZWApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvdXRwdXRJbmRleCA9PT0gMCkge1xuICAgICAgICAgIGF3YWl0IG91dHB1dFRlbnNvci5nZXREYXRhKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC1leHByZXNzaW9uc1xuICAgICAgICAgIG91dHB1dFRlbnNvci5kYXRhO1xuICAgICAgICB9XG4gICAgICAgIG91dHB1dC5wdXNoKG91dHB1dFRlbnNvcik7XG4gICAgICB9XG4gICAgICBMb2dnZXIudmVyYm9zZSgnRXhlY1BsYW4nLCAnZGlzcG9zaW5nIG9mIGluZmVyZW5jZUhhbmRsZXInKTtcbiAgICAgIGluZmVyZW5jZUhhbmRsZXIuZGlzcG9zZSgpO1xuICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9KTtcbiAgfVxuXG4gIF92YWx1ZXM6IEFycmF5PFRlbnNvcnx1bmRlZmluZWQ+O1xuICBfb3BzOiBLZXJuZWxPcFtdO1xuICBfc3RhcnRlcjogbnVtYmVyW107XG59XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCBMb25nIGZyb20gJ2xvbmcnO1xuXG5pbXBvcnQge29ubnhydW50aW1lfSBmcm9tICcuL29ydC1zY2hlbWEvZmxhdGJ1ZmZlcnMvb3J0LWdlbmVyYXRlZCc7XG5pbXBvcnQge29ubnh9IGZyb20gJy4vb3J0LXNjaGVtYS9wcm90b2J1Zi9vbm54JztcbmltcG9ydCB7VGVuc29yfSBmcm9tICcuL3RlbnNvcic7XG5pbXBvcnQge2RlY29kZVV0ZjhTdHJpbmcsIExvbmdVdGlsfSBmcm9tICcuL3V0aWwnO1xuXG5pbXBvcnQgb3J0RmJzID0gb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicztcblxuZXhwb3J0IGRlY2xhcmUgbmFtZXNwYWNlIEF0dHJpYnV0ZSB7XG4gIGV4cG9ydCBpbnRlcmZhY2UgRGF0YVR5cGVNYXAge1xuICAgIGZsb2F0OiBudW1iZXI7XG4gICAgaW50OiBudW1iZXI7XG4gICAgc3RyaW5nOiBzdHJpbmc7XG4gICAgdGVuc29yOiBUZW5zb3I7XG4gICAgZmxvYXRzOiBudW1iZXJbXTtcbiAgICBpbnRzOiBudW1iZXJbXTtcbiAgICBzdHJpbmdzOiBzdHJpbmdbXTtcbiAgICB0ZW5zb3JzOiBUZW5zb3JbXTtcbiAgfVxuXG4gIGV4cG9ydCB0eXBlIERhdGFUeXBlID0ga2V5b2YgRGF0YVR5cGVNYXA7XG59XG5cbnR5cGUgVmFsdWVUeXBlcyA9IEF0dHJpYnV0ZS5EYXRhVHlwZU1hcFtBdHRyaWJ1dGUuRGF0YVR5cGVdO1xuXG50eXBlIFZhbHVlID0gW1ZhbHVlVHlwZXMsIEF0dHJpYnV0ZS5EYXRhVHlwZV07XG5cbmV4cG9ydCBjbGFzcyBBdHRyaWJ1dGUge1xuICBjb25zdHJ1Y3RvcihhdHRyaWJ1dGVzOiBvbm54LklBdHRyaWJ1dGVQcm90b1tdfG9ydEZicy5BdHRyaWJ1dGVbXXxudWxsfHVuZGVmaW5lZCkge1xuICAgIHRoaXMuX2F0dHJpYnV0ZXMgPSBuZXcgTWFwKCk7XG4gICAgaWYgKGF0dHJpYnV0ZXMgIT09IG51bGwgJiYgYXR0cmlidXRlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBmb3IgKGNvbnN0IGF0dHIgb2YgYXR0cmlidXRlcykge1xuICAgICAgICBpZiAoYXR0ciBpbnN0YW5jZW9mIG9ubnguQXR0cmlidXRlUHJvdG8pIHtcbiAgICAgICAgICB0aGlzLl9hdHRyaWJ1dGVzLnNldChhdHRyLm5hbWUsIFtBdHRyaWJ1dGUuZ2V0VmFsdWUoYXR0ciksIEF0dHJpYnV0ZS5nZXRUeXBlKGF0dHIpXSk7XG4gICAgICAgIH0gZWxzZSBpZiAoYXR0ciBpbnN0YW5jZW9mIG9ydEZicy5BdHRyaWJ1dGUpIHtcbiAgICAgICAgICB0aGlzLl9hdHRyaWJ1dGVzLnNldChhdHRyLm5hbWUoKSEsIFtBdHRyaWJ1dGUuZ2V0VmFsdWUoYXR0ciksIEF0dHJpYnV0ZS5nZXRUeXBlKGF0dHIpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9hdHRyaWJ1dGVzLnNpemUgPCBhdHRyaWJ1dGVzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2R1cGxpY2F0ZWQgYXR0cmlidXRlIG5hbWVzJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgc2V0KGtleTogc3RyaW5nLCB0eXBlOiBBdHRyaWJ1dGUuRGF0YVR5cGUsIHZhbHVlOiBWYWx1ZVR5cGVzKTogdm9pZCB7XG4gICAgdGhpcy5fYXR0cmlidXRlcy5zZXQoa2V5LCBbdmFsdWUsIHR5cGVdKTtcbiAgfVxuICBkZWxldGUoa2V5OiBzdHJpbmcpOiB2b2lkIHtcbiAgICB0aGlzLl9hdHRyaWJ1dGVzLmRlbGV0ZShrZXkpO1xuICB9XG4gIGdldEZsb2F0KGtleTogc3RyaW5nLCBkZWZhdWx0VmFsdWU/OiBBdHRyaWJ1dGUuRGF0YVR5cGVNYXBbJ2Zsb2F0J10pIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoa2V5LCAnZmxvYXQnLCBkZWZhdWx0VmFsdWUpO1xuICB9XG5cbiAgZ2V0SW50KGtleTogc3RyaW5nLCBkZWZhdWx0VmFsdWU/OiBBdHRyaWJ1dGUuRGF0YVR5cGVNYXBbJ2ludCddKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KGtleSwgJ2ludCcsIGRlZmF1bHRWYWx1ZSk7XG4gIH1cblxuICBnZXRTdHJpbmcoa2V5OiBzdHJpbmcsIGRlZmF1bHRWYWx1ZT86IEF0dHJpYnV0ZS5EYXRhVHlwZU1hcFsnc3RyaW5nJ10pIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoa2V5LCAnc3RyaW5nJywgZGVmYXVsdFZhbHVlKTtcbiAgfVxuXG4gIGdldFRlbnNvcihrZXk6IHN0cmluZywgZGVmYXVsdFZhbHVlPzogQXR0cmlidXRlLkRhdGFUeXBlTWFwWyd0ZW5zb3InXSkge1xuICAgIHJldHVybiB0aGlzLmdldChrZXksICd0ZW5zb3InLCBkZWZhdWx0VmFsdWUpO1xuICB9XG5cbiAgZ2V0RmxvYXRzKGtleTogc3RyaW5nLCBkZWZhdWx0VmFsdWU/OiBBdHRyaWJ1dGUuRGF0YVR5cGVNYXBbJ2Zsb2F0cyddKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KGtleSwgJ2Zsb2F0cycsIGRlZmF1bHRWYWx1ZSk7XG4gIH1cblxuICBnZXRJbnRzKGtleTogc3RyaW5nLCBkZWZhdWx0VmFsdWU/OiBBdHRyaWJ1dGUuRGF0YVR5cGVNYXBbJ2ludHMnXSkge1xuICAgIHJldHVybiB0aGlzLmdldChrZXksICdpbnRzJywgZGVmYXVsdFZhbHVlKTtcbiAgfVxuXG4gIGdldFN0cmluZ3Moa2V5OiBzdHJpbmcsIGRlZmF1bHRWYWx1ZT86IEF0dHJpYnV0ZS5EYXRhVHlwZU1hcFsnc3RyaW5ncyddKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KGtleSwgJ3N0cmluZ3MnLCBkZWZhdWx0VmFsdWUpO1xuICB9XG5cbiAgZ2V0VGVuc29ycyhrZXk6IHN0cmluZywgZGVmYXVsdFZhbHVlPzogQXR0cmlidXRlLkRhdGFUeXBlTWFwWyd0ZW5zb3JzJ10pIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoa2V5LCAndGVuc29ycycsIGRlZmF1bHRWYWx1ZSk7XG4gIH1cblxuICBwcml2YXRlIGdldDxWIGV4dGVuZHMgQXR0cmlidXRlLkRhdGFUeXBlTWFwW0F0dHJpYnV0ZS5EYXRhVHlwZV0+KFxuICAgICAga2V5OiBzdHJpbmcsIHR5cGU6IEF0dHJpYnV0ZS5EYXRhVHlwZSwgZGVmYXVsdFZhbHVlPzogVik6IFYge1xuICAgIGNvbnN0IHZhbHVlQW5kVHlwZSA9IHRoaXMuX2F0dHJpYnV0ZXMuZ2V0KGtleSk7XG4gICAgaWYgKHZhbHVlQW5kVHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoZGVmYXVsdFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcihgcmVxdWlyZWQgYXR0cmlidXRlIG5vdCBmb3VuZDogJHtrZXl9YCk7XG4gICAgfVxuICAgIGlmICh2YWx1ZUFuZFR5cGVbMV0gIT09IHR5cGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdHlwZSBtaXNtYXRjaDogZXhwZWN0ZWQgJHt0eXBlfSBidXQgZ290ICR7dmFsdWVBbmRUeXBlWzFdfWApO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWVBbmRUeXBlWzBdIGFzIFY7XG4gIH1cblxuICBwcml2YXRlIHN0YXRpYyBnZXRUeXBlKGF0dHI6IG9ubnguSUF0dHJpYnV0ZVByb3RvfG9ydEZicy5BdHRyaWJ1dGUpOiBBdHRyaWJ1dGUuRGF0YVR5cGUge1xuICAgIGNvbnN0IHR5cGUgPSBhdHRyIGluc3RhbmNlb2Ygb25ueC5BdHRyaWJ1dGVQcm90byA/IChhdHRyKS50eXBlIDogKGF0dHIgYXMgb3J0RmJzLkF0dHJpYnV0ZSkudHlwZSgpO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBvbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuRkxPQVQ6XG4gICAgICAgIHJldHVybiAnZmxvYXQnO1xuICAgICAgY2FzZSBvbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuSU5UOlxuICAgICAgICByZXR1cm4gJ2ludCc7XG4gICAgICBjYXNlIG9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5TVFJJTkc6XG4gICAgICAgIHJldHVybiAnc3RyaW5nJztcbiAgICAgIGNhc2Ugb25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLlRFTlNPUjpcbiAgICAgICAgcmV0dXJuICd0ZW5zb3InO1xuICAgICAgY2FzZSBvbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuRkxPQVRTOlxuICAgICAgICByZXR1cm4gJ2Zsb2F0cyc7XG4gICAgICBjYXNlIG9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5JTlRTOlxuICAgICAgICByZXR1cm4gJ2ludHMnO1xuICAgICAgY2FzZSBvbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuU1RSSU5HUzpcbiAgICAgICAgcmV0dXJuICdzdHJpbmdzJztcbiAgICAgIGNhc2Ugb25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLlRFTlNPUlM6XG4gICAgICAgIHJldHVybiAndGVuc29ycyc7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGF0dHJpYnV0ZSB0eXBlIGlzIG5vdCBzdXBwb3J0ZWQgeWV0OiAke29ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZVt0eXBlXX1gKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHN0YXRpYyBnZXRWYWx1ZShhdHRyOiBvbm54LklBdHRyaWJ1dGVQcm90b3xvcnRGYnMuQXR0cmlidXRlKSB7XG4gICAgY29uc3QgYXR0clR5cGUgPSBhdHRyIGluc3RhbmNlb2Ygb25ueC5BdHRyaWJ1dGVQcm90byA/IGF0dHIudHlwZSA6IChhdHRyIGFzIG9ydEZicy5BdHRyaWJ1dGUpLnR5cGUoKTtcbiAgICBpZiAoYXR0clR5cGUgPT09IG9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5HUkFQSCB8fCBhdHRyVHlwZSA9PT0gb25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLkdSQVBIUykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdncmFwaCBhdHRyaWJ1dGUgaXMgbm90IHN1cHBvcnRlZCB5ZXQnKTtcbiAgICB9XG5cbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMuZ2V0VmFsdWVOb0NoZWNrKGF0dHIpO1xuXG4gICAgLy8gY2FzdCBMT05HIHRvIG51bWJlclxuICAgIGlmIChhdHRyVHlwZSA9PT0gb25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLklOVCAmJiBMb25nVXRpbC5pc0xvbmcodmFsdWUpKSB7XG4gICAgICByZXR1cm4gTG9uZ1V0aWwubG9uZ1RvTnVtYmVyKHZhbHVlIGFzIExvbmcgfCBmbGF0YnVmZmVycy5Mb25nKTtcbiAgICB9XG5cbiAgICAvLyBjYXN0IExPTkdbXSB0byBudW1iZXJbXVxuICAgIGlmIChhdHRyVHlwZSA9PT0gb25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLklOVFMpIHtcbiAgICAgIGNvbnN0IGFyciA9ICh2YWx1ZSBhcyBBcnJheTxudW1iZXJ8TG9uZ3xmbGF0YnVmZmVycy5Mb25nPik7XG4gICAgICBjb25zdCBudW1iZXJWYWx1ZTogbnVtYmVyW10gPSBuZXcgQXJyYXk8bnVtYmVyPihhcnIubGVuZ3RoKTtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgbWF5YmVMb25nID0gYXJyW2ldO1xuICAgICAgICBudW1iZXJWYWx1ZVtpXSA9IExvbmdVdGlsLmxvbmdUb051bWJlcihtYXliZUxvbmcpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVtYmVyVmFsdWU7XG4gICAgfVxuXG4gICAgLy8gY2FzdCBvbm54LlRlbnNvclByb3RvIHRvIG9ubnhqcy5UZW5zb3JcbiAgICBpZiAoYXR0clR5cGUgPT09IG9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5URU5TT1IpIHtcbiAgICAgIHJldHVybiBhdHRyIGluc3RhbmNlb2Ygb25ueC5BdHRyaWJ1dGVQcm90byA/IFRlbnNvci5mcm9tUHJvdG8odmFsdWUgYXMgb25ueC5JVGVuc29yUHJvdG8pIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRlbnNvci5mcm9tT3J0VGVuc29yKHZhbHVlIGFzIG9ydEZicy5UZW5zb3IpO1xuICAgIH1cblxuICAgIC8vIGNhc3Qgb25ueC5UZW5zb3JQcm90b1tdIHRvIG9ubnhqcy5UZW5zb3JbXVxuICAgIGlmIChhdHRyVHlwZSA9PT0gb25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLlRFTlNPUlMpIHtcbiAgICAgIGlmIChhdHRyIGluc3RhbmNlb2Ygb25ueC5BdHRyaWJ1dGVQcm90bykge1xuICAgICAgICBjb25zdCB0ZW5zb3JQcm90b3MgPSB2YWx1ZSBhcyBvbm54LklUZW5zb3JQcm90b1tdO1xuICAgICAgICByZXR1cm4gdGVuc29yUHJvdG9zLm1hcCh2YWx1ZSA9PiBUZW5zb3IuZnJvbVByb3RvKHZhbHVlKSk7XG4gICAgICB9IGVsc2UgaWYgKGF0dHIgaW5zdGFuY2VvZiBvcnRGYnMuQXR0cmlidXRlKSB7XG4gICAgICAgIGNvbnN0IHRlbnNvclByb3RvcyA9IHZhbHVlIGFzIG9ydEZicy5UZW5zb3JbXTtcbiAgICAgICAgcmV0dXJuIHRlbnNvclByb3Rvcy5tYXAodmFsdWUgPT4gVGVuc29yLmZyb21PcnRUZW5zb3IodmFsdWUpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjYXN0IFVpbnQ4QXJyYXkgdG8gc3RyaW5nXG4gICAgaWYgKGF0dHJUeXBlID09PSBvbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuU1RSSU5HKSB7XG4gICAgICAvLyBzdHJpbmcgaW4gb25ueCBhdHRyaWJ1dGUgaXMgb2YgdWludDhhcnJheSB0eXBlLCBzbyB3ZSBuZWVkIHRvIGNvbnZlcnQgaXQgdG8gc3RyaW5nIGJlbG93LiBXaGlsZSBpbiBvcnQgZm9ybWF0LFxuICAgICAgLy8gc3RyaW5nIGF0dHJpYnV0ZXMgYXJlIHJldHVybmVkIGFzIHN0cmluZywgc28gbm8gY29udmVyc2lvbiBpcyBuZWVkZWQuXG4gICAgICBpZiAoYXR0ciBpbnN0YW5jZW9mIG9ubnguQXR0cmlidXRlUHJvdG8pIHtcbiAgICAgICAgY29uc3QgdXRmOFN0cmluZyA9IHZhbHVlIGFzIFVpbnQ4QXJyYXk7XG4gICAgICAgIHJldHVybiBkZWNvZGVVdGY4U3RyaW5nKHV0ZjhTdHJpbmcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNhc3QgVWludDhBcnJheVtdIHRvIHN0cmluZ1tdXG4gICAgaWYgKGF0dHJUeXBlID09PSBvbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuU1RSSU5HUykge1xuICAgICAgLy8gc3RyaW5ncyBpbiBvbm54IGF0dHJpYnV0ZSBpcyByZXR1cm5lZCBhcyB1aW50OGFycmF5W10sIHNvIHdlIG5lZWQgdG8gY29udmVydCBpdCB0byBzdHJpbmdbXSBiZWxvdy4gV2hpbGUgaW4gb3J0XG4gICAgICAvLyBmb3JtYXQgc3RyaW5ncyBhdHRyaWJ1dGVzIGFyZSByZXR1cm5lZCBhcyBzdHJpbmdbXSwgc28gbm8gY29udmVyc2lvbiBpcyBuZWVkZWQuXG4gICAgICBpZiAoYXR0ciBpbnN0YW5jZW9mIG9ubnguQXR0cmlidXRlUHJvdG8pIHtcbiAgICAgICAgY29uc3QgdXRmOFN0cmluZ3MgPSB2YWx1ZSBhcyBVaW50OEFycmF5W107XG4gICAgICAgIHJldHVybiB1dGY4U3RyaW5ncy5tYXAoZGVjb2RlVXRmOFN0cmluZyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlIGFzIFZhbHVlVHlwZXM7XG4gIH1cblxuICBwcml2YXRlIHN0YXRpYyBnZXRWYWx1ZU5vQ2hlY2soYXR0cjogb25ueC5JQXR0cmlidXRlUHJvdG98b3J0RmJzLkF0dHJpYnV0ZSkge1xuICAgIHJldHVybiBhdHRyIGluc3RhbmNlb2YgKG9ubnguQXR0cmlidXRlUHJvdG8pID8gdGhpcy5nZXRWYWx1ZU5vQ2hlY2tGcm9tT25ueEZvcm1hdChhdHRyKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdldFZhbHVlTm9DaGVja0Zyb21PcnRGb3JtYXQoYXR0ciBhcyBvcnRGYnMuQXR0cmlidXRlKTtcbiAgfVxuXG4gIHByaXZhdGUgc3RhdGljIGdldFZhbHVlTm9DaGVja0Zyb21Pbm54Rm9ybWF0KGF0dHI6IG9ubnguSUF0dHJpYnV0ZVByb3RvKSB7XG4gICAgc3dpdGNoIChhdHRyLnR5cGUhKSB7XG4gICAgICBjYXNlIG9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5GTE9BVDpcbiAgICAgICAgcmV0dXJuIGF0dHIuZjtcbiAgICAgIGNhc2Ugb25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLklOVDpcbiAgICAgICAgcmV0dXJuIGF0dHIuaTtcbiAgICAgIGNhc2Ugb25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLlNUUklORzpcbiAgICAgICAgcmV0dXJuIGF0dHIucztcbiAgICAgIGNhc2Ugb25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLlRFTlNPUjpcbiAgICAgICAgcmV0dXJuIGF0dHIudDtcbiAgICAgIGNhc2Ugb25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLkdSQVBIOlxuICAgICAgICByZXR1cm4gYXR0ci5nO1xuICAgICAgY2FzZSBvbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuRkxPQVRTOlxuICAgICAgICByZXR1cm4gYXR0ci5mbG9hdHM7XG4gICAgICBjYXNlIG9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5JTlRTOlxuICAgICAgICByZXR1cm4gYXR0ci5pbnRzO1xuICAgICAgY2FzZSBvbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuU1RSSU5HUzpcbiAgICAgICAgcmV0dXJuIGF0dHIuc3RyaW5ncztcbiAgICAgIGNhc2Ugb25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLlRFTlNPUlM6XG4gICAgICAgIHJldHVybiBhdHRyLnRlbnNvcnM7XG4gICAgICBjYXNlIG9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5HUkFQSFM6XG4gICAgICAgIHJldHVybiBhdHRyLmdyYXBocztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgYXR0cmlidXRlIHR5cGU6ICR7b25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlW2F0dHIudHlwZSFdfWApO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgc3RhdGljIGdldFZhbHVlTm9DaGVja0Zyb21PcnRGb3JtYXQoYXR0cjogb3J0RmJzLkF0dHJpYnV0ZSkge1xuICAgIHN3aXRjaCAoYXR0ci50eXBlKCkpIHtcbiAgICAgIGNhc2Ugb3J0RmJzLkF0dHJpYnV0ZVR5cGUuRkxPQVQ6XG4gICAgICAgIHJldHVybiBhdHRyLmYoKTtcbiAgICAgIGNhc2Ugb3J0RmJzLkF0dHJpYnV0ZVR5cGUuSU5UOlxuICAgICAgICByZXR1cm4gYXR0ci5pKCk7XG4gICAgICBjYXNlIG9ydEZicy5BdHRyaWJ1dGVUeXBlLlNUUklORzpcbiAgICAgICAgcmV0dXJuIGF0dHIucygpO1xuICAgICAgY2FzZSBvcnRGYnMuQXR0cmlidXRlVHlwZS5URU5TT1I6XG4gICAgICAgIHJldHVybiBhdHRyLnQoKTtcbiAgICAgIGNhc2Ugb3J0RmJzLkF0dHJpYnV0ZVR5cGUuR1JBUEg6XG4gICAgICAgIHJldHVybiBhdHRyLmcoKTtcbiAgICAgIGNhc2Ugb3J0RmJzLkF0dHJpYnV0ZVR5cGUuRkxPQVRTOlxuICAgICAgICByZXR1cm4gYXR0ci5mbG9hdHNBcnJheSgpO1xuICAgICAgY2FzZSBvcnRGYnMuQXR0cmlidXRlVHlwZS5JTlRTOiB7XG4gICAgICAgIGNvbnN0IGludHMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhdHRyLmludHNMZW5ndGgoKTsgaSsrKSB7XG4gICAgICAgICAgaW50cy5wdXNoKGF0dHIuaW50cyhpKSEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnRzO1xuICAgICAgfVxuICAgICAgY2FzZSBvcnRGYnMuQXR0cmlidXRlVHlwZS5TVFJJTkdTOiB7XG4gICAgICAgIGNvbnN0IHN0cmluZ3MgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhdHRyLnN0cmluZ3NMZW5ndGgoKTsgaSsrKSB7XG4gICAgICAgICAgc3RyaW5ncy5wdXNoKGF0dHIuc3RyaW5ncyhpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cmluZ3M7XG4gICAgICB9XG4gICAgICBjYXNlIG9ydEZicy5BdHRyaWJ1dGVUeXBlLlRFTlNPUlM6IHtcbiAgICAgICAgY29uc3QgdGVuc29ycyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGF0dHIudGVuc29yc0xlbmd0aCgpOyBpKyspIHtcbiAgICAgICAgICB0ZW5zb3JzLnB1c2goYXR0ci50ZW5zb3JzKGkpISk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRlbnNvcnM7XG4gICAgICB9XG4gICAgICAvLyBjYXNlIG9ydEZicy5BdHRyaWJ1dGVUeXBlLkdSQVBIUzpcbiAgICAgIC8vIFRPRE86IFN1YmdyYXBoIG5vdCBzdXBwb3J0ZWQgeWV0LlxuICAgICAgLy8gY29uc3QgZ3JhcGhzID0gW107XG4gICAgICAvLyBmb3IgKGxldCBpID0gMDsgaSA8IGF0dHIuZ3JhcGhzTGVuZ3RoKCk7IGkrKykge1xuICAgICAgLy8gICBncmFwaHMucHVzaChhdHRyLmdyYXBocyhpKSEpO1xuICAgICAgLy8gfVxuICAgICAgLy8gcmV0dXJuIGdyYXBocztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgYXR0cmlidXRlIHR5cGU6ICR7b3J0RmJzLkF0dHJpYnV0ZVR5cGVbYXR0ci50eXBlKCldfWApO1xuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBfYXR0cmlidXRlczogTWFwPHN0cmluZywgVmFsdWU+O1xufVxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0F0dHJpYnV0ZX0gZnJvbSAnLi9hdHRyaWJ1dGUnO1xuaW1wb3J0IHtvbm54cnVudGltZX0gZnJvbSAnLi9vcnQtc2NoZW1hL2ZsYXRidWZmZXJzL29ydC1nZW5lcmF0ZWQnO1xuaW1wb3J0IHtvbm54fSBmcm9tICcuL29ydC1zY2hlbWEvcHJvdG9idWYvb25ueCc7XG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi90ZW5zb3InO1xuaW1wb3J0IHtMb25nVXRpbCwgTUFYX0NMSVAsIE1JTl9DTElQLCBQcm90b1V0aWx9IGZyb20gJy4vdXRpbCc7XG5cbmltcG9ydCBvcnRGYnMgPSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzO1xuXG5leHBvcnQgZGVjbGFyZSBuYW1lc3BhY2UgR3JhcGgge1xuICBleHBvcnQgaW50ZXJmYWNlIFNoYXBlIHtcbiAgICByZWFkb25seSBkaW1zOiByZWFkb25seSBudW1iZXJbXTtcbiAgfVxuICBleHBvcnQgaW50ZXJmYWNlIFZhbHVlVHlwZSB7XG4gICAgcmVhZG9ubHkgdGVuc29yVHlwZTogVGVuc29yLkRhdGFUeXBlO1xuICAgIHJlYWRvbmx5IHNoYXBlOiBTaGFwZTtcbiAgfVxuICBleHBvcnQgaW50ZXJmYWNlIFZhbHVlIHtcbiAgICAvLyB0aGUgdGVuc29yIGRhdGEuIGVtcHR5IGZvciBub24taW5pdGlhbGl6ZWQgaW5wdXRzXG4gICAgcmVhZG9ubHkgdGVuc29yPzogVGVuc29yO1xuXG4gICAgLy8gaW5kZXggdG8gdGhlIE5vZGUgd2hlcmUgdGhlIHZhbHVlIGNvbWVzIGZyb20uIC0xIGZvciBpbml0aWFsaXplci5cbiAgICByZWFkb25seSBmcm9tOiBudW1iZXI7XG5cbiAgICAvLyBpbmRpY2VzIHRvIHRoZSBOb2RlcyB3aGVyZSB0aGUgdmFsdWVzIGdvIHRvLlxuICAgIHJlYWRvbmx5IHRvOiByZWFkb25seSBudW1iZXJbXTtcblxuICAgIC8vIHZhbHVlIHR5cGUgc3BlY2lmaWNhdGlvbi4gZW1wdHkgZm9yIG5vbi1pbnB1dCB2YWx1ZXMuXG4gICAgcmVhZG9ubHkgdHlwZT86IFZhbHVlVHlwZTtcbiAgfVxuICBleHBvcnQgaW50ZXJmYWNlIE5vZGUge1xuICAgIC8vIG5hbWUgb2YgdGhlIG5vZGVcbiAgICByZWFkb25seSBuYW1lOiBzdHJpbmc7XG5cbiAgICAvLyB0aGUgb3BlcmF0b3IgdHlwZVxuICAgIHJlYWRvbmx5IG9wVHlwZTogc3RyaW5nO1xuXG4gICAgLy8gaW5kaWNlcyB0byB0aGUgVmFsdWVzIHdoZXJlIHRoZSBpbnB1dHMgY29tZSBmcm9tLlxuICAgIHJlYWRvbmx5IGlucHV0czogcmVhZG9ubHkgbnVtYmVyW107XG5cbiAgICAvLyBpbmRpY2VzIHRvIHRoZSBWYWx1ZXMgd2hlcmUgdGhlIG91dHB1cyBnbyB0by5cbiAgICByZWFkb25seSBvdXRwdXRzOiByZWFkb25seSBudW1iZXJbXTtcblxuICAgIC8vIHRoZSBhdHRyaWJ1dGVzIHRoYXQgdXNlZCBieSB0aGUgb3BlcmF0b3JcbiAgICByZWFkb25seSBhdHRyaWJ1dGVzOiBBdHRyaWJ1dGU7XG4gIH1cblxuICAvKipcbiAgICogYSBUcmFuc2Zvcm1lciBpcyBhbiBpbnN0YW5jZSB0aGF0IGFsbG93cyBhbGwgcG9zc2libGUgdHJhbnNmb3JtYXRpb24gb3BlcmF0aW9ucyB0aGF0IGFwcGxpZWQgdG8gYSBncmFwaFxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBUcmFuc2Zvcm1lciB7XG4gICAgcmVtb3ZlQWxsSWRlbnRpdHlOb2RlcygpOiB2b2lkO1xuICAgIHJlbW92ZUFsbERyb3BvdXROb2RlcygpOiB2b2lkO1xuICAgIGZ1c2VDb252QWN0aXZhdGlvbk5vZGVzKCk6IHZvaWQ7XG4gICAgLy8gVE9ETzogYWRkIGdlbmVyaWMgZnVuY3Rpb25zIHRvIG1hbmlwdWxhdGUgdGhlIGdyYXBoXG4gIH1cblxuICAvLyBhbiBpbml0aWFsaXplciBjYW4gdXNlIHRyYW5zZm9ybWVyIHRvIHRyYW5zZm9ybSB0aGUgZ3JhcGhcbiAgZXhwb3J0IGludGVyZmFjZSBJbml0aWFsaXplciB7XG4gICAgdHJhbnNmb3JtR3JhcGgodHJhbnNmb3JtZXI6IFRyYW5zZm9ybWVyKTogdm9pZDtcbiAgfVxufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXJlZGVjbGFyZVxuZXhwb3J0IGludGVyZmFjZSBHcmFwaCB7XG4gIGdldElucHV0SW5kaWNlcygpOiByZWFkb25seSBudW1iZXJbXTtcbiAgZ2V0SW5wdXROYW1lcygpOiByZWFkb25seSBzdHJpbmdbXTtcbiAgZ2V0T3V0cHV0SW5kaWNlcygpOiByZWFkb25seSBudW1iZXJbXTtcbiAgZ2V0T3V0cHV0TmFtZXMoKTogcmVhZG9ubHkgc3RyaW5nW107XG4gIGdldFZhbHVlcygpOiByZWFkb25seSBHcmFwaC5WYWx1ZVtdO1xuICBnZXROb2RlcygpOiByZWFkb25seSBHcmFwaC5Ob2RlW107XG59XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb24sIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZWRlY2xhcmVcbmV4cG9ydCBjb25zdCBHcmFwaCA9IHtcbiAgLyoqXG4gICAqIGNvbnN0cnVjdCBhIGdyYXBoIGZyb20gYSBncmFwaCBwcm90b2J1ZiB0eXBlXG4gICAqL1xuICBmcm9tOiAoZ3JhcGhQcm90bzogb25ueC5JR3JhcGhQcm90b3xvcnRGYnMuR3JhcGgsIGluaXRpYWxpemVyPzogR3JhcGguSW5pdGlhbGl6ZXIpID0+XG4gICAgICBuZXcgR3JhcGhJbXBsKGdyYXBoUHJvdG8sIGluaXRpYWxpemVyKSxcbn07XG5cbmNsYXNzIFZhbHVlIGltcGxlbWVudHMgR3JhcGguVmFsdWUge1xuICBjb25zdHJ1Y3Rvcih2YWx1ZUluZm8/OiBvbm54LklWYWx1ZUluZm9Qcm90bykge1xuICAgIHRoaXMuX2Zyb20gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fdG8gPSBbXTtcbiAgICB0aGlzLnRlbnNvciA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnR5cGUgPSB1bmRlZmluZWQ7XG5cbiAgICBpZiAodmFsdWVJbmZvKSB7XG4gICAgICB0aGlzLnR5cGUgPSBQcm90b1V0aWwudGVuc29yVmFsdWVUeXBlRnJvbVByb3RvKHZhbHVlSW5mby50eXBlIS50ZW5zb3JUeXBlISk7XG4gICAgfVxuICB9XG5cbiAgX2Zyb20/OiBudW1iZXI7ICAvLyAtMSByZXByZXNlbnQgZnJvbSBpbml0aWFsaXplclxuICBnZXQgZnJvbSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZnJvbSE7XG4gIH1cbiAgX3RvOiBudW1iZXJbXTtcbiAgZ2V0IHRvKCkge1xuICAgIHJldHVybiB0aGlzLl90bztcbiAgfVxuICB0eXBlPzogR3JhcGguVmFsdWVUeXBlO1xuICB0ZW5zb3I/OiBUZW5zb3I7XG59XG5cbmNsYXNzIE5vZGUgaW1wbGVtZW50cyBHcmFwaC5Ob2RlIHtcbiAgY29uc3RydWN0b3IoX25vZGVQcm90bzogb25ueC5JTm9kZVByb3RvfG9ydEZicy5Ob2RlLCBuYW1lPzogc3RyaW5nKSB7XG4gICAgaWYgKF9ub2RlUHJvdG8gaW5zdGFuY2VvZiBvbm54Lk5vZGVQcm90bykge1xuICAgICAgdGhpcy5uYW1lID0gX25vZGVQcm90by5uYW1lO1xuICAgICAgdGhpcy5vcFR5cGUgPSBfbm9kZVByb3RvLm9wVHlwZTtcbiAgICAgIHRoaXMuYXR0cmlidXRlcyA9IG5ldyBBdHRyaWJ1dGUoX25vZGVQcm90by5hdHRyaWJ1dGUpO1xuICAgIH0gZWxzZSBpZiAoX25vZGVQcm90byBpbnN0YW5jZW9mIG9ydEZicy5Ob2RlKSB7XG4gICAgICB0aGlzLm5hbWUgPSBuYW1lID8/IF9ub2RlUHJvdG8ubmFtZSgpITtcbiAgICAgIHRoaXMub3BUeXBlID0gX25vZGVQcm90by5vcFR5cGUoKSE7XG4gICAgICB0aGlzLmF0dHJpYnV0ZXMgPSBuZXcgQXR0cmlidXRlKFByb3RvVXRpbC50ZW5zb3JBdHRyaWJ1dGVzRnJvbU9SVEZvcm1hdChfbm9kZVByb3RvKSk7XG4gICAgfVxuXG4gICAgdGhpcy5pbnB1dHMgPSBbXTtcbiAgICB0aGlzLm91dHB1dHMgPSBbXTtcbiAgICB0aGlzLmV4ZWN1dGVOb2RlID0gdHJ1ZTtcbiAgfVxuXG4gIG5hbWU6IHN0cmluZztcbiAgb3BUeXBlOiBzdHJpbmc7XG4gIGlucHV0czogbnVtYmVyW107XG4gIG91dHB1dHM6IG51bWJlcltdO1xuICBhdHRyaWJ1dGVzOiBBdHRyaWJ1dGU7XG4gIGV4ZWN1dGVOb2RlOiBib29sZWFuO1xufVxuXG5jbGFzcyBHcmFwaEltcGwgaW1wbGVtZW50cyBHcmFwaCwgR3JhcGguVHJhbnNmb3JtZXIge1xuICBwcml2YXRlIF9hbGxEYXRhOiBWYWx1ZVtdO1xuXG4gIHByaXZhdGUgX2FsbElucHV0SW5kaWNlczogbnVtYmVyW107XG4gIHByaXZhdGUgX2FsbElucHV0TmFtZXM6IHN0cmluZ1tdO1xuXG4gIHByaXZhdGUgX2FsbE91dHB1dEluZGljZXM6IG51bWJlcltdO1xuICBwcml2YXRlIF9hbGxPdXRwdXROYW1lczogc3RyaW5nW107XG5cbiAgcHJpdmF0ZSBfbm9kZXM6IE5vZGVbXTtcblxuICBjb25zdHJ1Y3RvcihncmFwaDogb25ueC5JR3JhcGhQcm90b3xvcnRGYnMuR3JhcGgsIGdyYXBoSW5pdGlhbGl6ZXI/OiBHcmFwaC5Jbml0aWFsaXplcikge1xuICAgIGlmICghZ3JhcGgpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2dyYXBoIGlzIGVtcHR5Jyk7XG4gICAgfVxuXG4gICAgLy8gYnVpbGQgdGhlIGdyYXBoIC0gd2lsbCB0aHJvdyBleGNlcHRpb25zIGlmIHNvbWV0aGluZyBmYXRhbCBpcyBkZXRlY3RlZFxuICAgIHRoaXMuYnVpbGRHcmFwaChncmFwaCk7XG5cbiAgICAvLyBleGVjdXRlIGFueSB0cmFuc2Zvcm1hdGlvbiBsb2dpYyBmb3IgdGhlIGdyYXBoIChpZiBhcHBsaWNhYmxlKVxuICAgIHRoaXMudHJhbnNmb3JtR3JhcGgoZ3JhcGhJbml0aWFsaXplcik7XG5cbiAgICAvLyBjaGVjayBmb3IgY3ljbGVzIGFuZCBvdGhlciBpbmNvbnNpc3RlbmNpZXMgLSB3aWxsIHRocm93IGV4Y2VwdGlvbnMgaWYgc29tZXRoaW5nIGZhdGFsIGlzIGRldGVjdGVkXG4gICAgdGhpcy5jaGVja0lzQWN5Y2xpYygpO1xuICB9XG5cbiAgZ2V0SW5wdXRJbmRpY2VzKCk6IHJlYWRvbmx5IG51bWJlcltdIHtcbiAgICByZXR1cm4gdGhpcy5fYWxsSW5wdXRJbmRpY2VzO1xuICB9XG5cbiAgZ2V0SW5wdXROYW1lcygpOiByZWFkb25seSBzdHJpbmdbXSB7XG4gICAgcmV0dXJuIHRoaXMuX2FsbElucHV0TmFtZXM7XG4gIH1cblxuICBnZXRPdXRwdXRJbmRpY2VzKCk6IHJlYWRvbmx5IG51bWJlcltdIHtcbiAgICByZXR1cm4gdGhpcy5fYWxsT3V0cHV0SW5kaWNlcztcbiAgfVxuXG4gIGdldE91dHB1dE5hbWVzKCk6IHJlYWRvbmx5IHN0cmluZ1tdIHtcbiAgICByZXR1cm4gdGhpcy5fYWxsT3V0cHV0TmFtZXM7XG4gIH1cblxuICBnZXRWYWx1ZXMoKTogcmVhZG9ubHkgR3JhcGguVmFsdWVbXSB7XG4gICAgcmV0dXJuIHRoaXMuX2FsbERhdGE7XG4gIH1cblxuICBnZXROb2RlcygpOiByZWFkb25seSBHcmFwaC5Ob2RlW10ge1xuICAgIHJldHVybiB0aGlzLl9ub2RlcztcbiAgfVxuXG4gIHByaXZhdGUgYnVpbGRHcmFwaChncmFwaDogb25ueC5JR3JhcGhQcm90b3xvcnRGYnMuR3JhcGgpIHtcbiAgICAvLyBidWlsZCB0aGUgZ3JhcGggLSB3aWxsIHRocm93IGV4Y2VwdGlvbnMgaWYgc29tZXRoaW5nIGZhdGFsIGlzIGRldGVjdGVkXG4gICAgaWYgKGdyYXBoIGluc3RhbmNlb2Ygb25ueC5HcmFwaFByb3RvKSB7XG4gICAgICB0aGlzLmJ1aWxkR3JhcGhGcm9tT25ueEZvcm1hdChncmFwaCk7XG4gICAgfSBlbHNlIGlmIChncmFwaCBpbnN0YW5jZW9mIG9ydEZicy5HcmFwaCkge1xuICAgICAgdGhpcy5idWlsZEdyYXBoRnJvbU9ydEZvcm1hdChncmFwaCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0dyYXBoIHR5cGUgaXMgbm90IHN1cHBvcnRlZC4nKTtcbiAgICB9XG4gIH1cbiAgcHJpdmF0ZSBidWlsZEdyYXBoRnJvbU9ubnhGb3JtYXQoZ3JhcGg6IG9ubnguSUdyYXBoUHJvdG8pIHtcbiAgICBjb25zdCBkYXRhSW5kaWNlcyA9IG5ldyBNYXA8c3RyaW5nLCBudW1iZXI+KCk7XG4gICAgdGhpcy5fYWxsRGF0YSA9IFtdO1xuXG4gICAgdGhpcy5fYWxsSW5wdXRJbmRpY2VzID0gW107XG4gICAgdGhpcy5fYWxsSW5wdXROYW1lcyA9IFtdO1xuXG4gICAgdGhpcy5fYWxsT3V0cHV0SW5kaWNlcyA9IFtdO1xuICAgIHRoaXMuX2FsbE91dHB1dE5hbWVzID0gW107XG5cbiAgICB0aGlzLl9ub2RlcyA9IFtdO1xuXG4gICAgY29uc3Qgbm9kZXNJbmRpY2VzID0gbmV3IE1hcDxzdHJpbmcsIG51bWJlcj4oKTtcblxuICAgIC8vIHNjYW4gYWxsIGlucHV0c1xuICAgIGlmICghZ3JhcGguaW5wdXQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyBpbmZvcm1hdGlvbiBpbiBncmFwaDogaW5wdXQnKTtcbiAgICB9XG4gICAgY29uc3QgaW5wdXRWYWx1ZU5hbWVzID0gW107XG4gICAgZm9yIChjb25zdCBpIG9mIGdyYXBoLmlucHV0KSB7XG4gICAgICBpZiAoZGF0YUluZGljZXMuaGFzKGkubmFtZSEpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgZHVwbGljYXRlZCBpbnB1dCBuYW1lOiAke2kubmFtZX1gKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGN1cnJlbnRJbmRleCA9IHRoaXMuX2FsbERhdGEucHVzaChuZXcgVmFsdWUoaSkpIC0gMTtcbiAgICAgIGRhdGFJbmRpY2VzLnNldChpLm5hbWUhLCBjdXJyZW50SW5kZXgpO1xuICAgICAgaW5wdXRWYWx1ZU5hbWVzLnB1c2goaS5uYW1lISk7XG4gICAgfVxuXG4gICAgLy8gc2NhbiBhbGwgaW5pdGlhbGl6ZXJzXG4gICAgaWYgKCFncmFwaC5pbml0aWFsaXplcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIGluZm9ybWF0aW9uIGluIGdyYXBoOiBpbml0aWFsaXplcicpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGkgb2YgZ3JhcGguaW5pdGlhbGl6ZXIpIHtcbiAgICAgIGxldCBpbmRleCA9IGRhdGFJbmRpY2VzLmdldChpLm5hbWUhKTtcbiAgICAgIGlmIChpbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gbmV3IFZhbHVlKCk7XG4gICAgICAgIHZhbHVlLnR5cGUgPSB7XG4gICAgICAgICAgc2hhcGU6IHtkaW1zOiBQcm90b1V0aWwudGVuc29yRGltc0Zyb21Qcm90byhpLmRpbXMhKX0sXG4gICAgICAgICAgdGVuc29yVHlwZTogUHJvdG9VdGlsLnRlbnNvckRhdGFUeXBlRnJvbVByb3RvKGkuZGF0YVR5cGUhKVxuICAgICAgICB9O1xuICAgICAgICBpbmRleCA9IHRoaXMuX2FsbERhdGEucHVzaCh2YWx1ZSkgLSAxO1xuICAgICAgICBkYXRhSW5kaWNlcy5zZXQoaS5uYW1lISwgaW5kZXgpO1xuICAgICAgfVxuICAgICAgdGhpcy5fYWxsRGF0YVtpbmRleF0uX2Zyb20gPSAtMTtcbiAgICAgIHRoaXMuX2FsbERhdGFbaW5kZXhdLnRlbnNvciA9IFRlbnNvci5mcm9tUHJvdG8oaSk7XG4gICAgfVxuXG4gICAgLy8gZmlsdGVyIG91dCBpbnB1dCBpbmRpY2VzXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9hbGxEYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIXRoaXMuX2FsbERhdGFbaV0udGVuc29yKSB7XG4gICAgICAgIHRoaXMuX2FsbElucHV0SW5kaWNlcy5wdXNoKGkpO1xuICAgICAgICB0aGlzLl9hbGxJbnB1dE5hbWVzLnB1c2goaW5wdXRWYWx1ZU5hbWVzW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBzY2FuIGFsbCBvdXRwdXRzXG4gICAgaWYgKCFncmFwaC5vdXRwdXQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyBpbmZvcm1hdGlvbiBpbiBncmFwaDogb3V0cHV0Jyk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgaSBvZiBncmFwaC5vdXRwdXQpIHtcbiAgICAgIGlmIChkYXRhSW5kaWNlcy5oYXMoaS5uYW1lISkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBkdXBsaWNhdGVkIG91dHB1dCBuYW1lOiAke2kubmFtZX1gKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGN1cnJlbnRJbmRleCA9IHRoaXMuX2FsbERhdGEucHVzaChuZXcgVmFsdWUoaSkpIC0gMTtcbiAgICAgIGRhdGFJbmRpY2VzLnNldChpLm5hbWUhLCBjdXJyZW50SW5kZXgpO1xuICAgICAgdGhpcy5fYWxsT3V0cHV0SW5kaWNlcy5wdXNoKGN1cnJlbnRJbmRleCk7XG4gICAgICB0aGlzLl9hbGxPdXRwdXROYW1lcy5wdXNoKGkubmFtZSEpO1xuICAgIH1cblxuICAgIC8vIHNjYW4gYWxsIG5vZGVzXG4gICAgaWYgKCFncmFwaC5ub2RlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgaW5mb3JtYXRpb24gaW4gZ3JhcGg6IG5vZGUnKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBub2RlUHJvdG8gb2YgZ3JhcGgubm9kZSkge1xuICAgICAgaWYgKCFub2RlUHJvdG8ubmFtZSkge1xuICAgICAgICAvLyBhc3NpZ24gYSBuYW1lIHRvIHRoZSBub2RlIGlmIGl0IGRvZXNuJ3QgaGF2ZSBvbmVcbiAgICAgICAgZm9yIChsZXQgcGljayA9IDA7OyBwaWNrKyspIHtcbiAgICAgICAgICBjb25zdCBuYW1lID0gYHVubmFtZWRfJHtub2RlUHJvdG8ub3BUeXBlfV8ke3BpY2t9YDtcbiAgICAgICAgICBpZiAoIW5vZGVzSW5kaWNlcy5oYXMobmFtZSkpIHtcbiAgICAgICAgICAgIG5vZGVQcm90by5uYW1lID0gbmFtZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobm9kZXNJbmRpY2VzLmhhcyhub2RlUHJvdG8ubmFtZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBkdXBsaWNhdGVkIG5vZGUgbmFtZTogJHtub2RlUHJvdG8ubmFtZX1gKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGN1cnJlbnRJbmRleCA9IHRoaXMuX25vZGVzLnB1c2gobmV3IE5vZGUobm9kZVByb3RvKSkgLSAxO1xuICAgICAgbm9kZXNJbmRpY2VzLnNldChub2RlUHJvdG8ubmFtZSwgY3VycmVudEluZGV4KTtcbiAgICB9XG5cbiAgICAvLyBzY2FuIG5vZGUncyBvdXRwdXRzXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9ub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuX25vZGVzW2ldO1xuICAgICAgY29uc3Qgbm9kZVByb3RvID0gZ3JhcGgubm9kZVtpXTtcbiAgICAgIGlmICghbm9kZVByb3RvLm91dHB1dCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG1pc3Npbmcgb3V0cHV0IGZvciBub2RlOiAke25vZGVQcm90by5uYW1lfWApO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBvdXRwdXQgb2Ygbm9kZVByb3RvLm91dHB1dCkge1xuICAgICAgICBsZXQgZGF0YUluZGV4ID0gZGF0YUluZGljZXMuZ2V0KG91dHB1dCk7XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YUluZGV4ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIGRhdGFJbmRleCA9IHRoaXMuX2FsbERhdGEucHVzaChuZXcgVmFsdWUoKSkgLSAxO1xuICAgICAgICAgIGRhdGFJbmRpY2VzLnNldChvdXRwdXQsIGRhdGFJbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS5vdXRwdXRzLnB1c2goZGF0YUluZGV4KTtcblxuICAgICAgICBpZiAodGhpcy5fYWxsRGF0YVtkYXRhSW5kZXhdLl9mcm9tICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG11bHRpcGxlIG5vZGVzIG91dHB1dCB0byBvbmUgZGF0YSB2YWx1ZTogJHtkYXRhSW5kZXh9YCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYWxsRGF0YVtkYXRhSW5kZXhdLl9mcm9tID0gaTtcblxuICAgICAgICAvLyBmb3IgdGhlICdDb25zdGFudCcgb3BlcmF0b3IsIGp1c3QgY3JlYXRlIGEgbmV3IGVkZ2UgaW4gdGhlIGdyYXBoIGNvcnJlc3BvbmRpbmcgdG8gdGhlICdvdXRwdXQnIG9mIHRoZVxuICAgICAgICAvLyBvcGVyYXRvciBhbmQgaWdub3JlIHRoZSBub2RlIGZyb20gdGhlIGdyYXBoXG4gICAgICAgIGlmIChub2RlUHJvdG8ub3BUeXBlID09PSAnQ29uc3RhbnQnKSB7XG4gICAgICAgICAgaWYgKCFub2RlUHJvdG8uYXR0cmlidXRlIHx8IG5vZGVQcm90by5hdHRyaWJ1dGUubGVuZ3RoICE9PSAxIHx8ICFub2RlUHJvdG8uYXR0cmlidXRlWzBdLnQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyBhdHRyaWJ1dGVzIG9yIG1pc3NpbmcgdGVuc29yIHZhbHVlIGluIGF0dHJpYnV0ZXMgZm9yIHRoaXMgQ29uc3RhbnQgb3BlcmF0b3InKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFub2RlUHJvdG8ub3V0cHV0IHx8IG5vZGVQcm90by5vdXRwdXQubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3Npbmcgb3V0cHV0IG9yIGluY29ycmVjdCBudW1iZXIgb2Ygb3V0cHV0cyBmb3IgdGhpcyBDb25zdGFudCBvcGVyYXRvcicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBub2RlLm91dHB1dHMucG9wKCk7XG4gICAgICAgICAgbm9kZS5leGVjdXRlTm9kZSA9IGZhbHNlO1xuXG4gICAgICAgICAgdGhpcy5fYWxsRGF0YVtkYXRhSW5kZXhdLl9mcm9tID0gLTE7XG4gICAgICAgICAgdGhpcy5fYWxsRGF0YVtkYXRhSW5kZXhdLnRlbnNvciA9IFRlbnNvci5mcm9tUHJvdG8obm9kZVByb3RvLmF0dHJpYnV0ZVswXS50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHNjYW4gbm9kZSdzIGlucHV0c1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLl9ub2Rlc1tpXTtcbiAgICAgIGNvbnN0IG5vZGVQcm90byA9IGdyYXBoLm5vZGVbaV07XG5cbiAgICAgIGlmICghbm9kZVByb3RvLmlucHV0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgbWlzc2luZyBpbnB1dCBmb3Igbm9kZTogJHtub2RlUHJvdG8ubmFtZX1gKTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgaW5wdXQgb2Ygbm9kZVByb3RvLmlucHV0KSB7XG4gICAgICAgIGNvbnN0IGRhdGFJbmRleCA9IGRhdGFJbmRpY2VzLmdldChpbnB1dCk7XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YUluZGV4ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIC8vIGhhbmRsZSBleGNlcHRpb24gd2hlbiBvcHNldCA+IDkgYW5kIHJvaSAvIHNjYWxlcyBub3QgZ2l2ZW5cbiAgICAgICAgICBpZiAoaW5wdXQgPT09ICcnICYmIChub2RlUHJvdG8uaW5wdXQubGVuZ3RoID09PSAzIHx8IG5vZGVQcm90by5pbnB1dC5sZW5ndGggPT09IDQpICYmXG4gICAgICAgICAgICAgIG5vZGVQcm90by5vcFR5cGUgPT09ICdSZXNpemUnKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bnJlY29nbml6ZWQgaW5wdXQgJyR7aW5wdXR9JyBmb3Igbm9kZTogJHtub2RlUHJvdG8ubmFtZX1gKTtcbiAgICAgICAgfVxuICAgICAgICBub2RlLmlucHV0cy5wdXNoKGRhdGFJbmRleCk7XG5cbiAgICAgICAgdGhpcy5fYWxsRGF0YVtkYXRhSW5kZXhdLl90by5wdXNoKGkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcHJpdmF0ZSBidWlsZEdyYXBoRnJvbU9ydEZvcm1hdChncmFwaDogb3J0RmJzLkdyYXBoKSB7XG4gICAgY29uc3QgZGF0YUluZGljZXMgPSBuZXcgTWFwPHN0cmluZywgbnVtYmVyPigpO1xuICAgIHRoaXMuX2FsbERhdGEgPSBbXTtcblxuICAgIHRoaXMuX2FsbElucHV0SW5kaWNlcyA9IFtdO1xuICAgIHRoaXMuX2FsbElucHV0TmFtZXMgPSBbXTtcblxuICAgIHRoaXMuX2FsbE91dHB1dEluZGljZXMgPSBbXTtcbiAgICB0aGlzLl9hbGxPdXRwdXROYW1lcyA9IFtdO1xuXG4gICAgdGhpcy5fbm9kZXMgPSBbXTtcblxuICAgIGNvbnN0IG5vZGVzSW5kaWNlcyA9IG5ldyBNYXA8c3RyaW5nLCBudW1iZXI+KCk7XG5cbiAgICAvLyBzY2FuIGFsbCBpbnB1dHNcbiAgICBjb25zdCBpbnB1dFZhbHVlTmFtZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGdyYXBoLmlucHV0c0xlbmd0aCgpOyBpKyspIHtcbiAgICAgIGNvbnN0IGlucHV0TmFtZSA9IGdyYXBoLmlucHV0cyhpKTtcbiAgICAgIGlmIChkYXRhSW5kaWNlcy5oYXMoaW5wdXROYW1lKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGR1cGxpY2F0ZWQgaW5wdXQgbmFtZTogJHtpbnB1dE5hbWV9YCk7XG4gICAgICB9XG4gICAgICAvLyBGaW5kIHRoZSBpbnB1dCB0eXBlSW5mbyBmcm9tIG5vZGVhcmdzXG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGdyYXBoLm5vZGVBcmdzTGVuZ3RoKCk7IGorKykge1xuICAgICAgICBpZiAoZ3JhcGgubm9kZUFyZ3Moaik/Lm5hbWUoKSA9PT0gaW5wdXROYW1lKSB7XG4gICAgICAgICAgY29uc3QgdmFsdWUgPSBuZXcgVmFsdWUoKTtcbiAgICAgICAgICBjb25zdCB2YWx1ZVR5cGUgPSBncmFwaC5ub2RlQXJncyhqKT8udHlwZSgpPy52YWx1ZVR5cGUoKTtcbiAgICAgICAgICBpZiAodmFsdWVUeXBlICE9PSBvcnRGYnMuVHlwZUluZm9WYWx1ZS50ZW5zb3JfdHlwZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIHZhbHVlIHR5cGUgZm9yIHRoZSBub2RlQXJnLicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCB2YWx1ZUluZm8gPSBncmFwaC5ub2RlQXJncyhqKSEudHlwZSgpIS52YWx1ZShuZXcgb3J0RmJzLlRlbnNvclR5cGVBbmRTaGFwZSgpKSE7XG4gICAgICAgICAgY29uc3QgdHlwZSA9IFByb3RvVXRpbC50ZW5zb3JEYXRhVHlwZUZyb21Qcm90byh2YWx1ZUluZm8uZWxlbVR5cGUoKSk7XG4gICAgICAgICAgY29uc3Qgc2hhcGUgPSB2YWx1ZUluZm8uc2hhcGUoKSE7XG4gICAgICAgICAgY29uc3QgZGltcyA9IFtdO1xuICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgc2hhcGUuZGltTGVuZ3RoKCkhOyBrKyspIHtcbiAgICAgICAgICAgIGRpbXMucHVzaChMb25nVXRpbC5sb25nVG9OdW1iZXIoc2hhcGUuZGltKGspIS52YWx1ZSgpIS5kaW1WYWx1ZSgpISkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YWx1ZS50eXBlID0ge3NoYXBlOiB7ZGltc30sIHRlbnNvclR5cGU6IHR5cGV9O1xuICAgICAgICAgIGNvbnN0IGN1cnJlbnRJbmRleCA9IHRoaXMuX2FsbERhdGEucHVzaCh2YWx1ZSkgLSAxO1xuICAgICAgICAgIGRhdGFJbmRpY2VzLnNldChpbnB1dE5hbWUsIGN1cnJlbnRJbmRleCk7XG4gICAgICAgICAgaW5wdXRWYWx1ZU5hbWVzLnB1c2goaW5wdXROYW1lKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBjaGVjayBpbml0aWFsaXplcnNcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGdyYXBoLmluaXRpYWxpemVyc0xlbmd0aCgpOyBpKyspIHtcbiAgICAgIGNvbnN0IGluaXRpYWxpemVyID0gZ3JhcGguaW5pdGlhbGl6ZXJzKGkpITtcbiAgICAgIGxldCBpbmRleCA9IGRhdGFJbmRpY2VzLmdldChpbml0aWFsaXplci5uYW1lKCkhKTtcbiAgICAgIGlmIChpbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gbmV3IFZhbHVlKCk7XG4gICAgICAgIGNvbnN0IGRpbXMgPSBQcm90b1V0aWwudGVuc29yRGltc0Zyb21PUlRGb3JtYXQoaW5pdGlhbGl6ZXIpO1xuICAgICAgICBjb25zdCB0eXBlID0gUHJvdG9VdGlsLnRlbnNvckRhdGFUeXBlRnJvbVByb3RvKGluaXRpYWxpemVyLmRhdGFUeXBlKCkpO1xuICAgICAgICB2YWx1ZS50eXBlID0ge3NoYXBlOiB7ZGltc30sIHRlbnNvclR5cGU6IHR5cGV9O1xuICAgICAgICBpbmRleCA9IHRoaXMuX2FsbERhdGEucHVzaCh2YWx1ZSkgLSAxO1xuICAgICAgICBkYXRhSW5kaWNlcy5zZXQoaW5pdGlhbGl6ZXIubmFtZSgpISwgaW5kZXgpO1xuICAgICAgfVxuICAgICAgdGhpcy5fYWxsRGF0YVtpbmRleF0uX2Zyb20gPSAtMTtcbiAgICAgIHRoaXMuX2FsbERhdGFbaW5kZXhdLnRlbnNvciA9IFRlbnNvci5mcm9tT3J0VGVuc29yKGluaXRpYWxpemVyKTtcbiAgICB9XG5cbiAgICAvLyBmaWx0ZXIgb3V0IGlucHV0IGluZGljZXNcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2FsbERhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICghdGhpcy5fYWxsRGF0YVtpXS50ZW5zb3IpIHtcbiAgICAgICAgdGhpcy5fYWxsSW5wdXRJbmRpY2VzLnB1c2goaSk7XG4gICAgICAgIHRoaXMuX2FsbElucHV0TmFtZXMucHVzaChpbnB1dFZhbHVlTmFtZXNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHNjYW4gYWxsIG91dHB1dHNcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGdyYXBoLm91dHB1dHNMZW5ndGgoKTsgaSsrKSB7XG4gICAgICBjb25zdCBvdXRwdXROYW1lID0gZ3JhcGgub3V0cHV0cyhpKTtcbiAgICAgIGlmIChkYXRhSW5kaWNlcy5oYXMob3V0cHV0TmFtZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBkdXBsaWNhdGVkIG91dHB1dCBuYW1lOiAke291dHB1dE5hbWV9YCk7XG4gICAgICB9XG4gICAgICBjb25zdCBjdXJyZW50SW5kZXggPSB0aGlzLl9hbGxEYXRhLnB1c2gobmV3IFZhbHVlKCkpIC0gMTtcbiAgICAgIGRhdGFJbmRpY2VzLnNldChvdXRwdXROYW1lLCBjdXJyZW50SW5kZXgpO1xuICAgICAgdGhpcy5fYWxsT3V0cHV0SW5kaWNlcy5wdXNoKGN1cnJlbnRJbmRleCk7XG4gICAgICB0aGlzLl9hbGxPdXRwdXROYW1lcy5wdXNoKG91dHB1dE5hbWUpO1xuICAgIH1cblxuICAgIC8vIHNjYW4gYWxsIG5vZGVzXG4gICAgaWYgKCFncmFwaC5ub2Rlcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIGluZm9ybWF0aW9uIGluIGdyYXBoOiBub2RlJyk7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ3JhcGgubm9kZXNMZW5ndGgoKTsgaSsrKSB7XG4gICAgICBjb25zdCBub2RlUHJvdG8gPSBncmFwaC5ub2RlcyhpKTtcbiAgICAgIGxldCBuYW1lID0gbm9kZVByb3RvIS5uYW1lKCk7XG4gICAgICBpZiAoIW5hbWUpIHtcbiAgICAgICAgLy8gYXNzaWduIGEgbmFtZSB0byB0aGUgbm9kZSBpZiBpdCBkb2Vzbid0IGhhdmUgb25lXG4gICAgICAgIGZvciAobGV0IHBpY2sgPSAwOzsgcGljaysrKSB7XG4gICAgICAgICAgbmFtZSA9IGB1bm5hbWVkXyR7bm9kZVByb3RvIS5vcFR5cGUoKX1fJHtwaWNrfWA7XG4gICAgICAgICAgaWYgKCFub2Rlc0luZGljZXMuaGFzKG5hbWUpKSB7XG4gICAgICAgICAgICAvLyBhbiB1bmlxdWUgbmFtZSBpcyBmb3VuZC4gYnJlYWsuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG5vZGVzSW5kaWNlcy5oYXMobmFtZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBkdXBsaWNhdGVkIG5vZGUgbmFtZTogJHtuYW1lfWApO1xuICAgICAgfVxuICAgICAgY29uc3QgY3VycmVudEluZGV4ID0gdGhpcy5fbm9kZXMucHVzaChuZXcgTm9kZShub2RlUHJvdG8hLCBuYW1lKSkgLSAxO1xuICAgICAgbm9kZXNJbmRpY2VzLnNldChuYW1lLCBjdXJyZW50SW5kZXgpO1xuICAgIH1cblxuICAgIC8vIHNjYW4gbm9kZSdzIG91dHB1dHNcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX25vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBub2RlID0gdGhpcy5fbm9kZXNbaV07XG4gICAgICBjb25zdCBub2RlUHJvdG8gPSBncmFwaC5ub2RlcyhpKTtcbiAgICAgIGlmIChub2RlUHJvdG8gPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIG5vZGUgZXhpc3RzIGF0IGluZGV4ICR7aX1gKTtcbiAgICAgIH1cbiAgICAgIGlmIChub2RlUHJvdG8/Lm91dHB1dHNMZW5ndGgoKSA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG1pc3Npbmcgb3V0cHV0IGZvciBub2RlOiAke25vZGVQcm90by5uYW1lfWApO1xuICAgICAgfVxuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBub2RlUHJvdG8/Lm91dHB1dHNMZW5ndGgoKTsgaisrKSB7XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IG5vZGVQcm90bz8ub3V0cHV0cyhqKTtcbiAgICAgICAgbGV0IGRhdGFJbmRleCA9IGRhdGFJbmRpY2VzLmdldChvdXRwdXQpO1xuICAgICAgICBpZiAodHlwZW9mIGRhdGFJbmRleCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBkYXRhSW5kZXggPSB0aGlzLl9hbGxEYXRhLnB1c2gobmV3IFZhbHVlKCkpIC0gMTtcbiAgICAgICAgICBkYXRhSW5kaWNlcy5zZXQob3V0cHV0LCBkYXRhSW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUub3V0cHV0cy5wdXNoKGRhdGFJbmRleCk7XG5cbiAgICAgICAgaWYgKHRoaXMuX2FsbERhdGFbZGF0YUluZGV4XS5fZnJvbSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBtdWx0aXBsZSBub2RlcyBvdXRwdXQgdG8gb25lIGRhdGEgdmFsdWU6ICR7ZGF0YUluZGV4fWApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2FsbERhdGFbZGF0YUluZGV4XS5fZnJvbSA9IGk7XG5cbiAgICAgICAgLy8gZm9yIHRoZSAnQ29uc3RhbnQnIG9wZXJhdG9yLCBqdXN0IGNyZWF0ZSBhIG5ldyBlZGdlIGluIHRoZSBncmFwaCBjb3JyZXNwb25kaW5nIHRvIHRoZSAnb3V0cHV0JyBvZiB0aGVcbiAgICAgICAgLy8gb3BlcmF0b3IgYW5kIGlnbm9yZSB0aGUgbm9kZSBmcm9tIHRoZSBncmFwaFxuICAgICAgICBpZiAobm9kZVByb3RvLm9wVHlwZSgpID09PSAnQ29uc3RhbnQnKSB7XG4gICAgICAgICAgaWYgKG5vZGVQcm90by5hdHRyaWJ1dGVzTGVuZ3RoKCkgIT09IDEgfHwgIW5vZGVQcm90by5hdHRyaWJ1dGVzKDApIS50KCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyBhdHRyaWJ1dGVzIG9yIG1pc3NpbmcgdGVuc29yIHZhbHVlIGluIGF0dHJpYnV0ZXMgZm9yIHRoaXMgQ29uc3RhbnQgb3BlcmF0b3InKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG5vZGVQcm90by5vdXRwdXRzTGVuZ3RoKCkgIT09IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyBvdXRwdXQgb3IgaW5jb3JyZWN0IG51bWJlciBvZiBvdXRwdXRzIGZvciB0aGlzIENvbnN0YW50IG9wZXJhdG9yJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5vZGUub3V0cHV0cy5wb3AoKTtcbiAgICAgICAgICBub2RlLmV4ZWN1dGVOb2RlID0gZmFsc2U7XG5cbiAgICAgICAgICB0aGlzLl9hbGxEYXRhW2RhdGFJbmRleF0uX2Zyb20gPSAtMTtcbiAgICAgICAgICB0aGlzLl9hbGxEYXRhW2RhdGFJbmRleF0udGVuc29yID0gVGVuc29yLmZyb21PcnRUZW5zb3Iobm9kZVByb3RvLmF0dHJpYnV0ZXMoMCkhLnQoKSEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gc2NhbiBub2RlJ3MgaW5wdXRzXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9ub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuX25vZGVzW2ldO1xuICAgICAgY29uc3Qgbm9kZVByb3RvID0gZ3JhcGgubm9kZXMoaSkhO1xuXG4gICAgICBpZiAobm9kZVByb3RvLmlucHV0c0xlbmd0aCgpID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgbWlzc2luZyBpbnB1dCBmb3Igbm9kZTogJHtub2RlUHJvdG8ubmFtZX1gKTtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbm9kZVByb3RvLmlucHV0c0xlbmd0aCgpITsgaisrKSB7XG4gICAgICAgIGNvbnN0IGlucHV0ID0gbm9kZVByb3RvLmlucHV0cyhqKSE7XG4gICAgICAgIGNvbnN0IGRhdGFJbmRleCA9IGRhdGFJbmRpY2VzLmdldChpbnB1dCk7XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YUluZGV4ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5yZWNvZ25pemVkIGlucHV0ICcke2lucHV0fScgZm9yIG5vZGU6ICR7bm9kZVByb3RvIS5uYW1lKCl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS5pbnB1dHMucHVzaChkYXRhSW5kZXgpO1xuXG4gICAgICAgIHRoaXMuX2FsbERhdGFbZGF0YUluZGV4XS5fdG8ucHVzaChpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGNoZWNrSXNBY3ljbGljKCkge1xuICAgIC8vIGdvIHRocm91Z2ggdGhlIGdyYXBoIGFuZCBjaGVjayBmb3IgY3ljbGVzIG9yIG90aGVyIGZhdGFsIGluY29uc2lzdGVuY2llc1xuICAgIGNvbnN0IHN0YXJ0ZXJzOiBTZXQ8bnVtYmVyPiA9IG5ldyBTZXQ8bnVtYmVyPigpO1xuICAgIHRoaXMuX2FsbElucHV0SW5kaWNlcy5mb3JFYWNoKGkgPT4ge1xuICAgICAgY29uc3QgZGF0YSA9IHRoaXMuX2FsbERhdGFbaV07XG4gICAgICBkYXRhLl90by5mb3JFYWNoKGogPT4ge1xuICAgICAgICBzdGFydGVycy5hZGQoaik7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8vIEl0ZXJhdGl2ZSBERlMgdG8gY2hlY2sgZm9yIGN5Y2xlc1xuICAgIGNvbnN0IG5vZGVzU3RhY2sgPSBBcnJheS5mcm9tKHN0YXJ0ZXJzKTtcbiAgICBjb25zdCBub2Rlc1N0YXRlID0gbmV3IEFycmF5PHN0cmluZz4odGhpcy5fbm9kZXMubGVuZ3RoKS5maWxsKCd3aGl0ZScpO1xuXG4gICAgd2hpbGUgKG5vZGVzU3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgY29uc3Qgbm9kZUluZGV4ID0gbm9kZXNTdGFjay5wb3AoKSE7XG4gICAgICAvLyB0aGlzIG5vZGUgaGFzIG5vdyBiZWVuIHByb2Nlc3NlZCBjb21wbGV0ZWx5LiBNYXJrIHRoaXMgbm9kZSAnYmxhY2snIHRvIGRlbm90ZSB0aGlzLlxuICAgICAgaWYgKG5vZGVzU3RhdGVbbm9kZUluZGV4XSA9PT0gJ2dyYXknKSB7XG4gICAgICAgIG5vZGVzU3RhdGVbbm9kZUluZGV4XSA9ICdibGFjayc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB0aGlzIG5vZGUgaXMgdW5kZXIgcHJvY2Vzc2luZyBzdGFnZS4gbWFyayB0aGlzIG5vZGUgJ2dyYXknIHRvIGRlbm90ZSB0aGlzLlxuICAgICAgICBub2Rlc1N0YWNrLnB1c2gobm9kZUluZGV4KTtcbiAgICAgICAgbm9kZXNTdGF0ZVtub2RlSW5kZXhdID0gJ2dyYXknO1xuXG4gICAgICAgIHRoaXMuX25vZGVzW25vZGVJbmRleF0ub3V0cHV0cy5mb3JFYWNoKChvdXRnb2luZ0VkZ2VJbmRleCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLl9hbGxEYXRhW291dGdvaW5nRWRnZUluZGV4XTtcbiAgICAgICAgICBpZiAodHlwZW9mIGRhdGEudGVuc29yICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdub2RlIG91dHB1dHMgc2hvdWxkIG5vdCBiZSBpbml0aWFsaXplZCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZGF0YS5fZnJvbSAhPT0gbm9kZUluZGV4KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Zyb20gcHJvcGVydHkgb2YgdGhlIFZhbHVlIG9iamVjdCBkb2VzblxcJ3QgbWF0Y2ggaW5kZXggb2YgTm9kZSBiZWluZyBwcm9jZXNzZWQnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGF0YS5fdG8uZm9yRWFjaCgoZG93bnN0cmVhbU5vZGVJbmRleCkgPT4ge1xuICAgICAgICAgICAgLy8gYmFjayBlZGdlIGZvdW5kIC0gY3ljbGljXG4gICAgICAgICAgICBpZiAobm9kZXNTdGF0ZVtkb3duc3RyZWFtTm9kZUluZGV4XSA9PT0gJ2dyYXknKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbW9kZWwgZ3JhcGggaXMgY3ljbGljJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0cmVlIGVkZ2UgZm91bmQgLSBjb250aW51ZSBwcm9jZXNzaW5nIGJ5IGFkZGluZyBpdCB0byBzdGFja1xuICAgICAgICAgICAgZWxzZSBpZiAobm9kZXNTdGF0ZVtkb3duc3RyZWFtTm9kZUluZGV4XSA9PT0gJ3doaXRlJykge1xuICAgICAgICAgICAgICBub2Rlc1N0YWNrLnB1c2goZG93bnN0cmVhbU5vZGVJbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgdHJhbnNmb3JtR3JhcGgoZ3JhcGhJbml0aWFsaXplcj86IEdyYXBoLkluaXRpYWxpemVyKTogdm9pZCB7XG4gICAgLy8gYXBwbHkgY29tbW9uIHRyYW5zZm9ybVxuICAgIHRoaXMucmVtb3ZlQWxsSWRlbnRpdHlOb2RlcygpO1xuICAgIHRoaXMucmVtb3ZlQWxsRHJvcG91dE5vZGVzKCk7XG4gICAgdGhpcy5mdXNlQ29udkFjdGl2YXRpb25Ob2RlcygpO1xuICAgIC8vIGFwcGx5IGluaXRpYWxpemVyIHNwZWNpZmljIHRyYW5zZm9ybVxuICAgIGlmIChncmFwaEluaXRpYWxpemVyKSB7XG4gICAgICBncmFwaEluaXRpYWxpemVyLnRyYW5zZm9ybUdyYXBoKHRoaXMpO1xuICAgIH1cblxuICAgIC8vIGZpbmFsaXplIGdyYXBoXG4gICAgdGhpcy5maW5hbGl6ZUdyYXBoKCk7XG4gIH1cblxuICAvKipcbiAgICogZmluYWxpemUgdGhlIGdyYXBoLlxuICAgKlxuICAgKiB0aGlzIGZ1bmN0aW9uIHNob3VsZCBiZSBjYWxsZWQgYWZ0ZXIgYWxsIHRoZSB0cmFuc2Zvcm1hdGlvbiBjb21wbGV0ZWQuXG4gICAqIHRoaXMgZnVuY3Rpb24gcmVtb3ZlcyBhbGwgdW5uZWNlc3Nhcnkgbm9kZXMgYW5kIHZhbHVlcyBmcm9tIHRoZSBncmFwaFxuICAgKi9cbiAgZmluYWxpemVHcmFwaCgpIHtcbiAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICAvLyBkZWxldGUgYWxsIG5vZGVzIHRoYXQgYXJlIG5vdCBiZWluZyBleGVjdXRlZFxuICAgIC8vIFRoZSBncmFwaCBpcyByZXByZXNlbnRlZCB1c2luZyB0aGVzZSB0d28gYXJyYXlzXG4gICAgLy8gdGhpcy5fbm9kZXMgLSBBcnJheSBob2xkaW5nIHRoZSBrZXJuZWxzIHRvIGV4ZWN1dGUgLSBlYWNoIGVudHJ5IGlzIGEga2VybmVsIHBvaW50aW5nIHRvIHRoaXMuX2FsbERhdGFcbiAgICAvLyB0aGlzLl9hbGxEYXRhIC0gaG9sZCAyIGZpZWxkcyAtIHRvIFtdICYgZnJvbSAtIHRoZXNlIGZlaWxlZHMgaG9sZCB0aGUgZ3JhcGggbWFwIGZvciBpbnB1dHMgYW5kIG91dHB1dHMgcGVyIG5vZGVcbiAgICAvLyBuZXdJbmRpY2VzIC0gcmVtYXBwaW5nIHRoZSBncmFwaCBhZnRlciByZWFkaW5nIHRoZSBmbGFnICdleGVjdXRlTm9kZSdcbiAgICBjb25zdCBuZXdJbmRpY2VzID0gbmV3IEFycmF5PG51bWJlcj4odGhpcy5fbm9kZXMubGVuZ3RoLCAwKTtcbiAgICBsZXQgbm9kZVBvc3NpdGlvbiA9IDA7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX25vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyBnaXZpbmcgbmV3IGluZGV4ZXMgdG8gdGhlIG5vZGVzIGJhc2VkIG9uIGV4ZWN1dGlvbiBmbGFnXG4gICAgICBuZXdJbmRpY2VzW2ldID0gbm9kZVBvc3NpdGlvbjtcbiAgICAgIGlmICh0aGlzLl9ub2Rlc1tpXS5leGVjdXRlTm9kZSkge1xuICAgICAgICBpZiAobm9kZVBvc3NpdGlvbiAhPT0gaSkge1xuICAgICAgICAgIHRoaXMuX25vZGVzW25vZGVQb3NzaXRpb25dID0gdGhpcy5fbm9kZXNbaV07XG4gICAgICAgIH1cbiAgICAgICAgbm9kZVBvc3NpdGlvbisrO1xuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkZWxldGUgYWxsIG91dHB1dCB2YWx1ZXNcbiAgICAgICAgdGhpcy5fbm9kZXNbaV0ub3V0cHV0cy5mb3JFYWNoKGluZCA9PiB7XG4gICAgICAgICAgdGhpcy5fYWxsRGF0YVtpbmRdLl9mcm9tID0gLTI7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHJlbW92aW5nIHRoZSB1bnVzZWQgbm9kZXNcbiAgICB0aGlzLl9ub2Rlcy5zcGxpY2Uobm9kZVBvc3NpdGlvbiwgdGhpcy5fbm9kZXMubGVuZ3RoIC0gbm9kZVBvc3NpdGlvbik7XG5cbiAgICAvLyBVcGRhdGluZyB0aGlzLl9hbGxEYXRhIGFjY29yZGluZyB0byB0aGUgbmV3IHRoaXMuX25vZGVzXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9hbGxEYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjdXJyZW50RGF0YSA9IHRoaXMuX2FsbERhdGFbaV07XG4gICAgICBpZiAoY3VycmVudERhdGEuX2Zyb20gIT09IHVuZGVmaW5lZCAmJiBjdXJyZW50RGF0YS5fZnJvbSAhPT0gLTEgJiYgY3VycmVudERhdGEuX2Zyb20gIT09IC0yKSB7XG4gICAgICAgIGN1cnJlbnREYXRhLl9mcm9tID0gbmV3SW5kaWNlc1tjdXJyZW50RGF0YS5fZnJvbV07XG4gICAgICB9XG5cbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgY3VycmVudERhdGEuX3RvLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChjdXJyZW50RGF0YS5fdG9bal0gPj0gMCkge1xuICAgICAgICAgIGN1cnJlbnREYXRhLl90b1tqXSA9IG5ld0luZGljZXNbY3VycmVudERhdGEuX3RvW2pdXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyeWluZyB0byB1cGRhdGUgYSByZW1vdmVkIG5vZGUnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIG9mZnNldCA9IDA7XG4gICAgLy8gZGVsZXRlIGFsbCB2YWx1ZXMgdGhhdCBhcmUgbm90IGJlaW5nIHJlZmVyZW5jZWRcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2FsbERhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIC8vIGlmIGN1cnJlbnQgdmFsdWUgaXMgbmVpdGhlciBsaW5rZWQgdG8gbmV4dCBub2RlLCBub3IgYW4gb3V0cHV0IHZhbHVlLCByZW1vdmUgaXQuXG4gICAgICBpZiAodGhpcy5fYWxsRGF0YVtpXS5mcm9tID09PSAtMiAmJiB0aGlzLl9hbGxPdXRwdXRJbmRpY2VzLmluZGV4T2YoaSArIG9mZnNldCkgPT09IC0xKSB7XG4gICAgICAgIG9mZnNldCsrO1xuICAgICAgICB0aGlzLl9hbGxEYXRhLnNwbGljZShpLCAxKTtcbiAgICAgICAgaS0tO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChvZmZzZXQgPiAwKSB7XG4gICAgICAgIGxldCBpbmQgPSAtMTtcbiAgICAgICAgLy8gaWYgY3VycmVudCB2YWx1ZSBpcyBuZWl0aGVyIGFuIGlucHV0IHZhbHVlIG5vciBhbiBpbml0aWFsaXplciwgZmluZCB0aGUgbm9kZSBpdCdzXG4gICAgICAgIC8vIGNvbWluZyBmcm9tIGFuZCB1cGRhdGUgdGhlIGNvcnJlc3BvbmRpbmcgbm9kZSBvdXRwdXRcbiAgICAgICAgaWYgKHRoaXMuX2FsbERhdGFbaV0uZnJvbSAhPT0gdW5kZWZpbmVkICYmIHRoaXMuX2FsbERhdGFbaV0uZnJvbSAhPT0gLTEpIHtcbiAgICAgICAgICBpbmQgPSB0aGlzLl9ub2Rlc1t0aGlzLl9hbGxEYXRhW2ldLmZyb21dLm91dHB1dHMuaW5kZXhPZihpICsgb2Zmc2V0KTtcbiAgICAgICAgICBpZiAoaW5kICE9PSAtMSkge1xuICAgICAgICAgICAgdGhpcy5fbm9kZXNbdGhpcy5fYWxsRGF0YVtpXS5mcm9tXS5vdXRwdXRzW2luZF0gPSBpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBpZiBjdXJyZW50IHZhbHVlIGlzIGFuIGlucHV0IHZhbHVlLCB1cGRhdGUgaXRzIHJlZmVyZW5jZSBpbiBpbnB1dEluZGljZXNcbiAgICAgICAgICBpbmQgPSB0aGlzLl9hbGxJbnB1dEluZGljZXMuaW5kZXhPZihpICsgb2Zmc2V0KTtcbiAgICAgICAgICBpZiAoaW5kICE9PSAtMSkge1xuICAgICAgICAgICAgdGhpcy5fYWxsSW5wdXRJbmRpY2VzW2luZF0gPSBpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZpbmQgdGhlIG5vZGUgdGhhdCB0aGUgY3VycmVudCB2YWx1ZSBpcyBsaW5raW5nIHRvIGFuZCB1cGRhdGUgaXRzIGlucHV0IHJlZmVyZW5jZVxuICAgICAgICB0aGlzLl9hbGxEYXRhW2ldLnRvLmZvckVhY2gobm9kZSA9PiB7XG4gICAgICAgICAgaW5kID0gdGhpcy5fbm9kZXNbbm9kZV0uaW5wdXRzLmluZGV4T2YoaSArIG9mZnNldCk7XG4gICAgICAgICAgaWYgKGluZCAhPT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuX25vZGVzW25vZGVdLmlucHV0c1tpbmRdID0gaTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGhpcy5fYWxsRGF0YVtpXS50by5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAvLyBpZiBjdXJyZW50IHZhbHVlIGlzIGEgZ3JhcGggb3V0cHV0LCB1cGRhdGUgaXRzIHJlZmVyZW5jZSBpbiBvdXRwdXRJbmRpY2VzXG4gICAgICAgICAgaW5kID0gdGhpcy5fYWxsT3V0cHV0SW5kaWNlcy5pbmRleE9mKGkgKyBvZmZzZXQpO1xuICAgICAgICAgIGlmIChpbmQgIT09IC0xKSB7XG4gICAgICAgICAgICB0aGlzLl9hbGxPdXRwdXRJbmRpY2VzW2luZF0gPSBpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEZWxldGUgdGhlIHNwZWNpZmVkIG5vZGUuIEFzc3VtZSB0aGUgbm9kZSBoYXMgb25lIGluY29taW5nIGlucHV0IGFuZCB0aGUgZmlyc3Qgb3V0cHV0IGNvbm5lY3RlZCB0byBvdGhlciBub2Rlcy5cbiAgICogQW4gaW5wdXQgdmFsaWRhdGlvbiBtdXN0IGJlIGRvbmUgYmVmb3JlIGNhbGxpbmcgdGhpcyBmdW5jdGlvbi5cbiAgICogQHBhcmFtIG5vZGVJbmRleCBUaGUgaW5kZXggb2Ygbm9kZSB0byBiZSBkZWxldGVkXG4gICAqL1xuICBwcml2YXRlIGRlbGV0ZU5vZGUobm9kZUluZGV4OiBudW1iZXIpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5fbm9kZXNbbm9kZUluZGV4XTtcbiAgICBpZiAobm9kZS5vdXRwdXRzLmxlbmd0aCA+IDEpIHtcbiAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbm9kZS5vdXRwdXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh0aGlzLl9hbGxEYXRhW25vZGUub3V0cHV0c1tpXV0udG8ubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm9kZSBkZWxldGlvbiB3aXRoIG1vcmUgdGhhbiBvbmUgb3V0cHV0IGNvbm5lY3RlZCB0byBvdGhlciBub2RlcyBpcyBub3Qgc3VwcG9ydGVkLiAnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHRoaXMgbm9kZSB3aWwgbm90IGJlIGV4ZWN1dGVkXG4gICAgbm9kZS5leGVjdXRlTm9kZSA9IGZhbHNlO1xuICAgIGNvbnN0IGlucHV0VmFsdWVJbmRleCA9IG5vZGUuaW5wdXRzWzBdO1xuICAgIGNvbnN0IG91dHB1dFZhbHVlSW5kZXggPSBub2RlLm91dHB1dHNbMF07XG4gICAgY29uc3Qgbm9kZXNDb25zdW1pbmdPdXRwdXQgPSB0aGlzLl9hbGxEYXRhW291dHB1dFZhbHVlSW5kZXhdLnRvO1xuXG4gICAgLy8gcmVtb3ZlIHRoaXMgbm9kZSBmcm9tIHRoZSB0byBwcm9wZXJ0eSBvZiB0aGUgaW5wdXQgVmFsdWVcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUuaW5wdXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBkZWxJbmRleCA9IHRoaXMuX2FsbERhdGFbbm9kZS5pbnB1dHNbaV1dLnRvLmluZGV4T2Yobm9kZUluZGV4KTtcbiAgICAgIC8vIHNob3VsZCBub3QgaGFwcGVuXG4gICAgICBpZiAoZGVsSW5kZXggPT09IC0xKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIFZhbHVlIG9iamVjdCBkb2VzblxcJ3QgaGF2ZSB0aGUgY3VycmVudCBOb2RlIGluIGl0XFwncyBcXCd0b1xcJyBwcm9wZXJ0eSAnKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2FsbERhdGFbbm9kZS5pbnB1dHNbaV1dLnRvLnNwbGljZShkZWxJbmRleCwgMSk7XG4gICAgfVxuXG4gICAgLy8gY2xlYXIgbm9kZSBpbmRpY2VzIGNvbnN1bWluZyB0aGlzIG91dHB1dCBWYWx1ZVxuICAgIHRoaXMuX2FsbERhdGFbb3V0cHV0VmFsdWVJbmRleF0uX3RvID0gW107XG5cbiAgICAvLyBpZiB0aGUgb3V0cHV0IG9mIHRoaXMgbm9kZSBpcyBhIGdyYXBoIG91dHB1dCwgYWRqdXN0IHRoZSBpbmRleCBhcHByb3ByaWF0ZWx5XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLl9hbGxPdXRwdXRJbmRpY2VzLmluZGV4T2Yob3V0cHV0VmFsdWVJbmRleCk7XG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgdGhpcy5fYWxsT3V0cHV0SW5kaWNlc1tpbmRleF0gPSBpbnB1dFZhbHVlSW5kZXg7XG4gICAgfVxuXG4gICAgLy8gb3ZlcnJpZGUgdGhlIGlucHV0cyBmb3Igbm9kZXMgY29uc3VtaW5nIHRoaXMgbm9kZSdzIG91dHB1dCB3aXRoIHRoZSBpbnB1dCB0byB0aGlzIG5vZGVcbiAgICBpZiAobm9kZXNDb25zdW1pbmdPdXRwdXQgJiYgbm9kZXNDb25zdW1pbmdPdXRwdXQubGVuZ3RoID4gMCkge1xuICAgICAgZm9yIChjb25zdCBub2RlSW5kZXggb2Ygbm9kZXNDb25zdW1pbmdPdXRwdXQpIHtcbiAgICAgICAgY29uc3QgcmVwbGFjZUluZGV4ID0gdGhpcy5fbm9kZXNbbm9kZUluZGV4XS5pbnB1dHMuaW5kZXhPZihvdXRwdXRWYWx1ZUluZGV4KTtcbiAgICAgICAgLy8gc2hvdWxkIG5vdCBoYXBwZW5cbiAgICAgICAgaWYgKHJlcGxhY2VJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBOb2RlIG9iamVjdCBkb2VzblxcJ3QgaGF2ZSB0aGUgb3V0cHV0IFZhbHVlIGluIGl0XFwncyBcXCdpbnB1dHNcXCcgcHJvcGVydHkgJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbm9kZXNbbm9kZUluZGV4XS5pbnB1dHNbcmVwbGFjZUluZGV4XSA9IGlucHV0VmFsdWVJbmRleDtcbiAgICAgICAgdGhpcy5fYWxsRGF0YVtpbnB1dFZhbHVlSW5kZXhdLnRvLnB1c2gobm9kZUluZGV4KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZW1vdmVBbGxEcm9wb3V0Tm9kZXMoKSB7XG4gICAgbGV0IG5vZGVJbmRleCA9IDA7XG4gICAgZm9yIChjb25zdCBub2RlIG9mIHRoaXMuX25vZGVzKSB7XG4gICAgICAvLyB3ZWVkIG91dCAnRHJvcG91dCcgbm9kZXMgc28gdGhhdCBubyB0aW1lIGlzIHdhc3RlZCBpbiBleGVjdXRpb25cbiAgICAgIGlmIChub2RlLm9wVHlwZSA9PT0gJ0Ryb3BvdXQnKSB7XG4gICAgICAgIC8vIHRoZSBub2RlIHNob3VsZCBoYXZlIGV4YWN0bHkgMSBpbnB1dCBhbmQgMSBvciAyIG91dHB1dHNcbiAgICAgICAgaWYgKG5vZGUuaW5wdXRzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRHJvcG91dCBub2RlcyBzaG91bGQgb25seSBjb250YWluIG9uZSBpbnB1dC4gJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUub3V0cHV0cy5sZW5ndGggIT09IDEgJiYgbm9kZS5vdXRwdXRzLmxlbmd0aCAhPT0gMikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRHJvcG91dCBub2RlcyBzaG91bGQgY29udGFpbiBlaXRoZXIgMSBvciAyIG91dHB1dChzKScpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRoZSBzZWNvbmQgb3V0cHV0IHNob3VsZCBub3QgYmUgcmVmZXJlbmNlZCBieSBhbnkgb3RoZXIgbm9kZVxuICAgICAgICBpZiAobm9kZS5vdXRwdXRzLmxlbmd0aCA9PT0gMiAmJiB0aGlzLl9hbGxEYXRhW25vZGUub3V0cHV0c1sxXV0uX3RvLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRHJvcG91dCBub2Rlc1xcJ3Mgc2Vjb25kIG91dHB1dCBzaG91bGQgbm90IGJlIHJlZmVyZW5jZWQgYnkgb3RoZXIgbm9kZXMnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlbGV0ZU5vZGUobm9kZUluZGV4KTtcbiAgICAgIH1cbiAgICAgIG5vZGVJbmRleCsrO1xuICAgIH1cbiAgfVxuXG4gIHJlbW92ZUFsbElkZW50aXR5Tm9kZXMoKSB7XG4gICAgbGV0IG5vZGVJbmRleCA9IDA7XG4gICAgZm9yIChjb25zdCBub2RlIG9mIHRoaXMuX25vZGVzKSB7XG4gICAgICAvLyB3ZWVkIG91dCAnSWRlbnRpdHknIG5vZGVzIHNvIHRoYXQgbm8gdGltZSBpcyB3YXN0ZWQgaW4gZXhlY3V0aW9uXG4gICAgICBpZiAobm9kZS5vcFR5cGUgPT09ICdJZGVudGl0eScpIHtcbiAgICAgICAgdGhpcy5kZWxldGVOb2RlKG5vZGVJbmRleCk7XG4gICAgICB9XG4gICAgICBub2RlSW5kZXgrKztcbiAgICB9XG4gIH1cblxuICBpc0FjdGl2YXRpb24objogTm9kZSk6IGJvb2xlYW4ge1xuICAgIHN3aXRjaCAobi5vcFR5cGUpIHtcbiAgICAgIC8vIFRPRE86IGFkZCBvdGhlciBhY3RpdmF0aW9uIG1ldGhvZHNcbiAgICAgIGNhc2UgJ1JlbHUnOlxuICAgICAgY2FzZSAnU2lnbW9pZCc6XG4gICAgICBjYXNlICdDbGlwJzpcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgZnVzZUNvbnZBY3RpdmF0aW9uTm9kZXMoKSB7XG4gICAgZm9yIChjb25zdCBub2RlIG9mIHRoaXMuX25vZGVzKSB7XG4gICAgICBpZiAobm9kZS5vcFR5cGUgPT09ICdDb252Jykge1xuICAgICAgICBjb25zdCBuZXh0ID0gdGhpcy5fYWxsRGF0YVtub2RlLm91dHB1dHNbMF1dLl90bztcbiAgICAgICAgaWYgKG5leHQubGVuZ3RoID09PSAxICYmIHRoaXMuaXNBY3RpdmF0aW9uKHRoaXMuX25vZGVzW25leHRbMF1dKSkge1xuICAgICAgICAgIGNvbnN0IGNoaWxkID0gdGhpcy5fbm9kZXNbbmV4dFswXV07XG4gICAgICAgICAgaWYgKGNoaWxkLm9wVHlwZSA9PT0gJ0NsaXAnKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGQuaW5wdXRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG5vZGUuYXR0cmlidXRlcy5zZXQoXG4gICAgICAgICAgICAgICAgICAgICdhY3RpdmF0aW9uX3BhcmFtcycsICdmbG9hdHMnLFxuICAgICAgICAgICAgICAgICAgICBbY2hpbGQuYXR0cmlidXRlcy5nZXRGbG9hdCgnbWluJyksIGNoaWxkLmF0dHJpYnV0ZXMuZ2V0RmxvYXQoJ21heCcpXSk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBub2RlLmF0dHJpYnV0ZXMuc2V0KCdhY3RpdmF0aW9uX3BhcmFtcycsICdmbG9hdHMnLCBbTUlOX0NMSVAsIE1BWF9DTElQXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgICAgY2hpbGQuaW5wdXRzLmxlbmd0aCA+PSAzICYmIHRoaXMuX2FsbERhdGFbY2hpbGQuaW5wdXRzWzFdXS50ZW5zb3IgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgIHRoaXMuX2FsbERhdGFbY2hpbGQuaW5wdXRzWzJdXS50ZW5zb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBub2RlLmF0dHJpYnV0ZXMuc2V0KCdhY3RpdmF0aW9uX3BhcmFtcycsICdmbG9hdHMnLCBbXG4gICAgICAgICAgICAgICAgdGhpcy5fYWxsRGF0YVtjaGlsZC5pbnB1dHNbMV1dLnRlbnNvciEuZmxvYXREYXRhWzBdLCB0aGlzLl9hbGxEYXRhW2NoaWxkLmlucHV0c1syXV0udGVuc29yIS5mbG9hdERhdGFbMF1cbiAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBTa2lwIGZ1c2lvbiB3aXRoIGNsaXAgbm9kZSBzaW5jZSBjbGlwIG1pbiBhbmQgY2xpcCBtYXggYXJlIG5vdCBjb21pbmcgZnJvbSBpbml0aWFsaXplclxuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgbm9kZS5hdHRyaWJ1dGVzLnNldCgnYWN0aXZhdGlvbicsICdzdHJpbmcnLCAoY2hpbGQub3BUeXBlKSk7XG4gICAgICAgICAgdGhpcy5kZWxldGVOb2RlKG5leHRbMF0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7ZmxhdGJ1ZmZlcnN9IGZyb20gJ2ZsYXRidWZmZXJzJztcblxuaW1wb3J0IHtHcmFwaH0gZnJvbSAnLi9ncmFwaCc7XG5pbXBvcnQge09wU2V0fSBmcm9tICcuL29wc2V0JztcbmltcG9ydCB7b25ueHJ1bnRpbWV9IGZyb20gJy4vb3J0LXNjaGVtYS9mbGF0YnVmZmVycy9vcnQtZ2VuZXJhdGVkJztcbmltcG9ydCB7b25ueH0gZnJvbSAnLi9vcnQtc2NoZW1hL3Byb3RvYnVmL29ubngnO1xuaW1wb3J0IHtMb25nVXRpbH0gZnJvbSAnLi91dGlsJztcblxuaW1wb3J0IG9ydEZicyA9IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnM7XG5cbmV4cG9ydCBjbGFzcyBNb2RlbCB7XG4gIC8vIGVtcHR5IG1vZGVsXG4gIGNvbnN0cnVjdG9yKCkge31cblxuICBsb2FkKGJ1ZjogVWludDhBcnJheSwgZ3JhcGhJbml0aWFsaXplcj86IEdyYXBoLkluaXRpYWxpemVyLCBpc09ydEZvcm1hdD86IGJvb2xlYW4pOiB2b2lkIHtcbiAgICBsZXQgb25ueEVycm9yOiBFcnJvcnx1bmRlZmluZWQ7XG4gICAgaWYgKCFpc09ydEZvcm1hdCkge1xuICAgICAgLy8gaXNPcnRGb3JtYXQgPT09IGZhbHNlIHx8IGlzT3J0Rm9ybWF0ID09PSB1bmRlZmluZWRcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMubG9hZEZyb21Pbm54Rm9ybWF0KGJ1ZiwgZ3JhcGhJbml0aWFsaXplcik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGlzT3J0Rm9ybWF0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICAgIG9ubnhFcnJvciA9IGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHRoaXMubG9hZEZyb21PcnRGb3JtYXQoYnVmLCBncmFwaEluaXRpYWxpemVyKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoaXNPcnRGb3JtYXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgICAgLy8gVHJpZWQgYm90aCBmb3JtYXRzIGFuZCBmYWlsZWQgKHdoZW4gaXNPcnRGb3JtYXQgPT09IHVuZGVmaW5lZClcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGxvYWQgbW9kZWwgYXMgT05OWCBmb3JtYXQ6ICR7b25ueEVycm9yfVxcbmFzIE9SVCBmb3JtYXQ6ICR7ZX1gKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGxvYWRGcm9tT25ueEZvcm1hdChidWY6IFVpbnQ4QXJyYXksIGdyYXBoSW5pdGlhbGl6ZXI/OiBHcmFwaC5Jbml0aWFsaXplcik6IHZvaWQge1xuICAgIGNvbnN0IG1vZGVsUHJvdG8gPSBvbm54Lk1vZGVsUHJvdG8uZGVjb2RlKGJ1Zik7XG4gICAgY29uc3QgaXJWZXJzaW9uID0gTG9uZ1V0aWwubG9uZ1RvTnVtYmVyKG1vZGVsUHJvdG8uaXJWZXJzaW9uKTtcbiAgICBpZiAoaXJWZXJzaW9uIDwgMykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdvbmx5IHN1cHBvcnQgT05OWCBtb2RlbCB3aXRoIElSX1ZFUlNJT04+PTMnKTtcbiAgICB9XG5cbiAgICB0aGlzLl9vcHNldHMgPVxuICAgICAgICBtb2RlbFByb3RvLm9wc2V0SW1wb3J0Lm1hcChpID0+ICh7ZG9tYWluOiBpLmRvbWFpbiBhcyBzdHJpbmcsIHZlcnNpb246IExvbmdVdGlsLmxvbmdUb051bWJlcihpLnZlcnNpb24hKX0pKTtcblxuICAgIHRoaXMuX2dyYXBoID0gR3JhcGguZnJvbShtb2RlbFByb3RvLmdyYXBoISwgZ3JhcGhJbml0aWFsaXplcik7XG4gIH1cblxuICBwcml2YXRlIGxvYWRGcm9tT3J0Rm9ybWF0KGJ1ZjogVWludDhBcnJheSwgZ3JhcGhJbml0aWFsaXplcj86IEdyYXBoLkluaXRpYWxpemVyKTogdm9pZCB7XG4gICAgY29uc3QgZmIgPSBuZXcgZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlcihidWYpO1xuICAgIGNvbnN0IG9ydE1vZGVsID0gb3J0RmJzLkluZmVyZW5jZVNlc3Npb24uZ2V0Um9vdEFzSW5mZXJlbmNlU2Vzc2lvbihmYikubW9kZWwoKSE7XG4gICAgY29uc3QgaXJWZXJzaW9uID0gTG9uZ1V0aWwubG9uZ1RvTnVtYmVyKG9ydE1vZGVsLmlyVmVyc2lvbigpKTtcbiAgICBpZiAoaXJWZXJzaW9uIDwgMykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdvbmx5IHN1cHBvcnQgT05OWCBtb2RlbCB3aXRoIElSX1ZFUlNJT04+PTMnKTtcbiAgICB9XG4gICAgdGhpcy5fb3BzZXRzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvcnRNb2RlbC5vcHNldEltcG9ydExlbmd0aCgpOyBpKyspIHtcbiAgICAgIGNvbnN0IG9wc2V0SWQgPSBvcnRNb2RlbC5vcHNldEltcG9ydChpKSE7XG4gICAgICB0aGlzLl9vcHNldHMucHVzaCh7ZG9tYWluOiBvcHNldElkPy5kb21haW4oKSBhcyBzdHJpbmcsIHZlcnNpb246IExvbmdVdGlsLmxvbmdUb051bWJlcihvcHNldElkLnZlcnNpb24oKSEpfSk7XG4gICAgfVxuXG4gICAgdGhpcy5fZ3JhcGggPSBHcmFwaC5mcm9tKG9ydE1vZGVsLmdyYXBoKCkhLCBncmFwaEluaXRpYWxpemVyKTtcbiAgfVxuXG4gIHByaXZhdGUgX2dyYXBoOiBHcmFwaDtcbiAgZ2V0IGdyYXBoKCk6IEdyYXBoIHtcbiAgICByZXR1cm4gdGhpcy5fZ3JhcGg7XG4gIH1cblxuICBwcml2YXRlIF9vcHNldHM6IE9wU2V0W107XG4gIGdldCBvcHNldHMoKTogcmVhZG9ubHkgT3BTZXRbXSB7XG4gICAgcmV0dXJuIHRoaXMuX29wc2V0cztcbiAgfVxufVxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge3JlYWRGaWxlfSBmcm9tICdub2RlOmZzL3Byb21pc2VzJztcblxuaW1wb3J0IHtyZXNvbHZlQmFja2VuZCwgU2Vzc2lvbkhhbmRsZXJUeXBlfSBmcm9tICcuL2JhY2tlbmQnO1xuaW1wb3J0IHtFeGVjdXRpb25QbGFufSBmcm9tICcuL2V4ZWN1dGlvbi1wbGFuJztcbmltcG9ydCB7R3JhcGh9IGZyb20gJy4vZ3JhcGgnO1xuaW1wb3J0IHtQcm9maWxlcn0gZnJvbSAnLi9pbnN0cnVtZW50JztcbmltcG9ydCB7TW9kZWx9IGZyb20gJy4vbW9kZWwnO1xuaW1wb3J0IHtPcGVyYXRvcn0gZnJvbSAnLi9vcGVyYXRvcnMnO1xuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4vdGVuc29yJztcblxuZXhwb3J0IGRlY2xhcmUgbmFtZXNwYWNlIFNlc3Npb24ge1xuICBleHBvcnQgaW50ZXJmYWNlIENvbmZpZyB7XG4gICAgYmFja2VuZEhpbnQ/OiBzdHJpbmc7XG4gICAgcHJvZmlsZXI/OiBQcm9maWxlci5Db25maWc7XG4gIH1cblxuICBleHBvcnQgaW50ZXJmYWNlIENvbnRleHQge1xuICAgIHByb2ZpbGVyOiBSZWFkb25seTxQcm9maWxlcj47XG4gICAgZ3JhcGhJbnB1dFR5cGVzPzogVGVuc29yLkRhdGFUeXBlW107XG4gICAgZ3JhcGhJbnB1dERpbXM/OiBBcnJheTxyZWFkb25seSBudW1iZXJbXT47XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFNlc3Npb24ge1xuICBjb25zdHJ1Y3Rvcihjb25maWc6IFNlc3Npb24uQ29uZmlnID0ge30pIHtcbiAgICB0aGlzLl9pbml0aWFsaXplZCA9IGZhbHNlO1xuICAgIHRoaXMuYmFja2VuZEhpbnQgPSBjb25maWcuYmFja2VuZEhpbnQ7XG4gICAgdGhpcy5wcm9maWxlciA9IFByb2ZpbGVyLmNyZWF0ZShjb25maWcucHJvZmlsZXIpO1xuICAgIHRoaXMuY29udGV4dCA9IHtwcm9maWxlcjogdGhpcy5wcm9maWxlciwgZ3JhcGhJbnB1dFR5cGVzOiBbXSwgZ3JhcGhJbnB1dERpbXM6IFtdfTtcbiAgfVxuXG4gIGdldCBpbnB1dE5hbWVzKCk6IHJlYWRvbmx5IHN0cmluZ1tdIHtcbiAgICByZXR1cm4gdGhpcy5fbW9kZWwuZ3JhcGguZ2V0SW5wdXROYW1lcygpO1xuICB9XG4gIGdldCBvdXRwdXROYW1lcygpOiByZWFkb25seSBzdHJpbmdbXSB7XG4gICAgcmV0dXJuIHRoaXMuX21vZGVsLmdyYXBoLmdldE91dHB1dE5hbWVzKCk7XG4gIH1cblxuICBzdGFydFByb2ZpbGluZygpIHtcbiAgICB0aGlzLnByb2ZpbGVyLnN0YXJ0KCk7XG4gIH1cblxuICBlbmRQcm9maWxpbmcoKSB7XG4gICAgdGhpcy5wcm9maWxlci5zdG9wKCk7XG4gIH1cblxuICBhc3luYyBsb2FkTW9kZWwodXJpOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+O1xuICBhc3luYyBsb2FkTW9kZWwoYnVmZmVyOiBBcnJheUJ1ZmZlciwgYnl0ZU9mZnNldD86IG51bWJlciwgbGVuZ3RoPzogbnVtYmVyKTogUHJvbWlzZTx2b2lkPjtcbiAgYXN5bmMgbG9hZE1vZGVsKGJ1ZmZlcjogVWludDhBcnJheSk6IFByb21pc2U8dm9pZD47XG4gIGFzeW5jIGxvYWRNb2RlbChhcmc6IHN0cmluZ3xBcnJheUJ1ZmZlcnxVaW50OEFycmF5LCBieXRlT2Zmc2V0PzogbnVtYmVyLCBsZW5ndGg/OiBudW1iZXIpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBhd2FpdCB0aGlzLnByb2ZpbGVyLmV2ZW50KCdzZXNzaW9uJywgJ1Nlc3Npb24ubG9hZE1vZGVsJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gcmVzb2x2ZSBiYWNrZW5kIGFuZCBzZXNzaW9uIGhhbmRsZXJcbiAgICAgIGNvbnN0IGJhY2tlbmQgPSBhd2FpdCByZXNvbHZlQmFja2VuZCh0aGlzLmJhY2tlbmRIaW50KTtcbiAgICAgIHRoaXMuc2Vzc2lvbkhhbmRsZXIgPSBiYWNrZW5kLmNyZWF0ZVNlc3Npb25IYW5kbGVyKHRoaXMuY29udGV4dCk7XG5cbiAgICAgIHRoaXMuX21vZGVsID0gbmV3IE1vZGVsKCk7XG4gICAgICBpZiAodHlwZW9mIGFyZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgY29uc3QgaXNPcnRGb3JtYXQgPSBhcmcuZW5kc1dpdGgoJy5vcnQnKTtcbiAgICAgICAgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzLnZlcnNpb25zICYmIHByb2Nlc3MudmVyc2lvbnMubm9kZSkge1xuICAgICAgICAgIC8vIG5vZGVcbiAgICAgICAgICBjb25zdCBidWYgPSBhd2FpdCByZWFkRmlsZShhcmcpO1xuICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZShidWYsIGlzT3J0Rm9ybWF0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBicm93c2VyXG4gICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChhcmcpO1xuICAgICAgICAgIGNvbnN0IGJ1ZiA9IGF3YWl0IHJlc3BvbnNlLmFycmF5QnVmZmVyKCk7XG4gICAgICAgICAgdGhpcy5pbml0aWFsaXplKG5ldyBVaW50OEFycmF5KGJ1ZiksIGlzT3J0Rm9ybWF0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghQXJyYXlCdWZmZXIuaXNWaWV3KGFyZykpIHtcbiAgICAgICAgLy8gbG9hZCBtb2RlbCBmcm9tIEFycmF5QnVmZmVyXG4gICAgICAgIGNvbnN0IGFyciA9IG5ldyBVaW50OEFycmF5KGFyZywgYnl0ZU9mZnNldCB8fCAwLCBsZW5ndGggfHwgYXJnLmJ5dGVMZW5ndGgpO1xuICAgICAgICB0aGlzLmluaXRpYWxpemUoYXJyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGxvYWQgbW9kZWwgZnJvbSBVaW50OGFycmF5XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZShhcmcpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBpbml0aWFsaXplKG1vZGVsUHJvdG9CbG9iOiBVaW50OEFycmF5LCBpc09ydEZvcm1hdD86IGJvb2xlYW4pOiB2b2lkIHtcbiAgICBpZiAodGhpcy5faW5pdGlhbGl6ZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYWxyZWFkeSBpbml0aWFsaXplZCcpO1xuICAgIH1cblxuICAgIHRoaXMucHJvZmlsZXIuZXZlbnQoJ3Nlc3Npb24nLCAnU2Vzc2lvbi5pbml0aWFsaXplJywgKCkgPT4ge1xuICAgICAgLy8gbG9hZCBncmFwaFxuICAgICAgY29uc3QgZ3JhcGhJbml0aWFsaXplciA9XG4gICAgICAgICAgdGhpcy5zZXNzaW9uSGFuZGxlci50cmFuc2Zvcm1HcmFwaCA/IHRoaXMuc2Vzc2lvbkhhbmRsZXIgYXMgR3JhcGguSW5pdGlhbGl6ZXIgOiB1bmRlZmluZWQ7XG4gICAgICB0aGlzLl9tb2RlbC5sb2FkKG1vZGVsUHJvdG9CbG9iLCBncmFwaEluaXRpYWxpemVyLCBpc09ydEZvcm1hdCk7XG5cbiAgICAgIC8vIGdyYXBoIGlzIGNvbXBsZXRlbHkgaW5pdGlhbHppZWQgYXQgdGhpcyBzdGFnZSAsIGxldCB0aGUgaW50ZXJlc3RlZCBoYW5kbGVycyBrbm93XG4gICAgICBpZiAodGhpcy5zZXNzaW9uSGFuZGxlci5vbkdyYXBoSW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgdGhpcy5zZXNzaW9uSGFuZGxlci5vbkdyYXBoSW5pdGlhbGl6ZWQodGhpcy5fbW9kZWwuZ3JhcGgpO1xuICAgICAgfVxuICAgICAgLy8gaW5pdGlhbGl6ZSBlYWNoIG9wZXJhdG9yIGluIHRoZSBncmFwaFxuICAgICAgdGhpcy5pbml0aWFsaXplT3BzKHRoaXMuX21vZGVsLmdyYXBoKTtcblxuICAgICAgLy8gaW5zdGFudGlhdGUgYW4gRXhlY3V0aW9uUGxhbiBvYmplY3QgdG8gYmUgdXNlZCBieSB0aGUgU2Vzc2lvbiBvYmplY3RcbiAgICAgIHRoaXMuX2V4ZWN1dGlvblBsYW4gPSBuZXcgRXhlY3V0aW9uUGxhbih0aGlzLl9tb2RlbC5ncmFwaCwgdGhpcy5fb3BzLCB0aGlzLnByb2ZpbGVyKTtcbiAgICB9KTtcblxuICAgIHRoaXMuX2luaXRpYWxpemVkID0gdHJ1ZTtcbiAgfVxuXG4gIGFzeW5jIHJ1bihpbnB1dHM6IE1hcDxzdHJpbmcsIFRlbnNvcj58VGVuc29yW10pOiBQcm9taXNlPE1hcDxzdHJpbmcsIFRlbnNvcj4+IHtcbiAgICBpZiAoIXRoaXMuX2luaXRpYWxpemVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Nlc3Npb24gbm90IGluaXRpYWxpemVkIHlldCcpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnByb2ZpbGVyLmV2ZW50KCdzZXNzaW9uJywgJ1Nlc3Npb24ucnVuJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgaW5wdXRUZW5zb3JzID0gdGhpcy5ub3JtYWxpemVBbmRWYWxpZGF0ZUlucHV0cyhpbnB1dHMpO1xuXG4gICAgICBjb25zdCBvdXRwdXRUZW5zb3JzID0gYXdhaXQgdGhpcy5fZXhlY3V0aW9uUGxhbi5leGVjdXRlKHRoaXMuc2Vzc2lvbkhhbmRsZXIsIGlucHV0VGVuc29ycyk7XG5cbiAgICAgIHJldHVybiB0aGlzLmNyZWF0ZU91dHB1dChvdXRwdXRUZW5zb3JzKTtcbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgbm9ybWFsaXplQW5kVmFsaWRhdGVJbnB1dHMoaW5wdXRzOiBNYXA8c3RyaW5nLCBUZW5zb3I+fFRlbnNvcltdKTogVGVuc29yW10ge1xuICAgIGNvbnN0IG1vZGVsSW5wdXROYW1lcyA9IHRoaXMuX21vZGVsLmdyYXBoLmdldElucHV0TmFtZXMoKTtcblxuICAgIC8vIG5vcm1hbGl6ZSBpbnB1dHNcbiAgICAvLyBpbnB1dHM6IFRlbnNvcltdXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXRzKSkge1xuICAgICAgaWYgKGlucHV0cy5sZW5ndGggIT09IG1vZGVsSW5wdXROYW1lcy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbmNvcnJlY3QgaW5wdXQgYXJyYXkgbGVuZ3RoOiBleHBlY3RlZCAke21vZGVsSW5wdXROYW1lcy5sZW5ndGh9IGJ1dCBnb3QgJHtpbnB1dHMubGVuZ3RofWApO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBjb252ZXJ0IG1hcCB0byBhcnJheVxuICAgIC8vIGlucHV0czogTWFwPHN0cmluZywgVGVuc29yPlxuICAgIGVsc2Uge1xuICAgICAgaWYgKGlucHV0cy5zaXplICE9PSBtb2RlbElucHV0TmFtZXMubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW5jb3JyZWN0IGlucHV0IG1hcCBzaXplOiBleHBlY3RlZCAke21vZGVsSW5wdXROYW1lcy5sZW5ndGh9IGJ1dCBnb3QgJHtpbnB1dHMuc2l6ZX1gKTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgc29ydGVkSW5wdXRzID0gbmV3IEFycmF5PFRlbnNvcj4oaW5wdXRzLnNpemUpO1xuICAgICAgbGV0IHNvcnRlZElucHV0c0luZGV4ID0gMDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbW9kZWxJbnB1dE5hbWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IHRlbnNvciA9IGlucHV0cy5nZXQobW9kZWxJbnB1dE5hbWVzW2ldKTtcbiAgICAgICAgaWYgKCF0ZW5zb3IpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG1pc3NpbmcgaW5wdXQgdGVuc29yIGZvcjogJyR7bmFtZX0nYCk7XG4gICAgICAgIH1cbiAgICAgICAgc29ydGVkSW5wdXRzW3NvcnRlZElucHV0c0luZGV4KytdID0gdGVuc29yO1xuICAgICAgfVxuXG4gICAgICBpbnB1dHMgPSBzb3J0ZWRJbnB1dHM7XG4gICAgfVxuXG4gICAgLy8gdmFsaWRhdGUgZGltcyByZXF1aXJlbWVudHNcbiAgICAvLyBGaXJzdCBzZXNzaW9uIHJ1biAtIGdyYXBoIGlucHV0IGRhdGEgaXMgbm90IGNhY2hlZCBmb3IgdGhlIHNlc3Npb25cbiAgICBpZiAoIXRoaXMuY29udGV4dC5ncmFwaElucHV0VHlwZXMgfHwgdGhpcy5jb250ZXh0LmdyYXBoSW5wdXRUeXBlcy5sZW5ndGggPT09IDAgfHwgIXRoaXMuY29udGV4dC5ncmFwaElucHV0RGltcyB8fFxuICAgICAgICB0aGlzLmNvbnRleHQuZ3JhcGhJbnB1dERpbXMubGVuZ3RoID09PSAwKSB7XG4gICAgICBjb25zdCBtb2RlbElucHV0SW5kaWNlcyA9IHRoaXMuX21vZGVsLmdyYXBoLmdldElucHV0SW5kaWNlcygpO1xuICAgICAgY29uc3QgbW9kZWxWYWx1ZXMgPSB0aGlzLl9tb2RlbC5ncmFwaC5nZXRWYWx1ZXMoKTtcblxuICAgICAgY29uc3QgZ3JhcGhJbnB1dERpbXMgPSBuZXcgQXJyYXk8cmVhZG9ubHkgbnVtYmVyW10+KG1vZGVsSW5wdXRJbmRpY2VzLmxlbmd0aCk7XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbW9kZWxJbnB1dEluZGljZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3QgZ3JhcGhJbnB1dCA9IG1vZGVsVmFsdWVzW21vZGVsSW5wdXRJbmRpY2VzW2ldXTtcbiAgICAgICAgZ3JhcGhJbnB1dERpbXNbaV0gPSBncmFwaElucHV0LnR5cGUhLnNoYXBlLmRpbXM7XG5cbiAgICAgICAgLy8gY2FjaGVkIGZvciBzZWNvbmQgYW5kIHN1YnNlcXVlbnQgcnVucy5cbiAgICAgICAgLy8gU29tZSBwYXJ0cyBvZiB0aGUgZnJhbWV3b3JrIHdvcmtzIG9uIHRoZSBhc3N1bXB0aW9uIHRoYXQgdGhlIGdyYXBoIGFuZCB0eXBlcyBhbmQgc2hhcGVzIGFyZSBzdGF0aWNcbiAgICAgICAgdGhpcy5jb250ZXh0LmdyYXBoSW5wdXRUeXBlcyEucHVzaChncmFwaElucHV0LnR5cGUhLnRlbnNvclR5cGUpO1xuICAgICAgICB0aGlzLmNvbnRleHQuZ3JhcGhJbnB1dERpbXMhLnB1c2goaW5wdXRzW2ldLmRpbXMpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnZhbGlkYXRlSW5wdXRUZW5zb3JEaW1zKGdyYXBoSW5wdXREaW1zLCBpbnB1dHMsIHRydWUpO1xuICAgIH1cblxuICAgIC8vIFNlY29uZCBhbmQgc3Vic2VxdWVudCBzZXNzaW9uIHJ1bnMgLSBncmFwaCBpbnB1dCBkYXRhIGlzIGNhY2hlZCBmb3IgdGhlIHNlc3Npb25cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMudmFsaWRhdGVJbnB1dFRlbnNvckRpbXModGhpcy5jb250ZXh0LmdyYXBoSW5wdXREaW1zLCBpbnB1dHMsIGZhbHNlKTtcbiAgICB9XG5cbiAgICAvLyB2YWxpZGF0ZSB0eXBlcyByZXF1aXJlbWVudFxuICAgIHRoaXMudmFsaWRhdGVJbnB1dFRlbnNvclR5cGVzKHRoaXMuY29udGV4dC5ncmFwaElucHV0VHlwZXMhLCBpbnB1dHMpO1xuXG4gICAgcmV0dXJuIGlucHV0cztcbiAgfVxuXG4gIHByaXZhdGUgdmFsaWRhdGVJbnB1dFRlbnNvclR5cGVzKGdyYXBoSW5wdXRUeXBlczogVGVuc29yLkRhdGFUeXBlW10sIGdpdmVuSW5wdXRzOiBUZW5zb3JbXSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ2l2ZW5JbnB1dHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGV4cGVjdGVkVHlwZSA9IGdyYXBoSW5wdXRUeXBlc1tpXTtcbiAgICAgIGNvbnN0IGFjdHVhbFR5cGUgPSBnaXZlbklucHV0c1tpXS50eXBlO1xuICAgICAgaWYgKGV4cGVjdGVkVHlwZSAhPT0gYWN0dWFsVHlwZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGlucHV0IHRlbnNvclske2l9XSBjaGVjayBmYWlsZWQ6IGV4cGVjdGVkIHR5cGUgJyR7ZXhwZWN0ZWRUeXBlfScgYnV0IGdvdCAke2FjdHVhbFR5cGV9YCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSB2YWxpZGF0ZUlucHV0VGVuc29yRGltcyhcbiAgICAgIGdyYXBoSW5wdXREaW1zOiBBcnJheTxyZWFkb25seSBudW1iZXJbXT4sIGdpdmVuSW5wdXRzOiBUZW5zb3JbXSwgbm9uZURpbVN1cHBvcnRlZDogYm9vbGVhbikge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ2l2ZW5JbnB1dHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGV4cGVjdGVkRGltcyA9IGdyYXBoSW5wdXREaW1zW2ldO1xuICAgICAgY29uc3QgYWN0dWFsRGltcyA9IGdpdmVuSW5wdXRzW2ldLmRpbXM7XG4gICAgICBpZiAoIXRoaXMuY29tcGFyZVRlbnNvckRpbXMoZXhwZWN0ZWREaW1zLCBhY3R1YWxEaW1zLCBub25lRGltU3VwcG9ydGVkKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGlucHV0IHRlbnNvclske2l9XSBjaGVjayBmYWlsZWQ6IGV4cGVjdGVkIHNoYXBlICdbJHtleHBlY3RlZERpbXMuam9pbignLCcpfV0nIGJ1dCBnb3QgWyR7XG4gICAgICAgICAgICBhY3R1YWxEaW1zLmpvaW4oJywnKX1dYCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBjb21wYXJlVGVuc29yRGltcyhleHBlY3RlZERpbXM6IHJlYWRvbmx5IG51bWJlcltdLCBhY3R1YWxEaW1zOiByZWFkb25seSBudW1iZXJbXSwgbm9uZURpbVN1cHBvcnRlZDogYm9vbGVhbik6XG4gICAgICBib29sZWFuIHtcbiAgICBpZiAoZXhwZWN0ZWREaW1zLmxlbmd0aCAhPT0gYWN0dWFsRGltcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGV4cGVjdGVkRGltcy5sZW5ndGg7ICsraSkge1xuICAgICAgaWYgKGV4cGVjdGVkRGltc1tpXSAhPT0gYWN0dWFsRGltc1tpXSAmJiAoIW5vbmVEaW1TdXBwb3J0ZWQgfHwgZXhwZWN0ZWREaW1zW2ldICE9PSAwKSAmJiBleHBlY3RlZERpbXNbaV0gIT09IG51bGwpIHtcbiAgICAgICAgLy8gZGF0YSBzaGFwZSBtaXMtbWF0Y2ggQU5EIG5vdCBhICdOb25lJyBkaW1lbnNpb24uXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHByaXZhdGUgY3JlYXRlT3V0cHV0KG91dHB1dFRlbnNvcnM6IFRlbnNvcltdKTogTWFwPHN0cmluZywgVGVuc29yPiB7XG4gICAgY29uc3QgbW9kZWxPdXRwdXROYW1lcyA9IHRoaXMuX21vZGVsLmdyYXBoLmdldE91dHB1dE5hbWVzKCk7XG4gICAgaWYgKG91dHB1dFRlbnNvcnMubGVuZ3RoICE9PSBtb2RlbE91dHB1dE5hbWVzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBlY3RlZCBudW1iZXIgb2Ygb3V0cHV0cyBkbyBub3QgbWF0Y2ggbnVtYmVyIG9mIGdlbmVyYXRlZCBvdXRwdXRzJyk7XG4gICAgfVxuXG4gICAgY29uc3Qgb3V0cHV0ID0gbmV3IE1hcDxzdHJpbmcsIFRlbnNvcj4oKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1vZGVsT3V0cHV0TmFtZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIG91dHB1dC5zZXQobW9kZWxPdXRwdXROYW1lc1tpXSwgb3V0cHV0VGVuc29yc1tpXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfVxuXG4gIHByaXZhdGUgaW5pdGlhbGl6ZU9wcyhncmFwaDogR3JhcGgpOiB2b2lkIHtcbiAgICBjb25zdCBub2RlcyA9IGdyYXBoLmdldE5vZGVzKCk7XG4gICAgdGhpcy5fb3BzID0gbmV3IEFycmF5KG5vZGVzLmxlbmd0aCk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLl9vcHNbaV0gPSB0aGlzLnNlc3Npb25IYW5kbGVyLnJlc29sdmUobm9kZXNbaV0sIHRoaXMuX21vZGVsLm9wc2V0cywgZ3JhcGgpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgX21vZGVsOiBNb2RlbDtcbiAgcHJpdmF0ZSBfaW5pdGlhbGl6ZWQ6IGJvb2xlYW47XG5cbiAgcHJpdmF0ZSBfb3BzOiBPcGVyYXRvcltdO1xuICBwcml2YXRlIF9leGVjdXRpb25QbGFuOiBFeGVjdXRpb25QbGFuO1xuXG4gIHByaXZhdGUgYmFja2VuZEhpbnQ/OiBzdHJpbmc7XG5cbiAgcHJpdmF0ZSBzZXNzaW9uSGFuZGxlcjogU2Vzc2lvbkhhbmRsZXJUeXBlO1xuICBwcml2YXRlIGNvbnRleHQ6IFNlc3Npb24uQ29udGV4dDtcbiAgcHJpdmF0ZSBwcm9maWxlcjogUmVhZG9ubHk8UHJvZmlsZXI+O1xufVxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0luZmVyZW5jZVNlc3Npb24sIEluZmVyZW5jZVNlc3Npb25IYW5kbGVyLCBTZXNzaW9uSGFuZGxlciwgVGVuc29yfSBmcm9tICdvbm54cnVudGltZS1jb21tb24nO1xuXG5pbXBvcnQge1Nlc3Npb259IGZyb20gJy4vc2Vzc2lvbic7XG5pbXBvcnQge1RlbnNvciBhcyBPbm54anNUZW5zb3J9IGZyb20gJy4vdGVuc29yJztcblxuZXhwb3J0IGNsYXNzIE9ubnhqc1Nlc3Npb25IYW5kbGVyIGltcGxlbWVudHMgSW5mZXJlbmNlU2Vzc2lvbkhhbmRsZXIge1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHNlc3Npb246IFNlc3Npb24pIHtcbiAgICB0aGlzLmlucHV0TmFtZXMgPSB0aGlzLnNlc3Npb24uaW5wdXROYW1lcztcbiAgICB0aGlzLm91dHB1dE5hbWVzID0gdGhpcy5zZXNzaW9uLm91dHB1dE5hbWVzO1xuICB9XG5cbiAgYXN5bmMgZGlzcG9zZSgpOiBQcm9taXNlPHZvaWQ+IHt9XG4gIGlucHV0TmFtZXM6IHJlYWRvbmx5IHN0cmluZ1tdO1xuICBvdXRwdXROYW1lczogcmVhZG9ubHkgc3RyaW5nW107XG4gIGFzeW5jIHJ1bihcbiAgICAgIGZlZWRzOiBTZXNzaW9uSGFuZGxlci5GZWVkc1R5cGUsIF9mZXRjaGVzOiBTZXNzaW9uSGFuZGxlci5GZXRjaGVzVHlwZSxcbiAgICAgIF9vcHRpb25zOiBJbmZlcmVuY2VTZXNzaW9uLlJ1bk9wdGlvbnMpOiBQcm9taXNlPFNlc3Npb25IYW5kbGVyLlJldHVyblR5cGU+IHtcbiAgICBjb25zdCBpbnB1dE1hcCA9IG5ldyBNYXA8c3RyaW5nLCBPbm54anNUZW5zb3I+KCk7XG4gICAgZm9yIChjb25zdCBuYW1lIGluIGZlZWRzKSB7XG4gICAgICBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoZmVlZHMsIG5hbWUpKSB7XG4gICAgICAgIGNvbnN0IGZlZWQgPSBmZWVkc1tuYW1lXTtcbiAgICAgICAgaW5wdXRNYXAuc2V0KFxuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIG5ldyBPbm54anNUZW5zb3IoXG4gICAgICAgICAgICAgICAgZmVlZC5kaW1zLCBmZWVkLnR5cGUgYXMgT25ueGpzVGVuc29yLkRhdGFUeXBlLCB1bmRlZmluZWQsIHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBmZWVkLmRhdGEgYXMgT25ueGpzVGVuc29yLk51bWJlclR5cGUpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgb3V0cHV0TWFwID0gYXdhaXQgdGhpcy5zZXNzaW9uLnJ1bihpbnB1dE1hcCk7XG4gICAgY29uc3Qgb3V0cHV0OiBTZXNzaW9uSGFuZGxlci5SZXR1cm5UeXBlID0ge307XG4gICAgb3V0cHV0TWFwLmZvckVhY2goKHRlbnNvciwgbmFtZSkgPT4ge1xuICAgICAgb3V0cHV0W25hbWVdID0gbmV3IFRlbnNvcih0ZW5zb3IudHlwZSwgdGVuc29yLmRhdGEsIHRlbnNvci5kaW1zKTtcbiAgICB9KTtcbiAgICByZXR1cm4gb3V0cHV0O1xuICB9XG4gIHN0YXJ0UHJvZmlsaW5nKCk6IHZvaWQge1xuICAgIHRoaXMuc2Vzc2lvbi5zdGFydFByb2ZpbGluZygpO1xuICB9XG4gIGVuZFByb2ZpbGluZygpOiB2b2lkIHtcbiAgICB0aGlzLnNlc3Npb24uZW5kUHJvZmlsaW5nKCk7XG4gIH1cbn1cbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuLyogZXNsaW50LWRpc2FibGUgaW1wb3J0L25vLWludGVybmFsLW1vZHVsZXMgKi9cbmltcG9ydCB7QmFja2VuZCwgSW5mZXJlbmNlU2Vzc2lvbiwgSW5mZXJlbmNlU2Vzc2lvbkhhbmRsZXJ9IGZyb20gJ29ubnhydW50aW1lLWNvbW1vbic7XG5cbmltcG9ydCB7U2Vzc2lvbn0gZnJvbSAnLi9vbm54anMvc2Vzc2lvbic7XG5pbXBvcnQge09ubnhqc1Nlc3Npb25IYW5kbGVyfSBmcm9tICcuL29ubnhqcy9zZXNzaW9uLWhhbmRsZXItaW5mZXJlbmNlJztcblxuY2xhc3MgT25ueGpzQmFja2VuZCBpbXBsZW1lbnRzIEJhY2tlbmQge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWVtcHR5LWZ1bmN0aW9uXG4gIGFzeW5jIGluaXQoKTogUHJvbWlzZTx2b2lkPiB7fVxuXG4gIGFzeW5jIGNyZWF0ZUluZmVyZW5jZVNlc3Npb25IYW5kbGVyKHBhdGhPckJ1ZmZlcjogc3RyaW5nfFVpbnQ4QXJyYXksIG9wdGlvbnM/OiBJbmZlcmVuY2VTZXNzaW9uLlNlc3Npb25PcHRpb25zKTpcbiAgICAgIFByb21pc2U8SW5mZXJlbmNlU2Vzc2lvbkhhbmRsZXI+IHtcbiAgICAvLyBOT1RFOiBTZXNzaW9uLkNvbmZpZyhmcm9tIG9ubnguanMpIGlzIG5vdCBjb21wYXRpYmxlIHdpdGggSW5mZXJlbmNlU2Vzc2lvbi5TZXNzaW9uT3B0aW9ucyhmcm9tXG4gICAgLy8gb25ueHJ1bnRpbWUtY29tbW9uKS5cbiAgICAvLyAgICAgICBJbiBmdXR1cmUgd2Ugc2hvdWxkIHJlbW92ZSBTZXNzaW9uLkNvbmZpZyBhbmQgdXNlIEluZmVyZW5jZVNlc3Npb24uU2Vzc2lvbk9wdGlvbnMuXG4gICAgLy8gICAgICAgQ3VycmVudGx5IHdlIGFsbG93IHRoaXMgdG8gaGFwcGVuIHRvIG1ha2UgdGVzdCBydW5uZXIgd29yay5cbiAgICBjb25zdCBzZXNzaW9uID0gbmV3IFNlc3Npb24ob3B0aW9ucyBhcyB1bmtub3duIGFzIFNlc3Npb24uQ29uZmlnKTtcblxuICAgIC8vIHR5cGVzY3JpcHQgY2Fubm90IG1lcmdlIG1ldGhvZCBvdmVycmlkZSBjb3JyZWN0bHkgKHNvIGZhciBpbiA0LjIuMykuIG5lZWQgaWYtZWxzZSB0byBjYWxsIHRoZSBtZXRob2QuXG4gICAgaWYgKHR5cGVvZiBwYXRoT3JCdWZmZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICBhd2FpdCBzZXNzaW9uLmxvYWRNb2RlbChwYXRoT3JCdWZmZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhd2FpdCBzZXNzaW9uLmxvYWRNb2RlbChwYXRoT3JCdWZmZXIpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgT25ueGpzU2Vzc2lvbkhhbmRsZXIoc2Vzc2lvbik7XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IG9ubnhqc0JhY2tlbmQgPSBuZXcgT25ueGpzQmFja2VuZCgpO1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdmFyLXJlcXVpcmVzLCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tcmVxdWlyZS1pbXBvcnRzICovXG4vLyBXZSB1c2UgXCJyZXF1aXJlXCIgaW5zdGVhZCBvZiBcImltcG9ydFwiIGhlcmUgYmVjYXVzZSBpbXBvcnQgc3RhdGVtZW50IG11c3QgYmUgcHV0IGluIHRvcCBsZXZlbC4gT3VyIGN1cnJlbnQgY29kZSBkb2VzXG4vLyBub3QgYWxsb3cgYnVuZGxlciB0byB0cmVlLXNoYWtpbmcgY29kZSBhcyBleHBlY3RlZCBiZWNhdXNlIHNvbWUgY29kZXMgYXJlIHRyZWF0ZWQgYXMgaGF2aW5nIHNpZGUgZWZmZWN0cy5cbi8vIFNvIHdlIGltcG9ydCBjb2RlIGluc2lkZSB0aGUgaWYtY2xhdXNlIHRvIGFsbG93IGJ1bmRsZXIgcmVtb3ZlIHRoZSBjb2RlIHNhZmVseS5cblxuZXhwb3J0ICogZnJvbSAnb25ueHJ1bnRpbWUtY29tbW9uJztcbmltcG9ydCAqIGFzIG9ydCBmcm9tICdvbm54cnVudGltZS1jb21tb24nO1xuZXhwb3J0IGRlZmF1bHQgb3J0O1xuXG5pbXBvcnQge3JlZ2lzdGVyQmFja2VuZCwgZW52fSBmcm9tICdvbm54cnVudGltZS1jb21tb24nO1xuaW1wb3J0IHt2ZXJzaW9ufSBmcm9tICcuL3ZlcnNpb24nO1xuXG5pZiAoIUJVSUxEX0RFRlMuRElTQUJMRV9XRUJHTCkge1xuICBjb25zdCBvbm54anNCYWNrZW5kID0gcmVxdWlyZSgnLi9iYWNrZW5kLW9ubnhqcycpLm9ubnhqc0JhY2tlbmQ7XG4gIHJlZ2lzdGVyQmFja2VuZCgnd2ViZ2wnLCBvbm54anNCYWNrZW5kLCAtMTApO1xufVxuXG5pZiAoIUJVSUxEX0RFRlMuRElTQUJMRV9XQVNNKSB7XG4gIGNvbnN0IHdhc21CYWNrZW5kID0gQlVJTERfREVGUy5ESVNBQkxFX1RSQUlOSU5HID8gcmVxdWlyZSgnLi9iYWNrZW5kLXdhc20taW5mZXJlbmNlJykud2FzbUJhY2tlbmQgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmUoJy4vYmFja2VuZC13YXNtLXRyYWluaW5nJykud2FzbUJhY2tlbmQ7XG4gIGlmICghQlVJTERfREVGUy5ESVNBQkxFX1dFQkdQVSkge1xuICAgIHJlZ2lzdGVyQmFja2VuZCgnd2ViZ3B1Jywgd2FzbUJhY2tlbmQsIDUpO1xuICAgIHJlZ2lzdGVyQmFja2VuZCgnd2Vibm4nLCB3YXNtQmFja2VuZCwgNSk7XG4gIH1cbiAgcmVnaXN0ZXJCYWNrZW5kKCdjcHUnLCB3YXNtQmFja2VuZCwgMTApO1xuICByZWdpc3RlckJhY2tlbmQoJ3dhc20nLCB3YXNtQmFja2VuZCwgMTApO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZW52LnZlcnNpb25zLCAnd2ViJywge3ZhbHVlOiB2ZXJzaW9uLCBlbnVtZXJhYmxlOiB0cnVlfSk7XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbi8vIFRoaXMgZmlsZSBpcyBnZW5lcmF0ZWQgYnkgL2pzL3NjcmlwdHMvdXBkYXRlLXZlcnNpb24udHNcbi8vIERvIG5vdCBtb2RpZnkgZmlsZSBjb250ZW50IG1hbnVhbGx5LlxuXG5leHBvcnQgY29uc3QgdmVyc2lvbiA9ICcxLjE4LjAnO1xuIl0sCiAgIm1hcHBpbmdzIjogIjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLElBZ0JNLFVBQ0EsMEJBWU8saUJBd0NQLGdDQXdDTztBQTdHYjs7O0FBZ0JBLElBQU0sV0FBcUMsb0JBQUksSUFBRztBQUNsRCxJQUFNLDJCQUFxQyxDQUFBO0FBWXBDLElBQU0sa0JBQWtCLENBQUNBLE9BQWNDLFVBQWtCLGFBQTBCO0FBQ3hGLFVBQUlBLFlBQVcsT0FBT0EsU0FBUSxTQUFTLGNBQWMsT0FBT0EsU0FBUSxrQ0FBa0MsWUFBWTtBQUNoSCxjQUFNLGlCQUFpQixTQUFTLElBQUlELEtBQUk7QUFDeEMsWUFBSSxtQkFBbUIsUUFBVztBQUNoQyxtQkFBUyxJQUFJQSxPQUFNLEVBQUMsU0FBQUMsVUFBUyxTQUFRLENBQUM7bUJBQzdCLGVBQWUsV0FBVyxVQUFVO0FBRTdDO21CQUNTLGVBQWUsYUFBYSxVQUFVO0FBQy9DLGNBQUksZUFBZSxZQUFZQSxVQUFTO0FBQ3RDLGtCQUFNLElBQUksTUFBTSw0QkFBNEJELEtBQUksb0JBQW9CLFFBQVEsRUFBRTs7O0FBSWxGLFlBQUksWUFBWSxHQUFHO0FBQ2pCLGdCQUFNLElBQUkseUJBQXlCLFFBQVFBLEtBQUk7QUFDL0MsY0FBSSxNQUFNLElBQUk7QUFDWixxQ0FBeUIsT0FBTyxHQUFHLENBQUM7O0FBR3RDLG1CQUFTRSxLQUFJLEdBQUdBLEtBQUkseUJBQXlCLFFBQVFBLE1BQUs7QUFDeEQsZ0JBQUksU0FBUyxJQUFJLHlCQUF5QkEsRUFBQyxDQUFDLEVBQUcsWUFBWSxVQUFVO0FBQ25FLHVDQUF5QixPQUFPQSxJQUFHLEdBQUdGLEtBQUk7QUFDMUM7OztBQUdKLG1DQUF5QixLQUFLQSxLQUFJOztBQUVwQzs7QUFHRixZQUFNLElBQUksVUFBVSxxQkFBcUI7SUFDM0M7QUFRQSxJQUFNLGlDQUFpQyxPQUFNLGdCQUFnRDtBQUMzRixZQUFNLGNBQWMsU0FBUyxJQUFJLFdBQVc7QUFDNUMsVUFBSSxDQUFDLGFBQWE7QUFDaEIsZUFBTzs7QUFHVCxVQUFJLFlBQVksYUFBYTtBQUMzQixlQUFPLFlBQVk7aUJBQ1YsWUFBWSxTQUFTO0FBQzlCLGVBQU8sWUFBWTthQUNkO0FBQ0wsY0FBTSxpQkFBaUIsQ0FBQyxDQUFDLFlBQVk7QUFDckMsWUFBSTtBQUNGLGNBQUksQ0FBQyxnQkFBZ0I7QUFDbkIsd0JBQVksY0FBYyxZQUFZLFFBQVEsS0FBSyxXQUFXOztBQUVoRSxnQkFBTSxZQUFZO0FBQ2xCLHNCQUFZLGNBQWM7QUFDMUIsaUJBQU8sWUFBWTtpQkFDWixHQUFHO0FBQ1YsY0FBSSxDQUFDLGdCQUFnQjtBQUNuQix3QkFBWSxRQUFRLEdBQUcsQ0FBQztBQUN4Qix3QkFBWSxVQUFVOztBQUV4QixpQkFBTyxZQUFZOztBQUVuQixpQkFBTyxZQUFZOzs7SUFHekI7QUFXTyxJQUFNLHNDQUFzQyxPQUFNLFlBQ21CO0FBRXRFLFlBQU0sTUFBTSxRQUFRLHNCQUFzQixDQUFBO0FBQzFDLFlBQU0sZUFBZSxJQUFJLElBQUksT0FBSyxPQUFPLE1BQU0sV0FBVyxJQUFJLEVBQUUsSUFBSTtBQUNwRSxZQUFNLGVBQWUsYUFBYSxXQUFXLElBQUksMkJBQTJCO0FBRzVFLFVBQUlDO0FBQ0osWUFBTSxTQUFTLENBQUE7QUFDZixZQUFNLHdCQUF3QixvQkFBSSxJQUFHO0FBQ3JDLGlCQUFXLGVBQWUsY0FBYztBQUN0QyxjQUFNLGdCQUFnQixNQUFNLCtCQUErQixXQUFXO0FBQ3RFLFlBQUksT0FBTyxrQkFBa0IsVUFBVTtBQUNyQyxpQkFBTyxLQUFLLEVBQUMsTUFBTSxhQUFhLEtBQUssY0FBYSxDQUFDO2VBQzlDO0FBQ0wsY0FBSSxDQUFDQSxVQUFTO0FBQ1osWUFBQUEsV0FBVTs7QUFFWixjQUFJQSxhQUFZLGVBQWU7QUFDN0Isa0NBQXNCLElBQUksV0FBVzs7OztBQU0zQyxVQUFJLENBQUNBLFVBQVM7QUFDWixjQUFNLElBQUksTUFBTSxvQ0FBb0MsT0FBTyxJQUFJLE9BQUssSUFBSSxFQUFFLElBQUksS0FBSyxFQUFFLEdBQUcsRUFBRSxFQUFFLEtBQUssSUFBSSxDQUFDLEVBQUU7O0FBSTFHLGlCQUFXLEVBQUMsTUFBQUQsT0FBTSxJQUFHLEtBQUssUUFBUTtBQUNoQyxZQUFJLGFBQWEsU0FBU0EsS0FBSSxHQUFHO0FBRS9CLGtCQUFRLEtBQUssMENBQ1RBLEtBQUksdURBQXVELEdBQUcsRUFBRTs7O0FBSXhFLFlBQU0sY0FBYyxJQUFJLE9BQU8sT0FBSyxzQkFBc0IsSUFBSSxPQUFPLE1BQU0sV0FBVyxJQUFJLEVBQUUsSUFBSSxDQUFDO0FBRWpHLGFBQU87UUFDTEM7UUFBUyxJQUFJLE1BQU0sU0FBUztVQUMxQixLQUFLLENBQUMsUUFBUSxTQUFRO0FBQ3BCLGdCQUFJLFNBQVMsc0JBQXNCO0FBQ2pDLHFCQUFPOztBQUVULG1CQUFPLFFBQVEsSUFBSSxRQUFRLElBQUk7VUFDakM7U0FDRDs7SUFFTDs7Ozs7QUNoS0o7OztBQW9GQTs7Ozs7QUNwRkEsSUFNYTtBQU5iOzs7QUFNTyxJQUFNLFVBQVU7Ozs7O0FDTnZCLElBUUksZUFFUztBQVZiOzs7QUFJQTtBQUlBLElBQUksZ0JBQXdDO0FBRXJDLElBQU0sTUFBVztNQUN0QixNQUFNLENBQUE7TUFDTixPQUFPLENBQUE7TUFDUCxRQUFRLENBQUE7TUFDUixVQUFVLEVBQUMsUUFBUSxRQUFPO01BRTFCLElBQUksU0FBUyxPQUFtQjtBQUM5QixZQUFJLFVBQVUsUUFBVztBQUN2Qjs7QUFFRixZQUFJLE9BQU8sVUFBVSxZQUFZLENBQUMsV0FBVyxRQUFRLFdBQVcsU0FBUyxPQUFPLEVBQUUsUUFBUSxLQUFLLE1BQU0sSUFBSTtBQUN2RyxnQkFBTSxJQUFJLE1BQU0sOEJBQThCLEtBQUssRUFBRTs7QUFFdkQsd0JBQWdCO01BQ2xCO01BQ0EsSUFBSSxXQUFRO0FBQ1YsZUFBTztNQUNUOztBQUlGLFdBQU8sZUFBZSxLQUFLLFlBQVksRUFBQyxZQUFZLEtBQUksQ0FBQzs7Ozs7QUMvQnpELElBZ1FhRTtBQWhRYjs7O0FBR0E7QUE2UE8sSUFBTUEsT0FBVzs7Ozs7QUNoUXhCLElBU2EsaUJBK0ZBO0FBeEdiOzs7QUFTTyxJQUFNLGtCQUFrQixDQUFDLFFBQWdCLFlBQTRDO0FBQzFGLFlBQU0sU0FBUyxPQUFPLGFBQWEsY0FBYyxTQUFTLGNBQWMsUUFBUSxJQUFLLElBQUksZ0JBQWdCLEdBQUcsQ0FBQztBQUM3RyxhQUFPLFFBQVEsT0FBTyxLQUFLLENBQUM7QUFDNUIsYUFBTyxTQUFTLE9BQU8sS0FBSyxDQUFDO0FBQzdCLFlBQU0sa0JBQ0YsT0FBTyxXQUFXLElBQUk7QUFFMUIsVUFBSSxtQkFBbUIsTUFBTTtBQUUzQixZQUFJO0FBQ0osWUFBSTtBQUNKLFlBQUksU0FBUyxpQkFBaUIsVUFBYSxRQUFRLGlCQUFpQixRQUFRO0FBQzFFLGtCQUFRLE9BQU8sS0FBSyxDQUFDO0FBQ3JCLG1CQUFTLE9BQU8sS0FBSyxDQUFDO2VBQ2pCO0FBQ0wsa0JBQVEsT0FBTyxLQUFLLENBQUM7QUFDckIsbUJBQVMsT0FBTyxLQUFLLENBQUM7O0FBR3hCLGNBQU0sY0FBYyxTQUFTLFdBQVcsU0FBWSxRQUFRLFNBQVM7QUFFckUsY0FBTSxPQUFPLFNBQVM7QUFDdEIsWUFBSTtBQUNKLFlBQUk7QUFDSixZQUFJLFNBQVMsVUFBYSxLQUFLLFNBQVMsUUFBVztBQUNqRCxxQkFBVyxDQUFDLEtBQUssS0FBSyxLQUFLLEdBQUc7ZUFDekI7QUFDTCxjQUFJLE9BQVEsS0FBSyxTQUFVLFVBQVU7QUFDbkMsdUJBQVcsQ0FBQyxLQUFLLE1BQU0sS0FBSyxNQUFNLEtBQUssTUFBTSxLQUFLLElBQUk7aUJBQ2pEO0FBQ0wsdUJBQVcsQ0FBQyxLQUFLLEtBQUssQ0FBQyxHQUFHLEtBQUssS0FBSyxDQUFDLEdBQUcsS0FBSyxLQUFLLENBQUMsR0FBRyxDQUFDO0FBQ3ZELGdCQUFJLEtBQUssS0FBSyxDQUFDLE1BQU0sUUFBVztBQUM5Qix1QkFBUyxDQUFDLElBQUksS0FBSyxLQUFLLENBQUM7Ozs7QUFJL0IsWUFBSSxTQUFTLFVBQWEsS0FBSyxTQUFTLFFBQVc7QUFDakQscUJBQVcsQ0FBQyxHQUFHLEdBQUcsR0FBRyxDQUFDO2VBQ2pCO0FBQ0wsY0FBSSxPQUFRLEtBQUssU0FBVSxVQUFVO0FBQ25DLHVCQUFXLENBQUMsS0FBSyxNQUFNLEtBQUssTUFBTSxLQUFLLE1BQU0sS0FBSyxJQUFJO2lCQUNqRDtBQUNMLHVCQUFXLENBQUMsS0FBSyxLQUFLLENBQUMsR0FBRyxLQUFLLEtBQUssQ0FBQyxHQUFHLEtBQUssS0FBSyxDQUFDLEdBQUcsQ0FBQztBQUN2RCxnQkFBSSxLQUFLLEtBQUssQ0FBQyxNQUFNLFFBQVc7QUFDOUIsdUJBQVMsQ0FBQyxJQUFJLEtBQUssS0FBSyxDQUFDOzs7O0FBSy9CLGNBQU0sU0FBUyxTQUFTO0FBRXhCLFlBQUksaUJBQWlCLEdBQUcsaUJBQWlCLFFBQVEsaUJBQWlCLFNBQVMsR0FBRyxpQkFBaUI7QUFHL0YsWUFBSSxnQkFBZ0IsUUFBUTtBQUMxQiwyQkFBaUI7QUFDakIsMkJBQWlCO0FBQ2pCLDJCQUFpQixTQUFTO0FBQzFCLDJCQUFpQixTQUFTO21CQUNqQixnQkFBZ0IsT0FBTztBQUNoQywyQkFBaUI7QUFDakIsMkJBQWlCO0FBQ2pCLDJCQUFpQixTQUFTO21CQUNqQixnQkFBZ0IsT0FBTztBQUNoQywyQkFBaUI7QUFDakIsMkJBQWlCO0FBQ2pCLDJCQUFpQixTQUFTOztBQUc1QixpQkFBUyxJQUFJLEdBQUcsSUFBSSxRQUFRLEtBQUs7QUFDL0IsbUJBQVMsSUFBSSxHQUFHLElBQUksT0FBTyxLQUFLO0FBQzlCLGtCQUFNLEtBQU0sT0FBTyxLQUFLLGdCQUFnQixJQUFlLFNBQVMsQ0FBQyxLQUFLLFNBQVMsQ0FBQztBQUNoRixrQkFBTSxLQUFNLE9BQU8sS0FBSyxnQkFBZ0IsSUFBZSxTQUFTLENBQUMsS0FBSyxTQUFTLENBQUM7QUFDaEYsa0JBQU0sS0FBTSxPQUFPLEtBQUssZ0JBQWdCLElBQWUsU0FBUyxDQUFDLEtBQUssU0FBUyxDQUFDO0FBQ2hGLGtCQUFNLElBQUksbUJBQW1CLEtBQ3pCLE9BQ0UsT0FBTyxLQUFLLGdCQUFnQixJQUFlLFNBQVMsQ0FBQyxLQUFLLFNBQVMsQ0FBQztBQUUxRSw0QkFBZ0IsWUFBWSxVQUFVLElBQUksTUFBTSxJQUFJLE1BQU0sSUFBSSxNQUFNLElBQUk7QUFDeEUsNEJBQWdCLFNBQVMsR0FBRyxHQUFHLEdBQUcsQ0FBQzs7O0FBR3ZDLFlBQUksZUFBZSxRQUFRO0FBQ3pCLGlCQUFPLE9BQU8sVUFBUztlQUNsQjtBQUNMLGdCQUFNLElBQUksTUFBTSw0QkFBNEI7O2FBRXpDO0FBQ0wsY0FBTSxJQUFJLE1BQU0sMkJBQTJCOztJQUUvQztBQUtPLElBQU0sb0JBQW9CLENBQUMsUUFBZ0IsWUFBaUQ7QUFDakcsWUFBTSxrQkFBa0IsT0FBTyxhQUFhLGNBQ3hDLFNBQVMsY0FBYyxRQUFRLEVBQUUsV0FBVyxJQUFJLElBQ2hELElBQUksZ0JBQWdCLEdBQUcsQ0FBQyxFQUFFLFdBQVcsSUFBSTtBQUM3QyxVQUFJO0FBQ0osVUFBSSxtQkFBbUIsTUFBTTtBQUUzQixZQUFJO0FBQ0osWUFBSTtBQUNKLFlBQUk7QUFDSixZQUFJLFNBQVMsaUJBQWlCLFVBQWEsUUFBUSxpQkFBaUIsUUFBUTtBQUMxRSxrQkFBUSxPQUFPLEtBQUssQ0FBQztBQUNyQixtQkFBUyxPQUFPLEtBQUssQ0FBQztBQUN0QixxQkFBVyxPQUFPLEtBQUssQ0FBQztlQUNuQjtBQUNMLGtCQUFRLE9BQU8sS0FBSyxDQUFDO0FBQ3JCLG1CQUFTLE9BQU8sS0FBSyxDQUFDO0FBQ3RCLHFCQUFXLE9BQU8sS0FBSyxDQUFDOztBQUUxQixjQUFNLGNBQWMsWUFBWSxTQUFhLFFBQVEsV0FBVyxTQUFZLFFBQVEsU0FBUyxRQUFTO0FBRXRHLGNBQU0sT0FBTyxTQUFTO0FBQ3RCLFlBQUk7QUFDSixZQUFJO0FBQ0osWUFBSSxTQUFTLFVBQWEsS0FBSyxTQUFTLFFBQVc7QUFDakQscUJBQVcsQ0FBQyxLQUFLLEtBQUssS0FBSyxHQUFHO2VBQ3pCO0FBQ0wsY0FBSSxPQUFRLEtBQUssU0FBVSxVQUFVO0FBQ25DLHVCQUFXLENBQUMsS0FBSyxNQUFNLEtBQUssTUFBTSxLQUFLLE1BQU0sS0FBSyxJQUFJO2lCQUNqRDtBQUNMLHVCQUFXLENBQUMsS0FBSyxLQUFLLENBQUMsR0FBRyxLQUFLLEtBQUssQ0FBQyxHQUFHLEtBQUssS0FBSyxDQUFDLEdBQUcsR0FBRztBQUN6RCxnQkFBSSxLQUFLLEtBQUssQ0FBQyxNQUFNLFFBQVc7QUFDOUIsdUJBQVMsQ0FBQyxJQUFJLEtBQUssS0FBSyxDQUFDOzs7O0FBSS9CLFlBQUksU0FBUyxVQUFhLEtBQUssU0FBUyxRQUFXO0FBQ2pELHFCQUFXLENBQUMsR0FBRyxHQUFHLEdBQUcsQ0FBQztlQUNqQjtBQUNMLGNBQUksT0FBUSxLQUFLLFNBQVUsVUFBVTtBQUNuQyx1QkFBVyxDQUFDLEtBQUssTUFBTSxLQUFLLE1BQU0sS0FBSyxNQUFNLEtBQUssSUFBSTtpQkFDakQ7QUFDTCx1QkFBVyxDQUFDLEtBQUssS0FBSyxDQUFDLEdBQUcsS0FBSyxLQUFLLENBQUMsR0FBRyxLQUFLLEtBQUssQ0FBQyxHQUFHLENBQUM7QUFDdkQsZ0JBQUksS0FBSyxLQUFLLENBQUMsTUFBTSxRQUFXO0FBQzlCLHVCQUFTLENBQUMsSUFBSSxLQUFLLEtBQUssQ0FBQzs7OztBQUsvQixjQUFNLFNBQVMsU0FBUztBQUN4QixZQUFJLFlBQVksUUFBVztBQUN6QixjQUFJLFFBQVEsV0FBVyxXQUFjLGFBQWEsS0FBSyxRQUFRLFdBQVcsV0FDckUsYUFBYSxNQUFNLFFBQVEsV0FBVyxTQUFTLFFBQVEsV0FBVyxRQUFTO0FBQzlFLGtCQUFNLElBQUksTUFBTSwrQ0FBZ0Q7OztBQUtwRSxjQUFNLE9BQU87QUFDYixZQUFJLGdCQUFnQixHQUFHLGdCQUFnQixHQUFHLGdCQUFnQixHQUFHLGdCQUFnQjtBQUM3RSxZQUFJLGlCQUFpQixHQUFHLGlCQUFpQixRQUFRLGlCQUFpQixTQUFTLEdBQUcsaUJBQWlCO0FBRy9GLFlBQUksZ0JBQWdCLFFBQVE7QUFDMUIsMkJBQWlCO0FBQ2pCLDJCQUFpQjtBQUNqQiwyQkFBaUIsU0FBUztBQUMxQiwyQkFBaUIsU0FBUzttQkFDakIsZ0JBQWdCLE9BQU87QUFDaEMsMkJBQWlCO0FBQ2pCLDJCQUFpQjtBQUNqQiwyQkFBaUIsU0FBUzttQkFDakIsZ0JBQWdCLE9BQU87QUFDaEMsMkJBQWlCO0FBQ2pCLDJCQUFpQjtBQUNqQiwyQkFBaUIsU0FBUzs7QUFHNUIsZ0JBQVEsZ0JBQWdCLGdCQUFnQixPQUFPLE1BQU07QUFFckQsaUJBQVMsSUFBSSxHQUFHLElBQUksU0FBUyxPQUN4QixpQkFBaUIsTUFBTSxpQkFBaUIsTUFBTSxpQkFBaUIsTUFBTSxpQkFBaUIsTUFBTSxLQUFLO0FBQ3BHLGdCQUFNLEtBQUssYUFBYSxLQUFNLE9BQU8sS0FBSyxnQkFBZ0IsSUFBZSxTQUFTLENBQUMsS0FBSyxTQUFTLENBQUM7QUFDbEcsZ0JBQU0sS0FBSyxhQUFhLEtBQU0sT0FBTyxLQUFLLGdCQUFnQixJQUFlLFNBQVMsQ0FBQyxLQUFLLFNBQVMsQ0FBQztBQUNsRyxnQkFBTSxLQUFLLGFBQWEsS0FBTSxPQUFPLEtBQUssZ0JBQWdCLElBQWUsU0FBUyxDQUFDLEtBQUssU0FBUyxDQUFDO0FBQ2xHLGdCQUFNLEtBQUssYUFBYSxJQUFJLG1CQUFtQixLQUMzQyxPQUNFLE9BQU8sS0FBSyxnQkFBZ0IsSUFBZSxTQUFTLENBQUMsS0FBSyxTQUFTLENBQUM7O2FBR3ZFO0FBQ0wsY0FBTSxJQUFJLE1BQU0sMkJBQTJCOztBQUU3QyxhQUFPO0lBQ1Q7Ozs7O0FDdE1BLElBaUJhLGdCQWtGQSxpQkFnS0EsbUJBV0EscUJBU0E7QUF2UmI7OztBQUlBO0FBYU8sSUFBTSxpQkFBaUIsQ0FBQyxRQUFxQyxZQUEwQztBQUM1RyxVQUFJLFdBQVcsUUFBVztBQUN4QixjQUFNLElBQUksTUFBTSw4QkFBOEI7O0FBRWhELFVBQUksUUFBUSxXQUFXLFVBQWEsUUFBUSxVQUFVLFFBQVc7QUFDL0QsY0FBTSxJQUFJLE1BQU0sd0NBQXdDOztBQUUxRCxVQUFJLFFBQVEsaUJBQWlCLFFBQVE7QUFDbkMsY0FBTSxJQUFJLE1BQU0seUNBQXlDOztBQUczRCxZQUFNLEVBQUMsUUFBUSxNQUFLLElBQUk7QUFFeEIsWUFBTSxPQUFPLFFBQVEsUUFBUSxFQUFDLE1BQU0sS0FBSyxNQUFNLEVBQUM7QUFDaEQsVUFBSTtBQUNKLFVBQUk7QUFFSixVQUFJLE9BQVEsS0FBSyxTQUFVLFVBQVU7QUFDbkMsbUJBQVcsQ0FBQyxLQUFLLE1BQU0sS0FBSyxNQUFNLEtBQUssTUFBTSxLQUFLLElBQUk7YUFDakQ7QUFDTCxtQkFBVyxDQUFDLEtBQUssS0FBTSxDQUFDLEdBQUcsS0FBSyxLQUFNLENBQUMsR0FBRyxLQUFLLEtBQU0sQ0FBQyxHQUFHLEtBQUssS0FBTSxDQUFDLEtBQUssR0FBRzs7QUFHL0UsVUFBSSxPQUFRLEtBQUssU0FBVSxVQUFVO0FBQ25DLG1CQUFXLENBQUMsS0FBSyxNQUFNLEtBQUssTUFBTSxLQUFLLE1BQU0sS0FBSyxJQUFJO2FBQ2pEO0FBQ0wsbUJBQVcsQ0FBQyxLQUFLLEtBQU0sQ0FBQyxHQUFHLEtBQUssS0FBTSxDQUFDLEdBQUcsS0FBSyxLQUFNLENBQUMsR0FBRyxLQUFLLEtBQU0sQ0FBQyxLQUFLLENBQUM7O0FBRzdFLFlBQU0sY0FBYyxRQUFRLFdBQVcsU0FBWSxRQUFRLFNBQVM7QUFHcEUsWUFBTSxlQUNGLFFBQVEsaUJBQWlCLFNBQWEsUUFBUSxpQkFBaUIsU0FBWSxRQUFRLGVBQWUsUUFBUztBQUMvRyxZQUFNLFNBQVMsU0FBUztBQUN4QixZQUFNLGNBQWMsaUJBQWlCLFNBQVMsSUFBSSxhQUFhLFNBQVMsQ0FBQyxJQUFJLElBQUksYUFBYSxTQUFTLENBQUM7QUFHeEcsVUFBSSxPQUFPLEdBQUcsZ0JBQWdCLEdBQUcsZ0JBQWdCLEdBQUcsZ0JBQWdCLEdBQUcsZ0JBQWdCO0FBQ3ZGLFVBQUksaUJBQWlCLEdBQUcsaUJBQWlCLFFBQVEsaUJBQWlCLFNBQVMsR0FBRyxpQkFBaUI7QUFHL0YsVUFBSSxnQkFBZ0IsT0FBTztBQUN6QixlQUFPO0FBQ1Asd0JBQWdCO0FBQ2hCLHdCQUFnQjtBQUNoQix3QkFBZ0I7QUFDaEIsd0JBQWdCOztBQUlsQixVQUFJLGlCQUFpQixRQUFRO0FBQzNCLHlCQUFpQixTQUFTO2lCQUNqQixpQkFBaUIsT0FBTztBQUNqQyx5QkFBaUI7QUFDakIseUJBQWlCO0FBQ2pCLHlCQUFpQixTQUFTO2lCQUNqQixpQkFBaUIsT0FBTztBQUNqQyx5QkFBaUI7QUFDakIseUJBQWlCO0FBQ2pCLHlCQUFpQixTQUFTOztBQUc1QixlQUFTLElBQUksR0FBRyxJQUFJLFFBQ2YsS0FBSyxpQkFBaUIsTUFBTSxpQkFBaUIsTUFBTSxpQkFBaUIsTUFBTSxpQkFBaUIsTUFBTTtBQUNwRyxvQkFBWSxnQkFBZ0IsS0FBSyxPQUFPLGFBQWEsSUFBSSxTQUFTLENBQUMsS0FBSyxTQUFTLENBQUM7QUFDbEYsb0JBQVksZ0JBQWdCLEtBQUssT0FBTyxhQUFhLElBQUksU0FBUyxDQUFDLEtBQUssU0FBUyxDQUFDO0FBQ2xGLG9CQUFZLGdCQUFnQixLQUFLLE9BQU8sYUFBYSxJQUFJLFNBQVMsQ0FBQyxLQUFLLFNBQVMsQ0FBQztBQUNsRixZQUFJLG1CQUFtQixNQUFNLGtCQUFrQixJQUFJO0FBQ2pELHNCQUFZLGdCQUFnQixLQUFLLE9BQU8sYUFBYSxJQUFJLFNBQVMsQ0FBQyxLQUFLLFNBQVMsQ0FBQzs7O0FBS3RGLFlBQU0sZUFBZSxpQkFBaUIsU0FBUyxJQUFJLE9BQU8sV0FBVyxhQUFhLENBQUMsR0FBRyxHQUFHLFFBQVEsS0FBSyxDQUFDLElBQ3hELElBQUksT0FBTyxXQUFXLGFBQWEsQ0FBQyxHQUFHLEdBQUcsUUFBUSxLQUFLLENBQUM7QUFDdkcsYUFBTztJQUNUO0FBS08sSUFBTSxrQkFBa0IsT0FDM0IsT0FDQSxZQUN5QztBQUUzQyxZQUFNLGlCQUFpQixPQUFRLHFCQUFzQixlQUFlLGlCQUFpQjtBQUNyRixZQUFNLGlCQUFpQixPQUFRLGNBQWUsZUFBZSxpQkFBaUI7QUFDOUUsWUFBTSxnQkFBZ0IsT0FBUSxnQkFBaUIsZUFBZSxpQkFBaUI7QUFDL0UsWUFBTSxXQUFXLE9BQU8sVUFBVTtBQUVsQyxVQUFJO0FBQ0osVUFBSSx3QkFBK0MsV0FBVyxDQUFBO0FBRTlELFlBQU1DLGdCQUFlLE1BQUs7QUFDeEIsWUFBSSxPQUFPLGFBQWEsYUFBYTtBQUNuQyxpQkFBTyxTQUFTLGNBQWMsUUFBUTttQkFDN0IsT0FBTyxvQkFBb0IsYUFBYTtBQUNqRCxpQkFBTyxJQUFJLGdCQUFnQixHQUFHLENBQUM7ZUFDMUI7QUFDTCxnQkFBTSxJQUFJLE1BQU0seUJBQXlCOztNQUU3QztBQUNBLFlBQU0sc0JBQXNCLENBQUMsV0FBNkM7QUFDeEUsWUFBSSxrQkFBa0IsbUJBQW1CO0FBQ3ZDLGlCQUFPLE9BQU8sV0FBVyxJQUFJO21CQUNwQixrQkFBa0IsaUJBQWlCO0FBQzVDLGlCQUFPLE9BQU8sV0FBVyxJQUFJO2VBQ3hCO0FBQ0wsaUJBQU87O01BRVg7QUFFQSxVQUFJLGdCQUFnQjtBQUVsQixjQUFNLFNBQVNBLGNBQVk7QUFDM0IsZUFBTyxRQUFRLE1BQU07QUFDckIsZUFBTyxTQUFTLE1BQU07QUFDdEIsY0FBTSxrQkFBa0Isb0JBQW9CLE1BQU07QUFFbEQsWUFBSSxtQkFBbUIsTUFBTTtBQUMzQixjQUFJLFNBQVMsTUFBTTtBQUNuQixjQUFJLFFBQVEsTUFBTTtBQUNsQixjQUFJLFlBQVksVUFBYSxRQUFRLGtCQUFrQixVQUFhLFFBQVEsaUJBQWlCLFFBQVc7QUFDdEcscUJBQVMsUUFBUTtBQUNqQixvQkFBUSxRQUFROztBQUdsQixjQUFJLFlBQVksUUFBVztBQUN6QixvQ0FBd0I7QUFDeEIsZ0JBQUksUUFBUSxpQkFBaUIsUUFBVztBQUN0QyxvQkFBTSxJQUFJLE1BQU0sNkRBQTZEO21CQUN4RTtBQUNMLG9DQUFzQixlQUFlOztBQUV2QyxrQ0FBc0IsU0FBUztBQUMvQixrQ0FBc0IsUUFBUTtpQkFDekI7QUFDTCxrQ0FBc0IsZUFBZTtBQUNyQyxrQ0FBc0IsU0FBUztBQUMvQixrQ0FBc0IsUUFBUTs7QUFHaEMsMEJBQWdCLFVBQVUsT0FBTyxHQUFHLENBQUM7QUFDckMsaUJBQU8sZ0JBQWdCLGFBQWEsR0FBRyxHQUFHLE9BQU8sTUFBTSxFQUFFO2VBQ3BEO0FBQ0wsZ0JBQU0sSUFBSSxNQUFNLDJCQUEyQjs7aUJBRXBDLGdCQUFnQjtBQUN6QixZQUFJO0FBQ0osWUFBSTtBQUVKLFlBQUksWUFBWSxVQUFhLFFBQVEsaUJBQWlCLFVBQWEsUUFBUSxrQkFBa0IsUUFBVztBQUN0RyxtQkFBUyxRQUFRO0FBQ2pCLGtCQUFRLFFBQVE7ZUFDWDtBQUNMLG1CQUFTLE1BQU07QUFDZixrQkFBUSxNQUFNOztBQUdoQixZQUFJLFlBQVksUUFBVztBQUN6QixrQ0FBd0I7O0FBRTFCLDhCQUFzQixTQUFTO0FBQy9CLDhCQUFzQixTQUFTO0FBQy9CLDhCQUFzQixRQUFRO0FBRTlCLFlBQUksWUFBWSxRQUFXO0FBQ3pCLGdCQUFNLGFBQWFBLGNBQVk7QUFFL0IscUJBQVcsUUFBUTtBQUNuQixxQkFBVyxTQUFTO0FBRXBCLGdCQUFNLGtCQUFrQixvQkFBb0IsVUFBVTtBQUV0RCxjQUFJLG1CQUFtQixNQUFNO0FBQzNCLDRCQUFnQixhQUFhLE9BQU8sR0FBRyxDQUFDO0FBQ3hDLG1CQUFPLGdCQUFnQixhQUFhLEdBQUcsR0FBRyxPQUFPLE1BQU0sRUFBRTtpQkFDcEQ7QUFDTCxrQkFBTSxJQUFJLE1BQU0sMkJBQTJCOztlQUV4QztBQUNMLGlCQUFPLE1BQU07O2lCQUVOLGVBQWU7QUFFeEIsWUFBSSxZQUFZLFFBQVc7QUFDekIsZ0JBQU0sSUFBSSxNQUFNLHlEQUF5RDs7QUFHM0UsY0FBTSxTQUFTQSxjQUFZO0FBQzNCLGVBQU8sUUFBUSxNQUFNO0FBQ3JCLGVBQU8sU0FBUyxNQUFNO0FBQ3RCLGNBQU0sa0JBQWtCLG9CQUFvQixNQUFNO0FBRWxELFlBQUksbUJBQW1CLE1BQU07QUFDM0IsZ0JBQU0sU0FBUyxNQUFNO0FBQ3JCLGdCQUFNLFFBQVEsTUFBTTtBQUNwQiwwQkFBZ0IsVUFBVSxPQUFPLEdBQUcsR0FBRyxPQUFPLE1BQU07QUFDcEQsaUJBQU8sZ0JBQWdCLGFBQWEsR0FBRyxHQUFHLE9BQU8sTUFBTSxFQUFFO0FBQ3pELGdDQUFzQixTQUFTO0FBQy9CLGdDQUFzQixRQUFRO0FBQzlCLGlCQUFPLGVBQWUsTUFBTSxxQkFBcUI7ZUFDNUM7QUFDTCxnQkFBTSxJQUFJLE1BQU0sMkJBQTJCOztpQkFFcEMsVUFBVTtBQUNuQixlQUFPLElBQUksUUFBUSxDQUFDLFNBQVMsV0FBVTtBQUNyQyxnQkFBTSxTQUFTQSxjQUFZO0FBQzNCLGdCQUFNLFVBQVUsb0JBQW9CLE1BQU07QUFDMUMsY0FBSSxDQUFDLFNBQVMsQ0FBQyxTQUFTO0FBQ3RCLG1CQUFPLE9BQU07O0FBRWYsZ0JBQU0sV0FBVyxJQUFJLE1BQUs7QUFDMUIsbUJBQVMsY0FBYztBQUN2QixtQkFBUyxNQUFNO0FBQ2YsbUJBQVMsU0FBUyxNQUFLO0FBQ3JCLG1CQUFPLFFBQVEsU0FBUztBQUN4QixtQkFBTyxTQUFTLFNBQVM7QUFDekIsb0JBQVEsVUFBVSxVQUFVLEdBQUcsR0FBRyxPQUFPLE9BQU8sT0FBTyxNQUFNO0FBQzdELGtCQUFNLE1BQU0sUUFBUSxhQUFhLEdBQUcsR0FBRyxPQUFPLE9BQU8sT0FBTyxNQUFNO0FBRWxFLGtDQUFzQixTQUFTLE9BQU87QUFDdEMsa0NBQXNCLFFBQVEsT0FBTztBQUNyQyxvQkFBUSxlQUFlLElBQUksTUFBTSxxQkFBcUIsQ0FBQztVQUN6RDtRQUNGLENBQUM7YUFDSTtBQUNMLGNBQU0sSUFBSSxNQUFNLGdFQUFnRTs7QUFHbEYsVUFBSSxTQUFTLFFBQVc7QUFDdEIsZUFBTyxlQUFlLE1BQU0scUJBQXFCO2FBQzVDO0FBQ0wsY0FBTSxJQUFJLE1BQU0sZ0VBQWdFOztJQUVwRjtBQUtPLElBQU0sb0JBQW9CLENBQzdCLFNBQXNDLFlBQWdEO0FBQ3hGLFlBQU0sRUFBQyxPQUFPLFFBQVEsVUFBVSxRQUFPLElBQUk7QUFFM0MsWUFBTSxPQUFPLENBQUMsR0FBRyxRQUFRLE9BQU8sQ0FBQztBQUNqQyxhQUFPLElBQUksT0FBTyxFQUFDLFVBQVUsV0FBVyxNQUFNLFdBQVcsU0FBUyxNQUFNLFVBQVUsUUFBTyxDQUFDO0lBQzVGO0FBS08sSUFBTSxzQkFBc0IsQ0FDL0IsV0FBMEMsWUFBa0Q7QUFDOUYsWUFBTSxFQUFDLFVBQVUsTUFBTSxVQUFVLFFBQU8sSUFBSTtBQUM1QyxhQUFPLElBQUksT0FBTyxFQUFDLFVBQVUsY0FBYyxNQUFNLFlBQVksV0FBVyxXQUFXLE1BQU0sVUFBVSxRQUFPLENBQUM7SUFDN0c7QUFLTyxJQUFNLHlCQUF5QixDQUNsQyxNQUFTLFFBQXdDLFNBQ2pELElBQUksT0FBTyxFQUFDLFVBQVUsY0FBYyxNQUFNLE1BQU0sUUFBUSxNQUFNLFFBQVEsQ0FBQyxPQUFPLE1BQU0sRUFBQyxDQUFDOzs7OztBQ3pSMUYsSUFXYSx1Q0FhQSx1Q0FvQlQscUJBQ1M7QUE3Q2I7OztBQVdPLElBQU0sd0NBQXdDLG9CQUFJLElBQTZDO01BQ3BHLENBQUMsV0FBVyxZQUFZO01BQ3hCLENBQUMsU0FBUyxVQUFVO01BQ3BCLENBQUMsUUFBUSxTQUFTO01BQ2xCLENBQUMsVUFBVSxXQUFXO01BQ3RCLENBQUMsU0FBUyxVQUFVO01BQ3BCLENBQUMsU0FBUyxVQUFVO01BQ3BCLENBQUMsUUFBUSxVQUFVO01BQ25CLENBQUMsV0FBVyxZQUFZO01BQ3hCLENBQUMsVUFBVSxXQUFXO0tBQ3ZCO0FBR00sSUFBTSx3Q0FBd0Msb0JBQUksSUFBa0Q7TUFDekcsQ0FBQyxjQUFjLFNBQVM7TUFDeEIsQ0FBQyxZQUFZLE9BQU87TUFDcEIsQ0FBQyxXQUFXLE1BQU07TUFDbEIsQ0FBQyxhQUFhLFFBQVE7TUFDdEIsQ0FBQyxZQUFZLE9BQU87TUFDcEIsQ0FBQyxZQUFZLE9BQU87TUFDcEIsQ0FBQyxjQUFjLFNBQVM7TUFDeEIsQ0FBQyxhQUFhLFFBQVE7S0FDdkI7QUFXRCxJQUFJLHNCQUFzQjtBQUNuQixJQUFNLGtCQUFrQixNQUFLO0FBQ2xDLFVBQUksQ0FBQyxxQkFBcUI7QUFDeEIsOEJBQXNCO0FBQ3RCLGNBQU0sMkJBQTJCLE9BQU8sa0JBQWtCLGVBQWUsY0FBYztBQUN2RixjQUFNLDRCQUE0QixPQUFPLG1CQUFtQixlQUFlLGVBQWU7QUFDMUYsY0FBTSwwQkFBMEIsT0FBTyxpQkFBaUIsZUFBZSxhQUFhO0FBRXBGLFlBQUksMEJBQTBCO0FBQzVCLGdEQUFzQyxJQUFJLFNBQVMsYUFBYTtBQUNoRSxnREFBc0MsSUFBSSxlQUFlLE9BQU87O0FBRWxFLFlBQUksMkJBQTJCO0FBQzdCLGdEQUFzQyxJQUFJLFVBQVUsY0FBYztBQUNsRSxnREFBc0MsSUFBSSxnQkFBZ0IsUUFBUTs7QUFFcEUsWUFBSSx5QkFBeUI7QUFDM0IsZ0RBQXNDLElBQUksV0FBVyxZQUFZO0FBQ2pFLGdEQUFzQyxJQUFJLGNBQWMsU0FBUztlQUM1RDtBQUVMLGdEQUFzQyxJQUFJLFdBQVcsV0FBVzs7O0lBR3RFOzs7OztBQ3BFQSxJQVdhLGVBa0JBO0FBN0JiOzs7QUFJQTtBQU9PLElBQU0sZ0JBQWdCLENBQUMsU0FBb0M7QUFDaEUsVUFBSSxPQUFPO0FBQ1gsZUFBUyxJQUFJLEdBQUcsSUFBSSxLQUFLLFFBQVEsS0FBSztBQUNwQyxjQUFNLE1BQU0sS0FBSyxDQUFDO0FBQ2xCLFlBQUksT0FBTyxRQUFRLFlBQVksQ0FBQyxPQUFPLGNBQWMsR0FBRyxHQUFHO0FBQ3pELGdCQUFNLElBQUksVUFBVSxRQUFRLENBQUMsOEJBQThCLEdBQUcsRUFBRTs7QUFFbEUsWUFBSSxNQUFNLEdBQUc7QUFDWCxnQkFBTSxJQUFJLFdBQVcsUUFBUSxDQUFDLDBDQUEwQyxHQUFHLEVBQUU7O0FBRS9FLGdCQUFROztBQUVWLGFBQU87SUFDVDtBQUtPLElBQU0sZ0JBQWdCLENBQUMsUUFBZ0IsU0FBbUM7QUFDL0UsY0FBUSxPQUFPLFVBQVU7UUFDdkIsS0FBSztBQUNILGlCQUFPLElBQUksT0FBTyxPQUFPLE1BQU0sT0FBTyxNQUFNLElBQUk7UUFDbEQsS0FBSztBQUNILGlCQUFPLElBQUksT0FBTztZQUNoQixVQUFVO1lBQ1YsTUFBTSxPQUFPO1lBQ2IsTUFBTSxPQUFPO1lBQ2I7V0FDRDtRQUNILEtBQUs7QUFDSCxpQkFBTyxJQUFJLE9BQU87WUFDaEIsVUFBVTtZQUNWLFNBQVMsT0FBTztZQUNoQixNQUFNLE9BQU87WUFDYjtXQUNEO1FBQ0gsS0FBSztBQUNILGlCQUFPLElBQUksT0FBTztZQUNoQixVQUFVO1lBQ1YsV0FBVyxPQUFPO1lBQ2xCLE1BQU0sT0FBTztZQUNiO1dBQ0Q7UUFDSDtBQUNFLGdCQUFNLElBQUksTUFBTSxrQ0FBa0MsT0FBTyxRQUFRLG1CQUFtQjs7SUFFMUY7Ozs7O0FDekRBLElBd0JhO0FBeEJiOzs7QUFHQTtBQUVBO0FBRUE7QUFDQTtBQWdCTSxJQUFPLFNBQVAsTUFBYTs7OztNQXlDakIsWUFDSSxNQUVBLE1BQThFLE1BQXdCO0FBRXhHLHdCQUFlO0FBRWYsWUFBSTtBQUNKLFlBQUk7QUFFSixZQUFJLE9BQU8sU0FBUyxZQUFZLGNBQWMsTUFBTTtBQUlsRCxlQUFLLGVBQWUsS0FBSztBQUN6QixpQkFBTyxLQUFLO0FBQ1osaUJBQU8sS0FBSztBQUNaLGtCQUFRLEtBQUssVUFBVTtZQUNyQixLQUFLLGNBQWM7QUFDakIsb0JBQU0sZ0NBQWdDLHNDQUFzQyxJQUFJLElBQUk7QUFDcEYsa0JBQUksQ0FBQywrQkFBK0I7QUFDbEMsc0JBQU0sSUFBSSxVQUFVLHFCQUFxQixJQUFJLHVDQUF1Qzs7QUFFdEYsa0JBQUksRUFBRSxLQUFLLGdCQUFnQixnQ0FBZ0M7QUFDekQsc0JBQU0sSUFBSSxVQUFVLDRCQUE0Qiw4QkFBOEIsSUFBSSxFQUFFOztBQUV0RixtQkFBSyxVQUFVLEtBQUs7QUFDcEI7O1lBRUYsS0FBSyxXQUFXO0FBQ2Qsa0JBQUksU0FBUyxXQUFXO0FBQ3RCLHNCQUFNLElBQUksVUFBVSxxQkFBcUIsSUFBSSxpQ0FBaUM7O0FBRWhGLG1CQUFLLGlCQUFpQixLQUFLO0FBQzNCLG1CQUFLLGFBQWEsS0FBSztBQUN2QixtQkFBSyxXQUFXLEtBQUs7QUFDckI7O1lBRUYsS0FBSyxjQUFjO0FBQ2pCLGtCQUFLLFNBQVMsYUFBYSxTQUFTLGFBQWEsU0FBUyxXQUFXLFNBQVMsV0FBVyxTQUFTLFlBQzdGLFNBQVMsV0FBVyxTQUFTLFFBQVM7QUFDekMsc0JBQU0sSUFBSSxVQUFVLHFCQUFxQixJQUFJLG9DQUFvQzs7QUFFbkYsbUJBQUssZ0JBQWdCLEtBQUs7QUFDMUIsbUJBQUssYUFBYSxLQUFLO0FBQ3ZCLG1CQUFLLFdBQVcsS0FBSztBQUNyQjs7WUFFRjtBQUNFLG9CQUFNLElBQUksTUFBTSw2Q0FBNkMsS0FBSyxZQUFZLEdBQUc7O2VBRWhGO0FBSUwsY0FBSTtBQUNKLGNBQUk7QUFFSixjQUFJLE9BQU8sU0FBUyxVQUFVO0FBSTVCLG1CQUFPO0FBQ1Asd0JBQVk7QUFDWixnQkFBSSxTQUFTLFVBQVU7QUFFckIsa0JBQUksQ0FBQyxNQUFNLFFBQVEsSUFBSSxHQUFHO0FBQ3hCLHNCQUFNLElBQUksVUFBVSxnREFBaUQ7O0FBSXZFLHFCQUFPO21CQUNGO0FBRUwsb0JBQU0sd0JBQXdCLHNDQUFzQyxJQUFJLElBQUk7QUFDNUUsa0JBQUksMEJBQTBCLFFBQVc7QUFDdkMsc0JBQU0sSUFBSSxVQUFVLDRCQUE0QixJQUFJLEdBQUc7O0FBRXpELGtCQUFJLE1BQU0sUUFBUSxJQUFJLEdBQUc7QUFDdkIsb0JBQUksU0FBUyxhQUFhLDBCQUEwQixhQUFhO0FBTS9ELHdCQUFNLElBQUksVUFDTiwrRkFBK0Y7MkJBQzFGLFNBQVMsWUFBWSxTQUFTLFNBQVM7QUFZaEQseUJBQVEsc0JBQThCLEtBQUssTUFBTSxNQUFNO3VCQUNsRDtBQUdMLHlCQUFRLHNCQUE4QixLQUFLLElBQUk7O3lCQUV4QyxnQkFBZ0IsdUJBQXVCO0FBQ2hELHVCQUFPO3FCQUNGO0FBQ0wsc0JBQU0sSUFBSSxVQUFVLEtBQUssSUFBSSxrQ0FBa0MscUJBQXFCLEVBQUU7OztpQkFHckY7QUFJTCx3QkFBWTtBQUNaLGdCQUFJLE1BQU0sUUFBUSxJQUFJLEdBQUc7QUFFdkIsa0JBQUksS0FBSyxXQUFXLEdBQUc7QUFDckIsc0JBQU0sSUFBSSxVQUFVLHFEQUFxRDs7QUFFM0Usb0JBQU0sbUJBQW1CLE9BQU8sS0FBSyxDQUFDO0FBQ3RDLGtCQUFJLHFCQUFxQixVQUFVO0FBQ2pDLHVCQUFPO0FBQ1AsdUJBQU87eUJBQ0UscUJBQXFCLFdBQVc7QUFDekMsdUJBQU87QUFJUCx1QkFBTyxXQUFXLEtBQUssSUFBYTtxQkFDL0I7QUFDTCxzQkFBTSxJQUFJLFVBQVUsdUNBQXVDLGdCQUFnQixHQUFHOzttQkFFM0U7QUFFTCxvQkFBTSxhQUNGLHNDQUFzQyxJQUFJLEtBQUssV0FBOEM7QUFDakcsa0JBQUksZUFBZSxRQUFXO0FBQzVCLHNCQUFNLElBQUksVUFBVSxxQ0FBcUMsS0FBSyxXQUFXLEdBQUc7O0FBRTlFLHFCQUFPO0FBQ1AscUJBQU87OztBQUtYLGNBQUksY0FBYyxRQUFXO0FBRTNCLHdCQUFZLENBQUMsS0FBSyxNQUFNO3FCQUNmLENBQUMsTUFBTSxRQUFRLFNBQVMsR0FBRztBQUNwQyxrQkFBTSxJQUFJLFVBQVUsd0NBQXlDOztBQUUvRCxpQkFBTztBQUVQLGVBQUssVUFBVTtBQUNmLGVBQUssZUFBZTs7QUFJdEIsY0FBTSxPQUFPLGNBQWMsSUFBSTtBQUUvQixZQUFJLEtBQUssV0FBVyxTQUFTLEtBQUssUUFBUSxRQUFRO0FBQ2hELGdCQUFNLElBQUksTUFBTSxpQkFBaUIsSUFBSSxnQ0FBZ0MsS0FBSyxRQUFRLE1BQU0sSUFBSTs7QUFHOUYsYUFBSyxPQUFPO0FBQ1osYUFBSyxPQUFPO0FBQ1osYUFBSyxPQUFPO01BQ2Q7OztNQUlBLGFBQWEsVUFDVCxPQUNBLFNBQ29CO0FBQ3RCLGVBQU8sZ0JBQWdCLE9BQU8sT0FBTztNQUN2QztNQUVBLE9BQU8sWUFDSCxTQUE0QixTQUFvQztBQUNsRSxlQUFPLGtCQUFrQixTQUFTLE9BQU87TUFDM0M7TUFFQSxPQUFPLGNBQ0gsV0FBZ0MsU0FBc0M7QUFDeEUsZUFBTyxvQkFBb0IsV0FBVyxPQUFPO01BQy9DO01BRUEsT0FBTyxpQkFDSCxNQUFTLFFBQXdDLE1BQXdCO0FBQzNFLGVBQU8sdUJBQXVCLE1BQU0sUUFBUSxJQUFJO01BQ2xEOzs7TUFLQSxVQUFVLFNBQWdDO0FBQ3hDLGVBQU8sZ0JBQWdCLE1BQU0sT0FBTztNQUN0QztNQUVBLFlBQVksU0FBa0M7QUFDNUMsZUFBTyxrQkFBa0IsTUFBTSxPQUFPO01BQ3hDOzs7TUFnREEsSUFBSSxPQUFJO0FBQ04sYUFBSyxZQUFXO0FBQ2hCLFlBQUksQ0FBQyxLQUFLLFNBQVM7QUFDakIsZ0JBQU0sSUFBSSxNQUNOLGdKQUMyRTs7QUFFakYsZUFBTyxLQUFLO01BQ2Q7TUFFQSxJQUFJLFdBQVE7QUFDVixlQUFPLEtBQUs7TUFDZDtNQUVBLElBQUksVUFBTztBQUNULGFBQUssWUFBVztBQUNoQixZQUFJLENBQUMsS0FBSyxnQkFBZ0I7QUFDeEIsZ0JBQU0sSUFBSSxNQUFNLDRDQUE0Qzs7QUFFOUQsZUFBTyxLQUFLO01BQ2Q7TUFFQSxJQUFJLFlBQVM7QUFDWCxhQUFLLFlBQVc7QUFDaEIsWUFBSSxDQUFDLEtBQUssZUFBZTtBQUN2QixnQkFBTSxJQUFJLE1BQU0sNENBQTRDOztBQUU5RCxlQUFPLEtBQUs7TUFDZDs7O01BS0EsTUFBTSxRQUFRLGFBQXFCO0FBQ2pDLGFBQUssWUFBVztBQUNoQixnQkFBUSxLQUFLLGNBQWM7VUFDekIsS0FBSztVQUNMLEtBQUs7QUFDSCxtQkFBTyxLQUFLO1VBQ2QsS0FBSztVQUNMLEtBQUssY0FBYztBQUNqQixnQkFBSSxDQUFDLEtBQUssWUFBWTtBQUNwQixvQkFBTSxJQUFJLE1BQU0scUVBQXFFOztBQUV2RixnQkFBSSxLQUFLLGVBQWU7QUFDdEIsb0JBQU0sSUFBSSxNQUFNLHlDQUF5Qzs7QUFFM0QsZ0JBQUk7QUFDRixtQkFBSyxnQkFBZ0I7QUFDckIsb0JBQU0sT0FBTyxNQUFNLEtBQUssV0FBVTtBQUNsQyxtQkFBSyxhQUFhO0FBQ2xCLG1CQUFLLGVBQWU7QUFDcEIsbUJBQUssVUFBVTtBQUVmLGtCQUFJLGVBQWUsS0FBSyxVQUFVO0FBQ2hDLHFCQUFLLFNBQVE7QUFDYixxQkFBSyxXQUFXOztBQUdsQixxQkFBTzs7QUFHUCxtQkFBSyxnQkFBZ0I7OztVQUd6QjtBQUNFLGtCQUFNLElBQUksTUFBTSxrQ0FBa0MsS0FBSyxZQUFZLEVBQUU7O01BRTNFO01BRUEsVUFBTztBQUNMLFlBQUksS0FBSyxlQUFlO0FBQ3RCLGdCQUFNLElBQUksTUFBTSx5Q0FBeUM7O0FBRzNELFlBQUksS0FBSyxVQUFVO0FBQ2pCLGVBQUssU0FBUTtBQUNiLGVBQUssV0FBVzs7QUFFbEIsYUFBSyxVQUFVO0FBQ2YsYUFBSyxpQkFBaUI7QUFDdEIsYUFBSyxnQkFBZ0I7QUFDckIsYUFBSyxhQUFhO0FBQ2xCLGFBQUssZ0JBQWdCO0FBRXJCLGFBQUssZUFBZTtNQUN0Qjs7O01BS1EsY0FBVztBQUNqQixZQUFJLEtBQUssaUJBQWlCLFFBQVE7QUFDaEMsZ0JBQU0sSUFBSSxNQUFNLHlCQUF5Qjs7TUFFN0M7TUFFQSxRQUFRLE1BQXVCO0FBQzdCLGFBQUssWUFBVztBQUNoQixZQUFJLEtBQUssY0FBYyxLQUFLLFVBQVU7QUFDcEMsZ0JBQU0sSUFBSSxNQUFNLGlEQUFpRDs7QUFFbkUsZUFBTyxjQUFjLE1BQU0sSUFBSTtNQUNqQzs7Ozs7O0FDcGFGLElBd1VhQztBQXhVYjs7O0FBSUE7QUFvVU8sSUFBTUEsVUFBUzs7Ozs7QUN4VXRCLElBUWEsT0FRUCxZQXFCTyxrQkFVQTtBQS9DYjs7O0FBR0E7QUFLTyxJQUFNLFFBQVEsQ0FBQyxZQUFvQixVQUFpQjtBQUN6RCxVQUFJLE9BQU8sSUFBSSxVQUFVLGNBQWMsQ0FBQyxJQUFJLEtBQUssUUFBUSxDQUFDLElBQUksT0FBTztBQUNuRTs7QUFHRixjQUFRLFVBQVUsR0FBRyxVQUFVLFVBQVUsS0FBSyxFQUFFO0lBQ2xEO0FBRUEsSUFBTSxhQUFhLENBQUMsS0FBYSxhQUFxQjtBQUNwRCxZQUFNLFFBQVEsSUFBSSxNQUFLLEVBQUcsT0FBTyxNQUFNLGFBQWEsS0FBSyxDQUFBO0FBQ3pELFVBQUksZUFBZTtBQUNuQixlQUFTLElBQUksR0FBRyxJQUFJLE1BQU0sUUFBUSxLQUFLO0FBQ3JDLFlBQUksZ0JBQWdCLENBQUMsTUFBTSxDQUFDLEVBQUUsU0FBUyxZQUFZLEdBQUc7QUFDcEQsY0FBSSxRQUFRLFFBQVEsR0FBRyxLQUFLLE1BQU0sQ0FBQyxFQUFFLEtBQUksRUFBRyxNQUFNLEdBQUcsRUFBRSxDQUFDLENBQUM7QUFDekQsY0FBSSxVQUFVO0FBQ1oscUJBQVMsS0FBSyxRQUFROztBQUV4QixnQkFBTSxPQUFPLEtBQUs7QUFDbEI7O0FBRUYsWUFBSSxNQUFNLENBQUMsRUFBRSxTQUFTLFlBQVksR0FBRztBQUNuQyx5QkFBZTs7O0lBR3JCO0FBS08sSUFBTSxtQkFBbUIsQ0FBQyxhQUFxQjtBQUNwRCxVQUFJLE9BQU8sSUFBSSxVQUFVLGNBQWMsQ0FBQyxJQUFJLEtBQUssUUFBUSxDQUFDLElBQUksT0FBTztBQUNuRTs7QUFFRixpQkFBVyxTQUFTLFFBQVE7SUFDOUI7QUFLTyxJQUFNLGlCQUFpQixDQUFDLGFBQXFCO0FBQ2xELFVBQUksT0FBTyxJQUFJLFVBQVUsY0FBYyxDQUFDLElBQUksS0FBSyxRQUFRLENBQUMsSUFBSSxPQUFPO0FBQ25FOztBQUVGLGlCQUFXLE9BQU8sUUFBUTtJQUM1Qjs7Ozs7QUNwREEsSUFnQmE7QUFoQmI7OztBQUdBO0FBSUE7QUFDQTtBQVFNLElBQU8sbUJBQVAsTUFBTyxrQkFBZ0I7TUFDM0IsWUFBb0IsU0FBZ0M7QUFDbEQsYUFBSyxVQUFVO01BQ2pCO01BR0EsTUFBTSxJQUFJLE9BQWtCLE1BQStCLE1BQWlCO0FBQzFFLHlCQUFnQjtBQUNoQixjQUFNLFVBQTRDLENBQUE7QUFDbEQsWUFBSSxVQUFzQixDQUFBO0FBRTFCLFlBQUksT0FBTyxVQUFVLFlBQVksVUFBVSxRQUFRLGlCQUFpQkMsV0FBVSxNQUFNLFFBQVEsS0FBSyxHQUFHO0FBQ2xHLGdCQUFNLElBQUksVUFDTiwrRkFBaUc7O0FBR3ZHLFlBQUksaUJBQWlCO0FBRXJCLFlBQUksT0FBTyxTQUFTLFVBQVU7QUFDNUIsY0FBSSxTQUFTLE1BQU07QUFDakIsa0JBQU0sSUFBSSxVQUFVLHlDQUF5Qzs7QUFFL0QsY0FBSSxnQkFBZ0JBLFNBQVE7QUFDMUIsa0JBQU0sSUFBSSxVQUFVLDhCQUFnQzs7QUFHdEQsY0FBSSxNQUFNLFFBQVEsSUFBSSxHQUFHO0FBQ3ZCLGdCQUFJLEtBQUssV0FBVyxHQUFHO0FBQ3JCLG9CQUFNLElBQUksVUFBVSxxQ0FBdUM7O0FBRTdELDZCQUFpQjtBQUVqQix1QkFBV0MsU0FBUSxNQUFNO0FBQ3ZCLGtCQUFJLE9BQU9BLFVBQVMsVUFBVTtBQUM1QixzQkFBTSxJQUFJLFVBQVUsZ0RBQWtEOztBQUV4RSxrQkFBSSxLQUFLLFlBQVksUUFBUUEsS0FBSSxNQUFNLElBQUk7QUFDekMsc0JBQU0sSUFBSSxXQUFXLDJDQUEyQ0EsS0FBSSxHQUFHOztBQUV6RSxzQkFBUUEsS0FBSSxJQUFJOztBQUdsQixnQkFBSSxPQUFPLFNBQVMsWUFBWSxTQUFTLE1BQU07QUFDN0Msd0JBQVU7dUJBQ0QsT0FBTyxTQUFTLGFBQWE7QUFDdEMsb0JBQU0sSUFBSSxVQUFVLDhCQUFnQzs7aUJBRWpEO0FBR0wsZ0JBQUksWUFBWTtBQUNoQixrQkFBTSxXQUFXLE9BQU8sb0JBQW9CLElBQUk7QUFDaEQsdUJBQVdBLFNBQVEsS0FBSyxhQUFhO0FBQ25DLGtCQUFJLFNBQVMsUUFBUUEsS0FBSSxNQUFNLElBQUk7QUFDakMsc0JBQU0sSUFBSyxLQUE0REEsS0FBSTtBQUMzRSxvQkFBSSxNQUFNLFFBQVEsYUFBYUQsU0FBUTtBQUNyQyw4QkFBWTtBQUNaLG1DQUFpQjtBQUNqQiwwQkFBUUMsS0FBSSxJQUFJOzs7O0FBS3RCLGdCQUFJLFdBQVc7QUFDYixrQkFBSSxPQUFPLFNBQVMsWUFBWSxTQUFTLE1BQU07QUFDN0MsMEJBQVU7eUJBQ0QsT0FBTyxTQUFTLGFBQWE7QUFDdEMsc0JBQU0sSUFBSSxVQUFVLDhCQUFnQzs7bUJBRWpEO0FBQ0wsd0JBQVU7OzttQkFHTCxPQUFPLFNBQVMsYUFBYTtBQUN0QyxnQkFBTSxJQUFJLFVBQVUseURBQTZEOztBQUluRixtQkFBV0EsU0FBUSxLQUFLLFlBQVk7QUFDbEMsY0FBSSxPQUFPLE1BQU1BLEtBQUksTUFBTSxhQUFhO0FBQ3RDLGtCQUFNLElBQUksTUFBTSxVQUFVQSxLQUFJLDBCQUEwQjs7O0FBSzVELFlBQUksZ0JBQWdCO0FBQ2xCLHFCQUFXQSxTQUFRLEtBQUssYUFBYTtBQUNuQyxvQkFBUUEsS0FBSSxJQUFJOzs7QUFNcEIsY0FBTSxVQUFVLE1BQU0sS0FBSyxRQUFRLElBQUksT0FBTyxTQUFTLE9BQU87QUFDOUQsY0FBTSxjQUEyQyxDQUFBO0FBQ2pELG1CQUFXLE9BQU8sU0FBUztBQUN6QixjQUFJLE9BQU8sZUFBZSxLQUFLLFNBQVMsR0FBRyxHQUFHO0FBQzVDLGtCQUFNLFNBQVMsUUFBUSxHQUFHO0FBQzFCLGdCQUFJLGtCQUFrQkQsU0FBUTtBQUM1QiwwQkFBWSxHQUFHLElBQUk7bUJBQ2Q7QUFDTCwwQkFBWSxHQUFHLElBQUksSUFBSUEsUUFBTyxPQUFPLE1BQU0sT0FBTyxNQUFNLE9BQU8sSUFBSTs7OztBQUl6RSx1QkFBYztBQUNkLGVBQU87TUFDVDtNQUVBLE1BQU0sVUFBTztBQUNYLGVBQU8sS0FBSyxRQUFRLFFBQU87TUFDN0I7TUFPQSxhQUFhLE9BQ1QsTUFBeUMsTUFBOEIsTUFDdkUsTUFBcUI7QUFDdkIseUJBQWdCO0FBRWhCLFlBQUk7QUFDSixZQUFJLFVBQTBCLENBQUE7QUFFOUIsWUFBSSxPQUFPLFNBQVMsVUFBVTtBQUM1QixpQ0FBdUI7QUFDdkIsY0FBSSxPQUFPLFNBQVMsWUFBWSxTQUFTLE1BQU07QUFDN0Msc0JBQVU7cUJBQ0QsT0FBTyxTQUFTLGFBQWE7QUFDdEMsa0JBQU0sSUFBSSxVQUFVLDhCQUFnQzs7bUJBRTdDLGdCQUFnQixZQUFZO0FBQ3JDLGlDQUF1QjtBQUN2QixjQUFJLE9BQU8sU0FBUyxZQUFZLFNBQVMsTUFBTTtBQUM3QyxzQkFBVTtxQkFDRCxPQUFPLFNBQVMsYUFBYTtBQUN0QyxrQkFBTSxJQUFJLFVBQVUsOEJBQWdDOzttQkFHcEQsZ0JBQWdCLGVBQ2YsT0FBTyxzQkFBc0IsZUFBZSxnQkFBZ0IsbUJBQW9CO0FBQ25GLGdCQUFNLFNBQVM7QUFDZixjQUFJLGFBQWE7QUFDakIsY0FBSSxhQUFhLEtBQUs7QUFDdEIsY0FBSSxPQUFPLFNBQVMsWUFBWSxTQUFTLE1BQU07QUFDN0Msc0JBQVU7cUJBQ0QsT0FBTyxTQUFTLFVBQVU7QUFDbkMseUJBQWE7QUFDYixnQkFBSSxDQUFDLE9BQU8sY0FBYyxVQUFVLEdBQUc7QUFDckMsb0JBQU0sSUFBSSxXQUFXLGtDQUFvQzs7QUFFM0QsZ0JBQUksYUFBYSxLQUFLLGNBQWMsT0FBTyxZQUFZO0FBQ3JELG9CQUFNLElBQUksV0FBVyxvQ0FBb0MsT0FBTyxVQUFVLElBQUk7O0FBRWhGLHlCQUFhLEtBQUssYUFBYTtBQUMvQixnQkFBSSxPQUFPLFNBQVMsVUFBVTtBQUM1QiwyQkFBYTtBQUNiLGtCQUFJLENBQUMsT0FBTyxjQUFjLFVBQVUsR0FBRztBQUNyQyxzQkFBTSxJQUFJLFdBQVcsa0NBQW9DOztBQUUzRCxrQkFBSSxjQUFjLEtBQUssYUFBYSxhQUFhLE9BQU8sWUFBWTtBQUNsRSxzQkFBTSxJQUFJLFdBQVcsb0NBQW9DLE9BQU8sYUFBYSxVQUFVLElBQUk7O0FBRTdGLGtCQUFJLE9BQU8sU0FBUyxZQUFZLFNBQVMsTUFBTTtBQUM3QywwQkFBVTt5QkFDRCxPQUFPLFNBQVMsYUFBYTtBQUN0QyxzQkFBTSxJQUFJLFVBQVUsOEJBQWdDOzt1QkFFN0MsT0FBTyxTQUFTLGFBQWE7QUFDdEMsb0JBQU0sSUFBSSxVQUFVLGdDQUFrQzs7cUJBRS9DLE9BQU8sU0FBUyxhQUFhO0FBQ3RDLGtCQUFNLElBQUksVUFBVSw4QkFBZ0M7O0FBRXRELGlDQUF1QixJQUFJLFdBQVcsUUFBUSxZQUFZLFVBQVU7ZUFDL0Q7QUFDTCxnQkFBTSxJQUFJLFVBQVUscURBQXlEOztBQUkvRSxjQUFNLENBQUNFLFVBQVMsdUJBQXVCLElBQUksTUFBTSxvQ0FBb0MsT0FBTztBQUM1RixjQUFNLFVBQVUsTUFBTUEsU0FBUSw4QkFBOEIsc0JBQXNCLHVCQUF1QjtBQUN6Ryx1QkFBYztBQUNkLGVBQU8sSUFBSSxrQkFBaUIsT0FBTztNQUNyQztNQUVBLGlCQUFjO0FBQ1osYUFBSyxRQUFRLGVBQWM7TUFDN0I7TUFDQSxlQUFZO0FBQ1YsYUFBSyxRQUFRLGFBQVk7TUFDM0I7TUFFQSxJQUFJLGFBQVU7QUFDWixlQUFPLEtBQUssUUFBUTtNQUN0QjtNQUNBLElBQUksY0FBVztBQUNiLGVBQU8sS0FBSyxRQUFRO01BQ3RCOzs7Ozs7QUN4TkYsSUF1ZWFDO0FBdmViOzs7QUFHQTtBQW9lTyxJQUFNQSxvQkFBNEM7Ozs7O0FDdmV6RDs7Ozs7OztBQ0FBOzs7Ozs7O0FDQUE7Ozs7Ozs7QUNBQTs7Ozs7OztBQ0FBLElBZ0JNLGlCQUdPO0FBbkJiOzs7QUFHQTtBQUlBO0FBU0EsSUFBTSxrQkFBMEI7QUFHMUIsSUFBTyxrQkFBUCxNQUFPLGlCQUFlO01BQzFCLFlBQW9CLFNBQWlDLG1CQUE0QixjQUFxQjtBQUNwRyxhQUFLLFVBQVU7QUFDZixhQUFLLG9CQUFvQjtBQUN6QixhQUFLLGVBQWU7TUFDdEI7TUFLQSxJQUFJLHFCQUFrQjtBQUNwQixlQUFPLEtBQUssUUFBUTtNQUN0QjtNQUNBLElBQUksc0JBQW1CO0FBQ3JCLGVBQU8sS0FBSyxRQUFRO01BQ3RCO01BRUEsSUFBSSxpQkFBYztBQUNoQixZQUFJLEtBQUssY0FBYztBQUNyQixpQkFBTyxLQUFLLFFBQVE7ZUFDZjtBQUNMLGdCQUFNLElBQUksTUFBTSxnREFBZ0Q7O01BRXBFO01BQ0EsSUFBSSxrQkFBZTtBQUNqQixZQUFJLEtBQUssY0FBYztBQUNyQixpQkFBTyxLQUFLLFFBQVE7ZUFDZjtBQUNMLGdCQUFNLElBQUksTUFBTSxnREFBZ0Q7O01BRXBFO01BRUEsYUFBYSxPQUFPLGlCQUErQyxnQkFBK0I7QUFFaEcsY0FBTSxZQUErQixnQkFBZ0IsYUFBYTtBQUNsRSxjQUFNLGlCQUFvQyxnQkFBZ0Isa0JBQWtCO0FBQzVFLGNBQU0sVUFBMEIsa0JBQWtCLENBQUE7QUFHbEQsY0FBTSxDQUFDQyxVQUFTLHVCQUF1QixJQUFJLE1BQU0sb0NBQW9DLE9BQU87QUFDNUYsWUFBSUEsU0FBUSw4QkFBOEI7QUFDeEMsZ0JBQU0sVUFBVSxNQUFNQSxTQUFRLDZCQUMxQixnQkFBZ0IsaUJBQWlCLGdCQUFnQixZQUFZLFdBQVcsZ0JBQ3hFLHVCQUF1QjtBQUMzQixpQkFBTyxJQUFJLGlCQUFnQixTQUFTLENBQUMsQ0FBQyxnQkFBZ0IsZ0JBQWdCLENBQUMsQ0FBQyxnQkFBZ0IsU0FBUztlQUM1RjtBQUNMLGdCQUFNLElBQUksTUFBTSxlQUFlOztNQUVuQzs7Ozs7Ozs7Ozs7Ozs7TUFlQSx3QkFDSSxZQUErQixhQUFnQyxPQUFrQixNQUNqRixNQUFpQjtBQUNuQixjQUFNLFVBQTRDLENBQUE7QUFDbEQsWUFBSSxVQUFzQixDQUFBO0FBRTFCLFlBQUksT0FBTyxVQUFVLFlBQVksVUFBVSxRQUFRLGlCQUFpQkMsV0FBVSxNQUFNLFFBQVEsS0FBSyxHQUFHO0FBQ2xHLGdCQUFNLElBQUksVUFDTiwrRkFBaUc7O0FBR3ZHLFlBQUksaUJBQWlCO0FBRXJCLFlBQUksT0FBTyxTQUFTLFVBQVU7QUFDNUIsY0FBSSxTQUFTLE1BQU07QUFDakIsa0JBQU0sSUFBSSxVQUFVLHlDQUF5Qzs7QUFFL0QsY0FBSSxnQkFBZ0JBLFNBQVE7QUFDMUIsa0JBQU0sSUFBSSxVQUFVLDhCQUFnQzs7QUFHdEQsY0FBSSxNQUFNLFFBQVEsSUFBSSxHQUFHO0FBQ3ZCLGdCQUFJLEtBQUssV0FBVyxHQUFHO0FBQ3JCLG9CQUFNLElBQUksVUFBVSxxQ0FBdUM7O0FBRTdELDZCQUFpQjtBQUVqQix1QkFBV0MsU0FBUSxNQUFNO0FBQ3ZCLGtCQUFJLE9BQU9BLFVBQVMsVUFBVTtBQUM1QixzQkFBTSxJQUFJLFVBQVUsZ0RBQWtEOztBQUV4RSxrQkFBSSxZQUFZLFFBQVFBLEtBQUksTUFBTSxJQUFJO0FBQ3BDLHNCQUFNLElBQUksV0FBVywyQ0FBMkNBLEtBQUksR0FBRzs7QUFFekUsc0JBQVFBLEtBQUksSUFBSTs7QUFHbEIsZ0JBQUksT0FBTyxTQUFTLFlBQVksU0FBUyxNQUFNO0FBQzdDLHdCQUFVO3VCQUNELE9BQU8sU0FBUyxhQUFhO0FBQ3RDLG9CQUFNLElBQUksVUFBVSw4QkFBZ0M7O2lCQUVqRDtBQUdMLGdCQUFJLFlBQVk7QUFDaEIsa0JBQU0sV0FBVyxPQUFPLG9CQUFvQixJQUFJO0FBQ2hELHVCQUFXQSxTQUFRLGFBQWE7QUFDOUIsa0JBQUksU0FBUyxRQUFRQSxLQUFJLE1BQU0sSUFBSTtBQUNqQyxzQkFBTSxJQUFLLEtBQW1EQSxLQUFJO0FBQ2xFLG9CQUFJLE1BQU0sUUFBUSxhQUFhRCxTQUFRO0FBQ3JDLDhCQUFZO0FBQ1osbUNBQWlCO0FBQ2pCLDBCQUFRQyxLQUFJLElBQUk7Ozs7QUFLdEIsZ0JBQUksV0FBVztBQUNiLGtCQUFJLE9BQU8sU0FBUyxZQUFZLFNBQVMsTUFBTTtBQUM3QywwQkFBVTt5QkFDRCxPQUFPLFNBQVMsYUFBYTtBQUN0QyxzQkFBTSxJQUFJLFVBQVUsOEJBQWdDOzttQkFFakQ7QUFDTCx3QkFBVTs7O21CQUdMLE9BQU8sU0FBUyxhQUFhO0FBQ3RDLGdCQUFNLElBQUksVUFBVSx5REFBNkQ7O0FBSW5GLG1CQUFXQSxTQUFRLFlBQVk7QUFDN0IsY0FBSSxPQUFPLE1BQU1BLEtBQUksTUFBTSxhQUFhO0FBQ3RDLGtCQUFNLElBQUksTUFBTSxVQUFVQSxLQUFJLDBCQUEwQjs7O0FBSzVELFlBQUksZ0JBQWdCO0FBQ2xCLHFCQUFXQSxTQUFRLGFBQWE7QUFDOUIsb0JBQVFBLEtBQUksSUFBSTs7O0FBSXBCLGVBQU8sQ0FBQyxTQUFTLE9BQU87TUFDMUI7Ozs7Ozs7O01BU0EsdUNBQXVDLFNBQWtDO0FBQ3ZFLGNBQU0sY0FBMkMsQ0FBQTtBQUNqRCxtQkFBVyxPQUFPLFNBQVM7QUFDekIsY0FBSSxPQUFPLGVBQWUsS0FBSyxTQUFTLEdBQUcsR0FBRztBQUM1QyxrQkFBTSxTQUFTLFFBQVEsR0FBRztBQUMxQixnQkFBSSxrQkFBa0JELFNBQVE7QUFDNUIsMEJBQVksR0FBRyxJQUFJO21CQUNkO0FBQ0wsMEJBQVksR0FBRyxJQUFJLElBQUlBLFFBQU8sT0FBTyxNQUFNLE9BQU8sTUFBTSxPQUFPLElBQUk7Ozs7QUFJekUsZUFBTztNQUNUO01BRUEsTUFBTSxnQkFBYTtBQUNqQixjQUFNLEtBQUssUUFBUSxjQUFhO01BQ2xDO01BSUEsTUFBTSxhQUFhLE9BQWtCLE1BQStCLE1BQWlCO0FBQ25GLGNBQU0sQ0FBQyxTQUFTLE9BQU8sSUFDbkIsS0FBSyx3QkFBd0IsS0FBSyxvQkFBb0IsS0FBSyxxQkFBcUIsT0FBTyxNQUFNLElBQUk7QUFDckcsY0FBTSxVQUFVLE1BQU0sS0FBSyxRQUFRLGFBQWEsT0FBTyxTQUFTLE9BQU87QUFDdkUsZUFBTyxLQUFLLHVDQUF1QyxPQUFPO01BQzVEO01BRUEsTUFBTSxpQkFBaUIsU0FBK0M7QUFDcEUsWUFBSSxLQUFLLG1CQUFtQjtBQUMxQixnQkFBTSxLQUFLLFFBQVEsaUJBQWlCLFdBQVcsQ0FBQSxDQUFFO2VBQzVDO0FBQ0wsZ0JBQU0sSUFBSSxNQUFNLG9EQUFvRDs7TUFFeEU7TUFJQSxNQUFNLFlBQVksT0FBa0IsTUFBK0IsTUFBaUI7QUFDbEYsWUFBSSxLQUFLLGNBQWM7QUFDckIsZ0JBQU0sQ0FBQyxTQUFTLE9BQU8sSUFDbkIsS0FBSyx3QkFBd0IsS0FBSyxnQkFBZ0IsS0FBSyxpQkFBaUIsT0FBTyxNQUFNLElBQUk7QUFDN0YsZ0JBQU0sVUFBVSxNQUFNLEtBQUssUUFBUSxZQUFZLE9BQU8sU0FBUyxPQUFPO0FBQ3RFLGlCQUFPLEtBQUssdUNBQXVDLE9BQU87ZUFDckQ7QUFDTCxnQkFBTSxJQUFJLE1BQU0sK0NBQStDOztNQUVuRTtNQUVBLE1BQU0sa0JBQWtCLGdCQUFnQixNQUFJO0FBQzFDLGVBQU8sS0FBSyxRQUFRLGtCQUFrQixhQUFhO01BQ3JEO01BRUEsTUFBTSxxQkFBcUIsT0FBbUIsZ0JBQWdCLE1BQUk7QUFDaEUsY0FBTSxhQUFhLE1BQU0sS0FBSyxrQkFBa0IsYUFBYTtBQUc3RCxZQUFJLE1BQU0sV0FBVyxJQUFJLFlBQVk7QUFDbkMsZ0JBQU0sSUFBSSxNQUNOLHFKQUMwRDs7QUFFaEUsZUFBTyxLQUFLLFFBQVEscUJBQXFCLE9BQU8sYUFBYTtNQUMvRDtNQUVBLE1BQU0sd0JBQXdCLGdCQUFnQixNQUFJO0FBQ2hELGVBQU8sS0FBSyxRQUFRLHdCQUF3QixhQUFhO01BQzNEO01BRUEsTUFBTSxVQUFPO0FBQ1gsZUFBTyxLQUFLLFFBQVEsUUFBTztNQUM3Qjs7Ozs7O0FDelBGLElBbU1hRTtBQW5NYjs7O0FBS0E7QUE4TE8sSUFBTUEsbUJBQTBDOzs7OztBQ25NdkQ7OzBCQUFBQztFQUFBOzs7Z0JBQUFDO0VBQUEsdUJBQUFDO0VBQUEsV0FBQUM7RUFBQTs7Ozs7QUFtQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDNUJBLElBQWE7QUFBYjtBQUFBO0FBQU8sSUFBTSxXQUFXO0FBQUE7QUFBQTs7O0FDK0l4QixTQUFTLElBQ0wsTUFBOEIsTUFBZSxNQUFzQixNQUE4QztBQUNuSCxNQUFJLFNBQVMsUUFBVztBQUV0QixXQUFPLHdCQUF3QixJQUFJO0FBQUEsRUFDckMsV0FBVyxTQUFTLFFBQVc7QUFFN0IsZ0JBQVksTUFBeUIsTUFBTSxDQUFDO0FBQUEsRUFDOUMsV0FBVyxPQUFPLFNBQVMsWUFBWSxTQUFTLFFBQVc7QUFFekQsZ0JBQVksTUFBeUIsTUFBTSxJQUFJO0FBQUEsRUFDakQsV0FBVyxPQUFPLFNBQVMsWUFBWSxTQUFTLFFBQVc7QUFFekQsZ0JBQVksTUFBeUIsTUFBTSxHQUFHLElBQUk7QUFBQSxFQUNwRCxXQUFXLE9BQU8sU0FBUyxZQUFZLE9BQU8sU0FBUyxVQUFVO0FBRS9ELGdCQUFZLE1BQXlCLE1BQU0sTUFBTSxJQUFJO0FBQUEsRUFDdkQsT0FBTztBQUNMLFVBQU0sSUFBSSxVQUFVLGdCQUFnQjtBQUFBLEVBQ3RDO0FBQ0Y7QUFFQSxTQUFTLHdCQUF3QixVQUE0QztBQUMzRSxTQUFPO0FBQUEsSUFDTCxTQUFTLElBQUksUUFBUSxLQUFLLE1BQU0sUUFBUTtBQUFBLElBQ3hDLE1BQU0sSUFBSSxLQUFLLEtBQUssTUFBTSxRQUFRO0FBQUEsSUFDbEMsU0FBUyxJQUFJLFFBQVEsS0FBSyxNQUFNLFFBQVE7QUFBQSxJQUN4QyxPQUFPLElBQUksTUFBTSxLQUFLLE1BQU0sUUFBUTtBQUFBLElBQ3BDLE9BQU8sSUFBSSxNQUFNLEtBQUssTUFBTSxRQUFRO0FBQUEsRUFDdEM7QUFDRjtBQUtBLFNBQVMsWUFBWSxVQUEyQixTQUFpQixRQUFnQixVQUFtQjtBQUNsRyxRQUFNLFNBQVMsa0JBQWtCLFlBQVksRUFBRSxLQUFLLGtCQUFrQixFQUFFO0FBQ3hFLE1BQUksZUFBZSxRQUFRLElBQUksZUFBZSxPQUFPLGVBQWUsR0FBRztBQUNyRTtBQUFBLEVBQ0Y7QUFFQSxNQUFJLE9BQU8sYUFBYTtBQUN0QixjQUFVLElBQUcsb0JBQUksS0FBSyxHQUFFLFlBQVksQ0FBQyxJQUFJLE9BQU87QUFBQSxFQUNsRDtBQUVBLE1BQUksT0FBTyxtQkFBbUI7QUFBQSxFQUU5QjtBQUVBLHNCQUFvQixPQUFPLFFBQVEsRUFBRSxJQUFJLFVBQVUsU0FBUyxRQUFRO0FBQ3RFO0FBak1BLElBeUZNLG9CQUtBLHVCQXdCQSxnQkFRQSxxQkFJQSx1QkFNRixtQkFzSFMsUUFrQlAsT0FtQkEsYUFLTyxVQXNKQTtBQTliYjtBQUFBO0FBQUE7QUF5RkEsSUFBTSxxQkFBTixNQUFtRDtBQUFBLE1BQ2pELElBQUksV0FBNEIsVUFBa0IsV0FBb0I7QUFBQSxNQUV0RTtBQUFBLElBQ0Y7QUFDQSxJQUFNLHdCQUFOLE1BQXNEO0FBQUEsTUFDcEQsSUFBSSxVQUEyQixTQUFpQixVQUFtQjtBQUVqRSxnQkFBUSxJQUFJLEdBQUcsS0FBSyxNQUFNLFFBQVEsQ0FBQyxJQUFJLFdBQVcsYUFBYSxXQUFXLGFBQWEsRUFBRSxHQUFHLE9BQU8sRUFBRTtBQUFBLE1BQ3ZHO0FBQUEsTUFFUSxNQUFNLFVBQTJCO0FBQ3ZDLGdCQUFRLFVBQVU7QUFBQSxVQUNoQixLQUFLO0FBQ0gsbUJBQU87QUFBQSxVQUNULEtBQUs7QUFDSCxtQkFBTztBQUFBLFVBQ1QsS0FBSztBQUNILG1CQUFPO0FBQUEsVUFDVCxLQUFLO0FBQ0gsbUJBQU87QUFBQSxVQUNULEtBQUs7QUFDSCxtQkFBTztBQUFBLFVBQ1Q7QUFDRSxrQkFBTSxJQUFJLE1BQU0seUJBQXlCLFFBQVEsRUFBRTtBQUFBLFFBQ3ZEO0FBQUEsTUFDRjtBQUFBLElBQ0Y7QUFFQSxJQUFNLGlCQUFpQjtBQUFBLE1BQ3JCLFNBQVM7QUFBQSxNQUNULE1BQU07QUFBQSxNQUNOLFNBQVM7QUFBQSxNQUNULE9BQU87QUFBQSxNQUNQLE9BQU87QUFBQSxJQUNUO0FBRUEsSUFBTSxzQkFBK0U7QUFBQSxNQUNuRixDQUFDLE1BQU0sR0FBRyxJQUFJLG1CQUFtQjtBQUFBLE1BQ2pDLENBQUMsU0FBUyxHQUFHLElBQUksc0JBQXNCO0FBQUEsSUFDekM7QUFDQSxJQUFNLHdCQUF3QjtBQUFBLE1BQzVCLFVBQVU7QUFBQSxNQUNWLGlCQUFpQjtBQUFBLE1BQ2pCLGFBQWE7QUFBQSxNQUNiLG1CQUFtQjtBQUFBLElBQ3JCO0FBQ0EsSUFBSSxvQkFDMEQsRUFBQyxDQUFDLEVBQUUsR0FBRyxzQkFBZ0Q7QUEyRHJILE1BQVVDLFNBQVY7QUFHUyxlQUFTLFFBQVEsTUFBYyxNQUFlO0FBQ25ELFFBQUFBLEtBQUksV0FBVyxNQUFNLElBQUk7QUFBQSxNQUMzQjtBQUZPLE1BQUFBLEtBQVM7QUFLVCxlQUFTLEtBQUssTUFBYyxNQUFlO0FBQ2hELFFBQUFBLEtBQUksUUFBUSxNQUFNLElBQUk7QUFBQSxNQUN4QjtBQUZPLE1BQUFBLEtBQVM7QUFLVCxlQUFTLFFBQVEsTUFBYyxNQUFlO0FBQ25ELFFBQUFBLEtBQUksV0FBVyxNQUFNLElBQUk7QUFBQSxNQUMzQjtBQUZPLE1BQUFBLEtBQVM7QUFLVCxlQUFTLE1BQU0sTUFBYyxNQUFlO0FBQ2pELFFBQUFBLEtBQUksU0FBUyxNQUFNLElBQUk7QUFBQSxNQUN6QjtBQUZPLE1BQUFBLEtBQVM7QUFLVCxlQUFTLE1BQU0sTUFBYyxNQUFlO0FBQ2pELFFBQUFBLEtBQUksU0FBUyxNQUFNLElBQUk7QUFBQSxNQUN6QjtBQUZPLE1BQUFBLEtBQVM7QUFJVCxlQUFTLE1BQU0sUUFBOEI7QUFDbEQsNEJBQW9CLENBQUM7QUFDckIsWUFBSSxJQUFJLFVBQVUsQ0FBQyxDQUFDO0FBQUEsTUFDdEI7QUFITyxNQUFBQSxLQUFTO0FBSVQsZUFBUyxJQUFJLFVBQWtCLFFBQTZCO0FBQ2pFLFlBQUksYUFBYSxLQUFLO0FBQ3BCLGdCQUFNLE1BQU07QUFBQSxRQUNkLE9BQU87QUFDTCxnQkFBTSxpQkFBaUIsa0JBQWtCLFFBQVEsS0FBSztBQUN0RCw0QkFBa0IsUUFBUSxJQUFJO0FBQUEsWUFDNUIsVUFBVSxPQUFPLFlBQVksZUFBZTtBQUFBLFlBQzVDLGlCQUFpQixPQUFPLG1CQUFtQixlQUFlO0FBQUEsWUFDMUQsYUFBYyxPQUFPLGdCQUFnQixTQUFhLGVBQWUsY0FBYyxPQUFPO0FBQUEsWUFDdEYsbUJBQW9CLE9BQU8sc0JBQXNCLFNBQWEsZUFBZSxvQkFDZixPQUFPO0FBQUEsVUFDdkU7QUFBQSxRQUNGO0FBQUEsTUFHRjtBQWZPLE1BQUFBLEtBQVM7QUFpQlQsZUFBUyxXQUFXQyxNQUFnQjtBQUN6QyxjQUFNLFNBQXdCLENBQUM7QUFDL0IsWUFBSUEsS0FBSSxVQUFVO0FBQ2hCLGlCQUFPLGtCQUFrQkEsS0FBSTtBQUFBLFFBQy9CO0FBQ0EsWUFBSSxJQUFJLE1BQU07QUFBQSxNQUNoQjtBQU5PLE1BQUFELEtBQVM7QUFBQSxPQWhEUjtBQTBESCxJQUFNLFNBQWlCO0FBa0I5QixJQUFNLFFBQU4sTUFBc0M7QUFBQSxNQUNwQyxZQUNXLFVBQXlDRSxPQUFxQixXQUM3RCxhQUFzRCxPQUEyQixLQUFvQjtBQUR0RztBQUF5QyxvQkFBQUE7QUFBcUI7QUFDN0Q7QUFBc0Q7QUFBMkI7QUFBQSxNQUFxQjtBQUFBLE1BRWxILE1BQU0sTUFBTTtBQUNWLGVBQU8sS0FBSyxZQUFZLElBQUk7QUFBQSxNQUM5QjtBQUFBLE1BRUEsTUFBTSxhQUE4QjtBQUNsQyxZQUFJLEtBQUssUUFBUSxVQUFhLEtBQUssVUFBVSxRQUFXO0FBQ3RELGdCQUFNLElBQUksTUFBTSxzQkFBc0I7QUFBQSxRQUN4QyxPQUFPO0FBQ0wsZUFBSyxJQUFJLFNBQVM7QUFDbEIsaUJBQU8sS0FBSyxJQUFJLHVCQUF1QixLQUFLLEtBQUs7QUFBQSxRQUNuRDtBQUFBLE1BQ0Y7QUFBQSxJQUNGO0FBRUEsSUFBTSxjQUFOLE1BQWtCO0FBQUEsTUFDaEIsWUFDVyxVQUF5Q0EsT0FBcUIsV0FBMEIsU0FBaUI7QUFBekc7QUFBeUMsb0JBQUFBO0FBQXFCO0FBQTBCO0FBQUEsTUFBa0I7QUFBQSxJQUN2SDtBQUVPLElBQU0sV0FBTixNQUFlO0FBQUEsTUFRWixZQUFZLGlCQUEwQixnQkFBeUIsNkJBQXNDO0FBK0g3RyxhQUFRLFdBQVc7QUFTbkIsYUFBUSxnQkFBZ0I7QUF2SXRCLGFBQUssV0FBVztBQUNoQixhQUFLLG1CQUFtQixvQkFBb0IsU0FBWSxNQUFRO0FBQ2hFLGFBQUssa0JBQWtCLG1CQUFtQixTQUFZLEtBQUs7QUFDM0QsYUFBSywrQkFBK0IsZ0NBQWdDLFNBQVksTUFBTztBQUFBLE1BQ3pGO0FBQUEsTUFaQSxPQUFPLE9BQU8sUUFBb0M7QUFDaEQsWUFBSSxXQUFXLFFBQVc7QUFDeEIsaUJBQU8sSUFBSSxLQUFLO0FBQUEsUUFDbEI7QUFDQSxlQUFPLElBQUksS0FBSyxPQUFPLGlCQUFpQixPQUFPLGdCQUFnQixPQUFPLDJCQUEyQjtBQUFBLE1BQ25HO0FBQUE7QUFBQSxNQVVBLFFBQVE7QUFDTixhQUFLLFdBQVc7QUFDaEIsYUFBSyxnQkFBZ0IsQ0FBQztBQUN0QixhQUFLLGFBQWEsSUFBSTtBQUN0QixhQUFLLGdCQUFnQjtBQUFBLE1BQ3ZCO0FBQUE7QUFBQSxNQUdBLE9BQU87QUFDTCxhQUFLLFdBQVc7QUFDaEIsZUFBTyxLQUFLLGdCQUFnQixLQUFLLGNBQWMsUUFBUSxLQUFLLGlCQUFpQjtBQUMzRSxlQUFLLFlBQVksS0FBSyxjQUFjLEtBQUssYUFBYSxDQUFDO0FBQUEsUUFDekQ7QUFBQSxNQUNGO0FBQUEsTUFNQSxNQUFTLFVBQWtDQSxPQUFjLE1BQTRCLEtBQ3JFO0FBQ2QsY0FBTSxRQUFRLEtBQUssV0FBVyxLQUFLLE1BQU0sVUFBVUEsT0FBTSxHQUFHLElBQUk7QUFDaEUsWUFBSSxZQUFZO0FBRWhCLGNBQU0sTUFBTSxLQUFLO0FBR2pCLFlBQUksT0FBTyxPQUFRLElBQW1CLFNBQVMsWUFBWTtBQUN6RCxzQkFBWTtBQUNaLGlCQUFPLElBQUksUUFBVyxDQUFDLFNBQVMsV0FBVztBQUN6QyxZQUFDLElBQ0k7QUFBQSxjQUNHLE9BQU0sVUFBUztBQUNiLG9CQUFJLE9BQU87QUFDVCx3QkFBTSxNQUFNLElBQUk7QUFBQSxnQkFDbEI7QUFDQSx3QkFBUSxLQUFLO0FBQUEsY0FDZjtBQUFBLGNBQ0EsT0FBTSxXQUFVO0FBQ2Qsb0JBQUksT0FBTztBQUNULHdCQUFNLE1BQU0sSUFBSTtBQUFBLGdCQUNsQjtBQUNBLHVCQUFPLE1BQU07QUFBQSxjQUNmO0FBQUEsWUFBQztBQUFBLFVBQ1gsQ0FBQztBQUFBLFFBQ0g7QUFDQSxZQUFJLENBQUMsYUFBYSxPQUFPO0FBQ3ZCLGdCQUFNLFdBQVcsTUFBTSxJQUFJO0FBQzNCLGNBQUksWUFBWSxPQUFPLFNBQVMsU0FBUyxZQUFZO0FBQ25ELG1CQUFPLElBQUksUUFBVyxDQUFDLFNBQVMsV0FBVztBQUN6QyxjQUFDLFNBQVU7QUFBQSxnQkFDUCxNQUFNO0FBQ0osMEJBQVEsR0FBRztBQUFBLGdCQUNiO0FBQUEsZ0JBQ0EsQ0FBQyxXQUFXO0FBQ1YseUJBQU8sTUFBTTtBQUFBLGdCQUNmO0FBQUEsY0FBQztBQUFBLFlBQ1AsQ0FBQztBQUFBLFVBQ0g7QUFBQSxRQUNGO0FBQ0EsZUFBTztBQUFBLE1BQ1Q7QUFBQTtBQUFBLE1BR0EsTUFBTSxVQUFrQ0EsT0FBYyxLQUEyQjtBQUMvRSxZQUFJLENBQUMsS0FBSyxVQUFVO0FBQ2xCLGdCQUFNLElBQUksTUFBTSw2QkFBNkI7QUFBQSxRQUMvQztBQUNBLFlBQUksUUFBUSxRQUFXO0FBQ3JCLGdCQUFNLFlBQVksSUFBSTtBQUN0QixlQUFLLE1BQU0sU0FBUztBQUNwQixpQkFBTyxJQUFJLE1BQU0sVUFBVUEsT0FBTSxXQUFXLE9BQUssS0FBSyxRQUFRLENBQUMsQ0FBQztBQUFBLFFBQ2xFLE9BQU87QUFDTCxnQkFBTSxRQUFvQixJQUFJLFdBQVc7QUFDekMsaUJBQU8sSUFBSSxNQUFNLFVBQVVBLE9BQU0sR0FBRyxPQUFNLE1BQUssS0FBSyxJQUFJLENBQUMsR0FBRyxPQUFPLEdBQUc7QUFBQSxRQUN4RTtBQUFBLE1BQ0Y7QUFBQTtBQUFBLE1BR0EsTUFBYyxJQUFJLE9BQTZCO0FBQzdDLGNBQU0sVUFBa0IsTUFBTSxNQUFNLFdBQVc7QUFDL0MsWUFBSSxLQUFLLGNBQWMsU0FBUyxLQUFLLGtCQUFrQjtBQUNyRCxlQUFLLGNBQWMsS0FBSyxJQUFJLFlBQVksTUFBTSxVQUFVLE1BQU0sTUFBTSxNQUFNLFdBQVcsT0FBTyxDQUFDO0FBQzdGLGVBQUssTUFBTSxPQUFPO0FBQUEsUUFDcEI7QUFBQSxNQUNGO0FBQUEsTUFFUSxRQUFRLE9BQW9CO0FBQ2xDLGNBQU0sVUFBa0IsSUFBSTtBQUM1QixZQUFJLEtBQUssY0FBYyxTQUFTLEtBQUssa0JBQWtCO0FBQ3JELGVBQUssY0FBYyxLQUFLLElBQUksWUFBWSxNQUFNLFVBQVUsTUFBTSxNQUFNLE1BQU0sV0FBVyxPQUFPLENBQUM7QUFDN0YsZUFBSyxNQUFNLE9BQU87QUFBQSxRQUNwQjtBQUFBLE1BQ0Y7QUFBQSxNQUVRLFlBQVksT0FBb0I7QUFDdEMsZUFBTztBQUFBLFVBQ0gsWUFBWSxNQUFNLFFBQVE7QUFBQSxVQUMxQixJQUFJLE1BQU0sVUFBVSxNQUFNLFdBQVcsUUFBUSxDQUFDLENBQUMsZ0JBQWdCLE1BQU0sSUFBSSxRQUFRLE1BQU0sUUFBUSxRQUFRLENBQUMsQ0FBQztBQUFBLFFBQUU7QUFBQSxNQUNqSDtBQUFBLE1BRVEsTUFBTSxhQUFxQjtBQUNqQyxZQUFJLEtBQUssY0FBYyxTQUFTLEtBQUssaUJBQWlCLEtBQUssbUJBQ3ZELGNBQWMsS0FBSyxjQUFjLEtBQUssOEJBQThCO0FBR3RFLHFCQUFXLGtCQUFrQixLQUFLLGVBQWUsS0FBSyxnQkFBZ0Isa0JBQWtCLEtBQUssbUJBQ3hGLEtBQUssZ0JBQWdCLEtBQUssY0FBYyxRQUN4QyxLQUFLLGlCQUFpQjtBQUN6QixpQkFBSyxZQUFZLEtBQUssY0FBYyxLQUFLLGFBQWEsQ0FBQztBQUFBLFVBQ3pEO0FBRUEsZUFBSyxhQUFhLElBQUk7QUFBQSxRQUN4QjtBQUFBLE1BQ0Y7QUFBQSxNQUVBLElBQUksVUFBVTtBQUNaLGVBQU8sS0FBSztBQUFBLE1BQ2Q7QUFBQSxJQVdGO0FBS08sSUFBTSxNQUFPLE9BQU8sZ0JBQWdCLGVBQWUsWUFBWSxNQUFPLE1BQU0sWUFBWSxJQUFJLElBQUksS0FBSztBQUFBO0FBQUE7OztBQ3RhckcsU0FBUyxnQkFBZ0IsTUFBa0IsUUFBMEIsT0FBcUM7QUFDL0csYUFBVyxRQUFRLE9BQU87QUFDeEIsVUFBTSxTQUFTLEtBQUssQ0FBQztBQUNyQixVQUFNLFNBQVMsS0FBSyxDQUFDO0FBQ3JCLFVBQU0sa0JBQWtCLEtBQUssQ0FBQztBQUM5QixVQUFNLFNBQVMsS0FBSyxDQUFDO0FBQ3JCLFVBQU0sU0FBUyxLQUFLLENBQUM7QUFFckIsUUFBSSxLQUFLLFdBQVcsUUFBUTtBQUMxQixpQkFBVyxTQUFTLFFBQVE7QUFFMUIsWUFBSSxNQUFNLFdBQVcsVUFBVyxNQUFNLFdBQVcsYUFBYSxXQUFXLElBQUs7QUFDNUUsY0FBSSxjQUFjLE1BQU0sU0FBUyxlQUFlLEdBQUc7QUFDakQsbUJBQU8sRUFBQyxRQUFRLE9BQU07QUFBQSxVQUN4QjtBQUFBLFFBQ0Y7QUFBQSxNQUNGO0FBQUEsSUFDRjtBQUFBLEVBQ0Y7QUFFQSxRQUFNLElBQUksVUFBVSw0QkFBNEIsS0FBSyxNQUFNLGtCQUN2RCxPQUFPLElBQUksU0FBTyxHQUFHLElBQUksVUFBVSxTQUFTLEtBQUssSUFBSSxPQUFPLEVBQUUsRUFBRSxLQUFLLElBQUksQ0FBQyxFQUFFO0FBQ2xGO0FBRUEsU0FBUyxjQUFjQyxVQUFpQixVQUEyQjtBQUNqRSxNQUFJLFNBQVMsU0FBUyxHQUFHLEdBQUc7QUFFMUIsVUFBTSxhQUFhLE9BQU8sU0FBUyxTQUFTLFVBQVUsR0FBRyxTQUFTLFNBQVMsQ0FBQyxHQUFHLEVBQUU7QUFDakYsV0FBTyxDQUFDLE1BQU0sVUFBVSxLQUFLLGNBQWNBO0FBQUEsRUFDN0MsV0FBVyxTQUFTLE1BQU0sR0FBRyxFQUFFLFdBQVcsR0FBRztBQUUzQyxVQUFNLE9BQU8sU0FBUyxNQUFNLEdBQUc7QUFDL0IsVUFBTSxhQUFhLE9BQU8sU0FBUyxLQUFLLENBQUMsR0FBRyxFQUFFO0FBQzlDLFVBQU0sV0FBVyxPQUFPLFNBQVMsS0FBSyxDQUFDLEdBQUcsRUFBRTtBQUM1QyxXQUFPLENBQUMsTUFBTSxVQUFVLEtBQUssQ0FBQyxNQUFNLFFBQVEsS0FBSyxjQUFjQSxZQUFXQSxZQUFXO0FBQUEsRUFDdkYsT0FBTztBQUVMLFdBQU8sT0FBTyxTQUFTLFVBQVUsRUFBRSxNQUFNQTtBQUFBLEVBQzNDO0FBQ0Y7QUEvREE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7O0FDQUE7QUFBQSxrREFBQUMsVUFBQTtBQUFBO0FBQ0EsSUFBQUEsU0FBUSxhQUFhO0FBQ3JCLFFBQUlDO0FBQUE7QUFBQSxNQUFzQixXQUFZO0FBQ2xDLGlCQUFTQSxNQUFLLE1BQU07QUFDaEIsY0FBSSxDQUFDLE1BQU07QUFDUCxrQkFBTSxJQUFJLFVBQVUseUNBQXlDO0FBQUEsVUFDakU7QUFDQSxlQUFLLFFBQVFBLE1BQUs7QUFDbEIsY0FBSSxRQUFRQSxNQUFLLE9BQU8sSUFBSSxHQUFHO0FBQzNCLGlCQUFLLFFBQVE7QUFBQSxVQUNqQjtBQUFBLFFBQ0o7QUFDQSxRQUFBQSxNQUFLLFNBQVMsU0FBVSxNQUFNO0FBQzFCLGNBQUksUUFBUSxLQUFLLFNBQVM7QUFDMUIsaUJBQU8sU0FBUyxnQkFBZ0JBLFNBQVFBLE1BQUssVUFBVSxLQUFLLEtBQUs7QUFBQSxRQUNyRTtBQUNBLFFBQUFBLE1BQUssU0FBUyxXQUFZO0FBQ3RCLGlCQUFPLElBQUlBLE1BQUssQ0FBQ0EsTUFBSyxJQUFJLENBQUMsR0FBR0EsTUFBSyxJQUFJLENBQUMsR0FBR0EsTUFBSyxJQUFJLENBQUMsR0FBR0EsTUFBSyxJQUFJLENBQUMsR0FBR0EsTUFBSyxJQUFJLENBQUMsQ0FBQyxFQUFFLEtBQUssR0FBRyxDQUFDO0FBQUEsUUFDL0Y7QUFDQSxRQUFBQSxNQUFLLGNBQWMsV0FBWTtBQUMzQixpQkFBTyxJQUFJQSxNQUFLLFdBQVc7QUFBQSxRQUMvQjtBQUNBLFFBQUFBLE1BQUssUUFBUSxTQUFVLE1BQU07QUFDekIsaUJBQU8sSUFBSUEsTUFBSyxJQUFJO0FBQUEsUUFDeEI7QUFDQSxRQUFBQSxNQUFLLE1BQU0sV0FBWTtBQUNuQixpQkFBTyxDQUFDQSxNQUFLLElBQUksQ0FBQyxHQUFHQSxNQUFLLElBQUksQ0FBQyxHQUFHQSxNQUFLLElBQUksQ0FBQyxHQUFHQSxNQUFLLElBQUksQ0FBQyxHQUFHQSxNQUFLLElBQUksQ0FBQyxDQUFDLEVBQUUsS0FBSyxHQUFHO0FBQUEsUUFDckY7QUFDQSxRQUFBQSxNQUFLLE1BQU0sU0FBVSxPQUFPO0FBQ3hCLGNBQUksTUFBTTtBQUNWLG1CQUFTLElBQUksR0FBRyxJQUFJLE9BQU8sS0FBSztBQUU1QixxQkFBVSxJQUFJLEtBQUssT0FBTyxLQUFLLFFBQVcsR0FBRyxTQUFTLEVBQUUsRUFBRSxVQUFVLENBQUM7QUFBQSxVQUN6RTtBQUNBLGlCQUFPO0FBQUEsUUFDWDtBQUNBLFFBQUFBLE1BQUssVUFBVSxTQUFTLFNBQVUsT0FBTztBQUdyQyxpQkFBT0EsTUFBSyxPQUFPLEtBQUssS0FBSyxLQUFLLFVBQVUsTUFBTSxTQUFTO0FBQUEsUUFDL0Q7QUFDQSxRQUFBQSxNQUFLLFVBQVUsVUFBVSxXQUFZO0FBQ2pDLGlCQUFPLEtBQUssVUFBVUEsTUFBSztBQUFBLFFBQy9CO0FBQ0EsUUFBQUEsTUFBSyxVQUFVLFdBQVcsV0FBWTtBQUNsQyxpQkFBTyxLQUFLO0FBQUEsUUFDaEI7QUFDQSxRQUFBQSxNQUFLLFVBQVUsU0FBUyxXQUFZO0FBQ2hDLGlCQUFPO0FBQUEsWUFDSCxPQUFPLEtBQUs7QUFBQSxVQUNoQjtBQUFBLFFBQ0o7QUFDQSxRQUFBQSxNQUFLLFlBQVksSUFBSSxPQUFPLGtFQUFrRSxHQUFHO0FBQ2pHLFFBQUFBLE1BQUssUUFBUTtBQUNiLGVBQU9BO0FBQUEsTUFDWCxFQUFFO0FBQUE7QUFDRixJQUFBRCxTQUFRLE9BQU9DO0FBQUE7QUFBQTs7O0FDaEJmLFNBQVMsS0FBSyxLQUFLLE1BQU0sVUFBVTtBQU1qQyxPQUFLLE1BQU0sTUFBTTtBQU1qQixPQUFLLE9BQU8sT0FBTztBQU1uQixPQUFLLFdBQVcsQ0FBQyxDQUFDO0FBQ3BCO0FBbUNBLFNBQVMsT0FBTyxLQUFLO0FBQ25CLFVBQVEsT0FBTyxJQUFJLFlBQVksT0FBTztBQUN4QztBQVFBLFNBQVMsTUFBTSxPQUFPO0FBQ3BCLE1BQUksSUFBSSxLQUFLLE1BQU0sUUFBUSxDQUFDLEtBQUs7QUFDakMsU0FBTyxRQUFRLEtBQUssSUFBSTtBQUMxQjtBQThCQSxTQUFTLFFBQVEsT0FBTyxVQUFVO0FBQ2hDLE1BQUksS0FBSyxXQUFXQztBQUNwQixNQUFJLFVBQVU7QUFDWixlQUFXO0FBQ1gsUUFBSUEsU0FBUyxLQUFLLFNBQVMsUUFBUSxLQUFNO0FBQ3ZDLGtCQUFZLFdBQVcsS0FBSztBQUM1QixVQUFJO0FBQ0YsZUFBTztBQUFBLElBQ1g7QUFDQSxVQUFNLFNBQVMsT0FBTyxHQUFHLElBQUk7QUFDN0IsUUFBSUE7QUFDRixpQkFBVyxLQUFLLElBQUk7QUFDdEIsV0FBTztBQUFBLEVBQ1QsT0FBTztBQUNMLGFBQVM7QUFDVCxRQUFJQSxTQUFTLFFBQVEsU0FBUyxRQUFRLEtBQU07QUFDMUMsa0JBQVksVUFBVSxLQUFLO0FBQzNCLFVBQUk7QUFDRixlQUFPO0FBQUEsSUFDWDtBQUNBLFVBQU0sU0FBUyxPQUFPLFFBQVEsSUFBSSxLQUFLLEdBQUcsS0FBSztBQUMvQyxRQUFJQTtBQUNGLGdCQUFVLEtBQUssSUFBSTtBQUNyQixXQUFPO0FBQUEsRUFDVDtBQUNGO0FBaUJBLFNBQVMsV0FBVyxPQUFPLFVBQVU7QUFDbkMsTUFBSSxNQUFNLEtBQUs7QUFDYixXQUFPLFdBQVcsUUFBUTtBQUM1QixNQUFJLFVBQVU7QUFDWixRQUFJLFFBQVE7QUFDVixhQUFPO0FBQ1QsUUFBSSxTQUFTO0FBQ1gsYUFBTztBQUFBLEVBQ1gsT0FBTztBQUNMLFFBQUksU0FBUyxDQUFDO0FBQ1osYUFBTztBQUNULFFBQUksUUFBUSxLQUFLO0FBQ2YsYUFBTztBQUFBLEVBQ1g7QUFDQSxNQUFJLFFBQVE7QUFDVixXQUFPLFdBQVcsQ0FBQyxPQUFPLFFBQVEsRUFBRSxJQUFJO0FBQzFDLFNBQU8sU0FBVSxRQUFRLGlCQUFrQixHQUFJLFFBQVEsaUJBQWtCLEdBQUcsUUFBUTtBQUN0RjtBQWtCQSxTQUFTLFNBQVMsU0FBUyxVQUFVLFVBQVU7QUFDN0MsU0FBTyxJQUFJLEtBQUssU0FBUyxVQUFVLFFBQVE7QUFDN0M7QUE2QkEsU0FBUyxXQUFXLEtBQUssVUFBVSxPQUFPO0FBQ3hDLE1BQUksSUFBSSxXQUFXO0FBQ2pCLFVBQU0sTUFBTSxjQUFjO0FBQzVCLE1BQUksT0FBTyxhQUFhLFVBQVU7QUFFaEMsWUFBUTtBQUNSLGVBQVc7QUFBQSxFQUNiLE9BQU87QUFDTCxlQUFXLENBQUMsQ0FBQztBQUFBLEVBQ2Y7QUFDQSxNQUFJLFFBQVEsU0FBUyxRQUFRLGNBQWMsUUFBUSxlQUFlLFFBQVE7QUFDeEUsV0FBTyxXQUFXLFFBQVE7QUFDNUIsVUFBUSxTQUFTO0FBQ2pCLE1BQUksUUFBUSxLQUFLLEtBQUs7QUFDcEIsVUFBTSxXQUFXLE9BQU87QUFFMUIsTUFBSTtBQUNKLE9BQUssSUFBSSxJQUFJLFFBQVEsR0FBRyxLQUFLO0FBQzNCLFVBQU0sTUFBTSxpQkFBaUI7QUFBQSxXQUN0QixNQUFNLEdBQUc7QUFDaEIsV0FBTyxXQUFXLElBQUksVUFBVSxDQUFDLEdBQUcsVUFBVSxLQUFLLEVBQUUsSUFBSTtBQUFBLEVBQzNEO0FBSUEsTUFBSSxlQUFlLFdBQVcsUUFBUSxPQUFPLENBQUMsQ0FBQztBQUUvQyxNQUFJLFNBQVM7QUFDYixXQUFTLElBQUksR0FBRyxJQUFJLElBQUksUUFBUSxLQUFLLEdBQUc7QUFDdEMsUUFBSSxPQUFPLEtBQUssSUFBSSxHQUFHLElBQUksU0FBUyxDQUFDLEdBQ25DLFFBQVEsU0FBUyxJQUFJLFVBQVUsR0FBRyxJQUFJLElBQUksR0FBRyxLQUFLO0FBQ3BELFFBQUksT0FBTyxHQUFHO0FBQ1osVUFBSSxRQUFRLFdBQVcsUUFBUSxPQUFPLElBQUksQ0FBQztBQUMzQyxlQUFTLE9BQU8sSUFBSSxLQUFLLEVBQUUsSUFBSSxXQUFXLEtBQUssQ0FBQztBQUFBLElBQ2xELE9BQU87QUFDTCxlQUFTLE9BQU8sSUFBSSxZQUFZO0FBQ2hDLGVBQVMsT0FBTyxJQUFJLFdBQVcsS0FBSyxDQUFDO0FBQUEsSUFDdkM7QUFBQSxFQUNGO0FBQ0EsU0FBTyxXQUFXO0FBQ2xCLFNBQU87QUFDVDtBQW1CQSxTQUFTLFVBQVUsS0FBSyxVQUFVO0FBQ2hDLE1BQUksT0FBTyxRQUFRO0FBQ2pCLFdBQU8sV0FBVyxLQUFLLFFBQVE7QUFDakMsTUFBSSxPQUFPLFFBQVE7QUFDakIsV0FBTyxXQUFXLEtBQUssUUFBUTtBQUVqQyxTQUFPLFNBQVMsSUFBSSxLQUFLLElBQUksTUFBTSxPQUFPLGFBQWEsWUFBWSxXQUFXLElBQUksUUFBUTtBQUM1RjtBQXhUQSxJQXFCSSxNQXFHQSxXQU9BLFlBMkdBLFNBK0ZBLGdCQU9BLGdCQU9BLGdCQU9BLGdCQU9BLGdCQU9BLFlBTUEsTUFZQSxPQVlBLEtBWUEsTUFZQSxTQVlBLFdBWUEsb0JBWUEsV0FZQSxlQXMrQkc7QUExN0NQO0FBQUE7QUFxQkEsSUFBSSxPQUFPO0FBQ1gsUUFBSTtBQUNGLGFBQU8sSUFBSSxZQUFZLFNBQVMsSUFBSSxZQUFZLE9BQU8sSUFBSSxXQUFXO0FBQUEsUUFDcEU7QUFBQSxRQUFHO0FBQUEsUUFBSTtBQUFBLFFBQUs7QUFBQSxRQUFLO0FBQUEsUUFBRztBQUFBLFFBQUc7QUFBQSxRQUFHO0FBQUEsUUFBRztBQUFBLFFBQUc7QUFBQSxRQUFJO0FBQUEsUUFBRztBQUFBLFFBQUk7QUFBQSxRQUFHO0FBQUEsUUFBRztBQUFBLFFBQUs7QUFBQSxRQUFJO0FBQUEsUUFBRztBQUFBLFFBQUs7QUFBQSxRQUFLO0FBQUEsUUFBSztBQUFBLFFBQUs7QUFBQSxRQUFHO0FBQUEsUUFBSztBQUFBLFFBQUc7QUFBQSxRQUFHO0FBQUEsUUFBRztBQUFBLFFBQUc7QUFBQSxRQUFHO0FBQUEsUUFBRztBQUFBLFFBQUc7QUFBQSxRQUFHO0FBQUEsUUFBRztBQUFBLFFBQUc7QUFBQSxRQUFHO0FBQUEsUUFBRztBQUFBLFFBQUs7QUFBQSxRQUFHO0FBQUEsUUFBSTtBQUFBLFFBQUc7QUFBQSxRQUFJO0FBQUEsUUFBRztBQUFBLFFBQUk7QUFBQSxRQUFHO0FBQUEsUUFBRztBQUFBLFFBQUs7QUFBQSxRQUFLO0FBQUEsUUFBSztBQUFBLFFBQUc7QUFBQSxRQUFHO0FBQUEsUUFBRztBQUFBLFFBQUs7QUFBQSxRQUFLO0FBQUEsUUFBSztBQUFBLFFBQUk7QUFBQSxRQUFLO0FBQUEsUUFBRztBQUFBLFFBQUc7QUFBQSxRQUFHO0FBQUEsUUFBSztBQUFBLFFBQUs7QUFBQSxRQUFLO0FBQUEsUUFBSTtBQUFBLFFBQUs7QUFBQSxRQUFHO0FBQUEsUUFBRztBQUFBLFFBQUc7QUFBQSxRQUFLO0FBQUEsUUFBSztBQUFBLFFBQUs7QUFBQSxRQUFJO0FBQUEsUUFBSztBQUFBLFFBQUc7QUFBQSxRQUFHO0FBQUEsUUFBRztBQUFBLFFBQUs7QUFBQSxRQUFLO0FBQUEsUUFBSztBQUFBLFFBQUk7QUFBQSxRQUFLO0FBQUEsUUFBRztBQUFBLFFBQUc7QUFBQSxRQUFHO0FBQUEsUUFBSztBQUFBLFFBQUs7QUFBQSxRQUFLO0FBQUEsUUFBSTtBQUFBLFFBQUs7QUFBQSxRQUFLO0FBQUEsUUFBSztBQUFBLFFBQUs7QUFBQSxRQUFHO0FBQUEsUUFBRztBQUFBLFFBQUk7QUFBQSxRQUFLO0FBQUEsUUFBRztBQUFBLFFBQUc7QUFBQSxRQUFHO0FBQUEsUUFBRztBQUFBLFFBQUk7QUFBQSxRQUFHO0FBQUEsUUFBSTtBQUFBLFFBQUk7QUFBQSxRQUFHO0FBQUEsUUFBRztBQUFBLFFBQUs7QUFBQSxRQUFJO0FBQUEsUUFBRztBQUFBLFFBQUs7QUFBQSxRQUFJO0FBQUEsUUFBRztBQUFBLFFBQUs7QUFBQSxRQUFJO0FBQUEsUUFBSTtBQUFBLFFBQUs7QUFBQSxRQUFLO0FBQUEsUUFBSTtBQUFBLFFBQUc7QUFBQSxRQUFLO0FBQUEsUUFBSTtBQUFBLFFBQUc7QUFBQSxRQUFLO0FBQUEsUUFBSTtBQUFBLFFBQUk7QUFBQSxRQUFLO0FBQUEsUUFBSztBQUFBLFFBQUs7QUFBQSxRQUFJO0FBQUEsUUFBRztBQUFBLFFBQUk7QUFBQSxRQUFJO0FBQUEsUUFBSztBQUFBLFFBQUs7QUFBQSxRQUFJO0FBQUEsUUFBRztBQUFBLFFBQUk7QUFBQSxRQUFHO0FBQUEsUUFBSztBQUFBLFFBQUk7QUFBQSxRQUFJO0FBQUEsUUFBRztBQUFBLFFBQUc7QUFBQSxRQUFLO0FBQUEsUUFBSTtBQUFBLFFBQUc7QUFBQSxRQUFLO0FBQUEsUUFBSTtBQUFBLFFBQUc7QUFBQSxRQUFLO0FBQUEsUUFBSTtBQUFBLFFBQUk7QUFBQSxRQUFLO0FBQUEsUUFBSztBQUFBLFFBQUk7QUFBQSxRQUFHO0FBQUEsUUFBSztBQUFBLFFBQUk7QUFBQSxRQUFHO0FBQUEsUUFBSztBQUFBLFFBQUk7QUFBQSxRQUFJO0FBQUEsUUFBSztBQUFBLFFBQUs7QUFBQSxRQUFLO0FBQUEsUUFBSTtBQUFBLFFBQUc7QUFBQSxRQUFJO0FBQUEsUUFBSTtBQUFBLFFBQUs7QUFBQSxRQUFLO0FBQUEsUUFBSTtBQUFBLFFBQUc7QUFBQSxRQUFJO0FBQUEsUUFBRztBQUFBLFFBQUs7QUFBQSxRQUFJO0FBQUEsUUFBSTtBQUFBLFFBQUc7QUFBQSxRQUFHO0FBQUEsUUFBSztBQUFBLFFBQUk7QUFBQSxRQUFHO0FBQUEsUUFBSztBQUFBLFFBQUk7QUFBQSxRQUFHO0FBQUEsUUFBSztBQUFBLFFBQUk7QUFBQSxRQUFJO0FBQUEsUUFBSztBQUFBLFFBQUs7QUFBQSxRQUFJO0FBQUEsUUFBRztBQUFBLFFBQUs7QUFBQSxRQUFJO0FBQUEsUUFBRztBQUFBLFFBQUs7QUFBQSxRQUFJO0FBQUEsUUFBSTtBQUFBLFFBQUs7QUFBQSxRQUFLO0FBQUEsUUFBSztBQUFBLFFBQUk7QUFBQSxRQUFHO0FBQUEsUUFBSTtBQUFBLFFBQUk7QUFBQSxRQUFLO0FBQUEsUUFBSztBQUFBLFFBQUk7QUFBQSxRQUFHO0FBQUEsUUFBSTtBQUFBLFFBQUc7QUFBQSxRQUFLO0FBQUEsUUFBSTtBQUFBLFFBQUk7QUFBQSxRQUFHO0FBQUEsUUFBRztBQUFBLFFBQUs7QUFBQSxRQUFJO0FBQUEsUUFBRztBQUFBLFFBQUs7QUFBQSxRQUFJO0FBQUEsUUFBRztBQUFBLFFBQUs7QUFBQSxRQUFJO0FBQUEsUUFBSTtBQUFBLFFBQUs7QUFBQSxRQUFLO0FBQUEsUUFBSTtBQUFBLFFBQUc7QUFBQSxRQUFLO0FBQUEsUUFBSTtBQUFBLFFBQUc7QUFBQSxRQUFLO0FBQUEsUUFBSTtBQUFBLFFBQUk7QUFBQSxRQUFLO0FBQUEsUUFBSztBQUFBLFFBQUs7QUFBQSxRQUFJO0FBQUEsUUFBRztBQUFBLFFBQUk7QUFBQSxRQUFJO0FBQUEsUUFBSztBQUFBLFFBQUs7QUFBQSxRQUFJO0FBQUEsUUFBRztBQUFBLFFBQUk7QUFBQSxRQUFHO0FBQUEsUUFBSztBQUFBLFFBQUk7QUFBQSxRQUFJO0FBQUEsUUFBRztBQUFBLFFBQUc7QUFBQSxRQUFLO0FBQUEsUUFBSTtBQUFBLFFBQUc7QUFBQSxRQUFLO0FBQUEsUUFBSTtBQUFBLFFBQUc7QUFBQSxRQUFLO0FBQUEsUUFBSTtBQUFBLFFBQUk7QUFBQSxRQUFLO0FBQUEsUUFBSztBQUFBLFFBQUk7QUFBQSxRQUFHO0FBQUEsUUFBSztBQUFBLFFBQUk7QUFBQSxRQUFHO0FBQUEsUUFBSztBQUFBLFFBQUk7QUFBQSxRQUFJO0FBQUEsUUFBSztBQUFBLFFBQUs7QUFBQSxRQUFLO0FBQUEsUUFBSTtBQUFBLFFBQUc7QUFBQSxRQUFJO0FBQUEsUUFBSTtBQUFBLFFBQUs7QUFBQSxRQUFLO0FBQUEsUUFBSTtBQUFBLFFBQUc7QUFBQSxRQUFJO0FBQUEsUUFBRztBQUFBLFFBQUs7QUFBQSxNQUM1bkMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxD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QUFRLFVBQVUsWUFBWTtBQUFBLFFBQ3RDLE9BQU87QUFDTCxnQkFBTSxRQUFRLFVBQVUsWUFBWTtBQUFBLFFBQ3RDO0FBRUEsZUFBTyxJQUFJLHFCQUFxQixPQUFPO0FBQUEsTUFDekM7QUFBQSxJQUNGO0FBRU8sSUFBTSxnQkFBZ0IsSUFBSSxjQUFjO0FBQUE7QUFBQTs7O0FDeEIvQztBQUNBO0FBR0E7OztBQ05PLElBQU1DLFdBQVU7OztBREl2QixJQUFPLGNBQVE7QUFLZixJQUFJLE1BQTJCO0FBQzdCLFFBQU1DLGlCQUFnQiw4REFBNEI7QUFDbEQsa0JBQWdCLFNBQVNBLGdCQUFlLEdBQUc7QUFDN0M7QUFFQSxJQUFJLE9BQTBCO0FBQzVCLFFBQU0sY0FBYyxPQUE4QixLQUFvQyxjQUNwQyxLQUFtQztBQUNyRixNQUFJLE9BQTRCO0FBQzlCLG9CQUFnQixVQUFVLGFBQWEsQ0FBQztBQUN4QyxvQkFBZ0IsU0FBUyxhQUFhLENBQUM7QUFBQSxFQUN6QztBQUNBLGtCQUFnQixPQUFPLGFBQWEsRUFBRTtBQUN0QyxrQkFBZ0IsUUFBUSxhQUFhLEVBQUU7QUFDekM7QUFFQSxPQUFPLGVBQWVDLEtBQUksVUFBVSxPQUFPLEVBQUMsT0FBT0MsVUFBUyxZQUFZLEtBQUksQ0FBQzsiLAogICJuYW1lcyI6IFsibmFtZSIsICJiYWNrZW5kIiwgImkiLCAiZW52IiwgImNyZWF0ZUNhbnZhcyIsICJUZW5zb3IiLCAiVGVuc29yIiwgIm5hbWUiLCAiYmFja2VuZCIsICJJbmZlcmVuY2VTZXNzaW9uIiwgImJhY2tlbmQiLCAiVGVuc29yIiwgIm5hbWUiLCAiVHJhaW5pbmdTZXNzaW9uIiwgIkluZmVyZW5jZVNlc3Npb24iLCAiVGVuc29yIiwgIlRyYWluaW5nU2Vzc2lvbiIsICJlbnYiLCAibG9nIiwgImVudiIsICJuYW1lIiwgInZlcnNpb24iLCAiZXhwb3J0cyIsICJHdWlkIiwgImNhY2hlIiwgImRpdiIsICJsb2cyIiwgIm9ubnhydW50aW1lIiwgImV4cGVyaW1lbnRhbCIsICJmYnMiLCAiQXR0cmlidXRlVHlwZSIsICJEaW1lbnNpb25WYWx1ZVR5cGUiLCAiVGVuc29yRGF0YVR5cGUiLCAiTm9kZVR5cGUiLCAiVHlwZUluZm9WYWx1ZSIsICJOb2RlIiwgInZlcnNpb24iLCAiVGVuc29yIiwgIkF0dHJpYnV0ZSIsICJHcmFwaCIsICJNb2RlbCIsICJJbmZlcmVuY2VTZXNzaW9uIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgInBhcmFtcyIsICJvZmZzZXQiLCAiZXhwb3J0cyIsICJpIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgImV4cG9ydHMiLCAiZXhwb3J0cyIsICJtb2R1bGUiLCAic2xpY2UiLCAic2l6ZSIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJmcm9tTnVtYmVyIiwgInRvTnVtYmVyIiwgImV4cG9ydHMiLCAiQnVmZmVyIiwgIm5hbWUiLCAiaSIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJjcmVhdGUiLCAiZXhwb3J0cyIsICJtb2R1bGUiLCAiZXhwb3J0cyIsICJtb2R1bGUiLCAiY3JlYXRlX2FycmF5IiwgImNyZWF0ZSIsICJidWZmZXIiLCAiZXhwb3J0cyIsICJtb2R1bGUiLCAiZXhwb3J0cyIsICJtb2R1bGUiLCAic2VsZiIsICJlcnIiLCAiZXhwb3J0cyIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJleHBvcnRzIiwgInJlcXVpcmVfbWluaW1hbCIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJvbm54IiwgIlRlbnNvciIsICJNYXAiLCAiaW5pdF90ZW5zb3IiLCAiVGVuc29yIiwgInNoYXBlIiwgInNwbGl0IiwgImltcG9ydF9vbm54IiwgIlRlbnNvciIsICJpbml0X3RlbnNvciIsICJjYWNoZSIsICJ2ZXJzaW9uIiwgIm5hbWUiLCAic2hhcGUiLCAic2hhcGUiLCAic2hhcGUiLCAiaW5pdF90ZW5zb3IiLCAic2hhcGUiLCAiVGVuc29yIiwgIm5hbWUiLCAibmFtZSIsICJuYW1lIiwgImFkZCIsICJhbmQiLCAib3IiLCAieG9yIiwgImdsc2wiLCAic2hhZGVyU291cmNlIiwgInZhbGlkYXRlSW5wdXRzIiwgInNoaWZ0IiwgInZhbGlkYXRlSW5wdXRzIiwgIm5hbWUiLCAibG9nIiwgIm5vdCIsICJ2YWxpZGF0ZUlucHV0cyIsICJ2YWxpZGF0ZUlucHV0cyIsICJ2YWxpZGF0ZUlucHV0cyIsICJ2YWxpZGF0ZUlucHV0cyIsICJuYW1lIiwgInZhbGlkYXRlSW5wdXRzIiwgInZhbGlkYXRlSW5wdXRzIiwgInZhbGlkYXRlSW5wdXRzIiwgInZhbGlkYXRlSW5wdXRzIiwgInZhbGlkYXRlSW5wdXRzIiwgInZhbGlkYXRlSW5wdXRzIiwgInZhbGlkYXRlSW5wdXRzIiwgInNoYXBlIiwgInZhbGlkYXRlSW5wdXRzIiwgInN1bSIsICJ2YWxpZGF0ZUlucHV0cyIsICJuYW1lIiwgImlucHV0cyIsICJ2YWxpZGF0ZUlucHV0cyIsICJkaW0iLCAidmFsaWRhdGVJbnB1dHMiLCAidmFsaWRhdGVJbnB1dHMiLCAiaW5pdF90ZW5zb3IiLCAiVGVuc29yIiwgInZhbGlkYXRlSW5wdXRzIiwgInZhbGlkYXRlSW5wdXRzIiwgInZhbGlkYXRlSW5wdXRzIiwgInNwbGl0IiwgInZhbGlkYXRlSW5wdXRzIiwgInZhbGlkYXRlSW5wdXRzIiwgInZhbGlkYXRlSW5wdXRzIiwgInZhbGlkYXRlSW5wdXRzIiwgInZhbGlkYXRlSW5wdXRzVjEzIiwgImFkZCIsICJhbmQiLCAibG9nIiwgIm5vdCIsICJvciIsICJ4b3IiLCAibmFtZSIsICJzaGFwZSIsICJzaGFwZSIsICJuYW1lIiwgInNvdXJjZSIsICJwYWNrZWRTYW1wbGVyIiwgInRleE51bVIiLCAidGV4TnVtQyIsICJ0cmFuc3Bvc2UiLCAibmFtZSIsICJzaGFwZSIsICJpIiwgIm5hbWUiLCAibmFtZSIsICJlbnYiLCAibmFtZSIsICJ0ZXh0dXJlIiwgImJhY2tlbmQiLCAidmVyc2lvbiIsICJlbnYiLCAiZW52IiwgImNhY2hlIiwgImJhY2tlbmQiLCAiaW5pdF9iYWNrZW5kIiwgIm91dHB1dCIsICJpbXBvcnRfb25ueCIsICJvcnRGYnMiLCAiaW5pdF90ZW5zb3IiLCAiVGVuc29yIiwgInZhbHVlIiwgImltcG9ydF9vbm54IiwgIm9ydEZicyIsICJpbml0X3RlbnNvciIsICJuYW1lIiwgIlRlbnNvciIsICJzaGFwZSIsICJub2RlSW5kZXgiLCAiaW1wb3J0X29ubngiLCAib3J0RmJzIiwgImluaXRfYmFja2VuZCIsICJiYWNrZW5kIiwgImluaXRfdGVuc29yIiwgIm5hbWUiLCAiVGVuc29yIiwgInZlcnNpb24iLCAib25ueGpzQmFja2VuZCIsICJlbnYiLCAidmVyc2lvbiJdCn0K
